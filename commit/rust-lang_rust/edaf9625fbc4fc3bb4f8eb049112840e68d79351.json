{"sha": "edaf9625fbc4fc3bb4f8eb049112840e68d79351", "node_id": "C_kwDOAAsO6NoAKGVkYWY5NjI1ZmJjNGZjM2JiNGY4ZWIwNDkxMTI4NDBlNjhkNzkzNTE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-01-26T15:10:01Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-02-02T15:40:11Z"}, "message": "Clean up leftovers from eager hidden type merging", "tree": {"sha": "647bb6e3da277557579f0c8f6c2859b8fcb1eb90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/647bb6e3da277557579f0c8f6c2859b8fcb1eb90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edaf9625fbc4fc3bb4f8eb049112840e68d79351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edaf9625fbc4fc3bb4f8eb049112840e68d79351", "html_url": "https://github.com/rust-lang/rust/commit/edaf9625fbc4fc3bb4f8eb049112840e68d79351", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edaf9625fbc4fc3bb4f8eb049112840e68d79351/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38f50d1ecb2adf9f9e6305b22cdee96bd65f9cbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/38f50d1ecb2adf9f9e6305b22cdee96bd65f9cbe", "html_url": "https://github.com/rust-lang/rust/commit/38f50d1ecb2adf9f9e6305b22cdee96bd65f9cbe"}], "stats": {"total": 143, "additions": 34, "deletions": 109}, "files": [{"sha": "6559ded5816d2b84b42dcd169096779b14465d86", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=edaf9625fbc4fc3bb4f8eb049112840e68d79351", "patch": "@@ -18,7 +18,9 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferCtxt, LateBoundRegionConversionTime, NllRegionVariableOrigin};\n+use rustc_infer::infer::{\n+    InferCtxt, InferOk, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n+};\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::AssertKind;\n@@ -194,39 +196,32 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             let opaque_type_values = opaque_type_values\n                 .into_iter()\n                 .filter_map(|(opaque_type_key, decl)| {\n-                    let def_id = body.source.def_id().expect_local();\n-                    let body_id = cx.tcx().hir().local_def_id_to_hir_id(def_id);\n-                    let cause = ObligationCause::misc(body.span, body_id);\n-                    let hidden = cx\n-                        .fully_perform_op(\n-                            Locations::All(body.span),\n-                            ConstraintCategory::OpaqueType,\n-                            CustomTypeOp::new(\n-                                |infcx| {\n-                                    let res = decl\n-                                        .hidden_type(infcx, &cause, param_env)\n-                                        .map_err(|e| e.0)?;\n-                                    infcx.register_member_constraints(\n-                                        param_env,\n-                                        opaque_type_key,\n-                                        res.value.ty,\n-                                        res.value.span,\n-                                    );\n-                                    Ok(res)\n-                                },\n-                                || \"opaque_type_map\".to_string(),\n-                            ),\n-                        )\n-                        .unwrap();\n-                    let mut hidden_type = infcx.resolve_vars_if_possible(hidden.ty);\n+                    cx.fully_perform_op(\n+                        Locations::All(body.span),\n+                        ConstraintCategory::OpaqueType,\n+                        CustomTypeOp::new(\n+                            |infcx| {\n+                                infcx.register_member_constraints(\n+                                    param_env,\n+                                    opaque_type_key,\n+                                    decl.hidden_type.ty,\n+                                    decl.hidden_type.span,\n+                                );\n+                                Ok(InferOk { value: (), obligations: vec![] })\n+                            },\n+                            || \"opaque_type_map\".to_string(),\n+                        ),\n+                    )\n+                    .unwrap();\n+                    let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type.ty);\n                     trace!(\n                         \"finalized opaque type {:?} to {:#?}\",\n                         opaque_type_key,\n                         hidden_type.kind()\n                     );\n                     if hidden_type.has_infer_types_or_consts() {\n                         infcx.tcx.sess.delay_span_bug(\n-                            hidden.span,\n+                            decl.hidden_type.span,\n                             &format!(\"could not resolve {:#?}\", hidden_type.kind()),\n                         );\n                         hidden_type = infcx.tcx.ty_error();\n@@ -263,7 +258,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                         );\n                         None\n                     } else {\n-                        Some((opaque_type_key, (hidden_type, hidden.span, decl.origin)))\n+                        Some((opaque_type_key, (hidden_type, decl.hidden_type.span, decl.origin)))\n                     }\n                 })\n                 .collect();"}, {"sha": "18a1120051efe63a47d850c760a154633ad95daf", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=edaf9625fbc4fc3bb4f8eb049112840e68d79351", "patch": "@@ -146,13 +146,13 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         })\n     }\n \n-    fn take_opaque_types_for_query_response(&self) -> Vec<(OpaqueTypeKey<'tcx>, Vec<Ty<'tcx>>)> {\n+    fn take_opaque_types_for_query_response(&self) -> Vec<(OpaqueTypeKey<'tcx>, Ty<'tcx>)> {\n         self.inner\n             .borrow_mut()\n             .opaque_type_storage\n             .take_opaque_types()\n             .into_iter()\n-            .map(|(k, v)| (k, v.hidden_types.into_iter().map(|ht| ht.ty).collect()))\n+            .map(|(k, v)| (k, v.hidden_type.ty))\n             .collect()\n     }\n \n@@ -497,14 +497,11 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let mut obligations = vec![];\n \n         // Carry all newly resolved opaque types to the caller's scope\n-        for (key, tys) in &query_response.value.opaque_types {\n+        for &(key, ty) in &query_response.value.opaque_types {\n             let substs = substitute_value(self.tcx, &result_subst, key.substs);\n             let opaque = self.tcx.mk_opaque(key.def_id, substs);\n-            for &ty in tys {\n-                let ty = substitute_value(self.tcx, &result_subst, ty);\n-                obligations\n-                    .extend(self.handle_opaque_type(opaque, ty, cause, param_env)?.obligations);\n-            }\n+            let ty = substitute_value(self.tcx, &result_subst, ty);\n+            obligations.extend(self.handle_opaque_type(opaque, ty, cause, param_env)?.obligations);\n         }\n \n         Ok(InferOk { value: result_subst, obligations })"}, {"sha": "748fe1379cd6246791b855d4f5a5ff5616fd7e6c", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 51, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=edaf9625fbc4fc3bb4f8eb049112840e68d79351", "patch": "@@ -6,7 +6,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_middle::traits::ObligationCause;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n@@ -33,61 +32,12 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// The hidden types that have been inferred for this opaque type.\n     /// There can be multiple, but they are all `lub`ed together at the end\n     /// to obtain the canonical hidden type.\n-    pub hidden_types: Vec<OpaqueHiddenType<'tcx>>,\n+    pub hidden_type: OpaqueHiddenType<'tcx>,\n \n     /// The origin of the opaque type.\n     pub origin: hir::OpaqueTyOrigin,\n }\n \n-impl<'tcx> OpaqueTypeDecl<'tcx> {\n-    pub fn hidden_type(\n-        &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        cause: &ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> Result<\n-        InferOk<'tcx, OpaqueHiddenType<'tcx>>,\n-        (TypeError<'tcx>, OpaqueHiddenType<'tcx>, OpaqueHiddenType<'tcx>),\n-    > {\n-        let mut value = self.hidden_types[0];\n-        let mut obligations = vec![];\n-        let mut error: Option<(_, _, OpaqueHiddenType<'tcx>)> = None;\n-        for &next in self.hidden_types[1..].iter() {\n-            // FIXME: make use of the spans to get nicer diagnostics!\n-            let res = match infcx.at(cause, param_env).eq(value.ty, next.ty) {\n-                Ok(res) => res,\n-                Err(e) => {\n-                    // Try to improve the span. Sometimes we have dummy spans, sometimes we are pointing\n-                    // at an if/match instead of at the arm that gave us the type, but later spans point\n-                    // to the right thing.\n-                    if let Some((_, _, old)) = &mut error {\n-                        old.span = old.span.substitute_dummy(next.span);\n-                        // Shrink the span if possible\n-                        if old.span.contains(next.span) {\n-                            old.span = next.span;\n-                        }\n-                    } else {\n-                        let mut next = next;\n-                        next.span = next.span.substitute_dummy(cause.span(infcx.tcx));\n-                        error = Some((e, value, next));\n-                    }\n-                    continue;\n-                }\n-            };\n-            obligations.extend(res.obligations);\n-            value.span = value.span.substitute_dummy(next.span);\n-            // Shrink the span if possible\n-            if value.span.contains(next.span) {\n-                value.span = next.span;\n-            }\n-        }\n-        match error {\n-            None => Ok(InferOk { value, obligations }),\n-            Some(e) => Err(e),\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, TypeFoldable)]\n pub struct OpaqueHiddenType<'tcx> {\n     /// The span of this particular definition of the opaque type. So"}, {"sha": "7f16a2f5332269756f9e3059799bfb1a70ccd34a", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=edaf9625fbc4fc3bb4f8eb049112840e68d79351", "patch": "@@ -20,7 +20,7 @@ impl<'tcx> OpaqueTypeStorage<'tcx> {\n     #[instrument(level = \"debug\")]\n     pub(crate) fn remove(&mut self, key: OpaqueTypeKey<'tcx>, idx: Option<OpaqueHiddenType<'tcx>>) {\n         if let Some(idx) = idx {\n-            self.opaque_types.get_mut(&key).unwrap().hidden_types[0] = idx;\n+            self.opaque_types.get_mut(&key).unwrap().hidden_type = idx;\n         } else {\n             match self.opaque_types.remove(&key) {\n                 None => bug!(\"reverted opaque type inference that was never registered: {:?}\", key),\n@@ -73,17 +73,15 @@ impl<'a, 'tcx> OpaqueTypeTable<'a, 'tcx> {\n         &mut self,\n         key: OpaqueTypeKey<'tcx>,\n         opaque_type: Ty<'tcx>,\n-        ty: OpaqueHiddenType<'tcx>,\n+        hidden_type: OpaqueHiddenType<'tcx>,\n         origin: OpaqueTyOrigin,\n     ) -> Option<Ty<'tcx>> {\n         if let Some(decl) = self.storage.opaque_types.get_mut(&key) {\n-            assert_eq!(decl.hidden_types.len(), 1);\n-            let prev = decl.hidden_types[0];\n-            decl.hidden_types = vec![ty];\n+            let prev = std::mem::replace(&mut decl.hidden_type, hidden_type);\n             self.undo_log.push(UndoLog::OpaqueTypes(key, Some(prev)));\n             return Some(prev.ty);\n         }\n-        let decl = OpaqueTypeDecl { opaque_type, hidden_types: vec![ty], origin };\n+        let decl = OpaqueTypeDecl { opaque_type, hidden_type, origin };\n         self.storage.opaque_types.insert(key, decl);\n         self.undo_log.push(UndoLog::OpaqueTypes(key, None));\n         None"}, {"sha": "654ec022b604fb0c4f53729116cd94751baa676c", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=edaf9625fbc4fc3bb4f8eb049112840e68d79351", "patch": "@@ -180,7 +180,7 @@ pub struct QueryResponse<'tcx, R> {\n     pub certainty: Certainty,\n     /// List of opaque types for which we figured out a hidden type\n     /// during the evaluation of the query.\n-    pub opaque_types: Vec<(OpaqueTypeKey<'tcx>, Vec<Ty<'tcx>>)>,\n+    pub opaque_types: Vec<(OpaqueTypeKey<'tcx>, Ty<'tcx>)>,\n     pub value: R,\n }\n "}, {"sha": "d4be3889a7ae7e1dcee977a2f19324fdd4feba24", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edaf9625fbc4fc3bb4f8eb049112840e68d79351/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=edaf9625fbc4fc3bb4f8eb049112840e68d79351", "patch": "@@ -99,8 +99,6 @@ pub use diverges::Diverges;\n pub use expectation::Expectation;\n pub use fn_ctxt::*;\n pub use inherited::{Inherited, InheritedBuilder};\n-use rustc_infer::traits::ObligationCause;\n-use traits::ObligationCauseCode::MiscObligation;\n \n use crate::astconv::AstConv;\n use crate::check::gather_locals::GatherLocalsVisitor;\n@@ -474,19 +472,6 @@ fn typeck_with_fallback<'tcx>(\n             fcx.require_type_is_sized(ty, span, code);\n         }\n \n-        let opaque_types = fcx.infcx.inner.borrow_mut().opaque_type_storage.opaque_types();\n-        for (_, decl) in opaque_types {\n-            let cause = ObligationCause::new(body.value.span, id, MiscObligation);\n-            if let Err((err, expected, actual)) =\n-                decl.hidden_type(&fcx.infcx, &cause, fcx.param_env)\n-            {\n-                let cause = ObligationCause::new(actual.span, id, MiscObligation);\n-                fcx.report_mismatched_types(&cause, expected.ty, actual.ty, err)\n-                    .span_label(expected.span, \"type expected due to this\")\n-                    .emit();\n-            }\n-        }\n-\n         fcx.select_all_obligations_or_error();\n \n         if fn_sig.is_some() {"}]}