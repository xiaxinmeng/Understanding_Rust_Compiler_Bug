{"sha": "796c0ca5548de6d4a5220dbae500e00db616243b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NmMwY2E1NTQ4ZGU2ZDRhNTIyMGRiYWU1MDBlMDBkYjYxNjI0M2I=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-03-17T03:50:20Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-28T21:58:50Z"}, "message": "Incorporate MIR const-checker into `Pat` lowering", "tree": {"sha": "1ca9cf3899fc5c49779ce986a4353256226e50bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ca9cf3899fc5c49779ce986a4353256226e50bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/796c0ca5548de6d4a5220dbae500e00db616243b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/796c0ca5548de6d4a5220dbae500e00db616243b", "html_url": "https://github.com/rust-lang/rust/commit/796c0ca5548de6d4a5220dbae500e00db616243b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/796c0ca5548de6d4a5220dbae500e00db616243b/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b54829b784bb5e16354fd0e63c1de4e6238800c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b54829b784bb5e16354fd0e63c1de4e6238800c", "html_url": "https://github.com/rust-lang/rust/commit/6b54829b784bb5e16354fd0e63c1de4e6238800c"}], "stats": {"total": 152, "additions": 89, "deletions": 63}, "files": [{"sha": "ad87afc3e0301b659a1e09176df7cee0456c15d1", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/796c0ca5548de6d4a5220dbae500e00db616243b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/796c0ca5548de6d4a5220dbae500e00db616243b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=796c0ca5548de6d4a5220dbae500e00db616243b", "patch": "@@ -22,13 +22,14 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         cv: &'tcx ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n+        mir_structural_match_violation: bool,\n     ) -> Pat<'tcx> {\n         debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n         debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n \n         self.tcx.infer_ctxt().enter(|infcx| {\n             let mut convert = ConstToPat::new(self, id, span, infcx);\n-            convert.to_pat(cv)\n+            convert.to_pat(cv, mir_structural_match_violation)\n         })\n     }\n }\n@@ -81,7 +82,11 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         traits::type_marked_structural(self.id, self.span, &self.infcx, ty)\n     }\n \n-    fn to_pat(&mut self, cv: &'tcx ty::Const<'tcx>) -> Pat<'tcx> {\n+    fn to_pat(\n+        &mut self,\n+        cv: &'tcx ty::Const<'tcx>,\n+        mir_structural_match_violation: bool,\n+    ) -> Pat<'tcx> {\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n         // performed by the recursive `recur` method, which is not meant to be\n         // invoked except by this method.\n@@ -100,6 +105,11 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 \"search_for_structural_match_violation cv.ty: {:?} returned: {:?}\",\n                 cv.ty, structural\n             );\n+\n+            if structural.is_none() && mir_structural_match_violation {\n+                bug!(\"MIR const-checker found novel structural match violation\");\n+            }\n+\n             if let Some(non_sm_ty) = structural {\n                 let adt_def = match non_sm_ty {\n                     traits::NonStructuralMatchTy::Adt(adt_def) => adt_def,\n@@ -146,13 +156,18 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 if !ty_is_partial_eq {\n                     // span_fatal avoids ICE from resolution of non-existent method (rare case).\n                     self.tcx().sess.span_fatal(self.span, &make_msg());\n-                } else {\n+                } else if mir_structural_match_violation {\n                     self.tcx().struct_span_lint_hir(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         self.id,\n                         self.span,\n                         |lint| lint.build(&make_msg()).emit(),\n                     );\n+                } else {\n+                    debug!(\n+                        \"`search_for_structural_match_violation` found one, but `CustomEq` was \\\n+                          not in the qualifs for that `const`\"\n+                    );\n                 }\n             }\n         }"}, {"sha": "bd75f11fb8f9465d4516964057e84fc74de0560e", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "modified", "additions": 71, "deletions": 60, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/796c0ca5548de6d4a5220dbae500e00db616243b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/796c0ca5548de6d4a5220dbae500e00db616243b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=796c0ca5548de6d4a5220dbae500e00db616243b", "patch": "@@ -15,7 +15,7 @@ use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::interpret::{get_slice_bytes, sign_extend, ConstValue, ErrorHandled};\n+use rustc_middle::mir::interpret::{get_slice_bytes, sign_extend, ConstValue};\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::mir::UserTypeProjection;\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n@@ -762,69 +762,80 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_path(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) -> Pat<'tcx> {\n         let ty = self.tables.node_type(id);\n         let res = self.tables.qpath_res(qpath, id);\n-        let is_associated_const = match res {\n-            Res::Def(DefKind::AssocConst, _) => true,\n-            _ => false,\n+\n+        let pat_from_kind = |kind| Pat { span, ty, kind: Box::new(kind) };\n+\n+        let (def_id, is_associated_const) = match res {\n+            Res::Def(DefKind::Const, def_id) => (def_id, false),\n+            Res::Def(DefKind::AssocConst, def_id) => (def_id, true),\n+\n+            _ => return pat_from_kind(self.lower_variant_or_leaf(res, id, span, ty, vec![])),\n         };\n-        let kind = match res {\n-            Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n-                let substs = self.tables.node_substs(id);\n-                // Use `Reveal::All` here because patterns are always monomorphic even if their function isn't.\n-                match self.tcx.const_eval_resolve(\n-                    self.param_env.with_reveal_all(),\n-                    def_id,\n-                    substs,\n-                    None,\n-                    Some(span),\n-                ) {\n-                    Ok(value) => {\n-                        let const_ =\n-                            ty::Const::from_value(self.tcx, value, self.tables.node_type(id));\n-\n-                        let pattern = self.const_to_pat(&const_, id, span);\n-                        if !is_associated_const {\n-                            return pattern;\n-                        }\n \n-                        let user_provided_types = self.tables().user_provided_types();\n-                        return if let Some(u_ty) = user_provided_types.get(id) {\n-                            let user_ty = PatTyProj::from_user_type(*u_ty);\n-                            Pat {\n-                                span,\n-                                kind: Box::new(PatKind::AscribeUserType {\n-                                    subpattern: pattern,\n-                                    ascription: Ascription {\n-                                        /// Note that use `Contravariant` here. See the\n-                                        /// `variance` field documentation for details.\n-                                        variance: ty::Variance::Contravariant,\n-                                        user_ty,\n-                                        user_ty_span: span,\n-                                    },\n-                                }),\n-                                ty: const_.ty,\n-                            }\n-                        } else {\n-                            pattern\n-                        };\n-                    }\n-                    Err(ErrorHandled::TooGeneric) => {\n-                        self.errors.push(if is_associated_const {\n-                            PatternError::AssocConstInPattern(span)\n-                        } else {\n-                            PatternError::StaticInPattern(span)\n-                        });\n-                        PatKind::Wild\n-                    }\n-                    Err(_) => {\n-                        self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n-                        PatKind::Wild\n-                    }\n-                }\n+        // Use `Reveal::All` here because patterns are always monomorphic even if their function\n+        // isn't.\n+        let param_env_reveal_all = self.param_env.with_reveal_all();\n+        let substs = self.tables.node_substs(id);\n+        let instance = match ty::Instance::resolve(self.tcx, param_env_reveal_all, def_id, substs) {\n+            Ok(Some(i)) => i,\n+            Ok(None) => {\n+                self.errors.push(if is_associated_const {\n+                    PatternError::AssocConstInPattern(span)\n+                } else {\n+                    PatternError::StaticInPattern(span)\n+                });\n+\n+                return pat_from_kind(PatKind::Wild);\n+            }\n+\n+            Err(_) => {\n+                self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n+                return pat_from_kind(PatKind::Wild);\n             }\n-            _ => self.lower_variant_or_leaf(res, id, span, ty, vec![]),\n         };\n \n-        Pat { span, ty, kind: Box::new(kind) }\n+        // `mir_const_qualif` must be called with the `DefId` of the item where the const is\n+        // defined, not where it is declared. The difference is significant for associated\n+        // constants.\n+        let mir_structural_match_violation = self.tcx.mir_const_qualif(instance.def_id()).custom_eq;\n+        debug!(\"mir_structural_match_violation({:?}) -> {}\", qpath, mir_structural_match_violation);\n+\n+        match self.tcx.const_eval_instance(param_env_reveal_all, instance, Some(span)) {\n+            Ok(value) => {\n+                let const_ = ty::Const::from_value(self.tcx, value, self.tables.node_type(id));\n+\n+                let pattern = self.const_to_pat(&const_, id, span, mir_structural_match_violation);\n+\n+                if !is_associated_const {\n+                    return pattern;\n+                }\n+\n+                let user_provided_types = self.tables().user_provided_types();\n+                if let Some(u_ty) = user_provided_types.get(id) {\n+                    let user_ty = PatTyProj::from_user_type(*u_ty);\n+                    Pat {\n+                        span,\n+                        kind: Box::new(PatKind::AscribeUserType {\n+                            subpattern: pattern,\n+                            ascription: Ascription {\n+                                /// Note that use `Contravariant` here. See the\n+                                /// `variance` field documentation for details.\n+                                variance: ty::Variance::Contravariant,\n+                                user_ty,\n+                                user_ty_span: span,\n+                            },\n+                        }),\n+                        ty: const_.ty,\n+                    }\n+                } else {\n+                    pattern\n+                }\n+            }\n+            Err(_) => {\n+                self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n+                pat_from_kind(PatKind::Wild)\n+            }\n+        }\n     }\n \n     /// Converts literals, paths and negation of literals to patterns.\n@@ -849,7 +860,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n             let lit_input = LitToConstInput { lit: &lit.node, ty: self.tables.expr_ty(expr), neg };\n             match self.tcx.at(expr.span).lit_to_const(lit_input) {\n-                Ok(val) => *self.const_to_pat(val, expr.hir_id, lit.span).kind,\n+                Ok(val) => *self.const_to_pat(val, expr.hir_id, lit.span, false).kind,\n                 Err(LitToConstError::UnparseableFloat) => {\n                     self.errors.push(PatternError::FloatBug);\n                     PatKind::Wild"}]}