{"sha": "67ae3a49e4864133784cd745a9a8866889f3ae15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3YWUzYTQ5ZTQ4NjQxMzM3ODRjZDc0NWE5YTg4NjY4ODlmM2FlMTU=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-12-09T17:17:18Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-12-09T17:20:20Z"}, "message": "Clean up `libcollections::VecMap`\n\n- Introduce a named type for the return type of `VecMap::move_iter`\n- Rename all type parameters to `V` for \"Value\".\n- Remove unnecessary call to an `Option::unwrap`, use pattern matching instead.\n- Remove incorrect `Hash` implementation which took the `VecMap`'s capacity\n  into account.\n\nThis is a [breaking-change], however whoever used the `Hash` implementation\nrelied on an incorrect implementation.", "tree": {"sha": "08bce0fac19faa0396ad62f46affd319bd5fa563", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08bce0fac19faa0396ad62f46affd319bd5fa563"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67ae3a49e4864133784cd745a9a8866889f3ae15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67ae3a49e4864133784cd745a9a8866889f3ae15", "html_url": "https://github.com/rust-lang/rust/commit/67ae3a49e4864133784cd745a9a8866889f3ae15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67ae3a49e4864133784cd745a9a8866889f3ae15/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95d17711397d63425688d18140a58723caddff8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/95d17711397d63425688d18140a58723caddff8e", "html_url": "https://github.com/rust-lang/rust/commit/95d17711397d63425688d18140a58723caddff8e"}], "stats": {"total": 89, "additions": 35, "deletions": 54}, "files": [{"sha": "cbe48bf45e7879b014dde7d9e5a3bb92f6e637c4", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 35, "deletions": 54, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/67ae3a49e4864133784cd745a9a8866889f3ae15/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ae3a49e4864133784cd745a9a8866889f3ae15/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=67ae3a49e4864133784cd745a9a8866889f3ae15", "patch": "@@ -23,8 +23,6 @@ use core::mem::replace;\n \n use {vec, slice};\n use vec::Vec;\n-use hash;\n-use hash::Hash;\n \n // FIXME(conventions): capacity management???\n \n@@ -62,8 +60,8 @@ use hash::Hash;\n /// assert!(months.is_empty());\n /// ```\n #[deriving(PartialEq, Eq)]\n-pub struct VecMap<T> {\n-    v: Vec<Option<T>>,\n+pub struct VecMap<V> {\n+    v: Vec<Option<V>>,\n }\n \n impl<V> Default for VecMap<V> {\n@@ -83,12 +81,6 @@ impl<V:Clone> Clone for VecMap<V> {\n     }\n }\n \n-impl <S: hash::Writer, T: Hash<S>> Hash<S> for VecMap<T> {\n-    fn hash(&self, state: &mut S) {\n-        self.v.hash(state)\n-    }\n-}\n-\n impl<V> VecMap<V> {\n     /// Creates an empty `VecMap`.\n     ///\n@@ -99,7 +91,7 @@ impl<V> VecMap<V> {\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn new() -> VecMap<V> { VecMap{v: vec!()} }\n+    pub fn new() -> VecMap<V> { VecMap { v: vec![] } }\n \n     /// Creates an empty `VecMap` with space for at least `capacity`\n     /// elements before resizing.\n@@ -207,10 +199,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(&mut self)\n-        -> FilterMap<(uint, Option<V>), (uint, V),\n-                Enumerate<vec::MoveItems<Option<V>>>>\n-    {\n+    pub fn into_iter(&mut self) -> MoveItems<V> {\n         let values = replace(&mut self.v, vec!());\n         values.into_iter().enumerate().filter_map(|(i, v)| {\n             v.map(|v| (i, v))\n@@ -523,16 +512,19 @@ impl<V> IndexMut<uint, V> for VecMap<V> {\n \n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n+        impl<'a, V> Iterator<$elem> for $name<'a, V> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 while self.front < self.back {\n                     match self.iter.next() {\n                         Some(elem) => {\n-                            if elem.is_some() {\n-                                let index = self.front;\n-                                self.front += 1;\n-                                return Some((index, elem $(. $getter ())+));\n+                            match elem$(. $getter ())+ {\n+                                Some(x) => {\n+                                    let index = self.front;\n+                                    self.front += 1;\n+                                    return Some((index, x));\n+                                },\n+                                None => {},\n                             }\n                         }\n                         _ => ()\n@@ -552,15 +544,18 @@ macro_rules! iterator {\n \n macro_rules! double_ended_iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n+        impl<'a, V> DoubleEndedIterator<$elem> for $name<'a, V> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 while self.front < self.back {\n                     match self.iter.next_back() {\n                         Some(elem) => {\n-                            if elem.is_some() {\n-                                self.back -= 1;\n-                                return Some((self.back, elem$(. $getter ())+));\n+                            match elem$(. $getter ())+ {\n+                                Some(x) => {\n+                                    self.back -= 1;\n+                                    return Some((self.back, x));\n+                                },\n+                                None => {},\n                             }\n                         }\n                         _ => ()\n@@ -574,39 +569,42 @@ macro_rules! double_ended_iterator {\n }\n \n /// Forward iterator over a map.\n-pub struct Entries<'a, T:'a> {\n+pub struct Entries<'a, V:'a> {\n     front: uint,\n     back: uint,\n-    iter: slice::Items<'a, Option<T>>\n+    iter: slice::Items<'a, Option<V>>\n }\n \n-iterator!(impl Entries -> (uint, &'a T), as_ref, unwrap)\n-double_ended_iterator!(impl Entries -> (uint, &'a T), as_ref, unwrap)\n+iterator!(impl Entries -> (uint, &'a V), as_ref)\n+double_ended_iterator!(impl Entries -> (uint, &'a V), as_ref)\n \n /// Forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-pub struct MutEntries<'a, T:'a> {\n+pub struct MutEntries<'a, V:'a> {\n     front: uint,\n     back: uint,\n-    iter: slice::MutItems<'a, Option<T>>\n+    iter: slice::MutItems<'a, Option<V>>\n }\n \n-iterator!(impl MutEntries -> (uint, &'a mut T), as_mut, unwrap)\n-double_ended_iterator!(impl MutEntries -> (uint, &'a mut T), as_mut, unwrap)\n+iterator!(impl MutEntries -> (uint, &'a mut V), as_mut)\n+double_ended_iterator!(impl MutEntries -> (uint, &'a mut V), as_mut)\n \n /// Forward iterator over the keys of a map\n-pub type Keys<'a, T> =\n-    iter::Map<'static, (uint, &'a T), uint, Entries<'a, T>>;\n+pub type Keys<'a, V> =\n+    iter::Map<'static, (uint, &'a V), uint, Entries<'a, V>>;\n \n /// Forward iterator over the values of a map\n-pub type Values<'a, T> =\n-    iter::Map<'static, (uint, &'a T), &'a T, Entries<'a, T>>;\n+pub type Values<'a, V> =\n+    iter::Map<'static, (uint, &'a V), &'a V, Entries<'a, V>>;\n+\n+/// Iterator over the key-value pairs of a map, the iterator consumes the map\n+pub type MoveItems<V> =\n+    FilterMap<'static, (uint, Option<V>), (uint, V), Enumerate<vec::MoveItems<Option<V>>>>;\n \n #[cfg(test)]\n mod test_map {\n     use std::prelude::*;\n     use vec::Vec;\n-    use hash;\n \n     use super::VecMap;\n \n@@ -920,23 +918,6 @@ mod test_map {\n         assert!(a < b && a <= b);\n     }\n \n-    #[test]\n-    fn test_hash() {\n-        let mut x = VecMap::new();\n-        let mut y = VecMap::new();\n-\n-        assert!(hash::hash(&x) == hash::hash(&y));\n-        x.insert(1, 'a');\n-        x.insert(2, 'b');\n-        x.insert(3, 'c');\n-\n-        y.insert(3, 'c');\n-        y.insert(2, 'b');\n-        y.insert(1, 'a');\n-\n-        assert!(hash::hash(&x) == hash::hash(&y));\n-    }\n-\n     #[test]\n     fn test_from_iter() {\n         let xs: Vec<(uint, char)> = vec![(1u, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')];"}]}