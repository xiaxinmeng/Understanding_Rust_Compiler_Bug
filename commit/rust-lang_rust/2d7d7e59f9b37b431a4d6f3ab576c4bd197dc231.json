{"sha": "2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkN2Q3ZTU5ZjliMzdiNDMxYTRkNmYzYWI1NzZjNGJkMTk3ZGMyMzE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-08T11:05:20Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-09T08:34:40Z"}, "message": "docs: adjust code blocks to pass with rustdoc.\n\nThe changes are basically just because rustdoc runs tests/rendering on\nmore snippets by default (i.e. everything without a `notrust` tag), and\nnot anything significant.", "tree": {"sha": "954b3d0abb575d833312116a81ca036c4ff262e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/954b3d0abb575d833312116a81ca036c4ff262e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "html_url": "https://github.com/rust-lang/rust/commit/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e904120487f67172eb2d509531ed8f9e230af3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e904120487f67172eb2d509531ed8f9e230af3a", "html_url": "https://github.com/rust-lang/rust/commit/8e904120487f67172eb2d509531ed8f9e230af3a"}], "stats": {"total": 165, "additions": 92, "deletions": 73}, "files": [{"sha": "5b38ef5645e2b127afb5a530f0f0f6fa4bac81d9", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "patch": "@@ -135,7 +135,7 @@ For simplicity, we do not plan to do so. Implementing automatic semicolon insert\n \n **Short answer** set the RUST_LOG environment variable to the name of your source file, sans extension.\n \n-```sh\n+``` {.sh .notrust}\n rustc hello.rs\n export RUST_LOG=hello\n ./hello"}, {"sha": "b9cab358e909da0c9018a82b26329a8127a4cd23", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "patch": "@@ -263,6 +263,7 @@ to the C library and afterwards be invoked from there.\n A basic example is:\n \n Rust code:\n+\n ~~~~ {.ignore}\n extern fn callback(a:i32) {\n     println!(\"I'm called from C with value {0}\", a);\n@@ -283,7 +284,8 @@ fn main() {\n ~~~~\n \n C code:\n-~~~~ {.ignore}\n+\n+~~~~ {.notrust}\n typedef void (*rust_callback)(int32_t);\n rust_callback cb;\n \n@@ -314,6 +316,7 @@ the notification. This will allow the callback to unsafely access the\n referenced Rust object.\n \n Rust code:\n+\n ~~~~ {.ignore}\n \n struct RustObject {\n@@ -346,7 +349,8 @@ fn main() {\n ~~~~\n \n C code:\n-~~~~ {.ignore}\n+\n+~~~~ {.notrust}\n typedef void (*rust_callback)(int32_t);\n void* cb_target;\n rust_callback cb;"}, {"sha": "69596b6e30475bfd6ec379a62d6e8e185225dbda", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "patch": "@@ -205,7 +205,7 @@ struct X { f: int }\n fn example1() {\n     let mut x = X { f: 3 };\n     let y = &mut x.f;  // -+ L\n-    ...                //  |\n+    // ...             //  |\n }                      // -+\n ~~~\n \n@@ -221,7 +221,7 @@ The situation gets more complex when borrowing data inside heap boxes:\n fn example2() {\n     let mut x = @X { f: 3 };\n     let y = &x.f;      // -+ L\n-    ...                //  |\n+    // ...             //  |\n }                      // -+\n ~~~\n \n@@ -251,7 +251,7 @@ fn example2() {\n     let mut x = @X {f: 3};\n     let x1 = x;\n     let y = &x1.f;     // -+ L\n-    ...                //  |\n+    // ...             //  |\n }                      // -+\n ~~~\n \n@@ -282,7 +282,7 @@ fn example3() -> int {\n         return *y;         //  |\n     }                      // -+\n     x = ~Foo {f: 4};\n-    ...\n+    // ...\n # return 0;\n }\n ~~~"}, {"sha": "1a01fad5da2144e71d7fbc6d3b469cdeb93993fa", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "patch": "@@ -185,6 +185,7 @@ amount.\n For example:\n \n ~~~\n+# #[allow(unused_imports)];\n extern crate test;\n \n use std::vec;\n@@ -201,6 +202,8 @@ fn initialise_a_vector(b: &mut BenchHarness) {\n     b.iter(|| {vec::from_elem(1024, 0u64);} );\n     b.bytes = 1024 * 8;\n }\n+\n+# fn main() {}\n ~~~\n \n The benchmark runner will calibrate measurement of the benchmark\n@@ -244,6 +247,7 @@ recognize that some calculation has no external effects and remove\n it entirely.\n \n ~~~\n+# #[allow(unused_imports)];\n extern crate test;\n use test::BenchHarness;\n \n@@ -253,6 +257,8 @@ fn bench_xor_1000_ints(bh: &mut BenchHarness) {\n             range(0, 1000).fold(0, |old, new| old ^ new);\n         });\n }\n+\n+# fn main() {}\n ~~~\n \n gives the following results\n@@ -271,6 +277,7 @@ cannot remove the computation entirely. This could be done for the\n example above by adjusting the `bh.iter` call to\n \n ~~~\n+# struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let bh = X;\n bh.iter(|| range(0, 1000).fold(0, |old, new| old ^ new))\n ~~~\n \n@@ -281,9 +288,12 @@ forces it to consider any argument as used.\n ~~~\n extern crate test;\n \n+# fn main() {\n+# struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let bh = X;\n bh.iter(|| {\n         test::black_box(range(0, 1000).fold(0, |old, new| old ^ new));\n     });\n+# }\n ~~~\n \n Neither of these read or modify the value, and are very cheap for"}, {"sha": "8dacf0e4de886f4cbaf6958ccd69cb117c06ef43", "filename": "src/doc/index.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "patch": "@@ -25,6 +25,8 @@ li {list-style-type: none; }\n \n * [The standard library, `std`](std/index.html)\n \n+<!-- force the two lists to be separate -->\n+\n * [The `arena` allocation library](arena/index.html)\n * [The `collections` library](collections/index.html)\n * [The `extra` library of extra stuff](extra/index.html)"}, {"sha": "d1cef9a0614771903ad98eafcf683914b8b3b88f", "filename": "src/doc/rust.md", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "patch": "@@ -60,7 +60,7 @@ dialect of EBNF supported by common automated LL(k) parsing tools such as\n `llgen`, rather than the dialect given in ISO 14977. The dialect can be\n defined self-referentially as follows:\n \n-~~~~ {.ebnf .notation}\n+~~~~ {.notrust .ebnf .notation}\n grammar : rule + ;\n rule    : nonterminal ':' productionrule ';' ;\n productionrule : production [ '|' production ] * ;\n@@ -150,7 +150,7 @@ Some productions are defined by exclusion of particular Unicode characters:\n \n ## Comments\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n comment : block_comment | line_comment ;\n block_comment : \"/*\" block_comment_body * '*' + '/' ;\n block_comment_body : (block_comment | character) * ;\n@@ -171,7 +171,7 @@ Non-doc comments are interpreted as a form of whitespace.\n \n ## Whitespace\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ;\n whitespace : [ whitespace_char | comment ] + ;\n ~~~~\n@@ -188,7 +188,7 @@ with any other legal whitespace element, such as a single space character.\n \n ## Tokens\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n simple_token : keyword | unop | binop ;\n token : simple_token | ident | literal | symbol | whitespace token ;\n ~~~~\n@@ -202,7 +202,7 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n \n The keywords are the following strings:\n \n-~~~~ {.keyword}\n+~~~~ {.notrust .keyword}\n as\n break\n do\n@@ -230,13 +230,13 @@ evaluates to, rather than referring to it by name or some other evaluation\n rule. A literal is a form of constant expression, so is evaluated (primarily)\n at compile time.\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n literal : string_lit | char_lit | num_lit ;\n ~~~~\n \n #### Character and string literals\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n char_lit : '\\x27' char_body '\\x27' ;\n string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n \n@@ -318,7 +318,7 @@ r##\"foo #\"# bar\"##;                // foo #\"# bar\n \n #### Number literals\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n num_lit : nonzero_dec [ dec_digit | '_' ] * num_suffix ?\n         | '0' [       [ dec_digit | '_' ] * num_suffix ?\n               | 'b'   [ '1' | '0' | '_' ] + int_suffix ?\n@@ -416,7 +416,7 @@ The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n symbol : \"::\" \"->\"\n        | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n        | ',' | ';' ;\n@@ -431,7 +431,7 @@ operators](#binary-operator-expressions), or [keywords](#keywords).\n \n ## Paths\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n expr_path : ident [ \"::\" expr_path_tail ] + ;\n expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n                | expr_path ;\n@@ -495,7 +495,7 @@ All of the above extensions are expressions with values.\n \n ## Macros\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')'\n macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';'\n matcher : '(' matcher * ')' | '[' matcher * ']'\n@@ -635,7 +635,7 @@ each of which may have some number of [attributes](#attributes) attached to it.\n \n ## Items\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n item : mod_item | fn_item | type_item | struct_item | enum_item\n      | static_item | trait_item | impl_item | extern_block ;\n ~~~~\n@@ -683,7 +683,7 @@ That is, Rust has no notion of type abstraction: there are no first-class \"foral\n \n ### Modules\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n mod : [ view_item | item ] * ;\n ~~~~\n@@ -703,15 +703,15 @@ An example of a module:\n mod math {\n     type Complex = (f64, f64);\n     fn sin(f: f64) -> f64 {\n-        ...\n+        /* ... */\n # fail!();\n     }\n     fn cos(f: f64) -> f64 {\n-        ...\n+        /* ... */\n # fail!();\n     }\n     fn tan(f: f64) -> f64 {\n-        ...\n+        /* ... */\n # fail!();\n     }\n }\n@@ -751,7 +751,7 @@ mod task {\n \n #### View items\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n view_item : extern_crate_decl | use_decl ;\n ~~~~\n \n@@ -764,7 +764,7 @@ There are several kinds of view item:\n \n ##### Extern crate declarations\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n extern_crate_decl : \"extern\" \"crate\" ident [ '(' link_attrs ')' ] ? [ '=' string_lit ] ? ;\n link_attrs : link_attr [ ',' link_attrs ] + ;\n link_attr : ident '=' literal ;\n@@ -796,7 +796,7 @@ extern crate foo = \"some/where/rust-foo#foo:1.0\"; // a full package ID for exter\n \n ##### Use declarations\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n use_decl : \"pub\" ? \"use\" ident [ '=' path\n                           | \"::\" path_glob ] ;\n \n@@ -1205,7 +1205,7 @@ whereas `Dog` is simply called an enum variant.\n \n ### Static items\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n static_item : \"static\" ident ':' type '=' expr ';' ;\n ~~~~\n \n@@ -1447,7 +1447,7 @@ Implementation parameters are written after the `impl` keyword.\n # trait Seq<T> { }\n \n impl<T> Seq<T> for ~[T] {\n-   ...\n+   /* ... */\n }\n impl Seq<bool> for u32 {\n    /* Treat the integer as a sequence of bits */\n@@ -1456,7 +1456,7 @@ impl Seq<bool> for u32 {\n \n ### External blocks\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n extern_block_item : \"extern\" '{' extern_block '} ;\n extern_block : [ foreign_fn ] * ;\n ~~~~\n@@ -1682,7 +1682,7 @@ import public items from their destination, not private items.\n \n ## Attributes\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n attribute : '#' '[' attr_list ']' ;\n attr_list : attr [ ',' attr_list ]*\n attr : ident [ '=' literal\n@@ -2226,7 +2226,7 @@ declaring a function-local item.\n \n #### Slot declarations\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n init : [ '=' ] expr ;\n ~~~~\n@@ -2326,7 +2326,7 @@ values.\n \n ### Structure expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n struct_expr : expr_path '{' ident ':' expr\n                       [ ',' ident ':' expr ] *\n                       [ \"..\" expr ] '}' |\n@@ -2380,7 +2380,7 @@ Point3d {y: 0, z: 10, .. base};\n \n ### Block expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n block_expr : '{' [ view_item ] *\n                  [ stmt ';' | item ] *\n                  [ expr ] '}'\n@@ -2398,7 +2398,7 @@ of the block are that of the expression itself.\n \n ### Method-call expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n method_call_expr : expr '.' ident paren_expr_list ;\n ~~~~\n \n@@ -2409,17 +2409,18 @@ or dynamically dispatching if the left-hand-side expression is an indirect [obje\n \n ### Field expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n field_expr : expr '.' ident\n ~~~~\n \n A _field expression_ consists of an expression followed by a single dot and an identifier,\n when not immediately followed by a parenthesized expression-list (the latter is a [method call expression](#method-call-expressions)).\n A field expression denotes a field of a [structure](#structure-types).\n \n-~~~~ {.field}\n+~~~~ {.ignore .field}\n myrecord.myfield;\n-{a: 10, b: 20}.a;\n+foo().x;\n+(Struct {a: 10, b: 20}).a;\n ~~~~\n \n A field access on a record is an [lvalue](#lvalues-rvalues-and-temporaries) referring to the value of that field.\n@@ -2430,7 +2431,7 @@ it is automatically dereferenced to make the field access possible.\n \n ### Vector expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n vec_expr : '[' \"mut\" ? vec_elems? ']'\n \n vec_elems : [expr [',' expr]*] | [expr ',' \"..\" expr]\n@@ -2452,7 +2453,7 @@ as a [literal](#literals) or a [static item](#static-items).\n \n ### Index expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n idx_expr : expr '[' expr ']'\n ~~~~\n \n@@ -2504,7 +2505,7 @@ before the expression they apply to.\n \n ### Binary operator expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n binop_expr : expr binop expr ;\n ~~~~\n \n@@ -2645,7 +2646,7 @@ Any such expression always has the [`unit`](#primitive-types) type.\n The precedence of Rust binary operators is ordered as follows, going\n from strong to weak:\n \n-~~~~ {.precedence}\n+~~~~ {.notrust .precedence}\n * / %\n as\n + -\n@@ -2669,7 +2670,7 @@ An expression enclosed in parentheses evaluates to the result of the enclosed\n expression.  Parentheses can be used to explicitly specify evaluation order\n within an expression.\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n paren_expr : '(' expr ')' ;\n ~~~~\n \n@@ -2682,7 +2683,7 @@ let x = (2 + 3) * 4;\n \n ### Call expressions\n \n-~~~~ {.abnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n expr_list : [ expr [ ',' expr ]* ] ? ;\n paren_expr_list : '(' expr_list ')' ;\n call_expr : expr paren_expr_list ;\n@@ -2705,7 +2706,7 @@ let pi: Option<f32> = FromStr::from_str(\"3.14\");\n \n ### Lambda expressions\n \n-~~~~ {.abnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n ident_list : [ ident [ ',' ident ]* ] ? ;\n lambda_expr : '|' ident_list '|' expr ;\n ~~~~\n@@ -2748,7 +2749,7 @@ ten_times(|j| println!(\"hello, {}\", j));\n \n ### While loops\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n while_expr : \"while\" expr '{' block '}' ;\n ~~~~\n \n@@ -2774,7 +2775,7 @@ The keyword `loop` in Rust appears both in _loop expressions_ and in _continue e\n A loop expression denotes an infinite loop;\n see [Continue expressions](#continue-expressions) for continue expressions.\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n ~~~~\n \n@@ -2785,7 +2786,7 @@ See [Break expressions](#break-expressions).\n \n ### Break expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n break_expr : \"break\" [ lifetime ];\n ~~~~\n \n@@ -2798,7 +2799,7 @@ but must enclose it.\n \n ### Continue expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n continue_expr : \"loop\" [ lifetime ];\n ~~~~\n \n@@ -2817,7 +2818,7 @@ A `loop` expression is only permitted in the body of a loop.\n \n ### For expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n for_expr : \"for\" pat \"in\" expr '{' block '}' ;\n ~~~~\n \n@@ -2851,7 +2852,7 @@ for i in range(0u, 256) {\n \n ### If expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n if_expr : \"if\" expr '{' block '}'\n           else_tail ? ;\n \n@@ -2872,7 +2873,7 @@ then any `else` block is executed.\n \n ### Match expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n match_expr : \"match\" expr '{' match_arm [ '|' match_arm ] * '}' ;\n \n match_arm : match_pat '=>' [ expr \",\" | '{' block '}' ] ;\n@@ -3063,7 +3064,7 @@ let message = match maybe_digit {\n \n ### Return expressions\n \n-~~~~ {.ebnf .gram}\n+~~~~ {.notrust .ebnf .gram}\n return_expr : \"return\" expr ? ;\n ~~~~\n \n@@ -3895,7 +3896,7 @@ fn main() {\n \n These four log levels correspond to levels 1-4, as controlled by `RUST_LOG`:\n \n-```bash\n+``` {.bash .notrust}\n $ RUST_LOG=rust=3 ./rust\n This is an error log\n This is a warn log"}, {"sha": "476cc26fe67350ce0148d0902a6acba51e29412f", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=2d7d7e59f9b37b431a4d6f3ab576c4bd197dc231", "patch": "@@ -1058,10 +1058,12 @@ being destroyed along with the owner. Since the `list` variable above is\n immutable, the whole list is immutable. The memory allocation itself is the\n box, while the owner holds onto a pointer to it:\n \n-              List box             List box           List box            List box\n-            +--------------+    +--------------+    +--------------+    +--------------+\n-    list -> | Cons | 1 | ~ | -> | Cons | 2 | ~ | -> | Cons | 3 | ~ | -> | Nil          |\n-            +--------------+    +--------------+    +--------------+    +--------------+\n+~~~ {.notrust}\n+          List box             List box           List box            List box\n+        +--------------+    +--------------+    +--------------+    +--------------+\n+list -> | Cons | 1 | ~ | -> | Cons | 2 | ~ | -> | Cons | 3 | ~ | -> | Nil          |\n+        +--------------+    +--------------+    +--------------+    +--------------+\n+~~~\n \n > ***Note:*** the above diagram shows the logical contents of the enum. The actual\n > memory layout of the enum may vary. For example, for the `List` enum shown\n@@ -1173,15 +1175,15 @@ ownership of a list to be passed in rather than just mutating it in-place.\n The obvious signature for a `List` equality comparison is the following:\n \n ~~~{.ignore}\n-fn eq(xs: List, ys: List) -> bool { ... }\n+fn eq(xs: List, ys: List) -> bool { /* ... */ }\n ~~~\n \n However, this will cause both lists to be moved into the function. Ownership\n isn't required to compare the lists, so the function should take *references*\n (&T) instead.\n \n ~~~{.ignore}\n-fn eq(xs: &List, ys: &List) -> bool { ... }\n+fn eq(xs: &List, ys: &List) -> bool { /* ... */ }\n ~~~\n \n A reference is a *non-owning* view of a value. A reference can be obtained with the `&` (address-of)\n@@ -1881,9 +1883,9 @@ A caller must in turn have a compatible pointer type to call the method.\n #     Rectangle(Point, Point)\n # }\n impl Shape {\n-    fn draw_reference(&self) { ... }\n-    fn draw_owned(~self) { ... }\n-    fn draw_value(self) { ... }\n+    fn draw_reference(&self) { /* ... */ }\n+    fn draw_owned(~self) { /* ... */ }\n+    fn draw_value(self) { /* ... */ }\n }\n \n let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n@@ -1906,9 +1908,9 @@ to a reference.\n #     Rectangle(Point, Point)\n # }\n # impl Shape {\n-#    fn draw_reference(&self) { ... }\n-#    fn draw_owned(~self) { ... }\n-#    fn draw_value(self) { ... }\n+#    fn draw_reference(&self) { /* ... */ }\n+#    fn draw_owned(~self) { /* ... */ }\n+#    fn draw_value(self) { /* ... */ }\n # }\n # let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n // As with typical function arguments, managed and owned pointers\n@@ -1934,8 +1936,8 @@ These methods are the preferred way to define constructor functions.\n \n ~~~~ {.ignore}\n impl Circle {\n-    fn area(&self) -> f64 { ... }\n-    fn new(area: f64) -> Circle { ... }\n+    fn area(&self) -> f64 { /* ... */ }\n+    fn new(area: f64) -> Circle { /* ... */ }\n }\n ~~~~\n \n@@ -2395,8 +2397,8 @@ to an object:\n # fn new_rectangle() -> Rectangle { true }\n # fn draw_all(shapes: &[~Drawable]) {}\n \n-impl Drawable for Circle { fn draw(&self) { ... } }\n-impl Drawable for Rectangle { fn draw(&self) { ... } }\n+impl Drawable for Circle { fn draw(&self) { /* ... */ } }\n+impl Drawable for Rectangle { fn draw(&self) { /* ... */ } }\n \n let c: ~Circle = ~new_circle();\n let r: ~Rectangle = ~new_rectangle();\n@@ -2510,7 +2512,7 @@ use std::f64::consts::PI;\n # impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / PI).sqrt() } }\n # impl Shape for CircleStruct { fn area(&self) -> f64 { PI * square(self.radius) } }\n \n-let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f};\n+let concrete = @CircleStruct{center:Point{x:3.0,y:4.0},radius:5.0};\n let mycircle: @Circle = concrete as @Circle;\n let nonsense = mycircle.radius() * mycircle.area();\n ~~~\n@@ -2667,8 +2669,8 @@ mod farm {\n     }\n \n     impl Farm {\n-        fn feed_chickens(&self) { ... }\n-        pub fn add_chicken(&self, c: Chicken) { ... }\n+        fn feed_chickens(&self) { /* ... */ }\n+        pub fn add_chicken(&self, c: Chicken) { /* ... */ }\n     }\n \n     pub fn feed_animals(farm: &Farm) {\n@@ -3141,7 +3143,7 @@ Now for something that you can actually compile yourself.\n \n We define two crates, and use one of them as a library in the other.\n \n-~~~~\n+~~~~{.ignore}\n // `world.rs`\n #[crate_id = \"world#0.42\"];\n # extern crate extra;"}]}