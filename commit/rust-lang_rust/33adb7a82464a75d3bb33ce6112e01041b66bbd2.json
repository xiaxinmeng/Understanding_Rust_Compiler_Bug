{"sha": "33adb7a82464a75d3bb33ce6112e01041b66bbd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYWRiN2E4MjQ2NGE3NWQzYmIzM2NlNjExMmUwMTA0MWI2NmJiZDI=", "commit": {"author": {"name": "Tim Chevalier", "email": "catamorphism@gmail.com", "date": "2012-10-17T20:05:04Z"}, "committer": {"name": "Tim Chevalier", "email": "catamorphism@gmail.com", "date": "2012-10-17T20:05:04Z"}, "message": "Merge pull request #3739 from killerswan/usagemsg\n\nAdd a module to getopts for verbose option group declaration (and use it in rustc)", "tree": {"sha": "5742e15946f42d3e3b1d58e005e546bf611ca379", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5742e15946f42d3e3b1d58e005e546bf611ca379"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33adb7a82464a75d3bb33ce6112e01041b66bbd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33adb7a82464a75d3bb33ce6112e01041b66bbd2", "html_url": "https://github.com/rust-lang/rust/commit/33adb7a82464a75d3bb33ce6112e01041b66bbd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33adb7a82464a75d3bb33ce6112e01041b66bbd2/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbc90b6bf6082f32cccef1011ac6b862a02957c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc90b6bf6082f32cccef1011ac6b862a02957c4", "html_url": "https://github.com/rust-lang/rust/commit/bbc90b6bf6082f32cccef1011ac6b862a02957c4"}, {"sha": "32baf1c54c4214f5a50da53979008ef9bcdad359", "url": "https://api.github.com/repos/rust-lang/rust/commits/32baf1c54c4214f5a50da53979008ef9bcdad359", "html_url": "https://github.com/rust-lang/rust/commit/32baf1c54c4214f5a50da53979008ef9bcdad359"}], "stats": {"total": 614, "additions": 546, "deletions": 68}, "files": [{"sha": "da1defc38b18ba8c85cfaca755902c6843e109f8", "filename": "src/libcore/str.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/33adb7a82464a75d3bb33ce6112e01041b66bbd2/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33adb7a82464a75d3bb33ce6112e01041b66bbd2/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=33adb7a82464a75d3bb33ce6112e01041b66bbd2", "patch": "@@ -203,6 +203,13 @@ pub pure fn connect(v: &[~str], sep: &str) -> ~str {\n     move s\n }\n \n+/// Given a string, make a new string with repeated copies of it\n+pub fn repeat(ss: &str, nn: uint) -> ~str {\n+    let mut acc = ~\"\";\n+    for nn.times { acc += ss; }\n+    return acc;\n+}\n+\n /*\n Section: Adding to and removing from a string\n */\n@@ -573,6 +580,40 @@ pub pure fn words(s: &str) -> ~[~str] {\n     split_nonempty(s, |c| char::is_whitespace(c))\n }\n \n+/** Split a string into a vector of substrings,\n+ *  each of which is less than a limit\n+ */\n+pub fn split_within(ss: &str, lim: uint) -> ~[~str] {\n+    let words = str::words(ss);\n+\n+    // empty?\n+    if words == ~[] { return ~[]; }\n+\n+    let mut rows : ~[~str] = ~[];\n+    let mut row  : ~str    = ~\"\";\n+\n+    for words.each |wptr| {\n+        let word = *wptr;\n+\n+        // if adding this word to the row would go over the limit,\n+        // then start a new row\n+        if str::len(row) + str::len(word) + 1 > lim {\n+            rows += [row]; // save previous row\n+            row = word;    // start a new one\n+        } else {\n+            if str::len(row) > 0 { row += ~\" \" } // separate words\n+            row += word;  // append to this row\n+        }\n+    }\n+\n+    // save the last row\n+    if row != ~\"\" { rows += [row]; }\n+\n+    return rows;\n+}\n+\n+\n+\n /// Convert a string to lowercase. ASCII only\n pub pure fn to_lower(s: &str) -> ~str {\n     map(s,\n@@ -2479,6 +2520,18 @@ mod tests {\n         assert ~[] == words(~\"\");\n     }\n \n+    #[test]\n+    fn test_split_within() {\n+        assert split_within(~\"\", 0) == ~[];\n+        assert split_within(~\"\", 15) == ~[];\n+        assert split_within(~\"hello\", 15) == ~[~\"hello\"];\n+\n+        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        assert split_within(data, 15) == ~[~\"Mary had a little\",\n+                                           ~\"lamb Little\",\n+                                           ~\"lamb\"];\n+    }\n+\n     #[test]\n     fn test_find_str() {\n         // byte positions\n@@ -2554,6 +2607,15 @@ mod tests {\n         t(~[~\"hi\"], ~\" \", ~\"hi\");\n     }\n \n+    #[test]\n+    fn test_repeat() {\n+        assert repeat(~\"x\", 4) == ~\"xxxx\";\n+        assert repeat(~\"hi\", 4) == ~\"hihihihi\";\n+        assert repeat(~\"\u0e44\u0e17\u534e\", 3) == ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\";\n+        assert repeat(~\"\", 4) == ~\"\";\n+        assert repeat(~\"hi\", 0) == ~\"\";\n+    }\n+\n     #[test]\n     fn test_to_upper() {\n         // libc::toupper, and hence str::to_upper"}, {"sha": "8d77b88aba23083b0870600006a3d08e4e1a7053", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 409, "deletions": 3, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/33adb7a82464a75d3bb33ce6112e01041b66bbd2/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33adb7a82464a75d3bb33ce6112e01041b66bbd2/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=33adb7a82464a75d3bb33ce6112e01041b66bbd2", "patch": "@@ -82,7 +82,7 @@ pub type Opt = {name: Name, hasarg: HasArg, occur: Occur};\n \n fn mkname(nm: &str) -> Name {\n     let unm = str::from_slice(nm);\n-    return if str::len(nm) == 1u {\n+    return if nm.len() == 1u {\n             Short(str::char_at(unm, 0u))\n         } else { Long(unm) };\n }\n@@ -114,6 +114,22 @@ impl Occur : Eq {\n     pure fn ne(other: &Occur) -> bool { !self.eq(other) }\n }\n \n+impl HasArg : Eq {\n+    pure fn eq(other: &HasArg) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &HasArg) -> bool { !self.eq(other) }\n+}\n+\n+impl Opt : Eq {\n+    pure fn eq(other: &Opt) -> bool {\n+        self.name   == (*other).name   &&\n+        self.hasarg == (*other).hasarg &&\n+        self.occur  == (*other).occur\n+    }\n+    pure fn ne(other: &Opt) -> bool { !self.eq(other) }\n+}\n+\n /// Create an option that is required and takes an argument\n pub fn reqopt(name: &str) -> Opt {\n     return {name: mkname(name), hasarg: Yes, occur: Req};\n@@ -150,8 +166,29 @@ enum Optval { Val(~str), Given, }\n  */\n pub type Matches = {opts: ~[Opt], vals: ~[~[Optval]], free: ~[~str]};\n \n+impl Optval : Eq {\n+    pure fn eq(other: &Optval) -> bool {\n+        match self {\n+            Val(ref s) => match *other { Val (ref os) => s == os,\n+                                          Given => false },\n+            Given       => match *other { Val(_) => false,\n+                                          Given => true }\n+        }\n+    }\n+    pure fn ne(other: &Optval) -> bool { !self.eq(other) }\n+}\n+\n+impl Matches : Eq {\n+    pure fn eq(other: &Matches) -> bool {\n+        self.opts == (*other).opts &&\n+        self.vals == (*other).vals &&\n+        self.free == (*other).free\n+    }\n+    pure fn ne(other: &Matches) -> bool { !self.eq(other) }\n+}\n+\n fn is_arg(arg: &str) -> bool {\n-    return str::len(arg) > 1u && arg[0] == '-' as u8;\n+    return arg.len() > 1u && arg[0] == '-' as u8;\n }\n \n fn name_str(nm: &Name) -> ~str {\n@@ -177,6 +214,35 @@ pub enum Fail_ {\n     UnexpectedArgument(~str),\n }\n \n+impl Fail_ : Eq {\n+    // this whole thing should be easy to infer...\n+    pure fn eq(other: &Fail_) -> bool {\n+        match self {\n+            ArgumentMissing(ref s) => {\n+                match *other { ArgumentMissing(ref so)    => s == so,\n+                               _                          => false }\n+            }\n+            UnrecognizedOption(ref s) => {\n+                match *other { UnrecognizedOption(ref so) => s == so,\n+                               _                          => false }\n+            }\n+            OptionMissing(ref s) => {\n+                match *other { OptionMissing(ref so)      => s == so,\n+                               _                          => false }\n+            }\n+            OptionDuplicated(ref s) => {\n+                match *other { OptionDuplicated(ref so)   => s == so,\n+                               _                          => false }\n+            }\n+            UnexpectedArgument(ref s) => {\n+                match *other { UnexpectedArgument(ref so) => s == so,\n+                               _                          => false }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &Fail_) -> bool { !self.eq(other) }\n+}\n+\n /// Convert a `fail_` enum into an error string\n pub fn fail_str(f: Fail_) -> ~str {\n     return match f {\n@@ -220,7 +286,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n     let mut i = 0u;\n     while i < l {\n         let cur = args[i];\n-        let curlen = str::len(cur);\n+        let curlen = cur.len();\n         if !is_arg(cur) {\n             free.push(cur);\n         } else if cur == ~\"--\" {\n@@ -444,6 +510,194 @@ impl FailType : Eq {\n     pure fn ne(other: &FailType) -> bool { !self.eq(other) }\n }\n \n+/** A module which provides a way to specify descriptions and\n+ *  groups of short and long option names, together.\n+ */\n+pub mod groups {\n+\n+    /** one group of options, e.g., both -h and --help, along with\n+     * their shared description and properties\n+     */\n+    pub type OptGroup = {\n+        short_name: ~str,\n+        long_name: ~str,\n+        hint: ~str,\n+        desc: ~str,\n+        hasarg: HasArg,\n+        occur: Occur\n+    };\n+\n+    impl OptGroup : Eq {\n+        pure fn eq(other: &OptGroup) -> bool {\n+            self.short_name == (*other).short_name &&\n+            self.long_name  == (*other).long_name  &&\n+            self.hint       == (*other).hint       &&\n+            self.desc       == (*other).desc       &&\n+            self.hasarg     == (*other).hasarg     &&\n+            self.occur      == (*other).occur\n+        }\n+        pure fn ne(other: &OptGroup) -> bool { !self.eq(other) }\n+    }\n+\n+    /// Create a long option that is required and takes an argument\n+    pub fn reqopt(short_name: &str, long_name: &str,\n+                  desc: &str, hint: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert len == 1 || len == 0;\n+        return {short_name: str::from_slice(short_name),\n+                long_name: str::from_slice(long_name),\n+                hint: str::from_slice(hint),\n+                desc: str::from_slice(desc),\n+                hasarg: Yes,\n+                occur: Req};\n+    }\n+\n+    /// Create a long option that is optional and takes an argument\n+    pub fn optopt(short_name: &str, long_name: &str,\n+                  desc: &str, hint: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert len == 1 || len == 0;\n+        return {short_name: str::from_slice(short_name),\n+                long_name: str::from_slice(long_name),\n+                hint: str::from_slice(hint),\n+                desc: str::from_slice(desc),\n+                hasarg: Yes,\n+                occur: Optional};\n+    }\n+\n+    /// Create a long option that is optional and does not take an argument\n+    pub fn optflag(short_name: &str, long_name: &str,\n+                   desc: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert len == 1 || len == 0;\n+        return {short_name: str::from_slice(short_name),\n+                long_name: str::from_slice(long_name),\n+                hint: ~\"\",\n+                desc: str::from_slice(desc),\n+                hasarg: No,\n+                occur: Optional};\n+    }\n+\n+    /// Create a long option that is optional and takes an optional argument\n+    pub fn optflagopt(short_name: &str, long_name: &str,\n+                      desc: &str, hint: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert len == 1 || len == 0;\n+        return {short_name: str::from_slice(short_name),\n+                long_name: str::from_slice(long_name),\n+                hint: str::from_slice(hint),\n+                desc: str::from_slice(desc),\n+                hasarg: Maybe,\n+                occur: Optional};\n+    }\n+\n+    /**\n+     * Create a long option that is optional, takes an argument, and may occur\n+     * multiple times\n+     */\n+    pub fn optmulti(short_name: &str, long_name: &str,\n+                    desc: &str, hint: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert len == 1 || len == 0;\n+        return {short_name: str::from_slice(short_name),\n+                long_name: str::from_slice(long_name),\n+                hint: str::from_slice(hint),\n+                desc: str::from_slice(desc),\n+                hasarg: Yes,\n+                occur: Multi};\n+    }\n+\n+    // translate OptGroup into Opt\n+    // (both short and long names correspond to different Opts)\n+    pub fn long_to_short(lopt: &OptGroup) -> ~[Opt] {\n+        match ((*lopt).short_name.len(),\n+               (*lopt).long_name.len()) {\n+\n+           (0,0) => fail ~\"this long-format option was given no name\",\n+\n+           (0,_) => ~[{name:   Long(((*lopt).long_name)),\n+                       hasarg: (*lopt).hasarg,\n+                       occur:  (*lopt).occur}],\n+\n+           (1,0) => ~[{name:  Short(str::char_at((*lopt).short_name, 0)),\n+                       hasarg: (*lopt).hasarg,\n+                       occur:  (*lopt).occur}],\n+\n+           (1,_) => ~[{name:   Short(str::char_at((*lopt).short_name, 0)),\n+                       hasarg: (*lopt).hasarg,\n+                       occur:  (*lopt).occur},\n+                      {name:   Long(((*lopt).long_name)),\n+                       hasarg: (*lopt).hasarg,\n+                       occur:  (*lopt).occur}],\n+\n+           (_,_) => fail ~\"something is wrong with the long-form opt\"\n+        }\n+    }\n+\n+    /*\n+     * Parse command line args with the provided long format options\n+     */\n+    pub fn getopts(args: &[~str], opts: &[OptGroup]) -> Result {\n+        ::getopts::getopts(args, vec::flat_map(opts, long_to_short))\n+    }\n+\n+    /**\n+     * Derive a usage message from a set of long options\n+     */\n+    pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n+\n+        let desc_sep = ~\"\\n\" + str::repeat(~\" \", 24);\n+\n+        let rows = vec::map(opts, |optref| {\n+            let short_name = (*optref).short_name;\n+            let long_name = (*optref).long_name;\n+            let hint = (*optref).hint;\n+            let desc = (*optref).desc;\n+            let hasarg = (*optref).hasarg;\n+\n+            let mut row = str::repeat(~\" \", 4);\n+\n+            // short option\n+            row += match short_name.len() {\n+                0 => ~\"\",\n+                1 => ~\"-\" + short_name + \" \",\n+                _ => fail ~\"the short name should only be 1 char long\",\n+            };\n+\n+            // long option\n+            row += match long_name.len() {\n+                0 => ~\"\",\n+                _ => ~\"--\" + long_name + \" \",\n+            };\n+\n+            // arg\n+            row += match hasarg {\n+                No    => ~\"\",\n+                Yes   => hint,\n+                Maybe => ~\"[\" + hint + ~\"]\",\n+            };\n+\n+            // here we just need to indent the start of the description\n+            let rowlen = row.len();\n+            row += if rowlen < 24 {\n+                str::repeat(~\" \", 24 - rowlen)\n+            } else {\n+                desc_sep\n+            };\n+\n+            // wrapped description\n+            row += str::connect(str::split_within(desc, 54), desc_sep);\n+\n+            row\n+        });\n+\n+        return str::from_slice(brief)    +\n+               ~\"\\n\\nOptions:\\n\"         +\n+               str::connect(rows, ~\"\\n\") +\n+               ~\"\\n\\n\";\n+    }\n+} // end groups module\n+\n #[cfg(test)]\n mod tests {\n     #[legacy_exports];\n@@ -943,6 +1197,158 @@ mod tests {\n         assert opts_present(matches, ~[~\"L\"]);\n         assert opts_str(matches, ~[~\"L\"]) == ~\"foo\";\n     }\n+\n+    #[test]\n+    fn test_groups_reqopt() {\n+        let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n+        assert opt == { short_name: ~\"b\",\n+                        long_name: ~\"banana\",\n+                        hint: ~\"VAL\",\n+                        desc: ~\"some bananas\",\n+                        hasarg: Yes,\n+                        occur: Req }\n+    }\n+\n+    #[test]\n+    fn test_groups_optopt() {\n+        let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n+        assert opt == { short_name: ~\"a\",\n+                        long_name: ~\"apple\",\n+                        hint: ~\"VAL\",\n+                        desc: ~\"some apples\",\n+                        hasarg: Yes,\n+                        occur: Optional }\n+    }\n+\n+    #[test]\n+    fn test_groups_optflag() {\n+        let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n+        assert opt == { short_name: ~\"k\",\n+                        long_name: ~\"kiwi\",\n+                        hint: ~\"\",\n+                        desc: ~\"some kiwis\",\n+                        hasarg: No,\n+                        occur: Optional }\n+    }\n+\n+    #[test]\n+    fn test_groups_optflagopt() {\n+        let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n+                                       ~\"some pineapples\", ~\"VAL\");\n+        assert opt == { short_name: ~\"p\",\n+                        long_name: ~\"pineapple\",\n+                        hint: ~\"VAL\",\n+                        desc: ~\"some pineapples\",\n+                        hasarg: Maybe,\n+                        occur: Optional }\n+    }\n+\n+    #[test]\n+    fn test_groups_optmulti() {\n+        let opt = groups::optmulti(~\"l\", ~\"lime\",\n+                                     ~\"some limes\", ~\"VAL\");\n+        assert opt == { short_name: ~\"l\",\n+                        long_name: ~\"lime\",\n+                        hint: ~\"VAL\",\n+                        desc: ~\"some limes\",\n+                        hasarg: Yes,\n+                        occur: Multi }\n+    }\n+\n+    #[test]\n+    fn test_groups_long_to_short() {\n+        let short = ~[reqopt(~\"b\"), reqopt(~\"banana\")];\n+        let verbose = groups::reqopt(~\"b\", ~\"banana\",\n+                                       ~\"some bananas\", ~\"VAL\");\n+\n+        assert groups::long_to_short(&verbose) == short;\n+    }\n+\n+    #[test]\n+    fn test_groups_getopts() {\n+        let short = ~[\n+            reqopt(~\"b\"), reqopt(~\"banana\"),\n+            optopt(~\"a\"), optopt(~\"apple\"),\n+            optflag(~\"k\"), optflagopt(~\"kiwi\"),\n+            optflagopt(~\"p\"),\n+            optmulti(~\"l\")\n+        ];\n+\n+        let verbose = ~[\n+            groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n+            groups::optopt(~\"a\", ~\"apple\", ~\"Desc\", ~\"VAL\"),\n+            groups::optflag(~\"k\", ~\"kiwi\", ~\"Desc\"),\n+            groups::optflagopt(~\"p\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+            groups::optmulti(~\"l\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+        ];\n+\n+        let sample_args = ~[~\"-k\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n+                            ~\"-p\", ~\"16\", ~\"l\", ~\"35\"];\n+\n+        // NOTE: we should sort before comparing\n+        assert getopts(sample_args, short)\n+            == groups::getopts(sample_args, verbose);\n+    }\n+\n+    #[test]\n+    fn test_groups_usage() {\n+        let optgroups = ~[\n+            groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n+            groups::optopt(~\"a\", ~\"012345678901234567890123456789\",\n+                             ~\"Desc\", ~\"VAL\"),\n+            groups::optflag(~\"k\", ~\"kiwi\", ~\"Desc\"),\n+            groups::optflagopt(~\"p\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+            groups::optmulti(~\"l\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+        ];\n+\n+        let expected =\n+~\"Usage: fruits\n+\n+Options:\n+    -b --banana VAL     Desc\n+    -a --012345678901234567890123456789 VAL\n+                        Desc\n+    -k --kiwi           Desc\n+    -p [VAL]            Desc\n+    -l VAL              Desc\n+\n+\";\n+\n+        let generated_usage = groups::usage(~\"Usage: fruits\", optgroups);\n+\n+        debug!(\"expected: <<%s>>\", expected);\n+        debug!(\"generated: <<%s>>\", generated_usage);\n+        assert generated_usage == expected;\n+    }\n+\n+    #[test]\n+    fn test_groups_usage_description_wrapping() {\n+        // indentation should be 24 spaces\n+        // lines wrap after 78: or rather descriptions wrap after 54\n+\n+        let optgroups = ~[\n+           groups::optflag(~\"k\", ~\"kiwi\",\n+           ~\"This is a long description which won't be wrapped..+..\"), // 54\n+           groups::optflag(~\"a\", ~\"apple\",\n+           ~\"This is a long description which _will_ be wrapped..+..\"), // 55\n+        ];\n+\n+        let expected =\n+~\"Usage: fruits\n+\n+Options:\n+    -k --kiwi           This is a long description which won't be wrapped..+..\n+    -a --apple          This is a long description which _will_ be\n+                        wrapped..+..\n+\n+\";\n+\n+        let usage = groups::usage(~\"Usage: fruits\", optgroups);\n+\n+        debug!(\"expected: <<%s>>\", expected);\n+        debug!(\"generated: <<%s>>\", usage);\n+        assert usage == expected\n+    }\n }\n \n // Local Variables:"}, {"sha": "934a02d6dd3e3a0f0321c37a04afa70c1e41fe3b", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 68, "deletions": 24, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/33adb7a82464a75d3bb33ce6112e01041b66bbd2/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33adb7a82464a75d3bb33ce6112e01041b66bbd2/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=33adb7a82464a75d3bb33ce6112e01041b66bbd2", "patch": "@@ -10,8 +10,10 @@ use util::ppaux;\n use back::link;\n use result::{Ok, Err};\n use std::getopts;\n+use std::getopts::{opt_present};\n+use std::getopts::groups;\n+use std::getopts::groups::{optopt, optmulti, optflag, optflagopt, getopts};\n use io::WriterUtil;\n-use getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n use back::{x86, x86_64};\n use std::map::HashMap;\n use lib::llvm::llvm;\n@@ -623,27 +625,69 @@ fn parse_pretty(sess: Session, &&name: ~str) -> pp_mode {\n     }\n }\n \n-fn opts() -> ~[getopts::Opt] {\n-    return ~[optflag(~\"h\"), optflag(~\"help\"),\n-             optflag(~\"v\"), optflag(~\"version\"),\n-          optflag(~\"emit-llvm\"), optflagopt(~\"pretty\"),\n-          optflag(~\"ls\"), optflag(~\"parse-only\"), optflag(~\"no-trans\"),\n-          optflag(~\"O\"), optopt(~\"opt-level\"), optmulti(~\"L\"), optflag(~\"S\"),\n-          optopt(~\"o\"), optopt(~\"out-dir\"), optflag(~\"xg\"),\n-          optflag(~\"c\"), optflag(~\"g\"), optflag(~\"save-temps\"),\n-          optopt(~\"sysroot\"), optopt(~\"target\"),\n-          optflag(~\"jit\"),\n-\n-          optmulti(~\"W\"), optmulti(~\"warn\"),\n-          optmulti(~\"A\"), optmulti(~\"allow\"),\n-          optmulti(~\"D\"), optmulti(~\"deny\"),\n-          optmulti(~\"F\"), optmulti(~\"forbid\"),\n-\n-          optmulti(~\"Z\"),\n-\n-          optmulti(~\"cfg\"), optflag(~\"test\"),\n-          optflag(~\"lib\"), optflag(~\"bin\"),\n-          optflag(~\"static\"), optflag(~\"gc\")];\n+// rustc command line options\n+fn optgroups() -> ~[getopts::groups::OptGroup] {\n+ ~[\n+  optflag(~\"\",  ~\"bin\", ~\"Compile an executable crate (default)\"),\n+  optflag(~\"c\", ~\"\",    ~\"Compile and assemble, but do not link\"),\n+  optmulti(~\"\", ~\"cfg\", ~\"Configure the compilation\n+                          environment\", ~\"SPEC\"),\n+  optflag(~\"\",  ~\"emit-llvm\",\n+                        ~\"Produce an LLVM bitcode file\"),\n+  optflag(~\"g\", ~\"\",    ~\"Produce debug info (experimental)\"),\n+  optflag(~\"\",  ~\"gc\",  ~\"Garbage collect shared data (experimental)\"),\n+  optflag(~\"h\", ~\"help\",~\"Display this message\"),\n+  optmulti(~\"L\", ~\"\",   ~\"Add a directory to the library search path\",\n+                              ~\"PATH\"),\n+  optflag(~\"\",  ~\"lib\", ~\"Compile a library crate\"),\n+  optflag(~\"\",  ~\"ls\",  ~\"List the symbols defined by a library crate\"),\n+  optflag(~\"\",  ~\"jit\", ~\"Execute using JIT (experimental)\"),\n+  optflag(~\"\", ~\"no-trans\",\n+                        ~\"Run all passes except translation; no output\"),\n+  optflag(~\"O\", ~\"\",    ~\"Equivalent to --opt-level=2\"),\n+  optopt(~\"o\", ~\"\",     ~\"Write output to <filename>\", ~\"FILENAME\"),\n+  optopt(~\"\", ~\"opt-level\",\n+                        ~\"Optimize with possible levels 0-3\", ~\"LEVEL\"),\n+  optopt( ~\"\",  ~\"out-dir\",\n+                        ~\"Write output to compiler-chosen filename\n+                          in <dir>\", ~\"DIR\"),\n+  optflag(~\"\", ~\"parse-only\",\n+                        ~\"Parse only; do not compile, assemble, or link\"),\n+  optflagopt(~\"\", ~\"pretty\",\n+                        ~\"Pretty-print the input instead of compiling;\n+                          valid types are: normal (un-annotated source),\n+                          expanded (crates expanded),\n+                          typed (crates expanded, with type annotations),\n+                          or identified (fully parenthesized,\n+                          AST nodes and blocks with IDs)\", ~\"TYPE\"),\n+  optflag(~\"S\", ~\"\",    ~\"Compile only; do not assemble or link\"),\n+  optflag(~\"\", ~\"xg\",   ~\"Extra debugging info (experimental)\"),\n+  optflag(~\"\", ~\"save-temps\",\n+                        ~\"Write intermediate files (.bc, .opt.bc, .o)\n+                          in addition to normal output\"),\n+  optflag(~\"\", ~\"static\",\n+                        ~\"Use or produce static libraries or binaries\n+                         (experimental)\"),\n+  optopt(~\"\", ~\"sysroot\",\n+                        ~\"Override the system root\", ~\"PATH\"),\n+  optflag(~\"\", ~\"test\", ~\"Build a test harness\"),\n+  optopt(~\"\", ~\"target\",\n+                        ~\"Target triple cpu-manufacturer-kernel[-os]\n+                          to compile for (see\n+         http://sources.redhat.com/autobook/autobook/autobook_17.html\n+                          for detail)\", ~\"TRIPLE\"),\n+  optmulti(~\"W\", ~\"warn\",\n+                        ~\"Set lint warnings\", ~\"OPT\"),\n+  optmulti(~\"A\", ~\"allow\",\n+                        ~\"Set lint allowed\", ~\"OPT\"),\n+  optmulti(~\"D\", ~\"deny\",\n+                        ~\"Set lint denied\", ~\"OPT\"),\n+  optmulti(~\"F\", ~\"forbid\",\n+                        ~\"Set lint forbidden\", ~\"OPT\"),\n+  optmulti(~\"Z\", ~\"\",   ~\"Set internal debugging options\", \"FLAG\"),\n+  optflag( ~\"v\", ~\"version\",\n+                        ~\"Print version info and exit\"),\n+ ]\n }\n \n type output_filenames = @{out_filename:Path, obj_filename:Path};\n@@ -741,7 +785,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            match getopts::getopts(~[~\"--test\"], opts()) {\n+            match getopts(~[~\"--test\"], optgroups()) {\n               Ok(m) => m,\n               Err(f) => fail ~\"test_switch_implies_cfg_test: \" +\n                              getopts::fail_str(f)\n@@ -758,7 +802,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n-            match getopts::getopts(~[~\"--test\", ~\"--cfg=test\"], opts()) {\n+            match getopts(~[~\"--test\", ~\"--cfg=test\"], optgroups()) {\n               Ok(m) => m,\n               Err(f) => {\n                 fail ~\"test_switch_implies_cfg_test_unless_cfg_test: \" +"}, {"sha": "e52f34f4645da8376c9f394a8b54120fe45d8b92", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 7, "deletions": 41, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/33adb7a82464a75d3bb33ce6112e01041b66bbd2/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33adb7a82464a75d3bb33ce6112e01041b66bbd2/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=33adb7a82464a75d3bb33ce6112e01041b66bbd2", "patch": "@@ -16,6 +16,7 @@ use io::ReaderUtil;\n use std::getopts;\n use std::map::HashMap;\n use getopts::{opt_present};\n+use getopts::groups;\n use rustc::driver::driver::*;\n use syntax::codemap;\n use syntax::diagnostic;\n@@ -31,46 +32,11 @@ fn version(argv0: &str) {\n }\n \n fn usage(argv0: &str) {\n-    io::println(fmt!(\"Usage: %s [options] <input>\\n\", argv0) +\n-                 ~\"\n-Options:\n-\n-    --bin              Compile an executable crate (default)\n-    -c                 Compile and assemble, but do not link\n-    --cfg <cfgspec>    Configure the compilation environment\n-    --emit-llvm        Produce an LLVM bitcode file\n-    -g                 Produce debug info (experimental)\n-    --gc               Garbage collect shared data (experimental/temporary)\n-    -h --help          Display this message\n-    -L <path>          Add a directory to the library search path\n-    --lib              Compile a library crate\n-    --ls               List the symbols defined by a compiled library crate\n-    --jit              Execute using JIT (experimental)\n-    --no-trans         Run all passes except translation; no output\n-    -O                 Equivalent to --opt-level=2\n-    -o <filename>      Write output to <filename>\n-    --opt-level <lvl>  Optimize with possible levels 0-3\n-    --out-dir <dir>    Write output to compiler-chosen filename in <dir>\n-    --parse-only       Parse only; do not compile, assemble, or link\n-    --pretty [type]    Pretty-print the input instead of compiling;\n-                       valid types are: normal (un-annotated source),\n-                       expanded (crates expanded), typed (crates expanded,\n-                       with type annotations), or identified (fully\n-                       parenthesized, AST nodes and blocks with IDs)\n-    -S                 Compile only; do not assemble or link\n-    --save-temps       Write intermediate files (.bc, .opt.bc, .o)\n-                       in addition to normal output\n-    --static           Use or produce static libraries or binaries\n-                       (experimental)\n-    --sysroot <path>   Override the system root\n-    --test             Build a test harness\n-    --target <triple>  Target cpu-manufacturer-kernel[-os] to compile for\n-                       (default: host triple)\n-                       (see http://sources.redhat.com/autobook/autobook/\n-                       autobook_17.html for detail)\n-    -W help            Print 'lint' options and default settings\n-    -Z help            Print internal options for debugging rustc\n-    -v --version       Print version info and exit\n+    let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n+    io::println(groups::usage(message, optgroups()) +\n+                ~\"Additional help:\n+    -W help             Print 'lint' options and default settings\n+    -Z help             Print internal options for debugging rustc\n \");\n }\n \n@@ -127,7 +93,7 @@ fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n     if args.is_empty() { usage(binary); return; }\n \n     let matches =\n-        match getopts::getopts(args, opts()) {\n+        match getopts::groups::getopts(args, optgroups()) {\n           Ok(m) => m,\n           Err(f) => {\n             early_error(demitter, getopts::fail_str(f))"}]}