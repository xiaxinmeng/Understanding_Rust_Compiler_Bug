{"sha": "d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZWM4ZWExY2MwYzJiODU0MDZhZmYyY2Y1YjU1YmY1YWE1NTFkOGM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-05-06T21:48:56Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-05-15T10:37:33Z"}, "message": "Implement RFC 2056 - trivial constraints", "tree": {"sha": "aec8a516f6f8fe742a2ee6c18b9cdf9b32941593", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aec8a516f6f8fe742a2ee6c18b9cdf9b32941593"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c", "html_url": "https://github.com/rust-lang/rust/commit/d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b17da2d7b0b0b59f7ac96b1702cfb0d23b05860", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b17da2d7b0b0b59f7ac96b1702cfb0d23b05860", "html_url": "https://github.com/rust-lang/rust/commit/0b17da2d7b0b0b59f7ac96b1702cfb0d23b05860"}], "stats": {"total": 74, "additions": 28, "deletions": 46}, "files": [{"sha": "ca62b421b320d5d858ec7ca98ba4a65e2970e559", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c", "patch": "@@ -641,17 +641,8 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let predicates: Vec<_> =\n         util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec())\n-        .filter(|p| !p.is_global()) // (*)\n         .collect();\n \n-    // (*) Any predicate like `i32: Trait<u32>` or whatever doesn't\n-    // need to be in the *environment* to be proven, so screen those\n-    // out. This is important for the soundness of inter-fn\n-    // caching. Note though that we should probably check that these\n-    // predicates hold at the point where the environment is\n-    // constructed, but I am not currently doing so out of laziness.\n-    // -nmatsakis\n-\n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n            predicates);\n "}, {"sha": "bd7ec4a12b0c635df7dc4aa5206ff63acc8e66d7", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d0ec8ea1cc0c2b85406aff2cf5b55bf5aa551d8c", "patch": "@@ -305,9 +305,6 @@ enum BuiltinImplConditions<'tcx> {\n     /// There is no built-in impl. There may be some other\n     /// candidate (a where-clause or user-defined impl).\n     None,\n-    /// There is *no* impl for this, builtin or not. Ignore\n-    /// all where-clauses.\n-    Never,\n     /// It is unknown whether there is an impl.\n     Ambiguous\n }\n@@ -781,13 +778,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                 mut obligation: TraitObligation<'tcx>)\n                                                 -> Result<EvaluationResult, OverflowError>\n     {\n-        debug!(\"evaluate_trait_predicate_recursively({:?})\",\n-               obligation);\n+        debug!(\"evaluate_trait_predicate_recursively({:?})\", obligation);\n \n-        if !self.intercrate.is_some() && obligation.is_global() {\n-            // If a param env is consistent, global obligations do not depend on its particular\n-            // value in order to work, so we can clear out the param env and get better\n-            // caching. (If the current param env is inconsistent, we don't care what happens).\n+        if self.intercrate.is_none() && obligation.is_global()\n+            && obligation.param_env.caller_bounds.iter().all(|bound| bound.needs_subst()) {\n+            // If a param env has no global bounds, global obligations do not\n+            // depend on its particular value in order to work, so we can clear\n+            // out the param env and get better caching.\n             debug!(\"evaluate_trait_predicate_recursively({:?}) - in global\", obligation);\n             obligation.param_env = obligation.param_env.without_caller_bounds();\n         }\n@@ -1451,22 +1448,22 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let sized_conditions = self.sized_conditions(obligation);\n             self.assemble_builtin_bound_candidates(sized_conditions,\n                                                    &mut candidates)?;\n-         } else if lang_items.unsize_trait() == Some(def_id) {\n-             self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n-         } else {\n-             if lang_items.clone_trait() == Some(def_id) {\n-                 // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n-                 // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n-                 // types have builtin support for `Clone`.\n-                 let clone_conditions = self.copy_clone_conditions(obligation);\n-                 self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n-             }\n-\n-             self.assemble_generator_candidates(obligation, &mut candidates)?;\n-             self.assemble_closure_candidates(obligation, &mut candidates)?;\n-             self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n-             self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-             self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n+        } else if lang_items.unsize_trait() == Some(def_id) {\n+            self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+        } else {\n+            if lang_items.clone_trait() == Some(def_id) {\n+                // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n+                // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n+                // types have builtin support for `Clone`.\n+                let clone_conditions = self.copy_clone_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n+            }\n+\n+            self.assemble_generator_candidates(obligation, &mut candidates)?;\n+            self.assemble_closure_candidates(obligation, &mut candidates)?;\n+            self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n+            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+            self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n         }\n \n         self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n@@ -2081,13 +2078,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     // BUILTIN BOUNDS\n     //\n     // These cover the traits that are built-in to the language\n-    // itself.  This includes `Copy` and `Sized` for sure. For the\n-    // moment, it also includes `Send` / `Sync` and a few others, but\n-    // those will hopefully change to library-defined traits in the\n-    // future.\n+    // itself: `Copy`, `Clone` and `Sized`.\n \n-    // HACK: if this returns an error, selection exits without considering\n-    // other impls.\n     fn assemble_builtin_bound_candidates<'o>(&mut self,\n                                              conditions: BuiltinImplConditions<'tcx>,\n                                              candidates: &mut SelectionCandidateSet<'tcx>)\n@@ -2106,14 +2098,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n                 Ok(candidates.ambiguous = true)\n             }\n-            BuiltinImplConditions::Never => { Err(Unimplemented) }\n         }\n     }\n \n     fn sized_conditions(&mut self, obligation: &TraitObligation<'tcx>)\n                      -> BuiltinImplConditions<'tcx>\n     {\n-        use self::BuiltinImplConditions::{Ambiguous, None, Never, Where};\n+        use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n         // NOTE: binder moved to (*)\n         let self_ty = self.infcx.shallow_resolve(\n@@ -2130,7 +2121,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder::dummy(Vec::new()))\n             }\n \n-            ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) | ty::TyForeign(..) => Never,\n+            ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) | ty::TyForeign(..) => None,\n \n             ty::TyTuple(tys) => {\n                 Where(ty::Binder::bind(tys.last().into_iter().cloned().collect()))\n@@ -2164,7 +2155,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let self_ty = self.infcx.shallow_resolve(\n             obligation.predicate.skip_binder().self_ty());\n \n-        use self::BuiltinImplConditions::{Ambiguous, None, Never, Where};\n+        use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n         match self_ty.sty {\n             ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n@@ -2182,7 +2173,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n             ty::TyGenerator(..) | ty::TyGeneratorWitness(..) | ty::TyForeign(..) |\n             ty::TyRef(_, _, hir::MutMutable) => {\n-                Never\n+                None\n             }\n \n             ty::TyArray(element_ty, _) => {\n@@ -2202,7 +2193,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 if is_copy_trait || is_clone_trait {\n                     Where(ty::Binder::bind(substs.upvar_tys(def_id, self.tcx()).collect()))\n                 } else {\n-                    Never\n+                    None\n                 }\n             }\n "}]}