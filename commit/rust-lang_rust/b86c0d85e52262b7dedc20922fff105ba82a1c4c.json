{"sha": "b86c0d85e52262b7dedc20922fff105ba82a1c4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NmMwZDg1ZTUyMjYyYjdkZWRjMjA5MjJmZmYxMDViYTgyYTFjNGM=", "commit": {"author": {"name": "pierwill", "email": "pierwill@users.noreply.github.com", "date": "2021-03-06T06:15:11Z"}, "committer": {"name": "pierwill", "email": "pierwill@users.noreply.github.com", "date": "2021-03-06T06:27:38Z"}, "message": "(std::net::parser): Fix capitalization of IP versions\n\nAlso add some missing punctuation in doc and code comments.", "tree": {"sha": "802a7bcd3d2b96c418d781612e7aa322cb37ede7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/802a7bcd3d2b96c418d781612e7aa322cb37ede7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b86c0d85e52262b7dedc20922fff105ba82a1c4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b86c0d85e52262b7dedc20922fff105ba82a1c4c", "html_url": "https://github.com/rust-lang/rust/commit/b86c0d85e52262b7dedc20922fff105ba82a1c4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b86c0d85e52262b7dedc20922fff105ba82a1c4c/comments", "author": {"login": "pierwill", "id": 19642016, "node_id": "MDQ6VXNlcjE5NjQyMDE2", "avatar_url": "https://avatars.githubusercontent.com/u/19642016?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pierwill", "html_url": "https://github.com/pierwill", "followers_url": "https://api.github.com/users/pierwill/followers", "following_url": "https://api.github.com/users/pierwill/following{/other_user}", "gists_url": "https://api.github.com/users/pierwill/gists{/gist_id}", "starred_url": "https://api.github.com/users/pierwill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pierwill/subscriptions", "organizations_url": "https://api.github.com/users/pierwill/orgs", "repos_url": "https://api.github.com/users/pierwill/repos", "events_url": "https://api.github.com/users/pierwill/events{/privacy}", "received_events_url": "https://api.github.com/users/pierwill/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pierwill", "id": 19642016, "node_id": "MDQ6VXNlcjE5NjQyMDE2", "avatar_url": "https://avatars.githubusercontent.com/u/19642016?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pierwill", "html_url": "https://github.com/pierwill", "followers_url": "https://api.github.com/users/pierwill/followers", "following_url": "https://api.github.com/users/pierwill/following{/other_user}", "gists_url": "https://api.github.com/users/pierwill/gists{/gist_id}", "starred_url": "https://api.github.com/users/pierwill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pierwill/subscriptions", "organizations_url": "https://api.github.com/users/pierwill/orgs", "repos_url": "https://api.github.com/users/pierwill/repos", "events_url": "https://api.github.com/users/pierwill/events{/privacy}", "received_events_url": "https://api.github.com/users/pierwill/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caca2121ffe4cb47d8ea2d9469c493995f57e0b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/caca2121ffe4cb47d8ea2d9469c493995f57e0b5", "html_url": "https://github.com/rust-lang/rust/commit/caca2121ffe4cb47d8ea2d9469c493995f57e0b5"}], "stats": {"total": 32, "additions": 16, "deletions": 16}, "files": [{"sha": "7064ed3ed236d9162b73fee4e4a2d03d1326d787", "filename": "library/std/src/net/parser.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b86c0d85e52262b7dedc20922fff105ba82a1c4c/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86c0d85e52262b7dedc20922fff105ba82a1c4c/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs?ref=b86c0d85e52262b7dedc20922fff105ba82a1c4c", "patch": "@@ -35,7 +35,7 @@ macro_rules! impl_helper {\n impl_helper! { u8 u16 u32 }\n \n struct Parser<'a> {\n-    // parsing as ASCII, so can use byte array\n+    // Parsing as ASCII, so can use byte array.\n     state: &'a [u8],\n }\n \n@@ -44,7 +44,7 @@ impl<'a> Parser<'a> {\n         Parser { state: input.as_bytes() }\n     }\n \n-    /// Run a parser, and restore the pre-parse state if it fails\n+    /// Run a parser, and restore the pre-parse state if it fails.\n     fn read_atomically<T, F>(&mut self, inner: F) -> Option<T>\n     where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n@@ -126,7 +126,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Read an IPv4 address\n+    /// Read an IPv4 address.\n     fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> {\n         self.read_atomically(|p| {\n             let mut groups = [0; 4];\n@@ -139,18 +139,18 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Read an IPV6 Address\n+    /// Read an IPv6 Address.\n     fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n-        /// Read a chunk of an ipv6 address into `groups`. Returns the number\n+        /// Read a chunk of an IPv6 address into `groups`. Returns the number\n         /// of groups read, along with a bool indicating if an embedded\n-        /// trailing ipv4 address was read. Specifically, read a series of\n-        /// colon-separated ipv6 groups (0x0000 - 0xFFFF), with an optional\n-        /// trailing embedded ipv4 address.\n+        /// trailing IPv4 address was read. Specifically, read a series of\n+        /// colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n+        /// trailing embedded IPv4 address.\n         fn read_groups(p: &mut Parser<'_>, groups: &mut [u16]) -> (usize, bool) {\n             let limit = groups.len();\n \n             for (i, slot) in groups.iter_mut().enumerate() {\n-                // Try to read a trailing embedded ipv4 address. There must be\n+                // Try to read a trailing embedded IPv4 address. There must be\n                 // at least two groups left.\n                 if i < limit - 1 {\n                     let ipv4 = p.read_separator(':', i, |p| p.read_ipv4_addr());\n@@ -188,8 +188,8 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n \n-            // read `::` if previous code parsed less than 8 groups\n-            // `::` indicates one or more groups of 16 bits of zeros\n+            // Read `::` if previous code parsed less than 8 groups.\n+            // `::` indicates one or more groups of 16 bits of zeros.\n             p.read_given_char(':')?;\n             p.read_given_char(':')?;\n \n@@ -206,28 +206,28 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Read an IP Address, either IPV4 or IPV6.\n+    /// Read an IP Address, either IPv4 or IPv6.\n     fn read_ip_addr(&mut self) -> Option<IpAddr> {\n         self.read_ipv4_addr().map(IpAddr::V4).or_else(move || self.read_ipv6_addr().map(IpAddr::V6))\n     }\n \n-    /// Read a : followed by a port in base 10.\n+    /// Read a `:` followed by a port in base 10.\n     fn read_port(&mut self) -> Option<u16> {\n         self.read_atomically(|p| {\n             p.read_given_char(':')?;\n             p.read_number(10, None)\n         })\n     }\n \n-    /// Read a % followed by a scope id in base 10.\n+    /// Read a `%` followed by a scope ID in base 10.\n     fn read_scope_id(&mut self) -> Option<u32> {\n         self.read_atomically(|p| {\n             p.read_given_char('%')?;\n             p.read_number(10, None)\n         })\n     }\n \n-    /// Read an IPV4 address with a port\n+    /// Read an IPv4 address with a port.\n     fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n         self.read_atomically(|p| {\n             let ip = p.read_ipv4_addr()?;\n@@ -236,7 +236,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Read an IPV6 address with a port\n+    /// Read an IPv6 address with a port.\n     fn read_socket_addr_v6(&mut self) -> Option<SocketAddrV6> {\n         self.read_atomically(|p| {\n             p.read_given_char('[')?;"}]}