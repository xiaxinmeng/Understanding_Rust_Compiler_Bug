{"sha": "ed6ad0952f980285c671277a9fd0559ab9d125d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNmFkMDk1MmY5ODAyODVjNjcxMjc3YTlmZDA1NTlhYjlkMTI1ZDM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-03-27T16:35:27Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-05-05T02:11:58Z"}, "message": "Point at fields that make the type recursive\n\nOn recursive types of infinite size, point at all the fields that make\nthe type recursive.\n\n```rust\nstruct Foo {\n    bar: Bar,\n}\n\nstruct Bar {\n    foo: Foo,\n}\n```\n\noutputs\n\n```\nerror[E0072]: recursive type `Foo` has infinite size\n --> file.rs:1:1\n1 |   struct Foo {\n  |  _^ starting here...\n2 | |     bar: Bar,\n  | |     -------- recursive here\n3 | | }\n  | |_^ ...ending here: recursive type has infinite size\n  |\n  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n\nerror[E0072]: recursive type `Bar` has infinite size\n --> file.rs:5:1\n  |\n5 |   struct Bar {\n  |  _^ starting here...\n6 | |     foo: Foo,\n  | |     -------- recursive here\n7 | | }\n  | |_^ ...ending here: recursive type has infinite size\n  |\n  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n```", "tree": {"sha": "2048a3fddfde3849c5775c79053deed8118a3f0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2048a3fddfde3849c5775c79053deed8118a3f0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed6ad0952f980285c671277a9fd0559ab9d125d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed6ad0952f980285c671277a9fd0559ab9d125d3", "html_url": "https://github.com/rust-lang/rust/commit/ed6ad0952f980285c671277a9fd0559ab9d125d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed6ad0952f980285c671277a9fd0559ab9d125d3/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96e2c34286099eea4f51daaadbb82a8fbe99e0f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/96e2c34286099eea4f51daaadbb82a8fbe99e0f6", "html_url": "https://github.com/rust-lang/rust/commit/96e2c34286099eea4f51daaadbb82a8fbe99e0f6"}], "stats": {"total": 205, "additions": 204, "deletions": 1}, "files": [{"sha": "333b64b08d71a65975d0ff2860f91b884fe32b1f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed6ad0952f980285c671277a9fd0559ab9d125d3/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed6ad0952f980285c671277a9fd0559ab9d125d3/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ed6ad0952f980285c671277a9fd0559ab9d125d3", "patch": "@@ -1299,6 +1299,20 @@ impl fmt::Debug for Ty {\n     }\n }\n \n+impl Ty {\n+    pub fn ty_def_id(&self) -> Option<DefId> {\n+        match self.node {\n+            TyPath(QPath::Resolved(_, ref path)) => {\n+                match path.def {\n+                    Def::Struct(did) | Def::Enum(did) => Some(did),\n+                    _ => None,\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// Not represented directly in the AST, referred to by name through a ty_path.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum PrimTy {"}, {"sha": "c462a56e562df41149a60771da01debb78233c82", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 123, "deletions": 1, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ed6ad0952f980285c671277a9fd0559ab9d125d3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed6ad0952f980285c671277a9fd0559ab9d125d3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ed6ad0952f980285c671277a9fd0559ab9d125d3", "patch": "@@ -27,7 +27,7 @@ use errors::DiagnosticBuilder;\n use fmt_macros::{Parser, Piece, Position};\n use hir::{self, intravisit, Local, Pat, Body};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n-use hir::map::NodeExpr;\n+use hir::map::{Node, NodeExpr};\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n@@ -779,6 +779,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn foo(&self, id: ast::NodeId, ty: &hir::Ty, sp: Span, err: &mut DiagnosticBuilder<'tcx>) -> bool {\n+        if let Some(Node::NodeItem(item)) = ty.ty_def_id().and_then(|id| {\n+            self.hir.get_if_local(id)\n+        }) {\n+            if self.is_node_id_referenced_in_item(item, id) {\n+                err.span_label(sp, &\"recursive here\");\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n     pub fn recursive_type_with_infinite_size_error(self,\n                                                    type_def_id: DefId)\n                                                    -> DiagnosticBuilder<'tcx>\n@@ -793,9 +805,119 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n                            at some point to make `{}` representable\",\n                           self.item_path_str(type_def_id)));\n+\n+        if let Some(Node::NodeItem(self_item)) = self.hir.get_if_local(type_def_id) {\n+            match self_item.node {\n+                hir::ItemStruct(hir::VariantData::Struct(ref fields, _), _) |\n+                hir::ItemStruct(hir::VariantData::Tuple(ref fields, _), _) => {\n+                    for field in fields {\n+                        match field.ty.node {\n+                            hir::TyPath(ref qpath) => {\n+                                // Foo | Option<Foo>\n+                                if let &hir::QPath::Resolved(_, ref path) = qpath {\n+                                    for segment in path.segments.iter() {\n+                                        if let hir::AngleBracketedParameters(\n+                                            hir::AngleBracketedParameterData {\n+                                                ref types, ..\n+                                            }) = segment.parameters\n+                                        {\n+                                            for ty in types {\n+                                                if self.foo(self_item.id, &ty, field.span,\n+                                                            &mut err) {\n+                                                    break;\n+                                                }\n+                                            }\n+                                        }\n+\n+                                    }\n+                                    match path.def {\n+                                        hir::def::Def::Struct(did) | hir::def::Def::Enum(did) => {\n+                                            let local = self.hir.get_if_local(did);\n+                                            if let Some(Node::NodeItem(item)) = local {\n+                                                if self.is_node_id_referenced_in_item(item,\n+                                                                                      self_item.id)\n+                                                {\n+                                                    err.span_label(field.span, &\"recursive here\");\n+                                                }\n+                                            }\n+                                        }\n+                                        _ => (),\n+                                    }\n+                                }\n+                            }\n+                            hir::TySlice(ref ty) |\n+                            hir::TyArray(ref ty, _) |\n+                            hir::TyPtr(hir::MutTy { ref ty, .. }) |\n+                            hir::TyRptr(_, hir::MutTy { ref ty, .. }) => {\n+                                // &[Foo] | [Foo] | &'a [Foo]\n+                                if let hir::TySlice(ref ty) = ty.node {\n+                                    // &'a [Foo]\n+                                    let _ = self.foo(self_item.id, &ty, field.span, &mut err);\n+                                } else {\n+                                    let _ = self.foo(self_item.id, &ty, field.span, &mut err);\n+                                }\n+                            }\n+                            hir::TyTup(ref tys) => {\n+                                // (Foo, Bar)\n+                                for ty in tys {\n+                                    if self.foo(self_item.id, &ty, field.span, &mut err) {\n+                                        break;\n+                                    }\n+                                }\n+                            }\n+                            _ => (),\n+                        }\n+                    }\n+                }\n+                _ => (),\n+            }\n+        }\n         err\n     }\n \n+    fn is_node_id_referenced_in_item(&self, item: &hir::Item, node_id: ast::NodeId) -> bool {\n+        if item.id == node_id {\n+            return true;\n+        }\n+        match item.node {\n+            hir::ItemStruct(hir::VariantData::Struct(ref fields, _), _) |\n+            hir::ItemStruct(hir::VariantData::Tuple(ref fields, _), _) => {\n+                for field in fields {\n+                    if let Some(Node::NodeItem(ref item)) = field.ty.ty_def_id().and_then(|id| {\n+                        self.hir.get_if_local(id)\n+                    }) {\n+                        if self.is_node_id_referenced_in_item(item, node_id) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            hir::ItemEnum(hir::EnumDef { ref variants }, _) => {\n+                for variant in variants {\n+                    match variant.node.data {\n+                        hir::VariantData::Struct(ref fields, _) |\n+                        hir::VariantData::Tuple(ref fields, _) => {\n+                            for field in fields {\n+                                if let Some(Node::NodeItem(ref item)) = field.ty\n+                                    .ty_def_id().and_then(|id| {\n+                                        self.hir.get_if_local(id)\n+                                    })\n+                                {\n+                                    if self.is_node_id_referenced_in_item(item, node_id) {\n+                                        return true;\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        _ => (),\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+        false\n+    }\n+\n     pub fn report_object_safety_error(self,\n                                       span: Span,\n                                       trait_def_id: DefId,"}, {"sha": "6fef4d30f7a77cc21070848c97d0cd44ffb4450f", "filename": "src/test/ui/span/recursive-type-field.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ed6ad0952f980285c671277a9fd0559ab9d125d3/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed6ad0952f980285c671277a9fd0559ab9d125d3/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs?ref=ed6ad0952f980285c671277a9fd0559ab9d125d3", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+struct Foo<'a> {\n+    bar: Bar<'a>,\n+    b: Rc<Bar<'a>>,\n+}\n+\n+struct Bar<'a> {\n+    y: (Foo<'a>, Foo<'a>),\n+    z: Option<Bar<'a>>,\n+    a: &'a Foo<'a>,\n+    c: &'a [Bar<'a>],\n+    d: [Bar<'a>; 1],\n+    e: Foo<'a>,\n+    x: Bar<'a>,\n+}\n+\n+fn main() {}"}, {"sha": "69d88f3a277b92b5ee8f28cac4853da0511d06dc", "filename": "src/test/ui/span/recursive-type-field.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ed6ad0952f980285c671277a9fd0559ab9d125d3/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed6ad0952f980285c671277a9fd0559ab9d125d3/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr?ref=ed6ad0952f980285c671277a9fd0559ab9d125d3", "patch": "@@ -0,0 +1,39 @@\n+error[E0072]: recursive type `Foo` has infinite size\n+  --> $DIR/recursive-type-field.rs:13:1\n+   |\n+13 |   struct Foo<'a> {\n+   |  _^ starting here...\n+14 | |     bar: Bar<'a>,\n+   | |     ------------ recursive here\n+15 | |     b: Rc<Bar<'a>>,\n+   | |     -------------- recursive here\n+16 | | }\n+   | |_^ ...ending here: recursive type has infinite size\n+   |\n+   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+\n+error[E0072]: recursive type `Bar` has infinite size\n+  --> $DIR/recursive-type-field.rs:18:1\n+   |\n+18 |   struct Bar<'a> {\n+   |  _^ starting here...\n+19 | |     y: (Foo<'a>, Foo<'a>),\n+   | |     --------------------- recursive here\n+20 | |     z: Option<Bar<'a>>,\n+   | |     ------------------ recursive here\n+21 | |     a: &'a Foo<'a>,\n+   | |     -------------- recursive here\n+22 | |     c: &'a [Bar<'a>],\n+   | |     ---------------- recursive here\n+23 | |     d: [Bar<'a>; 1],\n+   | |     --------------- recursive here\n+24 | |     e: Foo<'a>,\n+   | |     ---------- recursive here\n+25 | |     x: Bar<'a>,\n+   | |     ---------- recursive here\n+26 | | }\n+   | |_^ ...ending here: recursive type has infinite size\n+   |\n+   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n+\n+error: aborting due to 2 previous errors"}]}