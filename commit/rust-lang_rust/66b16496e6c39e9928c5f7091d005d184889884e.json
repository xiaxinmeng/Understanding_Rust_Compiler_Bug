{"sha": "66b16496e6c39e9928c5f7091d005d184889884e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YjE2NDk2ZTZjMzllOTkyOGM1ZjcwOTFkMDA1ZDE4NDg4OTg4NGU=", "commit": {"author": {"name": "n-salim", "email": "53019816+n-salim@users.noreply.github.com", "date": "2019-09-20T15:47:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-20T15:47:32Z"}, "message": "Merge pull request #23 from rust-lang/master\n\nSync to rust-lang/rust branch master", "tree": {"sha": "d46ba9ea92d542462d5f01cb38ca0b244ae8a564", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d46ba9ea92d542462d5f01cb38ca0b244ae8a564"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66b16496e6c39e9928c5f7091d005d184889884e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdhPSUCRBK7hj4Ov3rIwAAdHIIAGnnYRddWy5xVONLA8SlLn5X\nrzv+U5XVzYBhxtGVl9P4mIXx2qMTCzrd7kM6ZSj3bDotzXR7UNpP00PMmijl35N4\niWIPB51KJneqdSwBhsEQ2KvYnMMZNdR1FsSYRM1Q/wHZ77aFFqHJJ9Z3FkDbAdq2\nmccmUOXxBFSF/jpuwwh/Dseb+ztGTolJgrOysQtrZtzH/jYZzaYyt8B/lINOldTL\n8Ra5qWooMCgwqH55O6EGWRBOTzeKAjgXNXlI83A/HNebENQvzvPpd250mmHhq4x/\nE95q57HS1Rn+N+0hdSpajcnxB3HQ7AQ9EdtxDeMUqAQxo70c0fOEG5iqSaxxwVg=\n=mQB8\n-----END PGP SIGNATURE-----\n", "payload": "tree d46ba9ea92d542462d5f01cb38ca0b244ae8a564\nparent 83e7976c842a8ad73aa176b8439e1a2480596134\nparent 9ad1e7c46cf690b7ec6953b142430d21ca2d8799\nauthor n-salim <53019816+n-salim@users.noreply.github.com> 1568994452 -0700\ncommitter GitHub <noreply@github.com> 1568994452 -0700\n\nMerge pull request #23 from rust-lang/master\n\nSync to rust-lang/rust branch master"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66b16496e6c39e9928c5f7091d005d184889884e", "html_url": "https://github.com/rust-lang/rust/commit/66b16496e6c39e9928c5f7091d005d184889884e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66b16496e6c39e9928c5f7091d005d184889884e/comments", "author": {"login": "n-salim", "id": 53019816, "node_id": "MDQ6VXNlcjUzMDE5ODE2", "avatar_url": "https://avatars.githubusercontent.com/u/53019816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/n-salim", "html_url": "https://github.com/n-salim", "followers_url": "https://api.github.com/users/n-salim/followers", "following_url": "https://api.github.com/users/n-salim/following{/other_user}", "gists_url": "https://api.github.com/users/n-salim/gists{/gist_id}", "starred_url": "https://api.github.com/users/n-salim/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/n-salim/subscriptions", "organizations_url": "https://api.github.com/users/n-salim/orgs", "repos_url": "https://api.github.com/users/n-salim/repos", "events_url": "https://api.github.com/users/n-salim/events{/privacy}", "received_events_url": "https://api.github.com/users/n-salim/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83e7976c842a8ad73aa176b8439e1a2480596134", "url": "https://api.github.com/repos/rust-lang/rust/commits/83e7976c842a8ad73aa176b8439e1a2480596134", "html_url": "https://github.com/rust-lang/rust/commit/83e7976c842a8ad73aa176b8439e1a2480596134"}, {"sha": "9ad1e7c46cf690b7ec6953b142430d21ca2d8799", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad1e7c46cf690b7ec6953b142430d21ca2d8799", "html_url": "https://github.com/rust-lang/rust/commit/9ad1e7c46cf690b7ec6953b142430d21ca2d8799"}], "stats": {"total": 30064, "additions": 17730, "deletions": 12334}, "files": [{"sha": "9587aaab3594506bf8398f25a9d433096a6cb939", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -184,6 +184,7 @@ Neil Pankey <npankey@gmail.com> <neil@wire.im>\n Nick Platt <platt.nicholas@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n+Oliver Middleton <olliemail27@gmail.com> <ollie27@users.noreply.github.com>\n Oliver Scherer <oliver.schneider@kit.edu> <git-spam-no-reply9815368754983@oli-obk.de>\n Oliver Scherer <oliver.schneider@kit.edu> <git-spam9815368754983@oli-obk.de>\n Oliver Scherer <oliver.schneider@kit.edu> <github333195615777966@oli-obk.de>"}, {"sha": "f52e9738da8f97191531164828be2ffbee58bd77", "filename": "Cargo.lock", "status": "modified", "additions": 450, "deletions": 200, "changes": 650, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -109,9 +109,9 @@ dependencies = [\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.35\"\n+version = \"0.3.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1371048253fa3bac6704bfd6bbfc922ee9bdcee8881330d40f308b81cc5adc55\"\n+checksum = \"5180c5a20655b14a819b652fd2378fa5f1697b6c9ddad3e695c2f9cedf6df4e2\"\n dependencies = [\n  \"backtrace-sys\",\n  \"cfg-if\",\n@@ -223,18 +223,18 @@ checksum = \"560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40\"\n \n [[package]]\n name = \"bytecount\"\n-version = \"0.5.1\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"be0fdd54b507df8f22012890aadd099979befdba27713c767993f8380112ca7c\"\n+checksum = \"b0017894339f586ccb943b01b9555de56770c11cda818e7e3d8bd93f4ed7f46e\"\n dependencies = [\n  \"packed_simd\",\n ]\n \n [[package]]\n name = \"byteorder\"\n-version = \"1.2.7\"\n+version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94f88df23a25417badc922ab0f5716cc1330e87f71ddd9203b3a3ccd9cedf75d\"\n+checksum = \"a7c3dd8985a7111efc5c80b44e23ecdd8c007de8ade3b96595387e812b957cf5\"\n \n [[package]]\n name = \"bytes\"\n@@ -270,14 +270,15 @@ dependencies = [\n  \"atty\",\n  \"bytesize\",\n  \"cargo-test-macro\",\n+ \"cargo-test-support\",\n  \"clap\",\n  \"core-foundation\",\n  \"crates-io\",\n  \"crossbeam-utils 0.6.5\",\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"filetime\",\n  \"flate2\",\n@@ -286,8 +287,9 @@ dependencies = [\n  \"git2\",\n  \"git2-curl\",\n  \"glob\",\n- \"hex\",\n- \"home 0.5.0\",\n+ \"hex 0.4.0\",\n+ \"home\",\n+ \"humantime\",\n  \"ignore\",\n  \"im-rc\",\n  \"jobserver\",\n@@ -309,7 +311,7 @@ dependencies = [\n  \"same-file\",\n  \"semver\",\n  \"serde\",\n- \"serde_ignored 0.1.0\",\n+ \"serde_ignored\",\n  \"serde_json\",\n  \"shell-escape\",\n  \"strip-ansi-escapes\",\n@@ -327,6 +329,23 @@ dependencies = [\n name = \"cargo-test-macro\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"cargo-test-support\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cargo\",\n+ \"cargo-test-macro\",\n+ \"filetime\",\n+ \"flate2\",\n+ \"git2\",\n+ \"glob\",\n+ \"lazy_static 1.3.0\",\n+ \"remove_dir_all\",\n+ \"serde_json\",\n+ \"tar\",\n+ \"url 2.1.0\",\n+]\n+\n [[package]]\n name = \"cargo_metadata\"\n version = \"0.8.0\"\n@@ -392,9 +411,9 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"2.32.0\"\n+version = \"2.33.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b957d88f4b6a63b9d70d5f454ac8011819c6efa7727858f458ab71c756ce2d3e\"\n+checksum = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n dependencies = [\n  \"ansi_term\",\n  \"atty\",\n@@ -507,7 +526,7 @@ name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n  \"diff\",\n- \"env_logger 0.5.13\",\n+ \"env_logger\",\n  \"getopts\",\n  \"lazy_static 1.3.0\",\n  \"libc\",\n@@ -698,7 +717,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"09de9ee0fc255ace04c7fa0763c9395a945c37c8292bb554f8d48361d1dcf1b4\"\n dependencies = [\n  \"commoncrypto\",\n- \"hex\",\n+ \"hex 0.3.2\",\n  \"openssl\",\n  \"winapi 0.3.6\",\n ]\n@@ -753,9 +772,9 @@ checksum = \"d2a368589465391e127e10c9e3a08efc8df66fd49b87dc8524c764bbe7f2ef82\"\n dependencies = [\n  \"fnv\",\n  \"ident_case\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -765,8 +784,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"244e8987bd4e174385240cde20a3657f607fb0797563c28255c353b5819a07b1\"\n dependencies = [\n  \"darling_core\",\n- \"quote\",\n- \"syn\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -781,9 +800,9 @@ version = \"0.5.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6ca414e896ae072546f4d789f452daaecf60ddee4c9df5dc6d5936d769e3d87c\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -792,10 +811,10 @@ version = \"0.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3f57d78cf3bd45270dad4e70c21ec77a960b36c7a841ff9db76aaa775a8fb871\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n  \"rustc_version\",\n- \"syn\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -909,21 +928,9 @@ dependencies = [\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.5.13\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"15b0a4d2e39f8420210be8b27eeda28029729e2fd4291019455016c348240c38\"\n-dependencies = [\n- \"atty\",\n- \"humantime\",\n- \"log\",\n- \"termcolor\",\n-]\n-\n-[[package]]\n-name = \"env_logger\"\n-version = \"0.6.0\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"afb070faf94c85d17d50ca44f6ad076bce18ae92f0037d350947240a36e9d42e\"\n+checksum = \"aafcde04e90a5226a6443b7aabdb016ba2f8307c847d524724bd9b346dd1a2d3\"\n dependencies = [\n  \"atty\",\n  \"humantime\",\n@@ -965,9 +972,9 @@ version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n  \"synstructure\",\n ]\n \n@@ -1151,12 +1158,13 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.1.8\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34f33de6f0ae7c9cb5e574502a562e2b512799e32abb801cd1e79ad952b62b49\"\n+checksum = \"473a1265acc8ff1e808cd0a1af8cee3c2ee5200916058a2ca113c29f2d903571\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -1272,14 +1280,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"805026a5d0141ffc30abb3be3173848ad46a1b1664fe632428479619a3644d77\"\n \n [[package]]\n-name = \"home\"\n-version = \"0.3.3\"\n+name = \"hex\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"80dff82fb58cfbbc617fb9a9184b010be0529201553cda50ad04372bc2333aff\"\n-dependencies = [\n- \"scopeguard 0.3.3\",\n- \"winapi 0.3.6\",\n-]\n+checksum = \"023b39be39e3a2da62a94feb433e91e8bcd37676fbc8bea371daf52b7a769a3e\"\n \n [[package]]\n name = \"home\"\n@@ -1300,9 +1304,9 @@ dependencies = [\n  \"log\",\n  \"mac\",\n  \"markup5ever\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -1540,11 +1544,30 @@ version = \"0.11.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9ad0485404155f45cce53a40d4b2d6ac356418300daed05273d9e26f91c390be\"\n \n+[[package]]\n+name = \"jsonrpc-client-transports\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"39577db48b004cffb4c5b8e5c9b993c177c52599ecbee88711e815acf65144db\"\n+dependencies = [\n+ \"failure\",\n+ \"futures\",\n+ \"jsonrpc-core\",\n+ \"jsonrpc-pubsub\",\n+ \"jsonrpc-server-utils\",\n+ \"log\",\n+ \"parity-tokio-ipc\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"tokio\",\n+ \"url 1.7.2\",\n+]\n+\n [[package]]\n name = \"jsonrpc-core\"\n-version = \"12.0.0\"\n+version = \"13.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"288dca7f9713710a29e485076b9340156cb701edb46a881f5d0c31aa4f5b9143\"\n+checksum = \"dd42951eb35079520ee29b7efbac654d85821b397ef88c8151600ef7e2d00217\"\n dependencies = [\n  \"futures\",\n  \"log\",\n@@ -1553,6 +1576,70 @@ dependencies = [\n  \"serde_json\",\n ]\n \n+[[package]]\n+name = \"jsonrpc-core-client\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f047c10738edee7c3c6acf5241a0ce33df32ef9230c1a7fb03e4a77ee72c992f\"\n+dependencies = [\n+ \"jsonrpc-client-transports\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-derive\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"29f9149f785deaae92a4c834a9a1a83a4313b8cfedccf15362cd4cf039a64501\"\n+dependencies = [\n+ \"proc-macro-crate\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-ipc-server\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"256c5e4292c17b4c2ecdf542299dc8e9d6b3939c075c54825570ad9317fe5751\"\n+dependencies = [\n+ \"jsonrpc-core\",\n+ \"jsonrpc-server-utils\",\n+ \"log\",\n+ \"parity-tokio-ipc\",\n+ \"parking_lot 0.9.0\",\n+ \"tokio-service\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-pubsub\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2c08b444cc0ed70263798834343d0ac875e664257df8079160f23ac1ea79446\"\n+dependencies = [\n+ \"jsonrpc-core\",\n+ \"log\",\n+ \"parking_lot 0.9.0\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-server-utils\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"44561bfdd31401bad790527f1e951dde144f2341ddc3e1b859d32945e1a34eff\"\n+dependencies = [\n+ \"bytes\",\n+ \"globset\",\n+ \"jsonrpc-core\",\n+ \"lazy_static 1.3.0\",\n+ \"log\",\n+ \"num_cpus\",\n+ \"tokio\",\n+ \"tokio-codec\",\n+ \"unicase 2.4.0\",\n+]\n+\n [[package]]\n name = \"kernel32-sys\"\n version = \"0.2.2\"\n@@ -1583,9 +1670,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.61\"\n+version = \"0.2.62\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c665266eb592905e8503ba3403020f4b8794d26263f412ca33171600eca9a6fa\"\n+checksum = \"34fcd2c08d2f832f376f4173a231990fa5aef4e99fb569867318a227ef4c06ba\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1667,6 +1754,15 @@ dependencies = [\n  \"scopeguard 0.3.3\",\n ]\n \n+[[package]]\n+name = \"lock_api\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f8912e782533a93a167888781b836336a6ca5da6175c05944c86cf28c31104dc\"\n+dependencies = [\n+ \"scopeguard 1.0.0\",\n+]\n+\n [[package]]\n name = \"log\"\n version = \"0.4.8\"\n@@ -1698,18 +1794,15 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.57.2\"\n+version = \"0.60.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b62b77309737b1e262b3bbf37ff8faa740562c633b14702afe9be85dbcb6f88a\"\n+checksum = \"fe3edefcd66dde1f7f1df706f46520a3c93adc5ca4bc5747da6621195e894efd\"\n dependencies = [\n  \"bitflags\",\n- \"num-derive\",\n- \"num-traits\",\n  \"serde\",\n- \"serde_derive\",\n  \"serde_json\",\n- \"url 1.7.2\",\n- \"url_serde\",\n+ \"serde_repr\",\n+ \"url 2.1.0\",\n ]\n \n [[package]]\n@@ -1774,7 +1867,7 @@ dependencies = [\n  \"chrono\",\n  \"clap\",\n  \"elasticlunr-rs\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"error-chain\",\n  \"handlebars\",\n  \"itertools 0.8.0\",\n@@ -1799,7 +1892,7 @@ version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"77d1f0ba4d1e6b86fa18e8853d026d7d76a97eb7eb5eb052ed80901e43b7fc10\"\n dependencies = [\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"log\",\n  \"mdbook\",\n@@ -1812,7 +1905,7 @@ dependencies = [\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n- \"structopt\",\n+ \"structopt 0.2.18\",\n  \"url 1.7.2\",\n ]\n \n@@ -1992,12 +2085,12 @@ dependencies = [\n  \"colored\",\n  \"compiletest_rs\",\n  \"directories\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"getrandom\",\n- \"hex\",\n+ \"hex 0.3.2\",\n  \"log\",\n  \"num-traits\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"shell-escape\",\n@@ -2045,18 +2138,6 @@ version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a2228dca57108069a5262f2ed8bd2e82496d2e074a06d1ccc7ce1687b6ae0a2\"\n \n-[[package]]\n-name = \"num-derive\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8af1847c907c2f04d7bfd572fb25bbb4385c637fe5be163cf2f8c5d778fe1e7d\"\n-dependencies = [\n- \"num-traits\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"num-integer\"\n version = \"0.1.39\"\n@@ -2081,6 +2162,12 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"once_cell\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d6a04cb71e910d0034815600180f62a95bf6e67942d7ab52a166a68c7d7e9cd0\"\n+\n [[package]]\n name = \"open\"\n version = \"1.2.1\"\n@@ -2118,9 +2205,9 @@ checksum = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n \n [[package]]\n name = \"openssl-src\"\n-version = \"111.3.0+1.1.1c\"\n+version = \"111.6.0+1.1.1d\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53ed5f31d294bdf5f7a4ba0a206c2754b0f60e9a63b7e3076babc5317873c797\"\n+checksum = \"b9c2da1de8a7a3f860919c01540b03a6db16de042405a8a07a5e9d0b4b825d9c\"\n dependencies = [\n  \"cc\",\n ]\n@@ -2190,14 +2277,43 @@ dependencies = [\n  \"unwind\",\n ]\n \n+[[package]]\n+name = \"parity-tokio-ipc\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8281bf4f1d6429573f89589bf68d89451c46750977a8264f8ea3edbabeba7947\"\n+dependencies = [\n+ \"bytes\",\n+ \"futures\",\n+ \"log\",\n+ \"mio-named-pipes\",\n+ \"miow 0.3.3\",\n+ \"rand 0.7.0\",\n+ \"tokio\",\n+ \"tokio-named-pipes\",\n+ \"tokio-uds\",\n+ \"winapi 0.3.6\",\n+]\n+\n [[package]]\n name = \"parking_lot\"\n version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ab41b4aed082705d1056416ae4468b6ea99d52599ecf3169b00088d43113e337\"\n dependencies = [\n- \"lock_api\",\n- \"parking_lot_core\",\n+ \"lock_api 0.1.3\",\n+ \"parking_lot_core 0.4.0\",\n+]\n+\n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f842b1982eb6c2fe34036a4fbfb06dd185a3f5c8edfaacdf7d1ea10b07de6252\"\n+dependencies = [\n+ \"lock_api 0.3.1\",\n+ \"parking_lot_core 0.6.2\",\n+ \"rustc_version\",\n ]\n \n [[package]]\n@@ -2213,6 +2329,21 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.6.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b876b1b9e7ac6e1a74a6da34d25c42e17e8862aa409cbbbdcfc8d86c6f3bc62b\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"cloudabi\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"rustc_version\",\n+ \"smallvec\",\n+ \"winapi 0.3.6\",\n+]\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"1.0.1\"\n@@ -2252,9 +2383,9 @@ checksum = \"63120576c4efd69615b5537d3d052257328a4ca82876771d6944424ccfd9f646\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -2363,10 +2494,30 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df8b3f4e0475def7d9c2e5de8e5a1306949849761e107b360d03e98eafaffd61\"\n dependencies = [\n  \"chrono\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"log\",\n ]\n \n+[[package]]\n+name = \"proc-macro-crate\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e10d4b51f154c8a7fb96fd6dad097cb74b863943ec010ac94b9fd1be8861fe1e\"\n+dependencies = [\n+ \"toml\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-error\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aeccfe4d5d8ea175d5f0e4a2ad0637e0f4121d63bd99d356fb1f39ab2e7c6097\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+]\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"0.4.30\"\n@@ -2376,6 +2527,15 @@ dependencies = [\n  \"unicode-xid 0.1.0\",\n ]\n \n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n+dependencies = [\n+ \"unicode-xid 0.2.0\",\n+]\n+\n [[package]]\n name = \"proc_macro\"\n version = \"0.0.0\"\n@@ -2428,19 +2588,28 @@ version = \"0.6.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"faf4799c5d274f3868a4aae320a0a182cbd2baee377b378f080e16a23e9d80db\"\n dependencies = [\n- \"proc-macro2\",\n+ \"proc-macro2 0.4.30\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n ]\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.25\"\n+version = \"2.1.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0727b9d7baaf9e42851145545d7b980b5c1752bd16a4c77c925c5e573d0069d9\"\n+checksum = \"dde22b84ab75220015cbd91240222402bf885cbe3a5dc856475771abb82533ae\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n  \"derive_more\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"humantime\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n@@ -2727,18 +2896,18 @@ checksum = \"cabe4fa914dec5870285fa7f71f602645da47c486e68486d2b4ceb4a343e90ac\"\n \n [[package]]\n name = \"rls\"\n-version = \"1.38.0\"\n+version = \"1.39.0\"\n dependencies = [\n  \"cargo\",\n  \"cargo_metadata\",\n  \"clippy_lints\",\n  \"crossbeam-channel\",\n  \"difference\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"futures\",\n  \"heck\",\n- \"home 0.3.3\",\n+ \"home\",\n  \"itertools 0.8.0\",\n  \"jsonrpc-core\",\n  \"lazy_static 1.3.0\",\n@@ -2753,6 +2922,7 @@ dependencies = [\n  \"regex\",\n  \"rls-analysis\",\n  \"rls-data\",\n+ \"rls-ipc\",\n  \"rls-rustc\",\n  \"rls-span\",\n  \"rls-vfs\",\n@@ -2762,14 +2932,14 @@ dependencies = [\n  \"rustfmt-nightly\",\n  \"serde\",\n  \"serde_derive\",\n- \"serde_ignored 0.0.4\",\n+ \"serde_ignored\",\n  \"serde_json\",\n  \"tempfile\",\n  \"tokio\",\n  \"tokio-process\",\n  \"tokio-timer\",\n  \"toml\",\n- \"url 1.7.2\",\n+ \"url 2.1.0\",\n  \"walkdir\",\n ]\n \n@@ -2800,9 +2970,33 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"rls-ipc\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"jsonrpc-core\",\n+ \"jsonrpc-core-client\",\n+ \"jsonrpc-derive\",\n+ \"jsonrpc-ipc-server\",\n+ \"rls-data\",\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"rls-rustc\"\n version = \"0.6.0\"\n+dependencies = [\n+ \"clippy_lints\",\n+ \"env_logger\",\n+ \"failure\",\n+ \"futures\",\n+ \"log\",\n+ \"rand 0.6.1\",\n+ \"rls-data\",\n+ \"rls-ipc\",\n+ \"serde\",\n+ \"tokio\",\n+]\n \n [[package]]\n name = \"rls-span\"\n@@ -2845,11 +3039,10 @@ dependencies = [\n  \"fmt_macros\",\n  \"graphviz\",\n  \"jobserver\",\n- \"lazy_static 1.3.0\",\n  \"log\",\n  \"measureme\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"polonius-engine\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -2868,25 +3061,25 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dc2e1e68b64268c543bfa6e63e3c0d9ea58074c71396f42f76931f35a9287f9\"\n+checksum = \"f59b76d334bd533f3fdc5c651c27678c5e80fac67c6f7da22ba21a58878c55f5\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-graphviz\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c108d647ce0dd46477b048eafff5a6273b5652e02d47424b0cd684147379c811\"\n+checksum = \"3e632ef08ca17458acfd46d2ead3d541a1c249586cd5329f5fe333dacfab6142\"\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"656771744e0783cb8e4481e3b8b1f975687610aaf18833b898018111a0e0e582\"\n+checksum = \"e89e2c7be68185418f3cd56af3df8b29007a59a1cebefa63612d055f9bcb1a36\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n@@ -2895,7 +3088,7 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n- \"parking_lot\",\n+ \"parking_lot 0.7.1\",\n  \"rustc-ap-graphviz\",\n  \"rustc-ap-serialize\",\n  \"rustc-hash\",\n@@ -2907,44 +3100,48 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e37064f6624bc799bfaa2968b61ee6880926dea2a8bba69f18aef6c8e69c9604\"\n+checksum = \"1e47cb380abeb72b01e42b2342d592f7eeea7d536c2f1f0d0e550dc509e46333\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-serialize\",\n  \"rustc-ap-syntax_pos\",\n+ \"term_size\",\n  \"termcolor\",\n  \"unicode-width\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ef5bc0a971823637ea23a857f0ef1467f44b1e05d71968821f83a0abe53e0fe3\"\n+checksum = \"494cfaf67f49217d67d0774eeecbba61ac89acf478db97ef11f113ed8a959305\"\n+dependencies = [\n+ \"unicode-xid 0.2.0\",\n+]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b90037e3336fe8835f468db44d0848ae10d9cc8533ae89b55828883f905b7e80\"\n+checksum = \"e2e5d36becc59b4497f9cbd3ae0610081de0207a1d0e95c066369167b14f486f\"\n dependencies = [\n  \"itertools 0.8.0\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n  \"synstructure\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cadf9ca07315eab3a7a21f63872f9cc81e250fd6ede0419c24f8926ade73a45d\"\n+checksum = \"a7bfc5f96dfc3b9f8d5b57884f7f37467ecff6776cd4b8b491a7daece6fdd7c2\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n@@ -2955,19 +3152,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61673783f2089e01033ffa82d1988f55175402071b31253a358292e1624d4602\"\n+checksum = \"2bb9ee231cf79eded39c56647499f83d6136ff5c8c0baaa9e21b6febee00f4f6\"\n dependencies = [\n  \"indexmap\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"28f3dd1346d5b0269c07a4a78855e309a298ab569c9c1302d4d4f57f8eee4e84\"\n+checksum = \"b3827fc208814efbde82d613e31d11b4250ce9e8cf8afe4a4d47bbbd099632c9\"\n dependencies = [\n  \"bitflags\",\n  \"lazy_static 1.3.0\",\n@@ -2985,9 +3182,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-syntax_pos\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"45e67b526dbda3a0c7dab91c8947d43685e7697f52686a4949da3c179cd7c979\"\n+checksum = \"930ed81c34f325e512cc315c04d676fa84a373879d5c43bb54054a0522b05213\"\n dependencies = [\n  \"cfg-if\",\n  \"rustc-ap-arena\",\n@@ -3058,21 +3255,21 @@ checksum = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \n [[package]]\n name = \"rustc-std-workspace-alloc\"\n-version = \"1.0.0\"\n+version = \"1.99.0\"\n dependencies = [\n  \"alloc\",\n ]\n \n [[package]]\n name = \"rustc-std-workspace-core\"\n-version = \"1.0.0\"\n+version = \"1.99.0\"\n dependencies = [\n  \"core\",\n ]\n \n [[package]]\n name = \"rustc-std-workspace-std\"\n-version = \"1.0.0\"\n+version = \"1.99.0\"\n dependencies = [\n  \"std\",\n ]\n@@ -3081,15 +3278,11 @@ dependencies = [\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n- \"byteorder\",\n  \"crossbeam-utils 0.6.5\",\n- \"parking_lot\",\n- \"rand 0.6.1\",\n- \"scopeguard 0.3.3\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec\",\n- \"syn\",\n+ \"url 2.1.0\",\n  \"winapi 0.3.6\",\n ]\n \n@@ -3129,11 +3322,7 @@ dependencies = [\n name = \"rustc_codegen_llvm\"\n version = \"0.0.0\"\n dependencies = [\n- \"cc\",\n- \"memmap\",\n- \"num_cpus\",\n  \"rustc_llvm\",\n- \"tempfile\",\n ]\n \n [[package]]\n@@ -3147,7 +3336,7 @@ dependencies = [\n  \"log\",\n  \"memmap\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_codegen_utils\",\n@@ -3190,7 +3379,7 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -3203,8 +3392,9 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n- \"env_logger 0.5.13\",\n+ \"env_logger\",\n  \"graphviz\",\n+ \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc\",\n  \"rustc_ast_borrowck\",\n@@ -3248,7 +3438,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz\",\n  \"log\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n@@ -3262,6 +3452,7 @@ name = \"rustc_interface\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n+ \"once_cell\",\n  \"rustc\",\n  \"rustc-rayon\",\n  \"rustc_ast_borrowck\",\n@@ -3330,9 +3521,9 @@ name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n  \"synstructure\",\n ]\n \n@@ -3571,26 +3762,25 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-config_proc_macro\"\n-version = \"0.1.2\"\n+version = \"0.2.0\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n  \"serde\",\n- \"syn\",\n+ \"syn 1.0.5\",\n ]\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.6\"\n+version = \"1.4.8\"\n dependencies = [\n  \"annotate-snippets\",\n- \"atty\",\n  \"bytecount\",\n  \"cargo_metadata\",\n  \"derive-new\",\n  \"diff\",\n  \"dirs\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"getopts\",\n  \"ignore\",\n@@ -3605,7 +3795,7 @@ dependencies = [\n  \"rustfmt-config_proc_macro\",\n  \"serde\",\n  \"serde_json\",\n- \"structopt\",\n+ \"structopt 0.3.1\",\n  \"term 0.6.0\",\n  \"toml\",\n  \"unicode-segmentation\",\n@@ -3714,18 +3904,9 @@ version = \"1.0.81\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"477b13b646f5b5b56fc95bedfc3b550d12141ce84f466f6c44b9a17589923885\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n-[[package]]\n-name = \"serde_ignored\"\n-version = \"0.0.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"190e9765dcedb56be63b6e0993a006c7e3b071a016a304736e4a315dc01fb142\"\n-dependencies = [\n- \"serde\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -3748,6 +3929,17 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"serde_repr\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cd02c7587ec314570041b2754829f84d873ced14a96d1fd1823531e11db40573\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+]\n+\n [[package]]\n name = \"serde_urlencoded\"\n version = \"0.5.5\"\n@@ -3864,12 +4056,13 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"rustc_asan\",\n  \"rustc_lsan\",\n  \"rustc_msan\",\n  \"rustc_tsan\",\n  \"unwind\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -3904,8 +4097,8 @@ checksum = \"1eea1eee654ef80933142157fdad9dd8bc43cf7c74e999e369263496f04ff4da\"\n dependencies = [\n  \"phf_generator\",\n  \"phf_shared\",\n- \"proc-macro2\",\n- \"quote\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n  \"string_cache_shared\",\n ]\n \n@@ -3926,9 +4119,9 @@ dependencies = [\n \n [[package]]\n name = \"strsim\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550\"\n+checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n \n [[package]]\n name = \"structopt\"\n@@ -3937,7 +4130,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"16c2cdbf9cc375f15d1b4141bc48aeef444806655cd0e904207edc8d68d86ed7\"\n dependencies = [\n  \"clap\",\n- \"structopt-derive\",\n+ \"structopt-derive 0.2.18\",\n+]\n+\n+[[package]]\n+name = \"structopt\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2ac9d6e93dd792b217bf89cda5c14566e3043960c6f9da890c2ba5d09d07804c\"\n+dependencies = [\n+ \"clap\",\n+ \"structopt-derive 0.3.1\",\n ]\n \n [[package]]\n@@ -3947,9 +4150,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"53010261a84b37689f9ed7d395165029f9cc7abb9f56bbfe86bee2597ed25107\"\n dependencies = [\n  \"heck\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n+]\n+\n+[[package]]\n+name = \"structopt-derive\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2ae9e5165d463a0dea76967d021f8d0f9316057bf5163aa2a4843790e842ff37\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro-error\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n ]\n \n [[package]]\n@@ -3965,9 +4181,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8baacebd7b7c9b864d83a6ba7a246232983e277b86fa5cdec77f565715a4b136\"\n dependencies = [\n  \"heck\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -3976,20 +4192,31 @@ version = \"0.15.35\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"641e117d55514d6d918490e47102f7e08d096fdde360247e4a10f7a91a8478d3\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n  \"unicode-xid 0.1.0\",\n ]\n \n+[[package]]\n+name = \"syn\"\n+version = \"1.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"unicode-xid 0.2.0\",\n+]\n+\n [[package]]\n name = \"synstructure\"\n version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"02353edf96d6e4dc81aea2d8490a7e9db177bf8acb0e951c24940bf866cb313f\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n  \"unicode-xid 0.1.0\",\n ]\n \n@@ -4059,13 +4286,13 @@ dependencies = [\n \n [[package]]\n name = \"tempfile\"\n-version = \"3.0.5\"\n+version = \"3.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e91405c14320e5c79b3d148e1c86f40749a36e490642202a31689cb1a3452b2\"\n+checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n  \"winapi 0.3.6\",\n@@ -4169,9 +4396,9 @@ dependencies = [\n \n [[package]]\n name = \"textwrap\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"307686869c93e71f94da64286f9a9524c0f308a9e1c87a583de8e9c9039ad3f6\"\n+checksum = \"d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060\"\n dependencies = [\n  \"unicode-width\",\n ]\n@@ -4294,6 +4521,19 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"tokio-named-pipes\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9d282d483052288b2308ba5ee795f5673b159c9bdf63c385a05609da782a5eae\"\n+dependencies = [\n+ \"bytes\",\n+ \"futures\",\n+ \"mio\",\n+ \"mio-named-pipes\",\n+ \"tokio\",\n+]\n+\n [[package]]\n name = \"tokio-process\"\n version = \"0.2.3\"\n@@ -4322,12 +4562,21 @@ dependencies = [\n  \"log\",\n  \"mio\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.7.1\",\n  \"slab\",\n  \"tokio-executor\",\n  \"tokio-io\",\n ]\n \n+[[package]]\n+name = \"tokio-service\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"24da22d077e0f15f55162bdbdc661228c1581892f52074fb242678d015b45162\"\n+dependencies = [\n+ \"futures\",\n+]\n+\n [[package]]\n name = \"tokio-signal\"\n version = \"0.2.7\"\n@@ -4451,8 +4700,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3c99ca245ec273c7e75c8ee58f47b882d0146f3c2c8495158082c6671e8b5335\"\n dependencies = [\n  \"darling\",\n- \"quote\",\n- \"syn\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -4589,16 +4838,6 @@ dependencies = [\n  \"serde\",\n ]\n \n-[[package]]\n-name = \"url_serde\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"74e7d099f1ee52f823d4bdd60c93c3602043c728f5db3b97bdb548467f7bddea\"\n-dependencies = [\n- \"serde\",\n- \"url 1.7.2\",\n-]\n-\n [[package]]\n name = \"utf-8\"\n version = \"0.7.2\"\n@@ -4686,6 +4925,17 @@ dependencies = [\n  \"try-lock\",\n ]\n \n+[[package]]\n+name = \"wasi\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.8\""}, {"sha": "96d7e938be2f2ca8cbf253e70213530827a547c4", "filename": "README.md", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -26,12 +26,13 @@ or reading the [rustc guide][rustcguidebuild].\n ### Building on *nix\n 1. Make sure you have installed the dependencies:\n \n-   * `g++` 4.7 or later or `clang++` 3.x or later\n+   * `g++` 5.1 or later or `clang++` 3.5 or later\n    * `python` 2.7 (but not 3.x)\n    * GNU `make` 3.81 or later\n    * `cmake` 3.4.3 or later\n    * `curl`\n    * `git`\n+   * `ssl` which comes in `libssl-dev` or `openssl-devel`\n \n 2. Clone the [source] with `git`:\n \n@@ -56,6 +57,8 @@ or reading the [rustc guide][rustcguidebuild].\n     an installation (using `./x.py install`) that you set the `prefix` value\n     in the `[install]` section to a directory that you have write permissions.\n \n+    Create install directory if you are not installing in default directory\n+\n 4. Build and install:\n \n     ```sh\n@@ -148,6 +151,17 @@ by manually calling the appropriate vcvars file before running the bootstrap.\n > python x.py build\n ```\n \n+### Building rustc with older host toolchains\n+It is still possible to build Rust with the older toolchain versions listed below, but only if the\n+LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN option is set to true in the config.toml file.\n+\n+* Clang 3.1\n+* Apple Clang 3.1\n+* GCC 4.8\n+* Visual Studio 2015 (Update 3)\n+\n+Toolchain versions older than what is listed above cannot be used to build rustc.\n+\n #### Specifying an ABI\n \n Each specific ABI can also be used from either environment (for example, using"}, {"sha": "d634feba33ac5ec4be4f43369962f57eda16da8e", "filename": "RELEASES.md", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,3 +1,108 @@\n+Version 1.38.0 (2019-09-26)\n+==========================\n+\n+Language\n+--------\n+- [The `#[global_allocator]` attribute can now be used in submodules.][62735]\n+- [The `#[deprecated]` attribute can now be used on macros.][62042]\n+\n+Compiler\n+--------\n+- [Added pipelined compilation support to `rustc`.][62766] This will\n+  improve compilation times in some cases. For further information please refer\n+  to the [_\"Evaluating pipelined rustc compilation\"_][pipeline-internals] thread.\n+- [Added tier 3\\* support for the `aarch64-uwp-windows-msvc`, `i686-uwp-windows-gnu`,\n+  `i686-uwp-windows-msvc`, `x86_64-uwp-windows-gnu`, and\n+  `x86_64-uwp-windows-msvc` targets.][60260]\n+- [Added tier 3 support for the `armv7-unknown-linux-gnueabi` and\n+  `armv7-unknown-linux-musleabi` targets.][63107]\n+- [Added tier 3 support for the `hexagon-unknown-linux-musl` target.][62814]\n+- [Added tier 3 support for the `riscv32i-unknown-none-elf` target.][62784]\n+\n+\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+- [`ascii::EscapeDefault` now implements `Clone` and `Display`.][63421]\n+- [Derive macros for prelude traits (e.g. `Clone`, `Debug`, `Hash`) are now\n+  available at the same path as the trait.][63056] (e.g. The `Clone` derive macro\n+  is available at `std::clone::Clone`). This also makes all built-in macros\n+  available in `std`/`core` root. e.g. `std::include_bytes!`.\n+- [`str::Chars` now implements `Debug`.][63000]\n+- [`slice::{concat, connect, join}` now accepts `&[T]` in addition to `&T`.][62528]\n+- [`*const T` and `*mut T` now implement `marker::Unpin`.][62583]\n+- [`Arc<[T]>` and `Rc<[T]>` now implement `FromIterator<T>`.][61953]\n+- [Added euclidean remainder and division operations (`div_euclid`,\n+  `rem_euclid`) to all numeric primitives.][61884] Additionally `checked`,\n+  `overflowing`, and `wrapping` versions are available for all\n+  integer primitives.\n+- [`thread::AccessError` now implements `Clone`, `Copy`, `Eq`, `Error`, and\n+  `PartialEq`.][61491]\n+- [`iter::{StepBy, Peekable, Take}` now implement `DoubleEndedIterator`.][61457]\n+\n+Stabilized APIs\n+---------------\n+- [`<*const T>::cast`]\n+- [`<*mut T>::cast`]\n+- [`Duration::as_secs_f32`]\n+- [`Duration::as_secs_f64`]\n+- [`Duration::div_duration_f32`]\n+- [`Duration::div_duration_f64`]\n+- [`Duration::div_f32`]\n+- [`Duration::div_f64`]\n+- [`Duration::from_secs_f32`]\n+- [`Duration::from_secs_f64`]\n+- [`Duration::mul_f32`]\n+- [`Duration::mul_f64`]\n+- [`any::type_name`]\n+\n+Cargo\n+-----\n+- [Added pipelined compilation support to `cargo`.][cargo/7143]\n+- [You can now pass the `--features` option multiple times to enable\n+  multiple features.][cargo/7084]\n+\n+Misc\n+----\n+- [`rustc` will now warn about some incorrect uses of\n+  `mem::{uninitialized, zeroed}` that are known to cause undefined behaviour.][63346]\n+\n+[60260]: https://github.com/rust-lang/rust/pull/60260/\n+[61457]: https://github.com/rust-lang/rust/pull/61457/\n+[61491]: https://github.com/rust-lang/rust/pull/61491/\n+[61884]: https://github.com/rust-lang/rust/pull/61884/\n+[61953]: https://github.com/rust-lang/rust/pull/61953/\n+[62042]: https://github.com/rust-lang/rust/pull/62042/\n+[62528]: https://github.com/rust-lang/rust/pull/62528/\n+[62583]: https://github.com/rust-lang/rust/pull/62583/\n+[62735]: https://github.com/rust-lang/rust/pull/62735/\n+[62766]: https://github.com/rust-lang/rust/pull/62766/\n+[62784]: https://github.com/rust-lang/rust/pull/62784/\n+[62814]: https://github.com/rust-lang/rust/pull/62814/\n+[63000]: https://github.com/rust-lang/rust/pull/63000/\n+[63056]: https://github.com/rust-lang/rust/pull/63056/\n+[63107]: https://github.com/rust-lang/rust/pull/63107/\n+[63346]: https://github.com/rust-lang/rust/pull/63346/\n+[63421]: https://github.com/rust-lang/rust/pull/63421/\n+[cargo/7084]: https://github.com/rust-lang/cargo/pull/7084/\n+[cargo/7143]: https://github.com/rust-lang/cargo/pull/7143/\n+[`<*const T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n+[`<*mut T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n+[`Duration::as_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f32\n+[`Duration::as_secs_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f64\n+[`Duration::div_duration_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f32\n+[`Duration::div_duration_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f64\n+[`Duration::div_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f32\n+[`Duration::div_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f64\n+[`Duration::from_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs_f32\n+[`Duration::from_secs_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs_f64\n+[`Duration::mul_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f32\n+[`Duration::mul_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f64\n+[`any::type_name`]: https://doc.rust-lang.org/std/any/fn.type_name.html\n+[forge-platform-support]: https://forge.rust-lang.org/platform-support.html\n+[pipeline-internals]: https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199\n+\n Version 1.37.0 (2019-08-15)\n ==========================\n "}, {"sha": "848147c2974c1d77bc1a7c7c4e88c6cb7bef9cfe", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -184,7 +184,7 @@\n # default.\n #extended = false\n \n-# Installs chosen set of extended tools if enables. By default builds all.\n+# Installs chosen set of extended tools if enabled. By default builds all.\n # If chosen tool failed to build the installation fails.\n #tools = [\"cargo\", \"rls\", \"clippy\", \"rustfmt\", \"analysis\", \"src\"]\n "}, {"sha": "84415baa3a14085a63b572e0e4d625c18d077a42", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -119,17 +119,18 @@ fn main() {\n         cmd.arg(format!(\"-Cdebuginfo={}\", debuginfo_level));\n     }\n \n-    if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() &&\n-       env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none() {\n+    if env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none() {\n         // When extending this list, add the new lints to the RUSTFLAGS of the\n         // build_bootstrap function of src/bootstrap/bootstrap.py as well as\n         // some code doesn't go through this `rustc` wrapper.\n-        cmd.arg(\"-Dwarnings\");\n-        cmd.arg(\"-Drust_2018_idioms\");\n-        cmd.arg(\"-Dunused_lifetimes\");\n+        cmd.arg(\"-Wrust_2018_idioms\");\n+        cmd.arg(\"-Wunused_lifetimes\");\n         if use_internal_lints(crate_name) {\n             cmd.arg(\"-Zunstable-options\");\n-            cmd.arg(\"-Drustc::internal\");\n+            cmd.arg(\"-Wrustc::internal\");\n+        }\n+        if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() {\n+            cmd.arg(\"-Dwarnings\");\n         }\n     }\n "}, {"sha": "65129eeeec5041a267012ab20b59a31ec32b7a1b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -523,6 +523,10 @@ def get_toml(self, key, section=None):\n         'value2'\n         >>> rb.get_toml('key', 'c') is None\n         True\n+\n+        >>> rb.config_toml = 'key1 = true'\n+        >>> rb.get_toml(\"key1\")\n+        'true'\n         \"\"\"\n \n         cur_section = None\n@@ -571,6 +575,12 @@ def get_string(line):\n \n         >>> RustBuild.get_string('    \"devel\"   ')\n         'devel'\n+        >>> RustBuild.get_string(\"    'devel'   \")\n+        'devel'\n+        >>> RustBuild.get_string('devel') is None\n+        True\n+        >>> RustBuild.get_string('    \"devel   ')\n+        ''\n         \"\"\"\n         start = line.find('\"')\n         if start != -1:\n@@ -631,8 +641,9 @@ def build_bootstrap(self):\n         target_linker = self.get_toml(\"linker\", build_section)\n         if target_linker is not None:\n             env[\"RUSTFLAGS\"] += \"-C linker=\" + target_linker + \" \"\n+        env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes \"\n         if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n-            env[\"RUSTFLAGS\"] += \"-Dwarnings -Drust_2018_idioms -Dunused_lifetimes \"\n+            env[\"RUSTFLAGS\"] += \"-Dwarnings \"\n \n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n@@ -668,7 +679,7 @@ def check_submodule(self, module, slow_submodules):\n     def update_submodule(self, module, checked_out, recorded_submodules):\n         module_path = os.path.join(self.rust_root, module)\n \n-        if checked_out != None:\n+        if checked_out is not None:\n             default_encoding = sys.getdefaultencoding()\n             checked_out = checked_out.communicate()[0].decode(default_encoding).strip()\n             if recorded_submodules[module] == checked_out:\n@@ -697,6 +708,14 @@ def update_submodules(self):\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n                 self.get_toml('submodules') == \"false\":\n             return\n+\n+        # check the existence of 'git' command\n+        try:\n+            subprocess.check_output(['git', '--version'])\n+        except (subprocess.CalledProcessError, OSError):\n+            print(\"error: `git` is not found, please make sure it's installed and in the path.\")\n+            sys.exit(1)\n+\n         slow_submodules = self.get_toml('fast-submodules') == \"false\"\n         start_time = time()\n         if slow_submodules:\n@@ -821,13 +840,13 @@ def bootstrap(help_triggered):\n     except (OSError, IOError):\n         pass\n \n-    match = re.search(r'\\nverbose = (\\d+)', build.config_toml)\n-    if match is not None:\n-        build.verbose = max(build.verbose, int(match.group(1)))\n+    config_verbose = build.get_toml('verbose', 'build')\n+    if config_verbose is not None:\n+        build.verbose = max(build.verbose, int(config_verbose))\n \n-    build.use_vendored_sources = '\\nvendor = true' in build.config_toml\n+    build.use_vendored_sources = build.get_toml('vendor', 'build') == 'true'\n \n-    build.use_locked_deps = '\\nlocked-deps = true' in build.config_toml\n+    build.use_locked_deps = build.get_toml('locked-deps', 'build') == 'true'\n \n     build.check_vendored_status()\n "}, {"sha": "b7873fd1d35814b68811472fe5dea76e2faeca82", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1167,6 +1167,8 @@ impl<'a> Builder<'a> {\n             cargo.arg(\"--frozen\");\n         }\n \n+        cargo.env(\"RUSTC_INSTALL_BINDIR\", &self.config.bindir);\n+\n         self.ci_env.force_coloring_in_ci(&mut cargo);\n \n         cargo"}, {"sha": "9a964457ef285b630ad8bcf31fa5dc9c6b32388b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -212,6 +212,7 @@ pub fn std_cargo(builder: &Builder<'_>,\n                 emscripten: false,\n             });\n             cargo.env(\"LLVM_CONFIG\", llvm_config);\n+            cargo.env(\"RUSTC_BUILD_SANITIZERS\", \"1\");\n         }\n \n         cargo.arg(\"--features\").arg(features)"}, {"sha": "52b5cd888df9c20222db09aaf1b7a1920be57b90", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -137,7 +137,7 @@ pub struct Config {\n     pub sysconfdir: Option<PathBuf>,\n     pub datadir: Option<PathBuf>,\n     pub docdir: Option<PathBuf>,\n-    pub bindir: Option<PathBuf>,\n+    pub bindir: PathBuf,\n     pub libdir: Option<PathBuf>,\n     pub mandir: Option<PathBuf>,\n     pub codegen_tests: bool,\n@@ -400,6 +400,7 @@ impl Config {\n         config.incremental = flags.incremental;\n         config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n+        config.bindir = \"bin\".into(); // default\n         if let Some(value) = flags.deny_warnings {\n             config.deny_warnings = value;\n         }\n@@ -482,7 +483,7 @@ impl Config {\n             config.sysconfdir = install.sysconfdir.clone().map(PathBuf::from);\n             config.datadir = install.datadir.clone().map(PathBuf::from);\n             config.docdir = install.docdir.clone().map(PathBuf::from);\n-            config.bindir = install.bindir.clone().map(PathBuf::from);\n+            set(&mut config.bindir, install.bindir.clone().map(PathBuf::from));\n             config.libdir = install.libdir.clone().map(PathBuf::from);\n             config.mandir = install.mandir.clone().map(PathBuf::from);\n         }"}, {"sha": "e27a6bf7da0ac4f01fd4672458c7546ce8246ce6", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -762,7 +762,7 @@ impl Step for Analysis {\n             return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n-        builder.ensure(Std { compiler, target });\n+        builder.ensure(compile::Std { compiler, target });\n \n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n \n@@ -808,6 +808,7 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n             \"llvm-project/lld\", \"llvm-project\\\\lld\",\n             \"llvm-project/lldb\", \"llvm-project\\\\lldb\",\n             \"llvm-project/llvm\", \"llvm-project\\\\llvm\",\n+            \"llvm-project/compiler-rt\", \"llvm-project\\\\compiler-rt\",\n         ];\n         if spath.contains(\"llvm-project\") && !spath.ends_with(\"llvm-project\")\n             && !LLVM_PROJECTS.iter().any(|path| spath.contains(path))\n@@ -1999,6 +2000,8 @@ impl Step for HashSign {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n+        // This gets called by `promote-release`\n+        // (https://github.com/rust-lang/rust-central-station/tree/master/promote-release).\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n         if builder.config.dry_run {\n             return;\n@@ -2009,10 +2012,14 @@ impl Step for HashSign {\n         let addr = builder.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n         });\n-        let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n-            panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n-        });\n-        let pass = t!(fs::read_to_string(&file));\n+        let pass = if env::var(\"BUILD_MANIFEST_DISABLE_SIGNING\").is_err() {\n+            let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n+                panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n+            });\n+            t!(fs::read_to_string(&file))\n+        } else {\n+            String::new()\n+        };\n \n         let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n "}, {"sha": "873a3c31d1535fe5ed527c917706dc0a68560b40", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -476,11 +476,11 @@ impl Step for Std {\n                  .arg(\"--index-page\").arg(&builder.src.join(\"src/doc/index.md\"));\n \n             builder.run(&mut cargo);\n-            builder.cp_r(&my_out, &out);\n         };\n         for krate in &[\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"] {\n             run_cargo_rustdoc_for(krate);\n         }\n+        builder.cp_r(&my_out, &out);\n     }\n }\n "}, {"sha": "d9580b598155edc946002b2a77efa6ad0d73ad7f", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -36,7 +36,7 @@ pub struct Flags {\n     // This overrides the deny-warnings configuation option,\n     // which passes -Dwarnings to the compiler invocations.\n     //\n-    // true => deny, false => allow\n+    // true => deny, false => warn\n     pub deny_warnings: Option<bool>,\n }\n \n@@ -556,10 +556,10 @@ fn split(s: &[String]) -> Vec<String> {\n fn parse_deny_warnings(matches: &getopts::Matches) -> Option<bool> {\n     match matches.opt_str(\"warnings\").as_ref().map(|v| v.as_str()) {\n         Some(\"deny\") => Some(true),\n-        Some(\"allow\") => Some(false),\n+        Some(\"warn\") => Some(false),\n         Some(value) => {\n             eprintln!(\n-                r#\"invalid value for --warnings: {:?}, expected \"allow\" or \"deny\"\"#,\n+                r#\"invalid value for --warnings: {:?}, expected \"warn\" or \"deny\"\"#,\n                 value,\n                 );\n             process::exit(1);"}, {"sha": "384219c38fd0483f821754a19dc9029a5434173b", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -67,7 +67,6 @@ fn install_sh(\n     let sysconfdir_default = PathBuf::from(\"/etc\");\n     let datadir_default = PathBuf::from(\"share\");\n     let docdir_default = datadir_default.join(\"doc/rust\");\n-    let bindir_default = PathBuf::from(\"bin\");\n     let libdir_default = PathBuf::from(\"lib\");\n     let mandir_default = datadir_default.join(\"man\");\n     let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n@@ -76,7 +75,7 @@ fn install_sh(\n     let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n     let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n     let docdir = builder.config.docdir.as_ref().unwrap_or(&docdir_default);\n-    let bindir = builder.config.bindir.as_ref().unwrap_or(&bindir_default);\n+    let bindir = &builder.config.bindir;\n     let libdir = builder.config.libdir.as_ref().unwrap_or(&libdir_default);\n     let mandir = builder.config.mandir.as_ref().unwrap_or(&mandir_default);\n "}, {"sha": "7bf9ea2688f4c5a872d3f6f0b3f1ac645a9a7811", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -81,26 +81,29 @@ impl Step for Llvm {\n             (info, \"src/llvm-project/llvm\", builder.llvm_out(target), dir.join(\"bin\"))\n         };\n \n-        if !llvm_info.is_git() {\n-            println!(\n-                \"git could not determine the LLVM submodule commit hash. \\\n-                Assuming that an LLVM build is necessary.\",\n-            );\n-        }\n-\n         let build_llvm_config = llvm_config_ret_dir\n             .join(exe(\"llvm-config\", &*builder.config.build));\n         let done_stamp = out_dir.join(\"llvm-finished-building\");\n \n-        if let Some(llvm_commit) = llvm_info.sha() {\n-            if done_stamp.exists() {\n+        if done_stamp.exists() {\n+            if let Some(llvm_commit) = llvm_info.sha() {\n                 let done_contents = t!(fs::read(&done_stamp));\n \n                 // If LLVM was already built previously and the submodule's commit didn't change\n                 // from the previous build, then no action is required.\n                 if done_contents == llvm_commit.as_bytes() {\n-                    return build_llvm_config\n+                    return build_llvm_config;\n                 }\n+            } else {\n+                builder.info(\n+                    \"Could not determine the LLVM submodule commit hash. \\\n+                     Assuming that an LLVM rebuild is not necessary.\",\n+                );\n+                builder.info(&format!(\n+                    \"To force LLVM to rebuild, remove the file `{}`\",\n+                    done_stamp.display()\n+                ));\n+                return build_llvm_config;\n             }\n         }\n \n@@ -303,9 +306,7 @@ impl Step for Llvm {\n \n         cfg.build();\n \n-        if let Some(llvm_commit) = llvm_info.sha() {\n-            t!(fs::write(&done_stamp, llvm_commit));\n-        }\n+        t!(fs::write(&done_stamp, llvm_info.sha().unwrap_or(\"\")));\n \n         build_llvm_config\n     }"}, {"sha": "00d87f3841cfffd04af86c5c3139f36591aa3565", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1327,7 +1327,10 @@ impl Step for Compiletest {\n             cmd.env(\"RUSTC_PROFILER_SUPPORT\", \"1\");\n         }\n \n-        cmd.env(\"RUST_TEST_TMPDIR\", builder.out.join(\"tmp\"));\n+        let tmp = builder.out.join(\"tmp\");\n+        std::fs::create_dir_all(&tmp).unwrap();\n+        cmd.env(\"RUST_TEST_TMPDIR\", tmp);\n+\n \n         cmd.arg(\"--adb-path\").arg(\"adb\");\n         cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);"}, {"sha": "5f7761297095c8eef7e614f1eec90783b90775d5", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -7,7 +7,7 @@ trigger:\n   - auto\n \n variables:\n-- group: real-prod-credentials\n+- group: prod-credentials\n \n jobs:\n - job: Linux\n@@ -236,10 +236,16 @@ jobs:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n         SCRIPT: make ci-subset-1\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n       i686-msvc-2:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n         SCRIPT: make ci-subset-2\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n       # MSVC aux tests\n       x86_64-msvc-aux:\n         MSYS_BITS: 64\n@@ -250,6 +256,9 @@ jobs:\n         SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n         VCVARS_BAT: vcvars64.bat\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n       # MSVC tools tests\n       x86_64-msvc-tools:\n         MSYS_BITS: 64"}, {"sha": "e2baa923d99f7c8f493ee73868b468147f8c77aa", "filename": "src/ci/azure-pipelines/master.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fmaster.yml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -7,7 +7,7 @@ trigger:\n   - master\n \n variables:\n-- group: real-prod-credentials\n+- group: prod-credentials\n \n pool:\n   vmImage: ubuntu-16.04"}, {"sha": "bd4f1ed0cea439c4da31fd97114f16ef8511c865", "filename": "src/ci/azure-pipelines/steps/install-windows-build-deps.yml", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -18,9 +18,9 @@ steps:\n # one is MSI installers and one is EXE, but they're not used so frequently at\n # this point anyway so perhaps it's a wash!\n - script: |\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf is-install.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-08-22-is.exe\"\n-    is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n     echo ##vso[task.prependpath]C:\\Program Files (x86)\\Inno Setup 5\n+    curl.exe -o is-install.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-08-22-is.exe\n+    is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n   displayName: Install InnoSetup\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n \n@@ -43,24 +43,18 @@ steps:\n # FIXME: we should probe the default azure image and see if we can use the MSYS2\n # toolchain there. (if there's even one there). For now though this gets the job\n # done.\n-- script: |\n-    set MSYS_PATH=%CD%\\citools\\msys64\n-    choco install msys2 --params=\"/InstallDir:%MSYS_PATH% /NoPath\" -y\n-    set PATH=%MSYS_PATH%\\usr\\bin;%PATH%\n-    pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar\n-    IF \"%MINGW_URL%\"==\"\" (\n-      IF \"%MSYS_BITS%\"==\"32\" pacman -S --noconfirm --needed mingw-w64-i686-toolchain mingw-w64-i686-cmake mingw-w64-i686-gcc mingw-w64-i686-python2\n-      IF \"%MSYS_BITS%\"==\"64\" pacman -S --noconfirm --needed mingw-w64-x86_64-toolchain mingw-w64-x86_64-cmake mingw-w64-x86_64-gcc mingw-w64-x86_64-python2\n-    )\n-    where rev\n-    rev --help\n-    where make\n-\n-    echo ##vso[task.setvariable variable=MSYS_PATH]%MSYS_PATH%\n-    echo ##vso[task.prependpath]%MSYS_PATH%\\usr\\bin\n+- bash: |\n+    set -e\n+    choco install msys2 --params=\"/InstallDir:$(System.Workfolder)/msys2 /NoPath\" -y --no-progress\n+    echo \"##vso[task.prependpath]$(System.Workfolder)/msys2/usr/bin\"\n+    mkdir -p \"$(System.Workfolder)/msys2/home/$USERNAME\"\n   displayName: Install msys2\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n \n+- bash: pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar\n+  displayName: Install msys2 base deps\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n # If we need to download a custom MinGW, do so here and set the path\n # appropriately.\n #\n@@ -81,39 +75,46 @@ steps:\n #\n # Note that we don't literally overwrite the gdb.exe binary because it appears\n # to just use gdborig.exe, so that's the binary we deal with instead.\n-- script: |\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf %MINGW_ARCHIVE% %MINGW_URL%/%MINGW_ARCHIVE%\"\n-    7z x -y %MINGW_ARCHIVE% > nul\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_URL%/2017-04-20-%MSYS_BITS%bit-gdborig.exe\"\n-    mv 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_DIR%\\bin\\gdborig.exe\n-    echo ##vso[task.prependpath]%CD%\\%MINGW_DIR%\\bin\n+- bash: |\n+    set -e\n+    curl -o mingw.7z $MINGW_URL/$MINGW_ARCHIVE\n+    7z x -y mingw.7z > /dev/null\n+    curl -o $MINGW_DIR/bin/gdborig.exe $MINGW_URL/2017-04-20-${MSYS_BITS}bit-gdborig.exe\n+    echo \"##vso[task.prependpath]`pwd`/$MINGW_DIR/bin\"\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), ne(variables['MINGW_URL'],''))\n   displayName: Download custom MinGW\n \n-# Otherwise pull in the MinGW installed on appveyor\n-- script: |\n-    echo ##vso[task.prependpath]%MSYS_PATH%\\mingw%MSYS_BITS%\\bin\n+# Otherwise install MinGW through `pacman`\n+- bash: |\n+    set -e\n+    arch=i686\n+    if [ \"$MSYS_BITS\" = \"64\" ]; then\n+      arch=x86_64\n+    fi\n+    pacman -S --noconfirm --needed mingw-w64-$arch-toolchain mingw-w64-$arch-cmake mingw-w64-$arch-gcc mingw-w64-$arch-python2\n+    echo \"##vso[task.prependpath]$(System.Workfolder)/msys2/mingw$MSYS_BITS/bin\"\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n-  displayName: Add MinGW to path\n+  displayName: Download standard MinGW\n \n # Make sure we use the native python interpreter instead of some msys equivalent\n # one way or another. The msys interpreters seem to have weird path conversions\n # baked in which break LLVM's build system one way or another, so let's use the\n # native version which keeps everything as native as possible.\n-- script: |\n-    copy C:\\Python27amd64\\python.exe C:\\Python27amd64\\python2.7.exe\n-    echo ##vso[task.prependpath]C:\\Python27amd64\n+- bash: |\n+    set -e\n+    cp C:/Python27amd64/python.exe C:/Python27amd64/python2.7.exe\n+    echo \"##vso[task.prependpath]C:/Python27amd64\"\n   displayName: Prefer the \"native\" Python as LLVM has trouble building with MSYS sometimes\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n \n # Note that this is originally from the github releases patch of Ninja\n-- script: |\n-    md ninja\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-03-15-ninja-win.zip https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-03-15-ninja-win.zip\"\n-    7z x -oninja 2017-03-15-ninja-win.zip\n-    del 2017-03-15-ninja-win.zip\n-    set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja\n-    echo ##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]%RUST_CONFIGURE_ARGS%\n-    echo ##vso[task.prependpath]%CD%\\ninja\n+- bash: |\n+    set -e\n+    mkdir ninja\n+    curl -o ninja.zip https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-03-15-ninja-win.zip\n+    7z x -oninja ninja.zip\n+    rm ninja.zip\n+    echo \"##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]$RUST_CONFIGURE_ARGS --enable-ninja\"\n+    echo \"##vso[task.prependpath]`pwd`/ninja\"\n   displayName: Download and install ninja\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))"}, {"sha": "15a2499e4609e3c6bf0895001d2f49280f610c8e", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -147,8 +147,15 @@ steps:\n     git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n     cd rust-toolstate\n     python2.7 \"$BUILD_SOURCESDIRECTORY/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"\" \"\"\n+    # Only check maintainers if this build is supposed to publish toolstate.\n+    # Builds that are not supposed to publish don't have the access token.\n+    if [ -n \"${TOOLSTATE_PUBLISH+is_set}\" ]; then\n+      TOOLSTATE_VALIDATE_MAINTAINERS_REPO=rust-lang/rust python2.7 \"${BUILD_SOURCESDIRECTORY}/src/tools/publish_toolstate.py\"\n+    fi\n     cd ..\n     rm -rf rust-toolstate\n+  env:\n+    TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)\n   condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['IMAGE'], 'mingw-check'))\n   displayName: Verify the publish_toolstate script works\n \n@@ -168,7 +175,8 @@ steps:\n   env:\n     CI: true\n     SRC: .\n-    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+    AWS_ACCESS_KEY_ID: $(SCCACHE_AWS_ACCESS_KEY_ID)\n+    AWS_SECRET_ACCESS_KEY: $(SCCACHE_AWS_SECRET_ACCESS_KEY)\n     TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n   displayName: Run build\n@@ -192,7 +200,8 @@ steps:\n     fi\n     retry aws s3 cp --no-progress --recursive --acl public-read ./$upload_dir s3://$DEPLOY_BUCKET/$deploy_dir/$BUILD_SOURCEVERSION\n   env:\n-    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+    AWS_ACCESS_KEY_ID: $(UPLOAD_AWS_ACCESS_KEY_ID)\n+    AWS_SECRET_ACCESS_KEY: $(UPLOAD_AWS_SECRET_ACCESS_KEY)\n   condition: and(succeeded(), not(variables.SKIP_JOB), or(eq(variables.DEPLOY, '1'), eq(variables.DEPLOY_ALT, '1')))\n   displayName: Upload artifacts\n \n@@ -201,7 +210,8 @@ steps:\n # errors here ever fail the build since this is just informational.\n - bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$CI_JOB_NAME.csv\n   env:\n-    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n-  condition: variables['AWS_SECRET_ACCESS_KEY']\n+    AWS_ACCESS_KEY_ID: $(UPLOAD_AWS_ACCESS_KEY_ID)\n+    AWS_SECRET_ACCESS_KEY: $(UPLOAD_AWS_SECRET_ACCESS_KEY)\n+  condition: variables['UPLOAD_AWS_SECRET_ACCESS_KEY']\n   continueOnError: true\n   displayName: Upload CPU usage statistics"}, {"sha": "c919b1023a0eb2c53de10f3b09b15f442fd5fdcb", "filename": "src/ci/azure-pipelines/try.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fazure-pipelines%2Ftry.yml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fazure-pipelines%2Ftry.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Ftry.yml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -3,7 +3,7 @@ trigger:\n - try\n \n variables:\n-- group: real-prod-credentials\n+- group: prod-credentials\n \n jobs:\n - job: Linux"}, {"sha": "517b59c38dcb06b7441802344782df01813a0a1a", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -19,3 +19,6 @@ RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n ENV SCRIPT python2.7 ../x.py test\n+\n+# FIXME(#59637) takes too long on CI right now\n+ENV NO_LLVM_ASSERTIONS=1 NO_DEBUG_ASSERTIONS=1"}, {"sha": "03db3ba0995d6a94ff0a0737b3e210258d7706e5", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -25,3 +25,6 @@ ENV SCRIPT python2.7 ../x.py test \\\n   --exclude src/test/rustdoc-js \\\n   --exclude src/tools/error_index_generator \\\n   --exclude src/tools/linkchecker\n+\n+# FIXME(#59637) takes too long on CI right now\n+ENV NO_LLVM_ASSERTIONS=1 NO_DEBUG_ASSERTIONS=1"}, {"sha": "871416b85c1a73717d65d6f4a9ea29e5aef3db0e", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1 +1 @@\n-Subproject commit 7ddc46460f09a5cd9bd2a620565bdc20b3315ea9\n+Subproject commit 871416b85c1a73717d65d6f4a9ea29e5aef3db0e"}, {"sha": "4374786f0b4bf0606b35d5c30a9681f342e5707b", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1 +1 @@\n-Subproject commit 38b9a76bc8b59ac862663807fc51c9b757337fd6\n+Subproject commit 4374786f0b4bf0606b35d5c30a9681f342e5707b"}, {"sha": "fa5dfb832ef8a7568e17dabf612f486d641ff4ac", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1 +1 @@\n-Subproject commit 090c015f7939665866432c334957bd536c811870\n+Subproject commit fa5dfb832ef8a7568e17dabf612f486d641ff4ac"}, {"sha": "67cfbf31df880728dcf7cb35b15b028ec92caf31", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1 +1 @@\n-Subproject commit e76be6b2dc84c6a992e186157efe29d625e29b94\n+Subproject commit 67cfbf31df880728dcf7cb35b15b028ec92caf31"}, {"sha": "941968db2fd9c85788a4f971c8e425d46b4cb734", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1 +1 @@\n-Subproject commit 6e25a3d0d3573eb42b2e2339f1219e969d1b3dee\n+Subproject commit 941968db2fd9c85788a4f971c8e425d46b4cb734"}, {"sha": "49d05b5038df74dd8ff7bd53545adc7fdfc123d9", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -471,3 +471,53 @@ Some methodology notes about what rustdoc counts in this metric:\n \n Public items that are not documented can be seen with the built-in `missing_docs` lint. Private\n items that are not documented can be seen with Clippy's `missing_docs_in_private_items` lint.\n+\n+### `--enable-per-target-ignores`: allow `ignore-foo` style filters for doctests\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --enable-per-target-ignores\n+```\n+\n+This flag allows you to tag doctests with compiltest style `ignore-foo` filters that prevent\n+rustdoc from running that test if the target triple string contains foo. For example:\n+\n+```rust\n+///```ignore-foo,ignore-bar\n+///assert!(2 == 2);\n+///```\n+struct Foo;\n+```\n+\n+This will not be run when the build target is `super-awesome-foo` or `less-bar-awesome`.\n+If the flag is not enabled, then rustdoc will consume the filter, but do nothing with it, and\n+the above example will be run for all targets.\n+If you want to preserve backwards compatibility for older versions of rustdoc, you can use\n+\n+```rust\n+///```ignore,ignore-foo\n+///assert!(2 == 2);\n+///```\n+struct Foo;\n+```\n+\n+In older versions, this will be ignored on all targets, but on newer versions `ignore-gnu` will\n+override `ignore`.\n+\n+### `--runtool`, `--runtool-arg`: program to run tests with; args to pass to it\n+\n+Using thses options looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --runtool runner --runtool-arg --do-thing --runtool-arg --do-other-thing\n+```\n+\n+These options can be used to run the doctest under a program, and also pass arguments to\n+that program. For example, if you want to run your doctests under valgrind you might run\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --runtool valgrind\n+```\n+\n+Another use case would be to run a test inside an emulator, or through a Virtual Machine."}, {"sha": "7c2e91474c1f1710e5f85c62d09c47ea957e19ba", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -45,7 +45,10 @@ def normalize_whitespace(s):\n \n def breakpoint_callback(frame, bp_loc, dict):\n     \"\"\"This callback is registered with every breakpoint and makes sure that the\n-    frame containing the breakpoint location is selected\"\"\"\n+    frame containing the breakpoint location is selected \"\"\"\n+\n+    # HACK(eddyb) print a newline to avoid continuing an unfinished line.\n+    print(\"\")\n     print(\"Hit breakpoint \" + str(bp_loc))\n \n     # Select the frame and the thread containing it"}, {"sha": "0cb91ba4c81da148c9f89dde57ca042162b7e529", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -3,7 +3,7 @@\n \n use core::borrow::Borrow;\n use core::cmp::Ordering::{self, Less, Greater, Equal};\n-use core::cmp::max;\n+use core::cmp::{max, min};\n use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n@@ -187,8 +187,8 @@ pub struct Intersection<'a, T: 'a> {\n }\n enum IntersectionInner<'a, T: 'a> {\n     Stitch {\n-        small_iter: Iter<'a, T>, // for size_hint, should be the smaller of the sets\n-        other_iter: Iter<'a, T>,\n+        a: Iter<'a, T>,\n+        b: Iter<'a, T>,\n     },\n     Search {\n         small_iter: Iter<'a, T>,\n@@ -201,12 +201,12 @@ impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match &self.inner {\n             IntersectionInner::Stitch {\n-                small_iter,\n-                other_iter,\n+                a,\n+                b,\n             } => f\n                 .debug_tuple(\"Intersection\")\n-                .field(&small_iter)\n-                .field(&other_iter)\n+                .field(&a)\n+                .field(&b)\n                 .finish(),\n             IntersectionInner::Search {\n                 small_iter,\n@@ -397,8 +397,8 @@ impl<T: Ord> BTreeSet<T> {\n             // Iterate both sets jointly, spotting matches along the way.\n             Intersection {\n                 inner: IntersectionInner::Stitch {\n-                    small_iter: small.iter(),\n-                    other_iter: other.iter(),\n+                    a: small.iter(),\n+                    b: other.iter(),\n                 },\n             }\n         } else {\n@@ -1221,11 +1221,11 @@ impl<T> Clone for Intersection<'_, T> {\n         Intersection {\n             inner: match &self.inner {\n                 IntersectionInner::Stitch {\n-                    small_iter,\n-                    other_iter,\n+                    a,\n+                    b,\n                 } => IntersectionInner::Stitch {\n-                    small_iter: small_iter.clone(),\n-                    other_iter: other_iter.clone(),\n+                    a: a.clone(),\n+                    b: b.clone(),\n                 },\n                 IntersectionInner::Search {\n                     small_iter,\n@@ -1245,16 +1245,16 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         match &mut self.inner {\n             IntersectionInner::Stitch {\n-                small_iter,\n-                other_iter,\n+                a,\n+                b,\n             } => {\n-                let mut small_next = small_iter.next()?;\n-                let mut other_next = other_iter.next()?;\n+                let mut a_next = a.next()?;\n+                let mut b_next = b.next()?;\n                 loop {\n-                    match Ord::cmp(small_next, other_next) {\n-                        Less => small_next = small_iter.next()?,\n-                        Greater => other_next = other_iter.next()?,\n-                        Equal => return Some(small_next),\n+                    match Ord::cmp(a_next, b_next) {\n+                        Less => a_next = a.next()?,\n+                        Greater => b_next = b.next()?,\n+                        Equal => return Some(a_next),\n                     }\n                 }\n             }\n@@ -1272,7 +1272,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let min_len = match &self.inner {\n-            IntersectionInner::Stitch { small_iter, .. } => small_iter.len(),\n+            IntersectionInner::Stitch { a, b } => min(a.len(), b.len()),\n             IntersectionInner::Search { small_iter, .. } => small_iter.len(),\n         };\n         (0, Some(min_len))"}, {"sha": "ecb5948f11b363447d0738106c8175be60e06346", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -102,8 +102,8 @@ fn test_append() {\n         assert_eq!(m.pop_front(), Some(elt))\n     }\n     assert_eq!(n.len(), 0);\n-    // let's make sure it's working properly, since we\n-    // did some direct changes to private members\n+    // Let's make sure it's working properly, since we\n+    // did some direct changes to private members.\n     n.push_back(3);\n     assert_eq!(n.len(), 1);\n     assert_eq!(n.pop_front(), Some(3));"}, {"sha": "9e6ed92ffb567295d9a312f174838ddbcb11c48b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -117,7 +117,7 @@\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n #![feature(rustc_const_unstable)]\n-#![feature(const_vec_new)]\n+#![cfg_attr(bootstrap, feature(const_vec_new))]\n #![feature(slice_partition_dedup)]\n #![feature(maybe_uninit_extra, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]\n@@ -171,3 +171,9 @@ pub mod vec;\n mod std {\n     pub use core::ops; // RangeFull\n }\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"liballoc_internals\", issue = \"0\", reason = \"implementation detail\")]\n+pub mod __export {\n+    pub use core::format_args;\n+}"}, {"sha": "2f2cdc39c633db3f763d302db11cfdb6c0602031", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -98,5 +98,5 @@ macro_rules! vec {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! format {\n-    ($($arg:tt)*) => ($crate::fmt::format(::core::format_args!($($arg)*)))\n+    ($($arg:tt)*) => ($crate::fmt::format($crate::__export::format_args!($($arg)*)))\n }"}, {"sha": "ee75fc288fee5b7a380b071944c6affc2825103a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 100, "deletions": 77, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -19,26 +19,26 @@ mod tests;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces Unique::empty() on zero-sized types\n-/// * Produces Unique::empty() on zero-length allocations\n-/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n-/// * Guards against 32-bit systems allocating more than isize::MAX bytes\n-/// * Guards against overflowing your length\n-/// * Aborts on OOM or calls handle_alloc_error as applicable\n-/// * Avoids freeing Unique::empty()\n-/// * Contains a ptr::Unique and thus endows the user with all related benefits\n+/// * Produces `Unique::empty()` on zero-sized types.\n+/// * Produces `Unique::empty()` on zero-length allocations.\n+/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n+/// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n+/// * Guards against overflowing your length.\n+/// * Aborts on OOM or calls `handle_alloc_error` as applicable.\n+/// * Avoids freeing `Unique::empty()`.\n+/// * Contains a `ptr::Unique` and thus endows the user with all related benefits.\n ///\n /// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n-/// free its memory, but it *won't* try to Drop its contents. It is up to the user of RawVec\n-/// to handle the actual things *stored* inside of a RawVec.\n+/// free its memory, but it *won't* try to drop its contents. It is up to the user of `RawVec`\n+/// to handle the actual things *stored* inside of a `RawVec`.\n ///\n-/// Note that a RawVec always forces its capacity to be usize::MAX for zero-sized types.\n-/// This enables you to use capacity growing logic catch the overflows in your length\n+/// Note that a `RawVec` always forces its capacity to be `usize::MAX` for zero-sized types.\n+/// This enables you to use capacity-growing logic catch the overflows in your length\n /// that might occur with zero-sized types.\n ///\n-/// However this means that you need to be careful when round-tripping this type\n-/// with a `Box<[T]>`: `capacity()` won't yield the len. However `with_capacity`,\n-/// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n+/// The above means that you need to be careful when round-tripping this type with a\n+/// `Box<[T]>`, since `capacity()` won't yield the length. However, `with_capacity`,\n+/// `shrink_to_fit`, and `from_box` will actually set `RawVec`'s private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n #[allow(missing_debug_implementations)]\n@@ -49,14 +49,14 @@ pub struct RawVec<T, A: Alloc = Global> {\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Like `new` but parameterized over the choice of allocator for\n-    /// the returned RawVec.\n+    /// Like `new`, but parameterized over the choice of allocator for\n+    /// the returned `RawVec`.\n     pub const fn new_in(a: A) -> Self {\n-        // !0 is usize::MAX. This branch should be stripped at compile time.\n-        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`\n+        // `!0` is `usize::MAX`. This branch should be stripped at compile time.\n+        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`:\n         //let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n-        // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n+        // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n         RawVec {\n             ptr: Unique::empty(),\n             // FIXME(mark-i-m): use `cap` when ifs are allowed in const\n@@ -65,15 +65,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n-    /// Like `with_capacity` but parameterized over the choice of\n-    /// allocator for the returned RawVec.\n+    /// Like `with_capacity`, but parameterized over the choice of\n+    /// allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n         RawVec::allocate_in(capacity, false, a)\n     }\n \n-    /// Like `with_capacity_zeroed` but parameterized over the choice\n-    /// of allocator for the returned RawVec.\n+    /// Like `with_capacity_zeroed`, but parameterized over the choice\n+    /// of allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n         RawVec::allocate_in(capacity, true, a)\n@@ -86,7 +86,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n             alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n \n-            // handles ZSTs and `capacity = 0` alike\n+            // Handles ZSTs and `capacity == 0` alike.\n             let ptr = if alloc_size == 0 {\n                 NonNull::<T>::dangling()\n             } else {\n@@ -113,20 +113,45 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Creates the biggest possible RawVec (on the system heap)\n-    /// without allocating. If T has positive size, then this makes a\n-    /// RawVec with capacity 0. If T has 0 size, then it makes a\n-    /// RawVec with capacity `usize::MAX`. Useful for implementing\n+    /// HACK(Centril): This exists because `#[unstable]` `const fn`s needn't conform\n+    /// to `min_const_fn` and so they cannot be called in `min_const_fn`s either.\n+    ///\n+    /// If you change `RawVec<T>::new` or dependencies, please take care to not\n+    /// introduce anything that would truly violate `min_const_fn`.\n+    ///\n+    /// NOTE: We could avoid this hack and check conformance with some\n+    /// `#[rustc_force_min_const_fn]` attribute which requires conformance\n+    /// with `min_const_fn` but does not necessarily allow calling it in\n+    /// `stable(...) const fn` / user code not enabling `foo` when\n+    /// `#[rustc_const_unstable(feature = \"foo\", ..)]` is present.\n+    pub const NEW: Self = Self::new();\n+\n+    /// Creates the biggest possible `RawVec` (on the system heap)\n+    /// without allocating. If `T` has positive size, then this makes a\n+    /// `RawVec` with capacity `0`. If `T` is zero-sized, then it makes a\n+    /// `RawVec` with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub const fn new() -> Self {\n-        Self::new_in(Global)\n+        // FIXME(Centril): Reintegrate this with `fn new_in` when we can.\n+\n+        // `!0` is `usize::MAX`. This branch should be stripped at compile time.\n+        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`:\n+        //let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+\n+        // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n+        RawVec {\n+            ptr: Unique::empty(),\n+            // FIXME(mark-i-m): use `cap` when ifs are allowed in const\n+            cap: [0, !0][(mem::size_of::<T>() == 0) as usize],\n+            a: Global,\n+        }\n     }\n \n-    /// Creates a RawVec (on the system heap) with exactly the\n+    /// Creates a `RawVec` (on the system heap) with exactly the\n     /// capacity and alignment requirements for a `[T; capacity]`. This is\n-    /// equivalent to calling RawVec::new when `capacity` is 0 or T is\n+    /// equivalent to calling `RawVec::new` when `capacity` is `0` or `T` is\n     /// zero-sized. Note that if `T` is zero-sized this means you will\n-    /// *not* get a RawVec with the requested capacity!\n+    /// *not* get a `RawVec` with the requested capacity.\n     ///\n     /// # Panics\n     ///\n@@ -136,27 +161,27 @@ impl<T> RawVec<T, Global> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         RawVec::allocate_in(capacity, false, Global)\n     }\n \n-    /// Like `with_capacity` but guarantees the buffer is zeroed.\n+    /// Like `with_capacity`, but guarantees the buffer is zeroed.\n     #[inline]\n     pub fn with_capacity_zeroed(capacity: usize) -> Self {\n         RawVec::allocate_in(capacity, true, Global)\n     }\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Reconstitutes a RawVec from a pointer, capacity, and allocator.\n+    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n     ///\n     /// # Undefined Behavior\n     ///\n-    /// The ptr must be allocated (via the given allocator `a`), and with the given capacity. The\n-    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n+    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n+    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n     pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n@@ -167,13 +192,13 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Reconstitutes a RawVec from a pointer, capacity.\n+    /// Reconstitutes a `RawVec` from a pointer and capacity.\n     ///\n     /// # Undefined Behavior\n     ///\n-    /// The ptr must be allocated (on the system heap), and with the given capacity. The\n-    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n+    /// The `ptr` must be allocated (on the system heap), and with the given `capacity`.\n+    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n     pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n@@ -194,7 +219,7 @@ impl<T> RawVec<T, Global> {\n \n impl<T, A: Alloc> RawVec<T, A> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// Unique::empty() if `capacity = 0` or T is zero-sized. In the former case, you must\n+    /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n         self.ptr.as_ptr()\n@@ -212,12 +237,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n-    /// Returns a shared reference to the allocator backing this RawVec.\n+    /// Returns a shared reference to the allocator backing this `RawVec`.\n     pub fn alloc(&self) -> &A {\n         &self.a\n     }\n \n-    /// Returns a mutable reference to the allocator backing this RawVec.\n+    /// Returns a mutable reference to the allocator backing this `RawVec`.\n     pub fn alloc_mut(&mut self) -> &mut A {\n         &mut self.a\n     }\n@@ -247,7 +272,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n+    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n     ///   all `usize::MAX` slots in your imaginary buffer.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n@@ -290,20 +315,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the RawVec is overfull.\n+            // Since we set the capacity to `usize::MAX` when `elem_size` is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n             let (new_cap, uniq) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n-                    // isize::MAX bytes, `elem_size * self.cap <= isize::MAX` as\n+                    // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n                     // a precondition, so this can't overflow. Additionally the\n                     // alignment will never be too large as to \"not be\n                     // satisfiable\", so `Layout::from_size_align` will always\n                     // return `Some`.\n                     //\n-                    // tl;dr; we bypass runtime checks due to dynamic assertions\n+                    // TL;DR, we bypass runtime checks due to dynamic assertions\n                     // in this module, allowing us to use\n                     // `from_size_align_unchecked`.\n                     let new_cap = 2 * self.cap;\n@@ -320,8 +345,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     }\n                 }\n                 None => {\n-                    // skip to 4 because tiny Vec's are dumb; but not if that\n-                    // would cause overflow\n+                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n+                    // would cause overflow.\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     match self.a.alloc_array::<T>(new_cap) {\n                         Ok(ptr) => (new_cap, ptr.into()),\n@@ -342,7 +367,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n+    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n     ///   all `usize::MAX` slots in your imaginary buffer.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n@@ -356,15 +381,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 None => return false, // nothing to double\n             };\n \n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the RawVec is overfull.\n+            // Since we set the capacity to `usize::MAX` when `elem_size` is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            // Since we guarantee that we never allocate more than isize::MAX\n+            // Since we guarantee that we never allocate more than `isize::MAX`\n             // bytes, `elem_size * self.cap <= isize::MAX` as a precondition, so\n             // this can't overflow.\n             //\n-            // Similarly like with `double` above we can go straight to\n+            // Similarly to with `double` above, we can go straight to\n             // `Layout::from_size_align_unchecked` as we know this won't\n             // overflow and the alignment is sufficiently small.\n             let new_cap = 2 * self.cap;\n@@ -409,7 +434,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n@@ -424,7 +449,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n         -> Result<usize, TryReserveError> {\n \n-        // Nothing we can really do about these checks :(\n+        // Nothing we can really do about these checks, sadly.\n         let required_cap = used_capacity.checked_add(needed_extra_capacity)\n             .ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n@@ -459,7 +484,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     ///\n     /// # Examples\n     ///\n@@ -538,7 +563,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Here, `cap < used_capacity + needed_extra_capacity <= new_cap`\n             // (regardless of whether `self.cap - used_capacity` wrapped).\n-            // Therefore we can safely call grow_in_place.\n+            // Therefore, we can safely call `grow_in_place`.\n \n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n@@ -576,14 +601,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n             return;\n         }\n \n-        // This check is my waterloo; it's the only thing Vec wouldn't have to do.\n+        // This check is my waterloo; it's the only thing `Vec` wouldn't have to do.\n         assert!(self.cap >= amount, \"Tried to shrink to a larger capacity\");\n \n         if amount == 0 {\n             // We want to create a new zero-length vector within the\n-            // same allocator.  We use ptr::write to avoid an\n+            // same allocator. We use `ptr::write` to avoid an\n             // erroneous attempt to drop the contents, and we use\n-            // ptr::read to sidestep condition against destructuring\n+            // `ptr::read` to sidestep condition against destructuring\n             // types that implement Drop.\n \n             unsafe {\n@@ -600,7 +625,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 //\n                 // We also know that `self.cap` is greater than `amount`, and\n                 // consequently we don't need runtime checks for creating either\n-                // layout\n+                // layout.\n                 let old_size = elem_size * self.cap;\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n@@ -653,7 +678,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 return Ok(());\n             }\n \n-            // Nothing we can really do about these checks :(\n+            // Nothing we can really do about these checks, sadly.\n             let new_cap = match strategy {\n                 Exact => used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?,\n                 Amortized => self.amortized_new_size(used_capacity, needed_extra_capacity)?,\n@@ -692,15 +717,15 @@ impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n     /// Note that this will correctly reconstitute any `cap` changes\n-    /// that may have been performed. (see description of type for details)\n+    /// that may have been performed. (See description of type for details.)\n     ///\n     /// # Undefined Behavior\n     ///\n     /// All elements of `RawVec<T, Global>` must be initialized. Notice that\n     /// the rules around uninitialized boxed values are not finalized yet,\n     /// but until they are, it is advisable to avoid them.\n     pub unsafe fn into_box(self) -> Box<[T]> {\n-        // NOTE: not calling `capacity()` here, actually using the real `cap` field!\n+        // NOTE: not calling `capacity()` here; actually using the real `cap` field!\n         let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n         let output: Box<[T]> = Box::from_raw(slice);\n         mem::forget(self);\n@@ -709,7 +734,7 @@ impl<T> RawVec<T, Global> {\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n+    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     pub unsafe fn dealloc_buffer(&mut self) {\n         let elem_size = mem::size_of::<T>();\n         if elem_size != 0 {\n@@ -721,22 +746,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n-    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n+    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n         unsafe { self.dealloc_buffer(); }\n     }\n }\n \n-\n-\n // We need to guarantee the following:\n-// * We don't ever allocate `> isize::MAX` byte-size objects\n-// * We don't overflow `usize::MAX` and actually allocate too little\n+// * We don't ever allocate `> isize::MAX` byte-size objects.\n+// * We don't overflow `usize::MAX` and actually allocate too little.\n //\n // On 64-bit we just need to check for overflow since trying to allocate\n // `> isize::MAX` bytes will surely fail. On 32-bit and 16-bit we need to add\n // an extra guard for this in case we're running on a platform which can use\n-// all 4GB in user-space. e.g., PAE or x32\n+// all 4GB in user-space, e.g., PAE or x32.\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n@@ -751,5 +774,5 @@ fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n // ensure that the code generation related to these panics is minimal as there's\n // only one location which panics rather than a bunch throughout the module.\n fn capacity_overflow() -> ! {\n-    panic!(\"capacity overflow\")\n+    panic!(\"capacity overflow\");\n }"}, {"sha": "d35b62fc1ef15ce8b18ac8bd7628b38a3c9190ee", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -5,12 +5,12 @@ fn allocator_param() {\n     use crate::alloc::AllocErr;\n \n     // Writing a test of integration between third-party\n-    // allocators and RawVec is a little tricky because the RawVec\n+    // allocators and `RawVec` is a little tricky because the `RawVec`\n     // API does not expose fallible allocation methods, so we\n     // cannot check what happens when allocator is exhausted\n     // (beyond detecting a panic).\n     //\n-    // Instead, this just checks that the RawVec methods do at\n+    // Instead, this just checks that the `RawVec` methods do at\n     // least go through the Allocator API when it reserves\n     // storage.\n \n@@ -44,7 +44,7 @@ fn allocator_param() {\n fn reserve_does_not_overallocate() {\n     {\n         let mut v: RawVec<u32> = RawVec::new();\n-        // First `reserve` allocates like `reserve_exact`\n+        // First, `reserve` allocates like `reserve_exact`.\n         v.reserve(0, 9);\n         assert_eq!(9, v.capacity());\n     }"}, {"sha": "f234ac5ebe51bcd2628df98ccbe5d86199eb5c9d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -567,7 +567,7 @@ impl<T: ?Sized> Rc<T> {\n     ///     let x = Rc::from_raw(x_ptr);\n     ///     assert_eq!(&*x, \"hello\");\n     ///\n-    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory unsafe.\n+    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory-unsafe.\n     /// }\n     ///\n     /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n@@ -1832,8 +1832,9 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just values\n-    /// that compare as equal).\n+    /// Returns `true` if the two `Weak`s point to the same value (not just\n+    /// values that compare as equal), or if both don't point to any value\n+    /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n@@ -1843,7 +1844,6 @@ impl<T: ?Sized> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_ptr_eq)]\n     /// use std::rc::Rc;\n     ///\n     /// let first_rc = Rc::new(5);\n@@ -1861,7 +1861,6 @@ impl<T: ?Sized> Weak<T> {\n     /// Comparing `Weak::new`.\n     ///\n     /// ```\n-    /// #![feature(weak_ptr_eq)]\n     /// use std::rc::{Rc, Weak};\n     ///\n     /// let first = Weak::new();\n@@ -1873,7 +1872,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n+    #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n         self.ptr.as_ptr() == other.ptr.as_ptr()\n     }"}, {"sha": "1166e7b5df2959bb3d6d64af27e56b193a898045", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -369,7 +369,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_string_new\")]\n+    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_string_new\"))]\n     pub const fn new() -> String {\n         String { vec: Vec::new() }\n     }"}, {"sha": "45f98162e4cd57fa3e8798f31b2ee6f76025a68c", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -547,7 +547,7 @@ impl<T: ?Sized> Arc<T> {\n     ///     let x = Arc::from_raw(x_ptr);\n     ///     assert_eq!(&*x, \"hello\");\n     ///\n-    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n+    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.\n     /// }\n     ///\n     /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n@@ -1550,19 +1550,18 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just values\n-    /// that compare as equal).\n+    /// Returns `true` if the two `Weak`s point to the same value (not just\n+    /// values that compare as equal), or if both don't point to any value\n+    /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n     /// other, even though they don't point to any value.\n     ///\n-    ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_ptr_eq)]\n     /// use std::sync::Arc;\n     ///\n     /// let first_rc = Arc::new(5);\n@@ -1580,7 +1579,6 @@ impl<T: ?Sized> Weak<T> {\n     /// Comparing `Weak::new`.\n     ///\n     /// ```\n-    /// #![feature(weak_ptr_eq)]\n     /// use std::sync::{Arc, Weak};\n     ///\n     /// let first = Weak::new();\n@@ -1592,7 +1590,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n+    #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n         self.ptr.as_ptr() == other.ptr.as_ptr()\n     }"}, {"sha": "35db18c39c83a705be03ec3b6813c03db8ba06fe", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -90,6 +90,17 @@ fn test_intersection() {\n                        &[1, 3, 11, 77, 103]);\n }\n \n+#[test]\n+fn test_intersection_size_hint() {\n+    let x: BTreeSet<i32> = [3, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.intersection(&y);\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n+    assert_eq!(iter.next(), Some(&3));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+    assert_eq!(iter.next(), None);\n+}\n+\n #[test]\n fn test_difference() {\n     fn check_difference(a: &[i32], b: &[i32], expected: &[i32]) {"}, {"sha": "405969a550b88121395350ff4d70d9e4a570bfd8", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -314,10 +314,10 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_vec_new\")]\n+    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_vec_new\"))]\n     pub const fn new() -> Vec<T> {\n         Vec {\n-            buf: RawVec::new(),\n+            buf: RawVec::NEW,\n             len: 0,\n         }\n     }\n@@ -685,21 +685,25 @@ impl<T> Vec<T> {\n     /// [`drain`]: #method.drain\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: usize) {\n-        let current_len = self.len;\n-        unsafe {\n-            let mut ptr = self.as_mut_ptr().add(self.len);\n-            // Set the final length at the end, keeping in mind that\n-            // dropping an element might panic. Works around a missed\n-            // optimization, as seen in the following issue:\n-            // https://github.com/rust-lang/rust/issues/51802\n-            let mut local_len = SetLenOnDrop::new(&mut self.len);\n+        if mem::needs_drop::<T>() {\n+            let current_len = self.len;\n+            unsafe {\n+                let mut ptr = self.as_mut_ptr().add(self.len);\n+                // Set the final length at the end, keeping in mind that\n+                // dropping an element might panic. Works around a missed\n+                // optimization, as seen in the following issue:\n+                // https://github.com/rust-lang/rust/issues/51802\n+                let mut local_len = SetLenOnDrop::new(&mut self.len);\n \n-            // drop any extra elements\n-            for _ in len..current_len {\n-                local_len.decrement_len(1);\n-                ptr = ptr.offset(-1);\n-                ptr::drop_in_place(ptr);\n+                // drop any extra elements\n+                for _ in len..current_len {\n+                    local_len.decrement_len(1);\n+                    ptr = ptr.offset(-1);\n+                    ptr::drop_in_place(ptr);\n+                }\n             }\n+        } else if len <= self.len {\n+            self.len = len;\n         }\n     }\n "}, {"sha": "0afbf4f134679b7343de55c5e8377a577cfd2323", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -153,13 +153,13 @@ impl dyn Any {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: Any>(&self) -> bool {\n-        // Get TypeId of the type this function is instantiated with\n+        // Get `TypeId` of the type this function is instantiated with.\n         let t = TypeId::of::<T>();\n \n-        // Get TypeId of the type in the trait object\n+        // Get `TypeId` of the type in the trait object.\n         let concrete = self.type_id();\n \n-        // Compare both TypeIds on equality\n+        // Compare both `TypeId`s on equality.\n         t == concrete\n     }\n "}, {"sha": "32ec26975e375291ec503bd2194c7419e041f917", "filename": "src/libcore/bool.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -0,0 +1,45 @@\n+//! impl bool {}\n+\n+#[cfg(not(boostrap_stdarch_ignore_this))]\n+#[lang = \"bool\"]\n+impl bool {\n+    /// Returns `Some(t)` if the `bool` is `true`, or `None` otherwise.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(bool_to_option)]\n+    ///\n+    /// assert_eq!(false.then(0), None);\n+    /// assert_eq!(true.then(0), Some(0));\n+    /// ```\n+    #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n+    #[inline]\n+    pub fn then<T>(self, t: T) -> Option<T> {\n+        if self {\n+            Some(t)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns `Some(f())` if the `bool` is `true`, or `None` otherwise.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(bool_to_option)]\n+    ///\n+    /// assert_eq!(false.then_with(|| 0), None);\n+    /// assert_eq!(true.then_with(|| 0), Some(0));\n+    /// ```\n+    #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n+    #[inline]\n+    pub fn then_with<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n+        if self {\n+            Some(f())\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "06f2b7bab12ebc548c8c051ce8ee3d1a258b3eb2", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -42,11 +42,11 @@\n \n use crate::fmt;\n \n-/// An identity function.\n+/// The identity function.\n ///\n /// Two things are important to note about this function:\n ///\n-/// - It is not always equivalent to a closure like `|x| x` since the\n+/// - It is not always equivalent to a closure like `|x| x`, since the\n ///   closure may coerce `x` into a different type.\n ///\n /// - It moves the input `x` passed to the function.\n@@ -56,31 +56,32 @@ use crate::fmt;\n ///\n /// # Examples\n ///\n-/// Using `identity` to do nothing among other interesting functions:\n+/// Using `identity` to do nothing in a sequence of other, interesting,\n+/// functions:\n ///\n /// ```rust\n /// use std::convert::identity;\n ///\n /// fn manipulation(x: u32) -> u32 {\n-///     // Let's assume that this function does something interesting.\n+///     // Let's pretend that adding one is an interesting function.\n ///     x + 1\n /// }\n ///\n /// let _arr = &[identity, manipulation];\n /// ```\n ///\n-/// Using `identity` to get a function that changes nothing in a conditional:\n+/// Using `identity` as a \"do nothing\" base case in a conditional:\n ///\n /// ```rust\n /// use std::convert::identity;\n ///\n /// # let condition = true;\n-///\n+/// #\n /// # fn manipulation(x: u32) -> u32 { x + 1 }\n-///\n+/// #\n /// let do_stuff = if condition { manipulation } else { identity };\n ///\n-/// // do more interesting stuff..\n+/// // Do more interesting stuff...\n ///\n /// let _results = do_stuff(42);\n /// ```"}, {"sha": "ee4be6c9151194b0e7a58e32b8be797e188bd933", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -49,28 +49,16 @@ pub unsafe fn unreachable_unchecked() -> ! {\n     intrinsics::unreachable()\n }\n \n-/// Signals the processor that it is entering a busy-wait spin-loop.\n+/// Emits a machine instruction hinting to the processor that it is running in busy-wait\n+/// spin-loop (\"spin lock\").\n ///\n-/// Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving\n-/// power or switching hyper-threads.\n-///\n-/// This function is different than [`std::thread::yield_now`] which directly yields to the\n-/// system's scheduler, whereas `spin_loop` only signals the processor that it is entering a\n-/// busy-wait spin-loop without yielding control to the system's scheduler.\n-///\n-/// Using a busy-wait spin-loop with `spin_loop` is ideally used in situations where a\n-/// contended lock is held by another thread executed on a different CPU and where the waiting\n-/// times are relatively small. Because entering busy-wait spin-loop does not trigger the system's\n-/// scheduler, no overhead for switching threads occurs. However, if the thread holding the\n-/// contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice\n-/// before switching to the thread that holds the lock. If the contending lock is held by a thread\n-/// on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to\n-/// use [`std::thread::yield_now`].\n+/// For a discussion of different locking strategies and their trade-offs, see\n+/// [`core::sync::atomic::spin_loop_hint`].\n ///\n /// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n /// do anything at all.\n ///\n-/// [`std::thread::yield_now`]: ../../std/thread/fn.yield_now.html\n+/// [`core::sync::atomic::spin_loop_hint`]: ../sync/atomic/fn.spin_loop_hint.html\n #[inline]\n #[unstable(feature = \"renamed_spin_loop\", issue = \"55002\")]\n pub fn spin_loop() {"}, {"sha": "ecff40a75978dbca8587d61c8f147781afb1dc67", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -845,21 +845,26 @@ extern \"rust-intrinsic\" {\n     ///\n     /// ```\n     /// let store = [0, 1, 2, 3];\n-    /// let mut v_orig = store.iter().collect::<Vec<&i32>>();\n+    /// let v_orig = store.iter().collect::<Vec<&i32>>();\n+    ///\n+    /// // clone the vector as we will reuse them later\n+    /// let v_clone = v_orig.clone();\n     ///\n     /// // Using transmute: this is Undefined Behavior, and a bad idea.\n     /// // However, it is no-copy.\n     /// let v_transmuted = unsafe {\n-    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(\n-    ///         v_orig.clone())\n+    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(v_clone)\n     /// };\n     ///\n+    /// let v_clone = v_orig.clone();\n+    ///\n     /// // This is the suggested, safe way.\n     /// // It does copy the entire vector, though, into a new array.\n-    /// let v_collected = v_orig.clone()\n-    ///                         .into_iter()\n-    ///                         .map(|r| Some(r))\n-    ///                         .collect::<Vec<Option<&i32>>>();\n+    /// let v_collected = v_clone.into_iter()\n+    ///                          .map(Some)\n+    ///                          .collect::<Vec<Option<&i32>>>();\n+    ///\n+    /// let v_clone = v_orig.clone();\n     ///\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n@@ -869,11 +874,12 @@ extern \"rust-intrinsic\" {\n     /// // the original inner type (`&i32`) to the converted inner type\n     /// // (`Option<&i32>`), so read the nomicon pages linked above.\n     /// let v_from_raw = unsafe {\n-    ///     Vec::from_raw_parts(v_orig.as_mut_ptr() as *mut Option<&i32>,\n-    ///                         v_orig.len(),\n-    ///                         v_orig.capacity())\n+    ///     // Ensure the original vector is not dropped.\n+    ///     let mut v_clone = std::mem::ManuallyDrop::new(v_clone);\n+    ///     Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option<&i32>,\n+    ///                         v_clone.len(),\n+    ///                         v_clone.capacity())\n     /// };\n-    /// std::mem::forget(v_orig);\n     /// ```\n     ///\n     /// Implementing `split_at_mut`:"}, {"sha": "3b8edc2ad61770aa786c86a4ce6b3b00e77abd06", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -5,7 +5,7 @@ use crate::usize;\n use crate::intrinsics;\n \n use super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n-use super::LoopState;\n+use super::{LoopState, from_fn};\n \n mod chain;\n mod flatten;\n@@ -534,6 +534,26 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n             self.iter.nth(nth - 1);\n         }\n     }\n+\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return Try::from_ok(acc),\n+                Some(x) => acc = f(acc, x)?,\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n+    }\n }\n \n impl<I> StepBy<I> where I: ExactSizeIterator {\n@@ -567,6 +587,28 @@ impl<I> DoubleEndedIterator for StepBy<I> where I: DoubleEndedIterator + ExactSi\n             .saturating_add(self.next_back_index());\n         self.iter.nth_back(n)\n     }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth_back<I: DoubleEndedIterator>(\n+            iter: &mut I,\n+            step: usize,\n+        ) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth_back(step)\n+        }\n+\n+        match self.next_back() {\n+            None => Try::from_ok(init),\n+            Some(x) => {\n+                let acc = f(init, x)?;\n+                from_fn(nth_back(&mut self.iter, self.step)).try_fold(acc, f)\n+            }\n+        }\n+    }\n }\n \n // StepBy can only make the iterator shorter, so the len will still fit."}, {"sha": "c09df3f7f22cbd8c650cf85a33a93fe5c77061ff", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 183, "deletions": 6, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -2546,11 +2546,51 @@ pub trait Iterator {\n \n     /// Lexicographically compares the elements of this `Iterator` with those\n     /// of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!([1].iter().cmp([1].iter()), Ordering::Equal);\n+    /// assert_eq!([1].iter().cmp([1, 2].iter()), Ordering::Less);\n+    /// assert_eq!([1, 2].iter().cmp([1].iter()), Ordering::Greater);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn cmp<I>(mut self, other: I) -> Ordering where\n+    fn cmp<I>(self, other: I) -> Ordering\n+    where\n         I: IntoIterator<Item = Self::Item>,\n         Self::Item: Ord,\n         Self: Sized,\n+    {\n+        self.cmp_by(other, |x, y| x.cmp(&y))\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another with respect to the specified comparison function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let xs = [1, 2, 3, 4];\n+    /// let ys = [1, 4, 9, 16];\n+    ///\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| x.cmp(&y)), Ordering::Less);\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (x * x).cmp(&y)), Ordering::Equal);\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (2 * x).cmp(&y)), Ordering::Greater);\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn cmp_by<I, F>(mut self, other: I, mut cmp: F) -> Ordering\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> Ordering,\n     {\n         let mut other = other.into_iter();\n \n@@ -2569,7 +2609,7 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            match x.cmp(&y) {\n+            match cmp(x, y) {\n                 Ordering::Equal => (),\n                 non_eq => return non_eq,\n             }\n@@ -2578,11 +2618,62 @@ pub trait Iterator {\n \n     /// Lexicographically compares the elements of this `Iterator` with those\n     /// of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!([1.].iter().partial_cmp([1.].iter()), Some(Ordering::Equal));\n+    /// assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));\n+    /// assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));\n+    ///\n+    /// assert_eq!([std::f64::NAN].iter().partial_cmp([1.].iter()), None);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn partial_cmp<I>(mut self, other: I) -> Option<Ordering> where\n+    fn partial_cmp<I>(self, other: I) -> Option<Ordering>\n+    where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n+    {\n+        self.partial_cmp_by(other, |x, y| x.partial_cmp(&y))\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another with respect to the specified comparison function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let xs = [1.0, 2.0, 3.0, 4.0];\n+    /// let ys = [1.0, 4.0, 9.0, 16.0];\n+    ///\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| x.partial_cmp(&y)),\n+    ///     Some(Ordering::Less)\n+    /// );\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| (x * x).partial_cmp(&y)),\n+    ///     Some(Ordering::Equal)\n+    /// );\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| (2.0 * x).partial_cmp(&y)),\n+    ///     Some(Ordering::Greater)\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn partial_cmp_by<I, F>(mut self, other: I, mut partial_cmp: F) -> Option<Ordering>\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> Option<Ordering>,\n     {\n         let mut other = other.into_iter();\n \n@@ -2601,7 +2692,7 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            match x.partial_cmp(&y) {\n+            match partial_cmp(x, y) {\n                 Some(Ordering::Equal) => (),\n                 non_eq => return non_eq,\n             }\n@@ -2610,11 +2701,44 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are equal to those of\n     /// another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().eq([1].iter()), true);\n+    /// assert_eq!([1].iter().eq([1, 2].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn eq<I>(mut self, other: I) -> bool where\n+    fn eq<I>(self, other: I) -> bool\n+    where\n         I: IntoIterator,\n         Self::Item: PartialEq<I::Item>,\n         Self: Sized,\n+    {\n+        self.eq_by(other, |x, y| x == y)\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are equal to those of\n+    /// another with respect to the specified equality function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// let xs = [1, 2, 3, 4];\n+    /// let ys = [1, 4, 9, 16];\n+    ///\n+    /// assert!(xs.iter().eq_by(&ys, |&x, &y| x * x == y));\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn eq_by<I, F>(mut self, other: I, mut eq: F) -> bool\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> bool,\n     {\n         let mut other = other.into_iter();\n \n@@ -2629,12 +2753,21 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            if x != y { return false }\n+            if !eq(x, y) {\n+                return false;\n+            }\n         }\n     }\n \n     /// Determines if the elements of this `Iterator` are unequal to those of\n     /// another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().ne([1].iter()), false);\n+    /// assert_eq!([1].iter().ne([1, 2].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn ne<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2646,6 +2779,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less than those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().lt([1].iter()), false);\n+    /// assert_eq!([1].iter().lt([1, 2].iter()), true);\n+    /// assert_eq!([1, 2].iter().lt([1].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn lt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2657,6 +2798,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less or equal to those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().le([1].iter()), true);\n+    /// assert_eq!([1].iter().le([1, 2].iter()), true);\n+    /// assert_eq!([1, 2].iter().le([1].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn le<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2671,6 +2820,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().gt([1].iter()), false);\n+    /// assert_eq!([1].iter().gt([1, 2].iter()), false);\n+    /// assert_eq!([1, 2].iter().gt([1].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn gt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2682,6 +2839,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than or equal to those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().ge([1].iter()), true);\n+    /// assert_eq!([1].iter().ge([1, 2].iter()), false);\n+    /// assert_eq!([1, 2].iter().ge([1].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn ge<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2730,6 +2895,18 @@ pub trait Iterator {\n     /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n     /// [`is_sorted`]; see its documentation for more information.\n     ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_sorted)]\n+    ///\n+    /// assert!([1, 2, 2, 9].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(![1, 3, 2, 4].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!([0].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(std::iter::empty::<i32>().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// ```\n+    ///\n     /// [`is_sorted`]: trait.Iterator.html#method.is_sorted\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n     fn is_sorted_by<F>(mut self, mut compare: F) -> bool"}, {"sha": "a2cc585fc51fd3ae11a246c7306eb03197b02c41", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -87,7 +87,7 @@\n #![feature(link_llvm_intrinsics)]\n #![feature(never_type)]\n #![feature(nll)]\n-#![feature(bind_by_move_pattern_guards)]\n+#![cfg_attr(boostrap_stdarch_ignore_this, feature(bind_by_move_pattern_guards))]\n #![feature(exhaustive_patterns)]\n #![feature(no_core)]\n #![feature(on_unimplemented)]\n@@ -227,6 +227,7 @@ pub mod task;\n pub mod alloc;\n \n // note: does not need to be public\n+mod bool;\n mod tuple;\n mod unit;\n "}, {"sha": "384bc87499887ad84542a5fd8573e3722b393ff0", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1236,8 +1236,10 @@ pub(crate) mod builtin {\n     pub macro test($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n-    #[unstable(feature = \"test\", issue = \"50297\",\n-               reason = \"`bench` is a part of custom test frameworks which are unstable\")]\n+    #[cfg_attr(not(boostrap_stdarch_ignore_this), unstable(soft, feature = \"test\", issue = \"50297\",\n+               reason = \"`bench` is a part of custom test frameworks which are unstable\"))]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, unstable(feature = \"test\", issue = \"50297\",\n+               reason = \"`bench` is a part of custom test frameworks which are unstable\"))]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n     pub macro bench($item:item) { /* compiler built-in */ }"}, {"sha": "347e7dce6e67d242e7a68bf1a63c41917eea250b", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -602,10 +602,10 @@ unsafe impl<T: ?Sized> Freeze for *mut T {}\n unsafe impl<T: ?Sized> Freeze for &T {}\n unsafe impl<T: ?Sized> Freeze for &mut T {}\n \n-/// Types which can be safely moved after being pinned.\n+/// Types that can be safely moved after being pinned.\n ///\n /// Since Rust itself has no notion of immovable types, and considers moves\n-/// (e.g. through assignment or [`mem::replace`]) to always be safe,\n+/// (e.g., through assignment or [`mem::replace`]) to always be safe,\n /// this trait cannot prevent types from moving by itself.\n ///\n /// Instead it is used to prevent moves through the type system,"}, {"sha": "0cf2ebb487ddd50d7ea8e2c90af3c451ddf46de8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1401,12 +1401,8 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n-            pub fn wrapping_abs(self) -> Self {\n-                if self.is_negative() {\n-                    self.wrapping_neg()\n-                } else {\n-                    self\n-                }\n+            pub const fn wrapping_abs(self) -> Self {\n+                (self ^ (self >> ($BITS - 1))).wrapping_sub(self >> ($BITS - 1))\n             }\n         }\n \n@@ -1764,12 +1760,8 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n-            pub fn overflowing_abs(self) -> (Self, bool) {\n-                if self.is_negative() {\n-                    self.overflowing_neg()\n-                } else {\n-                    (self, false)\n-                }\n+            pub const fn overflowing_abs(self) -> (Self, bool) {\n+                (self ^ (self >> ($BITS - 1))).overflowing_sub(self >> ($BITS - 1))\n             }\n         }\n \n@@ -1973,15 +1965,11 @@ $EndFeature, \"\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn abs(self) -> Self {\n-                if self.is_negative() {\n-                    // Note that the #[inline] above means that the overflow\n-                    // semantics of this negation depend on the crate we're being\n-                    // inlined into.\n-                    -self\n-                } else {\n-                    self\n-                }\n+            pub const fn abs(self) -> Self {\n+                // Note that the #[inline] above means that the overflow\n+                // semantics of the subtraction depend on the crate we're being\n+                // inlined into.\n+                (self ^ (self >> ($BITS - 1))) - (self >> ($BITS - 1))\n             }\n         }\n \n@@ -2104,11 +2092,14 @@ $to_xe_bytes_doc,\n \n ```\n let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\n-assert_eq!(bytes, if cfg!(target_endian = \\\"big\\\") {\n+assert_eq!(\n+    bytes,\n+    if cfg!(target_endian = \\\"big\\\") {\n         \", $be_bytes, \"\n     } else {\n         \", $le_bytes, \"\n-    });\n+    }\n+);\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -2200,10 +2191,10 @@ $from_xe_bytes_doc,\n \n ```\n let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n-        \", $be_bytes, \"\n-    } else {\n-        \", $le_bytes, \"\n-    });\n+    \", $be_bytes, \"\n+} else {\n+    \", $le_bytes, \"\n+});\n assert_eq!(value, \", $swap_op, \");\n ```\n \n@@ -3923,11 +3914,14 @@ $to_xe_bytes_doc,\n \n ```\n let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\n-assert_eq!(bytes, if cfg!(target_endian = \\\"big\\\") {\n+assert_eq!(\n+    bytes,\n+    if cfg!(target_endian = \\\"big\\\") {\n         \", $be_bytes, \"\n     } else {\n         \", $le_bytes, \"\n-    });\n+    }\n+);\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -4019,10 +4013,10 @@ $from_xe_bytes_doc,\n \n ```\n let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n-        \", $be_bytes, \"\n-    } else {\n-        \", $le_bytes, \"\n-    });\n+    \", $be_bytes, \"\n+} else {\n+    \", $le_bytes, \"\n+});\n assert_eq!(value, \", $swap_op, \");\n ```\n "}, {"sha": "5569d99f8d81ddfe310210ac76b89dfe1bbd9c68", "filename": "src/libcore/option.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -295,7 +295,7 @@ impl<T> Option<T> {\n     /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub fn as_pin_ref<'a>(self: Pin<&'a Option<T>>) -> Option<Pin<&'a T>> {\n+    pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n         unsafe {\n             Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x))\n         }\n@@ -306,7 +306,7 @@ impl<T> Option<T> {\n     /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub fn as_pin_mut<'a>(self: Pin<&'a mut Option<T>>) -> Option<Pin<&'a mut T>> {\n+    pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n         unsafe {\n             Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x))\n         }\n@@ -1110,6 +1110,18 @@ impl<T: Deref> Option<T> {\n     /// to the original one, additionally coercing the contents via [`Deref`].\n     ///\n     /// [`Deref`]: ../../std/ops/trait.Deref.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inner_deref)]\n+    ///\n+    /// let x: Option<String> = Some(\"hey\".to_owned());\n+    /// assert_eq!(x.as_deref(), Some(\"hey\"));\n+    ///\n+    /// let x: Option<String> = None;\n+    /// assert_eq!(x.as_deref(), None);\n+    /// ```\n     pub fn as_deref(&self) -> Option<&T::Target> {\n         self.as_ref().map(|t| t.deref())\n     }\n@@ -1121,6 +1133,18 @@ impl<T: DerefMut> Option<T> {\n     ///\n     /// Leaves the original `Option` in-place, creating a new one containing a mutable reference to\n     /// the inner type's `Deref::Target` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inner_deref)]\n+    ///\n+    /// let mut x: Option<String> = Some(\"hey\".to_owned());\n+    /// assert_eq!(x.as_deref_mut().map(|x| {\n+    ///     x.make_ascii_uppercase();\n+    ///     x\n+    /// }), Some(\"HEY\".to_owned().as_mut_str()));\n+    /// ```\n     pub fn as_deref_mut(&mut self) -> Option<&mut T::Target> {\n         self.as_mut().map(|t| t.deref_mut())\n     }\n@@ -1199,6 +1223,13 @@ impl<T: Clone> Clone for Option<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n     /// Returns [`None`][Option::None].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let opt: Option<u32> = Option::default();\n+    /// assert!(opt.is_none());\n+    /// ```\n     #[inline]\n     fn default() -> Option<T> { None }\n }"}, {"sha": "1dc6d54b08a5aa7700a48f674487bbf1d89755b8", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -233,7 +233,7 @@\n //! # type Field = i32;\n //! # struct Struct { field: Field }\n //! impl Struct {\n-//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> &'a mut Field {\n+//!     fn pin_get_field(self: Pin<&mut Self>) -> &mut Field {\n //!         // This is okay because `field` is never considered pinned.\n //!         unsafe { &mut self.get_unchecked_mut().field }\n //!     }\n@@ -257,7 +257,7 @@\n //! # type Field = i32;\n //! # struct Struct { field: Field }\n //! impl Struct {\n-//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> Pin<&'a mut Field> {\n+//!     fn pin_get_field(self: Pin<&mut Self>) -> Pin<&mut Field> {\n //!         // This is okay because `field` is pinned when `self` is.\n //!         unsafe { self.map_unchecked_mut(|s| &mut s.field) }\n //!     }\n@@ -549,7 +549,7 @@ impl<P: Deref> Pin<P> {\n     /// ruled out by the contract of `Pin::new_unchecked`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n+    pub fn as_ref(&self) -> Pin<&P::Target> {\n         unsafe { Pin::new_unchecked(&*self.pointer) }\n     }\n \n@@ -584,9 +584,30 @@ impl<P: DerefMut> Pin<P> {\n     /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n     /// \"Malicious\" implementations of `Pointer::DerefMut` are likewise\n     /// ruled out by the contract of `Pin::new_unchecked`.\n+    ///\n+    /// This method is useful when doing multiple calls to functions that consume the pinned type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::pin::Pin;\n+    ///\n+    /// # struct Type {}\n+    /// impl Type {\n+    ///     fn method(self: Pin<&mut Self>) {\n+    ///         // do something\n+    ///     }\n+    ///\n+    ///     fn call_method_twice(mut self: Pin<&mut Self>) {\n+    ///         // `method` consumes `self`, so reborrow the `Pin<&mut Self>` via `as_mut`.\n+    ///         self.as_mut().method();\n+    ///         self.as_mut().method();\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n+    pub fn as_mut(&mut self) -> Pin<&mut P::Target> {\n         unsafe { Pin::new_unchecked(&mut *self.pointer) }\n     }\n \n@@ -596,7 +617,7 @@ impl<P: DerefMut> Pin<P> {\n     /// run before being overwritten, so no pinning guarantee is violated.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn set(self: &mut Pin<P>, value: P::Target)\n+    pub fn set(&mut self, value: P::Target)\n     where\n         P::Target: Sized,\n     {\n@@ -621,7 +642,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked<U, F>(self: Pin<&'a T>, func: F) -> Pin<&'a U> where\n+    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U> where\n         F: FnOnce(&T) -> &U,\n     {\n         let pointer = &*self.pointer;\n@@ -648,7 +669,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     /// [\"pinning projections\"]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn get_ref(self: Pin<&'a T>) -> &'a T {\n+    pub fn get_ref(self) -> &'a T {\n         self.pointer\n     }\n }\n@@ -657,7 +678,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn into_ref(self: Pin<&'a mut T>) -> Pin<&'a T> {\n+    pub fn into_ref(self) -> Pin<&'a T> {\n         Pin { pointer: self.pointer }\n     }\n \n@@ -672,7 +693,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// with the same lifetime as the original `Pin`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn get_mut(self: Pin<&'a mut T>) -> &'a mut T\n+    pub fn get_mut(self) -> &'a mut T\n         where T: Unpin,\n     {\n         self.pointer\n@@ -690,7 +711,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// instead.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub unsafe fn get_unchecked_mut(self: Pin<&'a mut T>) -> &'a mut T {\n+    pub unsafe fn get_unchecked_mut(self) -> &'a mut T {\n         self.pointer\n     }\n \n@@ -710,7 +731,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked_mut<U, F>(self: Pin<&'a mut T>, func: F) -> Pin<&'a mut U> where\n+    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U> where\n         F: FnOnce(&mut T) -> &mut U,\n     {\n         let pointer = Pin::get_unchecked_mut(self);"}, {"sha": "13ccc9b252a775cbf82564e5b7ca1e21184d1fd1", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1042,7 +1042,7 @@ impl<T: ?Sized> *const T {\n         (self as *const u8) == null()\n     }\n \n-    /// Cast to a pointer to a different type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> *const U {\n@@ -1726,7 +1726,7 @@ impl<T: ?Sized> *mut T {\n         (self as *mut u8) == null_mut()\n     }\n \n-    /// Cast to a pointer to a different type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> *mut U {"}, {"sha": "7dcd57f1f985888e9c109fd5fa8c6c3ae6305d1f", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -125,7 +125,7 @@ impl<T: ?Sized> NonNull<T> {\n         &mut *self.as_ptr()\n     }\n \n-    /// Cast to a pointer of another type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> NonNull<U> {"}, {"sha": "c9ccef972c2b5faabdabf7f55a79c4378d180a9e", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -124,28 +124,31 @@ use crate::fmt;\n \n use crate::hint::spin_loop;\n \n-/// Signals the processor that it is entering a busy-wait spin-loop.\n+/// Signals the processor that it is inside a busy-wait spin-loop (\"spin lock\").\n ///\n /// Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving\n /// power or switching hyper-threads.\n ///\n-/// This function is different than [`std::thread::yield_now`] which directly yields to the\n-/// system's scheduler, whereas `spin_loop_hint` only signals the processor that it is entering a\n-/// busy-wait spin-loop without yielding control to the system's scheduler.\n+/// This function is different from [`std::thread::yield_now`] which directly yields to the\n+/// system's scheduler, whereas `spin_loop_hint` does not interact with the operating system.\n ///\n-/// Using a busy-wait spin-loop with `spin_loop_hint` is ideally used in situations where a\n-/// contended lock is held by another thread executed on a different CPU and where the waiting\n-/// times are relatively small. Because entering busy-wait spin-loop does not trigger the system's\n-/// scheduler, no overhead for switching threads occurs. However, if the thread holding the\n-/// contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice\n-/// before switching to the thread that holds the lock. If the contending lock is held by a thread\n-/// on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to\n-/// use [`std::thread::yield_now`].\n+/// Spin locks can be very efficient for short lock durations because they do not involve context\n+/// switches or interaction with the operating system. For long lock durations they become wasteful\n+/// however because they use CPU cycles for the entire lock duration, and using a\n+/// [`std::sync::Mutex`] is likely the better approach. If actively spinning for a long time is\n+/// required, e.g. because code polls a non-blocking API, calling [`std::thread::yield_now`]\n+/// or [`std::thread::sleep`] may be the best option.\n+///\n+/// **Note**: Spin locks are based on the underlying assumption that another thread will release\n+/// the lock 'soon'. In order for this to work, that other thread must run on a different CPU or\n+/// core (at least potentially). Spin locks do not work efficiently on single CPU / core platforms.\n ///\n /// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n /// do anything at all.\n ///\n /// [`std::thread::yield_now`]: ../../../std/thread/fn.yield_now.html\n+/// [`std::thread::sleep`]: ../../../std/thread/fn.sleep.html\n+/// [`std::sync::Mutex`]: ../../../std/sync/struct.Mutex.html\n #[inline]\n #[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n pub fn spin_loop_hint() {\n@@ -979,9 +982,8 @@ impl<T> AtomicPtr<T> {\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n     /// let other_ptr   = &mut 10;\n-    /// let another_ptr = &mut 10;\n     ///\n-    /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n+    /// let value = some_ptr.compare_and_swap(ptr, other_ptr, Ordering::Relaxed);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1021,9 +1023,8 @@ impl<T> AtomicPtr<T> {\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n     /// let other_ptr   = &mut 10;\n-    /// let another_ptr = &mut 10;\n     ///\n-    /// let value = some_ptr.compare_exchange(other_ptr, another_ptr,\n+    /// let value = some_ptr.compare_exchange(ptr, other_ptr,\n     ///                                       Ordering::SeqCst, Ordering::Relaxed);\n     /// ```\n     #[inline]"}, {"sha": "0f1e6e89451e9b4294a6aad180c3250e623f2122", "filename": "src/libcore/tests/bool.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Ftests%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Ftests%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fbool.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -0,0 +1,7 @@\n+#[test]\n+fn test_bool_to_option() {\n+    assert_eq!(false.then(0), None);\n+    assert_eq!(true.then(0), Some(0));\n+    assert_eq!(false.then_with(|| 0), None);\n+    assert_eq!(true.then_with(|| 0), Some(0));\n+}"}, {"sha": "c9096b713f20ec42b532913a6eba398888140b4e", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -57,6 +57,62 @@ fn test_multi_iter() {\n     assert!(xs.iter().lt(xs.iter().skip(2)));\n }\n \n+#[test]\n+fn test_cmp_by() {\n+    use core::cmp::Ordering;\n+\n+    let f = |x: i32, y: i32| (x * x).cmp(&y);\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 16].iter().copied();\n+\n+    assert_eq!(xs().cmp_by(ys(), f), Ordering::Less);\n+    assert_eq!(ys().cmp_by(xs(), f), Ordering::Greater);\n+    assert_eq!(xs().cmp_by(xs().map(|x| x * x), f), Ordering::Equal);\n+    assert_eq!(xs().rev().cmp_by(ys().rev(), f), Ordering::Greater);\n+    assert_eq!(xs().cmp_by(ys().rev(), f), Ordering::Less);\n+    assert_eq!(xs().cmp_by(ys().take(2), f), Ordering::Greater);\n+}\n+\n+#[test]\n+fn test_partial_cmp_by() {\n+    use core::cmp::Ordering;\n+    use core::f64;\n+\n+    let f = |x: i32, y: i32| (x * x).partial_cmp(&y);\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 16].iter().copied();\n+\n+    assert_eq!(xs().partial_cmp_by(ys(), f), Some(Ordering::Less));\n+    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n+    assert_eq!(xs().partial_cmp_by(xs().map(|x| x * x), f), Some(Ordering::Equal));\n+    assert_eq!(xs().rev().partial_cmp_by(ys().rev(), f), Some(Ordering::Greater));\n+    assert_eq!(xs().partial_cmp_by(xs().rev(), f), Some(Ordering::Less));\n+    assert_eq!(xs().partial_cmp_by(ys().take(2), f), Some(Ordering::Greater));\n+\n+    let f = |x: f64, y: f64| (x * x).partial_cmp(&y);\n+    let xs = || [1.0, 2.0, 3.0, 4.0].iter().copied();\n+    let ys = || [1.0, 4.0, f64::NAN, 16.0].iter().copied();\n+\n+    assert_eq!(xs().partial_cmp_by(ys(), f), None);\n+    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n+}\n+\n+#[test]\n+fn test_eq_by() {\n+    let f = |x: i32, y: i32| x * x == y;\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 9, 16].iter().copied();\n+\n+    assert!(xs().eq_by(ys(), f));\n+    assert!(!ys().eq_by(xs(), f));\n+    assert!(!xs().eq_by(xs(), f));\n+    assert!(!ys().eq_by(ys(), f));\n+\n+    assert!(!xs().take(3).eq_by(ys(), f));\n+    assert!(!xs().eq_by(ys().take(3), f));\n+    assert!(xs().take(3).eq_by(ys().take(3), f));\n+}\n+\n #[test]\n fn test_counter_from_iter() {\n     let it = (0..).step_by(5).take(10);\n@@ -329,6 +385,23 @@ fn test_iterator_step_by_nth_overflow() {\n     assert_eq!(it.0, (usize::MAX as Bigger) * 1);\n }\n \n+#[test]\n+fn test_iterator_step_by_nth_try_fold() {\n+    let mut it = (0..).step_by(10);\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(60));\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(90));\n+\n+    let mut it = (100..).step_by(10);\n+    assert_eq!(it.try_fold(50, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(110));\n+\n+    let mut it = (100..=100).step_by(10);\n+    assert_eq!(it.next(), Some(100));\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+}\n+\n #[test]\n fn test_iterator_step_by_nth_back() {\n     let mut it = (0..16).step_by(5);\n@@ -354,6 +427,24 @@ fn test_iterator_step_by_nth_back() {\n     assert_eq!(it().nth_back(42), None);\n }\n \n+#[test]\n+fn test_iterator_step_by_nth_try_rfold() {\n+    let mut it = (0..100).step_by(10);\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(70));\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(30));\n+\n+    let mut it = (0..100).step_by(10);\n+    assert_eq!(it.try_rfold(50, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(80));\n+\n+    let mut it = (100..=100).step_by(10);\n+    assert_eq!(it.next_back(), Some(100));\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+}\n+\n #[test]\n #[should_panic]\n fn test_iterator_step_by_zero() {"}, {"sha": "050195cd2ef51eaca905ce2b05e9f0ae15556393", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,3 +1,4 @@\n+#![feature(bool_to_option)]\n #![feature(bound_cloned)]\n #![feature(box_syntax)]\n #![feature(cell_update)]\n@@ -32,6 +33,7 @@\n #![feature(const_fn)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]\n+#![feature(iter_order_by)]\n \n extern crate test;\n \n@@ -40,6 +42,7 @@ mod any;\n mod array;\n mod ascii;\n mod atomic;\n+mod bool;\n mod cell;\n mod char;\n mod clone;"}, {"sha": "4e8b4ecad0200c9a7afcf2dadbacbc57286f5b40", "filename": "src/libcore/unicode/printable.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Funicode%2Fprintable.py", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibcore%2Funicode%2Fprintable.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.py?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -60,7 +60,7 @@ def get_codepoints(f):\n         yield Codepoint(codepoint, class_)\n         prev_codepoint = codepoint\n \n-    if class_first != None:\n+    if class_first is not None:\n         raise ValueError(\"Missing Last after First\")\n \n     for c in range(prev_codepoint + 1, NUM_CODEPOINTS):"}, {"sha": "0834faf1324245b9249c0625b5a56a14e6e95fc4", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -15,7 +15,6 @@ bitflags = \"1.0\"\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n-lazy_static = \"1.0.0\"\n num_cpus = \"1.0\"\n scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n@@ -31,8 +30,8 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n backtrace = \"0.3.3\"\n-parking_lot = \"0.7\"\n-byteorder = { version = \"1.1\", features = [\"i128\"]}\n+parking_lot = \"0.9\"\n+byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "d4fc1b12830a12eeb4af48f5a5306f0841da4252", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -187,7 +187,7 @@ impl<T: Copy> ArenaAllocatable for T {}\n \n unsafe trait ArenaField<'tcx>: Sized {\n     /// Returns a specific arena to allocate from.\n-    /// If None is returned, the DropArena will be used.\n+    /// If `None` is returned, the `DropArena` will be used.\n     fn arena<'a>(arena: &'a Arena<'tcx>) -> Option<&'a TypedArena<Self>>;\n }\n "}, {"sha": "eee33846139e673dcdea38ac9a8977807ae573af", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,7 +1,8 @@\n // Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80 characters.\n-// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n-register_long_diagnostics! {\n+// Each message should start and end with a new line, and be wrapped to 80\n+// characters.  In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use\n+// `:set tw=0` to disable.\n+syntax::register_diagnostics! {\n E0038: r##\"\n Trait objects like `Box<Trait>` can only be constructed when certain\n requirements are satisfied by the trait in question.\n@@ -2183,11 +2184,7 @@ Examples of erroneous code:\n static X: u32 = 42;\n ```\n \"##,\n-\n-}\n-\n-\n-register_diagnostics! {\n+;\n //  E0006, // merged with E0005\n //  E0101, // replaced with E0282\n //  E0102, // replaced with E0282\n@@ -2206,7 +2203,8 @@ register_diagnostics! {\n //  E0305, // expected constant\n     E0311, // thing may not live long enough\n     E0312, // lifetime of reference outlives lifetime of borrowed content\n-    E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n+    E0313, // lifetime of borrowed pointer outlives lifetime of captured\n+           // variable\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n@@ -2223,12 +2221,13 @@ register_diagnostics! {\n     E0483, // lifetime of operand does not outlive the operation\n     E0484, // reference is not valid at the time of borrow\n     E0485, // automatically reference is not valid at the time of borrow\n-    E0486, // type of expression contains references that are not valid during...\n+    E0486, // type of expression contains references that are not valid during..\n     E0487, // unsafe use of destructor: destructor might be called while...\n     E0488, // lifetime of variable does not enclose its declaration\n     E0489, // type/lifetime parameter not in scope here\n     E0490, // a value of type `..` is borrowed for too long\n-    E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n+    E0495, // cannot infer an appropriate lifetime due to conflicting\n+           // requirements\n     E0566, // conflicting representation hints\n     E0623, // lifetime mismatch where both parameters are anonymous regions\n     E0628, // generators cannot have explicit parameters\n@@ -2239,7 +2238,8 @@ register_diagnostics! {\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n     E0697, // closures cannot be static\n     E0707, // multiple elided lifetimes used in arguments of `async fn`\n-    E0708, // `async` non-`move` closures with parameters are not currently supported\n+    E0708, // `async` non-`move` closures with parameters are not currently\n+           // supported\n     E0709, // multiple different lifetimes used in arguments of `async fn`\n     E0710, // an unknown tool name found in scoped lint\n     E0711, // a feature has been declared with conflicting stability attributes"}, {"sha": "1df09429e519f835948af6007239498a3beefe14", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -4,13 +4,12 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-\n-use crate::ty::TyCtxt;\n-use crate::ty::query::Providers;\n-\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n+\n use std::fmt::{self, Display};\n use syntax::symbol::sym;\n use syntax_pos::Span;"}, {"sha": "f7d31ca06ee56e173dc8d900632d980de17d8206", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,15 +1,17 @@\n+use self::Namespace::*;\n+\n use crate::hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::hir;\n+use crate::ty;\n use crate::util::nodemap::DefIdMap;\n+\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax::ast::NodeId;\n use syntax_pos::Span;\n use rustc_macros::HashStable;\n-use crate::hir;\n-use crate::ty;\n-use std::fmt::Debug;\n \n-use self::Namespace::*;\n+use std::fmt::Debug;\n \n /// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n@@ -115,7 +117,7 @@ impl DefKind {\n         }\n     }\n \n-    /// An English article for the def.\n+    /// Gets an English article for the definition.\n     pub fn article(&self) -> &'static str {\n         match *self {\n             DefKind::AssocTy\n@@ -134,18 +136,22 @@ pub enum Res<Id = hir::HirId> {\n     Def(DefKind, DefId),\n \n     // Type namespace\n+\n     PrimTy(hir::PrimTy),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n     ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n \n     // Value namespace\n+\n     SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n     Local(Id),\n \n     // Macro namespace\n+\n     NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n \n     // All namespaces\n+\n     Err,\n }\n \n@@ -330,7 +336,7 @@ impl NonMacroAttrKind {\n }\n \n impl<Id> Res<Id> {\n-    /// Return the `DefId` of this `Def` if it has an id, else panic.\n+    /// Return the `DefId` of this `Def` if it has an ID, else panic.\n     pub fn def_id(&self) -> DefId\n     where\n         Id: Debug,\n@@ -340,7 +346,7 @@ impl<Id> Res<Id> {\n         })\n     }\n \n-    /// Return `Some(..)` with the `DefId` of this `Res` if it has a id, else `None`.\n+    /// Return `Some(..)` with the `DefId` of this `Res` if it has a ID, else `None`.\n     pub fn opt_def_id(&self) -> Option<DefId> {\n         match *self {\n             Res::Def(_, id) => Some(id),\n@@ -379,7 +385,7 @@ impl<Id> Res<Id> {\n         }\n     }\n \n-    /// An English article for the res.\n+    /// Gets an English article for the `Res`.\n     pub fn article(&self) -> &'static str {\n         match *self {\n             Res::Def(kind, _) => kind.article(),"}, {"sha": "d0bdc149131835c8bc62d9c300d18e37c1c2669d", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -11,7 +11,7 @@ newtype_index! {\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum CrateNum {\n-    /// A special CrateNum that we use for the tcx.rcache when decoding from\n+    /// A special `CrateNum` that we use for the `tcx.rcache` when decoding from\n     /// the incr. comp. cache.\n     ReservedForIncrCompCache,\n     Index(CrateId),\n@@ -26,11 +26,10 @@ impl ::std::fmt::Debug for CrateNum {\n     }\n }\n \n-/// Item definitions in the currently-compiled crate would have the CrateNum\n-/// LOCAL_CRATE in their DefId.\n+/// Item definitions in the currently-compiled crate would have the `CrateNum`\n+/// `LOCAL_CRATE` in their `DefId`.\n pub const LOCAL_CRATE: CrateNum = CrateNum::Index(CrateId::from_u32_const(0));\n \n-\n impl Idx for CrateNum {\n     #[inline]\n     fn new(value: usize) -> Self {"}, {"sha": "1f125de9672168d6e599aeef32378264ad20dbc7", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -31,11 +31,13 @@\n //! This order consistency is required in a few places in rustc, for\n //! example generator inference, and possibly also HIR borrowck.\n \n-use syntax::ast::{Ident, Name, Attribute};\n-use syntax_pos::Span;\n+use super::itemlikevisit::DeepVisitor;\n+\n use crate::hir::*;\n use crate::hir::map::Map;\n-use super::itemlikevisit::DeepVisitor;\n+\n+use syntax::ast::{Ident, Name, Attribute};\n+use syntax_pos::Span;\n \n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n@@ -139,7 +141,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// explicitly, you need to override each method. (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n-pub trait Visitor<'v> : Sized {\n+pub trait Visitor<'v>: Sized {\n     ///////////////////////////////////////////////////////////////////////////\n     // Nested items.\n \n@@ -162,8 +164,8 @@ pub trait Visitor<'v> : Sized {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v>;\n \n     /// Invoked when a nested item is encountered. By default does\n-    /// nothing unless you override `nested_visit_map` to return\n-    /// `Some(_)`, in which case it will walk the item. **You probably\n+    /// nothing unless you override `nested_visit_map` to return other than\n+    /// `None`, in which case it will walk the item. **You probably\n     /// don't want to override this method** -- instead, override\n     /// `nested_visit_map` or use the \"shallow\" or \"deep\" visit\n     /// patterns described on `itemlikevisit::ItemLikeVisitor`. The only\n@@ -201,8 +203,8 @@ pub trait Visitor<'v> : Sized {\n \n     /// Invoked to visit the body of a function, method or closure. Like\n     /// visit_nested_item, does nothing by default unless you override\n-    /// `nested_visit_map` to return `Some(_)`, in which case it will walk the\n-    /// body.\n+    /// `nested_visit_map` to return other htan `None`, in which case it will walk\n+    /// the body.\n     fn visit_nested_body(&mut self, id: BodyId) {\n         let opt_body = self.nested_visit_map().intra().map(|map| map.body(id));\n         if let Some(body) = opt_body {\n@@ -603,7 +605,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_lifetime(lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Never => {},\n+        TyKind::Never => {}\n         TyKind::Tup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }"}, {"sha": "39dd46c2d2903473e35e8b26a88e3163d24add3d", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,7 +1,7 @@\n use super::{Item, ImplItem, TraitItem};\n use super::intravisit::Visitor;\n \n-/// The \"item-like visitor\" visitor defines only the top-level methods\n+/// The \"item-like visitor\" defines only the top-level methods\n /// that can be invoked by `Crate::visit_all_item_likes()`. Whether\n /// this trait is the right one to implement will depend on the\n /// overall pattern you need. Here are the three available patterns,\n@@ -18,22 +18,21 @@ use super::intravisit::Visitor;\n ///    an item, but don't care about how item-like things are nested\n ///    within one another.\n ///    - Example: Examine each expression to look for its type and do some check or other.\n-///    - How: Implement `intravisit::Visitor` and use\n-///      `tcx.hir().krate().visit_all_item_likes(visitor.as_deep_visitor())`. Within\n-///      your `intravisit::Visitor` impl, implement methods like\n-///      `visit_expr()`; don't forget to invoke\n-///      `intravisit::walk_visit_expr()` to keep walking the subparts.\n+///    - How: Implement `intravisit::Visitor` and override the `nested_visit_map()` method\n+///      to return `NestedVisitorMap::OnlyBodies` and use\n+///      `tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor())`. Within\n+///      your `intravisit::Visitor` impl, implement methods like `visit_expr()` (don't forget\n+///      to invoke `intravisit::walk_expr()` to keep walking the subparts).\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Integrates well into dependency tracking.\n ///    - Con: Don't get information about nesting between items\n /// 3. **Nested visit**: Want to visit the whole HIR and you care about the nesting between\n ///    item-like things.\n ///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n ///      impl into scope while visiting the impl-items, and then back out again.\n-///    - How: Implement `intravisit::Visitor` and override the\n-///      `nested_visit_map()` methods to return\n-///      `NestedVisitorMap::All`. Walk your crate with\n-///      `intravisit::walk_crate()` invoked on `tcx.hir().krate()`.\n+///    - How: Implement `intravisit::Visitor` and override the `nested_visit_map()` method\n+///      to return `NestedVisitorMap::All`. Walk your crate with `intravisit::walk_crate()`\n+///      invoked on `tcx.hir().krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Preserves nesting information\n ///    - Con: Does not integrate well into dependency tracking.\n@@ -79,7 +78,7 @@ impl<'v, 'hir, V> ItemLikeVisitor<'hir> for DeepVisitor<'v, V>\n     }\n }\n \n-/// A parallel variant of ItemLikeVisitor\n+/// A parallel variant of `ItemLikeVisitor`.\n pub trait ParItemLikeVisitor<'hir> {\n     fn visit_item(&self, item: &'hir Item);\n     fn visit_trait_item(&self, trait_item: &'hir TraitItem);"}, {"sha": "48f7fc4446505369371b1964685155d742a2e981", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -79,7 +79,7 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n pub struct LoweringContext<'a> {\n     crate_root: Option<Symbol>,\n \n-    /// Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n+    /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n     cstore: &'a dyn CrateStore,\n@@ -126,7 +126,7 @@ pub struct LoweringContext<'a> {\n     /// lifetime definitions in the corresponding impl or function generics.\n     lifetimes_to_define: Vec<(Span, ParamName)>,\n \n-    /// Whether or not in-band lifetimes are being collected. This is used to\n+    /// `true` if in-band lifetimes are being collected. This is used to\n     /// indicate whether or not we're in a place where new lifetimes will result\n     /// in in-band lifetime definitions, such a function or an impl header,\n     /// including implicit lifetimes from `impl_header_lifetime_elision`.\n@@ -154,13 +154,13 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    /// Obtain resolution for a `NodeId` with a single resolution.\n+    /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n-    /// Obtain per-namespace resolutions for `use` statement with the given `NoedId`.\n+    /// Obtains per-namespace resolutions for `use` statement with the given `NodeId`.\n     fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n \n-    /// Obtain resolution for a label with the given `NodeId`.\n+    /// Obtains resolution for a label with the given `NodeId`.\n     fn get_label_res(&mut self, id: NodeId) -> Option<NodeId>;\n \n     /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n@@ -425,19 +425,44 @@ impl<'a> LoweringContext<'a> {\n \n         impl<'tcx, 'interner> Visitor<'tcx> for MiscCollector<'tcx, 'interner> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n-                match p.node {\n+                if let PatKind::Paren(..) | PatKind::Rest = p.node {\n                     // Doesn't generate a HIR node\n-                    PatKind::Paren(..) | PatKind::Rest => {},\n-                    _ => {\n-                        if let Some(owner) = self.hir_id_owner {\n-                            self.lctx.lower_node_id_with_owner(p.id, owner);\n-                        }\n-                    }\n-                };\n+                } else if let Some(owner) = self.hir_id_owner {\n+                    self.lctx.lower_node_id_with_owner(p.id, owner);\n+                }\n \n                 visit::walk_pat(self, p)\n             }\n \n+            // HACK(or_patterns; Centril | dlrobertson): Avoid creating\n+            // HIR  nodes for `PatKind::Or` for the top level of a `ast::Arm`.\n+            // This is a temporary hack that should go away once we push down\n+            // `arm.pats: HirVec<P<Pat>>` -> `arm.pat: P<Pat>` to HIR. // Centril\n+            fn visit_arm(&mut self, arm: &'tcx Arm) {\n+                match &arm.pat.node {\n+                    PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                    _ => self.visit_pat(&arm.pat),\n+                }\n+                walk_list!(self, visit_expr, &arm.guard);\n+                self.visit_expr(&arm.body);\n+                walk_list!(self, visit_attribute, &arm.attrs);\n+            }\n+\n+            // HACK(or_patterns; Centril | dlrobertson): Same as above. // Centril\n+            fn visit_expr(&mut self, e: &'tcx Expr) {\n+                if let ExprKind::Let(pat, scrutinee) = &e.node {\n+                    walk_list!(self, visit_attribute, e.attrs.iter());\n+                    match &pat.node {\n+                        PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                        _ => self.visit_pat(&pat),\n+                    }\n+                    self.visit_expr(scrutinee);\n+                    self.visit_expr_post(e);\n+                    return;\n+                }\n+                visit::walk_expr(self, e)\n+            }\n+\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n \n@@ -674,7 +699,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_res(&mut self, res: Res<NodeId>) -> Res {\n         res.map_id(|id| {\n             self.lower_node_id_generic(id, |_| {\n-                panic!(\"expected node_id to be lowered already for res {:#?}\", res)\n+                panic!(\"expected `NodeId` to be lowered already for res {:#?}\", res);\n             })\n         })\n     }\n@@ -1291,7 +1316,7 @@ impl<'a> LoweringContext<'a> {\n                             ImplTraitContext::Universal(in_band_ty_params),\n                         );\n                         // Set the name to `impl Bound1 + Bound2`.\n-                        let ident = Ident::from_str(&pprust::ty_to_string(t)).with_span_pos(span);\n+                        let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         in_band_ty_params.push(hir::GenericParam {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(ident),\n@@ -1339,7 +1364,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n             }\n-            TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now.\"),\n+            TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now\"),\n             TyKind::CVarArgs => {\n                 // Create the implicit lifetime of the \"spoofed\" `VaListImpl`.\n                 let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n@@ -2657,12 +2682,8 @@ impl<'a> LoweringContext<'a> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n-    fn lower_block_with_stmts(\n-        &mut self,\n-        b: &Block,\n-        targeted_by_break: bool,\n-        mut stmts: Vec<hir::Stmt>,\n-    ) -> P<hir::Block> {\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+        let mut stmts = vec![];\n         let mut expr = None;\n \n         for (index, stmt) in b.stmts.iter().enumerate() {\n@@ -2687,8 +2708,11 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n-        self.lower_block_with_stmts(b, targeted_by_break, vec![])\n+    /// Lowers a block directly to an expression, presuming that it\n+    /// has no attributes and is not targeted by a `break`.\n+    fn lower_block_expr(&mut self, b: &Block) -> hir::Expr {\n+        let block = self.lower_block(b, false);\n+        self.expr_block(block, ThinVec::new())\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n@@ -2974,7 +2998,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             StmtKind::Expr(ref e) => hir::StmtKind::Expr(P(self.lower_expr(e))),\n             StmtKind::Semi(ref e) => hir::StmtKind::Semi(P(self.lower_expr(e))),\n-            StmtKind::Mac(..) => panic!(\"Shouldn't exist here\"),\n+            StmtKind::Mac(..) => panic!(\"shouldn't exist here\"),\n         };\n         smallvec![hir::Stmt {\n             hir_id: self.lower_node_id(s.id),\n@@ -3162,7 +3186,7 @@ impl<'a> LoweringContext<'a> {\n \n         hir::Path {\n             span,\n-            res: res.map_id(|_| panic!(\"unexpected node_id\")),\n+            res: res.map_id(|_| panic!(\"unexpected `NodeId`\")),\n             segments: segments.into(),\n         }\n     }"}, {"sha": "990728fa0e68079b795e01a82e2cc85380e6a513", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 59, "deletions": 68, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -68,7 +68,7 @@ impl LoweringContext<'_> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(m, ohs)\n             }\n-            ExprKind::Let(ref pats, ref scrutinee) => self.lower_expr_let(e.span, pats, scrutinee),\n+            ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n             ExprKind::If(ref cond, ref then, ref else_opt) => {\n                 self.lower_expr_if(e.span, cond, then, else_opt.as_deref())\n             }\n@@ -90,10 +90,7 @@ impl LoweringContext<'_> {\n             ),\n             ExprKind::Async(capture_clause, closure_node_id, ref block) => {\n                 self.make_async_expr(capture_clause, closure_node_id, None, block.span, |this| {\n-                    this.with_new_scopes(|this| {\n-                        let block = this.lower_block(block, false);\n-                        this.expr_block(block, ThinVec::new())\n-                    })\n+                    this.with_new_scopes(|this| this.lower_block_expr(block))\n                 })\n             }\n             ExprKind::Await(ref expr) => self.lower_expr_await(e.span, expr),\n@@ -227,16 +224,11 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    /// Emit an error and lower `ast::ExprKind::Let(pats, scrutinee)` into:\n+    /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }\n     /// ```\n-    fn lower_expr_let(\n-        &mut self,\n-        span: Span,\n-        pats: &[AstP<Pat>],\n-        scrutinee: &Expr\n-    ) -> hir::ExprKind {\n+    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind {\n         // If we got here, the `let` expression is not allowed.\n         self.sess\n             .struct_span_err(span, \"`let` expressions are not supported here\")\n@@ -246,23 +238,23 @@ impl LoweringContext<'_> {\n \n         // For better recovery, we emit:\n         // ```\n-        // match scrutinee { pats => true, _ => false }\n+        // match scrutinee { pat => true, _ => false }\n         // ```\n         // While this doesn't fully match the user's intent, it has key advantages:\n         // 1. We can avoid using `abort_if_errors`.\n-        // 2. We can typeck both `pats` and `scrutinee`.\n-        // 3. `pats` is allowed to be refutable.\n+        // 2. We can typeck both `pat` and `scrutinee`.\n+        // 3. `pat` is allowed to be refutable.\n         // 4. The return type of the block is `bool` which seems like what the user wanted.\n         let scrutinee = self.lower_expr(scrutinee);\n         let then_arm = {\n-            let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+            let pat = self.lower_pat_top_hack(pat);\n             let expr = self.expr_bool(span, true);\n-            self.arm(pats, P(expr))\n+            self.arm(pat, P(expr))\n         };\n         let else_arm = {\n-            let pats = hir_vec![self.pat_wild(span)];\n+            let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(pats, P(expr))\n+            self.arm(hir_vec![pat], P(expr))\n         };\n         hir::ExprKind::Match(\n             P(scrutinee),\n@@ -289,15 +281,13 @@ impl LoweringContext<'_> {\n         let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n \n         // Handle then + scrutinee:\n-        let then_blk = self.lower_block(then, false);\n-        let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar) = match cond.node {\n+        let then_expr = self.lower_block_expr(then);\n+        let (then_pat, scrutinee, desugar) = match cond.node {\n             // `<pat> => <then>`:\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 let scrutinee = self.lower_expr(scrutinee);\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n-                (pats, scrutinee, desugar)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::IfLetDesugar { contains_else_clause })\n             }\n             // `true => <then>`:\n             _ => {\n@@ -312,13 +302,11 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `if cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::IfDesugar { contains_else_clause };\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n     }\n@@ -343,10 +331,9 @@ impl LoweringContext<'_> {\n         };\n \n         // Handle then + scrutinee:\n-        let then_blk = self.lower_block(body, false);\n-        let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar, source) = match cond.node {\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+        let then_expr = self.lower_block_expr(body);\n+        let (then_pat, scrutinee, desugar, source) = match cond.node {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -356,16 +343,15 @@ impl LoweringContext<'_> {\n                 //     }\n                 //   }\n                 let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::WhileLetDesugar;\n-                (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::WhileLetDesugar, hir::LoopSource::WhileLet)\n             }\n             _ => {\n                 // We desugar: `'label: while $cond $body` into:\n                 //\n                 // ```\n                 // 'label: loop {\n-                //     match DropTemps($cond) {\n+                //     match drop-temps { $cond } {\n                 //         true => $body,\n                 //         _ => break,\n                 //     }\n@@ -383,14 +369,12 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `while cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::WhileDesugar;\n                 // `true => <then>`:\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar, hir::LoopSource::While)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         // `match <scrutinee> { ... }`\n         let match_expr = self.expr_match(\n@@ -440,7 +424,7 @@ impl LoweringContext<'_> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n-            pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n+            pats: self.lower_pat_top_hack(&arm.pat),\n             guard: match arm.guard {\n                 Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n                 _ => None,\n@@ -450,6 +434,16 @@ impl LoweringContext<'_> {\n         }\n     }\n \n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn lower_pat_top_hack(&mut self, pat: &Pat) -> HirVec<P<hir::Pat>> {\n+        match pat.node {\n+            PatKind::Or(ref ps) => ps.iter().map(|x| self.lower_pat(x)).collect(),\n+            _ => hir_vec![self.lower_pat(pat)],\n+        }\n+    }\n+\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n@@ -508,14 +502,13 @@ impl LoweringContext<'_> {\n \n     /// Desugar `<expr>.await` into:\n     /// ```rust\n-    /// {\n-    ///     let mut pinned = <expr>;\n-    ///     loop {\n+    /// match <expr> {\n+    ///     mut pinned => loop {\n     ///         match ::std::future::poll_with_tls_context(unsafe {\n-    ///             ::std::pin::Pin::new_unchecked(&mut pinned)\n+    ///             <::std::pin::Pin>::new_unchecked(&mut pinned)\n     ///         }) {\n     ///             ::std::task::Poll::Ready(result) => break result,\n-    ///             ::std::task::Poll::Pending => {},\n+    ///             ::std::task::Poll::Pending => {}\n     ///         }\n     ///         yield ();\n     ///     }\n@@ -550,21 +543,12 @@ impl LoweringContext<'_> {\n             self.allow_gen_future.clone(),\n         );\n \n-        // let mut pinned = <expr>;\n-        let expr = P(self.lower_expr(expr));\n         let pinned_ident = Ident::with_dummy_span(sym::pinned);\n         let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n             span,\n             pinned_ident,\n             hir::BindingAnnotation::Mutable,\n         );\n-        let pinned_let = self.stmt_let_pat(\n-            ThinVec::new(),\n-            span,\n-            Some(expr),\n-            pinned_pat,\n-            hir::LocalSource::AwaitDesugar,\n-        );\n \n         // ::std::future::poll_with_tls_context(unsafe {\n         //     ::std::pin::Pin::new_unchecked(&mut pinned)\n@@ -622,7 +606,7 @@ impl LoweringContext<'_> {\n             self.arm(hir_vec![pending_pat], empty_block)\n         };\n \n-        let match_stmt = {\n+        let inner_match_stmt = {\n             let match_expr = self.expr_match(\n                 span,\n                 poll_expr,\n@@ -644,10 +628,11 @@ impl LoweringContext<'_> {\n \n         let loop_block = P(self.block_all(\n             span,\n-            hir_vec![match_stmt, yield_stmt],\n+            hir_vec![inner_match_stmt, yield_stmt],\n             None,\n         ));\n \n+        // loop { .. }\n         let loop_expr = P(hir::Expr {\n             hir_id: loop_hir_id,\n             node: hir::ExprKind::Loop(\n@@ -659,10 +644,14 @@ impl LoweringContext<'_> {\n             attrs: ThinVec::new(),\n         });\n \n-        hir::ExprKind::Block(\n-            P(self.block_all(span, hir_vec![pinned_let], Some(loop_expr))),\n-            None,\n-        )\n+        // mut pinned => loop { ... }\n+        let pinned_arm = self.arm(hir_vec![pinned_pat], loop_expr);\n+\n+        // match <expr> {\n+        //     mut pinned => loop { .. }\n+        // }\n+        let expr = P(self.lower_expr(expr));\n+        hir::ExprKind::Match(expr, hir_vec![pinned_arm], hir::MatchSource::AwaitDesugar)\n     }\n \n     fn lower_expr_closure(\n@@ -1255,7 +1244,6 @@ impl LoweringContext<'_> {\n                 ThinVec::from(attrs.clone()),\n             ));\n             let ok_pat = self.pat_ok(span, val_pat);\n-\n             self.arm(hir_vec![ok_pat], val_expr)\n         };\n \n@@ -1317,7 +1305,7 @@ impl LoweringContext<'_> {\n     /// `{ let _t = $expr; _t }` but should provide better compile-time performance.\n     ///\n     /// The drop order can be important in e.g. `if expr { .. }`.\n-    fn expr_drop_temps(\n+    pub(super) fn expr_drop_temps(\n         &mut self,\n         span: Span,\n         expr: P<hir::Expr>,\n@@ -1486,7 +1474,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn arm(&mut self, pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn arm(&mut self, pats: HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: hir_vec![],"}, {"sha": "61be40a6b907f63e6ea69cd712bcc7bdeb7c9ae2", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -718,7 +718,7 @@ impl LoweringContext<'_> {\n                         AnonymousLifetimeMode::PassThrough,\n                         |this, _| {\n                             (\n-                                // Disallow impl Trait in foreign items\n+                                // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(fdec, None, false, None),\n                                 this.lower_fn_params_to_names(fdec),\n                             )\n@@ -732,7 +732,7 @@ impl LoweringContext<'_> {\n                         self.lower_ty(t, ImplTraitContext::disallowed()), self.lower_mutability(m))\n                 }\n                 ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n-                ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n+                ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),\n             },\n             vis: self.lower_visibility(&i.vis, None),\n             span: i.span,\n@@ -1071,10 +1071,7 @@ impl LoweringContext<'_> {\n     }\n \n     fn lower_fn_body_block(&mut self, decl: &FnDecl, body: &Block) -> hir::BodyId {\n-        self.lower_fn_body(decl, |this| {\n-            let body = this.lower_block(body, false);\n-            this.expr_block(body, ThinVec::new())\n-        })\n+        self.lower_fn_body(decl, |this| this.lower_block_expr(body))\n     }\n \n     pub(super) fn lower_const_body(&mut self, expr: &Expr) -> hir::BodyId {\n@@ -1102,8 +1099,7 @@ impl LoweringContext<'_> {\n             // from:\n             //\n             //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n-            //       async move {\n-            //       }\n+            //         <body>\n             //     }\n             //\n             // into:\n@@ -1116,11 +1112,19 @@ impl LoweringContext<'_> {\n             //         let <pattern> = __arg1;\n             //         let __arg0 = __arg0;\n             //         let <pattern> = __arg0;\n+            //         drop-temps { <body> } // see comments later in fn for details\n             //       }\n             //     }\n             //\n             // If `<pattern>` is a simple ident, then it is lowered to a single\n             // `let <pattern> = <pattern>;` statement as an optimization.\n+            //\n+            // Note that the body is embedded in `drop-temps`; an\n+            // equivalent desugaring would be `return { <body>\n+            // };`. The key point is that we wish to drop all the\n+            // let-bound variables and temporaries created in the body\n+            // (and its tail expression!) before we drop the\n+            // parameters (c.f. rust-lang/rust#64512).\n             for (index, parameter) in decl.inputs.iter().enumerate() {\n                 let parameter = this.lower_param(parameter);\n                 let span = parameter.pat.span;\n@@ -1219,8 +1223,36 @@ impl LoweringContext<'_> {\n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value, closure_id, None, body.span,\n                 |this| {\n-                    let body = this.lower_block_with_stmts(body, false, statements);\n-                    this.expr_block(body, ThinVec::new())\n+                    // Create a block from the user's function body:\n+                    let user_body = this.lower_block_expr(body);\n+\n+                    // Transform into `drop-temps { <user-body> }`, an expression:\n+                    let desugared_span = this.mark_span_with_reason(\n+                        DesugaringKind::Async,\n+                        user_body.span,\n+                        None,\n+                    );\n+                    let user_body = this.expr_drop_temps(\n+                        desugared_span,\n+                        P(user_body),\n+                        ThinVec::new(),\n+                    );\n+\n+                    // As noted above, create the final block like\n+                    //\n+                    // ```\n+                    // {\n+                    //   let $param_pattern = $raw_param;\n+                    //   ...\n+                    //   drop-temps { <user-body> }\n+                    // }\n+                    // ```\n+                    let body = this.block_all(\n+                        desugared_span,\n+                        statements.into(),\n+                        Some(P(user_body)),\n+                    );\n+                    this.expr_block(P(body), ThinVec::new())\n                 });\n             (HirVec::from(parameters), this.expr(body.span, async_expr, ThinVec::new()))\n         })"}, {"sha": "4179cf2ff807fd0d169900eef3e3c8bbec10afcf", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -340,7 +340,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     /// their outer items.\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n-        panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n+        panic!(\"`visit_nested_xxx` must be manually implemented in this visitor\");\n     }\n \n     fn visit_nested_item(&mut self, item: ItemId) {"}, {"sha": "d1cc7a8ce988fd30efc58a0bb6ccfd7418a18c92", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 69, "deletions": 7, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -31,7 +31,7 @@ impl<'a> DefCollector<'a> {\n         self.definitions.create_def_with_parent(parent_def, node_id, data, self.expansion, span)\n     }\n \n-    pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n+    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n         let orig_parent_def = std::mem::replace(&mut self.parent_def, parent_def);\n         f(self);\n         self.parent_def = orig_parent_def;\n@@ -74,6 +74,22 @@ impl<'a> DefCollector<'a> {\n         })\n     }\n \n+    fn collect_field(&mut self, field: &'a StructField, index: Option<usize>) {\n+        if field.is_placeholder {\n+            self.visit_macro_invoc(field.id);\n+        } else {\n+            let name = field.ident.map(|ident| ident.name)\n+                .or_else(|| index.map(sym::integer))\n+                .unwrap_or_else(|| {\n+                    let node_id = NodeId::placeholder_from_expn_id(self.expansion);\n+                    sym::integer(self.definitions.placeholder_field_indices[&node_id])\n+                })\n+                .as_interned_str();\n+            let def = self.create_def(field.id, DefPathData::ValueNs(name), field.span);\n+            self.with_parent(def, |this| visit::walk_struct_field(this, field));\n+        }\n+    }\n+\n     pub fn visit_macro_invoc(&mut self, id: NodeId) {\n         self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n     }\n@@ -155,6 +171,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_variant(&mut self, v: &'a Variant) {\n+        if v.is_placeholder {\n+            return self.visit_macro_invoc(v.id);\n+        }\n         let def = self.create_def(v.id,\n                                   DefPathData::TypeNs(v.ident.as_interned_str()),\n                                   v.span);\n@@ -167,17 +186,22 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_variant_data(&mut self, data: &'a VariantData) {\n+        // The assumption here is that non-`cfg` macro expansion cannot change field indices.\n+        // It currently holds because only inert attributes are accepted on fields,\n+        // and every such attribute expands into a single field after it's resolved.\n         for (index, field) in data.fields().iter().enumerate() {\n-            let name = field.ident.map(|ident| ident.name)\n-                .unwrap_or_else(|| sym::integer(index));\n-            let def = self.create_def(field.id,\n-                                      DefPathData::ValueNs(name.as_interned_str()),\n-                                      field.span);\n-            self.with_parent(def, |this| this.visit_struct_field(field));\n+            self.collect_field(field, Some(index));\n+            if field.is_placeholder && field.ident.is_none() {\n+                self.definitions.placeholder_field_indices.insert(field.id, index);\n+            }\n         }\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n+        if param.is_placeholder {\n+            self.visit_macro_invoc(param.id);\n+            return;\n+        }\n         let name = param.ident.as_interned_str();\n         let def_path_data = match param.kind {\n             GenericParamKind::Lifetime { .. } => DefPathData::LifetimeNs(name),\n@@ -294,4 +318,42 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             }\n         }\n     }\n+\n+    fn visit_arm(&mut self, arm: &'a Arm) {\n+        if arm.is_placeholder {\n+            self.visit_macro_invoc(arm.id)\n+        } else {\n+            visit::walk_arm(self, arm)\n+        }\n+    }\n+\n+    fn visit_field(&mut self, f: &'a Field) {\n+        if f.is_placeholder {\n+            self.visit_macro_invoc(f.id)\n+        } else {\n+            visit::walk_field(self, f)\n+        }\n+    }\n+\n+    fn visit_field_pattern(&mut self, fp: &'a FieldPat) {\n+        if fp.is_placeholder {\n+            self.visit_macro_invoc(fp.id)\n+        } else {\n+            visit::walk_field_pattern(self, fp)\n+        }\n+    }\n+\n+    fn visit_param(&mut self, p: &'a Param) {\n+        if p.is_placeholder {\n+            self.visit_macro_invoc(p.id)\n+        } else {\n+            visit::walk_param(self, p)\n+        }\n+    }\n+\n+    // This method is called only when we are visiting an individual field\n+    // after expanding an attribute on it.\n+    fn visit_struct_field(&mut self, field: &'a StructField) {\n+        self.collect_field(field, None);\n+    }\n }"}, {"sha": "187bc5933246078819b9cba87d3a819c453c9677", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -7,23 +7,24 @@\n use crate::hir;\n use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, CRATE_DEF_INDEX};\n use crate::ich::Fingerprint;\n+use crate::session::CrateDisambiguator;\n+use crate::util::nodemap::NodeMap;\n+\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n use rustc_data_structures::stable_hasher::StableHasher;\n-use crate::session::CrateDisambiguator;\n use std::borrow::Borrow;\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::{Symbol, sym, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::util::nodemap::NodeMap;\n \n-/// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n-/// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n-/// stores the DefIndex of its parent.\n-/// There is one DefPathTable for each crate.\n+/// The `DefPathTable` maps `DefIndex`es to `DefKey`s and vice versa.\n+/// Internally the `DefPathTable` holds a tree of `DefKey`s, where each `DefKey`\n+/// stores the `DefIndex` of its parent.\n+/// There is one `DefPathTable` for each crate.\n #[derive(Clone, Default, RustcDecodable, RustcEncodable)]\n pub struct DefPathTable {\n     index_to_key: Vec<DefKey>,\n@@ -103,6 +104,8 @@ pub struct Definitions {\n     /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n     /// we know what parent node that fragment should be attached to thanks to this table.\n     invocation_parents: FxHashMap<ExpnId, DefIndex>,\n+    /// Indices of unnamed struct or variant fields with unresolved attributes.\n+    pub(super) placeholder_field_indices: NodeMap<usize>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -121,7 +124,7 @@ impl DefKey {\n     fn compute_stable_hash(&self, parent_hash: DefPathHash) -> DefPathHash {\n         let mut hasher = StableHasher::new();\n \n-        // We hash a 0u8 here to disambiguate between regular DefPath hashes,\n+        // We hash a `0u8` here to disambiguate between regular `DefPath` hashes,\n         // and the special \"root_parent\" below.\n         0u8.hash(&mut hasher);\n         parent_hash.hash(&mut hasher);\n@@ -145,8 +148,7 @@ impl DefKey {\n                                crate_disambiguator: CrateDisambiguator)\n                                -> DefPathHash {\n         let mut hasher = StableHasher::new();\n-        // Disambiguate this from a regular DefPath hash,\n-        // see compute_stable_hash() above.\n+        // Disambiguate this from a regular `DefPath` hash; see `compute_stable_hash()` above.\n         1u8.hash(&mut hasher);\n         crate_name.hash(&mut hasher);\n         crate_disambiguator.hash(&mut hasher);\n@@ -155,10 +157,10 @@ impl DefKey {\n }\n \n /// A pair of `DefPathData` and an integer disambiguator. The integer is\n-/// normally 0, but in the event that there are multiple defs with the\n+/// normally `0`, but in the event that there are multiple defs with the\n /// same `parent` and `data`, we use this field to disambiguate\n /// between them. This introduces some artificial ordering dependency\n-/// but means that if you have (e.g.) two impls for the same type in\n+/// but means that if you have, e.g., two impls for the same type in\n /// the same module, they do get distinct `DefId`s.\n #[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DisambiguatedDefPathData {\n@@ -277,29 +279,34 @@ impl DefPath {\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n-    /// The crate root (marker)\n+\n+    /// The crate root (marker).\n     CrateRoot,\n-    // Catch-all for random DefId things like `DUMMY_NODE_ID`\n+    // Catch-all for random `DefId` things like `DUMMY_NODE_ID`.\n     Misc,\n+\n     // Different kinds of items and item-like things:\n-    /// An impl\n+\n+    /// An impl.\n     Impl,\n-    /// Something in the type NS\n+    /// Something in the type namespace.\n     TypeNs(InternedString),\n-    /// Something in the value NS\n+    /// Something in the value namespace.\n     ValueNs(InternedString),\n-    /// Something in the macro NS\n+    /// Something in the macro namespace.\n     MacroNs(InternedString),\n-    /// Something in the lifetime NS\n+    /// Something in the lifetime namespace.\n     LifetimeNs(InternedString),\n-    /// A closure expression\n+    /// A closure expression.\n     ClosureExpr,\n-    // Subportions of items\n-    /// Implicit ctor for a unit or tuple-like struct or enum variant.\n+\n+    // Subportions of items:\n+\n+    /// Implicit constructor for a unit or tuple-like struct or enum variant.\n     Ctor,\n-    /// A constant expression (see {ast,hir}::AnonConst).\n+    /// A constant expression (see `{ast,hir}::AnonConst`).\n     AnonConst,\n-    /// An `impl Trait` type node\n+    /// An `impl Trait` type node.\n     ImplTrait,\n     /// Identifies a piece of crate metadata that is global to a whole crate\n     /// (as opposed to just one item). `GlobalMetaData` components are only\n@@ -435,7 +442,7 @@ impl Definitions {\n         self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n         self.set_invocation_parent(ExpnId::root(), root_index);\n \n-        // Allocate some other DefIndices that always must exist.\n+        // Allocate some other `DefIndex`es that always must exist.\n         GlobalMetaDataKind::allocate_def_indices(self);\n \n         root_index\n@@ -458,7 +465,7 @@ impl Definitions {\n                 data,\n                 self.table.def_key(self.node_to_def_index[&node_id]));\n \n-        // The root node must be created with create_root_def()\n+        // The root node must be created with `create_root_def()`.\n         assert!(data != DefPathData::CrateRoot);\n \n         // Find the next free disambiguator for this key.\n@@ -486,9 +493,9 @@ impl Definitions {\n         assert_eq!(index.index(), self.def_index_to_node.len());\n         self.def_index_to_node.push(node_id);\n \n-        // Some things for which we allocate DefIndices don't correspond to\n-        // anything in the AST, so they don't have a NodeId. For these cases\n-        // we don't need a mapping from NodeId to DefIndex.\n+        // Some things for which we allocate `DefIndex`es don't correspond to\n+        // anything in the AST, so they don't have a `NodeId`. For these cases\n+        // we don't need a mapping from `NodeId` to `DefIndex`.\n         if node_id != ast::DUMMY_NODE_ID {\n             debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n             self.node_to_def_index.insert(node_id, index);\n@@ -498,20 +505,20 @@ impl Definitions {\n             self.expansions_that_defined.insert(index, expn_id);\n         }\n \n-        // The span is added if it isn't dummy\n+        // The span is added if it isn't dummy.\n         if !span.is_dummy() {\n             self.def_index_to_span.insert(index, span);\n         }\n \n         index\n     }\n \n-    /// Initialize the `ast::NodeId` to `HirId` mapping once it has been generated during\n+    /// Initializes the `ast::NodeId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n     pub fn init_node_id_to_hir_id_mapping(&mut self,\n                                           mapping: IndexVec<ast::NodeId, hir::HirId>) {\n         assert!(self.node_to_hir_id.is_empty(),\n-                \"Trying initialize NodeId -> HirId mapping twice\");\n+                \"trying to initialize `NodeId` -> `HirId` mapping twice\");\n         self.node_to_hir_id = mapping;\n     }\n \n@@ -533,7 +540,7 @@ impl Definitions {\n \n     pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: DefIndex) {\n         let old_parent = self.invocation_parents.insert(invoc_id, parent);\n-        assert!(old_parent.is_none(), \"parent def-index is reset for an invocation\");\n+        assert!(old_parent.is_none(), \"parent `DefIndex` is reset for an invocation\");\n     }\n }\n \n@@ -585,9 +592,9 @@ impl DefPathData {\n     }\n }\n \n-// We define the GlobalMetaDataKind enum with this macro because we want to\n+// We define the `GlobalMetaDataKind` enum with this macro because we want to\n // make sure that we exhaustively iterate over all variants when registering\n-// the corresponding DefIndices in the DefTable.\n+// the corresponding `DefIndex`es in the `DefTable`.\n macro_rules! define_global_metadata_kind {\n     (pub enum GlobalMetaDataKind {\n         $($variant:ident),*\n@@ -609,7 +616,7 @@ macro_rules! define_global_metadata_kind {\n                         DUMMY_SP\n                     );\n \n-                    // Make sure calling def_index does not crash.\n+                    // Make sure calling `def_index` does not crash.\n                     instance.def_index(&definitions.table);\n                 })*\n             }\n@@ -623,7 +630,7 @@ macro_rules! define_global_metadata_kind {\n                     }\n                 };\n \n-                // These DefKeys are all right after the root,\n+                // These `DefKey`s are all right after the root,\n                 // so a linear search is fine.\n                 let index = def_path_table.index_to_key\n                                           .iter()"}, {"sha": "5cec8a593f12af42337d18b12bf41164b2a516f1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -5,10 +5,15 @@ pub use self::definitions::{\n };\n \n use crate::dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n-\n+use crate::hir::*;\n+use crate::hir::DefKind;\n use crate::hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId};\n-\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir::print::Nested;\n use crate::middle::cstore::CrateStoreDyn;\n+use crate::ty::query::Providers;\n+use crate::util::nodemap::FxHashMap;\n+use crate::util::common::time;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n@@ -18,15 +23,7 @@ use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use crate::hir::*;\n-use crate::hir::DefKind;\n-use crate::hir::itemlikevisit::ItemLikeVisitor;\n-use crate::hir::print::Nested;\n-use crate::util::nodemap::FxHashMap;\n-use crate::util::common::time;\n-\n use std::result::Result::Err;\n-use crate::ty::query::Providers;\n \n pub mod blocks;\n mod collector;\n@@ -627,7 +624,7 @@ impl<'hir> Map<'hir> {\n             .unwrap_or(hir_id)\n     }\n \n-    /// Check if the node is an argument. An argument is a local variable whose\n+    /// Checks if the node is an argument. An argument is a local variable whose\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: HirId) -> bool {\n         match self.find(id) {\n@@ -733,7 +730,7 @@ impl<'hir> Map<'hir> {\n     /// ```\n     /// fn foo(x: usize) -> bool {\n     ///     if x == 1 {\n-    ///         true  // `get_return_block` gets passed the `id` corresponding\n+    ///         true  // If `get_return_block` gets passed the `id` corresponding\n     ///     } else {  // to this, it will return `foo`'s `HirId`.\n     ///         false\n     ///     }\n@@ -743,7 +740,7 @@ impl<'hir> Map<'hir> {\n     /// ```\n     /// fn foo(x: usize) -> bool {\n     ///     loop {\n-    ///         true  // `get_return_block` gets passed the `id` corresponding\n+    ///         true  // If `get_return_block` gets passed the `id` corresponding\n     ///     }         // to this, it will return `None`.\n     ///     false\n     /// }\n@@ -994,9 +991,9 @@ impl<'hir> Map<'hir> {\n         self.map.iter().enumerate().filter_map(|(i, local_map)| {\n             local_map.as_ref().map(|m| (i, m))\n         }).flat_map(move |(array_index, local_map)| {\n-            // Iterate over each valid entry in the local map\n+            // Iterate over each valid entry in the local map.\n             local_map.iter_enumerated().filter_map(move |(i, entry)| entry.map(move |_| {\n-                // Reconstruct the HirId based on the 3 indices we used to find it\n+                // Reconstruct the `HirId` based on the 3 indices we used to find it.\n                 HirId {\n                     owner: DefIndex::from(array_index),\n                     local_id: i,\n@@ -1207,7 +1204,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n         definitions,\n     };\n \n-    time(sess, \"validate hir map\", || {\n+    time(sess, \"validate HIR map\", || {\n         hir_id_validator::check_crate(&map);\n     });\n \n@@ -1247,18 +1244,18 @@ impl<'a> print::State<'a> {\n             Node::Pat(a)          => self.print_pat(&a),\n             Node::Arm(a)          => self.print_arm(&a),\n             Node::Block(a)        => {\n-                // containing cbox, will be closed by print-block at }\n+                // Containing cbox, will be closed by print-block at `}`.\n                 self.cbox(print::INDENT_UNIT);\n-                // head-ibox, will be closed by print-block after {\n+                // Head-ibox, will be closed by print-block after `{`.\n                 self.ibox(0);\n                 self.print_block(&a)\n             }\n             Node::Lifetime(a)     => self.print_lifetime(&a),\n             Node::Visibility(a)   => self.print_visibility(&a),\n             Node::GenericParam(_) => bug!(\"cannot print Node::GenericParam\"),\n             Node::Field(_)        => bug!(\"cannot print StructField\"),\n-            // these cases do not carry enough information in the\n-            // hir_map to reconstruct their full structure for pretty\n+            // These cases do not carry enough information in the\n+            // `hir_map` to reconstruct their full structure for pretty\n             // printing.\n             Node::Ctor(..)        => bug!(\"cannot print isolated Ctor\"),\n             Node::Local(a)        => self.print_local_decl(&a),\n@@ -1273,8 +1270,8 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n     let id_str = if include_id { &id_str[..] } else { \"\" };\n \n     let path_str = || {\n-        // This functionality is used for debugging, try to use TyCtxt to get\n-        // the user-friendly path, otherwise fall back to stringifying DefPath.\n+        // This functionality is used for debugging, try to use `TyCtxt` to get\n+        // the user-friendly path, otherwise fall back to stringifying `DefPath`.\n         crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n                 let def_id = map.local_def_id(id);"}, {"sha": "2c8590aa4e3fa14f3b87504c2e3fb950205e27e9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -13,26 +13,24 @@ pub use self::UnsafeSource::*;\n use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use crate::hir::ptr::P;\n-use crate::util::nodemap::{NodeMap, FxHashSet};\n use crate::mir::mono::Linkage;\n+use crate::ty::AdtKind;\n+use crate::ty::query::Providers;\n+use crate::util::nodemap::{NodeMap, FxHashSet};\n \n use errors::FatalError;\n use syntax_pos::{Span, DUMMY_SP, symbol::InternedString, MultiSpan};\n use syntax::source_map::Spanned;\n-use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n-use crate::ty::AdtKind;\n-use crate::ty::query::Providers;\n-\n+use rustc_target::spec::abi::Abi;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable;\n-\n use rustc_serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::{BTreeSet, BTreeMap};\n use std::fmt;\n@@ -99,7 +97,8 @@ impl rustc_serialize::UseSpecializedEncodable for HirId {\n         } = *self;\n \n         owner.encode(s)?;\n-        local_id.encode(s)\n+        local_id.encode(s)?;\n+        Ok(())\n     }\n }\n \n@@ -121,7 +120,7 @@ impl fmt::Display for HirId {\n     }\n }\n \n-// Hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n+// Hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module.\n mod item_local_id_inner {\n     use rustc_data_structures::indexed_vec::Idx;\n     use rustc_macros::HashStable;\n@@ -191,7 +190,7 @@ pub enum ParamName {\n     Fresh(usize),\n \n     /// Indicates an illegal name was given and an error has been\n-    /// repored (so we should squelch other derived errors). Occurs\n+    /// reported (so we should squelch other derived errors). Occurs\n     /// when, e.g., `'_` is used in the wrong place.\n     Error,\n }\n@@ -746,7 +745,7 @@ pub struct Crate {\n     // Attributes from non-exported macros, kept only for collecting the library feature list.\n     pub non_exported_macro_attrs: HirVec<Attribute>,\n \n-    // N.B., we use a BTreeMap here so that `visit_all_items` iterates\n+    // N.B., we use a `BTreeMap` here so that `visit_all_items` iterates\n     // over the ids in increasing order. In principle it should not\n     // matter what order we visit things in, but in *practice* it\n     // does, because it can affect the order in which errors are\n@@ -1403,13 +1402,13 @@ pub struct AnonConst {\n     pub body: BodyId,\n }\n \n-/// An expression\n+/// An expression.\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Expr {\n-    pub span: Span,\n+    pub hir_id: HirId,\n     pub node: ExprKind,\n     pub attrs: ThinVec<Attribute>,\n-    pub hir_id: HirId,\n+    pub span: Span,\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -2422,37 +2421,37 @@ pub enum ItemKind {\n     ///\n     /// or just\n     ///\n-    /// `use foo::bar::baz;` (with `as baz` implicitly on the right)\n+    /// `use foo::bar::baz;` (with `as baz` implicitly on the right).\n     Use(P<Path>, UseKind),\n \n-    /// A `static` item\n+    /// A `static` item.\n     Static(P<Ty>, Mutability, BodyId),\n-    /// A `const` item\n+    /// A `const` item.\n     Const(P<Ty>, BodyId),\n-    /// A function declaration\n+    /// A function declaration.\n     Fn(P<FnDecl>, FnHeader, Generics, BodyId),\n-    /// A module\n+    /// A module.\n     Mod(Mod),\n-    /// An external module\n+    /// An external module.\n     ForeignMod(ForeignMod),\n-    /// Module-level inline assembly (from global_asm!)\n+    /// Module-level inline assembly (from `global_asm!`).\n     GlobalAsm(P<GlobalAsm>),\n-    /// A type alias, e.g., `type Foo = Bar<u8>`\n+    /// A type alias, e.g., `type Foo = Bar<u8>`.\n     TyAlias(P<Ty>, Generics),\n-    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`\n+    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n     OpaqueTy(OpaqueTy),\n-    /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`\n+    /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`.\n     Enum(EnumDef, Generics),\n-    /// A struct definition, e.g., `struct Foo<A> {x: A}`\n+    /// A struct definition, e.g., `struct Foo<A> {x: A}`.\n     Struct(VariantData, Generics),\n-    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`\n+    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n     Union(VariantData, Generics),\n-    /// A trait definition\n+    /// A trait definition.\n     Trait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),\n-    /// A trait alias\n+    /// A trait alias.\n     TraitAlias(Generics, GenericBounds),\n \n-    /// An implementation, eg `impl<A> Trait for Foo { .. }`\n+    /// An implementation, e.g., `impl<A> Trait for Foo { .. }`.\n     Impl(Unsafety,\n          ImplPolarity,\n          Defaultness,"}, {"sha": "cfbfb5eceb550f4016afe6b49f82cc29b462de5b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1293,11 +1293,11 @@ impl<'a> State<'a> {\n                 self.print_closure_params(&decl, body);\n                 self.s.space();\n \n-                // this is a bare expression\n+                // This is a bare expression.\n                 self.ann.nested(self, Nested::Body(body));\n                 self.end(); // need to close a box\n \n-                // a box will be closed by print_expr, but we didn't want an overall\n+                // A box will be closed by `print_expr`, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an\n                 // empty box to satisfy the close.\n                 self.ibox(0);\n@@ -1307,9 +1307,9 @@ impl<'a> State<'a> {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n                 }\n-                // containing cbox, will be closed by print-block at }\n+                // containing cbox, will be closed by print-block at `}`\n                 self.cbox(INDENT_UNIT);\n-                // head-box, will be closed by print-block after {\n+                // head-box, will be closed by print-block after `{`\n                 self.ibox(0);\n                 self.print_block(&blk);\n             }\n@@ -1759,7 +1759,7 @@ impl<'a> State<'a> {\n                         self.word_space(\",\");\n                     }\n                     if let PatKind::Wild = p.node {\n-                        // Print nothing\n+                        // Print nothing.\n                     } else {\n                         self.print_pat(&p);\n                     }\n@@ -1891,7 +1891,7 @@ impl<'a> State<'a> {\n             i += 1;\n \n             if let hir::TyKind::Infer = ty.node {\n-                // Print nothing\n+                // Print nothing.\n             } else {\n                 s.s.word(\":\");\n                 s.s.space();\n@@ -2221,14 +2221,15 @@ impl<'a> State<'a> {\n     }\n }\n \n-// Dup'ed from parse::classify, but adapted for the HIR.\n /// Does this expression require a semicolon to be treated\n /// as a statement? The negation of this: 'can this expression\n /// be used as a statement without a semicolon' -- is used\n /// as an early-bail-out in the parser so that, for instance,\n ///     if true {...} else {...}\n ///      |x| 5\n /// isn't parsed as (if true {...} else {...} | x) | 5\n+//\n+// Duplicated from `parse::classify`, but adapted for the HIR.\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n         hir::ExprKind::Match(..) |\n@@ -2238,7 +2239,7 @@ fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     }\n }\n \n-/// this statement requires a semicolon after it.\n+/// This statement requires a semicolon after it.\n /// note that in one case (stmt_semi), we've already\n /// seen the semicolon, and thus don't need another.\n fn stmt_ends_with_semi(stmt: &hir::StmtKind) -> bool {\n@@ -2277,7 +2278,7 @@ fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n     }\n }\n \n-/// Expressions that syntactically contain an \"exterior\" struct literal i.e., not surrounded by any\n+/// Expressions that syntactically contain an \"exterior\" struct literal, i.e., not surrounded by any\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n@@ -2287,20 +2288,20 @@ fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n         hir::ExprKind::Assign(ref lhs, ref rhs) |\n         hir::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n         hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n-            // X { y: 1 } + X { y: 2 }\n+            // `X { y: 1 } + X { y: 2 }`\n             contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n         }\n         hir::ExprKind::Unary(_, ref x) |\n         hir::ExprKind::Cast(ref x, _) |\n         hir::ExprKind::Type(ref x, _) |\n         hir::ExprKind::Field(ref x, _) |\n         hir::ExprKind::Index(ref x, _) => {\n-            // &X { y: 1 }, X { y: 1 }.y\n+            // `&X { y: 1 }, X { y: 1 }.y`\n             contains_exterior_struct_lit(&x)\n         }\n \n         hir::ExprKind::MethodCall(.., ref exprs) => {\n-            // X { y: 1 }.bar(...)\n+            // `X { y: 1 }.bar(...)`\n             contains_exterior_struct_lit(&exprs[0])\n         }\n "}, {"sha": "182a9ade8c36ead44a39da901c9126bc1cf5c4b3", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -12,17 +12,16 @@ use std::hash as std_hash;\n use std::cell::RefCell;\n \n use syntax::ast;\n-\n use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n use syntax::tokenstream::DelimSpan;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::hygiene;\n \n-use rustc_data_structures::stable_hasher::{HashStable,\n-                                           StableHasher, StableHasherResult,\n-                                           ToStableHashKey};\n+use rustc_data_structures::stable_hasher::{\n+    HashStable, StableHasher, StableHasherResult, ToStableHashKey,\n+};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use smallvec::SmallVec;\n \n@@ -32,9 +31,9 @@ fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n }\n \n /// This is the context state available during incr. comp. hashing. It contains\n-/// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n-/// a reference to the TyCtxt) and it holds a few caches for speeding up various\n-/// things (e.g., each DefId/DefPath is only hashed once).\n+/// enough information to transform `DefId`s and `HirId`s into stable `DefPath`s (i.e.,\n+/// a reference to the `TyCtxt`) and it holds a few caches for speeding up various\n+/// things (e.g., each `DefId`/`DefPath` is only hashed once).\n #[derive(Clone)]\n pub struct StableHashingContext<'a> {\n     sess: &'a Session,\n@@ -46,7 +45,7 @@ pub struct StableHashingContext<'a> {\n     node_id_hashing_mode: NodeIdHashingMode,\n \n     // Very often, we are hashing something that does not need the\n-    // CachingSourceMapView, so we initialize it lazily.\n+    // `CachingSourceMapView`, so we initialize it lazily.\n     raw_source_map: &'a SourceMap,\n     caching_source_map: Option<CachingSourceMapView<'a>>,\n }\n@@ -57,24 +56,24 @@ pub enum NodeIdHashingMode {\n     HashDefPath,\n }\n \n-/// The BodyResolver allows to map a BodyId to the corresponding hir::Body.\n-/// We could also just store a plain reference to the hir::Crate but we want\n+/// The `BodyResolver` allows mapping a `BodyId` to the corresponding `hir::Body`.\n+/// We could also just store a plain reference to the `hir::Crate` but we want\n /// to avoid that the crate is used to get untracked access to all of the HIR.\n #[derive(Clone, Copy)]\n struct BodyResolver<'tcx>(&'tcx hir::Crate);\n \n impl<'tcx> BodyResolver<'tcx> {\n-    // Return a reference to the hir::Body with the given BodyId.\n-    // DOES NOT DO ANY TRACKING, use carefully.\n+    /// Returns a reference to the `hir::Body` with the given `BodyId`.\n+    /// **Does not do any tracking**; use carefully.\n     fn body(self, id: hir::BodyId) -> &'tcx hir::Body {\n         self.0.body(id)\n     }\n }\n \n impl<'a> StableHashingContext<'a> {\n-    // The `krate` here is only used for mapping BodyIds to Bodies.\n-    // Don't use it for anything else or you'll run the risk of\n-    // leaking data out of the tracking system.\n+    /// The `krate` here is only used for mapping `BodyId`s to `Body`s.\n+    /// Don't use it for anything else or you'll run the risk of\n+    /// leaking data out of the tracking system.\n     #[inline]\n     pub fn new(sess: &'a Session,\n                krate: &'a hir::Crate,\n@@ -217,9 +216,7 @@ impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n     }\n }\n \n-impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {\n-}\n-\n+impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {}\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -292,16 +289,15 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::NodeId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Span {\n-\n-    // Hash a span in a stable way. We can't directly hash the span's BytePos\n-    // fields (that would be similar to hashing pointers, since those are just\n-    // offsets into the SourceMap). Instead, we hash the (file name, line, column)\n-    // triple, which stays the same even if the containing SourceFile has moved\n-    // within the SourceMap.\n-    // Also note that we are hashing byte offsets for the column, not unicode\n-    // codepoint offsets. For the purpose of the hash that's sufficient.\n-    // Also, hashing filenames is expensive so we avoid doing it twice when the\n-    // span starts and ends in the same file, which is almost always the case.\n+    /// Hashes a span in a stable way. We can't directly hash the span's `BytePos`\n+    /// fields (that would be similar to hashing pointers, since those are just\n+    /// offsets into the `SourceMap`). Instead, we hash the (file name, line, column)\n+    /// triple, which stays the same even if the containing `SourceFile` has moved\n+    /// within the `SourceMap`.\n+    /// Also note that we are hashing byte offsets for the column, not unicode\n+    /// codepoint offsets. For the purpose of the hash that's sufficient.\n+    /// Also, hashing filenames is expensive so we avoid doing it twice when the\n+    /// span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -340,7 +336,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n         }\n \n         std_hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n-        // We truncate the stable_id hash and line and col numbers. The chances\n+        // We truncate the stable ID hash and line and column numbers. The chances\n         // of causing a collision this way should be minimal.\n         std_hash::Hash::hash(&(file_lo.name_hash as u64), hasher);\n "}, {"sha": "6e6492d0426f257c7fe9927b9361f9c9c5a3bf48", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -5,8 +5,10 @@ use crate::hir;\n use crate::hir::map::DefPathHash;\n use crate::hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n use crate::ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n-use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n-                                           StableHasher, StableHasherResult};\n+\n+use rustc_data_structures::stable_hasher::{\n+    HashStable, ToStableHashKey, StableHasher, StableHasherResult,\n+};\n use smallvec::SmallVec;\n use std::mem;\n use syntax::ast;\n@@ -82,9 +84,9 @@ for hir::ItemLocalId {\n     }\n }\n \n-// The following implementations of HashStable for ItemId, TraitItemId, and\n-// ImplItemId deserve special attention. Normally we do not hash NodeIds within\n-// the HIR, since they just signify a HIR nodes own path. But ItemId et al\n+// The following implementations of HashStable for `ItemId`, `TraitItemId`, and\n+// `ImplItemId` deserve special attention. Normally we do not hash `NodeId`s within\n+// the HIR, since they just signify a HIR nodes own path. But `ItemId` et al\n // are used when another item in the HIR is *referenced* and we certainly\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n@@ -131,7 +133,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     }\n }\n \n-\n impl_stable_hash_for!(struct ast::Label {\n     ident\n });\n@@ -241,7 +242,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n     }\n }\n \n-impl_stable_hash_for!(enum ::syntax::ast::CrateSugar {\n+impl_stable_hash_for!(enum ast::CrateSugar {\n     JustCrate,\n     PubCrate,\n });\n@@ -365,8 +366,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     }\n }\n \n-impl<'a> ToStableHashKey<StableHashingContext<'a>>\n-for hir::def_id::DefIndex {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     type KeyType = DefPathHash;\n \n     #[inline]"}, {"sha": "a33181e5925cda13aef96e1b5f138237beb138e3", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -115,9 +115,10 @@ for ::syntax::attr::StabilityLevel {\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue } => {\n+            ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue, ref is_soft } => {\n                 reason.hash_stable(hcx, hasher);\n                 issue.hash_stable(hcx, hasher);\n+                is_soft.hash_stable(hcx, hasher);\n             }\n             ::syntax::attr::StabilityLevel::Stable { ref since } => {\n                 since.hash_stable(hcx, hasher);\n@@ -390,9 +391,17 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnKind {\n     Root,\n     Macro(kind, descr),\n+    AstPass(kind),\n     Desugaring(kind)\n });\n \n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::AstPass {\n+    StdImports,\n+    TestHarness,\n+    ProcMacroHarness,\n+    PluginMacroDefs,\n+});\n+\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::DesugaringKind {\n     CondTemporary,\n     Async,"}, {"sha": "f230c53728748d4a215cc7186a98b79303977fee", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -204,7 +204,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::TyVid {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _hcx: &mut StableHashingContext<'a>,\n                                           _hasher: &mut StableHasher<W>) {\n-        // TyVid values are confined to an inference context and hence\n+        // `TyVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash a TyVid {:?}.\", *self)\n     }\n@@ -214,7 +214,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::IntVid {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _hcx: &mut StableHashingContext<'a>,\n                                           _hasher: &mut StableHasher<W>) {\n-        // IntVid values are confined to an inference context and hence\n+        // `IntVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash an IntVid {:?}.\", *self)\n     }\n@@ -224,7 +224,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::FloatVid {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _hcx: &mut StableHashingContext<'a>,\n                                           _hasher: &mut StableHasher<W>) {\n-        // FloatVid values are confined to an inference context and hence\n+        // `FloatVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash a FloatVid {:?}.\", *self)\n     }"}, {"sha": "96d40bc81add2633eecb641999b0a4daf965baea", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -97,7 +97,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n                self.tag(),\n                a,\n                b);\n-        let origin = Subtype(self.fields.trace.clone());\n+        let origin = Subtype(box self.fields.trace.clone());\n         self.fields.infcx.borrow_region_constraints()\n                          .make_eqregion(origin, a, b);\n         Ok(a)"}, {"sha": "ab24b3f2f059f1b953a5b5befa982e9630090ff0", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -55,7 +55,8 @@ use crate::hir::def_id::DefId;\n use crate::hir::Node;\n use crate::infer::opaque_types;\n use crate::middle::region;\n-use crate::traits::{ObligationCause, ObligationCauseCode};\n+use crate::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n+use crate::traits::{ObligationCauseCode};\n use crate::ty::error::TypeError;\n use crate::ty::{self, subst::{Subst, SubstsRef}, Region, Ty, TyCtxt, TypeFoldable};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n@@ -624,13 +625,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            ObligationCauseCode::MatchExpressionArm {\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                 source,\n                 ref prior_arms,\n                 last_ty,\n                 discrim_hir_id,\n                 ..\n-            } => match source {\n+            }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arms have incompatible types\";\n                     err.span_label(cause.span, msg);\n@@ -681,7 +682,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n             },\n-            ObligationCauseCode::IfExpression { then, outer, semicolon } => {\n+            ObligationCauseCode::IfExpression(box IfExpressionCause { then, outer, semicolon }) => {\n                 err.span_label(then, \"expected because of this\");\n                 outer.map(|sp| err.span_label(sp, \"if and else have incompatible types\"));\n                 if let Some(sp) = semicolon {\n@@ -1622,13 +1623,15 @@ impl<'tcx> ObligationCause<'tcx> {\n         use crate::traits::ObligationCauseCode::*;\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n-            MatchExpressionArm { source, .. } => Error0308(match source {\n-                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have incompatible types\",\n-                hir::MatchSource::TryDesugar => {\n-                    \"try expression alternatives have incompatible types\"\n-                }\n-                _ => \"match arms have incompatible types\",\n-            }),\n+            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) =>\n+                Error0308(match source {\n+                    hir::MatchSource::IfLetDesugar { .. } =>\n+                        \"`if let` arms have incompatible types\",\n+                    hir::MatchSource::TryDesugar => {\n+                        \"try expression alternatives have incompatible types\"\n+                    }\n+                    _ => \"match arms have incompatible types\",\n+                }),\n             IfExpression { .. } => Error0308(\"if and else have incompatible types\"),\n             IfExpressionWithNoElse => Error0317(\"if may be missing an else clause\"),\n             MainFunctionType => Error0580(\"main function has wrong type\"),\n@@ -1656,7 +1659,7 @@ impl<'tcx> ObligationCause<'tcx> {\n         match self.code {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\",\n-            MatchExpressionArm { source, .. } => match source {\n+            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n                 _ => \"match arms have compatible types\",\n             },"}, {"sha": "bfa8353ca343f0be89499f5a20a6feab856eb07f", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -30,7 +30,7 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -50,7 +50,7 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -70,7 +70,7 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -92,7 +92,7 @@ impl NiceRegionError<'me, 'tcx> {\n                 _,\n                 _,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -108,7 +108,7 @@ impl NiceRegionError<'me, 'tcx> {\n             )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -125,7 +125,7 @@ impl NiceRegionError<'me, 'tcx> {\n             )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -142,7 +142,7 @@ impl NiceRegionError<'me, 'tcx> {\n             )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -192,23 +192,28 @@ impl NiceRegionError<'me, 'tcx> {\n             vid, sub_placeholder, sup_placeholder, trait_def_id, expected_substs, actual_substs\n         );\n \n-        let mut err = self.tcx().sess.struct_span_err(\n-            cause.span(self.tcx()),\n-            &format!(\n-                \"implementation of `{}` is not general enough\",\n-                self.tcx().def_path_str(trait_def_id),\n-            ),\n+        let span = cause.span(self.tcx());\n+        let msg = format!(\n+            \"implementation of `{}` is not general enough\",\n+            self.tcx().def_path_str(trait_def_id),\n+        );\n+        let mut err = self.tcx().sess.struct_span_err(span, &msg);\n+        err.span_label(\n+            self.tcx().def_span(trait_def_id),\n+            format!(\"trait `{}` defined here\", self.tcx().def_path_str(trait_def_id)),\n         );\n \n-        match cause.code {\n-            ObligationCauseCode::ItemObligation(def_id) => {\n-                err.note(&format!(\n-                    \"Due to a where-clause on `{}`,\",\n-                    self.tcx().def_path_str(def_id),\n-                ));\n-            }\n-            _ => (),\n-        }\n+        let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id) = cause.code {\n+            err.span_label(span, \"doesn't satisfy where-clause\");\n+            err.span_label(\n+                self.tcx().def_span(def_id),\n+                &format!(\"due to a where-clause on `{}`...\", self.tcx().def_path_str(def_id)),\n+            );\n+            true\n+        } else {\n+            err.span_label(span, &msg);\n+            false\n+        };\n \n         let expected_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n@@ -295,6 +300,7 @@ impl NiceRegionError<'me, 'tcx> {\n             expected_has_vid,\n             actual_has_vid,\n             any_self_ty_has_vid,\n+            leading_ellipsis,\n         );\n \n         err\n@@ -318,6 +324,7 @@ impl NiceRegionError<'me, 'tcx> {\n         expected_has_vid: Option<usize>,\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n+        leading_ellipsis: bool,\n     ) {\n         // HACK(eddyb) maybe move this in a more central location.\n         #[derive(Copy, Clone)]\n@@ -392,13 +399,15 @@ impl NiceRegionError<'me, 'tcx> {\n \n             let mut note = if passive_voice {\n                 format!(\n-                    \"`{}` would have to be implemented for the type `{}`\",\n+                    \"{}`{}` would have to be implemented for the type `{}`\",\n+                    if leading_ellipsis { \"...\" } else { \"\" },\n                     expected_trait_ref,\n                     expected_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n                 format!(\n-                    \"`{}` must implement `{}`\",\n+                    \"{}`{}` must implement `{}`\",\n+                    if leading_ellipsis { \"...\" } else { \"\" },\n                     expected_trait_ref.map(|tr| tr.self_ty()),\n                     expected_trait_ref,\n                 )\n@@ -407,20 +416,20 @@ impl NiceRegionError<'me, 'tcx> {\n             match (has_sub, has_sup) {\n                 (Some(n1), Some(n2)) => {\n                     let _ = write!(note,\n-                        \", for any two lifetimes `'{}` and `'{}`\",\n+                        \", for any two lifetimes `'{}` and `'{}`...\",\n                         std::cmp::min(n1, n2),\n                         std::cmp::max(n1, n2),\n                     );\n                 }\n                 (Some(n), _) | (_, Some(n)) => {\n                     let _ = write!(note,\n-                        \", for any lifetime `'{}`\",\n+                        \", for any lifetime `'{}`...\",\n                         n,\n                     );\n                 }\n                 (None, None) => if let Some(n) = expected_has_vid {\n                     let _ = write!(note,\n-                        \", for some specific lifetime `'{}`\",\n+                        \", for some specific lifetime `'{}`...\",\n                         n,\n                     );\n                 },\n@@ -439,13 +448,13 @@ impl NiceRegionError<'me, 'tcx> {\n \n             let mut note = if passive_voice {\n                 format!(\n-                    \"but `{}` is actually implemented for the type `{}`\",\n+                    \"...but `{}` is actually implemented for the type `{}`\",\n                     actual_trait_ref,\n                     actual_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n                 format!(\n-                    \"but `{}` actually implements `{}`\",\n+                    \"...but `{}` actually implements `{}`\",\n                     actual_trait_ref.map(|tr| tr.self_ty()),\n                     actual_trait_ref,\n                 )"}, {"sha": "115ffea97bf1a47a3e3a0809f3a90163068d70e7", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                           sup: Region<'tcx>)\n                                           -> DiagnosticBuilder<'tcx> {\n         match origin {\n-            infer::Subtype(trace) => {\n+            infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 let mut err = self.report_and_explain_type_error(trace, &terr);\n                 self.tcx.note_and_explain_region(region_scope_tree, &mut err, \"\", sup, \"...\");\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx> {\n         // I can't think how to do better than this right now. -nikomatsakis\n         match placeholder_origin {\n-            infer::Subtype(trace) => {\n+            infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsPlaceholderMismatch;\n                 self.report_and_explain_type_error(trace, &terr)\n             }"}, {"sha": "10e45321a6d6ae5e2d3ecf4fbc3b40546f7e6f13", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -57,7 +57,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n                a,\n                b);\n \n-        let origin = Subtype(self.fields.trace.clone());\n+        let origin = Subtype(box self.fields.trace.clone());\n         Ok(self.fields.infcx.borrow_region_constraints().glb_regions(self.tcx(), origin, a, b))\n     }\n "}, {"sha": "8b64cda7bd26d7e22e335c47f4fd3cfa4d5ed13d", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -57,7 +57,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n                a,\n                b);\n \n-        let origin = Subtype(self.fields.trace.clone());\n+        let origin = Subtype(box self.fields.trace.clone());\n         Ok(self.fields.infcx.borrow_region_constraints().lub_regions(self.tcx(), origin, a, b))\n     }\n "}, {"sha": "c5712cc9941a9d84d32dae63876a813360716607", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -254,7 +254,7 @@ pub struct TypeTrace<'tcx> {\n #[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n     /// Arose from a subtyping relation\n-    Subtype(TypeTrace<'tcx>),\n+    Subtype(Box<TypeTrace<'tcx>>),\n \n     /// Stack-allocated closures cannot outlive innermost loop\n     /// or function so as to ensure we only require finite stack\n@@ -340,6 +340,10 @@ pub enum SubregionOrigin<'tcx> {\n     },\n }\n \n+// `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(SubregionOrigin<'_>, 32);\n+\n /// Places that type/region parameters can appear.\n #[derive(Clone, Copy, Debug)]\n pub enum ParameterOrigin {\n@@ -1321,13 +1325,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         if !value.needs_infer() {\n-            return value.clone(); // avoid duplicated subst-folding\n+            return value.clone(); // Avoid duplicated subst-folding.\n         }\n         let mut r = resolve::OpportunisticVarResolver::new(self);\n         value.fold_with(&mut r)\n     }\n \n-    /// Returns first unresolved variable contained in `T`. In the\n+    /// Returns the first unresolved variable contained in `T`. In the\n     /// process of visiting `T`, this will resolve (where possible)\n     /// type variables in `T`, but it never constructs the final,\n     /// resolved type, so it's more efficient than\n@@ -1462,7 +1466,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n \n-        // this can get called from typeck (by euv), and moves_by_default\n+        // This can get called from typeck (by euv), and `moves_by_default`\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n@@ -1482,7 +1486,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n-    /// Obtain the signature of a closure. For closures, unlike\n+    /// Obtains the signature of a closure. For closures, unlike\n     /// `tcx.fn_sig(def_id)`, this method will work during the\n     /// type-checking of the enclosing function and return the closure\n     /// signature in its partially inferred state.\n@@ -1558,11 +1562,7 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n         ShallowResolver { infcx }\n     }\n \n-    // We have this force-inlined variant of `shallow_resolve` for the one\n-    // callsite that is extremely hot. All other callsites use the normal\n-    // variant.\n-    #[inline(always)]\n-    pub fn inlined_shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.sty {\n             ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n@@ -1597,6 +1597,42 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n             _ => typ,\n         }\n     }\n+\n+    // `resolver.shallow_resolve_changed(ty)` is equivalent to\n+    // `resolver.shallow_resolve(ty) != ty`, but more efficient. It's always\n+    // inlined, despite being large, because it has a single call site that is\n+    // extremely hot.\n+    #[inline(always)]\n+    pub fn shallow_resolve_changed(&mut self, typ: Ty<'tcx>) -> bool {\n+        match typ.sty {\n+            ty::Infer(ty::TyVar(v)) => {\n+                use self::type_variable::TypeVariableValue;\n+\n+                // See the comment in `shallow_resolve()`.\n+                match self.infcx.type_variables.borrow_mut().probe(v) {\n+                    TypeVariableValue::Known { value: t } => self.fold_ty(t) != typ,\n+                    TypeVariableValue::Unknown { .. } => false,\n+                }\n+            }\n+\n+            ty::Infer(ty::IntVar(v)) => {\n+                match self.infcx.int_unification_table.borrow_mut().probe_value(v) {\n+                    Some(v) => v.to_type(self.infcx.tcx) != typ,\n+                    None => false,\n+                }\n+            }\n+\n+            ty::Infer(ty::FloatVar(v)) => {\n+                match self.infcx.float_unification_table.borrow_mut().probe_value(v) {\n+                    Some(v) => v.to_type(self.infcx.tcx) != typ,\n+                    None => false,\n+                }\n+            }\n+\n+            _ => false,\n+        }\n+    }\n+\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n@@ -1605,7 +1641,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.inlined_shallow_resolve(ty)\n+        self.shallow_resolve(ty)\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {"}, {"sha": "76db55ecfa8ef70a4dc8d28f44d8c59e155c98d3", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -130,7 +130,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         // FIXME -- we have more fine-grained information available\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages.\n-        let origin = SubregionOrigin::Subtype(self.fields.trace.clone());\n+        let origin = SubregionOrigin::Subtype(box self.fields.trace.clone());\n         self.fields.infcx.borrow_region_constraints()\n                          .make_subregion(origin, a, b);\n "}, {"sha": "7a01ae6b6d9ccb546b0f5b251ddfb65a7c4740b3", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -45,7 +45,6 @@\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n #![feature(range_is_empty)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n@@ -68,7 +67,6 @@\n \n #[macro_use] extern crate bitflags;\n extern crate getopts;\n-#[macro_use] extern crate lazy_static;\n #[macro_use] extern crate scoped_tls;\n #[cfg(windows)]\n extern crate libc;\n@@ -88,16 +86,13 @@ mod tests;\n #[macro_use]\n mod macros;\n \n-// N.B., this module needs to be declared first so diagnostics are\n-// registered before they are used.\n pub mod error_codes;\n \n #[macro_use]\n pub mod query;\n \n #[macro_use]\n pub mod arena;\n-pub mod cfg;\n pub mod dep_graph;\n pub mod hir;\n pub mod ich;\n@@ -143,6 +138,3 @@ pub mod util {\n \n // Allows macros to refer to this crate as `::rustc`\n extern crate self as rustc;\n-\n-// Build the diagnostics array at the end so that the metadata includes error use sites.\n-__build_diagnostic_array! { librustc, DIAGNOSTICS }"}, {"sha": "dd290572d7bb790208278e70e43dd050050005dd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -395,6 +395,12 @@ declare_lint! {\n     \"reservation of a two-phased borrow conflicts with other shared borrows\"\n }\n \n+declare_lint! {\n+    pub SOFT_UNSTABLE,\n+    Deny,\n+    \"a feature gate that doesn't break dependent crates\"\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -460,6 +466,7 @@ declare_lint_pass! {\n         NESTED_IMPL_TRAIT,\n         MUTABLE_BORROW_RESERVATION_CONFLICT,\n         INDIRECT_STRUCTURAL_MATCH,\n+        SOFT_UNSTABLE,\n     ]\n }\n "}, {"sha": "c658120b95df36a393aa7c773b9f4906cec6971d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -16,32 +16,32 @@\n \n use self::TargetLint::*;\n \n-use std::slice;\n-use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use crate::hir;\n+use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use crate::hir::intravisit as hir_visit;\n+use crate::hir::intravisit::Visitor;\n+use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use crate::lint::{EarlyLintPass, LateLintPass, EarlyLintPassObject, LateLintPassObject};\n use crate::lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n use crate::middle::privacy::AccessLevels;\n-use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use crate::session::{config, early_error, Session};\n use crate::ty::{self, print::Printer, subst::Kind, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n \n+use errors::DiagnosticBuilder;\n+use std::slice;\n use std::default::Default as StdDefault;\n+use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use syntax::ast;\n use syntax::edition;\n-use syntax_pos::{MultiSpan, Span, symbol::Symbol};\n-use errors::DiagnosticBuilder;\n-use crate::hir;\n-use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use crate::hir::intravisit as hir_visit;\n-use crate::hir::intravisit::Visitor;\n-use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n+use syntax_pos::{MultiSpan, Span, symbol::Symbol};\n \n /// Information about the registered lints.\n ///"}, {"sha": "5b490b701267deae304e620ddce0e8178eb2b305", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -646,6 +646,30 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         (Level::Forbid, None) => sess.struct_err(msg),\n     };\n \n+    // Check for future incompatibility lints and issue a stronger warning.\n+    let lints = sess.lint_store.borrow();\n+    let lint_id = LintId::of(lint);\n+    let future_incompatible = lints.future_incompatible(lint_id);\n+\n+    // If this code originates in a foreign macro, aka something that this crate\n+    // did not itself author, then it's likely that there's nothing this crate\n+    // can do about it. We probably want to skip the lint entirely.\n+    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n+        // Any suggestions made here are likely to be incorrect, so anything we\n+        // emit shouldn't be automatically fixed by rustfix.\n+        err.allow_suggestions(false);\n+\n+        // If this is a future incompatible lint it'll become a hard error, so\n+        // we have to emit *something*. Also allow lints to whitelist themselves\n+        // on a case-by-case basis for emission in a foreign macro.\n+        if future_incompatible.is_none() && !lint.report_in_external_macro {\n+            err.cancel();\n+            // Don't continue further, since we don't want to have\n+            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n+            return err;\n+        }\n+    }\n+\n     let name = lint.name_lower();\n     match src {\n         LintSource::Default => {\n@@ -695,10 +719,6 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n \n     err.code(DiagnosticId::Lint(name));\n \n-    // Check for future incompatibility lints and issue a stronger warning.\n-    let lints = sess.lint_store.borrow();\n-    let lint_id = LintId::of(lint);\n-    let future_incompatible = lints.future_incompatible(lint_id);\n     if let Some(future_incompatible) = future_incompatible {\n         const STANDARD_MESSAGE: &str =\n             \"this was previously accepted by the compiler but is being phased out; \\\n@@ -723,22 +743,6 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         err.note(&citation);\n     }\n \n-    // If this code originates in a foreign macro, aka something that this crate\n-    // did not itself author, then it's likely that there's nothing this crate\n-    // can do about it. We probably want to skip the lint entirely.\n-    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n-        // Any suggestions made here are likely to be incorrect, so anything we\n-        // emit shouldn't be automatically fixed by rustfix.\n-        err.allow_suggestions(false);\n-\n-        // If this is a future incompatible lint it'll become a hard error, so\n-        // we have to emit *something*. Also allow lints to whitelist themselves\n-        // on a case-by-case basis for emission in a foreign macro.\n-        if future_incompatible.is_none() && !lint.report_in_external_macro {\n-            err.cancel()\n-        }\n-    }\n-\n     return err\n }\n \n@@ -868,23 +872,23 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n         ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n-        ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n+        ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             if expn_data.def_site.is_dummy() {\n-                // dummy span for the def_site means it's an external macro\n+                // Dummy span for the `def_site` means it's an external macro.\n                 return true;\n             }\n             match sess.source_map().span_to_snippet(expn_data.def_site) {\n                 Ok(code) => !code.starts_with(\"macro_rules\"),\n-                // no snippet = external macro or compiler-builtin expansion\n+                // No snippet means external macro or compiler-builtin expansion.\n                 Err(_) => true,\n             }\n         }\n         ExpnKind::Macro(..) => true, // definitely a plugin\n     }\n }\n \n-/// Returns whether `span` originates in a derive macro's expansion\n+/// Returns `true` if `span` originates in a derive-macro's expansion.\n pub fn in_derive_expansion(span: Span) -> bool {\n     if let ExpnKind::Macro(MacroKind::Derive, _) = span.ctxt().outer_expn_data().kind {\n         return true;"}, {"sha": "ba27d332e43f784d08084de10aa3843858fce99e", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 49, "deletions": 35, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -16,17 +16,17 @@ struct EntryContext<'a, 'tcx> {\n \n     map: &'a hir_map::Map<'tcx>,\n \n-    // The top-level function called 'main'\n+    /// The top-level function called `main`.\n     main_fn: Option<(HirId, Span)>,\n \n-    // The function that has attribute named 'main'\n+    /// The function that has attribute named `main`.\n     attr_main_fn: Option<(HirId, Span)>,\n \n-    // The function that has the attribute 'start' on it\n+    /// The function that has the attribute 'start' on it.\n     start_fn: Option<(HirId, Span)>,\n \n-    // The functions that one might think are 'main' but aren't, e.g.\n-    // main functions not defined at the top level. For diagnostics.\n+    /// The functions that one might think are `main` but aren't, e.g.\n+    /// main functions not defined at the top level. For diagnostics.\n     non_main_fns: Vec<(HirId, Span)> ,\n }\n \n@@ -39,11 +39,11 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, _trait_item: &'tcx TraitItem) {\n-        // entry fn is never a trait item\n+        // Entry fn is never a trait item.\n     }\n \n     fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n-        // entry fn is never an impl item\n+        // Entry fn is never a trait item.\n     }\n }\n \n@@ -54,7 +54,7 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n         *ty == config::CrateType::Executable\n     });\n     if !any_exe {\n-        // No need to find a main function\n+        // No need to find a main function.\n         return None;\n     }\n \n@@ -88,7 +88,7 @@ fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n                 EntryPointType::MainAttr\n             } else if item.ident.name == sym::main {\n                 if at_root {\n-                    // This is a top-level function so can be 'main'.\n+                    // This is a top-level function so can be `main`.\n                     EntryPointType::MainNamed\n                 } else {\n                     EntryPointType::OtherMain\n@@ -109,7 +109,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n                 ctxt.main_fn = Some((item.hir_id, item.span));\n             } else {\n                 span_err!(ctxt.session, item.span, E0136,\n-                          \"multiple 'main' functions\");\n+                          \"multiple `main` functions\");\n             }\n         },\n         EntryPointType::OtherMain => {\n@@ -130,7 +130,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n             if ctxt.start_fn.is_none() {\n                 ctxt.start_fn = Some((item.hir_id, item.span));\n             } else {\n-                struct_span_err!(ctxt.session, item.span, E0138, \"multiple 'start' functions\")\n+                struct_span_err!(ctxt.session, item.span, E0138, \"multiple `start` functions\")\n                     .span_label(ctxt.start_fn.unwrap().1, \"previous `start` function here\")\n                     .span_label(item.span, \"multiple `start` functions\")\n                     .emit();\n@@ -148,34 +148,48 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(De\n     } else if let Some((hir_id, _)) = visitor.main_fn {\n         Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n     } else {\n-        // No main function\n-        let mut err = struct_err!(tcx.sess, E0601,\n-            \"`main` function not found in crate `{}`\", tcx.crate_name(LOCAL_CRATE));\n-        if !visitor.non_main_fns.is_empty() {\n-            // There were some functions named 'main' though. Try to give the user a hint.\n-            err.note(\"the main function must be defined at the crate level \\\n-                      but you have one or more functions named 'main' that are not \\\n-                      defined at the crate level. Either move the definition or \\\n-                      attach the `#[main]` attribute to override this behavior.\");\n-            for &(_, span) in &visitor.non_main_fns {\n-                err.span_note(span, \"here is a function named 'main'\");\n-            }\n-            err.emit();\n-        } else {\n-            if let Some(ref filename) = tcx.sess.local_crate_source_file {\n-                err.note(&format!(\"consider adding a `main` function to `{}`\", filename.display()));\n-            }\n-            if tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\"If you don't know the basics of Rust, you can go look to the Rust Book \\\n-                          to get started: https://doc.rust-lang.org/book/\");\n-            }\n-            err.emit();\n-        }\n-\n+        no_main_err(tcx, visitor);\n         None\n     }\n }\n \n+fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) {\n+    // There is no main function.\n+    let mut err = struct_err!(tcx.sess, E0601,\n+        \"`main` function not found in crate `{}`\", tcx.crate_name(LOCAL_CRATE));\n+    let filename = &tcx.sess.local_crate_source_file;\n+    let note = if !visitor.non_main_fns.is_empty() {\n+        for &(_, span) in &visitor.non_main_fns {\n+            err.span_note(span, \"here is a function named `main`\");\n+        }\n+        err.note(\"you have one or more functions named `main` not defined at the crate level\");\n+        err.help(\"either move the `main` function definitions or attach the `#[main]` attribute \\\n+                  to one of them\");\n+        // There were some functions named `main` though. Try to give the user a hint.\n+        format!(\"the main function must be defined at the crate level{}\",\n+                 filename.as_ref().map(|f| format!(\" (in `{}`)\", f.display())).unwrap_or_default())\n+    } else if let Some(filename) = filename {\n+        format!(\"consider adding a `main` function to `{}`\", filename.display())\n+    } else {\n+        String::from(\"consider adding a `main` function at the crate level\")\n+    };\n+    let sp = tcx.hir().krate().span;\n+    // The file may be empty, which leads to the diagnostic machinery not emitting this\n+    // note. This is a relatively simple way to detect that case and emit a span-less\n+    // note instead.\n+    if let Ok(_) = tcx.sess.source_map().lookup_line(sp.lo()) {\n+        err.set_span(sp);\n+        err.span_label(sp, &note);\n+    } else {\n+        err.note(&note);\n+    }\n+    if tcx.sess.teach(&err.get_code().unwrap()) {\n+        err.note(\"If you don't know the basics of Rust, you can go look to the Rust Book \\\n+                  to get started: https://doc.rust-lang.org/book/\");\n+    }\n+    err.emit();\n+}\n+\n pub fn find_entry_point(tcx: TyCtxt<'_>) -> Option<(DefId, EntryFnType)> {\n     tcx.entry_fn(LOCAL_CRATE)\n }"}, {"sha": "de6dadabcbf5623f846f9ecc70f8b1a17e4a1a92", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -596,7 +596,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::StmtKind::Item(_) => {\n-                // we don't visit nested items in this visitor,\n+                // We don't visit nested items in this visitor,\n                 // only the fn body we were given.\n             }\n "}, {"sha": "c5d9a722ae18e09c5c9fdbebd9151f1a13295021", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -3,10 +3,8 @@\n //! Language items are items that represent concepts intrinsic to the language\n //! itself. Examples are:\n //!\n-//! * Traits that specify \"kinds\"; e.g., \"Sync\", \"Send\".\n-//!\n-//! * Traits that represent operators; e.g., \"Add\", \"Sub\", \"Index\".\n-//!\n+//! * Traits that specify \"kinds\"; e.g., `Sync`, `Send`.\n+//! * Traits that represent operators; e.g., `Add`, `Sub`, `Index`.\n //! * Functions called by the compiler itself.\n \n pub use self::LangItem::*;\n@@ -151,11 +149,11 @@ impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-        // at present, lang items are always items, not trait items\n+        // At present, lang items are always items, not trait items.\n     }\n \n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-        // at present, lang items are always items, not impl items\n+        // At present, lang items are always items, not impl items.\n     }\n }\n \n@@ -204,7 +202,7 @@ impl LanguageItemCollector<'tcx> {\n     }\n }\n \n-/// Extract the first `lang = \"$name\"` out of a list of attributes.\n+/// Extracts the first `lang = \"$name\"` out of a list of attributes.\n /// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n /// are also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n@@ -216,7 +214,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     }))\n }\n \n-/// Traverse and collect all the lang items in all crates.\n+/// Traverses and collects all the lang items in all crates.\n pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n     // Initialize the collector.\n     let mut collector = LanguageItemCollector::new(tcx);\n@@ -246,6 +244,7 @@ pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n \n language_item_table! {\n //  Variant name,                Name,                 Method name,             Target;\n+    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n     CharImplItem,                \"char\",               char_impl,               Target::Impl;\n     StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n     SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n@@ -367,7 +366,7 @@ language_item_table! {\n \n     MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n \n-    // Align offset for stride != 1, must not panic.\n+    // Align offset for stride != 1; must not panic.\n     AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n \n     TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n@@ -378,7 +377,7 @@ language_item_table! {\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n-    /// If not found, fatally abort compilation.\n+    /// If not found, fatally aborts compilation.\n     pub fn require_lang_item(&self, lang_item: LangItem, span: Option<Span>) -> DefId {\n         self.lang_items().require(lang_item).unwrap_or_else(|msg| {\n             if let Some(span) = span {"}, {"sha": "87470140e3148dd19dc04e409ee4f2bdbae6d013", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -6,29 +6,27 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n \n+use crate::hir;\n+use crate::hir::Node;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use crate::ich::{StableHashingContext, NodeIdHashingMode};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n-use crate::ty;\n+use crate::ty::{self, DefIdTree, TyCtxt};\n+use crate::ty::query::Providers;\n \n-use std::mem;\n-use std::fmt;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use rustc_macros::HashStable;\n use syntax::source_map;\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::ty::{DefIdTree, TyCtxt};\n-use crate::ty::query::Providers;\n \n-use crate::hir;\n-use crate::hir::Node;\n-use crate::hir::def_id::DefId;\n-use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use crate::hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n-use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use std::fmt;\n+use std::mem;\n \n-/// Scope represents a statically-describable scope that can be\n-/// used to bound the lifetime/region for values.\n+/// Represents a statically-describable scope that can be used to\n+/// bound the lifetime/region for values.\n ///\n /// `Node(node_id)`: Any AST node that has any scope at all has the\n /// `Node(node_id)` scope. Other variants represent special cases not\n@@ -225,25 +223,25 @@ pub struct ScopeTree {\n     /// have lifetime parameters free in this body.\n     root_parent: Option<hir::HirId>,\n \n-    /// `parent_map` maps from a scope ID to the enclosing scope id;\n+    /// Maps from a scope ID to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope ID for the block associated with a closure is\n     /// the closure itself.)\n     parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n \n-    /// `var_map` maps from a variable or binding ID to the block in\n-    /// which that variable is declared.\n+    /// Maps from a variable or binding ID to the block in which that\n+    /// variable is declared.\n     var_map: FxHashMap<hir::ItemLocalId, Scope>,\n \n-    /// maps from a `NodeId` to the associated destruction scope (if any)\n+    /// Maps from a `NodeId` to the associated destruction scope (if any).\n     destruction_scopes: FxHashMap<hir::ItemLocalId, Scope>,\n \n-    /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n-    /// larger than the default. The map goes from the expression id\n-    /// to the cleanup scope id. For rvalues not present in this\n-    /// table, the appropriate cleanup scope is the innermost\n+    /// `rvalue_scopes` includes entries for those expressions whose\n+    /// cleanup scope is larger than the default. The map goes from the\n+    /// expression ID to the cleanup scope id. For rvalues not present in\n+    /// this table, the appropriate cleanup scope is the innermost\n     /// enclosing statement, conditional expression, or repeating\n     /// block (see `terminating_scopes`).\n     /// In constants, None is used to indicate that certain expressions\n@@ -318,7 +316,7 @@ pub struct ScopeTree {\n     ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n     ///     QED.\n     ///\n-    /// I don't think this property relies on `3.` in an essential way - it\n+    /// This property ought to not on (3) in an essential way -- it\n     /// is probably still correct even if we have \"unrestricted\" terminating\n     /// scopes. However, why use the complicated proof when a simple one\n     /// works?\n@@ -341,20 +339,20 @@ pub struct ScopeTree {\n \n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct YieldData {\n-    /// `Span` of the yield.\n+    /// The `Span` of the yield.\n     pub span: Span,\n-    /// The number of expressions and patterns appearing before the `yield` in the body + 1.\n+    /// The number of expressions and patterns appearing before the `yield` in the body plus one.\n     pub expr_and_pat_count: usize,\n     pub source: hir::YieldSource,\n }\n \n #[derive(Debug, Copy, Clone)]\n pub struct Context {\n-    /// the root of the current region tree. This is typically the id\n+    /// The root of the current region tree. This is typically the id\n     /// of the innermost fn body. Each fn forms its own disjoint tree\n     /// in the region hierarchy. These fn bodies are themselves\n     /// arranged into a tree. See the \"Modeling closures\" section of\n-    /// the README in infer::region_constraints for more\n+    /// the README in `infer::region_constraints` for more\n     /// details.\n     root_id: Option<hir::ItemLocalId>,\n \n@@ -369,15 +367,15 @@ pub struct Context {\n struct RegionResolutionVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    // The number of expressions and patterns visited in the current body\n+    // The number of expressions and patterns visited in the current body.\n     expr_and_pat_count: usize,\n     // When this is `true`, we record the `Scopes` we encounter\n     // when processing a Yield expression. This allows us to fix\n     // up their indices.\n     pessimistic_yield: bool,\n-    // Stores scopes when pessimistic_yield is true.\n+    // Stores scopes when `pessimistic_yield` is `true`.\n     fixup_scopes: Vec<Scope>,\n-    // Generated scope tree:\n+    // The generated scope tree.\n     scope_tree: ScopeTree,\n \n     cx: Context,\n@@ -411,7 +409,7 @@ struct ExprLocatorVisitor {\n     expr_and_pat_count: usize,\n }\n \n-// This visitor has to have the same visit_expr calls as RegionResolutionVisitor\n+// This visitor has to have the same `visit_expr` calls as `RegionResolutionVisitor`\n // since `expr_count` is compared against the results there.\n impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n@@ -456,7 +454,7 @@ impl<'tcx> ScopeTree {\n             assert!(prev.is_none());\n         }\n \n-        // record the destruction scopes for later so we can query them\n+        // Record the destruction scopes for later so we can query them.\n         if let ScopeData::Destruction = child.data {\n             self.destruction_scopes.insert(child.item_local_id(), child);\n         }\n@@ -478,7 +476,7 @@ impl<'tcx> ScopeTree {\n         self.destruction_scopes.get(&n).cloned()\n     }\n \n-    /// Records that `sub_closure` is defined within `sup_closure`. These ids\n+    /// Records that `sub_closure` is defined within `sup_closure`. These IDs\n     /// should be the ID of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n     fn record_closure_parent(&mut self,\n@@ -505,14 +503,14 @@ impl<'tcx> ScopeTree {\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n \n+    /// Returns the narrowest scope that encloses `id`, if any.\n     pub fn opt_encl_scope(&self, id: Scope) -> Option<Scope> {\n-        //! Returns the narrowest scope that encloses `id`, if any.\n         self.parent_map.get(&id).cloned().map(|(p, _)| p)\n     }\n \n+    /// Returns the narrowest scope that encloses `id`, if any.\n     #[allow(dead_code)] // used in cfg\n     pub fn encl_scope(&self, id: Scope) -> Scope {\n-        //! Returns the narrowest scope that encloses `id`, if any.\n         self.opt_encl_scope(id).unwrap()\n     }\n \n@@ -522,16 +520,15 @@ impl<'tcx> ScopeTree {\n             bug!(\"no enclosing scope for id {:?}\", var_id))\n     }\n \n+    /// Returns the scope when the temp created by `expr_id` will be cleaned up.\n     pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<Scope> {\n-        //! Returns the scope when temp created by expr_id will be cleaned up\n-\n-        // check for a designated rvalue scope\n+        // Check for a designated rvalue scope.\n         if let Some(&s) = self.rvalue_scopes.get(&expr_id) {\n             debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n             return s;\n         }\n \n-        // else, locate the innermost terminating scope\n+        // Otherwise, locate the innermost terminating scope\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n@@ -552,9 +549,8 @@ impl<'tcx> ScopeTree {\n         return None;\n     }\n \n+    /// Returns the lifetime of the variable `id`.\n     pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n-        //! Returns the lifetime of the variable `id`.\n-\n         let scope = ty::ReScope(self.var_scope(id));\n         debug!(\"var_region({:?}) = {:?}\", id, scope);\n         scope\n@@ -589,7 +585,7 @@ impl<'tcx> ScopeTree {\n         return true;\n     }\n \n-    /// Returns the ID of the innermost containing body\n+    /// Returns the ID of the innermost containing body.\n     pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n         loop {\n             if let ScopeData::CallSite = scope.data {\n@@ -1140,7 +1136,7 @@ fn resolve_local<'tcx>(\n     // Rule A. `let (ref x, ref y) = (foo().x, 44)`. The rvalue `(22, 44)`\n     // would have an extended lifetime, but not `foo()`.\n     //\n-    // Rule B. `let x = &foo().x`. The rvalue ``foo()` would have extended\n+    // Rule B. `let x = &foo().x`. The rvalue `foo()` would have extended\n     // lifetime.\n     //\n     // In some cases, multiple rules may apply (though not to the same"}, {"sha": "c06a0feb6a99381f6f8d870e992b80c610832cec", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -438,6 +438,7 @@ impl<'tcx> Index<'tcx> {\n                     level: attr::StabilityLevel::Unstable {\n                         reason: Some(Symbol::intern(reason)),\n                         issue: 27812,\n+                        is_soft: false,\n                     },\n                     feature: sym::rustc_private,\n                     rustc_depr: None,\n@@ -480,7 +481,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n pub fn report_unstable(\n-    sess: &Session, feature: Symbol, reason: Option<Symbol>, issue: u32, span: Span\n+    sess: &Session, feature: Symbol, reason: Option<Symbol>, issue: u32, is_soft: bool, span: Span\n ) {\n     let msg = match reason {\n         Some(r) => format!(\"use of unstable library feature '{}': {}\", feature, r),\n@@ -505,7 +506,13 @@ pub fn report_unstable(\n     let error_id = (DiagnosticMessageId::StabilityId(issue), span_key, msg.clone());\n     let fresh = sess.one_time_diagnostics.borrow_mut().insert(error_id);\n     if fresh {\n-        emit_feature_err(&sess.parse_sess, feature, span, GateIssue::Library(Some(issue)), &msg);\n+        if is_soft {\n+            sess.buffer_lint(lint::builtin::SOFT_UNSTABLE, CRATE_NODE_ID, span, &msg);\n+        } else {\n+            emit_feature_err(\n+                &sess.parse_sess, feature, span, GateIssue::Library(Some(issue)), &msg\n+            );\n+        }\n     }\n }\n \n@@ -621,6 +628,7 @@ pub enum EvalResult {\n         feature: Symbol,\n         reason: Option<Symbol>,\n         issue: u32,\n+        is_soft: bool,\n     },\n     /// The item does not have the `#[stable]` or `#[unstable]` marker assigned.\n     Unmarked,\n@@ -720,7 +728,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n \n         match stability {\n-            Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n+            Some(&Stability {\n+                level: attr::Unstable { reason, issue, is_soft }, feature, ..\n+            }) => {\n                 if span.allows_unstable(feature) {\n                     debug!(\"stability: skipping span={:?} since it is internal\", span);\n                     return EvalResult::Allow;\n@@ -744,7 +754,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n \n-                EvalResult::Deny { feature, reason, issue }\n+                EvalResult::Deny { feature, reason, issue, is_soft }\n             }\n             Some(_) => {\n                 // Stable APIs are always ok to call and deprecated APIs are\n@@ -767,8 +777,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n         match self.eval_stability(def_id, id, span) {\n             EvalResult::Allow => {}\n-            EvalResult::Deny { feature, reason, issue } =>\n-                report_unstable(self.sess, feature, reason, issue, span),\n+            EvalResult::Deny { feature, reason, issue, is_soft } =>\n+                report_unstable(self.sess, feature, reason, issue, is_soft, span),\n             EvalResult::Unmarked => {\n                 // The API could be uncallable for other reasons, for example when a private module\n                 // was referenced."}, {"sha": "fa5fa2257dbc8ce9940f1ec6181b86e8afba253b", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -116,8 +116,8 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn register(&mut self, name: &str, span: Span) {\n-        $(if name == stringify!($name) {\n+    fn register(&mut self, name: Symbol, span: Span) {\n+        $(if name == sym::$name {\n             if self.items.$name().is_none() {\n                 self.items.missing.push(lang_items::$item);\n             }\n@@ -136,7 +136,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         if let Some((lang_item, _)) = lang_items::extract(&i.attrs) {\n-            self.register(&lang_item.as_str(), i.span);\n+            self.register(lang_item, i.span);\n         }\n         intravisit::walk_foreign_item(self, i)\n     }"}, {"sha": "1f604877841a730e117322eb4bced048ded902d1", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -27,7 +27,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a>,\n                                           _: &mut StableHasher<W>) {\n-        // do nothing\n+        // Do nothing.\n     }\n }\n "}, {"sha": "15e6cb6bcabaeab755d8bb9a413647675a87b634", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 87, "deletions": 59, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -4,16 +4,17 @@ use super::{\n     Pointer, InterpResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n };\n \n+use crate::mir;\n use crate::ty::layout::{Size, Align};\n+\n+use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_target::abi::HasDataLayout;\n use syntax::ast::Mutability;\n use std::iter;\n-use crate::mir;\n use std::ops::{Range, Deref, DerefMut};\n-use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_target::abi::HasDataLayout;\n use std::borrow::Cow;\n \n-// NOTE: When adding new fields, make sure to adjust the Snapshot impl in\n+// NOTE: When adding new fields, make sure to adjust the `Snapshot` impl in\n // `src/librustc_mir/interpret/snapshot.rs`.\n #[derive(\n     Clone,\n@@ -27,7 +28,7 @@ use std::borrow::Cow;\n     RustcDecodable,\n     HashStable,\n )]\n-pub struct Allocation<Tag=(),Extra=()> {\n+pub struct Allocation<Tag = (),Extra = ()> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer.\n     bytes: Vec<u8>,\n@@ -42,15 +43,14 @@ pub struct Allocation<Tag=(),Extra=()> {\n     pub size: Size,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n-    /// Whether the allocation is mutable.\n+    /// `true` if the allocation is mutable.\n     /// Also used by codegen to determine if a static should be put into mutable memory,\n     /// which happens for `static mut` and `static` with interior mutability.\n     pub mutability: Mutability,\n     /// Extra state for the machine.\n     pub extra: Extra,\n }\n \n-\n pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n     // There is no constructor in here because the constructor's type depends\n     // on `MemoryKind`, and making things sufficiently generic leads to painful\n@@ -92,7 +92,7 @@ pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n     }\n }\n \n-// For Tag=() and no extra state, we have is a trivial implementation.\n+// For `Tag = ()` and no extra state, we have a trivial implementation.\n impl AllocationExtra<()> for () { }\n \n // The constructors are all without extra; the extra gets added by a machine hook later.\n@@ -130,6 +130,34 @@ impl<Tag> Allocation<Tag> {\n     }\n }\n \n+impl Allocation<(), ()> {\n+    /// Add Tag and Extra fields\n+    pub fn with_tags_and_extra<T, E>(\n+        self,\n+        mut tagger: impl FnMut(AllocId) -> T,\n+        extra: E,\n+    ) -> Allocation<T, E> {\n+        Allocation {\n+            bytes: self.bytes,\n+            size: self.size,\n+            relocations: Relocations::from_presorted(\n+                self.relocations.iter()\n+                    // The allocations in the relocations (pointers stored *inside* this allocation)\n+                    // all get the base pointer tag.\n+                    .map(|&(offset, ((), alloc))| {\n+                        let tag = tagger(alloc);\n+                        (offset, (tag, alloc))\n+                    })\n+                    .collect()\n+            ),\n+            undef_mask: self.undef_mask,\n+            align: self.align,\n+            mutability: self.mutability,\n+            extra,\n+        }\n+    }\n+}\n+\n /// Raw accessors. Provide access to otherwise private bytes.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     pub fn len(&self) -> usize {\n@@ -157,7 +185,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n \n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n-/// Byte accessors\n+/// Byte accessors.\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Just a small local helper function to avoid a bit of code repetition.\n     /// Returns the range of this allocation that was meant.\n@@ -167,7 +195,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         offset: Size,\n         size: Size\n     ) -> Range<usize> {\n-        let end = offset + size; // this does overflow checking\n+        let end = offset + size; // This does overflow checking.\n         assert_eq!(\n             end.bytes() as usize as u64, end.bytes(),\n             \"cannot handle this access on this host architecture\"\n@@ -204,7 +232,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             self.check_defined(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n         } else {\n-            // We still don't want relocations on the *edges*\n+            // We still don't want relocations on the *edges*.\n             self.check_relocation_edges(cx, ptr, size)?;\n         }\n \n@@ -213,7 +241,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(&self.bytes[range])\n     }\n \n-    /// Check that these bytes are initialized and not pointer bytes, and then return them\n+    /// Checks that these bytes are initialized and not pointer bytes, and then return them\n     /// as a slice.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n@@ -265,7 +293,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Reading and writing\n+/// Reading and writing.\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n     /// before a `0` is found.\n@@ -301,9 +329,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         allow_ptr_and_undef: bool,\n     ) -> InterpResult<'tcx>\n     {\n-        // Check bounds and relocations on the edges\n+        // Check bounds and relocations on the edges.\n         self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n-        // Check undef and ptr\n+        // Check undef and ptr.\n         if !allow_ptr_and_undef {\n             self.check_defined(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n@@ -344,12 +372,12 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Read a *non-ZST* scalar\n+    /// Reads a *non-ZST* scalar.\n     ///\n-    /// zsts can't be read out of two reasons:\n-    /// * byteorder cannot work with zero element buffers\n-    /// * in order to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n-    ///   being valid for ZSTs\n+    /// ZSTs can't be read for two reasons:\n+    /// * byte-order cannot work with zero-element buffers;\n+    /// * in order to obtain a `Pointer`, we need to check for ZSTness anyway due to integer\n+    ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn read_scalar(\n@@ -359,20 +387,20 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size\n     ) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>>\n     {\n-        // get_bytes_unchecked tests relocation edges\n+        // `get_bytes_unchecked` tests relocation edges.\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Undef check happens *after* we established that the alignment is correct.\n-        // We must not return Ok() for unaligned pointers!\n+        // We must not return `Ok()` for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n-            // this inflates undefined bytes to the entire scalar, even if only a few\n-            // bytes are undefined\n+            // This inflates undefined bytes to the entire scalar, even if only a few\n+            // bytes are undefined.\n             return Ok(ScalarMaybeUndef::Undef);\n         }\n-        // Now we do the actual reading\n+        // Now we do the actual reading.\n         let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n-        // See if we got a pointer\n+        // See if we got a pointer.\n         if size != cx.data_layout().pointer_size {\n-            // *Now* better make sure that the inside also is free of relocations.\n+            // *Now*, we better make sure that the inside is free of relocations too.\n             self.check_relocations(cx, ptr, size)?;\n         } else {\n             match self.relocations.get(&ptr.offset) {\n@@ -387,7 +415,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n     }\n \n-    /// Read a pointer-sized scalar.\n+    /// Reads a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn read_ptr_sized(\n@@ -399,12 +427,12 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n     }\n \n-    /// Write a *non-ZST* scalar\n+    /// Writes a *non-ZST* scalar.\n     ///\n-    /// zsts can't be read out of two reasons:\n-    /// * byteorder cannot work with zero element buffers\n-    /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n-    ///   being valid for ZSTs\n+    /// ZSTs can't be read for two reasons:\n+    /// * byte-order cannot work with zero-element buffers;\n+    /// * in order to obtain a `Pointer`, we need to check for ZSTness anyway due to integer\n+    ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn write_scalar(\n@@ -432,7 +460,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let dst = self.get_bytes_mut(cx, ptr, type_size)?;\n         write_target_uint(endian, dst, bytes).unwrap();\n \n-        // See if we have to also write a relocation\n+        // See if we have to also write a relocation.\n         match val {\n             Scalar::Ptr(val) => {\n                 self.relocations.insert(\n@@ -446,7 +474,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Write a pointer-sized scalar.\n+    /// Writes a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn write_ptr_sized(\n@@ -461,9 +489,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Relocations\n+/// Relocations.\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n-    /// Returns all relocations overlapping with the given ptr-offset pair.\n+    /// Returns all relocations overlapping with the given pointer-offset pair.\n     pub fn get_relocations(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -473,7 +501,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = ptr.offset.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n-        let end = ptr.offset + size; // this does overflow checking\n+        let end = ptr.offset + size; // This does overflow checking.\n         self.relocations.range(Size::from_bytes(start)..end)\n     }\n \n@@ -533,7 +561,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Error if there are relocations overlapping with the edges of the\n+    /// Errors if there are relocations overlapping with the edges of the\n     /// given memory range.\n     #[inline]\n     fn check_relocation_edges(\n@@ -549,7 +577,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n }\n \n \n-/// Undefined bytes\n+/// Undefined bytes.\n impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n     /// error which will report the first byte which is undefined.\n@@ -590,7 +618,7 @@ pub struct AllocationDefinedness {\n \n /// Transferring the definedness mask to other allocations.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n-    /// Creates a run-length encoding of the undef_mask.\n+    /// Creates a run-length encoding of the undef mask.\n     pub fn compress_undef_range(\n         &self,\n         src: Pointer<Tag>,\n@@ -603,18 +631,18 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         // Therefor we precompute a compressed version of the undef mask of the source value and\n         // then write it back `repeat` times without computing any more information from the source.\n \n-        // a precomputed cache for ranges of defined/undefined bits\n+        // A precomputed cache for ranges of defined/undefined bits\n         // 0000010010001110 will become\n-        // [5, 1, 2, 1, 3, 3, 1]\n-        // where each element toggles the state\n+        // `[5, 1, 2, 1, 3, 3, 1]`,\n+        // where each element toggles the state.\n \n         let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n         let initial = self.undef_mask.get(src.offset);\n         let mut cur_len = 1;\n         let mut cur = initial;\n \n         for i in 1..size.bytes() {\n-            // FIXME: optimize to bitshift the current undef block's bits and read the top bit\n+            // FIXME: optimize to bitshift the current undef block's bits and read the top bit.\n             if self.undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n                 cur_len += 1;\n             } else {\n@@ -629,15 +657,15 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         AllocationDefinedness { ranges, initial, }\n     }\n \n-    /// Apply multiple instances of the run-length encoding to the undef_mask.\n+    /// Applies multiple instances of the run-length encoding to the undef mask.\n     pub fn mark_compressed_undef_range(\n         &mut self,\n         defined: &AllocationDefinedness,\n         dest: Pointer<Tag>,\n         size: Size,\n         repeat: u64,\n     ) {\n-        // an optimization where we can just overwrite an entire range of definedness bits if\n+        // An optimization where we can just overwrite an entire range of definedness bits if\n         // they are going to be uniformly `1` or `0`.\n         if defined.ranges.len() <= 1 {\n             self.undef_mask.set_range_inbounds(\n@@ -666,9 +694,9 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Relocations\n+/// Relocations.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);\n+pub struct Relocations<Tag = (), Id = AllocId>(SortedMap<Size, (Tag, Id)>);\n \n impl<Tag, Id> Relocations<Tag, Id> {\n     pub fn new() -> Self {\n@@ -738,7 +766,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         }\n     }\n \n-    /// Apply a relocation copy.\n+    /// Applies a relocation copy.\n     /// The affected range, as defined in the parameters to `prepare_relocation_copy` is expected\n     /// to be clear of relocations.\n     pub fn mark_relocation_range(\n@@ -810,8 +838,8 @@ impl UndefMask {\n         let (blocka, bita) = bit_index(start);\n         let (blockb, bitb) = bit_index(end);\n         if blocka == blockb {\n-            // first set all bits but the first `bita`\n-            // then unset the last `64 - bitb` bits\n+            // First set all bits except the first `bita`,\n+            // then unset the last `64 - bitb` bits.\n             let range = if bitb == 0 {\n                 u64::max_value() << bita\n             } else {\n@@ -826,24 +854,24 @@ impl UndefMask {\n         }\n         // across block boundaries\n         if new_state {\n-            // set bita..64 to 1\n+            // Set `bita..64` to `1`.\n             self.blocks[blocka] |= u64::max_value() << bita;\n-            // set 0..bitb to 1\n+            // Set `0..bitb` to `1`.\n             if bitb != 0 {\n                 self.blocks[blockb] |= u64::max_value() >> (64 - bitb);\n             }\n-            // fill in all the other blocks (much faster than one bit at a time)\n+            // Fill in all the other blocks (much faster than one bit at a time).\n             for block in (blocka + 1) .. blockb {\n                 self.blocks[block] = u64::max_value();\n             }\n         } else {\n-            // set bita..64 to 0\n+            // Set `bita..64` to `0`.\n             self.blocks[blocka] &= !(u64::max_value() << bita);\n-            // set 0..bitb to 0\n+            // Set `0..bitb` to `0`.\n             if bitb != 0 {\n                 self.blocks[blockb] &= !(u64::max_value() >> (64 - bitb));\n             }\n-            // fill in all the other blocks (much faster than one bit at a time)\n+            // Fill in all the other blocks (much faster than one bit at a time).\n             for block in (blocka + 1) .. blockb {\n                 self.blocks[block] = 0;\n             }\n@@ -880,7 +908,7 @@ impl UndefMask {\n             let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n             assert_eq!(additional_blocks as usize as u64, additional_blocks);\n             self.blocks.extend(\n-                // FIXME(oli-obk): optimize this by repeating `new_state as Block`\n+                // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n                 iter::repeat(0).take(additional_blocks as usize),\n             );\n         }"}, {"sha": "ac99ccd45eafe4e8b0c578a5d1c63d174e0bc3cf", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,23 +1,21 @@\n-use std::{fmt, env};\n+use super::{RawConst, Pointer, CheckInAllocMsg, ScalarMaybeUndef};\n \n use crate::hir;\n use crate::hir::map::definitions::DefPathData;\n use crate::mir;\n use crate::ty::{self, Ty, layout};\n use crate::ty::layout::{Size, Align, LayoutError};\n-use rustc_target::spec::abi::Abi;\n-use rustc_macros::HashStable;\n-\n-use super::{RawConst, Pointer, CheckInAllocMsg, ScalarMaybeUndef};\n+use crate::ty::query::TyCtxtAt;\n \n use backtrace::Backtrace;\n-\n-use crate::ty::query::TyCtxtAt;\n use errors::DiagnosticBuilder;\n-\n+use rustc_macros::HashStable;\n+use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n use syntax::symbol::Symbol;\n \n+use std::{fmt, env};\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n pub enum ErrorHandled {\n     /// Already reported a lint or an error for this evaluation.\n@@ -215,6 +213,15 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n     eprintln!(\"\\n\\nAn error occurred in miri:\\n{:?}\", backtrace);\n }\n \n+impl From<ErrorHandled> for InterpErrorInfo<'tcx> {\n+    fn from(err: ErrorHandled) -> Self {\n+        match err {\n+            ErrorHandled::Reported => err_inval!(ReferencedConstant),\n+            ErrorHandled::TooGeneric => err_inval!(TooGeneric),\n+        }.into()\n+    }\n+}\n+\n impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     fn from(kind: InterpError<'tcx>) -> Self {\n         let backtrace = match env::var(\"RUSTC_CTFE_BACKTRACE\") {\n@@ -315,6 +322,9 @@ impl<O: fmt::Debug> fmt::Debug for PanicInfo<O> {\n     }\n }\n \n+/// Error information for when the program we executed turned out not to actually be a valid\n+/// program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp\n+/// where we work on generic code or execution does not have all information available.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InvalidProgramInfo<'tcx> {\n     /// Resolution can fail if we are in a too generic context.\n@@ -344,6 +354,7 @@ impl fmt::Debug for InvalidProgramInfo<'tcx> {\n     }\n }\n \n+/// Error information for when the program caused Undefined Behavior.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UndefinedBehaviorInfo {\n     /// Free-form case. Only for errors that are never caught!\n@@ -366,12 +377,19 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n     }\n }\n \n+/// Error information for when the program did something that might (or might not) be correct\n+/// to do according to the Rust spec, but due to limitations in the interpreter, the\n+/// operation could not be carried out. These limitations can differ between CTFE and the\n+/// Miri engine, e.g., CTFE does not support casting pointers to \"real\" integers.\n+///\n+/// Currently, we also use this as fall-back error kind for errors that have not been\n+/// categorized yet.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsupportedOpInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n \n-    // -- Everything below is not classified yet --\n+    // -- Everything below is not categorized yet --\n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n     FunctionRetMismatch(Ty<'tcx>, Ty<'tcx>),\n@@ -430,13 +448,13 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n         match self {\n             PointerOutOfBounds { ptr, msg, allocation_size } => {\n                 write!(f, \"{} failed: pointer must be in-bounds at offset {}, \\\n-                          but is outside bounds of allocation {} which has size {}\",\n+                           but is outside bounds of allocation {} which has size {}\",\n                     msg, ptr.offset.bytes(), ptr.alloc_id, allocation_size.bytes())\n             },\n             ValidationFailure(ref err) => {\n                 write!(f, \"type validation failed: {}\", err)\n             }\n-            NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n+            NoMirFor(ref func) => write!(f, \"no MIR for `{}`\", func),\n             FunctionAbiMismatch(caller_abi, callee_abi) =>\n                 write!(f, \"tried to call a function with ABI {:?} using caller ABI {:?}\",\n                     callee_abi, caller_abi),\n@@ -451,9 +469,9 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n             FunctionArgCountMismatch =>\n                 write!(f, \"tried to call a function with incorrect number of arguments\"),\n             ReallocatedWrongMemoryKind(ref old, ref new) =>\n-                write!(f, \"tried to reallocate memory from {} to {}\", old, new),\n+                write!(f, \"tried to reallocate memory from `{}` to `{}`\", old, new),\n             DeallocatedWrongMemoryKind(ref old, ref new) =>\n-                write!(f, \"tried to deallocate {} memory but gave {} as the kind\", old, new),\n+                write!(f, \"tried to deallocate `{}` memory but gave `{}` as the kind\", old, new),\n             InvalidChar(c) =>\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n             AlignmentCheckFailed { required, has } =>\n@@ -462,7 +480,7 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n             TypeNotPrimitive(ty) =>\n                 write!(f, \"expected primitive type, got {}\", ty),\n             PathNotFound(ref path) =>\n-                write!(f, \"Cannot find path {:?}\", path),\n+                write!(f, \"cannot find path {:?}\", path),\n             IncorrectAllocationInformation(size, size2, align, align2) =>\n                 write!(f, \"incorrect alloc info: expected size {} and align {}, \\\n                            got size {} and align {}\",\n@@ -525,7 +543,7 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n             InvalidBoolOp(_) =>\n                 write!(f, \"invalid boolean operation\"),\n             UnterminatedCString(_) =>\n-                write!(f, \"attempted to get length of a null terminated string, but no null \\\n+                write!(f, \"attempted to get length of a null-terminated string, but no null \\\n                     found before end of allocation\"),\n             ReadUndefBytes(_) =>\n                 write!(f, \"attempted to read undefined bytes\"),\n@@ -538,6 +556,8 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n     }\n }\n \n+/// Error information for when the program exhausted the resources granted to it\n+/// by the interpreter.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ResourceExhaustionInfo {\n     /// The stack grew too big.\n@@ -582,7 +602,7 @@ pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n \n impl fmt::Display for InterpError<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Forward `Display` to `Debug`\n+        // Forward `Display` to `Debug`.\n         write!(f, \"{:?}\", self)\n     }\n }"}, {"sha": "23433c2e8834d28dc65e8b162712e62451a96db6", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,4 +1,4 @@\n-//! An interpreter for MIR used in CTFE and by miri\n+//! An interpreter for MIR used in CTFE and by miri.\n \n #[macro_export]\n macro_rules! err_unsup {\n@@ -107,21 +107,21 @@ pub use self::allocation::{Allocation, AllocationExtra, Relocations, UndefMask};\n \n pub use self::pointer::{Pointer, PointerArithmetic, CheckInAllocMsg};\n \n-use std::fmt;\n use crate::mir;\n use crate::hir::def_id::DefId;\n use crate::ty::{self, TyCtxt, Instance, subst::UnpackedKind};\n+use crate::ty::codec::TyDecoder;\n use crate::ty::layout::{self, Size};\n use std::io;\n+use std::fmt;\n+use std::num::NonZeroU32;\n+use std::sync::atomic::{AtomicU32, Ordering};\n use rustc_serialize::{Encoder, Decodable, Encodable};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n+use rustc_data_structures::sync::{Lock, HashMapExt};\n use rustc_data_structures::tiny_list::TinyList;\n use rustc_macros::HashStable;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n-use crate::ty::codec::TyDecoder;\n-use std::sync::atomic::{AtomicU32, Ordering};\n-use std::num::NonZeroU32;\n \n /// Uniquely identifies a specific constant or static.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n@@ -152,8 +152,8 @@ pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    let alloc: GlobalAlloc<'tcx> =\n-        tcx.alloc_map.lock().get(alloc_id).expect(\"no value for AllocId\");\n+    let alloc: GlobalAlloc<'tcx> = tcx.alloc_map.lock().get(alloc_id)\n+        .expect(\"no value for given alloc ID\");\n     match alloc {\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n@@ -166,8 +166,8 @@ pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n             fn_instance.encode(encoder)?;\n         }\n         GlobalAlloc::Static(did) => {\n-            // referring to statics doesn't need to know about their allocations,\n-            // just about its DefId\n+            // References to statics doesn't need to know about their allocations,\n+            // just about its `DefId`.\n             AllocDiscriminant::Static.encode(encoder)?;\n             did.encode(encoder)?;\n         }\n@@ -187,19 +187,18 @@ enum State {\n }\n \n pub struct AllocDecodingState {\n-    // For each AllocId we keep track of which decoding state it's currently in.\n-    decoding_state: Vec<Mutex<State>>,\n+    // For each `AllocId`, we keep track of which decoding state it's currently in.\n+    decoding_state: Vec<Lock<State>>,\n     // The offsets of each allocation in the data stream.\n     data_offsets: Vec<u32>,\n }\n \n impl AllocDecodingState {\n-\n     pub fn new_decoding_session(&self) -> AllocDecodingSession<'_> {\n         static DECODER_SESSION_ID: AtomicU32 = AtomicU32::new(0);\n         let counter = DECODER_SESSION_ID.fetch_add(1, Ordering::SeqCst);\n \n-        // Make sure this is never zero\n+        // Make sure this is never zero.\n         let session_id = DecodingSessionId::new((counter & 0x7FFFFFFF) + 1).unwrap();\n \n         AllocDecodingSession {\n@@ -208,10 +207,10 @@ impl AllocDecodingState {\n         }\n     }\n \n-    pub fn new(data_offsets: Vec<u32>) -> AllocDecodingState {\n-        let decoding_state = vec![Mutex::new(State::Empty); data_offsets.len()];\n+    pub fn new(data_offsets: Vec<u32>) -> Self {\n+        let decoding_state = vec![Lock::new(State::Empty); data_offsets.len()];\n \n-        AllocDecodingState {\n+        Self {\n             decoding_state,\n             data_offsets,\n         }\n@@ -225,23 +224,23 @@ pub struct AllocDecodingSession<'s> {\n }\n \n impl<'s> AllocDecodingSession<'s> {\n-    // Decodes an AllocId in a thread-safe way.\n+    /// Decodes an `AllocId` in a thread-safe way.\n     pub fn decode_alloc_id<D>(&self, decoder: &mut D) -> Result<AllocId, D::Error>\n     where\n         D: TyDecoder<'tcx>,\n     {\n-        // Read the index of the allocation\n+        // Read the index of the allocation.\n         let idx = decoder.read_u32()? as usize;\n         let pos = self.state.data_offsets[idx] as usize;\n \n-        // Decode the AllocDiscriminant now so that we know if we have to reserve an\n-        // AllocId.\n+        // Decode the `AllocDiscriminant` now so that we know if we have to reserve an\n+        // `AllocId`.\n         let (alloc_kind, pos) = decoder.with_position(pos, |decoder| {\n             let alloc_kind = AllocDiscriminant::decode(decoder)?;\n             Ok((alloc_kind, decoder.position()))\n         })?;\n \n-        // Check the decoding state, see if it's already decoded or if we should\n+        // Check the decoding state to see if it's already decoded or if we should\n         // decode it here.\n         let alloc_id = {\n             let mut entry = self.state.decoding_state[idx].lock();\n@@ -251,20 +250,20 @@ impl<'s> AllocDecodingSession<'s> {\n                     return Ok(alloc_id);\n                 }\n                 ref mut entry @ State::Empty => {\n-                    // We are allowed to decode\n+                    // We are allowed to decode.\n                     match alloc_kind {\n                         AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n-                            // AllocId so we can decode cyclic graphs.\n+                            // `AllocId` so we can decode cyclic graphs.\n                             let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n                             *entry = State::InProgress(\n                                 TinyList::new_single(self.session_id),\n                                 alloc_id);\n                             Some(alloc_id)\n                         },\n                         AllocDiscriminant::Fn | AllocDiscriminant::Static => {\n-                            // Fns and statics cannot be cyclic and their AllocId\n-                            // is determined later by interning\n+                            // Fns and statics cannot be cyclic, and their `AllocId`\n+                            // is determined later by interning.\n                             *entry = State::InProgressNonAlloc(\n                                 TinyList::new_single(self.session_id));\n                             None\n@@ -273,9 +272,9 @@ impl<'s> AllocDecodingSession<'s> {\n                 }\n                 State::InProgressNonAlloc(ref mut sessions) => {\n                     if sessions.contains(&self.session_id) {\n-                        bug!(\"This should be unreachable\")\n+                        bug!(\"this should be unreachable\");\n                     } else {\n-                        // Start decoding concurrently\n+                        // Start decoding concurrently.\n                         sessions.insert(self.session_id);\n                         None\n                     }\n@@ -285,37 +284,38 @@ impl<'s> AllocDecodingSession<'s> {\n                         // Don't recurse.\n                         return Ok(alloc_id)\n                     } else {\n-                        // Start decoding concurrently\n+                        // Start decoding concurrently.\n                         sessions.insert(self.session_id);\n                         Some(alloc_id)\n                     }\n                 }\n             }\n         };\n \n-        // Now decode the actual data\n+        // Now decode the actual data.\n         let alloc_id = decoder.with_position(pos, |decoder| {\n             match alloc_kind {\n                 AllocDiscriminant::Alloc => {\n-                    let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n-                    // We already have a reserved AllocId.\n+                    let alloc = <&'tcx Allocation as Decodable>::decode(decoder)?;\n+                    // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n-                    trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n-                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, allocation);\n+                    trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n+                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, alloc);\n                     Ok(alloc_id)\n                 },\n                 AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n-                    trace!(\"creating fn alloc id\");\n+                    trace!(\"creating fn alloc ID\");\n                     let instance = ty::Instance::decode(decoder)?;\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n                     let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n                     Ok(alloc_id)\n                 },\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n-                    trace!(\"creating extern static alloc id at\");\n+                    trace!(\"creating extern static alloc ID\");\n                     let did = DefId::decode(decoder)?;\n+                    trace!(\"decoded static def-ID: {:?}\", did);\n                     let alloc_id = decoder.tcx().alloc_map.lock().create_static_alloc(did);\n                     Ok(alloc_id)\n                 }\n@@ -340,7 +340,7 @@ impl fmt::Display for AllocId {\n /// a static, or a \"real\" allocation with some data in it.\n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub enum GlobalAlloc<'tcx> {\n-    /// The alloc ID is used as a function pointer\n+    /// The alloc ID is used as a function pointer.\n     Function(Instance<'tcx>),\n     /// The alloc ID points to a \"lazy\" static variable that did not get computed (yet).\n     /// This is also used to break the cycle in recursive statics.\n@@ -350,16 +350,17 @@ pub enum GlobalAlloc<'tcx> {\n }\n \n pub struct AllocMap<'tcx> {\n-    /// Lets you know what an `AllocId` refers to.\n+    /// Maps `AllocId`s to their corresponding allocations.\n     alloc_map: FxHashMap<AllocId, GlobalAlloc<'tcx>>,\n \n     /// Used to ensure that statics and functions only get one associated `AllocId`.\n     /// Should never contain a `GlobalAlloc::Memory`!\n-    /// FIXME: Should we just have two separate dedup maps for statics and functions each?\n+    //\n+    // FIXME: Should we just have two separate dedup maps for statics and functions each?\n     dedup: FxHashMap<GlobalAlloc<'tcx>, AllocId>,\n \n     /// The `AllocId` to assign to the next requested ID.\n-    /// Always incremented, never gets smaller.\n+    /// Always incremented; never gets smaller.\n     next_id: AllocId,\n }\n \n@@ -389,7 +390,7 @@ impl<'tcx> AllocMap<'tcx> {\n         next\n     }\n \n-    /// Reserve a new ID *if* this allocation has not been dedup-reserved before.\n+    /// Reserves a new ID *if* this allocation has not been dedup-reserved before.\n     /// Should only be used for function pointers and statics, we don't want\n     /// to dedup IDs for \"real\" memory!\n     fn reserve_and_set_dedup(&mut self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n@@ -430,17 +431,17 @@ impl<'tcx> AllocMap<'tcx> {\n             }\n         });\n         if is_generic {\n-            // Get a fresh ID\n+            // Get a fresh ID.\n             let id = self.reserve();\n             self.alloc_map.insert(id, GlobalAlloc::Function(instance));\n             id\n         } else {\n-            // Deduplicate\n+            // Deduplicate.\n             self.reserve_and_set_dedup(GlobalAlloc::Function(instance))\n         }\n     }\n \n-    /// Intern the `Allocation` and return a new `AllocId`, even if there's already an identical\n+    /// Interns the `Allocation` and return a new `AllocId`, even if there's already an identical\n     /// `Allocation` with a different `AllocId`.\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,\n     /// their data will be deduplicated through `Allocation` interning -- but they\n@@ -465,19 +466,19 @@ impl<'tcx> AllocMap<'tcx> {\n     pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n         match self.get(id) {\n             Some(GlobalAlloc::Memory(mem)) => mem,\n-            _ => bug!(\"expected allocation id {} to point to memory\", id),\n+            _ => bug!(\"expected allocation ID {} to point to memory\", id),\n         }\n     }\n \n-    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n+    /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n         if let Some(old) = self.alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n-            bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n+            bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n-    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n+    /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n     fn set_alloc_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n         self.alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n@@ -513,7 +514,7 @@ pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result\n // Methods to facilitate working with signed integers stored in a u128\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Truncate `value` to `size` bits and then sign-extend it to 128 bits\n+/// Truncates `value` to `size` bits and then sign-extend it to 128 bits\n /// (i.e., if it is negative, fill with 1's on the left).\n #[inline]\n pub fn sign_extend(value: u128, size: Size) -> u128 {\n@@ -522,14 +523,14 @@ pub fn sign_extend(value: u128, size: Size) -> u128 {\n         // Truncated until nothing is left.\n         return 0;\n     }\n-    // sign extend\n+    // Sign-extend it.\n     let shift = 128 - size;\n-    // shift the unsigned value to the left\n-    // and back to the right as signed (essentially fills with FF on the left)\n+    // Shift the unsigned value to the left, then shift back to the right as signed\n+    // (essentially fills with FF on the left).\n     (((value << shift) as i128) >> shift) as u128\n }\n \n-/// Truncate `value` to `size` bits.\n+/// Truncates `value` to `size` bits.\n #[inline]\n pub fn truncate(value: u128, size: Size) -> u128 {\n     let size = size.bits();\n@@ -538,6 +539,6 @@ pub fn truncate(value: u128, size: Size) -> u128 {\n         return 0;\n     }\n     let shift = 128 - size;\n-    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+    // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n     (value << shift) >> shift\n }"}, {"sha": "1bb4d9ea4d6d92edddac3a6541ec36a84f930145", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -86,18 +86,17 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n \n impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n \n-\n-/// Pointer is generic over the type that represents a reference to Allocations,\n+/// `Pointer` is generic over the type that represents a reference to `Allocation`s,\n /// thus making it possible for the most convenient representation to be used in\n /// each context.\n ///\n-/// Defaults to the index based and loosely coupled AllocId.\n+/// Defaults to the index based and loosely coupled `AllocId`.\n ///\n /// Pointer is also generic over the `Tag` associated with each pointer,\n /// which is used to do provenance tracking during execution.\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n-pub struct Pointer<Tag=(),Id=AllocId> {\n+pub struct Pointer<Tag = (), Id = AllocId> {\n     pub alloc_id: Id,\n     pub offset: Size,\n     pub tag: Tag,\n@@ -117,7 +116,7 @@ impl<Id: fmt::Debug> fmt::Debug for Pointer<(), Id> {\n     }\n }\n \n-/// Produces a `Pointer` which points to the beginning of the Allocation\n+/// Produces a `Pointer` which points to the beginning of the `Allocation`.\n impl From<AllocId> for Pointer {\n     #[inline(always)]\n     fn from(alloc_id: AllocId) -> Self {"}, {"sha": "b8bc74141973882f992c236832f625986dfc7945", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -17,8 +17,8 @@ pub struct RawConst<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-/// Represents a constant value in Rust. `Scalar` and `ScalarPair` are optimizations that\n-/// match the `LocalState` optimizations for easy conversions between `Value` and `ConstValue`.\n+/// Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for\n+/// array length computations, enum discriminants and the pattern matching logic.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum ConstValue<'tcx> {\n@@ -91,7 +91,7 @@ impl<'tcx> ConstValue<'tcx> {\n /// of a simple value or a pointer into another `Allocation`\n #[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n-pub enum Scalar<Tag=(), Id=AllocId> {\n+pub enum Scalar<Tag = (), Id = AllocId> {\n     /// The raw bytes of a simple value.\n     Raw {\n         /// The first `size` bytes of `data` are the value.\n@@ -359,7 +359,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline(always)]\n     pub fn assert_bits(self, target_size: Size) -> u128 {\n-        self.to_bits(target_size).expect(\"Expected Raw bits but got a Pointer\")\n+        self.to_bits(target_size).expect(\"expected Raw bits but got a Pointer\")\n     }\n \n     /// Do not call this method!  Use either `assert_ptr` or `force_ptr`.\n@@ -374,7 +374,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline(always)]\n     pub fn assert_ptr(self) -> Pointer<Tag> {\n-        self.to_ptr().expect(\"Expected a Pointer but got Raw bits\")\n+        self.to_ptr().expect(\"expected a Pointer but got Raw bits\")\n     }\n \n     /// Do not call this method!  Dispatch based on the type instead.\n@@ -482,8 +482,8 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum ScalarMaybeUndef<Tag=(), Id=AllocId> {\n+#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash, RustcEncodable, RustcDecodable)]\n+pub enum ScalarMaybeUndef<Tag = (), Id = AllocId> {\n     Scalar(Scalar<Tag, Id>),\n     Undef,\n }"}, {"sha": "0ebc70750a6bba18aaffb2f1372e03ca7c723da0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 173, "deletions": 292, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -18,6 +18,7 @@ use crate::ty::{\n     self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n     UserTypeAnnotationIndex,\n };\n+\n use polonius_engine::Atom;\n use rustc_data_structures::bit_set::BitMatrix;\n use rustc_data_structures::fx::FxHashSet;\n@@ -31,7 +32,6 @@ use rustc_serialize::{Encodable, Decodable};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::iter::FusedIterator;\n use std::ops::{Index, IndexMut};\n use std::slice;\n use std::vec::IntoIter;\n@@ -70,7 +70,7 @@ impl<'tcx> HasLocalDecls<'tcx> for Body<'tcx> {\n \n /// The various \"big phases\" that MIR goes through.\n ///\n-/// Warning: ordering of variants is significant\n+/// Warning: ordering of variants is significant.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum MirPhase {\n     Build = 0,\n@@ -80,16 +80,16 @@ pub enum MirPhase {\n }\n \n impl MirPhase {\n-    /// Gets the index of the current MirPhase within the set of all MirPhases.\n+    /// Gets the index of the current MirPhase within the set of all `MirPhase`s.\n     pub fn phase_index(&self) -> usize {\n         *self as usize\n     }\n }\n \n-/// Lowered representation of a single function.\n+/// The lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Body<'tcx> {\n-    /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n+    /// A list of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n \n@@ -100,18 +100,18 @@ pub struct Body<'tcx> {\n     /// us to see the difference and forego optimization on the inlined promoted items.\n     pub phase: MirPhase,\n \n-    /// List of source scopes; these are referenced by statements\n+    /// A list of source scopes; these are referenced by statements\n     /// and used for debuginfo. Indexed by a `SourceScope`.\n     pub source_scopes: IndexVec<SourceScope, SourceScopeData>,\n \n     /// Crate-local information for each source scope, that can't (and\n     /// needn't) be tracked across crates.\n     pub source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n \n-    /// Yields type of the function, if it is a generator.\n+    /// The yield type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n \n-    /// Generator drop glue\n+    /// Generator drop glue.\n     pub generator_drop: Option<Box<Body<'tcx>>>,\n \n     /// The layout of a generator. Produced by the state transformation.\n@@ -124,10 +124,10 @@ pub struct Body<'tcx> {\n     /// variables and temporaries.\n     pub local_decls: LocalDecls<'tcx>,\n \n-    /// User type annotations\n+    /// User type annotations.\n     pub user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n \n-    /// Number of arguments this function takes.\n+    /// The number of arguments this function takes.\n     ///\n     /// Starting at local 1, `arg_count` locals will be provided by the caller\n     /// and can be assumed to be initialized.\n@@ -143,10 +143,11 @@ pub struct Body<'tcx> {\n \n     /// Names and capture modes of all the closure upvars, assuming\n     /// the first argument is either the closure or a reference to it.\n+    //\n     // NOTE(eddyb) This is *strictly* a temporary hack for codegen\n     // debuginfo generation, and will be removed at some point.\n-    // Do **NOT** use it for anything else, upvar information should not be\n-    // in the MIR, please rely on local crate HIR or other side-channels.\n+    // Do **NOT** use it for anything else; upvar information should not be\n+    // in the MIR, so please rely on local crate HIR or other side-channels.\n     pub __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n \n     /// Mark this MIR of a const context other than const functions as having converted a `&&` or\n@@ -157,10 +158,10 @@ pub struct Body<'tcx> {\n     /// List of places where control flow was destroyed. Used for error reporting.\n     pub control_flow_destroyed: Vec<(Span, String)>,\n \n-    /// A span representing this MIR, for error reporting\n+    /// A span representing this MIR, for error reporting.\n     pub span: Span,\n \n-    /// A cache for various calculations\n+    /// A cache for various calculations.\n     cache: cache::Cache,\n }\n \n@@ -177,7 +178,7 @@ impl<'tcx> Body<'tcx> {\n         span: Span,\n         control_flow_destroyed: Vec<(Span, String)>,\n     ) -> Self {\n-        // We need `arg_count` locals, and one for the return place\n+        // We need `arg_count` locals, and one for the return place.\n         assert!(\n             local_decls.len() >= arg_count + 1,\n             \"expected at least {} locals, got {}\",\n@@ -384,12 +385,12 @@ impl<'tcx> Body<'tcx> {\n         true\n     }\n \n-    /// Returns the return type, it always return first element from `local_decls` array\n+    /// Returns the return type; it always return first element from `local_decls` array.\n     pub fn return_ty(&self) -> Ty<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n     }\n \n-    /// Gets the location of the terminator for the given block\n+    /// Gets the location of the terminator for the given block.\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n         Location { block: bb, statement_index: self[bb].statements.len() }\n     }\n@@ -463,7 +464,7 @@ impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<\n /// Most passes can work with it as a whole, within a single function.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub struct SourceInfo {\n-    /// Source span for the AST pertaining to this MIR entity.\n+    /// The source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n \n     /// The source scope, keeping track of which bindings can be\n@@ -591,13 +592,13 @@ impl Atom for Local {\n /// Classifies locals into categories. See `Body::local_kind`.\n #[derive(PartialEq, Eq, Debug, HashStable)]\n pub enum LocalKind {\n-    /// User-declared variable binding\n+    /// User-declared variable binding.\n     Var,\n-    /// Compiler-introduced temporary\n+    /// Compiler-introduced temporary.\n     Temp,\n-    /// Function argument\n+    /// Function argument.\n     Arg,\n-    /// Location of function's return value\n+    /// Location of function's return value.\n     ReturnPointer,\n }\n \n@@ -619,7 +620,7 @@ pub struct VarBindingForm<'tcx> {\n     /// (b) it gives a way to separate this case from the remaining cases\n     ///     for diagnostics.\n     pub opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n-    /// Span of the pattern in which this variable was bound.\n+    /// The span of the pattern in which this variable was bound.\n     pub pat_span: Span,\n }\n \n@@ -721,12 +722,12 @@ impl_stable_hash_for!(struct BlockTailInfo { tail_result_is_ignored });\n /// argument, or the return place.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct LocalDecl<'tcx> {\n-    /// `let mut x` vs `let x`.\n+    /// Whether this is a mutable minding (i.e., `let x` or `let mut x`).\n     ///\n     /// Temporaries and the return place are always mutable.\n     pub mutability: Mutability,\n \n-    /// Some(binding_mode) if this corresponds to a user-declared local variable.\n+    /// `Some(binding_mode)` if this corresponds to a user-declared local variable.\n     ///\n     /// This is solely used for local diagnostics when generating\n     /// warnings/errors when compiling the current crate, and\n@@ -760,7 +761,7 @@ pub struct LocalDecl<'tcx> {\n     /// intervening statement context).\n     pub is_block_tail: Option<BlockTailInfo>,\n \n-    /// Type of this local.\n+    /// The type of this local.\n     pub ty: Ty<'tcx>,\n \n     /// If the user manually ascribed a type to this variable,\n@@ -769,7 +770,7 @@ pub struct LocalDecl<'tcx> {\n     /// region inference.\n     pub user_ty: UserTypeProjections,\n \n-    /// Name of the local, used in debuginfo and pretty-printing.\n+    /// The name of the local, used in debuginfo and pretty-printing.\n     ///\n     /// Note that function arguments can also have this set to `Some(_)`\n     /// to generate better debuginfo.\n@@ -837,8 +838,8 @@ pub struct LocalDecl<'tcx> {\n     /// ROOT SCOPE\n     ///  \u2502{ argument x: &str }\n     ///  \u2502\n-    ///  \u2502 \u2502{ #[allow(unused_mut)] } // this is actually split into 2 scopes\n-    ///  \u2502 \u2502                        // in practice because I'm lazy.\n+    ///  \u2502 \u2502{ #[allow(unused_mut)] } // This is actually split into 2 scopes\n+    ///  \u2502 \u2502                         // in practice because I'm lazy.\n     ///  \u2502 \u2502\n     ///  \u2502 \u2502\u2190 x.source_info.scope\n     ///  \u2502 \u2502\u2190 `x.parse().unwrap()`\n@@ -852,7 +853,7 @@ pub struct LocalDecl<'tcx> {\n     ///  \u2502\n     ///  \u2502 \u2502{ let x: u32 }\n     ///  \u2502 \u2502\u2190 x.visibility_scope\n-    ///  \u2502 \u2502\u2190 `drop(x)` // this accesses `x: u32`\n+    ///  \u2502 \u2502\u2190 `drop(x)` // This accesses `x: u32`.\n     /// ```\n     pub source_info: SourceInfo,\n \n@@ -1038,16 +1039,16 @@ pub struct Terminator<'tcx> {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum TerminatorKind<'tcx> {\n-    /// block should have one successor in the graph; we jump there\n+    /// Block should have one successor in the graph; we jump there.\n     Goto { target: BasicBlock },\n \n-    /// operand evaluates to an integer; jump depending on its value\n-    /// to one of the targets, and otherwise fallback to `otherwise`\n+    /// Operand evaluates to an integer; jump depending on its value\n+    /// to one of the targets, and otherwise fallback to `otherwise`.\n     SwitchInt {\n-        /// discriminant value being tested\n+        /// The discriminant value being tested.\n         discr: Operand<'tcx>,\n \n-        /// type of value being tested\n+        /// The type of value being tested.\n         switch_ty: Ty<'tcx>,\n \n         /// Possible values. The locations to branch to in each case\n@@ -1057,6 +1058,7 @@ pub enum TerminatorKind<'tcx> {\n         /// Possible branch sites. The last element of this vector is used\n         /// for the otherwise branch, so targets.len() == values.len() + 1\n         /// should hold.\n+        //\n         // This invariant is quite non-obvious and also could be improved.\n         // One way to make this invariant is to have something like this instead:\n         //\n@@ -1069,7 +1071,7 @@ pub enum TerminatorKind<'tcx> {\n     },\n \n     /// Indicates that the landing pad is finished and unwinding should\n-    /// continue. Emitted by build::scope::diverge_cleanup.\n+    /// continue. Emitted by `build::scope::diverge_cleanup`.\n     Resume,\n \n     /// Indicates that the landing pad is finished and that the process\n@@ -1083,10 +1085,10 @@ pub enum TerminatorKind<'tcx> {\n     /// Indicates a terminator that can never be reached.\n     Unreachable,\n \n-    /// Drop the Place\n+    /// Drop the `Place`.\n     Drop { location: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n-    /// Drop the Place and assign the new value over it. This ensures\n+    /// Drop the `Place` and assign the new value over it. This ensures\n     /// that the assignment to `P` occurs *even if* the destructor for\n     /// place unwinds. Its semantics are best explained by the\n     /// elaboration:\n@@ -1119,9 +1121,9 @@ pub enum TerminatorKind<'tcx> {\n         unwind: Option<BasicBlock>,\n     },\n \n-    /// Block ends with a call of a converging function\n+    /// Block ends with a call of a converging function.\n     Call {\n-        /// The function that\u2019s being called\n+        /// The function that\u2019s being called.\n         func: Operand<'tcx>,\n         /// Arguments the function is called with.\n         /// These are owned by the callee, which is free to modify them.\n@@ -1132,7 +1134,7 @@ pub enum TerminatorKind<'tcx> {\n         destination: Option<(Place<'tcx>, BasicBlock)>,\n         /// Cleanups to be done if the call unwinds.\n         cleanup: Option<BasicBlock>,\n-        /// Whether this is from a call in HIR, rather than from an overloaded\n+        /// `true` if this is from a call in HIR rather than from an overloaded\n         /// operator. True for overloaded function call.\n         from_hir_call: bool,\n     },\n@@ -1147,40 +1149,40 @@ pub enum TerminatorKind<'tcx> {\n         cleanup: Option<BasicBlock>,\n     },\n \n-    /// A suspend point\n+    /// A suspend point.\n     Yield {\n-        /// The value to return\n+        /// The value to return.\n         value: Operand<'tcx>,\n-        /// Where to resume to\n+        /// Where to resume to.\n         resume: BasicBlock,\n-        /// Cleanup to be done if the generator is dropped at this suspend point\n+        /// Cleanup to be done if the generator is dropped at this suspend point.\n         drop: Option<BasicBlock>,\n     },\n \n-    /// Indicates the end of the dropping of a generator\n+    /// Indicates the end of the dropping of a generator.\n     GeneratorDrop,\n \n     /// A block where control flow only ever takes one real path, but borrowck\n     /// needs to be more conservative.\n     FalseEdges {\n-        /// The target normal control flow will take\n+        /// The target normal control flow will take.\n         real_target: BasicBlock,\n         /// A block control flow could conceptually jump to, but won't in\n-        /// practice\n+        /// practice.\n         imaginary_target: BasicBlock,\n     },\n     /// A terminator for blocks that only take one path in reality, but where we\n     /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n     /// This can arise in infinite loops with no function calls for example.\n     FalseUnwind {\n-        /// The target normal control flow will take\n+        /// The target normal control flow will take.\n         real_target: BasicBlock,\n         /// The imaginary cleanup block link. This particular path will never be taken\n         /// in practice, but in order to avoid fragility we want to always\n         /// consider it in borrowck. We don't want to accept programs which\n-        /// pass borrowck only when panic=abort or some assertions are disabled\n-        /// due to release vs. debug mode builds. This needs to be an Option because\n-        /// of the remove_noop_landing_pads and no_landing_pads passes\n+        /// pass borrowck only when `panic=abort` or some assertions are disabled\n+        /// due to release vs. debug mode builds. This needs to be an `Option` because\n+        /// of the `remove_noop_landing_pads` and `no_landing_pads` passes.\n         unwind: Option<BasicBlock>,\n     },\n }\n@@ -1445,7 +1447,7 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n }\n \n impl<'tcx> TerminatorKind<'tcx> {\n-    /// Write the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n+    /// Writes the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n     /// successor basic block, if any. The only information not included is the list of possible\n     /// successors, which may be rendered differently between the text and the graphviz format.\n     pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n@@ -1545,7 +1547,7 @@ pub struct Statement<'tcx> {\n \n // `Statement` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Statement<'_>, 56);\n+static_assert_size!(Statement<'_>, 32);\n \n impl Statement<'_> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n@@ -1566,7 +1568,7 @@ impl Statement<'_> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n-    Assign(Place<'tcx>, Box<Rvalue<'tcx>>),\n+    Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n \n     /// This represents all the reading that a pattern match may do\n     /// (e.g., inspecting constants and discriminant values), and the\n@@ -1575,10 +1577,10 @@ pub enum StatementKind<'tcx> {\n     ///\n     /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n     /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n-    FakeRead(FakeReadCause, Place<'tcx>),\n+    FakeRead(FakeReadCause, Box<Place<'tcx>>),\n \n     /// Write the discriminant for a variant to the enum Place.\n-    SetDiscriminant { place: Place<'tcx>, variant_index: VariantIdx },\n+    SetDiscriminant { place: Box<Place<'tcx>>, variant_index: VariantIdx },\n \n     /// Start a live range for the storage of the local.\n     StorageLive(Local),\n@@ -1595,7 +1597,7 @@ pub enum StatementKind<'tcx> {\n     /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n     /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n     /// for more details.\n-    Retag(RetagKind, Place<'tcx>),\n+    Retag(RetagKind, Box<Place<'tcx>>),\n \n     /// Encodes a user's type ascription. These need to be preserved\n     /// intact so that NLL can respect them. For example:\n@@ -1609,26 +1611,26 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n-    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeProjection>),\n+    AscribeUserType(Box<(Place<'tcx>, UserTypeProjection)>, ty::Variance),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n }\n \n-/// `RetagKind` describes what kind of retag is to be performed.\n+/// Describes what kind of retag is to be performed.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, HashStable)]\n pub enum RetagKind {\n-    /// The initial retag when entering a function\n+    /// The initial retag when entering a function.\n     FnEntry,\n-    /// Retag preparing for a two-phase borrow\n+    /// Retag preparing for a two-phase borrow.\n     TwoPhase,\n-    /// Retagging raw pointers\n+    /// Retagging raw pointers.\n     Raw,\n-    /// A \"normal\" retag\n+    /// A \"normal\" retag.\n     Default,\n }\n \n-/// The `FakeReadCause` describes the type of pattern why a `FakeRead` statement exists.\n+/// The `FakeReadCause` describes the type of pattern why a FakeRead statement exists.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum FakeReadCause {\n     /// Inject a fake read of the borrowed input at the end of each guards\n@@ -1673,7 +1675,7 @@ impl Debug for Statement<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n-            Assign(ref place, ref rv) => write!(fmt, \"{:?} = {:?}\", place, rv),\n+            Assign(box(ref place, ref rv)) => write!(fmt, \"{:?} = {:?}\", place, rv),\n             FakeRead(ref cause, ref place) => write!(fmt, \"FakeRead({:?}, {:?})\", cause, place),\n             Retag(ref kind, ref place) => write!(\n                 fmt,\n@@ -1694,7 +1696,7 @@ impl Debug for Statement<'_> {\n             InlineAsm(ref asm) => {\n                 write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm.asm, asm.outputs, asm.inputs)\n             }\n-            AscribeUserType(ref place, ref variance, ref c_ty) => {\n+            AscribeUserType(box(ref place, ref c_ty), ref variance) => {\n                 write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }\n             Nop => write!(fmt, \"nop\"),\n@@ -1714,7 +1716,7 @@ pub struct Place<'tcx> {\n     pub base: PlaceBase<'tcx>,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n-    pub projection: Option<Box<Projection<'tcx>>>,\n+    pub projection: Box<[PlaceElem<'tcx>]>,\n }\n \n #[derive(\n@@ -1757,15 +1759,6 @@ impl_stable_hash_for!(struct Static<'tcx> {\n     def_id\n });\n \n-/// The `Projection` data structure defines things of the form `base.x`, `*b` or `b[index]`.\n-#[derive(\n-    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n-)]\n-pub struct Projection<'tcx> {\n-    pub base: Option<Box<Projection<'tcx>>>,\n-    pub elem: PlaceElem<'tcx>,\n-}\n-\n #[derive(\n     Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n )]\n@@ -1847,14 +1840,22 @@ newtype_index! {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct PlaceRef<'a, 'tcx> {\n     pub base: &'a PlaceBase<'tcx>,\n-    pub projection: &'a Option<Box<Projection<'tcx>>>,\n+    pub projection: &'a [PlaceElem<'tcx>],\n }\n \n impl<'tcx> Place<'tcx> {\n-    pub const RETURN_PLACE: Place<'tcx> = Place {\n-        base: PlaceBase::Local(RETURN_PLACE),\n-        projection: None,\n-    };\n+    // FIXME change this back to a const when projection is a shared slice.\n+    //\n+    // pub const RETURN_PLACE: Place<'tcx> = Place {\n+    //     base: PlaceBase::Local(RETURN_PLACE),\n+    //     projection: &[],\n+    // };\n+    pub fn return_place() -> Place<'tcx> {\n+        Place {\n+            base: PlaceBase::Local(RETURN_PLACE),\n+            projection: Box::new([]),\n+        }\n+    }\n \n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.elem(ProjectionElem::Field(f, ty))\n@@ -1880,9 +1881,13 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n+        // FIXME(spastorino): revisit this again once projection is not a Box<[T]> anymore\n+        let mut projection = self.projection.into_vec();\n+        projection.push(elem);\n+\n         Place {\n             base: self.base,\n-            projection: Some(Box::new(Projection { base: self.projection, elem })),\n+            projection: projection.into_boxed_slice(),\n         }\n     }\n \n@@ -1891,7 +1896,7 @@ impl<'tcx> Place<'tcx> {\n     /// If `Place::is_indirect` returns false, the caller knows that the `Place` refers to the\n     /// same region of memory as its base.\n     pub fn is_indirect(&self) -> bool {\n-        self.iterate(|_, mut projections| projections.any(|proj| proj.elem.is_indirect()))\n+        self.projection.iter().any(|elem| elem.is_indirect())\n     }\n \n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n@@ -1902,61 +1907,16 @@ impl<'tcx> Place<'tcx> {\n         match self {\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             } |\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: box [ProjectionElem::Deref],\n             } => Some(*local),\n             _ => None,\n         }\n     }\n \n-    /// Recursively \"iterates\" over place components, generating a `PlaceBase` and\n-    /// `Projections` list and invoking `op` with a `ProjectionsIter`.\n-    pub fn iterate<R>(\n-        &self,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        Place::iterate_over(&self.base, &self.projection, op)\n-    }\n-\n-    pub fn iterate_over<R>(\n-        place_base: &PlaceBase<'tcx>,\n-        place_projection: &Option<Box<Projection<'tcx>>>,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        fn iterate_over2<'tcx, R>(\n-            place_base: &PlaceBase<'tcx>,\n-            place_projection: &Option<Box<Projection<'tcx>>>,\n-            next: &Projections<'_, 'tcx>,\n-            op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-        ) -> R {\n-            match place_projection {\n-                None => {\n-                    op(place_base, next.iter())\n-                }\n-\n-                Some(interior) => {\n-                    iterate_over2(\n-                        place_base,\n-                        &interior.base,\n-                        &Projections::List {\n-                            projection: interior,\n-                            next,\n-                        },\n-                        op,\n-                    )\n-                }\n-            }\n-        }\n-\n-        iterate_over2(place_base, place_projection, &Projections::Empty, op)\n-    }\n-\n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n         PlaceRef {\n             base: &self.base,\n@@ -1969,7 +1929,7 @@ impl From<Local> for Place<'_> {\n     fn from(local: Local) -> Self {\n         Place {\n             base: local.into(),\n-            projection: None,\n+            projection: Box::new([]),\n         }\n     }\n }\n@@ -1981,13 +1941,6 @@ impl From<Local> for PlaceBase<'_> {\n }\n \n impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n-    pub fn iterate<R>(\n-        &self,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        Place::iterate_over(self.base, self.projection, op)\n-    }\n-\n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n     //\n@@ -1996,143 +1949,71 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n         match self {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } |\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             } => Some(*local),\n             _ => None,\n         }\n     }\n }\n \n-/// A linked list of projections running up the stack; begins with the\n-/// innermost projection and extends to the outermost (e.g., `a.b.c`\n-/// would have the place `b` with a \"next\" pointer to `b.c`).\n-/// Created by `Place::iterate`.\n-///\n-/// N.B., this particular impl strategy is not the most obvious. It was\n-/// chosen because it makes a measurable difference to NLL\n-/// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n-pub enum Projections<'p, 'tcx> {\n-    Empty,\n-\n-    List { projection: &'p Projection<'tcx>, next: &'p Projections<'p, 'tcx> },\n-}\n-\n-impl<'p, 'tcx> Projections<'p, 'tcx> {\n-    fn iter(&self) -> ProjectionsIter<'_, 'tcx> {\n-        ProjectionsIter { value: self }\n-    }\n-}\n-\n-impl<'p, 'tcx> IntoIterator for &'p Projections<'p, 'tcx> {\n-    type Item = &'p Projection<'tcx>;\n-    type IntoIter = ProjectionsIter<'p, 'tcx>;\n-\n-    /// Converts a list of `Projection` components into an iterator;\n-    /// this iterator yields up a never-ending stream of `Option<&Place>`.\n-    /// These begin with the \"innermost\" projection and then with each\n-    /// projection therefrom. So given a place like `a.b.c` it would\n-    /// yield up:\n-    ///\n-    /// ```notrust\n-    /// Some(`a`), Some(`a.b`), Some(`a.b.c`), None, None, ...\n-    /// ```\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.iter()\n-    }\n-}\n-\n-/// Iterator over components; see `Projections::iter` for more\n-/// information.\n-///\n-/// N.B., this is not a *true* Rust iterator -- the code above just\n-/// manually invokes `next`. This is because we (sometimes) want to\n-/// keep executing even after `None` has been returned.\n-pub struct ProjectionsIter<'p, 'tcx> {\n-    pub value: &'p Projections<'p, 'tcx>,\n-}\n-\n-impl<'p, 'tcx> Iterator for ProjectionsIter<'p, 'tcx> {\n-    type Item = &'p Projection<'tcx>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if let &Projections::List { projection, next } = self.value {\n-            self.value = next;\n-            Some(projection)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'p, 'tcx> FusedIterator for ProjectionsIter<'p, 'tcx> {}\n-\n impl Debug for Place<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        self.iterate(|_place_base, place_projections| {\n-            // FIXME: remove this collect once we have migrated to slices\n-            let projs_vec: Vec<_> = place_projections.collect();\n-            for projection in projs_vec.iter().rev() {\n-                match projection.elem {\n-                    ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n-                        write!(fmt, \"(\").unwrap();\n-                    }\n-                    ProjectionElem::Deref => {\n-                        write!(fmt, \"(*\").unwrap();\n-                    }\n-                    ProjectionElem::Index(_)\n-                    | ProjectionElem::ConstantIndex { .. }\n-                    | ProjectionElem::Subslice { .. } => {}\n+        for elem in self.projection.iter().rev() {\n+            match elem {\n+                ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n+                    write!(fmt, \"(\").unwrap();\n+                }\n+                ProjectionElem::Deref => {\n+                    write!(fmt, \"(*\").unwrap();\n                 }\n+                ProjectionElem::Index(_)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {}\n             }\n-        });\n+        }\n \n-        self.iterate(|place_base, place_projections| {\n-            write!(fmt, \"{:?}\", place_base)?;\n+        write!(fmt, \"{:?}\", self.base)?;\n \n-            for projection in place_projections {\n-                match projection.elem {\n-                    ProjectionElem::Downcast(Some(name), _index) => {\n-                        write!(fmt, \" as {})\", name)?;\n-                    }\n-                    ProjectionElem::Downcast(None, index) => {\n-                        write!(fmt, \" as variant#{:?})\", index)?;\n-                    }\n-                    ProjectionElem::Deref => {\n-                        write!(fmt, \")\")?;\n-                    }\n-                    ProjectionElem::Field(field, ty) => {\n-                        write!(fmt, \".{:?}: {:?})\", field.index(), ty)?;\n-                    }\n-                    ProjectionElem::Index(ref index) => {\n-                        write!(fmt, \"[{:?}]\", index)?;\n-                    }\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } => {\n-                        write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n-                    }\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n-                        write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } if to == 0 => {\n-                        write!(fmt, \"[{:?}:]\", from)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } if from == 0 => {\n-                        write!(fmt, \"[:-{:?}]\", to)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } => {\n-                        write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n-                    }\n+        for elem in self.projection.iter() {\n+            match elem {\n+                ProjectionElem::Downcast(Some(name), _index) => {\n+                    write!(fmt, \" as {})\", name)?;\n+                }\n+                ProjectionElem::Downcast(None, index) => {\n+                    write!(fmt, \" as variant#{:?})\", index)?;\n+                }\n+                ProjectionElem::Deref => {\n+                    write!(fmt, \")\")?;\n+                }\n+                ProjectionElem::Field(field, ty) => {\n+                    write!(fmt, \".{:?}: {:?})\", field.index(), ty)?;\n+                }\n+                ProjectionElem::Index(ref index) => {\n+                    write!(fmt, \"[{:?}]\", index)?;\n+                }\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end: false } => {\n+                    write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n+                }\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n+                    write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n+                }\n+                ProjectionElem::Subslice { from, to } if *to == 0 => {\n+                    write!(fmt, \"[{:?}:]\", from)?;\n+                }\n+                ProjectionElem::Subslice { from, to } if *from == 0 => {\n+                    write!(fmt, \"[:-{:?}]\", to)?;\n+                }\n+                ProjectionElem::Subslice { from, to } => {\n+                    write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n                 }\n             }\n+        }\n \n-            Ok(())\n-        })\n+        Ok(())\n     }\n }\n \n@@ -2171,7 +2052,7 @@ pub struct SourceScopeData {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SourceScopeLocalData {\n-    /// A HirId with lint levels equivalent to this scope's lint levels.\n+    /// An `HirId` with lint levels equivalent to this scope's lint levels.\n     pub lint_root: hir::HirId,\n     /// The unsafe block that contains this node.\n     pub safety: Safety,\n@@ -2760,11 +2641,12 @@ impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd, HashStable)]\n pub struct Location {\n-    /// the location is within this block\n+    /// The block that the location is within.\n     pub block: BasicBlock,\n \n-    /// the location is the start of the statement; or, if `statement_index`\n-    /// == num-statements, then the start of the terminator.\n+    /// The location is the position of the start of the statement; or, if\n+    /// `statement_index` equals the number of statements, then the start of the\n+    /// terminator.\n     pub statement_index: usize,\n }\n \n@@ -2827,7 +2709,7 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n     General,\n-    /// Permitted in const fn and regular fns.\n+    /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n     ExternStatic(hir::HirId),\n     BorrowPacked(hir::HirId),\n@@ -2843,9 +2725,9 @@ pub struct UnsafetyViolation {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyCheckResult {\n-    /// Violations that are propagated *upwards* from this function\n+    /// Violations that are propagated *upwards* from this function.\n     pub violations: Lrc<[UnsafetyViolation]>,\n-    /// unsafe blocks in this function, along with whether they are used. This is\n+    /// `unsafe` blocks in this function, along with whether they are used. This is\n     /// used for the \"unused_unsafe\" lint.\n     pub unsafe_blocks: Lrc<[(hir::HirId, bool)]>,\n }\n@@ -2857,7 +2739,7 @@ newtype_index! {\n     }\n }\n \n-/// The layout of generator state\n+/// The layout of generator state.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GeneratorLayout<'tcx> {\n     /// The type of every local stored inside the generator.\n@@ -2872,11 +2754,14 @@ pub struct GeneratorLayout<'tcx> {\n     /// layout.\n     pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n \n-    /// Names and scopes of all the stored generator locals.\n-    /// NOTE(tmandry) This is *strictly* a temporary hack for codegen\n+    /// The names and scopes of all the stored generator locals.\n+    ///\n+    /// N.B., this is *strictly* a temporary hack for codegen\n     /// debuginfo generation, and will be removed at some point.\n     /// Do **NOT** use it for anything else, local information should not be\n     /// in the MIR, please rely on local crate HIR or other side-channels.\n+    //\n+    // FIXME(tmandry): see above.\n     pub __local_debuginfo_codegen_only_do_not_use: IndexVec<GeneratorSavedLocal, LocalDecl<'tcx>>,\n }\n \n@@ -2934,7 +2819,7 @@ pub struct BorrowCheckResult<'tcx> {\n /// instances assigned one of these same indices. Those regions will\n /// be substituted away by the creator. We use `ReClosureBound` in\n /// that case because the regions must be allocated in the global\n-/// TyCtxt, and hence we cannot use `ReVar` (which is what we use\n+/// `TyCtxt`, and hence we cannot use `ReVar` (which is what we use\n /// internally within the rest of the NLL code).\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'tcx> {\n@@ -2950,8 +2835,8 @@ pub struct ClosureRegionRequirements<'tcx> {\n     pub outlives_requirements: Vec<ClosureOutlivesRequirement<'tcx>>,\n }\n \n-/// Indicates an outlives constraint between a type or between two\n-/// free-regions declared on the closure.\n+/// Indicates an outlives-constraint between a type or between two\n+/// free regions declared on the closure.\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureOutlivesRequirement<'tcx> {\n     // This region or type ...\n@@ -2967,11 +2852,11 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n     pub category: ConstraintCategory,\n }\n \n-/// Outlives constraints can be categorized to determine whether and why they\n+/// Outlives-constraints can be categorized to determine whether and why they\n /// are interesting (for error reporting). Order of variants indicates sort\n /// order of the category, thereby influencing diagnostic output.\n ///\n-/// See also [rustc_mir::borrow_check::nll::constraints]\n+/// See also [rustc_mir::borrow_check::nll::constraints].\n #[derive(\n     Copy,\n     Clone,\n@@ -3019,7 +2904,7 @@ pub enum ConstraintCategory {\n     Internal,\n }\n \n-/// The subject of a ClosureOutlivesRequirement -- that is, the thing\n+/// The subject of a `ClosureOutlivesRequirement` -- that is, the thing\n /// that must outlive some region.\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ClosureOutlivesSubject<'tcx> {\n@@ -3037,7 +2922,7 @@ pub enum ClosureOutlivesSubject<'tcx> {\n }\n \n /*\n- * TypeFoldable implementations for MIR types\n+ * `TypeFoldable` implementations for MIR types\n */\n \n CloneTypeFoldableAndLiftImpls! {\n@@ -3113,14 +2998,14 @@ BraceStructTypeFoldableImpl! {\n \n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for StatementKind<'tcx> {\n-        (StatementKind::Assign)(a, b),\n+        (StatementKind::Assign)(a),\n         (StatementKind::FakeRead)(cause, place),\n         (StatementKind::SetDiscriminant) { place, variant_index },\n         (StatementKind::StorageLive)(a),\n         (StatementKind::StorageDead)(a),\n         (StatementKind::InlineAsm)(a),\n         (StatementKind::Retag)(kind, place),\n-        (StatementKind::AscribeUserType)(a, v, b),\n+        (StatementKind::AscribeUserType)(a, v),\n         (StatementKind::Nop),\n     }\n }\n@@ -3402,30 +3287,26 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Projection<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n-        let base = self.base.fold_with(folder);\n-        let elem = match self.elem {\n+        match self {\n             Deref => Deref,\n-            Field(f, ref ty) => Field(f, ty.fold_with(folder)),\n-            Index(ref v) => Index(v.fold_with(folder)),\n-            ref elem => elem.clone(),\n-        };\n-\n-        Projection { base, elem }\n+            Field(f, ty) => Field(*f, ty.fold_with(folder)),\n+            Index(v) => Index(v.fold_with(folder)),\n+            elem => elem.clone(),\n+        }\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n         use crate::mir::ProjectionElem::*;\n \n-        self.base.visit_with(visitor)\n-            || match self.elem {\n-                Field(_, ref ty) => ty.visit_with(visitor),\n-                Index(ref v) => v.visit_with(visitor),\n-                _ => false,\n-            }\n+        match self {\n+            Field(_, ty) => ty.visit_with(visitor),\n+            Index(v) => v.visit_with(visitor),\n+            _ => false,\n+        }\n     }\n }\n "}, {"sha": "d7768098397433176a95c4450c872033b601dd98", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -121,21 +121,16 @@ BraceStructTypeFoldableImpl! {\n impl<'tcx> Place<'tcx> {\n     pub fn ty_from<D>(\n         base: &PlaceBase<'tcx>,\n-        projection: &Option<Box<Projection<'tcx>>>,\n+        projection: &[PlaceElem<'tcx>],\n         local_decls: &D,\n         tcx: TyCtxt<'tcx>\n     ) -> PlaceTy<'tcx>\n         where D: HasLocalDecls<'tcx>\n     {\n-        Place::iterate_over(base, projection, |place_base, place_projections| {\n-            let mut place_ty = place_base.ty(local_decls);\n-\n-            for proj in place_projections {\n-                place_ty = place_ty.projection_ty(tcx, &proj.elem);\n-            }\n-\n-            place_ty\n-        })\n+        projection.iter().fold(\n+            base.ty(local_decls),\n+            |place_ty, elem| place_ty.projection_ty(tcx, elem)\n+        )\n     }\n \n     pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>"}, {"sha": "1e3b9eb29c79d0f07198409ccc43ee32f66eb1c3", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -152,18 +152,18 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_place_base(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_place_base(place_base, context, location);\n+                self.super_place_base(base, context, location);\n             }\n \n             fn visit_projection(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n-                                place: & $($mutability)? Projection<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n+                                projection: & $($mutability)? [PlaceElem<'tcx>],\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_projection(place_base, place, context, location);\n+                self.super_projection(base, projection, context, location);\n             }\n \n             fn visit_constant(&mut self,\n@@ -344,7 +344,9 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_source_info(source_info);\n                 match kind {\n-                    StatementKind::Assign(place, rvalue) => {\n+                    StatementKind::Assign(\n+                        box(ref $($mutability)? place, ref $($mutability)? rvalue)\n+                    ) => {\n                         self.visit_assign(place, rvalue, location);\n                     }\n                     StatementKind::FakeRead(_, place) => {\n@@ -391,7 +393,10 @@ macro_rules! make_mir_visitor {\n                     StatementKind::Retag(kind, place) => {\n                         self.visit_retag(kind, place, location);\n                     }\n-                    StatementKind::AscribeUserType(place, variance, user_ty) => {\n+                    StatementKind::AscribeUserType(\n+                        box(ref $($mutability)? place, ref $($mutability)? user_ty),\n+                        variance\n+                    ) => {\n                         self.visit_ascribe_user_ty(place, variance, user_ty, location);\n                     }\n                     StatementKind::Nop => {}\n@@ -685,7 +690,7 @@ macro_rules! make_mir_visitor {\n                             location: Location) {\n                 let mut context = context;\n \n-                if place.projection.is_some() {\n+                if !place.projection.is_empty() {\n                     context = if context.is_mutating_use() {\n                         PlaceContext::MutatingUse(MutatingUseContext::Projection)\n                     } else {\n@@ -695,9 +700,10 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_place_base(& $($mutability)? place.base, context, location);\n \n-                if let Some(box proj) = & $($mutability)? place.projection {\n-                    self.visit_projection(& $($mutability)? place.base, proj, context, location);\n-                }\n+                self.visit_projection(& $($mutability)? place.base,\n+                                      & $($mutability)? place.projection,\n+                                      context,\n+                                      location);\n             }\n \n             fn super_place_base(&mut self,\n@@ -715,31 +721,31 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_projection(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n-                                proj: & $($mutability)? Projection<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n+                                projection: & $($mutability)? [PlaceElem<'tcx>],\n                                 context: PlaceContext,\n                                 location: Location) {\n-                if let Some(box proj_base) = & $($mutability)? proj.base {\n-                    self.visit_projection(place_base, proj_base, context, location);\n-                }\n+                if let [proj_base @ .., elem] = projection {\n+                    self.visit_projection(base, proj_base, context, location);\n \n-                match & $($mutability)? proj.elem {\n-                    ProjectionElem::Field(_field, ty) => {\n-                        self.visit_ty(ty, TyContext::Location(location));\n-                    }\n-                    ProjectionElem::Index(local) => {\n-                        self.visit_local(\n-                            local,\n-                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n-                            location\n-                        );\n-                    }\n-                    ProjectionElem::Deref |\n-                    ProjectionElem::Subslice { from: _, to: _ } |\n-                    ProjectionElem::ConstantIndex { offset: _,\n-                                                    min_length: _,\n-                                                    from_end: _ } |\n-                    ProjectionElem::Downcast(_, _) => {\n+                    match elem {\n+                        ProjectionElem::Field(_field, ty) => {\n+                            self.visit_ty(ty, TyContext::Location(location));\n+                        }\n+                        ProjectionElem::Index(local) => {\n+                            self.visit_local(\n+                                local,\n+                                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                                location\n+                            );\n+                        }\n+                        ProjectionElem::Deref |\n+                        ProjectionElem::Subslice { from: _, to: _ } |\n+                        ProjectionElem::ConstantIndex { offset: _,\n+                                                        min_length: _,\n+                                                        from_end: _ } |\n+                        ProjectionElem::Downcast(_, _) => {\n+                        }\n                     }\n                 }\n             }"}, {"sha": "c7260945295a6e4c294dd48809ae030d64ffa945", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -17,7 +17,6 @@ use crate::traits::query::{\n use std::borrow::Cow;\n use syntax_pos::symbol::InternedString;\n \n-\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n@@ -463,15 +462,6 @@ rustc_queries! {\n             no_force\n             desc { \"extract field of const\" }\n         }\n-\n-        /// Produces an absolute path representation of the given type. See also the documentation\n-        /// on `std::any::type_name`.\n-        query type_name(key: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n-            eval_always\n-            no_force\n-            desc { \"get absolute path of type\" }\n-        }\n-\n     }\n \n     TypeChecking {\n@@ -854,7 +844,7 @@ rustc_queries! {\n             desc { \"calculating the lang items map\" }\n         }\n \n-        /// Returns all diagnostic items defined in all crates\n+        /// Returns all diagnostic items defined in all crates.\n         query all_diagnostic_items(_: CrateNum) -> &'tcx FxHashMap<Symbol, DefId> {\n             eval_always\n             desc { \"calculating the diagnostic items map\" }\n@@ -865,7 +855,7 @@ rustc_queries! {\n             desc { \"calculating the lang items defined in a crate\" }\n         }\n \n-        /// Returns the diagnostic items defined in a crate\n+        /// Returns the diagnostic items defined in a crate.\n         query diagnostic_items(_: CrateNum) -> &'tcx FxHashMap<Symbol, DefId> {\n             desc { \"calculating the diagnostic items map in a crate\" }\n         }"}, {"sha": "723855c7c29cf11b03f572dfef7a99b7b74e95e7", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 89, "deletions": 79, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,36 +1,38 @@\n //! Contains infrastructure for configuring the compiler, including parsing\n-//! command line options.\n-\n-use std::str::FromStr;\n+//! command-line options.\n \n+use crate::lint;\n+use crate::middle::cstore;\n use crate::session::{early_error, early_warn, Session};\n use crate::session::search_paths::SearchPath;\n \n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n+\n use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple};\n-use crate::lint;\n-use crate::middle::cstore;\n \n use syntax;\n use syntax::ast::{self, IntTy, UintTy, MetaItemKind};\n use syntax::source_map::{FileName, FilePathMapping};\n use syntax::edition::{Edition, EDITION_NAME_LIST, DEFAULT_EDITION};\n+use syntax::parse::{ParseSess, new_parser_from_source_str};\n use syntax::parse::token;\n-use syntax::parse;\n use syntax::symbol::{sym, Symbol};\n use syntax::feature_gate::UnstableFeatures;\n-use errors::emitter::HumanReadableErrorType;\n+use syntax::source_map::SourceMap;\n \n+use errors::emitter::HumanReadableErrorType;\n use errors::{ColorConfig, FatalError, Handler};\n \n use getopts;\n-use std::collections::{BTreeMap, BTreeSet};\n-use std::collections::btree_map::Iter as BTreeMapIter;\n-use std::collections::btree_map::Keys as BTreeMapKeysIter;\n-use std::collections::btree_map::Values as BTreeMapValuesIter;\n \n-use rustc_data_structures::fx::FxHashSet;\n-use std::{fmt, str};\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::collections::btree_map::{\n+    Iter as BTreeMapIter, Keys as BTreeMapKeysIter, Values as BTreeMapValuesIter,\n+};\n+use std::fmt;\n+use std::str::{self, FromStr};\n use std::hash::Hasher;\n use std::collections::hash_map::DefaultHasher;\n use std::iter::FromIterator;\n@@ -241,14 +243,14 @@ pub enum ErrorOutputType {\n }\n \n impl Default for ErrorOutputType {\n-    fn default() -> ErrorOutputType {\n-        ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(ColorConfig::Auto))\n+    fn default() -> Self {\n+        Self::HumanReadable(HumanReadableErrorType::Default(ColorConfig::Auto))\n     }\n }\n \n-// Use tree-based collections to cheaply get a deterministic Hash implementation.\n-// DO NOT switch BTreeMap out for an unsorted container type! That would break\n-// dependency tracking for command-line arguments.\n+/// Use tree-based collections to cheaply get a deterministic `Hash` implementation.\n+/// *Do not* switch `BTreeMap` out for an unsorted container type! That would break\n+/// dependency tracking for command-line arguments.\n #[derive(Clone, Hash)]\n pub struct OutputTypes(BTreeMap<OutputType, Option<PathBuf>>);\n \n@@ -281,7 +283,7 @@ impl OutputTypes {\n         self.0.len()\n     }\n \n-    // True if any of the output types require codegen or linking.\n+    // Returns `true` if any of the output types require codegen or linking.\n     pub fn should_codegen(&self) -> bool {\n         self.0.keys().any(|k| match *k {\n             OutputType::Bitcode\n@@ -295,9 +297,9 @@ impl OutputTypes {\n     }\n }\n \n-// Use tree-based collections to cheaply get a deterministic Hash implementation.\n-// DO NOT switch BTreeMap or BTreeSet out for an unsorted container type! That\n-// would break dependency tracking for command-line arguments.\n+/// Use tree-based collections to cheaply get a deterministic `Hash` implementation.\n+/// *Do not* switch `BTreeMap` or `BTreeSet` out for an unsorted container type! That\n+/// would break dependency tracking for command-line arguments.\n #[derive(Clone, Hash)]\n pub struct Externs(BTreeMap<String, ExternEntry>);\n \n@@ -327,7 +329,7 @@ macro_rules! hash_option {\n     ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n         if $sub_hashes.insert(stringify!($opt_name),\n                               $opt_expr as &dyn dep_tracking::DepTrackingHash).is_some() {\n-            bug!(\"Duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n+            bug!(\"duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n         }\n     });\n }\n@@ -362,7 +364,7 @@ macro_rules! top_level_options {\n     );\n }\n \n-// The top-level command-line options struct\n+// The top-level command-line options struct.\n //\n // For each option, one has to specify how it behaves with regard to the\n // dependency tracking system of incremental compilation. This is done via the\n@@ -376,16 +378,16 @@ macro_rules! top_level_options {\n // Incremental compilation is not influenced by this option.\n //\n // If you add a new option to this struct or one of the sub-structs like\n-// CodegenOptions, think about how it influences incremental compilation. If in\n+// `CodegenOptions`, think about how it influences incremental compilation. If in\n // doubt, specify [TRACKED], which is always \"correct\" but might lead to\n // unnecessary re-compilation.\n top_level_options!(\n     pub struct Options {\n         // The crate config requested for the session, which may be combined\n-        // with additional crate configurations during the compile process\n+        // with additional crate configurations during the compile process.\n         crate_types: Vec<CrateType> [TRACKED],\n         optimize: OptLevel [TRACKED],\n-        // Include the debug_assertions flag into dependency tracking, since it\n+        // Include the `debug_assertions` flag in dependency tracking, since it\n         // can influence whether overflow checks are done or not.\n         debug_assertions: bool [TRACKED],\n         debuginfo: DebugInfo [TRACKED],\n@@ -402,8 +404,8 @@ top_level_options!(\n         test: bool [TRACKED],\n         error_format: ErrorOutputType [UNTRACKED],\n \n-        // if Some, enable incremental compilation, using the given\n-        // directory to store intermediate results\n+        // If `Some`, enable incremental compilation, using the given\n+        // directory to store intermediate results.\n         incremental: Option<PathBuf> [UNTRACKED],\n \n         debugging_opts: DebuggingOptions [TRACKED],\n@@ -418,7 +420,7 @@ top_level_options!(\n         // written `extern crate name as std`. Defaults to `std`. Used by\n         // out-of-tree drivers.\n         alt_std_name: Option<String> [TRACKED],\n-        // Indicates how the compiler should treat unstable features\n+        // Indicates how the compiler should treat unstable features.\n         unstable_features: UnstableFeatures [TRACKED],\n \n         // Indicates whether this run of the compiler is actually rustdoc. This\n@@ -434,12 +436,12 @@ top_level_options!(\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n         cli_forced_thinlto_off: bool [UNTRACKED],\n \n-        // Remap source path prefixes in all output (messages, object files, debug, etc)\n+        // Remap source path prefixes in all output (messages, object files, debug, etc.).\n         remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n \n         edition: Edition [TRACKED],\n \n-        // Whether or not we're emitting JSON blobs about each artifact produced\n+        // `true` if we're emitting JSON blobs about each artifact produced\n         // by the compiler.\n         json_artifact_notifications: bool [TRACKED],\n     }\n@@ -468,7 +470,7 @@ pub enum BorrowckMode {\n }\n \n impl BorrowckMode {\n-    /// Should we run the MIR-based borrow check, but also fall back\n+    /// Returns whether we should run the MIR-based borrow check, but also fall back\n     /// on the AST borrow check if the MIR-based one errors.\n     pub fn migrate(self) -> bool {\n         match self {\n@@ -477,7 +479,7 @@ impl BorrowckMode {\n         }\n     }\n \n-    /// Should we emit the AST-based borrow checker errors?\n+    /// Returns whether we should emit the AST-based borrow checker errors.\n     pub fn use_ast(self) -> bool {\n         match self {\n             BorrowckMode::Mir => false,\n@@ -487,12 +489,13 @@ impl BorrowckMode {\n }\n \n pub enum Input {\n-    /// Loads source from file\n+    /// Load source code from a file.\n     File(PathBuf),\n+    /// Load source code from a string.\n     Str {\n-        /// String that is shown in place of a filename\n+        /// A string that is shown in place of a filename.\n         name: FileName,\n-        /// Anonymous source string\n+        /// An anonymous string containing the source code.\n         input: String,\n     },\n }\n@@ -651,7 +654,7 @@ impl Options {\n         FilePathMapping::new(self.remap_path_prefix.clone())\n     }\n \n-    /// Returns `true` if there will be an output file generated\n+    /// Returns `true` if there will be an output file generated.\n     pub fn will_create_output_file(&self) -> bool {\n         !self.debugging_opts.parse_only && // The file is just being parsed\n             !self.debugging_opts.ls // The file is just being queried\n@@ -709,16 +712,14 @@ impl Passes {\n     }\n }\n \n-/// Declare a macro that will define all CodegenOptions/DebuggingOptions fields and parsers all\n-/// at once. The goal of this macro is to define an interface that can be\n-/// programmatically used by the option parser in order to initialize the struct\n-/// without hardcoding field names all over the place.\n+/// Defines all `CodegenOptions`/`DebuggingOptions` fields and parsers all at once. The goal of this\n+/// macro is to define an interface that can be programmatically used by the option parser\n+/// to initialize the struct without hardcoding field names all over the place.\n ///\n-/// The goal is to invoke this macro once with the correct fields, and then this\n-/// macro generates all necessary code. The main gotcha of this macro is the\n-/// cgsetters module which is a bunch of generated code to parse an option into\n-/// its respective field in the struct. There are a few hand-written parsers for\n-/// parsing specific types of values in this module.\n+/// The goal is to invoke this macro once with the correct fields, and then this macro generates all\n+/// necessary code. The main gotcha of this macro is the `cgsetters` module which is a bunch of\n+/// generated code to parse an option into its respective field in the struct. There are a few\n+/// hand-written parsers for parsing specific types of values in this module.\n macro_rules! options {\n     ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n      $buildfn:ident, $prefix:expr, $outputname:expr,\n@@ -1539,7 +1540,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     ret\n }\n \n-/// Converts the crate cfg! configuration from String to Symbol.\n+/// Converts the crate `cfg!` configuration from `String` to `Symbol`.\n /// `rustc_interface::interface::Config` accepts this in the compiler configuration,\n /// but the symbol interner is not yet set up then, so we must convert it later.\n pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> ast::CrateConfig {\n@@ -1550,9 +1551,9 @@ pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> ast::CrateCo\n \n pub fn build_configuration(sess: &Session, mut user_cfg: ast::CrateConfig) -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n-    // some default and generated configuration items\n+    // some default and generated configuration items.\n     let default_cfg = default_configuration(sess);\n-    // If the user wants a test runner, then add the test cfg\n+    // If the user wants a test runner, then add the test cfg.\n     if sess.opts.test {\n         user_cfg.insert((sym::test, None));\n     }\n@@ -1851,13 +1852,22 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n     opts\n }\n \n-// Convert strings provided as --cfg [cfgspec] into a crate_cfg\n+struct NullEmitter;\n+\n+impl errors::emitter::Emitter for NullEmitter {\n+    fn emit_diagnostic(&mut self, _: &errors::DiagnosticBuilder<'_>) {}\n+}\n+\n+// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n     syntax::with_default_globals(move || {\n         let cfg = cfgspecs.into_iter().map(|s| {\n-            let sess = parse::ParseSess::new(FilePathMapping::empty());\n+\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+            let handler = Handler::with_emitter(false, None, Box::new(NullEmitter));\n+            let sess = ParseSess::with_span_handler(handler, cm);\n             let filename = FileName::cfg_spec_source_code(&s);\n-            let mut parser = parse::new_parser_from_source_str(&sess, filename, s.to_string());\n+            let mut parser = new_parser_from_source_str(&sess, filename, s.to_string());\n \n             macro_rules! error {($reason: expr) => {\n                 early_error(ErrorOutputType::default(),\n@@ -1917,7 +1927,7 @@ pub fn get_cmd_lint_options(matches: &getopts::Matches,\n     (lint_opts, describe_lints, lint_cap)\n }\n \n-/// Parse the `--color` flag\n+/// Parses the `--color` flag.\n pub fn parse_color(matches: &getopts::Matches) -> ColorConfig {\n     match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n         Some(\"auto\") => ColorConfig::Auto,\n@@ -1929,7 +1939,7 @@ pub fn parse_color(matches: &getopts::Matches) -> ColorConfig {\n         Some(arg) => early_error(\n             ErrorOutputType::default(),\n             &format!(\n-                \"argument for --color must be auto, \\\n+                \"argument for `--color` must be auto, \\\n                  always or never (instead was `{}`)\",\n                 arg\n             ),\n@@ -1974,16 +1984,16 @@ pub fn parse_json(matches: &getopts::Matches) -> (HumanReadableErrorType, bool)\n     (json_rendered(json_color), json_artifact_notifications)\n }\n \n-/// Parse the `--error-format` flag\n+/// Parses the `--error-format` flag.\n pub fn parse_error_format(\n     matches: &getopts::Matches,\n     color: ColorConfig,\n     json_rendered: HumanReadableErrorType,\n ) -> ErrorOutputType {\n-    // We need the opts_present check because the driver will send us Matches\n+    // We need the `opts_present` check because the driver will send us Matches\n     // with only stable options if no unstable options are used. Since error-format\n-    // is unstable, it will not be present. We have to use opts_present not\n-    // opt_present because the latter will panic.\n+    // is unstable, it will not be present. We have to use `opts_present` not\n+    // `opt_present` because the latter will panic.\n     let error_format = if matches.opts_present(&[\"error-format\".to_owned()]) {\n         match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n             None |\n@@ -1998,7 +2008,7 @@ pub fn parse_error_format(\n             Some(arg) => early_error(\n                 ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(color)),\n                 &format!(\n-                    \"argument for --error-format must be `human`, `json` or \\\n+                    \"argument for `--error-format` must be `human`, `json` or \\\n                      `short` (instead was `{}`)\",\n                     arg\n                 ),\n@@ -2037,7 +2047,7 @@ pub fn build_session_options_and_crate_config(\n             early_error(\n                 ErrorOutputType::default(),\n                 &format!(\n-                    \"argument for --edition must be one of: \\\n+                    \"argument for `--edition` must be one of: \\\n                      {}. (instead was `{}`)\",\n                     EDITION_NAME_LIST,\n                     arg\n@@ -2051,7 +2061,7 @@ pub fn build_session_options_and_crate_config(\n         early_error(\n                 ErrorOutputType::default(),\n                 &format!(\n-                    \"Edition {} is unstable and only \\\n+                    \"edition {} is unstable and only \\\n                      available for nightly builds of rustc.\",\n                     edition,\n                 )\n@@ -2075,14 +2085,14 @@ pub fn build_session_options_and_crate_config(\n         if let ErrorOutputType::Json { pretty: true, json_rendered } = error_format {\n             early_error(\n                 ErrorOutputType::Json { pretty: false, json_rendered },\n-                \"--error-format=pretty-json is unstable\",\n+                \"`--error-format=pretty-json` is unstable\",\n             );\n         }\n         if let ErrorOutputType::HumanReadable(HumanReadableErrorType::AnnotateSnippet(_)) =\n             error_format {\n             early_error(\n                 ErrorOutputType::Json { pretty: false, json_rendered },\n-                \"--error-format=human-annotate-rs is unstable\",\n+                \"`--error-format=human-annotate-rs` is unstable\",\n             );\n         }\n     }\n@@ -2116,7 +2126,7 @@ pub fn build_session_options_and_crate_config(\n     let mut codegen_units = cg.codegen_units;\n     let mut disable_thinlto = false;\n \n-    // Issue #30063: if user requests llvm-related output to one\n+    // Issue #30063: if user requests LLVM-related output to one\n     // particular path, disable codegen-units.\n     let incompatible: Vec<_> = output_types\n         .iter()\n@@ -2132,8 +2142,8 @@ pub fn build_session_options_and_crate_config(\n                         early_warn(\n                             error_format,\n                             &format!(\n-                                \"--emit={} with -o incompatible with \\\n-                                 -C codegen-units=N for N > 1\",\n+                                \"`--emit={}` with `-o` incompatible with \\\n+                                 `-C codegen-units=N` for N > 1\",\n                                 ot\n                             ),\n                         );\n@@ -2153,21 +2163,21 @@ pub fn build_session_options_and_crate_config(\n     if debugging_opts.threads == Some(0) {\n         early_error(\n             error_format,\n-            \"Value for threads must be a positive nonzero integer\",\n+            \"value for threads must be a positive non-zero integer\",\n         );\n     }\n \n     if debugging_opts.threads.unwrap_or(1) > 1 && debugging_opts.fuel.is_some() {\n         early_error(\n             error_format,\n-            \"Optimization fuel is incompatible with multiple threads\",\n+            \"optimization fuel is incompatible with multiple threads\",\n         );\n     }\n \n     if codegen_units == Some(0) {\n         early_error(\n             error_format,\n-            \"Value for codegen units must be a positive nonzero integer\",\n+            \"value for codegen units must be a positive non-zero integer\",\n         );\n     }\n \n@@ -2414,10 +2424,10 @@ pub fn build_session_options_and_crate_config(\n         )\n     }\n \n-    // We start out with a Vec<(Option<String>, bool)>>,\n-    // and later convert it into a BTreeSet<(Option<String>, bool)>\n+    // We start out with a `Vec<(Option<String>, bool)>>`,\n+    // and later convert it into a `BTreeSet<(Option<String>, bool)>`\n     // This allows to modify entries in-place to set their correct\n-    // 'public' value\n+    // 'public' value.\n     let mut externs: BTreeMap<String, ExternEntry> = BTreeMap::new();\n     for (arg, private) in matches.opt_strs(\"extern\").into_iter().map(|v| (v, false))\n         .chain(matches.opt_strs(\"extern-private\").into_iter().map(|v| (v, true))) {\n@@ -2616,15 +2626,15 @@ impl fmt::Display for CrateType {\n /// The values of all command-line arguments that are relevant for dependency\n /// tracking are hashed into a single value that determines whether the\n /// incremental compilation cache can be re-used or not. This hashing is done\n-/// via the DepTrackingHash trait defined below, since the standard Hash\n-/// implementation might not be suitable (e.g., arguments are stored in a Vec,\n+/// via the `DepTrackingHash` trait defined below, since the standard `Hash`\n+/// implementation might not be suitable (e.g., arguments are stored in a `Vec`,\n /// the hash of which is order dependent, but we might not want the order of\n /// arguments to make a difference for the hash).\n ///\n-/// However, since the value provided by Hash::hash often *is* suitable,\n+/// However, since the value provided by `Hash::hash` often *is* suitable,\n /// especially for primitive types, there is the\n-/// impl_dep_tracking_hash_via_hash!() macro that allows to simply reuse the\n-/// Hash implementation for DepTrackingHash. It's important though that\n+/// `impl_dep_tracking_hash_via_hash!()` macro that allows to simply reuse the\n+/// `Hash` implementation for `DepTrackingHash`. It's important though that\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n /// how the hash should be calculated when adding a new command-line argument.\n mod dep_tracking {\n@@ -2637,9 +2647,9 @@ mod dep_tracking {\n     use super::{CrateType, DebugInfo, ErrorOutputType, OptLevel, OutputTypes,\n                 Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n                 SymbolManglingVersion};\n-    use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n+    use syntax::feature_gate::UnstableFeatures;\n \n     pub trait DepTrackingHash {\n         fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType);"}, {"sha": "8656ebb2e6d72ad36190e32a6c158d39312ec46e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -79,24 +79,24 @@ pub struct Session {\n     /// if the value stored here has been affected by path remapping.\n     pub working_dir: (PathBuf, bool),\n \n-    // FIXME: lint_store and buffered_lints are not thread-safe,\n-    // but are only used in a single thread\n+    // FIXME: `lint_store` and `buffered_lints` are not thread-safe,\n+    // but are only used in a single thread.\n     pub lint_store: RwLock<lint::LintStore>,\n     pub buffered_lints: Lock<Option<lint::LintBuffer>>,\n \n-    /// Set of (DiagnosticId, Option<Span>, message) tuples tracking\n+    /// Set of `(DiagnosticId, Option<Span>, message)` tuples tracking\n     /// (sub)diagnostics that have been set once, but should not be set again,\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n     pub plugin_attributes: Lock<Vec<(Symbol, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n     pub dependency_formats: Once<dependency_format::Dependencies>,\n-    /// The crate_disambiguator is constructed out of all the `-C metadata`\n+    /// The `crate_disambiguator` is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n     /// multiple crates with the same name to coexist. See the\n-    /// rustc_codegen_llvm::back::symbol_names module for more information.\n+    /// `rustc_codegen_llvm::back::symbol_names` module for more information.\n     pub crate_disambiguator: Once<CrateDisambiguator>,\n \n     features: Once<feature_gate::Features>,\n@@ -111,7 +111,7 @@ pub struct Session {\n     /// The maximum number of stackframes allowed in const eval.\n     pub const_eval_stack_frame_limit: usize,\n \n-    /// The metadata::creader module may inject an allocator/panic_runtime\n+    /// The `metadata::creader` module may inject an allocator/`panic_runtime`\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n     pub allocator_kind: Once<Option<AllocatorKind>>,\n@@ -130,7 +130,7 @@ pub struct Session {\n     /// Used by `-Z profile-queries` in `util::common`.\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n-    /// Used by -Z self-profile\n+    /// Used by `-Z self-profile`.\n     pub self_profiling: Option<Arc<SelfProfiler>>,\n \n     /// Some measurements that are being gathered during compilation.\n@@ -187,16 +187,16 @@ pub struct PerfStats {\n     pub normalize_projection_ty: AtomicUsize,\n }\n \n-/// Enum to support dispatch of one-time diagnostics (in Session.diag_once)\n+/// Enum to support dispatch of one-time diagnostics (in `Session.diag_once`).\n enum DiagnosticBuilderMethod {\n     Note,\n     SpanNote,\n     SpanSuggestion(String), // suggestion\n-                            // add more variants as needed to support one-time diagnostics\n+                            // Add more variants as needed to support one-time diagnostics.\n }\n \n-/// Diagnostic message ID\u2014used by `Session.one_time_diagnostics` to avoid\n-/// emitting the same message more than once\n+/// Diagnostic message ID, used by `Session.one_time_diagnostics` to avoid\n+/// emitting the same message more than once.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum DiagnosticMessageId {\n     ErrorId(u16), // EXXXX error code as integer\n@@ -408,7 +408,7 @@ impl Session {\n             Some(next) => {\n                 self.next_node_id.set(ast::NodeId::from_usize(next));\n             }\n-            None => bug!(\"Input too large, ran out of node ids!\"),\n+            None => bug!(\"input too large; ran out of node-IDs!\"),\n         }\n \n         id\n@@ -440,11 +440,11 @@ impl Session {\n                     diag_builder.note(message);\n                 }\n                 DiagnosticBuilderMethod::SpanNote => {\n-                    let span = span_maybe.expect(\"span_note needs a span\");\n+                    let span = span_maybe.expect(\"`span_note` needs a span\");\n                     diag_builder.span_note(span, message);\n                 }\n                 DiagnosticBuilderMethod::SpanSuggestion(suggestion) => {\n-                    let span = span_maybe.expect(\"span_suggestion_* needs a span\");\n+                    let span = span_maybe.expect(\"`span_suggestion_*` needs a span\");\n                     diag_builder.span_suggestion(\n                         span,\n                         message,\n@@ -688,7 +688,7 @@ impl Session {\n \n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n         // \"mcount\" function relies on stack pointer.\n-        // See https://sourceware.org/binutils/docs/gprof/Implementation.html\n+        // See <https://sourceware.org/binutils/docs/gprof/Implementation.html>.\n         if self.instrument_mcount() {\n             true\n         } else if let Some(x) = self.opts.cg.force_frame_pointers {\n@@ -699,7 +699,7 @@ impl Session {\n     }\n \n     /// Returns the symbol name for the registrar function,\n-    /// given the crate Svh and the function DefIndex.\n+    /// given the crate `Svh` and the function `DefIndex`.\n     pub fn generate_plugin_registrar_symbol(&self, disambiguator: CrateDisambiguator) -> String {\n         format!(\n             \"__rustc_plugin_registrar_{}__\",\n@@ -719,7 +719,7 @@ impl Session {\n             &self.sysroot,\n             self.opts.target_triple.triple(),\n             &self.opts.search_paths,\n-            // target_tlib_path==None means it's the same as host_tlib_path.\n+            // `target_tlib_path == None` means it's the same as `host_tlib_path`.\n             self.target_tlib_path.as_ref().unwrap_or(&self.host_tlib_path),\n             kind,\n         )\n@@ -779,12 +779,12 @@ impl Session {\n         if let IncrCompSession::Active { .. } = *incr_comp_session {\n         } else {\n             bug!(\n-                \"Trying to finalize IncrCompSession `{:?}`\",\n+                \"trying to finalize `IncrCompSession` `{:?}`\",\n                 *incr_comp_session\n-            )\n+            );\n         }\n \n-        // Note: This will also drop the lock file, thus unlocking the directory\n+        // Note: this will also drop the lock file, thus unlocking the directory.\n         *incr_comp_session = IncrCompSession::Finalized {\n             session_directory: new_directory_path,\n         };\n@@ -800,13 +800,15 @@ impl Session {\n             } => session_directory.clone(),\n             IncrCompSession::InvalidBecauseOfErrors { .. } => return,\n             _ => bug!(\n-                \"Trying to invalidate IncrCompSession `{:?}`\",\n+                \"trying to invalidate `IncrCompSession` `{:?}`\",\n                 *incr_comp_session\n             ),\n         };\n \n-        // Note: This will also drop the lock file, thus unlocking the directory\n-        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors { session_directory };\n+        // Note: this will also drop the lock file, thus unlocking the directory.\n+        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors {\n+            session_directory,\n+        };\n     }\n \n     pub fn incr_comp_session_dir(&self) -> cell::Ref<'_, PathBuf> {\n@@ -815,8 +817,8 @@ impl Session {\n             incr_comp_session,\n             |incr_comp_session| match *incr_comp_session {\n                 IncrCompSession::NotInitialized => bug!(\n-                    \"Trying to get session directory from IncrCompSession `{:?}`\",\n-                    *incr_comp_session\n+                    \"trying to get session directory from `IncrCompSession`: {:?}\",\n+                    *incr_comp_session,\n                 ),\n                 IncrCompSession::Active {\n                     ref session_directory,\n@@ -1185,7 +1187,10 @@ fn build_session_(\n     );\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n \n-    let p_s = parse::ParseSess::with_span_handler(span_diagnostic, source_map);\n+    let parse_sess = parse::ParseSess::with_span_handler(\n+        span_diagnostic,\n+        source_map,\n+    );\n     let sysroot = match &sopts.maybe_sysroot {\n         Some(sysroot) => sysroot.clone(),\n         None => filesearch::get_or_default_sysroot(),\n@@ -1214,7 +1219,7 @@ fn build_session_(\n     let print_fuel = AtomicU64::new(0);\n \n     let working_dir = env::current_dir().unwrap_or_else(|e|\n-        p_s.span_diagnostic\n+        parse_sess.span_diagnostic\n             .fatal(&format!(\"Current directory is invalid: {}\", e))\n             .raise()\n     );\n@@ -1232,7 +1237,7 @@ fn build_session_(\n         opts: sopts,\n         host_tlib_path,\n         target_tlib_path,\n-        parse_sess: p_s,\n+        parse_sess,\n         sysroot,\n         local_crate_source_file,\n         working_dir,"}, {"sha": "a7e1f2a6a73a75047a758834aedb040c22c56f0b", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -81,6 +81,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                 .map(|obligation| FulfillmentError {\n                     obligation: obligation.goal.clone(),\n                     code: FulfillmentErrorCode::CodeAmbiguity,\n+                    points_at_arg_span: false,\n                 })\n                 .collect();\n             Err(errors)\n@@ -129,6 +130,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                                     code: FulfillmentErrorCode::CodeSelectionError(\n                                         SelectionError::Unimplemented\n                                     ),\n+                                    points_at_arg_span: false,\n                                 }),\n                             }\n                         } else {\n@@ -142,6 +144,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                         code: FulfillmentErrorCode::CodeSelectionError(\n                             SelectionError::Unimplemented\n                         ),\n+                        points_at_arg_span: false,\n                     })\n                 }\n             }"}, {"sha": "1d87484ef09bebd27f0a4066770eef5cc3bbbc27", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -119,11 +119,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n-    fn error_implies(&self,\n-                     cond: &ty::Predicate<'tcx>,\n-                     error: &ty::Predicate<'tcx>)\n-                     -> bool\n-    {\n+    fn error_implies(\n+        &self,\n+        cond: &ty::Predicate<'tcx>,\n+        error: &ty::Predicate<'tcx>,\n+    ) -> bool {\n         if cond == error {\n             return true\n         }\n@@ -155,13 +155,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn report_fulfillment_error(&self, error: &FulfillmentError<'tcx>,\n-                                body_id: Option<hir::BodyId>,\n-                                fallback_has_occurred: bool) {\n+    fn report_fulfillment_error(\n+        &self,\n+        error: &FulfillmentError<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n         debug!(\"report_fulfillment_errors({:?})\", error);\n         match error.code {\n-            FulfillmentErrorCode::CodeSelectionError(ref e) => {\n-                self.report_selection_error(&error.obligation, e, fallback_has_occurred);\n+            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n+                self.report_selection_error(\n+                    &error.obligation,\n+                    selection_error,\n+                    fallback_has_occurred,\n+                    error.points_at_arg_span,\n+                );\n             }\n             FulfillmentErrorCode::CodeProjectionError(ref e) => {\n                 self.report_projection_error(&error.obligation, e);\n@@ -170,19 +178,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 self.maybe_report_ambiguity(&error.obligation, body_id);\n             }\n             FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n-                self.report_mismatched_types(&error.obligation.cause,\n-                                             expected_found.expected,\n-                                             expected_found.found,\n-                                             err.clone())\n-                    .emit();\n+                self.report_mismatched_types(\n+                    &error.obligation.cause,\n+                    expected_found.expected,\n+                    expected_found.found,\n+                    err.clone(),\n+                ).emit();\n             }\n         }\n     }\n \n-    fn report_projection_error(&self,\n-                               obligation: &PredicateObligation<'tcx>,\n-                               error: &MismatchedProjectionTypes<'tcx>)\n-    {\n+    fn report_projection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &MismatchedProjectionTypes<'tcx>,\n+    ) {\n         let predicate =\n             self.resolve_vars_if_possible(&obligation.predicate);\n \n@@ -603,6 +613,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         error: &SelectionError<'tcx>,\n         fallback_has_occurred: bool,\n+        points_at_arg: bool,\n     ) {\n         let span = obligation.cause.span;\n \n@@ -690,7 +701,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         }\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n-                        self.suggest_fn_call(&obligation, &mut err, &trait_ref);\n+                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n                         self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n                         self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n \n@@ -963,6 +974,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n     ) {\n         let self_ty = trait_ref.self_ty();\n         match self_ty.sty {\n@@ -991,15 +1003,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             ..\n                         })) = self.tcx.hir().get_if_local(def_id) {\n                             let body = self.tcx.hir().body(*body_id);\n-                            err.help(&format!(\n-                                \"use parentheses to call the function: `{}({})`\",\n+                            let msg = \"use parentheses to call the function\";\n+                            let snippet = format!(\n+                                \"{}({})\",\n                                 ident,\n                                 body.params.iter()\n                                     .map(|arg| match &arg.pat.node {\n                                         hir::PatKind::Binding(_, _, ident, None)\n                                         if ident.name != kw::SelfLower => ident.to_string(),\n                                         _ => \"_\".to_string(),\n-                                    }).collect::<Vec<_>>().join(\", \")));\n+                                    }).collect::<Vec<_>>().join(\", \"),\n+                            );\n+                            // When the obligation error has been ensured to have been caused by\n+                            // an argument, the `obligation.cause.span` points at the expression\n+                            // of the argument, so we can provide a suggestion. This is signaled\n+                            // by `points_at_arg`. Otherwise, we give a more general note.\n+                            if points_at_arg {\n+                                err.span_suggestion(\n+                                    obligation.cause.span,\n+                                    msg,\n+                                    snippet,\n+                                    Applicability::HasPlaceholders,\n+                                );\n+                            } else {\n+                                err.help(&format!(\"{}: `{}`\", msg, snippet));\n+                            }\n                         }\n                     }\n                     _ => {}"}, {"sha": "805727b6ce0d72c0711065f284f07d2bf9af9d30", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -68,6 +68,10 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n+// `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PendingPredicateObligation<'_>, 136);\n+\n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n@@ -252,15 +256,20 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n         &mut self,\n         pending_obligation: &mut Self::Obligation,\n     ) -> ProcessResult<Self::Obligation, Self::Error> {\n-        // if we were stalled on some unresolved variables, first check\n+        // If we were stalled on some unresolved variables, first check\n         // whether any of them have been resolved; if not, don't bother\n         // doing more work yet\n         if !pending_obligation.stalled_on.is_empty() {\n-            if pending_obligation.stalled_on.iter().all(|&ty| {\n-                // Use the force-inlined variant of shallow_resolve() because this code is hot.\n-                let resolved = ShallowResolver::new(self.selcx.infcx()).inlined_shallow_resolve(ty);\n-                resolved == ty // nothing changed here\n-            }) {\n+            let mut changed = false;\n+            // This `for` loop was once a call to `all()`, but this lower-level\n+            // form was a perf win. See #64545 for details.\n+            for &ty in &pending_obligation.stalled_on {\n+                if ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(ty) {\n+                    changed = true;\n+                    break;\n+                }\n+            }\n+            if !changed {\n                 debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n                        self.selcx.infcx()\n                            .resolve_vars_if_possible(&pending_obligation.obligation),"}, {"sha": "c53f4e49971bf161c8c3df7ec73fdb48ccb1550a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -123,6 +123,10 @@ pub struct Obligation<'tcx, T> {\n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n+// `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PredicateObligation<'_>, 112);\n+\n /// The reason why we incurred this obligation; used for error reporting.\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct ObligationCause<'tcx> {\n@@ -147,7 +151,8 @@ impl<'tcx> ObligationCause<'tcx> {\n             ObligationCauseCode::StartFunctionType => {\n                 tcx.sess.source_map().def_span(self.span)\n             }\n-            ObligationCauseCode::MatchExpressionArm { arm_span, .. } => arm_span,\n+            ObligationCauseCode::MatchExpressionArm(\n+                box MatchExpressionArmCause { arm_span, .. }) => arm_span,\n             _ => self.span,\n         }\n     }\n@@ -223,23 +228,13 @@ pub enum ObligationCauseCode<'tcx> {\n     ExprAssignable,\n \n     /// Computing common supertype in the arms of a match expression\n-    MatchExpressionArm {\n-        arm_span: Span,\n-        source: hir::MatchSource,\n-        prior_arms: Vec<Span>,\n-        last_ty: Ty<'tcx>,\n-        discrim_hir_id: hir::HirId,\n-    },\n+    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n \n     /// Computing common supertype in the pattern guard for the arms of a match expression\n     MatchExpressionArmPattern { span: Span, ty: Ty<'tcx> },\n \n     /// Computing common supertype in an if expression\n-    IfExpression {\n-        then: Span,\n-        outer: Option<Span>,\n-        semicolon: Option<Span>,\n-    },\n+    IfExpression(Box<IfExpressionCause>),\n \n     /// Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse,\n@@ -269,6 +264,26 @@ pub enum ObligationCauseCode<'tcx> {\n     TrivialBound,\n }\n \n+// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(ObligationCauseCode<'_>, 32);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct MatchExpressionArmCause<'tcx> {\n+    pub arm_span: Span,\n+    pub source: hir::MatchSource,\n+    pub prior_arms: Vec<Span>,\n+    pub last_ty: Ty<'tcx>,\n+    pub discrim_hir_id: hir::HirId,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct IfExpressionCause {\n+    pub then: Span,\n+    pub outer: Option<Span>,\n+    pub semicolon: Option<Span>,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the\n@@ -469,7 +484,11 @@ EnumTypeFoldableImpl! {\n \n pub struct FulfillmentError<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,\n-    pub code: FulfillmentErrorCode<'tcx>\n+    pub code: FulfillmentErrorCode<'tcx>,\n+    /// Diagnostics only: we opportunistically change the `code.span` when we encounter an\n+    /// obligation error caused by a call argument. When this is the case, we also signal that in\n+    /// this field to ensure accuracy of suggestions.\n+    pub points_at_arg_span: bool,\n }\n \n #[derive(Clone)]\n@@ -1168,7 +1187,7 @@ impl<'tcx> FulfillmentError<'tcx> {\n            code: FulfillmentErrorCode<'tcx>)\n            -> FulfillmentError<'tcx>\n     {\n-        FulfillmentError { obligation: obligation, code: code }\n+        FulfillmentError { obligation: obligation, code: code, points_at_arg_span: false }\n     }\n }\n "}, {"sha": "a7990c4af69fd50fd0bfa7862689d4d243982b7a", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -130,13 +130,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// We say a method is *vtable safe* if it can be invoked on a trait\n-    /// object.  Note that object-safe traits can have some\n-    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n-    /// otherwise ensure that they cannot be used when `Self=Trait`.\n+    /// object. Note that object-safe traits can have some\n+    /// non-vtable-safe methods, so long as they require `Self: Sized` or\n+    /// otherwise ensure that they cannot be used when `Self = Trait`.\n     pub fn is_vtable_safe_method(self, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n         debug_assert!(self.generics_of(trait_def_id).has_self);\n         debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self : Sized` requisite can't be called.\n+        // Any method that has a `Self: Sized` bound cannot be called.\n         if self.generics_require_sized_self(method.def_id) {\n             return false;\n         }\n@@ -350,15 +350,15 @@ impl<'tcx> TyCtxt<'tcx> {\n             &sig.map_bound(|sig| sig.inputs()[0]),\n         );\n \n-        // until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n+        // Until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n         // However, this is already considered object-safe. We allow it as a special case here.\n         // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n-        // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n+        // `Receiver: Unsize<Receiver[Self => dyn Trait]>`.\n         if receiver_ty != self.types.self_param {\n             if !self.receiver_is_dispatchable(method, receiver_ty) {\n                 return Some(MethodViolationCode::UndispatchableReceiver);\n             } else {\n-                // sanity check to make sure the receiver actually has the layout of a pointer\n+                // Do sanity check to make sure the receiver actually has the layout of a pointer.\n \n                 use crate::ty::layout::Abi;\n \n@@ -368,12 +368,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                     match self.layout_of(param_env.and(ty)) {\n                         Ok(layout) => &layout.abi,\n                         Err(err) => bug!(\n-                            \"Error: {}\\n while computing layout for type {:?}\", err, ty\n+                            \"error: {}\\n while computing layout for type {:?}\", err, ty\n                         )\n                     }\n                 };\n \n-                // e.g., Rc<()>\n+                // e.g., `Rc<()>`\n                 let unit_receiver_ty = self.receiver_for_self_ty(\n                     receiver_ty, self.mk_unit(), method.def_id\n                 );\n@@ -384,7 +384,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         self.sess.delay_span_bug(\n                             self.def_span(method.def_id),\n                             &format!(\n-                                \"Receiver when Self = () should have a Scalar ABI, found {:?}\",\n+                                \"receiver when `Self = ()` should have a Scalar ABI; found {:?}\",\n                                 abi\n                             ),\n                         );\n@@ -395,7 +395,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     trait_def_id, self.mk_region(ty::ReStatic)\n                 );\n \n-                // e.g., Rc<dyn Trait>\n+                // e.g., `Rc<dyn Trait>`\n                 let trait_object_receiver = self.receiver_for_self_ty(\n                     receiver_ty, trait_object_ty, method.def_id\n                 );\n@@ -406,7 +406,8 @@ impl<'tcx> TyCtxt<'tcx> {\n                         self.sess.delay_span_bug(\n                             self.def_span(method.def_id),\n                             &format!(\n-                                \"Receiver when Self = {} should have a ScalarPair ABI, found {:?}\",\n+                                \"receiver when `Self = {}` should have a ScalarPair ABI; \\\n+                                 found {:?}\",\n                                 trait_object_ty, abi\n                             ),\n                         );\n@@ -418,8 +419,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         None\n     }\n \n-    /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n-    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n+    /// Performs a type substitution to produce the version of `receiver_ty` when `Self = self_ty`.\n+    /// For example, for `receiver_ty = Rc<Self>` and `self_ty = Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n         self,\n         receiver_ty: Ty<'tcx>,"}, {"sha": "b9557ceaa6d9f87aaf53cd7b540e3723509f69a2", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,7 +1,8 @@\n use crate::infer::InferCtxt;\n use crate::infer::canonical::OriginalQueryValues;\n-use crate::traits::{EvaluationResult, PredicateObligation, SelectionContext,\n-             TraitQueryMode, OverflowError};\n+use crate::traits::{\n+    EvaluationResult, PredicateObligation, SelectionContext, TraitQueryMode, OverflowError,\n+};\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Evaluates whether the predicate can be satisfied (by any means)"}, {"sha": "039dea1ffcd1655d4346485a8129d9c57e0c38ad", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -6,11 +6,11 @@ use crate::ty::Ty;\n pub struct CandidateStep<'tcx> {\n     pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n     pub autoderefs: usize,\n-    // true if the type results from a dereference of a raw pointer.\n-    // when assembling candidates, we include these steps, but not when\n-    // picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n-    // `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n-    // `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n+    /// `true` if the type results from a dereference of a raw pointer.\n+    /// when assembling candidates, we include these steps, but not when\n+    /// picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n+    /// `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n+    /// `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n     pub from_unsafe_deref: bool,\n     pub unsize: bool,\n }"}, {"sha": "a54bc05f169615917beae66bd191b58209457937", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -134,7 +134,7 @@ impl IntercrateAmbiguityCause {\n                     String::new()\n                 };\n                 format!(\n-                    \"upstream crates may add new impl of trait `{}`{} \\\n+                    \"upstream crates may add a new impl of trait `{}`{} \\\n                      in future versions\",\n                     trait_desc, self_desc\n                 )"}, {"sha": "6930c9368282b8b9cfb0b2e79c7a2449a2ec2f69", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -508,31 +508,33 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 trait_item_def_id,\n             }),\n             super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm {\n+            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n                 arm_span,\n                 source,\n                 ref prior_arms,\n                 last_ty,\n                 discrim_hir_id,\n-            } => {\n+            }) => {\n                 tcx.lift(&last_ty).map(|last_ty| {\n-                    super::MatchExpressionArm {\n+                    super::MatchExpressionArm(box super::MatchExpressionArmCause {\n                         arm_span,\n                         source,\n                         prior_arms: prior_arms.clone(),\n                         last_ty,\n                         discrim_hir_id,\n-                    }\n+                    })\n                 })\n             }\n             super::MatchExpressionArmPattern { span, ty } => {\n                 tcx.lift(&ty).map(|ty| super::MatchExpressionArmPattern { span, ty })\n             }\n-            super::IfExpression { then, outer, semicolon } => Some(super::IfExpression {\n-                then,\n-                outer,\n-                semicolon,\n-            }),\n+            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n+                Some(super::IfExpression(box super::IfExpressionCause {\n+                    then,\n+                    outer,\n+                    semicolon,\n+                }))\n+            }\n             super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n             super::MainFunctionType => Some(super::MainFunctionType),\n             super::StartFunctionType => Some(super::StartFunctionType),"}, {"sha": "3d36790c94b8c4bbf9ac37929f2ec0f6841c1647", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -512,7 +512,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n     (impl_trait_ref, impl_obligations)\n }\n \n-/// See `super::obligations_for_generics`\n+/// See [`super::obligations_for_generics`].\n pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      recursion_depth: usize,\n                                      param_env: ty::ParamEnv<'tcx>,\n@@ -562,7 +562,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n     }\n \n-    /// Cast a trait reference into a reference to one of its super\n+    /// Casts a trait reference into a reference to one of its super\n     /// traits; returns `None` if `target_trait_def_id` is not a\n     /// supertrait.\n     pub fn upcast_choices(self,\n@@ -571,7 +571,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                           -> Vec<ty::PolyTraitRef<'tcx>>\n     {\n         if source_trait_ref.def_id() == target_trait_def_id {\n-            return vec![source_trait_ref]; // shorcut the most common case\n+            return vec![source_trait_ref]; // Shortcut the most common case.\n         }\n \n         supertraits(self, source_trait_ref)"}, {"sha": "1aa21501129c8ab41718b6fc465f05c292ddc627", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -284,9 +284,11 @@ where\n #[macro_export]\n macro_rules! __impl_decoder_methods {\n     ($($name:ident -> $ty:ty;)*) => {\n-        $(fn $name(&mut self) -> Result<$ty, Self::Error> {\n-            self.opaque.$name()\n-        })*\n+        $(\n+            fn $name(&mut self) -> Result<$ty, Self::Error> {\n+                self.opaque.$name()\n+            }\n+        )*\n     }\n }\n \n@@ -327,14 +329,17 @@ macro_rules! impl_arena_allocatable_decoders {\n macro_rules! implement_ty_decoder {\n     ($DecoderName:ident <$($typaram:tt),*>) => {\n         mod __ty_decoder_impl {\n-            use super::$DecoderName;\n+            use std::borrow::Cow;\n+\n+            use rustc_serialize::{Decoder, SpecializedDecoder};\n+\n             use $crate::infer::canonical::CanonicalVarInfos;\n             use $crate::ty;\n             use $crate::ty::codec::*;\n             use $crate::ty::subst::SubstsRef;\n             use $crate::hir::def_id::{CrateNum};\n-            use rustc_serialize::{Decoder, SpecializedDecoder};\n-            use std::borrow::Cow;\n+\n+            use super::$DecoderName;\n \n             impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {\n                 type Error = String;\n@@ -368,8 +373,8 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            // FIXME(#36588) These impls are horribly unsound as they allow\n-            // the caller to pick any lifetime for 'tcx, including 'static,\n+            // FIXME(#36588): These impls are horribly unsound as they allow\n+            // the caller to pick any lifetime for `'tcx`, including `'static`,\n             // by using the unspecialized proxies to them.\n \n             arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);"}, {"sha": "0155803e30580ace326f457a2559e75a2ef5836b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 99, "deletions": 108, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -7,7 +7,7 @@ use crate::session::Session;\n use crate::session::config::{BorrowckMode, OutputFilenames};\n use crate::session::config::CrateType;\n use crate::middle;\n-use crate::hir::{TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n+use crate::hir::{self, TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n use crate::hir::def::{Res, DefKind, Export};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use crate::hir::map as hir_map;\n@@ -45,15 +45,16 @@ use crate::ty::CanonicalPolyFnSig;\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n+\n use errors::DiagnosticBuilder;\n-use smallvec::SmallVec;\n-use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n-                                           StableHasher, StableHasherResult,\n-                                           StableVec};\n use arena::SyncDroplessArena;\n+use smallvec::SmallVec;\n+use rustc_data_structures::stable_hasher::{\n+    HashStable, StableHasher, StableHasherResult, StableVec, hash_stable_hashmap,\n+};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n use rustc_data_structures::sharded::ShardedHashMap;\n+use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n@@ -74,8 +75,6 @@ use syntax::feature_gate;\n use syntax::symbol::{Symbol, InternedString, kw, sym};\n use syntax_pos::Span;\n \n-use crate::hir;\n-\n pub struct AllArenas {\n     pub interner: SyncDroplessArena,\n }\n@@ -91,10 +90,10 @@ impl AllArenas {\n type InternedSet<'tcx, T> = ShardedHashMap<Interned<'tcx, T>, ()>;\n \n pub struct CtxtInterners<'tcx> {\n-    /// The arena that types, regions, etc are allocated from\n+    /// The arena that types, regions, etc. are allocated from.\n     arena: &'tcx SyncDroplessArena,\n \n-    /// Specifically use a speedy hash algorithm for these hash sets,\n+    /// Specifically use a speedy hash algorithm for these hash sets, since\n     /// they're accessed quite often.\n     type_: InternedSet<'tcx, TyS<'tcx>>,\n     type_list: InternedSet<'tcx, List<Ty<'tcx>>>,\n@@ -129,7 +128,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n         }\n     }\n \n-    /// Intern a type\n+    /// Interns a type.\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n     fn intern_ty(&self,\n@@ -144,7 +143,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n                 outer_exclusive_binder: flags.outer_exclusive_binder,\n             };\n \n-\n             Interned(self.arena.alloc(ty_struct))\n         }).0\n     }\n@@ -207,26 +205,24 @@ pub struct LocalTableInContext<'a, V> {\n fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n                                      hir_id: hir::HirId,\n                                      mut_access: bool) {\n-    if cfg!(debug_assertions) {\n-        if let Some(local_id_root) = local_id_root {\n-            if hir_id.owner != local_id_root.index {\n-                ty::tls::with(|tcx| {\n-                    bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n-                          TypeckTables with local_id_root {:?}\",\n-                         tcx.hir().node_to_string(hir_id),\n-                         DefId::local(hir_id.owner),\n-                         local_id_root)\n-                });\n-            }\n-        } else {\n-            // We use \"Null Object\" TypeckTables in some of the analysis passes.\n-            // These are just expected to be empty and their `local_id_root` is\n-            // `None`. Therefore we cannot verify whether a given `HirId` would\n-            // be a valid key for the given table. Instead we make sure that\n-            // nobody tries to write to such a Null Object table.\n-            if mut_access {\n-                bug!(\"access to invalid TypeckTables\")\n-            }\n+    if let Some(local_id_root) = local_id_root {\n+        if hir_id.owner != local_id_root.index {\n+            ty::tls::with(|tcx| {\n+                bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n+                        TypeckTables with local_id_root {:?}\",\n+                        tcx.hir().node_to_string(hir_id),\n+                        DefId::local(hir_id.owner),\n+                        local_id_root)\n+            });\n+        }\n+    } else {\n+        // We use \"Null Object\" TypeckTables in some of the analysis passes.\n+        // These are just expected to be empty and their `local_id_root` is\n+        // `None`. Therefore we cannot verify whether a given `HirId` would\n+        // be a valid key for the given table. Instead we make sure that\n+        // nobody tries to write to such a Null Object table.\n+        if mut_access {\n+            bug!(\"access to invalid TypeckTables\")\n         }\n     }\n }\n@@ -1025,7 +1021,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     hir_map: hir_map::Map<'tcx>,\n \n-    /// A map from DefPathHash -> DefId. Includes DefIds from the local crate\n+    /// A map from `DefPathHash` -> `DefId`. Includes `DefId`s from the local crate\n     /// as well as all upstream crates. Only populated in incremental mode.\n     pub def_path_hash_to_def_id: Option<FxHashMap<DefPathHash, DefId>>,\n \n@@ -1124,9 +1120,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    /// Allocates a byte or string literal for `mir::interpret`, read-only\n+    /// Allocates a read-only byte or string literal for `mir::interpret`.\n     pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n-        // create an allocation that just contains these bytes\n+        // Create an allocation that just contains these bytes.\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n         self.alloc_map.lock().create_memory_alloc(alloc)\n@@ -1346,7 +1342,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Converts a `DefId` into its fully expanded `DefPath` (every\n-    /// `DefId` is really just an interned def-path).\n+    /// `DefId` is really just an interned `DefPath`).\n     ///\n     /// Note that if `id` is not local to this crate, the result will\n     ///  be a non-local `DefPath`.\n@@ -1402,6 +1398,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.cstore.metadata_encoding_version().to_vec()\n     }\n \n+    pub fn encode_metadata(self)-> EncodedMetadata {\n+        self.cstore.encode_metadata(self)\n+    }\n+\n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n     pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Lrc<dyn Any> {\n@@ -1446,25 +1446,25 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.queries.on_disk_cache.serialize(self.global_tcx(), encoder)\n     }\n \n-    /// If true, we should use the AST-based borrowck (we may *also* use\n+    /// If `true`, we should use the AST-based borrowck (we may *also* use\n     /// the MIR-based borrowck).\n     pub fn use_ast_borrowck(self) -> bool {\n         self.borrowck_mode().use_ast()\n     }\n \n-    /// If true, we should use the MIR-based borrow check, but also\n-    /// fall back on the AST borrow check if the MIR-based one errors.\n+    /// If `true`, we should use the MIR-based borrowck, but also\n+    /// fall back on the AST borrowck if the MIR-based one errors.\n     pub fn migrate_borrowck(self) -> bool {\n         self.borrowck_mode().migrate()\n     }\n \n-    /// If true, make MIR codegen for `match` emit a temp that holds a\n+    /// If `true`, make MIR codegen for `match` emit a temp that holds a\n     /// borrow of the input to the match expression.\n     pub fn generate_borrow_of_any_match_input(&self) -> bool {\n         self.emit_read_for_match()\n     }\n \n-    /// If true, make MIR codegen for `match` emit FakeRead\n+    /// If `true`, make MIR codegen for `match` emit FakeRead\n     /// statements (which simulate the maximal effect of executing the\n     /// patterns in a match arm).\n     pub fn emit_read_for_match(&self) -> bool {\n@@ -1517,7 +1517,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    // This method returns the DefId and the BoundRegion corresponding to the given region.\n+    // Returns the `DefId` and the `BoundRegion` corresponding to the given region.\n     pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n@@ -1550,18 +1550,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         &self,\n         scope_def_id: DefId,\n     ) -> Option<Ty<'tcx>> {\n-        // HACK: `type_of_def_id()` will fail on these (#55796), so return None\n+        // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n         let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n                 match item.node {\n-                    ItemKind::Fn(..) => { /* type_of_def_id() will work */ }\n+                    ItemKind::Fn(..) => { /* `type_of_def_id()` will work */ }\n                     _ => {\n                         return None;\n                     }\n                 }\n             }\n-            _ => { /* type_of_def_id() will work or panic */ }\n+            _ => { /* `type_of_def_id()` will work or panic */ }\n         }\n \n         let ret_ty = self.type_of(scope_def_id);\n@@ -1579,7 +1579,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    // Here we check if the bound region is in Impl Item.\n+    // Checks if the bound region is in Impl Item.\n     pub fn is_bound_region_in_impl_item(\n         &self,\n         suitable_region_binding_scope: DefId,\n@@ -1599,23 +1599,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         false\n     }\n \n-    /// Determine whether identifiers in the assembly have strict naming rules.\n+    /// Determines whether identifiers in the assembly have strict naming rules.\n     /// Currently, only NVPTX* targets need it.\n     pub fn has_strict_asm_symbol_naming(&self) -> bool {\n-        self.gcx.sess.target.target.arch.contains(\"nvptx\")\n-    }\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn encode_metadata(self)\n-        -> EncodedMetadata\n-    {\n-        self.cstore.encode_metadata(self)\n+        self.sess.target.target.arch.contains(\"nvptx\")\n     }\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n-    /// Call the closure with a local `TyCtxt` using the given arena.\n+    /// Calls the closure with a local `TyCtxt` using the given arena.\n     /// `interners` is a slot passed so we can create a CtxtInterners\n     /// with the same lifetime as `arena`.\n     pub fn enter_local<F, R>(&'tcx self, f: F) -> R\n@@ -1651,7 +1643,7 @@ impl<'tcx> GlobalCtxt<'tcx> {\n /// It would be more efficient if `TypedArena` provided a way to\n /// determine whether the address is in the allocated range.\n ///\n-/// None is returned if the value or one of the components is not part\n+/// `None` is returned if the value or one of the components is not part\n /// of the provided context.\n /// For `Ty`, `None` can be returned if either the type interner doesn't\n /// contain the `TyKind` key or if the address of the interned\n@@ -1662,7 +1654,6 @@ pub trait Lift<'tcx>: fmt::Debug {\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n }\n \n-\n macro_rules! nop_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n@@ -1709,7 +1700,7 @@ nop_list_lift!{Predicate<'a> => Predicate<'tcx>}\n nop_list_lift!{CanonicalVarInfo => CanonicalVarInfo}\n nop_list_lift!{ProjectionKind => ProjectionKind}\n \n-// this is the impl for `&'a InternalSubsts<'a>`\n+// This is the impl for `&'a InternalSubsts<'a>`.\n nop_list_lift!{Kind<'a> => Kind<'tcx>}\n \n pub mod tls {\n@@ -1732,43 +1723,43 @@ pub mod tls {\n     use rustc_rayon_core as rayon_core;\n \n     /// This is the implicit state of rustc. It contains the current\n-    /// TyCtxt and query. It is updated when creating a local interner or\n-    /// executing a new query. Whenever there's a TyCtxt value available\n-    /// you should also have access to an ImplicitCtxt through the functions\n+    /// `TyCtxt` and query. It is updated when creating a local interner or\n+    /// executing a new query. Whenever there's a `TyCtxt` value available\n+    /// you should also have access to an `ImplicitCtxt` through the functions\n     /// in this module.\n     #[derive(Clone)]\n     pub struct ImplicitCtxt<'a, 'tcx> {\n-        /// The current TyCtxt. Initially created by `enter_global` and updated\n-        /// by `enter_local` with a new local interner\n+        /// The current `TyCtxt`. Initially created by `enter_global` and updated\n+        /// by `enter_local` with a new local interner.\n         pub tcx: TyCtxt<'tcx>,\n \n-        /// The current query job, if any. This is updated by JobOwner::start in\n-        /// ty::query::plumbing when executing a query\n+        /// The current query job, if any. This is updated by `JobOwner::start` in\n+        /// `ty::query::plumbing` when executing a query.\n         pub query: Option<Lrc<query::QueryJob<'tcx>>>,\n \n         /// Where to store diagnostics for the current query job, if any.\n-        /// This is updated by JobOwner::start in ty::query::plumbing when executing a query\n+        /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n         pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n \n         /// Used to prevent layout from recursing too deeply.\n         pub layout_depth: usize,\n \n         /// The current dep graph task. This is used to add dependencies to queries\n-        /// when executing them\n+        /// when executing them.\n         pub task_deps: Option<&'a Lock<TaskDeps>>,\n     }\n \n-    /// Sets Rayon's thread local variable which is preserved for Rayon jobs\n+    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n     /// to `value` during the call to `f`. It is restored to its previous value after.\n-    /// This is used to set the pointer to the new ImplicitCtxt.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n     #[cfg(parallel_compiler)]\n     #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         rayon_core::tlv::with(value, f)\n     }\n \n-    /// Gets Rayon's thread local variable which is preserved for Rayon jobs.\n-    /// This is used to get the pointer to the current ImplicitCtxt.\n+    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n+    /// This is used to get the pointer to the current `ImplicitCtxt`.\n     #[cfg(parallel_compiler)]\n     #[inline]\n     fn get_tlv() -> usize {\n@@ -1777,13 +1768,13 @@ pub mod tls {\n \n     #[cfg(not(parallel_compiler))]\n     thread_local! {\n-        /// A thread local variable which stores a pointer to the current ImplicitCtxt.\n+        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n         static TLV: Cell<usize> = Cell::new(0);\n     }\n \n     /// Sets TLV to `value` during the call to `f`.\n     /// It is restored to its previous value after.\n-    /// This is used to set the pointer to the new ImplicitCtxt.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n     #[cfg(not(parallel_compiler))]\n     #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n@@ -1793,14 +1784,14 @@ pub mod tls {\n         f()\n     }\n \n-    /// This is used to get the pointer to the current ImplicitCtxt.\n+    /// Gets the pointer to the current `ImplicitCtxt`.\n     #[cfg(not(parallel_compiler))]\n     fn get_tlv() -> usize {\n         TLV.with(|tlv| tlv.get())\n     }\n \n     /// This is a callback from libsyntax as it cannot access the implicit state\n-    /// in librustc otherwise\n+    /// in librustc otherwise.\n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n@@ -1825,7 +1816,7 @@ pub mod tls {\n         })\n     }\n \n-    /// Sets up the callbacks from libsyntax on the current thread\n+    /// Sets up the callbacks from libsyntax on the current thread.\n     pub fn with_thread_locals<F, R>(f: F) -> R\n         where F: FnOnce() -> R\n     {\n@@ -1850,7 +1841,7 @@ pub mod tls {\n         })\n     }\n \n-    /// Sets `context` as the new current ImplicitCtxt for the duration of the function `f`\n+    /// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n     #[inline]\n     pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n     where\n@@ -1861,19 +1852,19 @@ pub mod tls {\n         })\n     }\n \n-    /// Enters GlobalCtxt by setting up libsyntax callbacks and\n-    /// creating a initial TyCtxt and ImplicitCtxt.\n-    /// This happens once per rustc session and TyCtxts only exists\n+    /// Enters `GlobalCtxt` by setting up libsyntax callbacks and\n+    /// creating a initial `TyCtxt` and `ImplicitCtxt`.\n+    /// This happens once per rustc session and `TyCtxt`s only exists\n     /// inside the `f` function.\n     pub fn enter_global<'tcx, F, R>(gcx: &'tcx GlobalCtxt<'tcx>, f: F) -> R\n     where\n         F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        // Update GCX_PTR to indicate there's a GlobalCtxt available\n+        // Update `GCX_PTR` to indicate there's a `GlobalCtxt` available.\n         GCX_PTR.with(|lock| {\n             *lock.lock() = gcx as *const _ as usize;\n         });\n-        // Set GCX_PTR back to 0 when we exit\n+        // Set `GCX_PTR` back to 0 when we exit.\n         let _on_drop = OnDrop(move || {\n             GCX_PTR.with(|lock| *lock.lock() = 0);\n         });\n@@ -1894,12 +1885,12 @@ pub mod tls {\n     }\n \n     scoped_thread_local! {\n-        /// Stores a pointer to the GlobalCtxt if one is available.\n-        /// This is used to access the GlobalCtxt in the deadlock handler given to Rayon.\n+        /// Stores a pointer to the `GlobalCtxt` if one is available.\n+        /// This is used to access the `GlobalCtxt` in the deadlock handler given to Rayon.\n         pub static GCX_PTR: Lock<usize>\n     }\n \n-    /// Creates a TyCtxt and ImplicitCtxt based on the GCX_PTR thread local.\n+    /// Creates a `TyCtxt` and `ImplicitCtxt` based on the `GCX_PTR` thread local.\n     /// This is used in the deadlock handler.\n     pub unsafe fn with_global<F, R>(f: F) -> R\n     where\n@@ -1921,7 +1912,7 @@ pub mod tls {\n         enter_context(&icx, |_| f(tcx))\n     }\n \n-    /// Allows access to the current ImplicitCtxt in a closure if one is available\n+    /// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n     #[inline]\n     pub fn with_context_opt<F, R>(f: F) -> R\n     where\n@@ -1931,16 +1922,16 @@ pub mod tls {\n         if context == 0 {\n             f(None)\n         } else {\n-            // We could get a ImplicitCtxt pointer from another thread.\n-            // Ensure that ImplicitCtxt is Sync\n+            // We could get a `ImplicitCtxt` pointer from another thread.\n+            // Ensure that `ImplicitCtxt` is `Sync`.\n             sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n \n             unsafe { f(Some(&*(context as *const ImplicitCtxt<'_, '_>))) }\n         }\n     }\n \n-    /// Allows access to the current ImplicitCtxt.\n-    /// Panics if there is no ImplicitCtxt available\n+    /// Allows access to the current `ImplicitCtxt`.\n+    /// Panics if there is no `ImplicitCtxt` available.\n     #[inline]\n     pub fn with_context<F, R>(f: F) -> R\n     where\n@@ -1949,11 +1940,11 @@ pub mod tls {\n         with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n     }\n \n-    /// Allows access to the current ImplicitCtxt whose tcx field has the same global\n-    /// interner as the tcx argument passed in. This means the closure is given an ImplicitCtxt\n-    /// with the same 'tcx lifetime as the TyCtxt passed in.\n-    /// This will panic if you pass it a TyCtxt which has a different global interner from\n-    /// the current ImplicitCtxt's tcx field.\n+    /// Allows access to the current `ImplicitCtxt` whose tcx field has the same global\n+    /// interner as the tcx argument passed in. This means the closure is given an `ImplicitCtxt`\n+    /// with the same `'tcx` lifetime as the `TyCtxt` passed in.\n+    /// This will panic if you pass it a `TyCtxt` which has a different global interner from\n+    /// the current `ImplicitCtxt`'s `tcx` field.\n     #[inline]\n     pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n     where\n@@ -1968,8 +1959,8 @@ pub mod tls {\n         })\n     }\n \n-    /// Allows access to the TyCtxt in the current ImplicitCtxt.\n-    /// Panics if there is no ImplicitCtxt available\n+    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+    /// Panics if there is no `ImplicitCtxt` available.\n     #[inline]\n     pub fn with<F, R>(f: F) -> R\n     where\n@@ -1978,8 +1969,8 @@ pub mod tls {\n         with_context(|context| f(context.tcx))\n     }\n \n-    /// Allows access to the TyCtxt in the current ImplicitCtxt.\n-    /// The closure is passed None if there is no ImplicitCtxt available\n+    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+    /// The closure is passed None if there is no `ImplicitCtxt` available.\n     #[inline]\n     pub fn with_opt<F, R>(f: F) -> R\n     where\n@@ -1991,7 +1982,7 @@ pub mod tls {\n \n macro_rules! sty_debug_print {\n     ($ctxt: expr, $($variant: ident),*) => {{\n-        // curious inner module to allow variant names to be used as\n+        // Curious inner module to allow variant names to be used as\n         // variable names.\n         #[allow(non_snake_case)]\n         mod inner {\n@@ -2265,9 +2256,9 @@ slice_interners!(\n     projs: _intern_projs(ProjectionKind)\n );\n \n-// This isn't a perfect fit: CanonicalVarInfo slices are always\n+// This isn't a perfect fit: `CanonicalVarInfo` slices are always\n // allocated in the global arena, so this `intern_method!` macro is\n-// overly general.  But we just return false for the code that checks\n+// overly general. However, we just return `false` for the code that checks\n // whether they belong in the thread-local arena, so no harm done, and\n // seems better than open-coding the rest.\n intern_method! {\n@@ -2366,7 +2357,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_adt(self, def: &'tcx AdtDef, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n-        // take a copy of substs so that we own the vectors inside\n+        // Take a copy of substs so that we own the vectors inside.\n         self.mk_ty(Adt(def, substs))\n     }\n \n@@ -2403,9 +2394,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem)  -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(item, None);\n-        self.mk_generic_adt(def_id, ty)\n+    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem)  -> Option<Ty<'tcx>> {\n+        let def_id = self.lang_items().require(item).ok()?;\n+        Some(self.mk_generic_adt(def_id, ty))\n     }\n \n     #[inline]"}, {"sha": "62910ec320494fd3053edb09211d9ea284ea3e37", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -4,6 +4,7 @@ use std::borrow::Cow;\n use std::fmt;\n use rustc_target::spec::abi;\n use syntax::ast;\n+use syntax::errors::pluralise;\n use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n \n@@ -82,12 +83,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n         };\n \n-        macro_rules! pluralise {\n-            ($x:expr) => {\n-                if $x != 1 { \"s\" } else { \"\" }\n-            };\n-        }\n-\n         match *self {\n             CyclicTy(_) => write!(f, \"cyclic type of infinite size\"),\n             Mismatch => write!(f, \"types differ\"),\n@@ -200,7 +195,9 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Array(_, n) => {\n                 let n = tcx.lift_to_global(&n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n-                    Some(n) => format!(\"array of {} elements\", n).into(),\n+                    Some(n) => {\n+                        format!(\"array of {} element{}\", n, if n != 1 { \"s\" } else { \"\" }).into()\n+                    }\n                     None => \"array\".into(),\n                 }\n             }"}, {"sha": "1e08ae45951d1e4db2b17a19b36af95c1009954b", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -39,8 +39,8 @@ use std::collections::BTreeMap;\n use std::fmt;\n use crate::util::nodemap::FxHashSet;\n \n-/// The TypeFoldable trait is implemented for every type that can be folded.\n-/// Basically, every type that has a corresponding method in TypeFolder.\n+/// This trait is implemented for every type that can be folded.\n+/// Basically, every type that has a corresponding method in `TypeFolder`.\n ///\n /// To implement this conveniently, use the\n /// `BraceStructTypeFoldableImpl` etc macros found in `macros.rs`."}, {"sha": "63cc60d80aada4e682db73528e837dacac1d313d", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -4,20 +4,20 @@ use rustc::hir::CRATE_HIR_ID;\n use crate::ty::context::TyCtxt;\n use crate::ty::{DefId, DefIdTree};\n \n-/// Represents a forest of DefIds closed under the ancestor relation. That is,\n-/// if a DefId representing a module is contained in the forest then all\n-/// DefIds defined in that module or submodules are also implicitly contained\n+/// Represents a forest of `DefId`s closed under the ancestor relation. That is,\n+/// if a `DefId` representing a module is contained in the forest then all\n+/// `DefId`s defined in that module or submodules are also implicitly contained\n /// in the forest.\n ///\n /// This is used to represent a set of modules in which a type is visibly\n /// uninhabited.\n #[derive(Clone)]\n pub struct DefIdForest {\n-    /// The minimal set of DefIds required to represent the whole set.\n-    /// If A and B are DefIds in the DefIdForest, and A is a descendant\n-    /// of B, then only B will be in root_ids.\n-    /// We use a SmallVec here because (for its use for caching inhabitedness)\n-    /// its rare that this will contain even two ids.\n+    /// The minimal set of `DefId`s required to represent the whole set.\n+    /// If A and B are DefIds in the `DefIdForest`, and A is a descendant\n+    /// of B, then only B will be in `root_ids`.\n+    /// We use a `SmallVec` here because (for its use for caching inhabitedness)\n+    /// its rare that this will contain even two IDs.\n     root_ids: SmallVec<[DefId; 1]>,\n }\n \n@@ -37,7 +37,7 @@ impl<'tcx> DefIdForest {\n         DefIdForest::from_id(crate_id)\n     }\n \n-    /// Creates a forest containing a DefId and all its descendants.\n+    /// Creates a forest containing a `DefId` and all its descendants.\n     pub fn from_id(id: DefId) -> DefIdForest {\n         let mut root_ids = SmallVec::new();\n         root_ids.push(id);"}, {"sha": "1a0e3517338773209352e43f4f282800ebc41c2b", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,16 +1,16 @@\n+pub use self::def_id_forest::DefIdForest;\n+\n use crate::ty::context::TyCtxt;\n use crate::ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n use crate::ty::{DefId, SubstsRef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::TyKind::*;\n use crate::ty;\n \n-pub use self::def_id_forest::DefIdForest;\n-\n mod def_id_forest;\n \n-// The methods in this module calculate DefIdForests of modules in which a\n-// AdtDef/VariantDef/FieldDef is visibly uninhabited.\n+// The methods in this module calculate `DefIdForest`s of modules in which a\n+// `AdtDef`/`VariantDef`/`FieldDef` is visibly uninhabited.\n //\n // # Example\n // ```rust\n@@ -36,24 +36,25 @@ mod def_id_forest;\n //     y: c::AlsoSecretlyUninhabited,\n // }\n // ```\n-// In this code, the type Foo will only be visibly uninhabited inside the\n-// modules b, c and d. Calling uninhabited_from on Foo or its AdtDef will\n-// return the forest of modules {b, c->d} (represented in a DefIdForest by the\n-// set {b, c})\n+// In this code, the type `Foo` will only be visibly uninhabited inside the\n+// modules `b`, `c` and `d`. Calling `uninhabited_from` on `Foo` or its `AdtDef` will\n+// return the forest of modules {`b`, `c`->`d`} (represented in a `DefIdForest` by the\n+// set {`b`, `c`}).\n //\n-// We need this information for pattern-matching on Foo or types that contain\n-// Foo.\n+// We need this information for pattern-matching on `Foo` or types that contain\n+// `Foo`.\n //\n // # Example\n // ```rust\n // let foo_result: Result<T, Foo> = ... ;\n // let Ok(t) = foo_result;\n // ```\n-// This code should only compile in modules where the uninhabitedness of Foo is\n+// This code should only compile in modules where the uninhabitedness of `Foo` is\n // visible.\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Checks whether a type is visibly uninhabited from a particular module.\n+    ///\n     /// # Example\n     /// ```rust\n     /// enum Void {}\n@@ -91,7 +92,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// visible.\n     pub fn is_ty_uninhabited_from(self, module: DefId, ty: Ty<'tcx>) -> bool {\n         // To check whether this type is uninhabited at all (not just from the\n-        // given node) you could check whether the forest is empty.\n+        // given node), you could check whether the forest is empty.\n         // ```\n         // forest.is_empty()\n         // ```\n@@ -108,7 +109,7 @@ impl<'tcx> TyCtxt<'tcx> {\n }\n \n impl<'tcx> AdtDef {\n-    /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this ADT is visibly uninhabited.\n     fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, substs: SubstsRef<'tcx>) -> DefIdForest {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n         if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n@@ -122,7 +123,7 @@ impl<'tcx> AdtDef {\n }\n \n impl<'tcx> VariantDef {\n-    /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this variant is visibly uninhabited.\n     pub fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -148,7 +149,7 @@ impl<'tcx> VariantDef {\n }\n \n impl<'tcx> FieldDef {\n-    /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this field is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -159,7 +160,7 @@ impl<'tcx> FieldDef {\n             self.ty(tcx, substs).uninhabited_from(tcx)\n         };\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n-        // Visibility::Invisible so we need to override self.vis if we're\n+        // `Visibility::Invisible` so we need to override `self.vis` if we're\n         // dealing with an enum.\n         if is_enum {\n             data_uninhabitedness()\n@@ -178,7 +179,7 @@ impl<'tcx> FieldDef {\n }\n \n impl<'tcx> TyS<'tcx> {\n-    /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n     fn uninhabited_from(&self, tcx: TyCtxt<'tcx>) -> DefIdForest {\n         match self.sty {\n             Adt(def, substs) => def.uninhabited_from(tcx, substs),"}, {"sha": "e52feea1624c11e3b5f1912f8a199e0105483ccc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -127,6 +127,7 @@ impl IntegerExt for Integer {\n \n pub trait PrimitiveExt {\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n+    fn to_int_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n }\n \n impl PrimitiveExt for Primitive {\n@@ -138,6 +139,16 @@ impl PrimitiveExt for Primitive {\n             Pointer => tcx.mk_mut_ptr(tcx.mk_unit()),\n         }\n     }\n+\n+    /// Return an *integer* type matching this primitive.\n+    /// Useful in particular when dealing with enum discriminants.\n+    fn to_int_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            Int(i, signed) => i.to_ty(tcx, signed),\n+            Pointer => tcx.types.usize,\n+            Float(..) => bug!(\"floats do not have an int type\"),\n+        }\n+    }\n }\n \n /// The first half of a fat pointer."}, {"sha": "5ca819e12f23251dd4a1a18416afa82a2f17330d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -590,7 +590,7 @@ impl<'tcx> rustc_serialize::UseSpecializedDecodable for Ty<'tcx> {}\n pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n \n extern {\n-    /// A dummy type used to force List to by unsized without requiring fat pointers\n+    /// A dummy type used to force `List` to by unsized without requiring fat pointers.\n     type OpaqueListContents;\n }\n \n@@ -1938,9 +1938,15 @@ pub struct FieldDef {\n     pub vis: Visibility,\n }\n \n-/// The definition of an abstract data type -- a struct or enum.\n+/// The definition of a user-defined type, e.g., a `struct`, `enum`, or `union`.\n ///\n /// These are all interned (by `intern_adt_def`) into the `adt_defs` table.\n+///\n+/// The initialism *\"Adt\"* stands for an [*algebraic data type (ADT)*][adt].\n+/// This is slightly wrong because `union`s are not ADTs.\n+/// Moreover, Rust only allows recursive data types through indirection.\n+///\n+/// [adt]: https://en.wikipedia.org/wiki/Algebraic_data_type\n pub struct AdtDef {\n     /// `DefId` of the struct, enum or union item.\n     pub did: DefId,\n@@ -2894,6 +2900,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId)\n                                         -> Option<ImplOverlapKind>\n     {\n+        // If either trait impl references an error, they're allowed to overlap,\n+        // as one of them essentially doesn't exist.\n+        if self.impl_trait_ref(def_id1).map_or(false, |tr| tr.references_error()) ||\n+            self.impl_trait_ref(def_id2).map_or(false, |tr| tr.references_error()) {\n+            return Some(ImplOverlapKind::Permitted);\n+        }\n+\n         let is_legit = if self.features().overlapping_marker_traits {\n             let trait1_is_empty = self.impl_trait_ref(def_id1)\n                 .map_or(false, |trait_ref| {"}, {"sha": "50789bf6213b6ffd23d1e8a93e18b0a93e89d46e", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -27,7 +27,8 @@ pub trait Print<'tcx, P> {\n /// which the associated types allow passing through the methods.\n ///\n /// For pretty-printing/formatting in particular, see `PrettyPrinter`.\n-// FIXME(eddyb) find a better name, this is more general than \"printing\".\n+//\n+// FIXME(eddyb) find a better name; this is more general than \"printing\".\n pub trait Printer<'tcx>: Sized {\n     type Error;\n \n@@ -46,6 +47,7 @@ pub trait Printer<'tcx>: Sized {\n     ) -> Result<Self::Path, Self::Error> {\n         self.default_print_def_path(def_id, substs)\n     }\n+\n     fn print_impl_path(\n         self,\n         impl_def_id: DefId,\n@@ -80,6 +82,7 @@ pub trait Printer<'tcx>: Sized {\n         self,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error>;\n+\n     fn path_qualified(\n         self,\n         self_ty: Ty<'tcx>,\n@@ -93,11 +96,13 @@ pub trait Printer<'tcx>: Sized {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error>;\n+\n     fn path_append(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         disambiguated_data: &DisambiguatedDefPathData,\n     ) -> Result<Self::Path, Self::Error>;\n+\n     fn path_generic_args(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,"}, {"sha": "d99580116e4ae30fe0394c12a012a0566c581d39", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -8,10 +8,11 @@ use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n use crate::ty::subst::{Kind, Subst, UnpackedKind};\n use crate::ty::layout::{Integer, IntegerExt, Size};\n use crate::mir::interpret::{ConstValue, sign_extend, Scalar, truncate};\n-use syntax::ast;\n+\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_target::spec::abi::Abi;\n+use syntax::ast;\n use syntax::attr::{SignedInt, UnsignedInt};\n use syntax::symbol::{kw, InternedString};\n \n@@ -194,7 +195,7 @@ pub trait PrettyPrinter<'tcx>:\n         value.skip_binder().print(self)\n     }\n \n-    /// Print comma-separated elements.\n+    /// Prints comma-separated elements.\n     fn comma_sep<T>(mut self, mut elems: impl Iterator<Item = T>) -> Result<Self, Self::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = Self::Error>,\n@@ -209,14 +210,14 @@ pub trait PrettyPrinter<'tcx>:\n         Ok(self)\n     }\n \n-    /// Print `<...>` around what `f` prints.\n+    /// Prints `<...>` around what `f` prints.\n     fn generic_delimiters(\n         self,\n         f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n     ) -> Result<Self, Self::Error>;\n \n-    /// Return `true` if the region should be printed in\n-    /// optional positions, e.g. `&'a T` or `dyn Tr + 'b`.\n+    /// Returns `true` if the region should be printed in\n+    /// optional positions, e.g., `&'a T` or `dyn Tr + 'b`.\n     /// This is typically the case for all non-`'_` regions.\n     fn region_should_not_be_omitted(\n         &self,\n@@ -226,7 +227,7 @@ pub trait PrettyPrinter<'tcx>:\n     // Defaults (should not be overriden):\n \n     /// If possible, this returns a global path resolving to `def_id` that is visible\n-    /// from at least one local module and returns true. If the crate defining `def_id` is\n+    /// from at least one local module, and returns `true`. If the crate defining `def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n     fn try_print_visible_def_path(\n         self,\n@@ -267,11 +268,11 @@ pub trait PrettyPrinter<'tcx>:\n             // In local mode, when we encounter a crate other than\n             // LOCAL_CRATE, execution proceeds in one of two ways:\n             //\n-            // 1. for a direct dependency, where user added an\n+            // 1. For a direct dependency, where user added an\n             //    `extern crate` manually, we put the `extern\n             //    crate` as the parent. So you wind up with\n             //    something relative to the current crate.\n-            // 2. for an extern inferred from a path or an indirect crate,\n+            // 2. For an extern inferred from a path or an indirect crate,\n             //    where there is no explicit `extern crate`, we just prepend\n             //    the crate name.\n             match self.tcx().extern_crate(def_id) {\n@@ -304,13 +305,13 @@ pub trait PrettyPrinter<'tcx>:\n         let mut cur_def_key = self.tcx().def_key(def_id);\n         debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n \n-        // For a constructor we want the name of its parent rather than <unnamed>.\n+        // For a constructor, we want the name of its parent rather than <unnamed>.\n         match cur_def_key.disambiguated_data.data {\n             DefPathData::Ctor => {\n                 let parent = DefId {\n                     krate: def_id.krate,\n                     index: cur_def_key.parent\n-                        .expect(\"DefPathData::Ctor/VariantData missing a parent\"),\n+                        .expect(\"`DefPathData::Ctor` / `VariantData` missing a parent\"),\n                 };\n \n                 cur_def_key = self.tcx().def_key(parent);\n@@ -630,7 +631,7 @@ pub trait PrettyPrinter<'tcx>:\n                         sep = \", \";\n                     }\n                 } else {\n-                    // cross-crate closure types should only be\n+                    // Cross-crate closure types should only be\n                     // visible in codegen bug reports, I imagine.\n                     p!(write(\"@{:?}\", did));\n                     let mut sep = \" \";\n@@ -673,7 +674,7 @@ pub trait PrettyPrinter<'tcx>:\n                         sep = \", \";\n                     }\n                 } else {\n-                    // cross-crate closure types should only be\n+                    // Cross-crate closure types should only be\n                     // visible in codegen bug reports, I imagine.\n                     p!(write(\"@{:?}\", did));\n                     let mut sep = \" \";\n@@ -1173,6 +1174,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         }\n         Ok(self)\n     }\n+\n     fn path_qualified(\n         mut self,\n         self_ty: Ty<'tcx>,\n@@ -1201,6 +1203,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         self.empty_path = false;\n         Ok(self)\n     }\n+\n     fn path_append(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n@@ -1238,6 +1241,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         Ok(self)\n     }\n+\n     fn path_generic_args(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,"}, {"sha": "c20e75868895991ac0871d418955a43f5c2204e6", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 104, "deletions": 107, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -5,9 +5,6 @@ use crate::hir::map::definitions::DefPathHash;\n use crate::ich::{CachingSourceMapView, Fingerprint};\n use crate::mir::{self, interpret};\n use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n-                      SpecializedDecoder, SpecializedEncoder,\n-                      UseSpecializedDecodable, UseSpecializedEncodable};\n use crate::session::{CrateDisambiguator, Session};\n use crate::ty::{self, Ty};\n use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n@@ -19,6 +16,10 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::{Lrc, Lock, HashMapExt, Once};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_serialize::{\n+    Decodable, Decoder, Encodable, Encoder, SpecializedDecoder, SpecializedEncoder,\n+    UseSpecializedDecodable, UseSpecializedEncodable, opaque,\n+};\n use std::mem;\n use syntax::ast::{Ident, NodeId};\n use syntax::source_map::{SourceMap, StableSourceFileId};\n@@ -37,17 +38,16 @@ const TAG_EXPN_DATA_INLINE: u8 = 2;\n const TAG_VALID_SPAN: u8 = 0;\n const TAG_INVALID_SPAN: u8 = 1;\n \n-/// `OnDiskCache` provides an interface to incr. comp. data cached from the\n+/// Provides an interface to incremental compilation data cached from the\n /// previous compilation session. This data will eventually include the results\n /// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n /// any diagnostics that have been emitted during a query.\n pub struct OnDiskCache<'sess> {\n-\n     // The complete cache data in serialized form.\n     serialized_data: Vec<u8>,\n \n-    // This field collects all Diagnostics emitted during the current\n-    // compilation session.\n+    // Collects all `Diagnostic`s emitted during the current compilation\n+    // session.\n     current_diagnostics: Lock<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n \n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n@@ -56,7 +56,7 @@ pub struct OnDiskCache<'sess> {\n     source_map: &'sess SourceMap,\n     file_index_to_stable_id: FxHashMap<SourceFileIndex, StableSourceFileId>,\n \n-    // These two fields caches that are populated lazily during decoding.\n+    // Caches that are populated lazily during decoding.\n     file_index_to_file: Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     synthetic_syntax_contexts: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n@@ -78,7 +78,7 @@ struct Footer {\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     query_result_index: EncodedQueryResultIndex,\n     diagnostics_index: EncodedQueryResultIndex,\n-    // the location of all allocations\n+    // The location of all allocations.\n     interpret_alloc_index: Vec<u32>,\n }\n \n@@ -104,28 +104,28 @@ impl AbsoluteBytePos {\n }\n \n impl<'sess> OnDiskCache<'sess> {\n-    /// Creates a new OnDiskCache instance from the serialized data in `data`.\n-    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> OnDiskCache<'sess> {\n+    /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n+    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> Self {\n         debug_assert!(sess.opts.incremental.is_some());\n \n-        // Wrapping in a scope so we can borrow `data`\n+        // Wrap in a scope so we can borrow `data`.\n         let footer: Footer = {\n             let mut decoder = opaque::Decoder::new(&data[..], start_pos);\n \n-            // Decode the *position* of the footer which can be found in the\n+            // Decode the *position* of the footer, which can be found in the\n             // last 8 bytes of the file.\n             decoder.set_position(data.len() - IntEncodedWithFixedSize::ENCODED_SIZE);\n-            let query_result_index_pos = IntEncodedWithFixedSize::decode(&mut decoder)\n-                .expect(\"Error while trying to decode query result index position.\")\n+            let footer_pos = IntEncodedWithFixedSize::decode(&mut decoder)\n+                .expect(\"error while trying to decode footer position\")\n                 .0 as usize;\n \n-            // Decoder the file footer which contains all the lookup tables, etc.\n-            decoder.set_position(query_result_index_pos);\n+            // Decode the file footer, which contains all the lookup tables, etc.\n+            decoder.set_position(footer_pos);\n             decode_tagged(&mut decoder, TAG_FILE_FOOTER)\n-                .expect(\"Error while trying to decode query result index position.\")\n+                .expect(\"error while trying to decode footer position\")\n         };\n \n-        OnDiskCache {\n+        Self {\n             serialized_data: data,\n             file_index_to_stable_id: footer.file_index_to_stable_id,\n             file_index_to_file: Default::default(),\n@@ -140,8 +140,8 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn new_empty(source_map: &'sess SourceMap) -> OnDiskCache<'sess> {\n-        OnDiskCache {\n+    pub fn new_empty(source_map: &'sess SourceMap) -> Self {\n+        Self {\n             serialized_data: Vec::new(),\n             file_index_to_stable_id: Default::default(),\n             file_index_to_file: Default::default(),\n@@ -158,11 +158,11 @@ impl<'sess> OnDiskCache<'sess> {\n \n     pub fn serialize<'tcx, E>(&self, tcx: TyCtxt<'tcx>, encoder: &mut E) -> Result<(), E::Error>\n     where\n-        E: ty_codec::TyEncoder,\n+        E: TyEncoder,\n     {\n-        // Serializing the DepGraph should not modify it:\n+        // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n-            // Allocate SourceFileIndices\n+            // Allocate `SourceFileIndex`es.\n             let (file_to_file_index, file_index_to_stable_id) = {\n                 let files = tcx.sess.source_map().files();\n                 let mut file_to_file_index = FxHashMap::with_capacity_and_hasher(\n@@ -197,7 +197,7 @@ impl<'sess> OnDiskCache<'sess> {\n             // be in memory, so this should be a cheap operation.\n             tcx.dep_graph.exec_cache_promotions(tcx);\n \n-            // Encode query results\n+            // Encode query results.\n             let mut query_result_index = EncodedQueryResultIndex::new();\n \n             time(tcx.sess, \"encode query results\", || {\n@@ -221,29 +221,28 @@ impl<'sess> OnDiskCache<'sess> {\n                 Ok(())\n             })?;\n \n-            // Encode diagnostics\n+            // Encode diagnostics.\n             let diagnostics_index: EncodedDiagnosticsIndex = self.current_diagnostics.borrow()\n                 .iter()\n-                .map(|(dep_node_index, diagnostics)|\n-            {\n-                let pos = AbsoluteBytePos::new(encoder.position());\n-                // Let's make sure we get the expected type here:\n-                let diagnostics: &EncodedDiagnostics = diagnostics;\n-                let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n-                encoder.encode_tagged(dep_node_index, diagnostics)?;\n-\n-                Ok((dep_node_index, pos))\n-            })\n-            .collect::<Result<_, _>>()?;\n+                .map(|(dep_node_index, diagnostics)| {\n+                    let pos = AbsoluteBytePos::new(encoder.position());\n+                    // Let's make sure we get the expected type here.\n+                    let diagnostics: &EncodedDiagnostics = diagnostics;\n+                    let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n+                    encoder.encode_tagged(dep_node_index, diagnostics)?;\n+\n+                    Ok((dep_node_index, pos))\n+                })\n+                .collect::<Result<_, _>>()?;\n \n             let interpret_alloc_index = {\n                 let mut interpret_alloc_index = Vec::new();\n                 let mut n = 0;\n                 loop {\n                     let new_n = encoder.interpret_allocs_inverse.len();\n-                    // if we have found new ids, serialize those, too\n+                    // If we have found new IDs, serialize those too.\n                     if n == new_n {\n-                        // otherwise, abort\n+                        // Otherwise, abort.\n                         break;\n                     }\n                     interpret_alloc_index.reserve(new_n - n);\n@@ -263,13 +262,15 @@ impl<'sess> OnDiskCache<'sess> {\n             };\n \n             let sorted_cnums = sorted_cnums_including_local_crate(tcx);\n-            let prev_cnums: Vec<_> = sorted_cnums.iter().map(|&cnum| {\n-                let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n-                let crate_disambiguator = tcx.crate_disambiguator(cnum);\n-                (cnum.as_u32(), crate_name, crate_disambiguator)\n-            }).collect();\n-\n-            // Encode the file footer\n+            let prev_cnums: Vec<_> = sorted_cnums.iter()\n+                .map(|&cnum| {\n+                    let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n+                    let crate_disambiguator = tcx.crate_disambiguator(cnum);\n+                    (cnum.as_u32(), crate_name, crate_disambiguator)\n+                })\n+                .collect();\n+\n+            // Encode the file footer.\n             let footer_pos = encoder.position() as u64;\n             encoder.encode_tagged(TAG_FILE_FOOTER, &Footer {\n                 file_index_to_stable_id,\n@@ -371,7 +372,7 @@ impl<'sess> OnDiskCache<'sess> {\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n \n-        // Initialize the cnum_map using the value from the thread which finishes the closure first\n+        // Initialize `cnum_map` using the value from the thread that finishes the closure first.\n         self.cnum_map.init_nonlocking_same(|| {\n             Self::compute_cnum_map(tcx, &self.prev_cnums[..])\n         });\n@@ -381,25 +382,21 @@ impl<'sess> OnDiskCache<'sess> {\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos.to_usize()),\n             source_map: self.source_map,\n             cnum_map: self.cnum_map.get(),\n+            synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n-            synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n-            Ok(value) => {\n-                Some(value)\n-            }\n-            Err(e) => {\n-                bug!(\"Could not decode cached {}: {}\", debug_tag, e)\n-            }\n+            Ok(v) => Some(v),\n+            Err(e) => bug!(\"could not decode cached {}: {}\", debug_tag, e),\n         }\n     }\n \n-    // This function builds mapping from previous-session-CrateNum to\n-    // current-session-CrateNum. There might be CrateNums from the previous\n-    // Session that don't occur in the current one. For these, the mapping\n+    // This function builds mapping from previous-session-`CrateNum` to\n+    // current-session-`CrateNum`. There might be `CrateNum`s from the previous\n+    // `Session` that don't occur in the current one. For these, the mapping\n     // maps to None.\n     fn compute_cnum_map(\n         tcx: TyCtxt<'_>,\n@@ -432,9 +429,9 @@ impl<'sess> OnDiskCache<'sess> {\n \n //- DECODING -------------------------------------------------------------------\n \n-/// A decoder that can read the incr. comp. cache. It is similar to the one\n-/// we use for crate metadata decoding in that it can rebase spans and\n-/// eventually will also handle things that contain `Ty` instances.\n+/// A decoder that can read fro the incr. comp. cache. It is similar to the one\n+/// we use for crate metadata decoding in that it can rebase spans and eventually\n+/// will also handle things that contain `Ty` instances.\n struct CacheDecoder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     opaque: opaque::Decoder<'a>,\n@@ -458,7 +455,7 @@ impl<'a, 'tcx> CacheDecoder<'a, 'tcx> {\n         file_index_to_file.borrow_mut().entry(index).or_insert_with(|| {\n             let stable_id = file_index_to_stable_id[&index];\n             source_map.source_file_by_stable_id(stable_id)\n-                .expect(\"Failed to lookup SourceFile in new context.\")\n+                .expect(\"failed to lookup `SourceFile` in new context\")\n         }).clone()\n     }\n }\n@@ -479,7 +476,7 @@ impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-// Decode something that was encoded with encode_tagged() and verify that the\n+// Decodes something that was encoded with `encode_tagged()` and verify that the\n // tag matches and the correct amount of bytes was read.\n fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> Result<V, D::Error>\n where\n@@ -500,7 +497,7 @@ where\n     Ok(value)\n }\n \n-impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n+impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n@@ -534,7 +531,7 @@ impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n         }\n \n         let ty = or_insert_with(self)?;\n-        // This may overwrite the entry, but it should overwrite with the same value\n+        // This may overwrite the entry, but it should overwrite with the same value.\n         tcx.rcache.borrow_mut().insert_same(cache_key, ty);\n         Ok(ty)\n     }\n@@ -553,7 +550,7 @@ impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n \n     fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n         self.cnum_map[cnum].unwrap_or_else(|| {\n-            bug!(\"Could not find new CrateNum for {:?}\", cnum)\n+            bug!(\"could not find new `CrateNum` for {:?}\", cnum)\n         })\n     }\n }\n@@ -635,25 +632,25 @@ impl<'a, 'tcx> SpecializedDecoder<Ident> for CacheDecoder<'a, 'tcx> {\n }\n \n // This impl makes sure that we get a runtime error when we try decode a\n-// DefIndex that is not contained in a DefId. Such a case would be problematic\n-// because we would not know how to transform the DefIndex to the current\n+// `DefIndex` that is not contained in a `DefId`. Such a case would be problematic\n+// because we would not know how to transform the `DefIndex` to the current\n // context.\n impl<'a, 'tcx> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n-        bug!(\"Trying to decode DefIndex outside the context of a DefId\")\n+        bug!(\"trying to decode `DefIndex` outside the context of a `DefId`\")\n     }\n }\n \n-// Both the CrateNum and the DefIndex of a DefId can change in between two\n-// compilation sessions. We use the DefPathHash, which is stable across\n-// sessions, to map the old DefId to the new one.\n+// Both the `CrateNum` and the `DefIndex` of a `DefId` can change in between two\n+// compilation sessions. We use the `DefPathHash`, which is stable across\n+// sessions, to map the old `DefId` to the new one.\n impl<'a, 'tcx> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n-        // Load the DefPathHash which is was we encoded the DefId as.\n+        // Load the `DefPathHash` which is was we encoded the `DefId` as.\n         let def_path_hash = DefPathHash::decode(self)?;\n \n-        // Using the DefPathHash, we can lookup the new DefId\n+        // Using the `DefPathHash`, we can lookup the new `DefId`.\n         Ok(self.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n     }\n }\n@@ -667,21 +664,21 @@ impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<hir::HirId, Self::Error> {\n-        // Load the DefPathHash which is was we encoded the DefIndex as.\n+        // Load the `DefPathHash` which is what we encoded the `DefIndex` as.\n         let def_path_hash = DefPathHash::decode(self)?;\n \n-        // Use the DefPathHash to map to the current DefId.\n+        // Use the `DefPathHash` to map to the current `DefId`.\n         let def_id = self.tcx()\n                          .def_path_hash_to_def_id\n                          .as_ref()\n                          .unwrap()[&def_path_hash];\n \n         debug_assert!(def_id.is_local());\n \n-        // The ItemLocalId needs no remapping.\n+        // The `ItemLocalId` needs no remapping.\n         let local_id = hir::ItemLocalId::decode(self)?;\n \n-        // Reconstruct the HirId and look up the corresponding NodeId in the\n+        // Reconstruct the `HirId` and look up the corresponding `NodeId` in the\n         // context of the current session.\n         Ok(hir::HirId {\n             owner: def_id.index,\n@@ -690,8 +687,8 @@ impl<'a, 'tcx> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-// NodeIds are not stable across compilation sessions, so we store them in their\n-// HirId representation. This allows use to map them to the current NodeId.\n+// `NodeId`s are not stable across compilation sessions, so we store them in their\n+// `HirId` representation. This allows use to map them to the current `NodeId`.\n impl<'a, 'tcx> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n@@ -728,6 +725,7 @@ impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n \n //- ENCODING -------------------------------------------------------------------\n \n+/// An encoder that can write the incr. comp. cache.\n struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     tcx: TyCtxt<'tcx>,\n     encoder: &'a mut E,\n@@ -742,7 +740,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n \n impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n@@ -753,11 +751,11 @@ where\n     /// encode the specified tag, then the given value, then the number of\n     /// bytes taken up by tag and value. On decoding, we can then verify that\n     /// we get the expected tag and read the expected number of bytes.\n-    fn encode_tagged<T: Encodable, V: Encodable>(&mut self,\n-                                                 tag: T,\n-                                                 value: &V)\n-                                                 -> Result<(), E::Error>\n-    {\n+    fn encode_tagged<T: Encodable, V: Encodable>(\n+        &mut self,\n+        tag: T,\n+        value: &V\n+    ) -> Result<(), E::Error> {\n         let start_pos = self.position();\n \n         tag.encode(self)?;\n@@ -770,7 +768,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n@@ -790,10 +788,9 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n-\n         if *span == DUMMY_SP {\n             return TAG_INVALID_SPAN.encode(self);\n         }\n@@ -849,14 +846,14 @@ where\n         // We don't currently encode enough information to ensure hygiene works\n         // with incremental, so panic rather than risk incremental bugs.\n \n-        // FIXME: Handle hygiene in incremental\n-        bug!(\"Trying to encode Ident for incremental\")\n+        // FIXME: handle hygiene in incremental.\n+        bug!(\"trying to encode `Ident` for incremental\");\n     }\n }\n \n impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn position(&self) -> usize {\n@@ -866,7 +863,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n@@ -876,7 +873,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n@@ -887,7 +884,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self,\n@@ -900,7 +897,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &hir::HirId) -> Result<(), Self::Error> {\n@@ -918,7 +915,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &DefId) -> Result<(), Self::Error> {\n@@ -929,7 +926,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &LocalDefId) -> Result<(), Self::Error> {\n@@ -939,18 +936,18 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, _: &DefIndex) -> Result<(), Self::Error> {\n-        bug!(\"Encoding DefIndex without context.\")\n+        bug!(\"encoding `DefIndex` without context\");\n     }\n }\n \n-// NodeIds are not stable across compilation sessions, so we store them in their\n-// HirId representation. This allows use to map them to the current NodeId.\n+// `NodeId`s are not stable across compilation sessions, so we store them in their\n+// `HirId` representation. This allows use to map them to the current `NodeId`.\n impl<'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n@@ -967,7 +964,7 @@ impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque\n \n impl<'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n     T: Encodable,\n {\n     #[inline]\n@@ -996,7 +993,7 @@ macro_rules! encoder_methods {\n \n impl<'a, 'tcx, E> Encoder for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     type Error = E::Error;\n \n@@ -1040,7 +1037,7 @@ impl UseSpecializedDecodable for IntEncodedWithFixedSize {}\n impl SpecializedEncoder<IntEncodedWithFixedSize> for opaque::Encoder {\n     fn specialized_encode(&mut self, x: &IntEncodedWithFixedSize) -> Result<(), Self::Error> {\n         let start_pos = self.position();\n-        for i in 0 .. IntEncodedWithFixedSize::ENCODED_SIZE {\n+        for i in 0..IntEncodedWithFixedSize::ENCODED_SIZE {\n             ((x.0 >> i * 8) as u8).encode(self)?;\n         }\n         let end_pos = self.position();\n@@ -1085,10 +1082,10 @@ where\n             if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n                 let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n-                // Record position of the cache entry\n+                // Record position of the cache entry.\n                 query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n \n-                // Encode the type check tables with the SerializedDepNodeIndex\n+                // Encode the type check tables with the `SerializedDepNodeIndex`\n                 // as tag.\n                 encoder.encode_tagged(dep_node, &entry.value)?;\n             }"}, {"sha": "d199a26475be706b891010fe7100d95ae0aeae40", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -61,7 +61,7 @@ impl<'tcx, M: QueryConfig<'tcx>> Default for QueryCache<'tcx, M> {\n     }\n }\n \n-// If enabled, send a message to the profile-queries thread\n+// If enabled, sends a message to the profile-queries thread.\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n         if cfg!(debug_assertions) {\n@@ -72,7 +72,7 @@ macro_rules! profq_msg {\n     }\n }\n \n-// If enabled, format a key using its debug string, which can be\n+// If enabled, formats a key using its debug string, which can be\n // expensive to compute (in terms of time).\n macro_rules! profq_query_msg {\n     ($query:expr, $tcx:expr, $key:expr) => {{\n@@ -98,7 +98,7 @@ pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx>> {\n \n impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n-    /// start executing the query, or it returns with the result of the query.\n+    /// start executing the query, or returns with the result of the query.\n     /// If the query is executing elsewhere, this will wait for it.\n     /// If the query panicked, this will silently panic.\n     ///\n@@ -215,38 +215,38 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n     #[inline(never)]\n     #[cold]\n     fn drop(&mut self) {\n-        // Poison the query so jobs waiting on it panic\n+        // Poison the query so jobs waiting on it panic.\n         let shard = self.cache.get_shard_by_value(&self.key);\n         shard.lock().active.insert(self.key.clone(), QueryResult::Poisoned);\n         // Also signal the completion of the job, so waiters\n-        // will continue execution\n+        // will continue execution.\n         self.job.signal_complete();\n     }\n }\n \n #[derive(Clone)]\n pub struct CycleError<'tcx> {\n-    /// The query and related span which uses the cycle\n+    /// The query and related span that uses the cycle.\n     pub(super) usage: Option<(Span, Query<'tcx>)>,\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n }\n \n-/// The result of `try_get_lock`\n+/// The result of `try_get_lock`.\n pub(super) enum TryGetJob<'a, 'tcx, D: QueryDescription<'tcx>> {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n     NotYetStarted(JobOwner<'a, 'tcx, D>),\n \n     /// The query was already completed.\n-    /// Returns the result of the query and its dep node index\n-    /// if it succeeded or a cycle error if it failed\n+    /// Returns the result of the query and its dep-node index\n+    /// if it succeeded or a cycle error if it failed.\n     JobCompleted((D::Value, DepNodeIndex)),\n \n     /// Trying to execute the query resulted in a cycle.\n     Cycle(D::Value),\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Executes a job by changing the ImplicitCtxt to point to the\n+    /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n     #[inline(always)]\n@@ -259,11 +259,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        // The TyCtxt stored in TLS has the same global interner lifetime\n+        // The `TyCtxt` stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n-        // when accessing the ImplicitCtxt\n+        // when accessing the `ImplicitCtxt`.\n         tls::with_related_context(self, move |current_icx| {\n-            // Update the ImplicitCtxt to point to our new query job\n+            // Update the `ImplicitCtxt` to point to our new query job.\n             let new_icx = tls::ImplicitCtxt {\n                 tcx: self.global_tcx(),\n                 query: Some(job),\n@@ -272,7 +272,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 task_deps: current_icx.task_deps,\n             };\n \n-            // Use the ImplicitCtxt while we execute the query\n+            // Use the `ImplicitCtxt` while we execute the query.\n             tls::enter_context(&new_icx, |_| {\n                 compute(self.global_tcx())\n             })\n@@ -372,7 +372,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         // Fast path for when incr. comp. is off. `to_dep_node` is\n-        // expensive for some DepKinds.\n+        // expensive for some `DepKind`s.\n         if !self.dep_graph.is_fully_enabled() {\n             let null_dep_node = DepNode::new_no_params(crate::dep_graph::DepKind::Null);\n             return self.force_query_with_job::<Q>(key, job, null_dep_node).0;\n@@ -410,7 +410,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if !Q::EVAL_ALWAYS {\n             // The diagnostics for this query will be\n             // promoted to the current session during\n-            // try_mark_green(), so we can ignore them here.\n+            // `try_mark_green()`, so we can ignore them here.\n             let loaded = self.start_query(job.job.clone(), None, |tcx| {\n                 let marked = tcx.dep_graph.try_mark_green_and_read(tcx, &dep_node);\n                 marked.map(|(prev_dep_node_index, dep_node_index)| {\n@@ -441,22 +441,22 @@ impl<'tcx> TyCtxt<'tcx> {\n         dep_node: &DepNode,\n     ) -> Q::Value {\n         // Note this function can be called concurrently from the same query\n-        // We must ensure that this is handled correctly\n+        // We must ensure that this is handled correctly.\n \n         debug_assert!(self.dep_graph.is_green(dep_node));\n \n-        // First we try to load the result from the on-disk cache\n+        // First we try to load the result from the on-disk cache.\n         let result = if Q::cache_on_disk(self.global_tcx(), key.clone(), None) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n             self.sess.profiler(|p| p.incremental_load_result_start(Q::NAME));\n             let result = Q::try_load_from_disk(self.global_tcx(), prev_dep_node_index);\n             self.sess.profiler(|p| p.incremental_load_result_end(Q::NAME));\n \n             // We always expect to find a cached result for things that\n-            // can be forced from DepNode.\n+            // can be forced from `DepNode`.\n             debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n                           result.is_some(),\n-                          \"Missing on-disk cache entry for {:?}\",\n+                          \"missing on-disk cache entry for {:?}\",\n                           dep_node);\n             result\n         } else {\n@@ -475,8 +475,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             self.sess.profiler(|p| p.start_query(Q::NAME));\n \n-            // The dep-graph for this computation is already in\n-            // place\n+            // The dep-graph for this computation is already in-place.\n             let result = self.dep_graph.with_ignore(|| {\n                 Q::compute(self, key)\n             });\n@@ -485,7 +484,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             result\n         };\n \n-        // If -Zincremental-verify-ich is specified, re-hash results from\n+        // If `-Zincremental-verify-ich` is specified, re-hash results from\n         // the cache and make sure that they have the expected fingerprint.\n         if unlikely!(self.sess.opts.debugging_opts.incremental_verify_ich) {\n             self.incremental_verify_ich::<Q>(&result, dep_node, dep_node_index);\n@@ -508,10 +507,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) {\n         use crate::ich::Fingerprint;\n \n-        assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n+        assert!(\n+            Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n                 self.dep_graph.prev_fingerprint_of(dep_node),\n-                \"Fingerprint for green query instance not loaded \\\n-                    from cache: {:?}\", dep_node);\n+            \"fingerprint for green query instance not loaded from cache: {:?}\",\n+            dep_node,\n+        );\n \n         debug!(\"BEGIN verify_ich({:?})\", dep_node);\n         let mut hcx = self.create_stable_hashing_context();\n@@ -521,8 +522,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n \n-        assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n-            for {:?}\", dep_node);\n+        assert!(\n+            new_hash == old_hash,\n+            \"found unstable fingerprints for {:?}\",\n+            dep_node,\n+        );\n     }\n \n     #[inline(always)]\n@@ -534,11 +538,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n-        //    in DepGraph::try_mark_green()\n-        // 2. Two distinct query keys get mapped to the same DepNode\n-        //    (see for example #48923)\n+        //    in `DepGraph::try_mark_green()`.\n+        // 2. Two distinct query keys get mapped to the same `DepNode`\n+        //    (see for example #48923).\n         assert!(!self.dep_graph.dep_node_exists(&dep_node),\n-                \"Forcing query with already existing DepNode.\\n\\\n+                \"forcing query with already existing `DepNode`\\n\\\n                  - query-key: {:?}\\n\\\n                  - dep-node: {:?}\",\n                 key, dep_node);\n@@ -584,7 +588,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Ensure that either this query has all green inputs or been executed.\n-    /// Executing query::ensure(D) is considered a read of the dep-node D.\n+    /// Executing `query::ensure(D)` is considered a read of the dep-node `D`.\n     ///\n     /// This function is particularly useful when executing passes for their\n     /// side-effects -- e.g., in order to report errors for erroneous programs.\n@@ -899,13 +903,13 @@ macro_rules! define_queries_inner {\n                 }\n             }\n \n-            // FIXME(eddyb) Get more valid Span's on queries.\n+            // FIXME(eddyb) Get more valid `Span`s on queries.\n             pub fn default_span(&self, tcx: TyCtxt<$tcx>, span: Span) -> Span {\n                 if !span.is_dummy() {\n                     return span;\n                 }\n-                // The def_span query is used to calculate default_span,\n-                // so exit to avoid infinite recursion\n+                // The `def_span` query is used to calculate `default_span`,\n+                // so exit to avoid infinite recursion.\n                 if let Query::def_span(..) = *self {\n                     return span\n                 }\n@@ -1116,7 +1120,7 @@ macro_rules! define_provider_struct {\n         impl<$tcx> Default for Providers<$tcx> {\n             fn default() -> Self {\n                 $(fn $name<$tcx>(_: TyCtxt<$tcx>, key: $K) -> $R {\n-                    bug!(\"tcx.{}({:?}) unsupported by its crate\",\n+                    bug!(\"`tcx.{}({:?})` unsupported by its crate\",\n                          stringify!($name), key);\n                 })*\n                 Providers { $($name),* }\n@@ -1128,26 +1132,26 @@ macro_rules! define_provider_struct {\n \n /// The red/green evaluation system will try to mark a specific DepNode in the\n /// dependency graph as green by recursively trying to mark the dependencies of\n-/// that DepNode as green. While doing so, it will sometimes encounter a DepNode\n+/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n /// where we don't know if it is red or green and we therefore actually have\n /// to recompute its value in order to find out. Since the only piece of\n-/// information that we have at that point is the DepNode we are trying to\n+/// information that we have at that point is the `DepNode` we are trying to\n /// re-evaluate, we need some way to re-run a query from just that. This is what\n /// `force_from_dep_node()` implements.\n ///\n-/// In the general case, a DepNode consists of a DepKind and an opaque\n+/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n /// is usually constructed by computing a stable hash of the query-key that the\n-/// DepNode corresponds to. Consequently, it is not in general possible to go\n+/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n /// back from hash to query-key (since hash functions are not reversible). For\n /// this reason `force_from_dep_node()` is expected to fail from time to time\n-/// because we just cannot find out, from the DepNode alone, what the\n+/// because we just cannot find out, from the `DepNode` alone, what the\n /// corresponding query-key is and therefore cannot re-run the query.\n ///\n /// The system deals with this case letting `try_mark_green` fail which forces\n /// the root query to be re-evaluated.\n ///\n-/// Now, if force_from_dep_node() would always fail, it would be pretty useless.\n+/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n /// Fortunately, we can use some contextual information that will allow us to\n /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n@@ -1171,9 +1175,9 @@ macro_rules! define_provider_struct {\n pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n     use crate::dep_graph::RecoverKey;\n \n-    // We must avoid ever having to call force_from_dep_node() for a\n-    // DepNode::codegen_unit:\n-    // Since we cannot reconstruct the query key of a DepNode::codegen_unit, we\n+    // We must avoid ever having to call `force_from_dep_node()` for a\n+    // `DepNode::codegen_unit`:\n+    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n     // would always end up having to evaluate the first caller of the\n     // `codegen_unit` query that *is* reconstructible. This might very well be\n     // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n@@ -1196,7 +1200,7 @@ pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n             if let Some(def_id) = dep_node.extract_def_id(tcx) {\n                 def_id\n             } else {\n-                // return from the whole function\n+                // Return from the whole function.\n                 return false\n             }\n         }\n@@ -1224,20 +1228,20 @@ pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n \n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n-        // should therefore always be red or green already\n+        // should therefore always be red or green already.\n         DepKind::AllLocalTraitImpls |\n         DepKind::Krate |\n         DepKind::CrateMetadata |\n         DepKind::HirBody |\n         DepKind::Hir |\n \n-        // This are anonymous nodes\n+        // These are anonymous nodes.\n         DepKind::TraitSelect |\n \n         // We don't have enough information to reconstruct the query key of\n-        // these\n+        // these.\n         DepKind::CompileCodegenUnit => {\n-            bug!(\"force_from_dep_node() - Encountered {:?}\", dep_node)\n+            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n         }\n \n         DepKind::Analysis => { force!(analysis, krate!()); }"}, {"sha": "e73a51e6f78e5272eee86659d566340f87a7567d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -644,7 +644,7 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx List<ExistentialPredicate<'tcx>> {}\n \n impl<'tcx> List<ExistentialPredicate<'tcx>> {\n-    /// Returns the \"principal def id\" of this set of existential predicates.\n+    /// Returns the \"principal `DefId`\" of this set of existential predicates.\n     ///\n     /// A Rust trait object type consists (in addition to a lifetime bound)\n     /// of a set of trait bounds, which are separated into any number\n@@ -1052,7 +1052,7 @@ impl<'tcx> PolyGenSig<'tcx> {\n     }\n }\n \n-/// Signature of a function type, which I have arbitrarily\n+/// Signature of a function type, which we have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n /// - `inputs`: is the list of arguments and their modes.\n@@ -1076,7 +1076,8 @@ impl<'tcx> FnSig<'tcx> {\n         self.inputs_and_output[self.inputs_and_output.len() - 1]\n     }\n \n-    // Create a minimal `FnSig` to be used when encountering a `TyKind::Error` in a fallible method\n+    // Creates a minimal `FnSig` to be used when encountering a `TyKind::Error` in a fallible\n+    // method.\n     fn fake() -> FnSig<'tcx> {\n         FnSig {\n             inputs_and_output: List::empty(),\n@@ -1118,7 +1119,6 @@ impl<'tcx> PolyFnSig<'tcx> {\n \n pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n \n-\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ParamTy {"}, {"sha": "78d94df4fa03be353a56fe6b7f6bceee41d60104", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -996,6 +996,24 @@ impl<'tcx> ty::TyS<'tcx> {\n         debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n         r\n     }\n+\n+    /// Peel off all reference types in this type until there are none left.\n+    ///\n+    /// This method is idempotent, i.e. `ty.peel_refs().peel_refs() == ty.peel_refs()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// - `u8` -> `u8`\n+    /// - `&'a mut u8` -> `u8`\n+    /// - `&'a &'b u8` -> `u8`\n+    /// - `&'a *const &'b u8 -> *const &'b u8`\n+    pub fn peel_refs(&'tcx self) -> Ty<'tcx> {\n+        let mut ty = self;\n+        while let Ref(_, inner_ty, _) = ty.sty {\n+            ty = inner_ty;\n+        }\n+        ty\n+    }\n }\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {"}, {"sha": "2475b93d95f32af84ee0ded0da2e2cc39f199347", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -5,17 +5,13 @@ use rustc_data_structures::{fx::FxHashMap, sync::Lock};\n use std::cell::{RefCell, Cell};\n use std::fmt::Debug;\n use std::hash::Hash;\n-use std::panic;\n-use std::env;\n use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n use syntax_pos::{SpanData};\n use syntax::symbol::{Symbol, sym};\n use rustc_macros::HashStable;\n-use crate::ty::TyCtxt;\n use crate::dep_graph::{DepNode};\n-use lazy_static;\n use crate::session::Session;\n \n #[cfg(test)]\n@@ -31,39 +27,6 @@ pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n-lazy_static! {\n-    static ref DEFAULT_HOOK: Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static> = {\n-        let hook = panic::take_hook();\n-        panic::set_hook(Box::new(panic_hook));\n-        hook\n-    };\n-}\n-\n-fn panic_hook(info: &panic::PanicInfo<'_>) {\n-    (*DEFAULT_HOOK)(info);\n-\n-    let backtrace = env::var_os(\"RUST_BACKTRACE\").map(|x| &x != \"0\").unwrap_or(false);\n-\n-    if backtrace {\n-        TyCtxt::try_print_query_stack();\n-    }\n-\n-    #[cfg(windows)]\n-    unsafe {\n-        if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n-            extern \"system\" {\n-                fn DebugBreak();\n-            }\n-            // Trigger a debugger if we crashed during bootstrap.\n-            DebugBreak();\n-        }\n-    }\n-}\n-\n-pub fn install_panic_hook() {\n-    lazy_static::initialize(&DEFAULT_HOOK);\n-}\n-\n /// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n #[derive(Clone,Debug)]\n pub struct ProfQDumpParams {"}, {"sha": "645707ccc03388efebfbee407ef4411cf96ba0fe", "filename": "src/librustc_asan/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_asan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_asan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Fbuild.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -4,6 +4,10 @@ use build_helper::sanitizer_lib_boilerplate;\n use cmake::Config;\n \n fn main() {\n+    println!(\"cargo:rerun-if-env-changed=RUSTC_BUILD_SANITIZERS\");\n+    if env::var(\"RUSTC_BUILD_SANITIZERS\") != Ok(\"1\".to_string()) {\n+        return;\n+    }\n     if let Some(llvm_config) = env::var_os(\"LLVM_CONFIG\") {\n         build_helper::restore_library_path();\n "}, {"sha": "23d5480c60562b5811acf8baff6d091a1fea1fa8", "filename": "src/librustc_ast_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -9,7 +9,6 @@ use InteriorKind::*;\n \n use rustc::hir::HirId;\n use rustc::hir::Node;\n-use rustc::cfg;\n use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::mem_categorization as mc;\n@@ -28,6 +27,7 @@ use log::debug;\n \n use rustc::hir;\n \n+use crate::cfg;\n use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n \n pub mod check_loans;"}, {"sha": "67d818161b1b5d2a6cde7ba12356049b46ebed02", "filename": "src/librustc_ast_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -4,7 +4,7 @@\n use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n \n use crate::borrowck::*;\n-use rustc::cfg;\n+use crate::cfg;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n "}, {"sha": "0dc999083a91a93c88ffcf3f0419657ad0ddc408", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "renamed", "additions": 83, "deletions": 71, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,11 +1,12 @@\n use crate::cfg::*;\n-use crate::middle::region;\n-use rustc_data_structures::graph::implementation as graph;\n-use crate::ty::{self, TyCtxt};\n \n-use crate::hir::{self, PatKind};\n-use crate::hir::def_id::DefId;\n-use crate::hir::ptr::P;\n+use rustc::hir::{self, PatKind};\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::ptr::P;\n+use rustc::middle::region;\n+use rustc::ty::{self, TyCtxt};\n+\n+use rustc_data_structures::graph::implementation as graph;\n \n struct CFGBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -19,18 +20,18 @@ struct CFGBuilder<'a, 'tcx> {\n \n #[derive(Copy, Clone)]\n struct BlockScope {\n-    block_expr_id: hir::ItemLocalId, // id of breakable block expr node\n+    block_expr_id: hir::ItemLocalId, // ID of breakable block expr node\n     break_index: CFGIndex, // where to go on `break`\n }\n \n #[derive(Copy, Clone)]\n struct LoopScope {\n-    loop_id: hir::ItemLocalId,     // id of loop/while node\n+    loop_id: hir::ItemLocalId, // ID of `loop`/`while` node\n     continue_index: CFGIndex, // where to go on a `loop`\n-    break_index: CFGIndex,    // where to go on a `break`\n+    break_index: CFGIndex, // where to go on a `break`\n }\n \n-pub fn construct(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n+pub(super) fn construct(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n \n@@ -103,9 +104,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let init_exit = self.opt_expr(&local.init, pred);\n                 self.pat(&local.pat, init_exit)\n             }\n-            hir::StmtKind::Item(_) => {\n-                pred\n-            }\n+            hir::StmtKind::Item(_) => pred,\n             hir::StmtKind::Expr(ref expr) |\n             hir::StmtKind::Semi(ref expr) => {\n                 self.expr(&expr, pred)\n@@ -154,12 +153,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn pats_all<'b, I: Iterator<Item=&'b P<hir::Pat>>>(\n+    /// Handles case where all of the patterns must match.\n+    fn pats_all<'b, I: Iterator<Item = &'b P<hir::Pat>>>(\n         &mut self,\n         pats: I,\n-        pred: CFGIndex\n+        pred: CFGIndex,\n     ) -> CFGIndex {\n-        //! Handles case where all of the patterns must match.\n         pats.fold(pred, |pred, pat| self.pat(&pat, pred))\n     }\n \n@@ -185,15 +184,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Note that `break` and `loop` statements\n                 // may cause additional edges.\n \n-                let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]);          // 2\n+                let loopback = self.add_dummy_node(&[pred]); // 1\n+                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]); // 2\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.hir_id.local_id,\n                     continue_index: loopback,\n                     break_index: expr_exit,\n                 });\n-                let body_exit = self.block(&body, loopback);           // 3\n-                self.add_contained_edge(body_exit, loopback);            // 4\n+                let body_exit = self.block(&body, loopback); // 3\n+                self.add_contained_edge(body_exit, loopback); // 4\n                 self.loop_scopes.pop();\n                 expr_exit\n             }\n@@ -217,9 +216,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 3  v 4\n                 //   [..exit..]\n                 //\n-                let l_exit = self.expr(&l, pred);                      // 1\n-                let r_exit = self.expr(&r, l_exit);                    // 2\n-                self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit])            // 3,4\n+                let l_exit = self.expr(&l, pred); // 1\n+                let r_exit = self.expr(&r, l_exit); // 2\n+                self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit]) // 3,4\n             }\n \n             hir::ExprKind::Ret(ref v) => {\n@@ -313,11 +312,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn call<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n-            call_expr: &hir::Expr,\n-            pred: CFGIndex,\n-            func_or_rcvr: &hir::Expr,\n-            args: I) -> CFGIndex {\n+    fn call<'b, I: Iterator<Item = &'b hir::Expr>>(\n+        &mut self,\n+        call_expr: &hir::Expr,\n+        pred: CFGIndex,\n+        func_or_rcvr: &hir::Expr,\n+        args: I,\n+    ) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n         let m = self.tcx.hir().get_module_parent(call_expr.hir_id);\n@@ -328,33 +329,38 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn exprs<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n-                                             exprs: I,\n-                                             pred: CFGIndex) -> CFGIndex {\n-        //! Constructs graph for `exprs` evaluated in order\n+    /// Constructs graph for `exprs` evaluated in order.\n+    fn exprs<'b, I: Iterator<Item = &'b hir::Expr>>(\n+        &mut self,\n+        exprs: I,\n+        pred: CFGIndex,\n+    ) -> CFGIndex {\n         exprs.fold(pred, |p, e| self.expr(e, p))\n     }\n \n-    fn opt_expr(&mut self,\n-                opt_expr: &Option<P<hir::Expr>>,\n-                pred: CFGIndex) -> CFGIndex {\n-        //! Constructs graph for `opt_expr` evaluated, if Some\n+    /// Constructs graph for `opt_expr` evaluated, if `Some`.\n+    fn opt_expr(\n+        &mut self,\n+        opt_expr: &Option<P<hir::Expr>>,\n+        pred: CFGIndex,\n+    ) -> CFGIndex {\n         opt_expr.iter().fold(pred, |p, e| self.expr(&e, p))\n     }\n \n-    fn straightline<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n-                    expr: &hir::Expr,\n-                    pred: CFGIndex,\n-                    subexprs: I) -> CFGIndex {\n-        //! Handles case of an expression that evaluates `subexprs` in order\n-\n+    /// Handles case of an expression that evaluates `subexprs` in order.\n+    fn straightline<'b, I: Iterator<Item = &'b hir::Expr>>(\n+        &mut self,\n+        expr: &hir::Expr,\n+        pred: CFGIndex,\n+        subexprs: I,\n+    ) -> CFGIndex {\n         let subexprs_exit = self.exprs(subexprs, pred);\n         self.add_ast_node(expr.hir_id.local_id, &[subexprs_exit])\n     }\n \n     fn match_(&mut self, id: hir::ItemLocalId, discr: &hir::Expr,\n               arms: &[hir::Arm], pred: CFGIndex) -> CFGIndex {\n-        // The CFG for match expression is quite complex, so no ASCII\n+        // The CFG for match expressions is quite complex, so no ASCII\n         // art for it (yet).\n         //\n         // The CFG generated below matches roughly what MIR contains.\n@@ -369,13 +375,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         //\n         // What is going on is explained in further comments.\n \n-        // Visit the discriminant expression\n+        // Visit the discriminant expression.\n         let discr_exit = self.expr(discr, pred);\n \n         // Add a node for the exit of the match expression as a whole.\n         let expr_exit = self.add_ast_node(id, &[]);\n \n-        // Keep track of the previous guard expressions\n+        // Keep track of the previous guard expressions.\n         let mut prev_guard = None;\n         let match_scope = region::Scope { id, data: region::ScopeData::Node };\n \n@@ -388,12 +394,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Visit the pattern, coming from the discriminant exit\n                 let mut pat_exit = self.pat(&pat, discr_exit);\n \n-                // If there is a guard expression, handle it here\n+                // If there is a guard expression, handle it here.\n                 if let Some(ref guard) = arm.guard {\n                     // Add a dummy node for the previous guard\n-                    // expression to target\n+                    // expression to target.\n                     let guard_start = self.add_dummy_node(&[pat_exit]);\n-                    // Visit the guard expression\n+                    // Visit the guard expression.\n                     let guard_exit = match guard {\n                         hir::Guard::If(ref e) => (&**e, self.expr(e, guard_start)),\n                     };\n@@ -407,24 +413,23 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         self.add_exiting_edge(prev_guard, prev_index, match_scope, guard_start);\n                     }\n \n-                    // Push the guard onto the list of previous guards\n+                    // Push the guard onto the list of previous guards.\n                     prev_guard = Some(guard_exit);\n \n-                    // Update the exit node for the pattern\n+                    // Update the exit node for the pattern.\n                     pat_exit = guard_exit.1;\n                 }\n \n-                // Add an edge from the exit of this pattern to the\n-                // exit of the arm\n+                // Add an edge from the exit of this pattern to the exit of the arm.\n                 self.add_contained_edge(pat_exit, bindings_exit);\n             }\n \n-            // Visit the body of this arm\n+            // Visit the body of this arm.\n             let body_exit = self.expr(&arm.body, bindings_exit);\n \n             let arm_exit = self.add_ast_node(arm.hir_id.local_id, &[body_exit]);\n \n-            // Link the body to the exit of the expression\n+            // Link the body to the exit of the expression.\n             self.add_contained_edge(arm_exit, expr_exit);\n         }\n \n@@ -451,18 +456,22 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         node\n     }\n \n-    fn add_contained_edge(&mut self,\n-                          source: CFGIndex,\n-                          target: CFGIndex) {\n+    fn add_contained_edge(\n+        &mut self,\n+        source: CFGIndex,\n+        target: CFGIndex,\n+    ) {\n         let data = CFGEdgeData {exiting_scopes: vec![] };\n         self.graph.add_edge(source, target, data);\n     }\n \n-    fn add_exiting_edge(&mut self,\n-                        from_expr: &hir::Expr,\n-                        from_index: CFGIndex,\n-                        target_scope: region::Scope,\n-                        to_index: CFGIndex) {\n+    fn add_exiting_edge(\n+        &mut self,\n+        from_expr: &hir::Expr,\n+        from_index: CFGIndex,\n+        target_scope: region::Scope,\n+        to_index: CFGIndex,\n+    ) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n         let mut scope = region::Scope {\n             id: from_expr.hir_id.local_id,\n@@ -476,9 +485,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.graph.add_edge(from_index, to_index, data);\n     }\n \n-    fn add_returning_edge(&mut self,\n-                          _from_expr: &hir::Expr,\n-                          from_index: CFGIndex) {\n+    fn add_returning_edge(\n+        &mut self,\n+        _from_expr: &hir::Expr,\n+        from_index: CFGIndex,\n+    ) {\n         let data = CFGEdgeData {\n             exiting_scopes: self.loop_scopes.iter()\n                                             .rev()\n@@ -488,11 +499,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.graph.add_edge(from_index, self.fn_exit, data);\n     }\n \n-    fn find_scope_edge(&self,\n-                  expr: &hir::Expr,\n-                  destination: hir::Destination,\n-                  scope_cf_kind: ScopeCfKind) -> (region::Scope, CFGIndex) {\n-\n+    fn find_scope_edge(\n+        &self,\n+        expr: &hir::Expr,\n+        destination: hir::Destination,\n+        scope_cf_kind: ScopeCfKind,\n+    ) -> (region::Scope, CFGIndex) {\n         match destination.target_id {\n             Ok(loop_id) => {\n                 for b in &self.breakable_block_scopes {\n@@ -519,7 +531,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         });\n                     }\n                 }\n-                span_bug!(expr.span, \"no scope for id {}\", loop_id);\n+                span_bug!(expr.span, \"no scope for ID {}\", loop_id);\n             }\n             Err(err) => span_bug!(expr.span, \"scope error: {}\",  err),\n         }", "previous_filename": "src/librustc/cfg/construct.rs"}, {"sha": "99c6b49cad5d908f9529d0a5737016a9b8e3a23f", "filename": "src/librustc_ast_borrowck/cfg/graphviz.rs", "status": "renamed", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,21 +1,18 @@\n-/// This module provides linkage between rustc::middle::graph and\n+/// This module provides linkage between `rustc::middle::graph` and\n /// libgraphviz traits.\n \n-// For clarity, rename the graphviz crate locally to dot.\n-use graphviz as dot;\n-\n use crate::cfg;\n-use crate::hir;\n-use crate::ty::TyCtxt;\n+use rustc::hir;\n+use rustc::ty::TyCtxt;\n \n-pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n-pub type Edge<'a> = &'a cfg::CFGEdge;\n+pub(crate) type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n+pub(crate) type Edge<'a> = &'a cfg::CFGEdge;\n \n pub struct LabelledCFG<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n-    /// `labelled_edges` controls whether we emit labels on the edges\n+    /// `labelled_edges` controls whether we emit labels on the edges.\n     pub labelled_edges: bool,\n }\n \n@@ -28,12 +25,12 @@ impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n         };\n         let s = self.tcx.hir().node_to_string(hir_id);\n \n-        // Replacing newlines with \\\\l causes each line to be left-aligned,\n+        // Replacing newlines with `\\\\l` causes each line to be left-aligned,\n         // improving presentation of (long) pretty-printed expressions.\n         if s.contains(\"\\n\") {\n             let mut s = s.replace(\"\\n\", \"\\\\l\");\n             // Apparently left-alignment applies to the line that precedes\n-            // \\l, not the line that follows; so, add \\l at end of string\n+            // `\\l`, not the line that follows; so, add `\\l` at end of string\n             // if not already present, ensuring last line gets left-aligned\n             // as well.\n             let mut last_two: Vec<_> =\n@@ -112,8 +109,7 @@ impl<'a> dot::GraphWalk<'a> for &'a cfg::CFG {\n     }\n }\n \n-impl<'a, 'hir> dot::GraphWalk<'a> for LabelledCFG<'a, 'hir>\n-{\n+impl<'a, 'hir> dot::GraphWalk<'a> for LabelledCFG<'a, 'hir> {\n     type Node = Node<'a>;\n     type Edge = Edge<'a>;\n     fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> { self.cfg.nodes() }", "previous_filename": "src/librustc/cfg/graphviz.rs"}, {"sha": "981199c91d513effe18b18fb911c4ecf593b9728", "filename": "src/librustc_ast_borrowck/cfg/mod.rs", "status": "renamed", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -2,18 +2,18 @@\n //! Uses `Graph` as the underlying representation.\n \n use rustc_data_structures::graph::implementation as graph;\n-use crate::ty::TyCtxt;\n-use crate::hir;\n-use crate::hir::def_id::DefId;\n+use rustc::ty::TyCtxt;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n \n mod construct;\n pub mod graphviz;\n \n pub struct CFG {\n-    pub owner_def_id: DefId,\n-    pub graph: CFGGraph,\n-    pub entry: CFGIndex,\n-    pub exit: CFGIndex,\n+    owner_def_id: DefId,\n+    pub(crate) graph: CFGGraph,\n+    pub(crate) entry: CFGIndex,\n+    exit: CFGIndex,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -26,7 +26,7 @@ pub enum CFGNodeData {\n }\n \n impl CFGNodeData {\n-    pub fn id(&self) -> hir::ItemLocalId {\n+    pub(crate) fn id(&self) -> hir::ItemLocalId {\n         if let CFGNodeData::AST(id) = *self {\n             id\n         } else {\n@@ -37,24 +37,19 @@ impl CFGNodeData {\n \n #[derive(Debug)]\n pub struct CFGEdgeData {\n-    pub exiting_scopes: Vec<hir::ItemLocalId>\n+    pub(crate) exiting_scopes: Vec<hir::ItemLocalId>\n }\n \n-pub type CFGIndex = graph::NodeIndex;\n+pub(crate) type CFGIndex = graph::NodeIndex;\n \n-pub type CFGGraph = graph::Graph<CFGNodeData, CFGEdgeData>;\n+pub(crate) type CFGGraph = graph::Graph<CFGNodeData, CFGEdgeData>;\n \n-pub type CFGNode = graph::Node<CFGNodeData>;\n+pub(crate) type CFGNode = graph::Node<CFGNodeData>;\n \n-pub type CFGEdge = graph::Edge<CFGEdgeData>;\n+pub(crate) type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n     pub fn new(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n         construct::construct(tcx, body)\n     }\n-\n-    pub fn node_is_reachable(&self, id: hir::ItemLocalId) -> bool {\n-        self.graph.depth_traverse(self.entry, graph::OUTGOING)\n-                  .any(|idx| self.graph.node_data(idx).id() == id)\n-    }\n }", "previous_filename": "src/librustc/cfg/mod.rs"}, {"sha": "a8562901d99c5f3c0443db6b6dc6980580533998", "filename": "src/librustc_ast_borrowck/dataflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fdataflow.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -3,9 +3,7 @@\n //! and thus uses bitvectors. Your job is simply to specify the so-called\n //! GEN and KILL bits for each expression.\n \n-use rustc::cfg;\n-use rustc::cfg::CFGIndex;\n-use rustc::ty::TyCtxt;\n+use crate::cfg::{self, CFGIndex};\n use std::mem;\n use std::usize;\n use log::debug;\n@@ -16,6 +14,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::hir::print as pprust;\n+use rustc::ty::TyCtxt;\n \n #[derive(Copy, Clone, Debug)]\n pub enum EntryOrExit {"}, {"sha": "c077dc828aba22b98fe898fee4bd92039bef9832", "filename": "src/librustc_ast_borrowck/graphviz.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -4,13 +4,12 @@\n \n pub use Variant::*;\n \n-pub use rustc::cfg::graphviz::{Node, Edge};\n-use rustc::cfg::graphviz as cfg_dot;\n-\n+pub(crate) use crate::cfg::graphviz::{Node, Edge};\n+use crate::cfg::graphviz as cfg_dot;\n+use crate::cfg::CFGIndex;\n use crate::borrowck::{self, BorrowckCtxt, LoanPath};\n use crate::dataflow::{DataFlowOperator, DataFlowContext, EntryOrExit};\n use log::debug;\n-use rustc::cfg::CFGIndex;\n use std::rc::Rc;\n \n #[derive(Debug, Copy, Clone)]"}, {"sha": "aea97fea1a9fd67d5aeec911beb59e6775e17f5b", "filename": "src/librustc_ast_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_ast_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -18,5 +18,6 @@ mod borrowck;\n pub mod graphviz;\n \n mod dataflow;\n+pub mod cfg;\n \n pub use borrowck::provide;"}, {"sha": "98efa6a5804bd352d4617912ecdaaf58f099df4a", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -11,11 +11,7 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n-cc = \"1.0.1\" # Used to locate MSVC\n-num_cpus = \"1.0\"\n-tempfile = \"3.0\"\n rustc_llvm = { path = \"../librustc_llvm\" }\n-memmap = \"0.6\"\n \n [features]\n # This is used to convince Cargo to separately cache builds of `rustc_codegen_llvm`"}, {"sha": "2ca517dc3b1a7e8319ece659d0e02c43db65bdf7", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -229,7 +229,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 // We instead thus allocate some scratch space...\n                 let scratch_size = cast.size(bx);\n                 let scratch_align = cast.align(bx);\n-                let llscratch = bx.alloca(cast.llvm_type(bx), \"abi_cast\", scratch_align);\n+                let llscratch = bx.alloca(cast.llvm_type(bx), scratch_align);\n                 bx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value..."}, {"sha": "68d3f90cd3991160e18b6c656d1588a3dc771547", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -12,6 +12,7 @@ use crate::llvm::{self, ArchiveKind};\n use rustc_codegen_ssa::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION};\n use rustc_codegen_ssa::back::archive::{ArchiveBuilder, find_library};\n use rustc::session::Session;\n+use syntax::symbol::Symbol;\n \n struct ArchiveConfig<'a> {\n     pub sess: &'a Session,\n@@ -109,7 +110,7 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n \n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n-    fn add_native_library(&mut self, name: &str) {\n+    fn add_native_library(&mut self, name: Symbol) {\n         let location = find_library(name, &self.config.lib_search_paths,\n                                     self.config.sess);\n         self.add_archive(&location, |_| false).unwrap_or_else(|e| {"}, {"sha": "423a01ad1f9374a6da0a7f61b914bbe6434f4a86", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -387,23 +387,17 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         )\n     }\n \n-    fn alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         let mut bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n-        bx.dynamic_alloca(ty, name, align)\n+        bx.dynamic_alloca(ty, align)\n     }\n \n-    fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn dynamic_alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = if name.is_empty() {\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED)\n-            } else {\n-                let name = SmallCStr::new(name);\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty,\n-                                      name.as_ptr())\n-            };\n+            let alloca = llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }\n@@ -412,16 +406,9 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn array_alloca(&mut self,\n                         ty: &'ll Type,\n                         len: &'ll Value,\n-                        name: &str,\n                         align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = if name.is_empty() {\n-                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED)\n-            } else {\n-                let name = SmallCStr::new(name);\n-                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len,\n-                                           name.as_ptr())\n-            };\n+            let alloca = llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }"}, {"sha": "6dedf10f0ab837e41fb5f3094e02c757df62868a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -32,7 +32,7 @@ use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, MirDebugScope, Variable\n \n use libc::c_uint;\n use std::cell::RefCell;\n-use std::ffi::CString;\n+use std::ffi::{CStr, CString};\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n@@ -224,8 +224,37 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         gdb::insert_reference_to_gdb_debug_scripts_section_global(self)\n     }\n \n-    fn set_value_name(&mut self, value: &'ll Value, name: &str) {\n-        let cname = SmallCStr::new(name);\n+    fn set_var_name(&mut self, value: &'ll Value, name: impl ToString) {\n+        // Avoid wasting time if LLVM value names aren't even enabled.\n+        if self.sess().fewer_names() {\n+            return;\n+        }\n+\n+        // Only function parameters and instructions are local to a function,\n+        // don't change the name of anything else (e.g. globals).\n+        let param_or_inst = unsafe {\n+            llvm::LLVMIsAArgument(value).is_some() ||\n+            llvm::LLVMIsAInstruction(value).is_some()\n+        };\n+        if !param_or_inst {\n+            return;\n+        }\n+\n+        let old_name = unsafe {\n+            CStr::from_ptr(llvm::LLVMGetValueName(value))\n+        };\n+        match old_name.to_str() {\n+            Ok(\"\") => {}\n+            Ok(_) => {\n+                // Avoid replacing the name if it already exists.\n+                // While we could combine the names somehow, it'd\n+                // get noisy quick, and the usefulness is dubious.\n+                return;\n+            }\n+            Err(_) => return,\n+        }\n+\n+        let cname = CString::new(name.to_string()).unwrap();\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }"}, {"sha": "042e51ed2ba7a4e95e0f4bacd7e16142947df71c", "filename": "src/librustc_codegen_llvm/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,4 +1,4 @@\n-register_long_diagnostics! {\n+register_diagnostics! {\n \n E0511: r##\"\n Invalid monomorphization of an intrinsic function was used. Erroneous code"}, {"sha": "3f3c5ac1460a315d17bc8ced0c0fd1ce271c5652", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -15,6 +15,7 @@ use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::base::{to_immediate, wants_msvc_seh, compare_simd_types};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, Primitive};\n+use rustc::mir::interpret::GlobalId;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n use syntax::ast::{self, FloatTy};\n@@ -81,13 +82,14 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Valu\n impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn codegen_intrinsic_call(\n         &mut self,\n-        callee_ty: Ty<'tcx>,\n+        instance: ty::Instance<'tcx>,\n         fn_ty: &FnType<'tcx, Ty<'tcx>>,\n         args: &[OperandRef<'tcx, &'ll Value>],\n         llresult: &'ll Value,\n         span: Span,\n     ) {\n         let tcx = self.tcx;\n+        let callee_ty = instance.ty(tcx);\n \n         let (def_id, substs) = match callee_ty.sty {\n             ty::FnDef(def_id, substs) => (def_id, substs),\n@@ -133,10 +135,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n                 self.call(llfn, &[], None)\n             }\n-            \"size_of\" => {\n-                let tp_ty = substs.type_at(0);\n-                self.const_usize(self.size_of(tp_ty).bytes())\n-            }\n             \"va_start\" => {\n                 self.va_start(args[0].immediate())\n             }\n@@ -188,10 +186,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     self.const_usize(self.size_of(tp_ty).bytes())\n                 }\n             }\n-            \"min_align_of\" => {\n-                let tp_ty = substs.type_at(0);\n-                self.const_usize(self.align_of(tp_ty).bytes())\n-            }\n             \"min_align_of_val\" => {\n                 let tp_ty = substs.type_at(0);\n                 if let OperandValue::Pair(_, meta) = args[0].val {\n@@ -201,18 +195,19 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     self.const_usize(self.align_of(tp_ty).bytes())\n                 }\n             }\n-            \"pref_align_of\" => {\n-                let tp_ty = substs.type_at(0);\n-                self.const_usize(self.layout_of(tp_ty).align.pref.bytes())\n-            }\n+            \"size_of\" |\n+            \"pref_align_of\" |\n+            \"min_align_of\" |\n+            \"needs_drop\" |\n+            \"type_id\" |\n             \"type_name\" => {\n-                let tp_ty = substs.type_at(0);\n-                let ty_name = self.tcx.type_name(tp_ty);\n+                let gid = GlobalId {\n+                    instance,\n+                    promoted: None,\n+                };\n+                let ty_name = self.tcx.const_eval(ty::ParamEnv::reveal_all().and(gid)).unwrap();\n                 OperandRef::from_const(self, ty_name).immediate_or_packed_pair(self)\n             }\n-            \"type_id\" => {\n-                self.const_u64(self.tcx.type_id_hash(substs.type_at(0)))\n-            }\n             \"init\" => {\n                 let ty = substs.type_at(0);\n                 if !self.layout_of(ty).is_zst() {\n@@ -235,11 +230,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             \"uninit\" | \"forget\" => {\n                 return;\n             }\n-            \"needs_drop\" => {\n-                let tp_ty = substs.type_at(0);\n-\n-                self.const_bool(self.type_needs_drop(tp_ty))\n-            }\n             \"offset\" => {\n                 let ptr = args[0].immediate();\n                 let offset = args[1].immediate();\n@@ -871,7 +861,7 @@ fn codegen_msvc_try(\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = bx.type_ptr_to(bx.type_i64());\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let slot = bx.alloca(i64p, \"slot\", ptr_align);\n+        let slot = bx.alloca(i64p, ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));"}, {"sha": "34e39af3c39fcda98ca756257ee78f3dfd9ea24f", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -14,7 +14,6 @@\n #![feature(in_band_lifetimes)]\n #![feature(libc)]\n #![feature(nll)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(optin_builtin_traits)]\n #![feature(concat_idents)]\n #![feature(link_args)]\n@@ -227,21 +226,21 @@ impl CodegenBackend for LlvmCodegenBackend {\n                 for &(name, _) in back::write::RELOC_MODEL_ARGS.iter() {\n                     println!(\"    {}\", name);\n                 }\n-                println!(\"\");\n+                println!();\n             }\n             PrintRequest::CodeModels => {\n                 println!(\"Available code models:\");\n                 for &(name, _) in back::write::CODE_GEN_MODEL_ARGS.iter(){\n                     println!(\"    {}\", name);\n                 }\n-                println!(\"\");\n+                println!();\n             }\n             PrintRequest::TlsModels => {\n                 println!(\"Available TLS models:\");\n                 for &(name, _) in back::write::TLS_MODEL_ARGS.iter(){\n                     println!(\"    {}\", name);\n                 }\n-                println!(\"\");\n+                println!();\n             }\n             req => llvm_util::print(req, sess),\n         }\n@@ -256,7 +255,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n     }\n \n     fn diagnostics(&self) -> &[(&'static str, &'static str)] {\n-        &DIAGNOSTICS\n+        &error_codes::DIAGNOSTICS\n     }\n \n     fn target_features(&self, sess: &Session) -> Vec<Symbol> {\n@@ -425,5 +424,3 @@ impl Drop for ModuleLlvm {\n         }\n     }\n }\n-\n-__build_diagnostic_array! { librustc_codegen_llvm, DIAGNOSTICS }"}, {"sha": "b07214fdc03f3c22b4f93d2e462369ca87cd1bff", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -806,6 +806,7 @@ extern \"C\" {\n     pub fn LLVMRustRemoveFunctionAttributes(Fn: &Value, index: c_uint, attr: Attribute);\n \n     // Operations on parameters\n+    pub fn LLVMIsAArgument(Val: &Value) -> Option<&Value>;\n     pub fn LLVMCountParams(Fn: &Value) -> c_uint;\n     pub fn LLVMGetParam(Fn: &Value, Index: c_uint) -> &Value;\n \n@@ -818,6 +819,7 @@ extern \"C\" {\n     pub fn LLVMDeleteBasicBlock(BB: &BasicBlock);\n \n     // Operations on instructions\n+    pub fn LLVMIsAInstruction(Val: &Value) -> Option<&Value>;\n     pub fn LLVMGetFirstBasicBlock(Fn: &Value) -> &BasicBlock;\n \n     // Operations on call sites"}, {"sha": "bc028d6624279b1ba44891167e3c3573f39fb7fd", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -17,8 +17,8 @@ memmap = \"0.6\"\n log = \"0.4.5\"\n libc = \"0.2.44\"\n jobserver = \"0.1.11\"\n-parking_lot = \"0.7\"\n-tempfile = \"3.0.5\"\n+parking_lot = \"0.9\"\n+tempfile = \"3.1\"\n \n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "8d2120a345a8d61ea8015b51408bf41c582022b9", "filename": "src/librustc_codegen_ssa/back/archive.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,9 +1,10 @@\n use rustc::session::Session;\n+use syntax::symbol::Symbol;\n \n use std::io;\n use std::path::{Path, PathBuf};\n \n-pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n+pub fn find_library(name: Symbol, search_paths: &[PathBuf], sess: &Session)\n                     -> PathBuf {\n     // On Windows, static libraries sometimes show up as libfoo.a and other\n     // times show up as foo.lib\n@@ -40,7 +41,7 @@ pub trait ArchiveBuilder<'a> {\n         lto: bool,\n         skip_objects: bool,\n     ) -> io::Result<()>;\n-    fn add_native_library(&mut self, name: &str);\n+    fn add_native_library(&mut self, name: Symbol);\n     fn update_symbols(&mut self);\n \n     fn build(self);"}, {"sha": "2d84d67e3c85bd097a4dc8924005593711fac2bd", "filename": "src/librustc_codegen_ssa/back/command.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -8,12 +8,14 @@ use std::mem;\n use std::process::{self, Output};\n \n use rustc_target::spec::LldFlavor;\n+use syntax::symbol::Symbol;\n \n #[derive(Clone)]\n pub struct Command {\n     program: Program,\n     args: Vec<OsString>,\n     env: Vec<(OsString, OsString)>,\n+    env_remove: Vec<OsString>,\n }\n \n #[derive(Clone)]\n@@ -41,6 +43,7 @@ impl Command {\n             program,\n             args: Vec::new(),\n             env: Vec::new(),\n+            env_remove: Vec::new(),\n         }\n     }\n \n@@ -49,6 +52,11 @@ impl Command {\n         self\n     }\n \n+    pub fn sym_arg(&mut self, arg: Symbol) -> &mut Command {\n+        self.arg(&arg.as_str());\n+        self\n+    }\n+\n     pub fn args<I>(&mut self, args: I) -> &mut Command\n     where\n         I: IntoIterator<Item: AsRef<OsStr>>,\n@@ -75,6 +83,17 @@ impl Command {\n         self.env.push((key.to_owned(), value.to_owned()));\n     }\n \n+    pub fn env_remove<K>(&mut self, key: K) -> &mut Command\n+        where K: AsRef<OsStr>,\n+    {\n+        self._env_remove(key.as_ref());\n+        self\n+    }\n+\n+    fn _env_remove(&mut self, key: &OsStr) {\n+        self.env_remove.push(key.to_owned());\n+    }\n+\n     pub fn output(&mut self) -> io::Result<Output> {\n         self.command().output()\n     }\n@@ -100,6 +119,9 @@ impl Command {\n         };\n         ret.args(&self.args);\n         ret.envs(self.env.clone());\n+        for k in &self.env_remove {\n+            ret.env_remove(k);\n+        }\n         return ret\n     }\n "}, {"sha": "9b044d9b45377c03d750082ab7da1b0d09689ae3", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -13,6 +13,7 @@ use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_target::spec::{PanicStrategy, RelroLevel, LinkerFlavor};\n+use syntax::symbol::Symbol;\n \n use crate::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION, CrateInfo, CodegenResults};\n use super::archive::ArchiveBuilder;\n@@ -316,7 +317,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             NativeLibraryKind::NativeUnknown => continue,\n         }\n         if let Some(name) = lib.name {\n-            ab.add_native_library(&name.as_str());\n+            ab.add_native_library(name);\n         }\n     }\n \n@@ -532,6 +533,9 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n     for &(ref k, ref v) in &sess.target.target.options.link_env {\n         cmd.env(k, v);\n     }\n+    for k in &sess.target.target.options.link_env_remove {\n+        cmd.env_remove(k);\n+    }\n \n     if sess.opts.debugging_opts.print_link_args {\n         println!(\"{:?}\", &cmd);\n@@ -1273,15 +1277,14 @@ pub fn add_local_native_libraries(cmd: &mut dyn Linker,\n     let search_path = archive_search_paths(sess);\n     for lib in relevant_libs {\n         let name = match lib.name {\n-            Some(ref l) => l,\n+            Some(l) => l,\n             None => continue,\n         };\n         match lib.kind {\n-            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n-            NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n-            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&name.as_str()),\n-            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&name.as_str(),\n-                                                                        &search_path)\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(name),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(name),\n+            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(name),\n+            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(name, &search_path)\n         }\n     }\n }\n@@ -1594,7 +1597,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n             cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n         }\n         let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.link_rust_dylib(&unlib(&sess.target, filestem),\n+        cmd.link_rust_dylib(Symbol::intern(&unlib(&sess.target, filestem)),\n                             parent.unwrap_or(Path::new(\"\")));\n     }\n }\n@@ -1637,22 +1640,22 @@ pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n     for &(cnum, _) in crates {\n         for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n             let name = match lib.name {\n-                Some(ref l) => l,\n+                Some(l) => l,\n                 None => continue,\n             };\n             if !relevant_lib(sess, &lib) {\n                 continue\n             }\n             match lib.kind {\n-                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n-                NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(name),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(name),\n                 NativeLibraryKind::NativeStaticNobundle => {\n                     // Link \"static-nobundle\" native libs only if the crate they originate from\n                     // is being linked statically to the current crate.  If it's linked dynamically\n                     // or is an rlib already included via some other dylib crate, the symbols from\n                     // native libs will have already been included in that dylib.\n                     if data[cnum.as_usize() - 1] == Linkage::Static {\n-                        cmd.link_staticlib(&name.as_str())\n+                        cmd.link_staticlib(name)\n                     }\n                 },\n                 // ignore statically included native libraries here as we've"}, {"sha": "c42cd024926dc71f21444c13fab5e12865d9cb58", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -17,6 +17,7 @@ use rustc::session::config::{self, CrateType, OptLevel, DebugInfo,\n use rustc::ty::TyCtxt;\n use rustc_target::spec::{LinkerFlavor, LldFlavor};\n use rustc_serialize::{json, Encoder};\n+use syntax::symbol::Symbol;\n \n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n@@ -99,13 +100,13 @@ impl LinkerInfo {\n /// used to dispatch on whether a GNU-like linker (generally `ld.exe`) or an\n /// MSVC linker (e.g., `link.exe`) is being used.\n pub trait Linker {\n-    fn link_dylib(&mut self, lib: &str);\n-    fn link_rust_dylib(&mut self, lib: &str, path: &Path);\n-    fn link_framework(&mut self, framework: &str);\n-    fn link_staticlib(&mut self, lib: &str);\n+    fn link_dylib(&mut self, lib: Symbol);\n+    fn link_rust_dylib(&mut self, lib: Symbol, path: &Path);\n+    fn link_framework(&mut self, framework: Symbol);\n+    fn link_staticlib(&mut self, lib: Symbol);\n     fn link_rlib(&mut self, lib: &Path);\n     fn link_whole_rlib(&mut self, lib: &Path);\n-    fn link_whole_staticlib(&mut self, lib: &str, search_path: &[PathBuf]);\n+    fn link_whole_staticlib(&mut self, lib: Symbol, search_path: &[PathBuf]);\n     fn include_path(&mut self, path: &Path);\n     fn framework_path(&mut self, path: &Path);\n     fn output_filename(&mut self, path: &Path);\n@@ -215,9 +216,13 @@ impl<'a> GccLinker<'a> {\n }\n \n impl<'a> Linker for GccLinker<'a> {\n-    fn link_dylib(&mut self, lib: &str) { self.hint_dynamic(); self.cmd.arg(format!(\"-l{}\", lib)); }\n-    fn link_staticlib(&mut self, lib: &str) {\n-        self.hint_static(); self.cmd.arg(format!(\"-l{}\", lib));\n+    fn link_dylib(&mut self, lib: Symbol) {\n+        self.hint_dynamic();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n+    }\n+    fn link_staticlib(&mut self, lib: Symbol) {\n+        self.hint_static();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n     }\n     fn link_rlib(&mut self, lib: &Path) { self.hint_static(); self.cmd.arg(lib); }\n     fn include_path(&mut self, path: &Path) { self.cmd.arg(\"-L\").arg(path); }\n@@ -232,14 +237,14 @@ impl<'a> Linker for GccLinker<'a> {\n     fn build_static_executable(&mut self) { self.cmd.arg(\"-static\"); }\n     fn args(&mut self, args: &[String]) { self.cmd.args(args); }\n \n-    fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n+    fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.hint_dynamic();\n         self.cmd.arg(format!(\"-l{}\", lib));\n     }\n \n-    fn link_framework(&mut self, framework: &str) {\n+    fn link_framework(&mut self, framework: Symbol) {\n         self.hint_dynamic();\n-        self.cmd.arg(\"-framework\").arg(framework);\n+        self.cmd.arg(\"-framework\").sym_arg(framework);\n     }\n \n     // Here we explicitly ask that the entire archive is included into the\n@@ -248,7 +253,7 @@ impl<'a> Linker for GccLinker<'a> {\n     // don't otherwise explicitly reference them. This can occur for\n     // libraries which are just providing bindings, libraries with generic\n     // functions, etc.\n-    fn link_whole_staticlib(&mut self, lib: &str, search_path: &[PathBuf]) {\n+    fn link_whole_staticlib(&mut self, lib: Symbol, search_path: &[PathBuf]) {\n         self.hint_static();\n         let target = &self.sess.target.target;\n         if !target.options.is_like_osx {\n@@ -539,11 +544,11 @@ impl<'a> Linker for MsvcLinker<'a> {\n         }\n     }\n \n-    fn link_dylib(&mut self, lib: &str) {\n+    fn link_dylib(&mut self, lib: Symbol) {\n         self.cmd.arg(&format!(\"{}.lib\", lib));\n     }\n \n-    fn link_rust_dylib(&mut self, lib: &str, path: &Path) {\n+    fn link_rust_dylib(&mut self, lib: Symbol, path: &Path) {\n         // When producing a dll, the MSVC linker may not actually emit a\n         // `foo.lib` file if the dll doesn't actually export any symbols, so we\n         // check to see if the file is there and just omit linking to it if it's\n@@ -554,7 +559,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n         }\n     }\n \n-    fn link_staticlib(&mut self, lib: &str) {\n+    fn link_staticlib(&mut self, lib: Symbol) {\n         self.cmd.arg(&format!(\"{}.lib\", lib));\n     }\n \n@@ -605,11 +610,11 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn framework_path(&mut self, _path: &Path) {\n         bug!(\"frameworks are not supported on windows\")\n     }\n-    fn link_framework(&mut self, _framework: &str) {\n+    fn link_framework(&mut self, _framework: Symbol) {\n         bug!(\"frameworks are not supported on windows\")\n     }\n \n-    fn link_whole_staticlib(&mut self, lib: &str, _search_path: &[PathBuf]) {\n+    fn link_whole_staticlib(&mut self, lib: Symbol, _search_path: &[PathBuf]) {\n         // not supported?\n         self.link_staticlib(lib);\n     }\n@@ -740,8 +745,8 @@ impl<'a> Linker for EmLinker<'a> {\n         self.cmd.arg(\"-L\").arg(path);\n     }\n \n-    fn link_staticlib(&mut self, lib: &str) {\n-        self.cmd.arg(\"-l\").arg(lib);\n+    fn link_staticlib(&mut self, lib: Symbol) {\n+        self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n \n     fn output_filename(&mut self, path: &Path) {\n@@ -752,12 +757,12 @@ impl<'a> Linker for EmLinker<'a> {\n         self.cmd.arg(path);\n     }\n \n-    fn link_dylib(&mut self, lib: &str) {\n+    fn link_dylib(&mut self, lib: Symbol) {\n         // Emscripten always links statically\n         self.link_staticlib(lib);\n     }\n \n-    fn link_whole_staticlib(&mut self, lib: &str, _search_path: &[PathBuf]) {\n+    fn link_whole_staticlib(&mut self, lib: Symbol, _search_path: &[PathBuf]) {\n         // not supported?\n         self.link_staticlib(lib);\n     }\n@@ -767,7 +772,7 @@ impl<'a> Linker for EmLinker<'a> {\n         self.link_rlib(lib);\n     }\n \n-    fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n+    fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.link_dylib(lib);\n     }\n \n@@ -803,7 +808,7 @@ impl<'a> Linker for EmLinker<'a> {\n         bug!(\"frameworks are not supported on Emscripten\")\n     }\n \n-    fn link_framework(&mut self, _framework: &str) {\n+    fn link_framework(&mut self, _framework: Symbol) {\n         bug!(\"frameworks are not supported on Emscripten\")\n     }\n \n@@ -948,12 +953,12 @@ impl<'a> WasmLd<'a> {\n }\n \n impl<'a> Linker for WasmLd<'a> {\n-    fn link_dylib(&mut self, lib: &str) {\n-        self.cmd.arg(\"-l\").arg(lib);\n+    fn link_dylib(&mut self, lib: Symbol) {\n+        self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n \n-    fn link_staticlib(&mut self, lib: &str) {\n-        self.cmd.arg(\"-l\").arg(lib);\n+    fn link_staticlib(&mut self, lib: Symbol) {\n+        self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n \n     fn link_rlib(&mut self, lib: &Path) {\n@@ -995,16 +1000,16 @@ impl<'a> Linker for WasmLd<'a> {\n         self.cmd.args(args);\n     }\n \n-    fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n-        self.cmd.arg(\"-l\").arg(lib);\n+    fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n+        self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n \n-    fn link_framework(&mut self, _framework: &str) {\n+    fn link_framework(&mut self, _framework: Symbol) {\n         panic!(\"frameworks not supported\")\n     }\n \n-    fn link_whole_staticlib(&mut self, lib: &str, _search_path: &[PathBuf]) {\n-        self.cmd.arg(\"-l\").arg(lib);\n+    fn link_whole_staticlib(&mut self, lib: Symbol, _search_path: &[PathBuf]) {\n+        self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n \n     fn link_whole_rlib(&mut self, lib: &Path) {\n@@ -1162,27 +1167,27 @@ impl<'a> Linker for PtxLinker<'a> {\n         ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n-    fn link_dylib(&mut self, _lib: &str) {\n+    fn link_dylib(&mut self, _lib: Symbol) {\n         panic!(\"external dylibs not supported\")\n     }\n \n-    fn link_rust_dylib(&mut self, _lib: &str, _path: &Path) {\n+    fn link_rust_dylib(&mut self, _lib: Symbol, _path: &Path) {\n         panic!(\"external dylibs not supported\")\n     }\n \n-    fn link_staticlib(&mut self, _lib: &str) {\n+    fn link_staticlib(&mut self, _lib: Symbol) {\n         panic!(\"staticlibs not supported\")\n     }\n \n-    fn link_whole_staticlib(&mut self, _lib: &str, _search_path: &[PathBuf]) {\n+    fn link_whole_staticlib(&mut self, _lib: Symbol, _search_path: &[PathBuf]) {\n         panic!(\"staticlibs not supported\")\n     }\n \n     fn framework_path(&mut self, _path: &Path) {\n         panic!(\"frameworks not supported\")\n     }\n \n-    fn link_framework(&mut self, _framework: &str) {\n+    fn link_framework(&mut self, _framework: Symbol) {\n         panic!(\"frameworks not supported\")\n     }\n "}, {"sha": "8ff41c275a8f45283e387847e7d5861dd3abd94b", "filename": "src/librustc_codegen_ssa/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,4 +1,4 @@\n-register_long_diagnostics! {\n+syntax::register_diagnostics! {\n \n E0668: r##\"\n Malformed inline assembly rejected by LLVM."}, {"sha": "1708d7235b45b1d56badb6b3d7288d32b2bca6f4", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -4,7 +4,7 @@\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(libc)]\n-#![feature(rustc_diagnostic_macros)]\n+#![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n@@ -35,8 +35,6 @@ use rustc_data_structures::svh::Svh;\n use rustc::middle::cstore::{LibSource, CrateSource, NativeLibrary};\n use syntax_pos::symbol::Symbol;\n \n-// N.B., this module needs to be declared first so diagnostics are\n-// registered before they are used.\n mod error_codes;\n \n pub mod common;\n@@ -158,5 +156,3 @@ pub struct CodegenResults {\n     pub linker_info: back::linker::LinkerInfo,\n     pub crate_info: CrateInfo,\n }\n-\n-__build_diagnostic_array! { librustc_codegen_ssa, DIAGNOSTICS }"}, {"sha": "d192f2ffb6fba8bddd54076d55752fb9f30e2998", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -105,7 +105,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n     ) {\n         let cx = self.fx.cx;\n \n-        if let Some(proj) = place_ref.projection {\n+        if let [proj_base @ .., elem] = place_ref.projection {\n             // Allow uses of projections that are ZSTs or from scalar fields.\n             let is_consume = match context {\n                 PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n@@ -114,12 +114,12 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, &proj.base, self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.base, proj_base, self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty\n-                    .projection_ty(cx.tcx(), &proj.elem)\n+                    .projection_ty(cx.tcx(), elem)\n                     .ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 let span = if let mir::PlaceBase::Local(index) = place_ref.base {\n@@ -131,7 +131,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                     return;\n                 }\n \n-                if let mir::ProjectionElem::Field(..) = proj.elem {\n+                if let mir::ProjectionElem::Field(..) = elem {\n                     let layout = cx.spanned_layout_of(base_ty.ty, span);\n                     if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n                         // Recurse with the same context, instead of `Projection`,\n@@ -140,7 +140,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                         self.process_place(\n                             &mir::PlaceRef {\n                                 base: place_ref.base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             context,\n                             location,\n@@ -151,11 +151,11 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             }\n \n             // A deref projection only reads the pointer, never needs the place.\n-            if let mir::ProjectionElem::Deref = proj.elem {\n+            if let mir::ProjectionElem::Deref = elem {\n                 self.process_place(\n                     &mir::PlaceRef {\n                         base: place_ref.base,\n-                        projection: &proj.base,\n+                        projection: proj_base,\n                     },\n                     PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                     location\n@@ -168,7 +168,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n         // visit_place API\n         let mut context = context;\n \n-        if place_ref.projection.is_some() {\n+        if !place_ref.projection.is_empty() {\n             context = if context.is_mutating_use() {\n                 PlaceContext::MutatingUse(MutatingUseContext::Projection)\n             } else {\n@@ -177,10 +177,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n         }\n \n         self.visit_place_base(place_ref.base, context, location);\n-\n-        if let Some(box proj) = place_ref.projection {\n-            self.visit_projection(place_ref.base, proj, context, location);\n-        }\n+        self.visit_projection(place_ref.base, place_ref.projection, context, location);\n     }\n \n }\n@@ -196,7 +193,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n \n         if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *place {\n             self.assign(index, location);\n             let decl_span = self.fx.mir.local_decls[index].source_info.span;"}, {"sha": "1bb0ea5dae44b4c21676fee9955281a6e7490725", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 let op =\n-                    self.codegen_consume(&mut bx, &mir::Place::RETURN_PLACE.as_ref());\n+                    self.codegen_consume(&mut bx, &mir::Place::return_place().as_ref());\n                 if let Ref(llval, _, align) = op.val {\n                     bx.load(llval, align)\n                 } else {\n@@ -276,7 +276,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let llslot = match op.val {\n                     Immediate(_) | Pair(..) => {\n                         let scratch =\n-                            PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout, \"ret\");\n+                            PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout);\n                         op.val.store(&mut bx, scratch);\n                         scratch.llval\n                     }\n@@ -612,7 +612,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     ty,\n                                     def_id: _,\n                                 }),\n-                                projection: None,\n+                                projection: box [],\n                             }\n                         ) |\n                         mir::Operand::Move(\n@@ -622,7 +622,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     ty,\n                                     def_id: _,\n                                 }),\n-                                projection: None,\n+                                projection: box [],\n                             }\n                         ) => {\n                             let param_env = ty::ParamEnv::reveal_all();\n@@ -667,8 +667,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }).collect();\n \n \n-            let callee_ty = instance.as_ref().unwrap().ty(bx.tcx());\n-            bx.codegen_intrinsic_call(callee_ty, &fn_ty, &args, dest,\n+            bx.codegen_intrinsic_call(*instance.as_ref().unwrap(), &fn_ty, &args, dest,\n                                       terminator.source_info.span);\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -767,7 +766,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             match (arg, op.val) {\n                 (&mir::Operand::Copy(_), Ref(_, None, _)) |\n                 (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n-                    let tmp = PlaceRef::alloca(&mut bx, op.layout, \"const\");\n+                    let tmp = PlaceRef::alloca(&mut bx, op.layout);\n                     op.val.store(&mut bx, tmp);\n                     op.val = Ref(tmp.llval, None, tmp.align);\n                 }\n@@ -925,7 +924,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Immediate(_) | Pair(..) => {\n                 match arg.mode {\n                     PassMode::Indirect(..) | PassMode::Cast(_) => {\n-                        let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n+                        let scratch = PlaceRef::alloca(bx, arg.layout);\n                         op.val.store(bx, scratch);\n                         (scratch.llval, scratch.align, true)\n                     }\n@@ -940,7 +939,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                     // have scary latent bugs around.\n \n-                    let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n+                    let scratch = PlaceRef::alloca(bx, arg.layout);\n                     base::memcpy_ty(bx, scratch.llval, scratch.align, llval, align,\n                                     op.layout, MemFlags::empty());\n                     (scratch.llval, scratch.align, true)\n@@ -1017,7 +1016,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n                 cx.tcx().types.i32\n             ]));\n-            let slot = PlaceRef::alloca(bx, layout, \"personalityslot\");\n+            let slot = PlaceRef::alloca(bx, layout);\n             self.personality_slot = Some(slot);\n             slot\n         }\n@@ -1105,7 +1104,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n         let dest = if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *dest {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n@@ -1116,15 +1115,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n+                        let tmp = PlaceRef::alloca(bx, fn_ret.layout);\n                         tmp.storage_live(bx);\n                         llargs.push(tmp.llval);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result, so we create a temporary `alloca` for the\n                         // result.\n-                        let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n+                        let tmp = PlaceRef::alloca(bx, fn_ret.layout);\n                         tmp.storage_live(bx);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n@@ -1166,15 +1165,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) {\n         if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n                 LocalRef::Operand(None) => {\n                     let dst_layout = bx.layout_of(self.monomorphized_place_ty(&dst.as_ref()));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n-                    let place = PlaceRef::alloca(bx, dst_layout, \"transmute_temp\");\n+                    let place = PlaceRef::alloca(bx, dst_layout);\n                     place.storage_live(bx);\n                     self.codegen_transmute_into(bx, src, place);\n                     let op = bx.load_operand(place);\n@@ -1227,7 +1226,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if let PassMode::Cast(_) = ret_ty.mode {\n-                    let tmp = PlaceRef::alloca(bx, ret_ty.layout, \"tmp_ret\");\n+                    let tmp = PlaceRef::alloca(bx, ret_ty.layout);\n                     tmp.storage_live(bx);\n                     bx.store_arg_ty(&ret_ty, llval, tmp);\n                     let op = bx.load_operand(tmp);"}, {"sha": "aa3971a1da81aa0f14c5df0e1c4395d73c4eeeed", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -268,11 +268,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n                 if layout.is_unsized() {\n                     let indirect_place =\n-                        PlaceRef::alloca_unsized_indirect(&mut bx, layout, &name.as_str());\n+                        PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n+                    bx.set_var_name(indirect_place.llval, name);\n                     // FIXME: add an appropriate debuginfo\n                     LocalRef::UnsizedPlace(indirect_place)\n                 } else {\n-                    let place = PlaceRef::alloca(&mut bx, layout, &name.as_str());\n+                    let place = PlaceRef::alloca(&mut bx, layout);\n+                    bx.set_var_name(place.llval, name);\n                     if dbg {\n                         let (scope, span) = fx.debug_loc(mir::SourceInfo {\n                             span: decl.source_info.span,\n@@ -293,14 +295,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     if layout.is_unsized() {\n-                        let indirect_place = PlaceRef::alloca_unsized_indirect(\n-                            &mut bx,\n-                            layout,\n-                            &format!(\"{:?}\", local),\n-                        );\n+                        let indirect_place = PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n+                        bx.set_var_name(indirect_place.llval, format_args!(\"{:?}\", local));\n                         LocalRef::UnsizedPlace(indirect_place)\n                     } else {\n-                        LocalRef::Place(PlaceRef::alloca(&mut bx, layout, &format!(\"{:?}\", local)))\n+                        let place = PlaceRef::alloca(&mut bx, layout);\n+                        bx.set_var_name(place.llval, format_args!(\"{:?}\", local));\n+                        LocalRef::Place(place)\n                     }\n                 } else {\n                     // If this is an immediate local, we do not create an\n@@ -452,10 +453,11 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n \n+        // FIXME(eddyb) don't allocate a `String` unless it gets used.\n         let name = if let Some(name) = arg_decl.name {\n             name.as_str().to_string()\n         } else {\n-            format!(\"arg{}\", arg_index)\n+            format!(\"{:?}\", local)\n         };\n \n         if Some(local) == mir.spread_arg {\n@@ -470,7 +472,8 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty), &name);\n+            let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n+            bx.set_var_name(place.llval, name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &fx.fn_ty.args[idx];\n                 idx += 1;\n@@ -518,19 +521,19 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 PassMode::Ignore(IgnoreMode::CVarArgs) => {}\n                 PassMode::Direct(_) => {\n                     let llarg = bx.get_param(llarg_idx);\n-                    bx.set_value_name(llarg, &name);\n+                    bx.set_var_name(llarg, &name);\n                     llarg_idx += 1;\n                     return local(\n                         OperandRef::from_immediate_or_packed_pair(bx, llarg, arg.layout));\n                 }\n                 PassMode::Pair(..) => {\n-                    let a = bx.get_param(llarg_idx);\n-                    bx.set_value_name(a, &(name.clone() + \".0\"));\n-                    llarg_idx += 1;\n+                    let (a, b) = (bx.get_param(llarg_idx), bx.get_param(llarg_idx + 1));\n+                    llarg_idx += 2;\n \n-                    let b = bx.get_param(llarg_idx);\n-                    bx.set_value_name(b, &(name + \".1\"));\n-                    llarg_idx += 1;\n+                    // FIXME(eddyb) these are scalar components,\n+                    // maybe extract the high-level fields?\n+                    bx.set_var_name(a, format_args!(\"{}.0\", name));\n+                    bx.set_var_name(b, format_args!(\"{}.1\", name));\n \n                     return local(OperandRef {\n                         val: OperandValue::Pair(a, b),\n@@ -546,7 +549,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n             let llarg = bx.get_param(llarg_idx);\n-            bx.set_value_name(llarg, &name);\n+            bx.set_var_name(llarg, &name);\n             llarg_idx += 1;\n             PlaceRef::new_sized(llarg, arg.layout)\n         } else if arg.is_unsized_indirect() {\n@@ -558,11 +561,13 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             llarg_idx += 1;\n             let indirect_operand = OperandValue::Pair(llarg, llextra);\n \n-            let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout, &name);\n+            let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout);\n+            bx.set_var_name(tmp.llval, name);\n             indirect_operand.store(bx, tmp);\n             tmp\n         } else {\n-            let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n+            let tmp = PlaceRef::alloca(bx, arg.layout);\n+            bx.set_var_name(tmp.llval, name);\n             if fx.fn_ty.c_variadic && last_arg_idx.map(|idx| arg_index == idx).unwrap_or(false) {\n                 let va_list_did = match tcx.lang_items().va_list() {\n                     Some(did) => did,"}, {"sha": "daa25b2ea0591f572d82853cb20c7c980bf68bdd", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n-        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, \"unsized_tmp\", max_align);\n+        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, max_align);\n         bx.memcpy(lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place.\n@@ -384,47 +384,45 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n-        place_ref.iterate(|place_base, place_projection| {\n-            if let mir::PlaceBase::Local(index) = place_base {\n-                match self.locals[*index] {\n-                    LocalRef::Operand(Some(mut o)) => {\n-                        // Moves out of scalar and scalar pair fields are trivial.\n-                        for proj in place_projection {\n-                            match proj.elem {\n-                                mir::ProjectionElem::Field(ref f, _) => {\n-                                    o = o.extract_field(bx, f.index());\n-                                }\n-                                mir::ProjectionElem::Index(_) |\n-                                mir::ProjectionElem::ConstantIndex { .. } => {\n-                                    // ZSTs don't require any actual memory access.\n-                                    // FIXME(eddyb) deduplicate this with the identical\n-                                    // checks in `codegen_consume` and `extract_field`.\n-                                    let elem = o.layout.field(bx.cx(), 0);\n-                                    if elem.is_zst() {\n-                                        o = OperandRef::new_zst(bx, elem);\n-                                    } else {\n-                                        return None;\n-                                    }\n+        if let mir::PlaceBase::Local(index) = place_ref.base {\n+            match self.locals[*index] {\n+                LocalRef::Operand(Some(mut o)) => {\n+                    // Moves out of scalar and scalar pair fields are trivial.\n+                    for elem in place_ref.projection.iter() {\n+                        match elem {\n+                            mir::ProjectionElem::Field(ref f, _) => {\n+                                o = o.extract_field(bx, f.index());\n+                            }\n+                            mir::ProjectionElem::Index(_) |\n+                            mir::ProjectionElem::ConstantIndex { .. } => {\n+                                // ZSTs don't require any actual memory access.\n+                                // FIXME(eddyb) deduplicate this with the identical\n+                                // checks in `codegen_consume` and `extract_field`.\n+                                let elem = o.layout.field(bx.cx(), 0);\n+                                if elem.is_zst() {\n+                                    o = OperandRef::new_zst(bx, elem);\n+                                } else {\n+                                    return None;\n                                 }\n-                                _ => return None,\n                             }\n+                            _ => return None,\n                         }\n-\n-                        Some(o)\n-                    }\n-                    LocalRef::Operand(None) => {\n-                        bug!(\"use of {:?} before def\", place_ref);\n-                    }\n-                    LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n-                        // watch out for locals that do not have an\n-                        // alloca; they are handled somewhat differently\n-                        None\n                     }\n+\n+                    Some(o)\n+                }\n+                LocalRef::Operand(None) => {\n+                    bug!(\"use of {:?} before def\", place_ref);\n+                }\n+                LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n+                    // watch out for locals that do not have an\n+                    // alloca; they are handled somewhat differently\n+                    None\n                 }\n-            } else {\n-                None\n             }\n-        })\n+        } else {\n+            None\n+        }\n     }\n \n     pub fn codegen_consume("}, {"sha": "a4b4cb53bb1fb883c4459e5108fefdaf47c597f5", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -71,25 +71,21 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n-        name: &str\n     ) -> Self {\n-        debug!(\"alloca({:?}: {:?})\", name, layout);\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n-        let tmp = bx.alloca(bx.cx().backend_type(layout), name, layout.align.abi);\n+        let tmp = bx.alloca(bx.cx().backend_type(layout), layout.align.abi);\n         Self::new_sized(tmp, layout)\n     }\n \n     /// Returns a place for an indirect reference to an unsized place.\n     pub fn alloca_unsized_indirect<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n-        name: &str,\n     ) -> Self {\n-        debug!(\"alloca_unsized_indirect({:?}: {:?})\", name, layout);\n         assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n         let ptr_ty = bx.cx().tcx().mk_mut_ptr(layout.ty);\n         let ptr_layout = bx.cx().layout_of(ptr_ty);\n-        Self::alloca(bx, ptr_layout, name)\n+        Self::alloca(bx, ptr_layout)\n     }\n \n     pub fn len<Cx: ConstMethods<'tcx, Value = V>>(\n@@ -449,7 +445,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let result = match &place_ref {\n             mir::PlaceRef {\n                 base: mir::PlaceBase::Local(index),\n-                projection: None,\n+                projection: [],\n             } => {\n                 match self.locals[*index] {\n                     LocalRef::Place(place) => {\n@@ -469,7 +465,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     kind: mir::StaticKind::Promoted(promoted, substs),\n                     def_id,\n                 }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let instance = Instance::new(*def_id, self.monomorphize(substs));\n@@ -504,7 +500,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     kind: mir::StaticKind::Static,\n                     def_id,\n                 }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type.\n@@ -514,10 +510,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             },\n             mir::PlaceRef {\n                 base,\n-                projection: Some(box mir::Projection {\n-                    base: proj_base,\n-                    elem: mir::ProjectionElem::Deref,\n-                }),\n+                projection: [proj_base @ .., mir::ProjectionElem::Deref],\n             } => {\n                 // Load the pointer from its location.\n                 self.codegen_consume(bx, &mir::PlaceRef {\n@@ -527,22 +520,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             mir::PlaceRef {\n                 base,\n-                projection: Some(projection),\n+                projection: [proj_base @ .., elem],\n             } => {\n                 // FIXME turn this recursion into iteration\n                 let cg_base = self.codegen_place(bx, &mir::PlaceRef {\n                     base,\n-                    projection: &projection.base,\n+                    projection: proj_base,\n                 });\n \n-                match projection.elem {\n+                match elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         cg_base.project_field(bx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n                         let index = &mir::Operand::Copy(\n-                            mir::Place::from(index)\n+                            mir::Place::from(*index)\n                         );\n                         let index = self.codegen_operand(bx, index);\n                         let llindex = index.immediate();\n@@ -551,27 +544,27 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n+                        let lloffset = bx.cx().const_usize(*offset as u64);\n                         cg_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n+                        let lloffset = bx.cx().const_usize(*offset as u64);\n                         let lllen = cg_base.len(bx.cx());\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = cg_base.project_index(bx,\n-                            bx.cx().const_usize(from as u64));\n+                            bx.cx().const_usize(*from as u64));\n                         let projected_ty = PlaceTy::from_ty(cg_base.layout.ty)\n-                            .projection_ty(tcx, &projection.elem).ty;\n+                            .projection_ty(tcx, elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n-                                bx.cx().const_usize((from as u64) + (to as u64))));\n+                                bx.cx().const_usize((*from as u64) + (*to as u64))));\n                         }\n \n                         // Cast the place pointer type to the new\n@@ -582,7 +575,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         subslice\n                     }\n                     mir::ProjectionElem::Downcast(_, v) => {\n-                        cg_base.project_downcast(bx, v)\n+                        cg_base.project_downcast(bx, *v)\n                     }\n                 }\n             }"}, {"sha": "f21836a953c223ff31c81c57394ad04faeac53cf", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"codegen_rvalue: creating ugly alloca\");\n-                        let scratch = PlaceRef::alloca(&mut bx, operand.layout, \"__unsize_temp\");\n+                        let scratch = PlaceRef::alloca(&mut bx, operand.layout);\n                         scratch.storage_live(&mut bx);\n                         operand.val.store(&mut bx, scratch);\n                         base::coerce_unsized_into(&mut bx, scratch, dest);\n@@ -522,7 +522,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // because codegen_place() panics if Local is operand.\n         if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {"}, {"sha": "dab7dfc04175110b57b369126d2817c1d9bb34fe", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -16,21 +16,35 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         self.set_debug_loc(&mut bx, statement.source_info);\n         match statement.kind {\n-            mir::StatementKind::Assign(ref place, ref rvalue) => {\n+            mir::StatementKind::Assign(box(ref place, ref rvalue)) => {\n                 if let mir::Place {\n                     base: mir::PlaceBase::Local(index),\n-                    projection: None,\n-                } = *place {\n-                    match self.locals[index] {\n+                    projection: box [],\n+                } = place {\n+                    match self.locals[*index] {\n                         LocalRef::Place(cg_dest) => {\n                             self.codegen_rvalue(bx, cg_dest, rvalue)\n                         }\n                         LocalRef::UnsizedPlace(cg_indirect_dest) => {\n                             self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n                         }\n                         LocalRef::Operand(None) => {\n-                            let (bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n-                            self.locals[index] = LocalRef::Operand(Some(operand));\n+                            let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n+                            if let Some(name) = self.mir.local_decls[*index].name {\n+                                match operand.val {\n+                                    OperandValue::Ref(x, ..) |\n+                                    OperandValue::Immediate(x) => {\n+                                        bx.set_var_name(x, name);\n+                                    }\n+                                    OperandValue::Pair(a, b) => {\n+                                        // FIXME(eddyb) these are scalar components,\n+                                        // maybe extract the high-level fields?\n+                                        bx.set_var_name(a, format_args!(\"{}.0\", name));\n+                                        bx.set_var_name(b, format_args!(\"{}.1\", name));\n+                                    }\n+                                }\n+                            }\n+                            self.locals[*index] = LocalRef::Operand(Some(operand));\n                             bx\n                         }\n                         LocalRef::Operand(Some(op)) => {\n@@ -50,7 +64,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     self.codegen_rvalue(bx, cg_dest, rvalue)\n                 }\n             }\n-            mir::StatementKind::SetDiscriminant{ref place, variant_index} => {\n+            mir::StatementKind::SetDiscriminant{box ref place, variant_index} => {\n                 self.codegen_place(&mut bx, &place.as_ref())\n                     .codegen_set_discr(&mut bx, variant_index);\n                 bx"}, {"sha": "1886701fb3a88d95e1c9d4c274c1afe2f64039b6", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -109,13 +109,12 @@ pub trait BuilderMethods<'a, 'tcx>:\n         rhs: Self::Value,\n     ) -> (Self::Value, Self::Value);\n \n-    fn alloca(&mut self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n-    fn dynamic_alloca(&mut self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n+    fn alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n+    fn dynamic_alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n     fn array_alloca(\n         &mut self,\n         ty: Self::Type,\n         len: Self::Value,\n-        name: &str,\n         align: Align,\n     ) -> Self::Value;\n "}, {"sha": "9c16b864ef21dce3b48d1c017b16cb8b885848ac", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -57,5 +57,5 @@ pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {\n         span: Span,\n     );\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);\n-    fn set_value_name(&mut self, value: Self::Value, name: &str);\n+    fn set_var_name(&mut self, value: Self::Value, name: impl ToString);\n }"}, {"sha": "7c79cd6021031d7691328453e672272ffdb657b6", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,6 +1,6 @@\n use super::BackendTypes;\n use crate::mir::operand::OperandRef;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty};\n use rustc_target::abi::call::FnType;\n use syntax_pos::Span;\n \n@@ -10,7 +10,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     /// add them to librustc_codegen_llvm/context.rs\n     fn codegen_intrinsic_call(\n         &mut self,\n-        callee_ty: Ty<'tcx>,\n+        instance: ty::Instance<'tcx>,\n         fn_ty: &FnType<'tcx, Ty<'tcx>>,\n         args: &[OperandRef<'tcx, Self::Value>],\n         llresult: Self::Value,"}, {"sha": "1201446afb53128dddbd1b0a52134801ae72d6ff", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -10,7 +10,6 @@\n #![feature(core_intrinsics)]\n #![feature(never_type)]\n #![feature(nll)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(in_band_lifetimes)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "be9f79c83bb5a8416cf26cf41e73dff8b776dcc4", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -26,5 +26,5 @@ rustc-hash = \"1.0.1\"\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n \n [dependencies.parking_lot]\n-version = \"0.7\"\n+version = \"0.9\"\n features = [\"nightly\"]"}, {"sha": "6e80b48a6856016dadab3a7eb46bb2add06f0d6c", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -149,7 +149,7 @@ macro_rules! newtype_index {\n \n             #[inline]\n             $v const unsafe fn from_u32_unchecked(value: u32) -> Self {\n-                unsafe { $type { private: value } }\n+                $type { private: value }\n             }\n \n             /// Extracts the value of this index as an integer."}, {"sha": "ddf89d99621cabccc5be65cef79e1d048888bd70", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -74,9 +74,7 @@ impl<'a, O: ForestObligation + 'a> dot::GraphWalk<'a> for &'a ObligationForest<O\n             .flat_map(|i| {\n                 let node = &self.nodes[i];\n \n-                node.parent.iter().map(|p| p.get())\n-                    .chain(node.dependents.iter().map(|p| p.get()))\n-                    .map(move |p| (p, i))\n+                node.dependents.iter().map(move |&d| (d, i))\n             })\n             .collect()\n     }"}, {"sha": "98ae1a58324476c5c1731d32a20b1d13f97a0bb3", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 171, "deletions": 175, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -9,7 +9,7 @@\n //! `ObligationForest` supports two main public operations (there are a\n //! few others not discussed here):\n //!\n-//! 1. Add a new root obligations (`push_tree`).\n+//! 1. Add a new root obligations (`register_obligation`).\n //! 2. Process the pending obligations (`process_obligations`).\n //!\n //! When a new obligation `N` is added, it becomes the root of an\n@@ -20,21 +20,21 @@\n //! with every pending obligation (so that will include `N`, the first\n //! time). The callback also receives a (mutable) reference to the\n //! per-tree state `T`. The callback should process the obligation `O`\n-//! that it is given and return one of three results:\n+//! that it is given and return a `ProcessResult`:\n //!\n-//! - `Ok(None)` -> ambiguous result. Obligation was neither a success\n+//! - `Unchanged` -> ambiguous result. Obligation was neither a success\n //!   nor a failure. It is assumed that further attempts to process the\n //!   obligation will yield the same result unless something in the\n //!   surrounding environment changes.\n-//! - `Ok(Some(C))` - the obligation was *shallowly successful*. The\n+//! - `Changed(C)` - the obligation was *shallowly successful*. The\n //!   vector `C` is a list of subobligations. The meaning of this is that\n //!   `O` was successful on the assumption that all the obligations in `C`\n //!   are also successful. Therefore, `O` is only considered a \"true\"\n //!   success if `C` is empty. Otherwise, `O` is put into a suspended\n //!   state and the obligations in `C` become the new pending\n //!   obligations. They will be processed the next time you call\n //!   `process_obligations`.\n-//! - `Err(E)` -> obligation failed with error `E`. We will collect this\n+//! - `Error(E)` -> obligation failed with error `E`. We will collect this\n //!   error and return it from `process_obligations`, along with the\n //!   \"backtrace\" of obligations (that is, the list of obligations up to\n //!   and including the root of the failed obligation). No further\n@@ -47,50 +47,39 @@\n //! - `completed`: a list of obligations where processing was fully\n //!   completed without error (meaning that all transitive subobligations\n //!   have also been completed). So, for example, if the callback from\n-//!   `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n+//!   `process_obligations` returns `Changed(C)` for some obligation `O`,\n //!   then `O` will be considered completed right away if `C` is the\n //!   empty vector. Otherwise it will only be considered completed once\n //!   all the obligations in `C` have been found completed.\n //! - `errors`: a list of errors that occurred and associated backtraces\n //!   at the time of error, which can be used to give context to the user.\n //! - `stalled`: if true, then none of the existing obligations were\n-//!   *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n+//!   *shallowly successful* (that is, no callback returned `Changed(_)`).\n //!   This implies that all obligations were either errors or returned an\n //!   ambiguous result, which means that any further calls to\n //!   `process_obligations` would simply yield back further ambiguous\n //!   results. This is used by the `FulfillmentContext` to decide when it\n //!   has reached a steady state.\n //!\n-//! #### Snapshots\n-//!\n-//! The `ObligationForest` supports a limited form of snapshots; see\n-//! `start_snapshot`, `commit_snapshot`, and `rollback_snapshot`. In\n-//! particular, you can use a snapshot to roll back new root\n-//! obligations. However, it is an error to attempt to\n-//! `process_obligations` during a snapshot.\n-//!\n //! ### Implementation details\n //!\n //! For the most part, comments specific to the implementation are in the\n //! code. This file only contains a very high-level overview. Basically,\n //! the forest is stored in a vector. Each element of the vector is a node\n-//! in some tree. Each node in the vector has the index of an (optional)\n-//! parent and (for convenience) its root (which may be itself). It also\n-//! has a current state, described by `NodeState`. After each\n-//! processing step, we compress the vector to remove completed and error\n-//! nodes, which aren't needed anymore.\n+//! in some tree. Each node in the vector has the index of its dependents,\n+//! including the first dependent which is known as the parent. It also\n+//! has a current state, described by `NodeState`. After each processing\n+//! step, we compress the vector to remove completed and error nodes, which\n+//! aren't needed anymore.\n \n use crate::fx::{FxHashMap, FxHashSet};\n \n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n use std::hash;\n use std::marker::PhantomData;\n \n-mod node_index;\n-use self::node_index::NodeIndex;\n-\n mod graphviz;\n \n #[cfg(test)]\n@@ -148,18 +137,23 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// At the end of processing, those nodes will be removed by a\n     /// call to `compress`.\n     ///\n-    /// At all times we maintain the invariant that every node appears\n-    /// at a higher index than its parent. This is needed by the\n-    /// backtrace iterator (which uses `split_at`).\n+    /// `usize` indices are used here and throughout this module, rather than\n+    /// `newtype_index!` indices, because this code is hot enough that the\n+    /// `u32`-to-`usize` conversions that would be required are significant,\n+    /// and space considerations are not important.\n     nodes: Vec<Node<O>>,\n \n     /// A cache of predicates that have been successfully completed.\n     done_cache: FxHashSet<O::Predicate>,\n \n-    /// An cache of the nodes in `nodes`, indexed by predicate.\n-    waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n+    /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n+    /// its contents are not guaranteed to match those of `nodes`. See the\n+    /// comments in `process_obligation` for details.\n+    waiting_cache: FxHashMap<O::Predicate, usize>,\n \n-    scratch: Option<Vec<usize>>,\n+    /// A scratch vector reused in various operations, to avoid allocating new\n+    /// vectors.\n+    scratch: RefCell<Vec<usize>>,\n \n     obligation_tree_id_generator: ObligationTreeIdGenerator,\n \n@@ -178,19 +172,42 @@ struct Node<O> {\n     obligation: O,\n     state: Cell<NodeState>,\n \n-    /// The parent of a node - the original obligation of\n-    /// which it is a subobligation. Except for error reporting,\n-    /// it is just like any member of `dependents`.\n-    parent: Option<NodeIndex>,\n+    /// Obligations that depend on this obligation for their completion. They\n+    /// must all be in a non-pending state.\n+    dependents: Vec<usize>,\n \n-    /// Obligations that depend on this obligation for their\n-    /// completion. They must all be in a non-pending state.\n-    dependents: Vec<NodeIndex>,\n+    /// If true, dependents[0] points to a \"parent\" node, which requires\n+    /// special treatment upon error but is otherwise treated the same.\n+    /// (It would be more idiomatic to store the parent node in a separate\n+    /// `Option<usize>` field, but that slows down the common case of\n+    /// iterating over the parent and other descendants together.)\n+    has_parent: bool,\n \n     /// Identifier of the obligation tree to which this node belongs.\n     obligation_tree_id: ObligationTreeId,\n }\n \n+impl<O> Node<O> {\n+    fn new(\n+        parent: Option<usize>,\n+        obligation: O,\n+        obligation_tree_id: ObligationTreeId\n+    ) -> Node<O> {\n+        Node {\n+            obligation,\n+            state: Cell::new(NodeState::Pending),\n+            dependents:\n+                if let Some(parent_index) = parent {\n+                    vec![parent_index]\n+                } else {\n+                    vec![]\n+                },\n+            has_parent: parent.is_some(),\n+            obligation_tree_id,\n+        }\n+    }\n+}\n+\n /// The state of one node in some tree within the forest. This\n /// represents the current state of processing for the obligation (of\n /// type `O`) associated with this node.\n@@ -262,7 +279,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             nodes: vec![],\n             done_cache: Default::default(),\n             waiting_cache: Default::default(),\n-            scratch: Some(vec![]),\n+            scratch: RefCell::new(vec![]),\n             obligation_tree_id_generator: (0..).map(ObligationTreeId),\n             error_cache: Default::default(),\n         }\n@@ -275,17 +292,13 @@ impl<O: ForestObligation> ObligationForest<O> {\n     }\n \n     /// Registers an obligation.\n-    ///\n-    /// This CAN be done in a snapshot\n     pub fn register_obligation(&mut self, obligation: O) {\n         // Ignore errors here - there is no guarantee of success.\n         let _ = self.register_obligation_at(obligation, None);\n     }\n \n-    // returns Err(()) if we already know this obligation failed.\n-    fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>)\n-                              -> Result<(), ()>\n-    {\n+    // Returns Err(()) if we already know this obligation failed.\n+    fn register_obligation_at(&mut self, obligation: O, parent: Option<usize>) -> Result<(), ()> {\n         if self.done_cache.contains(obligation.as_predicate()) {\n             return Ok(());\n         }\n@@ -294,15 +307,14 @@ impl<O: ForestObligation> ObligationForest<O> {\n             Entry::Occupied(o) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n                        obligation, parent, o.get());\n-                let node = &mut self.nodes[o.get().get()];\n-                if let Some(parent) = parent {\n-                    // If the node is already in `waiting_cache`, it's already\n-                    // been marked with a parent. (It's possible that parent\n-                    // has been cleared by `apply_rewrites`, though.) So just\n-                    // dump `parent` into `node.dependents`... unless it's\n-                    // already in `node.dependents` or `node.parent`.\n-                    if !node.dependents.contains(&parent) && Some(parent) != node.parent {\n-                        node.dependents.push(parent);\n+                let node = &mut self.nodes[*o.get()];\n+                if let Some(parent_index) = parent {\n+                    // If the node is already in `waiting_cache`, it has\n+                    // already had its chance to be marked with a parent. So if\n+                    // it's not already present, just dump `parent` into the\n+                    // dependents as a non-parent.\n+                    if !node.dependents.contains(&parent_index) {\n+                        node.dependents.push(parent_index);\n                     }\n                 }\n                 if let NodeState::Error = node.state.get() {\n@@ -316,11 +328,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                        obligation, parent, self.nodes.len());\n \n                 let obligation_tree_id = match parent {\n-                    Some(p) => {\n-                        let parent_node = &self.nodes[p.get()];\n-                        parent_node.obligation_tree_id\n-                    }\n-                    None => self.obligation_tree_id_generator.next().unwrap()\n+                    Some(parent_index) => self.nodes[parent_index].obligation_tree_id,\n+                    None => self.obligation_tree_id_generator.next().unwrap(),\n                 };\n \n                 let already_failed =\n@@ -333,7 +342,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 if already_failed {\n                     Err(())\n                 } else {\n-                    v.insert(NodeIndex::new(self.nodes.len()));\n+                    v.insert(self.nodes.len());\n                     self.nodes.push(Node::new(parent, obligation, obligation_tree_id));\n                     Ok(())\n                 }\n@@ -342,12 +351,10 @@ impl<O: ForestObligation> ObligationForest<O> {\n     }\n \n     /// Converts all remaining obligations to the given error.\n-    ///\n-    /// This cannot be done during a snapshot.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n         let mut errors = vec![];\n-        for index in 0..self.nodes.len() {\n-            if let NodeState::Pending = self.nodes[index].state.get() {\n+        for (index, node) in self.nodes.iter().enumerate() {\n+            if let NodeState::Pending = node.state.get() {\n                 let backtrace = self.error_at(index);\n                 errors.push(Error {\n                     error: error.clone(),\n@@ -373,7 +380,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     fn insert_into_error_cache(&mut self, node_index: usize) {\n         let node = &self.nodes[node_index];\n-\n         self.error_cache\n             .entry(node.obligation_tree_id)\n             .or_default()\n@@ -394,11 +400,17 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut stalled = true;\n \n         for index in 0..self.nodes.len() {\n-            debug!(\"process_obligations: node {} == {:?}\", index, self.nodes[index]);\n+            let node = &mut self.nodes[index];\n+\n+            debug!(\"process_obligations: node {} == {:?}\", index, node);\n \n-            let result = match self.nodes[index] {\n-                Node { ref state, ref mut obligation, .. } if state.get() == NodeState::Pending =>\n-                    processor.process_obligation(obligation),\n+            // `processor.process_obligation` can modify the predicate within\n+            // `node.obligation`, and that predicate is the key used for\n+            // `self.waiting_cache`. This means that `self.waiting_cache` can\n+            // get out of sync with `nodes`. It's not very common, but it does\n+            // happen, and code in `compress` has to allow for it.\n+            let result = match node.state.get() {\n+                NodeState::Pending => processor.process_obligation(&mut node.obligation),\n                 _ => continue\n             };\n \n@@ -411,15 +423,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 ProcessResult::Changed(children) => {\n                     // We are not (yet) stalled.\n                     stalled = false;\n-                    self.nodes[index].state.set(NodeState::Success);\n+                    node.state.set(NodeState::Success);\n \n                     for child in children {\n                         let st = self.register_obligation_at(\n                             child,\n-                            Some(NodeIndex::new(index))\n+                            Some(index)\n                         );\n                         if let Err(()) = st {\n-                            // error already reported - propagate it\n+                            // Error already reported - propagate it\n                             // to our node.\n                             self.error_at(index);\n                         }\n@@ -448,8 +460,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         self.mark_as_waiting();\n         self.process_cycles(processor);\n-\n-        // Now we have to compress the result\n         let completed = self.compress(do_completed);\n \n         debug!(\"process_obligations: complete\");\n@@ -465,21 +475,20 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// report all cycles between them. This should be called\n     /// after `mark_as_waiting` marks all nodes with pending\n     /// subobligations as NodeState::Waiting.\n-    fn process_cycles<P>(&mut self, processor: &mut P)\n+    fn process_cycles<P>(&self, processor: &mut P)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        let mut stack = self.scratch.take().unwrap();\n+        let mut stack = self.scratch.replace(vec![]);\n         debug_assert!(stack.is_empty());\n \n         debug!(\"process_cycles()\");\n \n-        for index in 0..self.nodes.len() {\n+        for (index, node) in self.nodes.iter().enumerate() {\n             // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n             // hot and the state is almost always `Pending` or `Waiting`. It's\n             // a win to handle the no-op cases immediately to avoid the cost of\n             // the function call.\n-            let state = self.nodes[index].state.get();\n-            match state {\n+            match node.state.get() {\n                 NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n                 _ => self.find_cycles_from_node(&mut stack, processor, index),\n             }\n@@ -488,84 +497,88 @@ impl<O: ForestObligation> ObligationForest<O> {\n         debug!(\"process_cycles: complete\");\n \n         debug_assert!(stack.is_empty());\n-        self.scratch = Some(stack);\n+        self.scratch.replace(stack);\n     }\n \n-    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>,\n-                                processor: &mut P, index: usize)\n+    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n         where P: ObligationProcessor<Obligation=O>\n     {\n         let node = &self.nodes[index];\n-        let state = node.state.get();\n-        match state {\n+        match node.state.get() {\n             NodeState::OnDfsStack => {\n-                let index =\n-                    stack.iter().rposition(|n| *n == index).unwrap();\n+                let index = stack.iter().rposition(|&n| n == index).unwrap();\n                 processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)),\n                                            PhantomData);\n             }\n             NodeState::Success => {\n                 node.state.set(NodeState::OnDfsStack);\n                 stack.push(index);\n-                for dependent in node.parent.iter().chain(node.dependents.iter()) {\n-                    self.find_cycles_from_node(stack, processor, dependent.get());\n+                for &index in node.dependents.iter() {\n+                    self.find_cycles_from_node(stack, processor, index);\n                 }\n                 stack.pop();\n                 node.state.set(NodeState::Done);\n             },\n             NodeState::Waiting | NodeState::Pending => {\n-                // this node is still reachable from some pending node. We\n+                // This node is still reachable from some pending node. We\n                 // will get to it when they are all processed.\n             }\n             NodeState::Done | NodeState::Error => {\n-                // already processed that node\n+                // Already processed that node.\n             }\n         };\n     }\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n-    fn error_at(&mut self, p: usize) -> Vec<O> {\n-        let mut error_stack = self.scratch.take().unwrap();\n+    fn error_at(&self, mut index: usize) -> Vec<O> {\n+        let mut error_stack = self.scratch.replace(vec![]);\n         let mut trace = vec![];\n \n-        let mut n = p;\n         loop {\n-            self.nodes[n].state.set(NodeState::Error);\n-            trace.push(self.nodes[n].obligation.clone());\n-            error_stack.extend(self.nodes[n].dependents.iter().map(|x| x.get()));\n-\n-            // loop to the parent\n-            match self.nodes[n].parent {\n-                Some(q) => n = q.get(),\n-                None => break\n+            let node = &self.nodes[index];\n+            node.state.set(NodeState::Error);\n+            trace.push(node.obligation.clone());\n+            if node.has_parent {\n+                // The first dependent is the parent, which is treated\n+                // specially.\n+                error_stack.extend(node.dependents.iter().skip(1));\n+                index = node.dependents[0];\n+            } else {\n+                // No parent; treat all dependents non-specially.\n+                error_stack.extend(node.dependents.iter());\n+                break;\n             }\n         }\n \n-        while let Some(i) = error_stack.pop() {\n-            match self.nodes[i].state.get() {\n+        while let Some(index) = error_stack.pop() {\n+            let node = &self.nodes[index];\n+            match node.state.get() {\n                 NodeState::Error => continue,\n-                _ => self.nodes[i].state.set(NodeState::Error),\n+                _ => node.state.set(NodeState::Error),\n             }\n \n-            let node = &self.nodes[i];\n-\n-            error_stack.extend(\n-                node.parent.iter().chain(node.dependents.iter()).map(|x| x.get())\n-            );\n+            error_stack.extend(node.dependents.iter());\n         }\n \n-        self.scratch = Some(error_stack);\n+        self.scratch.replace(error_stack);\n         trace\n     }\n \n-    #[inline]\n-    fn mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n-        for dependent in node.parent.iter().chain(node.dependents.iter()) {\n-            self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n+    // This always-inlined function is for the hot call site.\n+    #[inline(always)]\n+    fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n+        for &index in node.dependents.iter() {\n+            self.mark_as_waiting_from(&self.nodes[index]);\n         }\n     }\n \n+    // This never-inlined function is for the cold call site.\n+    #[inline(never)]\n+    fn uninlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n+        self.inlined_mark_neighbors_as_waiting_from(node)\n+    }\n+\n     /// Marks all nodes that depend on a pending node as `NodeState::Waiting`.\n     fn mark_as_waiting(&self) {\n         for node in &self.nodes {\n@@ -576,7 +589,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         for node in &self.nodes {\n             if node.state.get() == NodeState::Pending {\n-                self.mark_neighbors_as_waiting_from(node);\n+                // This call site is hot.\n+                self.inlined_mark_neighbors_as_waiting_from(node);\n             }\n         }\n     }\n@@ -588,7 +602,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n             NodeState::Pending | NodeState::Done => {},\n         }\n \n-        self.mark_neighbors_as_waiting_from(node);\n+        // This call site is cold.\n+        self.uninlined_mark_neighbors_as_waiting_from(node);\n     }\n \n     /// Compresses the vector, removing all popped nodes. This adjusts\n@@ -600,44 +615,48 @@ impl<O: ForestObligation> ObligationForest<O> {\n     #[inline(never)]\n     fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n         let nodes_len = self.nodes.len();\n-        let mut node_rewrites: Vec<_> = self.scratch.take().unwrap();\n+        let mut node_rewrites: Vec<_> = self.scratch.replace(vec![]);\n         node_rewrites.extend(0..nodes_len);\n         let mut dead_nodes = 0;\n \n         // Now move all popped nodes to the end. Try to keep the order.\n         //\n         // LOOP INVARIANT:\n-        //     self.nodes[0..i - dead_nodes] are the first remaining nodes\n-        //     self.nodes[i - dead_nodes..i] are all dead\n-        //     self.nodes[i..] are unchanged\n-        for i in 0..self.nodes.len() {\n-            match self.nodes[i].state.get() {\n+        //     self.nodes[0..index - dead_nodes] are the first remaining nodes\n+        //     self.nodes[index - dead_nodes..index] are all dead\n+        //     self.nodes[index..] are unchanged\n+        for index in 0..self.nodes.len() {\n+            let node = &self.nodes[index];\n+            match node.state.get() {\n                 NodeState::Pending | NodeState::Waiting => {\n                     if dead_nodes > 0 {\n-                        self.nodes.swap(i, i - dead_nodes);\n-                        node_rewrites[i] -= dead_nodes;\n+                        self.nodes.swap(index, index - dead_nodes);\n+                        node_rewrites[index] -= dead_nodes;\n                     }\n                 }\n                 NodeState::Done => {\n-                    // Avoid cloning the key (predicate) in case it exists in the waiting cache\n+                    // This lookup can fail because the contents of\n+                    // `self.waiting_cache` is not guaranteed to match those of\n+                    // `self.nodes`. See the comment in `process_obligation`\n+                    // for more details.\n                     if let Some((predicate, _)) = self.waiting_cache\n-                        .remove_entry(self.nodes[i].obligation.as_predicate())\n+                        .remove_entry(node.obligation.as_predicate())\n                     {\n                         self.done_cache.insert(predicate);\n                     } else {\n-                        self.done_cache.insert(self.nodes[i].obligation.as_predicate().clone());\n+                        self.done_cache.insert(node.obligation.as_predicate().clone());\n                     }\n-                    node_rewrites[i] = nodes_len;\n+                    node_rewrites[index] = nodes_len;\n                     dead_nodes += 1;\n                 }\n                 NodeState::Error => {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n-                    self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n-                    node_rewrites[i] = nodes_len;\n+                    self.waiting_cache.remove(node.obligation.as_predicate());\n+                    node_rewrites[index] = nodes_len;\n                     dead_nodes += 1;\n-                    self.insert_into_error_cache(i);\n+                    self.insert_into_error_cache(index);\n                 }\n                 NodeState::OnDfsStack | NodeState::Success => unreachable!()\n             }\n@@ -646,12 +665,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n         // No compression needed.\n         if dead_nodes == 0 {\n             node_rewrites.truncate(0);\n-            self.scratch = Some(node_rewrites);\n+            self.scratch.replace(node_rewrites);\n             return if do_completed == DoCompleted::Yes { Some(vec![]) } else { None };\n         }\n \n-        // Pop off all the nodes we killed and extract the success\n-        // stories.\n+        // Pop off all the nodes we killed and extract the success stories.\n         let successful = if do_completed == DoCompleted::Yes {\n             Some((0..dead_nodes)\n                 .map(|_| self.nodes.pop().unwrap())\n@@ -670,7 +688,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.apply_rewrites(&node_rewrites);\n \n         node_rewrites.truncate(0);\n-        self.scratch = Some(node_rewrites);\n+        self.scratch.replace(node_rewrites);\n \n         successful\n     }\n@@ -679,59 +697,37 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let nodes_len = node_rewrites.len();\n \n         for node in &mut self.nodes {\n-            if let Some(index) = node.parent {\n-                let new_index = node_rewrites[index.get()];\n-                if new_index >= nodes_len {\n-                    // parent dead due to error\n-                    node.parent = None;\n-                } else {\n-                    node.parent = Some(NodeIndex::new(new_index));\n-                }\n-            }\n-\n-            let mut i = 0;\n-            while i < node.dependents.len() {\n-                let new_index = node_rewrites[node.dependents[i].get()];\n+            let mut index = 0;\n+            while index < node.dependents.len() {\n+                let new_index = node_rewrites[node.dependents[index]];\n                 if new_index >= nodes_len {\n-                    node.dependents.swap_remove(i);\n+                    node.dependents.swap_remove(index);\n+                    if index == 0 && node.has_parent {\n+                        // We just removed the parent.\n+                        node.has_parent = false;\n+                    }\n                 } else {\n-                    node.dependents[i] = NodeIndex::new(new_index);\n-                    i += 1;\n+                    node.dependents[index] = new_index;\n+                    index += 1;\n                 }\n             }\n         }\n \n-        let mut kill_list = vec![];\n-        for (predicate, index) in &mut self.waiting_cache {\n-            let new_index = node_rewrites[index.get()];\n+        // This updating of `self.waiting_cache` is necessary because the\n+        // removal of nodes within `compress` can fail. See above.\n+        self.waiting_cache.retain(|_predicate, index| {\n+            let new_index = node_rewrites[*index];\n             if new_index >= nodes_len {\n-                kill_list.push(predicate.clone());\n+                false\n             } else {\n-                *index = NodeIndex::new(new_index);\n+                *index = new_index;\n+                true\n             }\n-        }\n-\n-        for predicate in kill_list { self.waiting_cache.remove(&predicate); }\n-    }\n-}\n-\n-impl<O> Node<O> {\n-    fn new(\n-        parent: Option<NodeIndex>,\n-        obligation: O,\n-        obligation_tree_id: ObligationTreeId\n-    ) -> Node<O> {\n-        Node {\n-            obligation,\n-            state: Cell::new(NodeState::Pending),\n-            parent,\n-            dependents: vec![],\n-            obligation_tree_id,\n-        }\n+        });\n     }\n }\n \n-// I need a Clone closure\n+// I need a Clone closure.\n #[derive(Clone)]\n struct GetObligation<'a, O>(&'a [Node<O>]);\n "}, {"sha": "69ea473e054618dabe8dc437e23c649f42517b5f", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83e7976c842a8ad73aa176b8439e1a2480596134/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83e7976c842a8ad73aa176b8439e1a2480596134/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=83e7976c842a8ad73aa176b8439e1a2480596134", "patch": "@@ -1,20 +0,0 @@\n-use std::num::NonZeroU32;\n-use std::u32;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct NodeIndex {\n-    index: NonZeroU32,\n-}\n-\n-impl NodeIndex {\n-    #[inline]\n-    pub fn new(value: usize) -> NodeIndex {\n-        assert!(value < (u32::MAX as usize));\n-        NodeIndex { index: NonZeroU32::new((value as u32) + 1).unwrap() }\n-    }\n-\n-    #[inline]\n-    pub fn get(self) -> usize {\n-        (self.index.get() - 1) as usize\n-    }\n-}"}, {"sha": "25f67b30468ccdbe1f6f03e461813baae44fc065", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -11,8 +11,9 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n graphviz = { path = \"../libgraphviz\" }\n+lazy_static = \"1.0\"\n log = \"0.4\"\n-env_logger = { version = \"0.5\", default-features = false }\n+env_logger = { version = \"0.6\", default-features = false }\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }"}, {"sha": "8c5d8536c32fa7bc1ebf2cc732ec22febf635ec5", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 98, "deletions": 51, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -9,7 +9,6 @@\n #![feature(box_syntax)]\n #![cfg_attr(unix, feature(libc))]\n #![feature(nll)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(set_stdio)]\n #![feature(no_debug)]\n #![feature(integer_atomics)]\n@@ -21,6 +20,8 @@ pub extern crate getopts;\n extern crate libc;\n #[macro_use]\n extern crate log;\n+#[macro_use]\n+extern crate lazy_static;\n \n pub extern crate rustc_plugin_impl as plugin;\n \n@@ -36,8 +37,8 @@ use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::util::common::{ErrorReported, install_panic_hook, print_time_passes_entry};\n-use rustc::util::common::{set_time_depth, time};\n+use rustc::ty::TyCtxt;\n+use rustc::util::common::{set_time_depth, time, print_time_passes_entry, ErrorReported};\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -133,8 +134,11 @@ pub struct TimePassesCallbacks {\n \n impl Callbacks for TimePassesCallbacks {\n     fn config(&mut self, config: &mut interface::Config) {\n+        // If a --prints=... option has been given, we don't print the \"total\"\n+        // time because it will mess up the --prints output. See #64339.\n         self.time_passes =\n-            config.opts.debugging_opts.time_passes || config.opts.debugging_opts.time;\n+            config.opts.prints.is_empty() &&\n+            (config.opts.debugging_opts.time_passes || config.opts.debugging_opts.time);\n     }\n }\n \n@@ -162,8 +166,6 @@ pub fn run_compiler(\n         None => return Ok(()),\n     };\n \n-    install_panic_hook();\n-\n     let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n \n     let mut dummy_config = |sopts, cfg, diagnostic_output| {\n@@ -1152,61 +1154,105 @@ fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n     }\n }\n \n-/// Runs a procedure which will detect panics in the compiler and print nicer\n-/// error messages rather than just failing the test.\n+/// Runs a closure and catches unwinds triggered by fatal errors.\n ///\n-/// The diagnostic emitter yielded to the procedure should be used for reporting\n-/// errors of the compiler.\n-pub fn report_ices_to_stderr_if_any<F: FnOnce() -> R, R>(f: F) -> Result<R, ErrorReported> {\n+/// The compiler currently unwinds with a special sentinel value to abort\n+/// compilation on fatal errors. This function catches that sentinel and turns\n+/// the panic into a `Result` instead.\n+pub fn catch_fatal_errors<F: FnOnce() -> R, R>(f: F) -> Result<R, ErrorReported> {\n     catch_unwind(panic::AssertUnwindSafe(f)).map_err(|value| {\n         if value.is::<errors::FatalErrorMarker>() {\n             ErrorReported\n         } else {\n-            // Thread panicked without emitting a fatal diagnostic\n-            eprintln!(\"\");\n-\n-            let emitter = Box::new(errors::emitter::EmitterWriter::stderr(\n-                errors::ColorConfig::Auto,\n-                None,\n-                false,\n-                false,\n-                None,\n-            ));\n-            let handler = errors::Handler::with_emitter(true, None, emitter);\n-\n-            // a .span_bug or .bug call has already printed what\n-            // it wants to print.\n-            if !value.is::<errors::ExplicitBug>() {\n-                handler.emit(&MultiSpan::new(),\n-                             \"unexpected panic\",\n-                             errors::Level::Bug);\n-            }\n+            panic::resume_unwind(value);\n+        }\n+    })\n+}\n \n-            let mut xs: Vec<Cow<'static, str>> = vec![\n-                \"the compiler unexpectedly panicked. this is a bug.\".into(),\n-                format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL).into(),\n-                format!(\"rustc {} running on {}\",\n-                        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n-                        config::host_triple()).into(),\n-            ];\n+lazy_static! {\n+    static ref DEFAULT_HOOK: Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static> = {\n+        let hook = panic::take_hook();\n+        panic::set_hook(Box::new(|info| report_ice(info, BUG_REPORT_URL)));\n+        hook\n+    };\n+}\n \n-            if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n-                xs.push(format!(\"compiler flags: {}\", flags.join(\" \")).into());\n+/// Prints the ICE message, including backtrace and query stack.\n+///\n+/// The message will point the user at `bug_report_url` to report the ICE.\n+///\n+/// When `install_ice_hook` is called, this function will be called as the panic\n+/// hook.\n+pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n+    // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n+    (*DEFAULT_HOOK)(info);\n+\n+    // Separate the output with an empty line\n+    eprintln!();\n+\n+    let emitter = Box::new(errors::emitter::EmitterWriter::stderr(\n+        errors::ColorConfig::Auto,\n+        None,\n+        false,\n+        false,\n+        None,\n+    ));\n+    let handler = errors::Handler::with_emitter(true, None, emitter);\n+\n+    // a .span_bug or .bug call has already printed what\n+    // it wants to print.\n+    if !info.payload().is::<errors::ExplicitBug>() {\n+        handler.emit(&MultiSpan::new(),\n+                     \"unexpected panic\",\n+                     errors::Level::Bug);\n+    }\n \n-                if excluded_cargo_defaults {\n-                    xs.push(\"some of the compiler flags provided by cargo are hidden\".into());\n-                }\n-            }\n+    let mut xs: Vec<Cow<'static, str>> = vec![\n+        \"the compiler unexpectedly panicked. this is a bug.\".into(),\n+        format!(\"we would appreciate a bug report: {}\", bug_report_url).into(),\n+        format!(\"rustc {} running on {}\",\n+                option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n+                config::host_triple()).into(),\n+    ];\n \n-            for note in &xs {\n-                handler.emit(&MultiSpan::new(),\n-                             note,\n-                             errors::Level::Note);\n-            }\n+    if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n+        xs.push(format!(\"compiler flags: {}\", flags.join(\" \")).into());\n \n-            panic::resume_unwind(Box::new(errors::FatalErrorMarker));\n+        if excluded_cargo_defaults {\n+            xs.push(\"some of the compiler flags provided by cargo are hidden\".into());\n         }\n-    })\n+    }\n+\n+    for note in &xs {\n+        handler.emit(&MultiSpan::new(),\n+                     note,\n+                     errors::Level::Note);\n+    }\n+\n+    // If backtraces are enabled, also print the query stack\n+    let backtrace = env::var_os(\"RUST_BACKTRACE\").map(|x| &x != \"0\").unwrap_or(false);\n+\n+    if backtrace {\n+        TyCtxt::try_print_query_stack();\n+    }\n+\n+    #[cfg(windows)]\n+    unsafe {\n+        if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n+            extern \"system\" {\n+                fn DebugBreak();\n+            }\n+            // Trigger a debugger if we crashed during bootstrap\n+            DebugBreak();\n+        }\n+    }\n+}\n+\n+/// Installs a panic hook that will print the ICE message on unexpected panics.\n+///\n+/// A custom rustc driver can skip calling this to set up a custom ICE hook.\n+pub fn install_ice_hook() {\n+    lazy_static::initialize(&DEFAULT_HOOK);\n }\n \n /// This allows tools to enable rust logging without having to magically match rustc's\n@@ -1219,7 +1265,8 @@ pub fn main() {\n     let start = Instant::now();\n     init_rustc_env_logger();\n     let mut callbacks = TimePassesCallbacks::default();\n-    let result = report_ices_to_stderr_if_any(|| {\n+    install_ice_hook();\n+    let result = catch_fatal_errors(|| {\n         let args = env::args_os().enumerate()\n             .map(|(i, arg)| arg.into_string().unwrap_or_else(|arg| {\n                     early_error(ErrorOutputType::default(),"}, {"sha": "fa9504e22019ebfe585ca78846509f892675f7f9", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,7 +1,5 @@\n //! The various pretty-printing routines.\n \n-use rustc::cfg;\n-use rustc::cfg::graphviz::LabelledCFG;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks;\n@@ -14,6 +12,7 @@ use rustc::util::common::ErrorReported;\n use rustc_interface::util::ReplaceBodyWithLoop;\n use rustc_ast_borrowck as borrowck;\n use rustc_ast_borrowck::graphviz as borrowck_dot;\n+use rustc_ast_borrowck::cfg::{self, graphviz::LabelledCFG};\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast;\n@@ -327,6 +326,7 @@ impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n     }\n     fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n         match node {\n+            pprust::AnnNode::Crate(_) |\n             pprust::AnnNode::Ident(_) |\n             pprust::AnnNode::Name(_) => {},\n \n@@ -432,14 +432,18 @@ impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n         match node {\n             pprust::AnnNode::Ident(&ast::Ident { name, span }) => {\n                 s.s.space();\n-                // FIXME #16420: this doesn't display the connections\n-                // between syntax contexts\n                 s.synth_comment(format!(\"{}{:?}\", name.as_u32(), span.ctxt()))\n             }\n             pprust::AnnNode::Name(&name) => {\n                 s.s.space();\n                 s.synth_comment(name.as_u32().to_string())\n             }\n+            pprust::AnnNode::Crate(_) => {\n+                s.s.hardbreak();\n+                let verbose = self.sess.verbose();\n+                s.synth_comment(syntax_pos::hygiene::debug_hygiene_data(verbose));\n+                s.s.hardbreak_if_not_bol();\n+            }\n             _ => {}\n         }\n     }"}, {"sha": "c626dd0434d52ffff5dfa4c926a09b0d634e84da", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -30,10 +30,14 @@ pub struct AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n-        let children = db.children.clone();\n-        let (primary_span, suggestions) = self.primary_span_formatted(&db);\n+        let mut children = db.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n \n-        // FIXME(#59346): Add `fix_multispans_in_std_macros` function from emitter.rs\n+        self.fix_multispans_in_std_macros(&self.source_map,\n+                                          &mut primary_span,\n+                                          &mut children,\n+                                          &db.level,\n+                                          db.handler().flags.external_macro_backtrace);\n \n         self.emit_messages_default(&db.level,\n                                    db.message(),\n@@ -105,7 +109,7 @@ impl<'a>  DiagnosticConverter<'a> {\n         annotated_files: Vec<FileWithAnnotatedLines>,\n         primary_lo: Loc\n     ) -> Vec<Slice> {\n-        // FIXME(#59346): Provide a test case where `annotated_files` is > 1\n+        // FIXME(#64205): Provide a test case where `annotated_files` is > 1\n         annotated_files.iter().flat_map(|annotated_file| {\n             annotated_file.lines.iter().map(|line| {\n                 let line_source = Self::source_string(annotated_file.file.clone(), &line);"}, {"sha": "7b8902f125aee1ed3aa6bc87376c07c23b99782a", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -18,8 +18,17 @@ use log::debug;\n /// extending `HandlerFlags`, accessed via `self.handler.flags`.\n #[must_use]\n #[derive(Clone)]\n-pub struct DiagnosticBuilder<'a> {\n-    pub handler: &'a Handler,\n+pub struct DiagnosticBuilder<'a>(Box<DiagnosticBuilderInner<'a>>);\n+\n+/// This is a large type, and often used as a return value, especially within\n+/// the frequently-used `PResult` type. In theory, return value optimization\n+/// (RVO) should avoid unnecessary copying. In practice, it does not (at the\n+/// time of writing). The split between `DiagnosticBuilder` and\n+/// `DiagnosticBuilderInner` exists to avoid many `memcpy` calls.\n+#[must_use]\n+#[derive(Clone)]\n+struct DiagnosticBuilderInner<'a> {\n+    handler: &'a Handler,\n     diagnostic: Diagnostic,\n     allow_suggestions: bool,\n }\n@@ -52,7 +61,7 @@ macro_rules! forward {\n     ) => {\n         $(#[$attrs])*\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n-            self.diagnostic.$n($($name),*);\n+            self.0.diagnostic.$n($($name),*);\n             self\n         }\n     };\n@@ -69,7 +78,7 @@ macro_rules! forward {\n     ) => {\n         $(#[$attrs])*\n         pub fn $n<S: Into<MultiSpan>>(&mut self, $($name: $ty),*) -> &mut Self {\n-            self.diagnostic.$n($($name),*);\n+            self.0.diagnostic.$n($($name),*);\n             self\n         }\n     };\n@@ -79,24 +88,28 @@ impl<'a> Deref for DiagnosticBuilder<'a> {\n     type Target = Diagnostic;\n \n     fn deref(&self) -> &Diagnostic {\n-        &self.diagnostic\n+        &self.0.diagnostic\n     }\n }\n \n impl<'a> DerefMut for DiagnosticBuilder<'a> {\n     fn deref_mut(&mut self) -> &mut Diagnostic {\n-        &mut self.diagnostic\n+        &mut self.0.diagnostic\n     }\n }\n \n impl<'a> DiagnosticBuilder<'a> {\n+    pub fn handler(&self) -> &'a Handler{\n+        self.0.handler\n+    }\n+\n     /// Emit the diagnostic.\n     pub fn emit(&mut self) {\n         if self.cancelled() {\n             return;\n         }\n \n-        self.handler.emit_db(&self);\n+        self.0.handler.emit_db(&self);\n         self.cancel();\n     }\n \n@@ -115,8 +128,8 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// Buffers the diagnostic for later emission, unless handler\n     /// has disabled such buffering.\n     pub fn buffer(mut self, buffered_diagnostics: &mut Vec<Diagnostic>) {\n-        if self.handler.flags.dont_buffer_diagnostics ||\n-            self.handler.flags.treat_err_as_bug.is_some()\n+        if self.0.handler.flags.dont_buffer_diagnostics ||\n+            self.0.handler.flags.treat_err_as_bug.is_some()\n         {\n             self.emit();\n             return;\n@@ -126,7 +139,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         // implements `Drop`.\n         let diagnostic;\n         unsafe {\n-            diagnostic = std::ptr::read(&self.diagnostic);\n+            diagnostic = std::ptr::read(&self.0.diagnostic);\n             std::mem::forget(self);\n         };\n         // Logging here is useful to help track down where in logs an error was\n@@ -144,7 +157,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         span: Option<S>,\n     ) -> &mut Self {\n         let span = span.map(|s| s.into()).unwrap_or_else(|| MultiSpan::new());\n-        self.diagnostic.sub(level, message, span, None);\n+        self.0.diagnostic.sub(level, message, span, None);\n         self\n     }\n \n@@ -160,7 +173,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// locally in whichever way makes the most sense.\n     pub fn delay_as_bug(&mut self) {\n         self.level = Level::Bug;\n-        self.handler.delay_as_bug(self.diagnostic.clone());\n+        self.0.handler.delay_as_bug(self.0.diagnostic.clone());\n         self.cancel();\n     }\n \n@@ -171,7 +184,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// then the snippet will just include that `Span`, which is\n     /// called the primary span.\n     pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n-        self.diagnostic.span_label(span, label);\n+        self.0.diagnostic.span_label(span, label);\n         self\n     }\n \n@@ -208,10 +221,10 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.multipart_suggestion(\n+        self.0.diagnostic.multipart_suggestion(\n             msg,\n             suggestion,\n             applicability,\n@@ -225,29 +238,28 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.tool_only_multipart_suggestion(\n+        self.0.diagnostic.tool_only_multipart_suggestion(\n             msg,\n             suggestion,\n             applicability,\n         );\n         self\n     }\n \n-\n     pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestion(\n+        self.0.diagnostic.span_suggestion(\n             sp,\n             msg,\n             suggestion,\n@@ -263,10 +275,10 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestions: impl Iterator<Item = String>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestions(\n+        self.0.diagnostic.span_suggestions(\n             sp,\n             msg,\n             suggestions,\n@@ -282,10 +294,10 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestion_short(\n+        self.0.diagnostic.span_suggestion_short(\n             sp,\n             msg,\n             suggestion,\n@@ -301,10 +313,10 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestion_hidden(\n+        self.0.diagnostic.span_suggestion_hidden(\n             sp,\n             msg,\n             suggestion,\n@@ -320,10 +332,10 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.tool_only_span_suggestion(\n+        self.0.diagnostic.tool_only_span_suggestion(\n             sp,\n             msg,\n             suggestion,\n@@ -336,7 +348,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);\n \n     pub fn allow_suggestions(&mut self, allow: bool) -> &mut Self {\n-        self.allow_suggestions = allow;\n+        self.0.allow_suggestions = allow;\n         self\n     }\n \n@@ -359,19 +371,18 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n-    pub fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic)\n-                         -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder {\n+    pub fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder(Box::new(DiagnosticBuilderInner {\n             handler,\n             diagnostic,\n             allow_suggestions: true,\n-        }\n+        }))\n     }\n }\n \n impl<'a> Debug for DiagnosticBuilder<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.diagnostic.fmt(f)\n+        self.0.diagnostic.fmt(f)\n     }\n }\n \n@@ -381,7 +392,7 @@ impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n         if !panicking() && !self.cancelled() {\n             let mut db = DiagnosticBuilder::new(\n-                self.handler,\n+                self.0.handler,\n                 Level::Bug,\n                 \"the following error was constructed but not emitted\",\n             );"}, {"sha": "d238de2a17e29dade9065449f061a7427d6c12e4", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 139, "deletions": 129, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -247,17 +247,145 @@ pub trait Emitter {\n             (primary_span, &db.suggestions)\n         }\n     }\n+\n+    // This does a small \"fix\" for multispans by looking to see if it can find any that\n+    // point directly at <*macros>. Since these are often difficult to read, this\n+    // will change the span to point at the use site.\n+    fn fix_multispans_in_std_macros(&self,\n+                                    source_map: &Option<Lrc<SourceMapperDyn>>,\n+                                    span: &mut MultiSpan,\n+                                    children: &mut Vec<SubDiagnostic>,\n+                                    level: &Level,\n+                                    backtrace: bool) {\n+        let mut spans_updated = self.fix_multispan_in_std_macros(source_map, span, backtrace);\n+        for child in children.iter_mut() {\n+            spans_updated |= self.fix_multispan_in_std_macros(\n+                                 source_map,\n+                                 &mut child.span,\n+                                 backtrace\n+                             );\n+        }\n+        let msg = if level == &Error {\n+            \"this error originates in a macro outside of the current crate \\\n+             (in Nightly builds, run with -Z external-macro-backtrace \\\n+              for more info)\".to_string()\n+        } else {\n+            \"this warning originates in a macro outside of the current crate \\\n+             (in Nightly builds, run with -Z external-macro-backtrace \\\n+              for more info)\".to_string()\n+        };\n+\n+        if spans_updated {\n+            children.push(SubDiagnostic {\n+                level: Level::Note,\n+                message: vec![\n+                    (msg,\n+                     Style::NoStyle),\n+                ],\n+                span: MultiSpan::new(),\n+                render_span: None,\n+            });\n+        }\n+    }\n+\n+    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n+    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n+    // <*macros> to their corresponding use site.\n+    fn fix_multispan_in_std_macros(&self,\n+                                   source_map: &Option<Lrc<SourceMapperDyn>>,\n+                                   span: &mut MultiSpan,\n+                                   always_backtrace: bool) -> bool {\n+        let mut spans_updated = false;\n+\n+        if let Some(ref sm) = source_map {\n+            let mut before_after: Vec<(Span, Span)> = vec![];\n+            let mut new_labels: Vec<(Span, String)> = vec![];\n+\n+            // First, find all the spans in <*macros> and point instead at their use site\n+            for sp in span.primary_spans() {\n+                if sp.is_dummy() {\n+                    continue;\n+                }\n+                let call_sp = sm.call_span_if_macro(*sp);\n+                if call_sp != *sp && !always_backtrace {\n+                    before_after.push((*sp, call_sp));\n+                }\n+                let backtrace_len = sp.macro_backtrace().len();\n+                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n+                    // Only show macro locations that are local\n+                    // and display them like a span_note\n+                    if trace.def_site_span.is_dummy() {\n+                        continue;\n+                    }\n+                    if always_backtrace {\n+                        new_labels.push((trace.def_site_span,\n+                                            format!(\"in this expansion of `{}`{}\",\n+                                                    trace.macro_decl_name,\n+                                                    if backtrace_len > 2 {\n+                                                        // if backtrace_len == 1 it'll be pointed\n+                                                        // at by \"in this macro invocation\"\n+                                                        format!(\" (#{})\", i + 1)\n+                                                    } else {\n+                                                        String::new()\n+                                                    })));\n+                    }\n+                    // Check to make sure we're not in any <*macros>\n+                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n+                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n+                        !trace.macro_decl_name.starts_with(\"#[\") ||\n+                        always_backtrace {\n+                        new_labels.push((trace.call_site,\n+                                            format!(\"in this macro invocation{}\",\n+                                                    if backtrace_len > 2 && always_backtrace {\n+                                                        // only specify order when the macro\n+                                                        // backtrace is multiple levels deep\n+                                                        format!(\" (#{})\", i + 1)\n+                                                    } else {\n+                                                        String::new()\n+                                                    })));\n+                        if !always_backtrace {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            for (label_span, label_text) in new_labels {\n+                span.push_span_label(label_span, label_text);\n+            }\n+            for sp_label in span.span_labels() {\n+                if sp_label.span.is_dummy() {\n+                    continue;\n+                }\n+                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n+                    !always_backtrace\n+                {\n+                    let v = sp_label.span.macro_backtrace();\n+                    if let Some(use_site) = v.last() {\n+                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n+                    }\n+                }\n+            }\n+            // After we have them, make sure we replace these 'bad' def sites with their use sites\n+            for (before, after) in before_after {\n+                span.replace(before, after);\n+                spans_updated = true;\n+            }\n+        }\n+\n+        spans_updated\n+    }\n }\n \n impl Emitter for EmitterWriter {\n     fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n         let mut children = db.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n \n-        self.fix_multispans_in_std_macros(&mut primary_span,\n+        self.fix_multispans_in_std_macros(&self.sm,\n+                                          &mut primary_span,\n                                           &mut children,\n                                           &db.level,\n-                                          db.handler.flags.external_macro_backtrace);\n+                                          db.handler().flags.external_macro_backtrace);\n \n         self.emit_messages_default(&db.level,\n                                    &db.styled_message(),\n@@ -919,127 +1047,6 @@ impl EmitterWriter {\n         max\n     }\n \n-    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n-    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n-    // <*macros> to their corresponding use site.\n-    fn fix_multispan_in_std_macros(&mut self,\n-                                   span: &mut MultiSpan,\n-                                   always_backtrace: bool) -> bool {\n-        let mut spans_updated = false;\n-\n-        if let Some(ref sm) = self.sm {\n-            let mut before_after: Vec<(Span, Span)> = vec![];\n-            let mut new_labels: Vec<(Span, String)> = vec![];\n-\n-            // First, find all the spans in <*macros> and point instead at their use site\n-            for sp in span.primary_spans() {\n-                if sp.is_dummy() {\n-                    continue;\n-                }\n-                let call_sp = sm.call_span_if_macro(*sp);\n-                if call_sp != *sp && !always_backtrace {\n-                    before_after.push((*sp, call_sp));\n-                }\n-                let backtrace_len = sp.macro_backtrace().len();\n-                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n-                    // Only show macro locations that are local\n-                    // and display them like a span_note\n-                    if trace.def_site_span.is_dummy() {\n-                        continue;\n-                    }\n-                    if always_backtrace {\n-                        new_labels.push((trace.def_site_span,\n-                                            format!(\"in this expansion of `{}`{}\",\n-                                                    trace.macro_decl_name,\n-                                                    if backtrace_len > 2 {\n-                                                        // if backtrace_len == 1 it'll be pointed\n-                                                        // at by \"in this macro invocation\"\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                    }\n-                    // Check to make sure we're not in any <*macros>\n-                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n-                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n-                        !trace.macro_decl_name.starts_with(\"#[\") ||\n-                        always_backtrace {\n-                        new_labels.push((trace.call_site,\n-                                            format!(\"in this macro invocation{}\",\n-                                                    if backtrace_len > 2 && always_backtrace {\n-                                                        // only specify order when the macro\n-                                                        // backtrace is multiple levels deep\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                        if !always_backtrace {\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            for (label_span, label_text) in new_labels {\n-                span.push_span_label(label_span, label_text);\n-            }\n-            for sp_label in span.span_labels() {\n-                if sp_label.span.is_dummy() {\n-                    continue;\n-                }\n-                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n-                    !always_backtrace\n-                {\n-                    let v = sp_label.span.macro_backtrace();\n-                    if let Some(use_site) = v.last() {\n-                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n-                    }\n-                }\n-            }\n-            // After we have them, make sure we replace these 'bad' def sites with their use sites\n-            for (before, after) in before_after {\n-                span.replace(before, after);\n-                spans_updated = true;\n-            }\n-        }\n-\n-        spans_updated\n-    }\n-\n-    // This does a small \"fix\" for multispans by looking to see if it can find any that\n-    // point directly at <*macros>. Since these are often difficult to read, this\n-    // will change the span to point at the use site.\n-    fn fix_multispans_in_std_macros(&mut self,\n-                                    span: &mut MultiSpan,\n-                                    children: &mut Vec<SubDiagnostic>,\n-                                    level: &Level,\n-                                    backtrace: bool) {\n-        let mut spans_updated = self.fix_multispan_in_std_macros(span, backtrace);\n-        for child in children.iter_mut() {\n-            spans_updated |= self.fix_multispan_in_std_macros(&mut child.span, backtrace);\n-        }\n-        let msg = if level == &Error {\n-            \"this error originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\".to_string()\n-        } else {\n-            \"this warning originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\".to_string()\n-        };\n-\n-        if spans_updated {\n-            children.push(SubDiagnostic {\n-                level: Level::Note,\n-                message: vec![\n-                    (msg,\n-                     Style::NoStyle),\n-                ],\n-                span: MultiSpan::new(),\n-                render_span: None,\n-            });\n-        }\n-    }\n-\n     /// Adds a left margin to every line but the first, given a padding length and the label being\n     /// displayed, keeping the provided highlighting.\n     fn msg_to_buffer(&self,\n@@ -1137,15 +1144,18 @@ impl EmitterWriter {\n                 buffer.prepend(0, \" \", Style::NoStyle);\n             }\n             draw_note_separator(&mut buffer, 0, max_line_num_len + 1);\n-            let level_str = level.to_string();\n-            if !level_str.is_empty() {\n-                buffer.append(0, &level_str, Style::MainHeaderMsg);\n-                buffer.append(0, \": \", Style::NoStyle);\n+            if *level != Level::FailureNote {\n+                let level_str = level.to_string();\n+                if !level_str.is_empty() {\n+                    buffer.append(0, &level_str, Style::MainHeaderMsg);\n+                    buffer.append(0, \": \", Style::NoStyle);\n+                }\n             }\n             self.msg_to_buffer(&mut buffer, msg, max_line_num_len, \"note\", None);\n         } else {\n             let level_str = level.to_string();\n-            if !level_str.is_empty() {\n+            // The failure note level itself does not provide any useful diagnostic information\n+            if *level != Level::FailureNote && !level_str.is_empty() {\n                 buffer.append(0, &level_str, Style::Level(level.clone()));\n             }\n             // only render error codes, not lint codes\n@@ -1154,7 +1164,7 @@ impl EmitterWriter {\n                 buffer.append(0, &code, Style::Level(level.clone()));\n                 buffer.append(0, \"]\", Style::Level(level.clone()));\n             }\n-            if !level_str.is_empty() {\n+            if *level != Level::FailureNote && !level_str.is_empty() {\n                 buffer.append(0, \": \", header_style);\n             }\n             for &(ref text, _) in msg.iter() {"}, {"sha": "8b543be6e6497ba5d750673e24c2a5142796f681", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -833,7 +833,7 @@ impl Level {\n             Warning => \"warning\",\n             Note => \"note\",\n             Help => \"help\",\n-            FailureNote => \"\",\n+            FailureNote => \"failure-note\",\n             Cancelled => panic!(\"Shouldn't call on cancelled error\"),\n         }\n     }\n@@ -845,3 +845,10 @@ impl Level {\n         }\n     }\n }\n+\n+#[macro_export]\n+macro_rules! pluralise {\n+    ($x:expr) => {\n+        if $x != 1 { \"s\" } else { \"\" }\n+    };\n+}"}, {"sha": "659c4c89fe33c41272a68b3e073eb1b1abfe7413", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n-rand = \"0.6\"\n+rand = \"0.7\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }"}, {"sha": "e08eeaf85758eefdc619566da445814892f73977", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -27,7 +27,7 @@ use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::TyCtxt;\n use std::collections::BTreeSet;\n use syntax::ast;\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::{InternedString, Symbol, sym};\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED,\n                  ATTR_EXPECTED_CGU_REUSE};\n \n@@ -45,8 +45,8 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n             .collect_and_partition_mono_items(LOCAL_CRATE)\n             .1\n             .iter()\n-            .map(|cgu| format!(\"{}\", cgu.name()))\n-            .collect::<BTreeSet<String>>();\n+            .map(|cgu| *cgu.name())\n+            .collect::<BTreeSet<InternedString>>();\n \n         let ams = AssertModuleSource {\n             tcx,\n@@ -61,7 +61,7 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n \n struct AssertModuleSource<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    available_cgus: BTreeSet<String>,\n+    available_cgus: BTreeSet<InternedString>,\n }\n \n impl AssertModuleSource<'tcx> {\n@@ -127,15 +127,15 @@ impl AssertModuleSource<'tcx> {\n \n         debug!(\"mapping '{}' to cgu name '{}'\", self.field(attr, MODULE), cgu_name);\n \n-        if !self.available_cgus.contains(&cgu_name.as_str()[..]) {\n+        if !self.available_cgus.contains(&cgu_name) {\n             self.tcx.sess.span_err(attr.span,\n                 &format!(\"no module named `{}` (mangled: {}). \\\n                           Available modules: {}\",\n                     user_path,\n                     cgu_name,\n                     self.available_cgus\n                         .iter()\n-                        .cloned()\n+                        .map(|cgu| cgu.as_str().to_string())\n                         .collect::<Vec<_>>()\n                         .join(\", \")));\n         }"}, {"sha": "f6293107a940eeee46d717d8a9c7d34eee375e20", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -34,3 +34,4 @@ rustc_plugin = { path = \"../librustc_plugin\", package = \"rustc_plugin_impl\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n tempfile = \"3.0.5\"\n+once_cell = \"1\""}, {"sha": "79a343e0fee0bfcc2ce20a53e36fc92f822b0ec0", "filename": "src/librustc_interface/build.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_interface%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_interface%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fbuild.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=RUSTC_INSTALL_BINDIR\");\n+}"}, {"sha": "e8e8da67334712948bda3faf34b092e95e151bf9", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -34,14 +34,13 @@ use rustc_privacy;\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_traits;\n use rustc_typeck as typeck;\n-use syntax::{self, ast, diagnostics, visit};\n+use syntax::{self, ast, visit};\n use syntax::early_buffered_lints::BufferedEarlyLint;\n use syntax::ext::base::{NamedSyntaxExtension, ExtCtxt};\n use syntax::mut_visit::MutVisitor;\n use syntax::parse::{self, PResult};\n use syntax::util::node_count::NodeCounter;\n use syntax::symbol::Symbol;\n-use syntax::feature_gate::AttributeType;\n use syntax_pos::FileName;\n use syntax_ext;\n \n@@ -219,7 +218,6 @@ impl BoxedResolver {\n \n pub struct PluginInfo {\n     syntax_exts: Vec<NamedSyntaxExtension>,\n-    attributes: Vec<(Symbol, AttributeType)>,\n }\n \n pub fn register_plugins<'a>(\n@@ -230,10 +228,12 @@ pub fn register_plugins<'a>(\n     crate_name: &str,\n ) -> Result<(ast::Crate, PluginInfo)> {\n     krate = time(sess, \"attributes injection\", || {\n-        syntax::attr::inject(krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr)\n+        syntax_ext::cmdline_attrs::inject(\n+            krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr\n+        )\n     });\n \n-    let (mut krate, features) = syntax::config::features(\n+    let (krate, features) = syntax::config::features(\n         krate,\n         &sess.parse_sess,\n         sess.edition(),\n@@ -268,16 +268,6 @@ pub fn register_plugins<'a>(\n         middle::recursion_limit::update_limits(sess, &krate);\n     });\n \n-    krate = time(sess, \"crate injection\", || {\n-        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n-        let (krate, name) =\n-            syntax_ext::standard_library_imports::inject(krate, alt_std_name, sess.edition());\n-        if let Some(name) = name {\n-            sess.parse_sess.injected_crate_name.set(name);\n-        }\n-        krate\n-    });\n-\n     let registrars = time(sess, \"plugin loading\", || {\n         plugin::load::load_plugins(\n             sess,\n@@ -291,21 +281,6 @@ pub fn register_plugins<'a>(\n     let mut registry = Registry::new(sess, krate.span);\n \n     time(sess, \"plugin registration\", || {\n-        if sess.features_untracked().rustc_diagnostic_macros {\n-            registry.register_macro(\n-                \"__diagnostic_used\",\n-                diagnostics::plugin::expand_diagnostic_used,\n-            );\n-            registry.register_macro(\n-                \"__register_diagnostic\",\n-                diagnostics::plugin::expand_register_diagnostic,\n-            );\n-            registry.register_macro(\n-                \"__build_diagnostic_array\",\n-                diagnostics::plugin::expand_build_diagnostic_array,\n-            );\n-        }\n-\n         for registrar in registrars {\n             registry.args_hidden = Some(registrar.args);\n             (registrar.fun)(&mut registry);\n@@ -335,12 +310,9 @@ pub fn register_plugins<'a>(\n     }\n \n     *sess.plugin_llvm_passes.borrow_mut() = llvm_passes;\n-    *sess.plugin_attributes.borrow_mut() = attributes.clone();\n+    *sess.plugin_attributes.borrow_mut() = attributes;\n \n-    Ok((krate, PluginInfo {\n-        syntax_exts,\n-        attributes,\n-    }))\n+    Ok((krate, PluginInfo { syntax_exts }))\n }\n \n fn configure_and_expand_inner<'a>(\n@@ -352,7 +324,6 @@ fn configure_and_expand_inner<'a>(\n     crate_loader: &'a mut CrateLoader<'a>,\n     plugin_info: PluginInfo,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n-    let attributes = plugin_info.attributes;\n     time(sess, \"pre ast expansion lint checks\", || {\n         lint::check_ast_crate(\n             sess,\n@@ -370,6 +341,21 @@ fn configure_and_expand_inner<'a>(\n         &resolver_arenas,\n     );\n     syntax_ext::register_builtin_macros(&mut resolver, sess.edition());\n+\n+    krate = time(sess, \"crate injection\", || {\n+        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n+        let (krate, name) = syntax_ext::standard_library_imports::inject(\n+            krate,\n+            &mut resolver,\n+            &sess.parse_sess,\n+            alt_std_name,\n+        );\n+        if let Some(name) = name {\n+            sess.parse_sess.injected_crate_name.set(name);\n+        }\n+        krate\n+    });\n+\n     syntax_ext::plugin_macro_defs::inject(\n         &mut krate, &mut resolver, plugin_info.syntax_exts, sess.edition()\n     );\n@@ -530,7 +516,6 @@ fn configure_and_expand_inner<'a>(\n             &krate,\n             &sess.parse_sess,\n             &sess.features_untracked(),\n-            &attributes,\n             sess.opts.unstable_features,\n         );\n     });"}, {"sha": "b81f814de0f4a81b8c301a259ca06a0c4e905234", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 119, "deletions": 83, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -43,17 +43,17 @@ use std::{thread, panic};\n \n pub fn diagnostics_registry() -> Registry {\n     let mut all_errors = Vec::new();\n-    all_errors.extend_from_slice(&rustc::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_typeck::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_typeck::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_resolve::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_privacy::error_codes::DIAGNOSTICS);\n     // FIXME: need to figure out a way to get these back in here\n     // all_errors.extend_from_slice(get_codegen_backend(sess).diagnostics());\n-    all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_passes::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_plugin::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_mir::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&syntax::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_metadata::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_passes::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_plugin::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_mir::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&syntax::error_codes::DIAGNOSTICS);\n \n     Registry::new(&all_errors)\n }\n@@ -289,20 +289,39 @@ pub fn get_codegen_backend(sess: &Session) -> Box<dyn CodegenBackend> {\n     backend\n }\n \n-pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n-    // For now we only allow this function to be called once as it'll dlopen a\n-    // few things, which seems to work best if we only do that once. In\n-    // general this assertion never trips due to the once guard in `get_codegen_backend`,\n-    // but there's a few manual calls to this function in this file we protect\n-    // against.\n-    static LOADED: AtomicBool = AtomicBool::new(false);\n-    assert!(!LOADED.fetch_or(true, Ordering::SeqCst),\n-            \"cannot load the default codegen backend twice\");\n+// This is used for rustdoc, but it uses similar machinery to codegen backend\n+// loading, so we leave the code here. It is potentially useful for other tools\n+// that want to invoke the rustc binary while linking to rustc as well.\n+pub fn rustc_path<'a>() -> Option<&'a Path> {\n+    static RUSTC_PATH: once_cell::sync::OnceCell<Option<PathBuf>> =\n+        once_cell::sync::OnceCell::new();\n \n+    const BIN_PATH: &str = env!(\"RUSTC_INSTALL_BINDIR\");\n+\n+    RUSTC_PATH.get_or_init(|| get_rustc_path_inner(BIN_PATH)).as_ref().map(|v| &**v)\n+}\n+\n+fn get_rustc_path_inner(bin_path: &str) -> Option<PathBuf> {\n+    sysroot_candidates().iter()\n+        .filter_map(|sysroot| {\n+            let candidate = sysroot.join(bin_path).join(if cfg!(target_os = \"windows\") {\n+                \"rustc.exe\"\n+            } else {\n+                \"rustc\"\n+            });\n+            if candidate.exists() {\n+                Some(candidate)\n+            } else {\n+                None\n+            }\n+        })\n+        .next()\n+}\n+\n+fn sysroot_candidates() -> Vec<PathBuf> {\n     let target = session::config::host_triple();\n     let mut sysroot_candidates = vec![filesearch::get_or_default_sysroot()];\n-    let path = current_dll_path()\n-        .and_then(|s| s.canonicalize().ok());\n+    let path = current_dll_path().and_then(|s| s.canonicalize().ok());\n     if let Some(dll) = path {\n         // use `parent` twice to chop off the file name and then also the\n         // directory containing the dll which should be either `lib` or `bin`.\n@@ -327,69 +346,7 @@ pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend\n         }\n     }\n \n-    let sysroot = sysroot_candidates.iter()\n-        .map(|sysroot| {\n-            let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n-            sysroot.join(libdir).with_file_name(\n-                option_env!(\"CFG_CODEGEN_BACKENDS_DIR\").unwrap_or(\"codegen-backends\"))\n-        })\n-        .filter(|f| {\n-            info!(\"codegen backend candidate: {}\", f.display());\n-            f.exists()\n-        })\n-        .next();\n-    let sysroot = sysroot.unwrap_or_else(|| {\n-        let candidates = sysroot_candidates.iter()\n-            .map(|p| p.display().to_string())\n-            .collect::<Vec<_>>()\n-            .join(\"\\n* \");\n-        let err = format!(\"failed to find a `codegen-backends` folder \\\n-                           in the sysroot candidates:\\n* {}\", candidates);\n-        early_error(ErrorOutputType::default(), &err);\n-    });\n-    info!(\"probing {} for a codegen backend\", sysroot.display());\n-\n-    let d = sysroot.read_dir().unwrap_or_else(|e| {\n-        let err = format!(\"failed to load default codegen backend, couldn't \\\n-                           read `{}`: {}\", sysroot.display(), e);\n-        early_error(ErrorOutputType::default(), &err);\n-    });\n-\n-    let mut file: Option<PathBuf> = None;\n-\n-    let expected_name = format!(\"rustc_codegen_llvm-{}\", backend_name);\n-    for entry in d.filter_map(|e| e.ok()) {\n-        let path = entry.path();\n-        let filename = match path.file_name().and_then(|s| s.to_str()) {\n-            Some(s) => s,\n-            None => continue,\n-        };\n-        if !(filename.starts_with(DLL_PREFIX) && filename.ends_with(DLL_SUFFIX)) {\n-            continue\n-        }\n-        let name = &filename[DLL_PREFIX.len() .. filename.len() - DLL_SUFFIX.len()];\n-        if name != expected_name {\n-            continue\n-        }\n-        if let Some(ref prev) = file {\n-            let err = format!(\"duplicate codegen backends found\\n\\\n-                               first:  {}\\n\\\n-                               second: {}\\n\\\n-            \", prev.display(), path.display());\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-        file = Some(path.clone());\n-    }\n-\n-    match file {\n-        Some(ref s) => return load_backend_from_dylib(s),\n-        None => {\n-            let err = format!(\"failed to load default codegen backend for `{}`, \\\n-                               no appropriate codegen dylib found in `{}`\",\n-                              backend_name, sysroot.display());\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-    }\n+    return sysroot_candidates;\n \n     #[cfg(unix)]\n     fn current_dll_path() -> Option<PathBuf> {\n@@ -459,6 +416,85 @@ pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend\n     }\n }\n \n+pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n+    // For now we only allow this function to be called once as it'll dlopen a\n+    // few things, which seems to work best if we only do that once. In\n+    // general this assertion never trips due to the once guard in `get_codegen_backend`,\n+    // but there's a few manual calls to this function in this file we protect\n+    // against.\n+    static LOADED: AtomicBool = AtomicBool::new(false);\n+    assert!(!LOADED.fetch_or(true, Ordering::SeqCst),\n+            \"cannot load the default codegen backend twice\");\n+\n+    let target = session::config::host_triple();\n+    let sysroot_candidates = sysroot_candidates();\n+\n+    let sysroot = sysroot_candidates.iter()\n+        .map(|sysroot| {\n+            let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n+            sysroot.join(libdir).with_file_name(\n+                option_env!(\"CFG_CODEGEN_BACKENDS_DIR\").unwrap_or(\"codegen-backends\"))\n+        })\n+        .filter(|f| {\n+            info!(\"codegen backend candidate: {}\", f.display());\n+            f.exists()\n+        })\n+        .next();\n+    let sysroot = sysroot.unwrap_or_else(|| {\n+        let candidates = sysroot_candidates.iter()\n+            .map(|p| p.display().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n* \");\n+        let err = format!(\"failed to find a `codegen-backends` folder \\\n+                           in the sysroot candidates:\\n* {}\", candidates);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n+    info!(\"probing {} for a codegen backend\", sysroot.display());\n+\n+    let d = sysroot.read_dir().unwrap_or_else(|e| {\n+        let err = format!(\"failed to load default codegen backend, couldn't \\\n+                           read `{}`: {}\", sysroot.display(), e);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n+\n+    let mut file: Option<PathBuf> = None;\n+\n+    let expected_name = format!(\"rustc_codegen_llvm-{}\", backend_name);\n+    for entry in d.filter_map(|e| e.ok()) {\n+        let path = entry.path();\n+        let filename = match path.file_name().and_then(|s| s.to_str()) {\n+            Some(s) => s,\n+            None => continue,\n+        };\n+        if !(filename.starts_with(DLL_PREFIX) && filename.ends_with(DLL_SUFFIX)) {\n+            continue\n+        }\n+        let name = &filename[DLL_PREFIX.len() .. filename.len() - DLL_SUFFIX.len()];\n+        if name != expected_name {\n+            continue\n+        }\n+        if let Some(ref prev) = file {\n+            let err = format!(\"duplicate codegen backends found\\n\\\n+                               first:  {}\\n\\\n+                               second: {}\\n\\\n+            \", prev.display(), path.display());\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+        file = Some(path.clone());\n+    }\n+\n+    match file {\n+        Some(ref s) => return load_backend_from_dylib(s),\n+        None => {\n+            let err = format!(\"failed to load default codegen backend for `{}`, \\\n+                               no appropriate codegen dylib found in `{}`\",\n+                              backend_name, sysroot.display());\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+    }\n+\n+}\n+\n pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguator {\n     use std::hash::Hasher;\n "}, {"sha": "950771f0a692710021dc7e29c18736fdbbe3ea0b", "filename": "src/librustc_lexer/Cargo.toml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lexer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lexer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2FCargo.toml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -2,8 +2,14 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc_lexer\"\n version = \"0.1.0\"\n+license = \"MIT OR Apache-2.0\"\n edition = \"2018\"\n \n+repository = \"https://github.com/rust-lang/rust/\"\n+description = \"\"\"\n+Rust lexer used by rustc. No stability guarantees are provided.\n+\"\"\"\n+\n # Note: do not remove this blank `[lib]` section.\n # This will be used when publishing this crate as `rustc-ap-rustc_lexer`.\n [lib]"}, {"sha": "cf19a9eb147a8c1560bfa9d860a9d3cb58f6990f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -669,6 +669,22 @@ impl DeprecatedAttr {\n     }\n }\n \n+fn lint_deprecated_attr(\n+    cx: &EarlyContext<'_>,\n+    attr: &ast::Attribute,\n+    msg: &str,\n+    suggestion: Option<&str>,\n+) {\n+    cx.struct_span_lint(DEPRECATED, attr.span, &msg)\n+        .span_suggestion_short(\n+            attr.span,\n+            suggestion.unwrap_or(\"remove this attribute\"),\n+            String::new(),\n+            Applicability::MachineApplicable\n+        )\n+        .emit();\n+}\n+\n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         for &&(n, _, _, ref g) in &self.depr_attrs {\n@@ -679,18 +695,15 @@ impl EarlyLintPass for DeprecatedAttr {\n                                              _) = g {\n                     let msg = format!(\"use of deprecated attribute `{}`: {}. See {}\",\n                                       name, reason, link);\n-                    let mut err = cx.struct_span_lint(DEPRECATED, attr.span, &msg);\n-                    err.span_suggestion_short(\n-                        attr.span,\n-                        suggestion.unwrap_or(\"remove this attribute\"),\n-                        String::new(),\n-                        Applicability::MachineApplicable\n-                    );\n-                    err.emit();\n+                    lint_deprecated_attr(cx, attr, &msg, suggestion);\n                 }\n                 return;\n             }\n         }\n+        if attr.check_name(sym::no_start) || attr.check_name(sym::crate_id) {\n+            let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", attr.path);\n+            lint_deprecated_attr(cx, attr, &msg, None);\n+        }\n     }\n }\n \n@@ -772,7 +785,7 @@ impl EarlyLintPass for UnusedDocComment {\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n-        let arm_span = arm.pats[0].span.with_hi(arm.body.span.hi());\n+        let arm_span = arm.pat.span.with_hi(arm.body.span.hi());\n         self.warn_if_doc(cx, arm_span, \"match arms\", false, &arm.attrs);\n     }\n "}, {"sha": "ea2e1d9ecc53f46553207c643ec5eed7c560de96", "filename": "src/librustc_lint/error_codes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lint%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lint%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ferror_codes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,5 +1,4 @@\n-use syntax::register_diagnostics;\n-\n-register_diagnostics! {\n+syntax::register_diagnostics! {\n+;\n     E0721, // `await` keyword\n }"}, {"sha": "0e054013cd779ed30eab29353d0dd4c1c7cc9b33", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -15,7 +15,6 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(nll)]\n-#![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]\n \n@@ -436,7 +435,12 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(INDIRECT_STRUCTURAL_MATCH),\n             reference: \"issue #62411 <https://github.com/rust-lang/rust/issues/62411>\",\n             edition: None,\n-        }\n+        },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(SOFT_UNSTABLE),\n+            reference: \"issue #64266 <https://github.com/rust-lang/rust/issues/64266>\",\n+            edition: None,\n+        },\n         ]);\n \n     // Register renamed and removed lints."}, {"sha": "3b8c06ba154c605218c2939f980b2f7c10fb691a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 82, "deletions": 31, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -624,7 +624,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     AdtKind::Struct => {\n                         if !def.repr.c() && !def.repr.transparent() {\n                             return FfiUnsafe {\n-                                ty: ty,\n+                                ty,\n                                 reason: \"this struct has unspecified layout\",\n                                 help: Some(\"consider adding a `#[repr(C)]` or \\\n                                             `#[repr(transparent)]` attribute to this struct\"),\n@@ -633,7 +633,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                         if def.non_enum_variant().fields.is_empty() {\n                             return FfiUnsafe {\n-                                ty: ty,\n+                                ty,\n                                 reason: \"this struct has no fields\",\n                                 help: Some(\"consider adding a member to this struct\"),\n                             };\n@@ -669,7 +669,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     AdtKind::Union => {\n                         if !def.repr.c() && !def.repr.transparent() {\n                             return FfiUnsafe {\n-                                ty: ty,\n+                                ty,\n                                 reason: \"this union has unspecified layout\",\n                                 help: Some(\"consider adding a `#[repr(C)]` or \\\n                                             `#[repr(transparent)]` attribute to this union\"),\n@@ -678,7 +678,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                         if def.non_enum_variant().fields.is_empty() {\n                             return FfiUnsafe {\n-                                ty: ty,\n+                                ty,\n                                 reason: \"this union has no fields\",\n                                 help: Some(\"consider adding a field to this union\"),\n                             };\n@@ -721,7 +721,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             // Special-case types like `Option<extern fn()>`.\n                             if !is_repr_nullable_ptr(cx, ty, def, substs) {\n                                 return FfiUnsafe {\n-                                    ty: ty,\n+                                    ty,\n                                     reason: \"enum has no representation hint\",\n                                     help: Some(\"consider adding a `#[repr(C)]`, \\\n                                                 `#[repr(transparent)]`, or integer `#[repr(...)]` \\\n@@ -750,7 +750,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                     }\n                                     FfiPhantom(..) => {\n                                         return FfiUnsafe {\n-                                            ty: ty,\n+                                            ty,\n                                             reason: \"this enum contains a PhantomData field\",\n                                             help: None,\n                                         };\n@@ -764,13 +764,13 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             }\n \n             ty::Char => FfiUnsafe {\n-                ty: ty,\n+                ty,\n                 reason: \"the `char` type has no C equivalent\",\n                 help: Some(\"consider using `u32` or `libc::wchar_t` instead\"),\n             },\n \n             ty::Int(ast::IntTy::I128) | ty::Uint(ast::UintTy::U128) => FfiUnsafe {\n-                ty: ty,\n+                ty,\n                 reason: \"128-bit integers don't currently have a known stable ABI\",\n                 help: None,\n             },\n@@ -779,25 +779,25 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::Bool | ty::Int(..) | ty::Uint(..) | ty::Float(..) | ty::Never => FfiSafe,\n \n             ty::Slice(_) => FfiUnsafe {\n-                ty: ty,\n+                ty,\n                 reason: \"slices have no C equivalent\",\n                 help: Some(\"consider using a raw pointer instead\"),\n             },\n \n             ty::Dynamic(..) => FfiUnsafe {\n-                ty: ty,\n+                ty,\n                 reason: \"trait objects have no C equivalent\",\n                 help: None,\n             },\n \n             ty::Str => FfiUnsafe {\n-                ty: ty,\n+                ty,\n                 reason: \"string slices have no C equivalent\",\n                 help: Some(\"consider using `*const u8` and a length instead\"),\n             },\n \n             ty::Tuple(..) => FfiUnsafe {\n-                ty: ty,\n+                ty,\n                 reason: \"tuples have unspecified layout\",\n                 help: Some(\"consider using a struct instead\"),\n             },\n@@ -811,7 +811,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 match sig.abi() {\n                     Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic | Abi::RustCall => {\n                         return FfiUnsafe {\n-                            ty: ty,\n+                            ty,\n                             reason: \"this function pointer has Rust-specific calling convention\",\n                             help: Some(\"consider using an `extern fn(...) -> ...` \\\n                                         function pointer instead\"),\n@@ -855,36 +855,87 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::UnnormalizedProjection(..) |\n             ty::Projection(..) |\n             ty::Opaque(..) |\n-            ty::FnDef(..) => bug!(\"Unexpected type in foreign function\"),\n+            ty::FnDef(..) => bug!(\"unexpected type in foreign function: {:?}\", ty),\n+        }\n+    }\n+\n+    fn emit_ffi_unsafe_type_lint(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        sp: Span,\n+        note: &str,\n+        help: Option<&str>,\n+    ) {\n+        let mut diag = self.cx.struct_span_lint(\n+            IMPROPER_CTYPES,\n+            sp,\n+            &format!(\"`extern` block uses type `{}`, which is not FFI-safe\", ty),\n+        );\n+        diag.span_label(sp, \"not FFI-safe\");\n+        if let Some(help) = help {\n+            diag.help(help);\n+        }\n+        diag.note(note);\n+        if let ty::Adt(def, _) = ty.sty {\n+            if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did) {\n+                diag.span_note(sp, \"type defined here\");\n+            }\n+        }\n+        diag.emit();\n+    }\n+\n+    fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n+        use crate::rustc::ty::TypeFoldable;\n+\n+        struct ProhibitOpaqueTypes<'tcx> {\n+            ty: Option<Ty<'tcx>>,\n+        };\n+\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueTypes<'tcx> {\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+                if let ty::Opaque(..) = ty.sty {\n+                    self.ty = Some(ty);\n+                    true\n+                } else {\n+                    ty.super_visit_with(self)\n+                }\n+            }\n+        }\n+\n+        let mut visitor = ProhibitOpaqueTypes { ty: None };\n+        ty.visit_with(&mut visitor);\n+        if let Some(ty) = visitor.ty {\n+            self.emit_ffi_unsafe_type_lint(\n+                ty,\n+                sp,\n+                \"opaque types have no C equivalent\",\n+                None,\n+            );\n+            true\n+        } else {\n+            false\n         }\n     }\n \n     fn check_type_for_ffi_and_report_errors(&mut self, sp: Span, ty: Ty<'tcx>) {\n+        // We have to check for opaque types before `normalize_erasing_regions`,\n+        // which will replace opaque types with their underlying concrete type.\n+        if self.check_for_opaque_ty(sp, ty) {\n+            // We've already emitted an error due to an opaque type.\n+            return;\n+        }\n+\n         // it is only OK to use this function because extern fns cannot have\n         // any generic types right now:\n         let ty = self.cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n \n         match self.check_type_for_ffi(&mut FxHashSet::default(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiPhantom(ty) => {\n-                self.cx.span_lint(IMPROPER_CTYPES,\n-                                  sp,\n-                                  &format!(\"`extern` block uses type `{}` which is not FFI-safe: \\\n-                                            composed only of PhantomData\", ty));\n+                self.emit_ffi_unsafe_type_lint(ty, sp, \"composed only of `PhantomData`\", None);\n             }\n-            FfiResult::FfiUnsafe { ty: unsafe_ty, reason, help } => {\n-                let msg = format!(\"`extern` block uses type `{}` which is not FFI-safe: {}\",\n-                                  unsafe_ty, reason);\n-                let mut diag = self.cx.struct_span_lint(IMPROPER_CTYPES, sp, &msg);\n-                if let Some(s) = help {\n-                    diag.help(s);\n-                }\n-                if let ty::Adt(def, _) = unsafe_ty.sty {\n-                    if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did) {\n-                        diag.span_note(sp, \"type defined here\");\n-                    }\n-                }\n-                diag.emit();\n+            FfiResult::FfiUnsafe { ty, reason, help } => {\n+                self.emit_ffi_unsafe_type_lint(ty, sp, reason, help);\n             }\n         }\n     }"}, {"sha": "c3975098351af9f83fed30a3f7d5587aa88905c5", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -370,7 +370,8 @@ impl UnusedParens {\n                                      right_pos: Option<BytePos>) {\n         match value.node {\n             ast::ExprKind::Paren(ref inner) => {\n-                if !Self::is_expr_parens_necessary(inner, followed_by_block) {\n+                if !Self::is_expr_parens_necessary(inner, followed_by_block) &&\n+                    value.attrs.is_empty() {\n                     let expr_text = if let Ok(snippet) = cx.sess().source_map()\n                         .span_to_snippet(value.span) {\n                             snippet\n@@ -493,10 +494,8 @@ impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use syntax::ast::ExprKind::*;\n         let (value, msg, followed_by_block, left_pos, right_pos) = match e.node {\n-            Let(ref pats, ..) => {\n-                for p in pats {\n-                    self.check_unused_parens_pat(cx, p, false, false);\n-                }\n+            Let(ref pat, ..) => {\n+                self.check_unused_parens_pat(cx, pat, false, false);\n                 return;\n             }\n \n@@ -594,9 +593,7 @@ impl EarlyLintPass for UnusedParens {\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n-        for p in &arm.pats {\n-            self.check_unused_parens_pat(cx, p, false, false);\n-        }\n+        self.check_unused_parens_pat(cx, &arm.pat, false, false);\n     }\n }\n \n@@ -622,24 +619,19 @@ impl UnusedImportBraces {\n             }\n \n             // Trigger the lint if the nested item is a non-self single item\n-            let node_ident;\n-            match items[0].0.kind {\n+            let node_name = match items[0].0.kind {\n                 ast::UseTreeKind::Simple(rename, ..) => {\n                     let orig_ident = items[0].0.prefix.segments.last().unwrap().ident;\n                     if orig_ident.name == kw::SelfLower {\n                         return;\n                     }\n-                    node_ident = rename.unwrap_or(orig_ident);\n-                }\n-                ast::UseTreeKind::Glob => {\n-                    node_ident = ast::Ident::from_str(\"*\");\n+                    rename.unwrap_or(orig_ident).name\n                 }\n-                ast::UseTreeKind::Nested(_) => {\n-                    return;\n-                }\n-            }\n+                ast::UseTreeKind::Glob => Symbol::intern(\"*\"),\n+                ast::UseTreeKind::Nested(_) => return,\n+            };\n \n-            let msg = format!(\"braces around {} is unnecessary\", node_ident.name);\n+            let msg = format!(\"braces around {} is unnecessary\", node_name);\n             cx.span_lint(UNUSED_IMPORT_BRACES, item.span, &msg);\n         }\n     }"}, {"sha": "73720d8c2d64ec32b65855c84edfc2cbf240a6b7", "filename": "src/librustc_lsan/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lsan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_lsan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2Fbuild.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -4,6 +4,10 @@ use build_helper::sanitizer_lib_boilerplate;\n use cmake::Config;\n \n fn main() {\n+    println!(\"cargo:rerun-if-env-changed=RUSTC_BUILD_SANITIZERS\");\n+    if env::var(\"RUSTC_BUILD_SANITIZERS\") != Ok(\"1\".to_string()) {\n+        return;\n+    }\n     if let Some(llvm_config) = env::var_os(\"LLVM_CONFIG\") {\n         build_helper::restore_library_path();\n "}, {"sha": "a1e3bbcbf8ea94d8205ca043e9fe7a0f780a9525", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -444,7 +444,8 @@ impl cstore::CStore {\n             .insert(local_span, (name.to_string(), data.get_span(id.index, sess)));\n \n         LoadedMacro::MacroDef(ast::Item {\n-            ident: ast::Ident::from_str(&name.as_str()),\n+            // FIXME: cross-crate hygiene\n+            ident: ast::Ident::with_dummy_span(name.as_symbol()),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),"}, {"sha": "34c84b1d79d4b0030a418cb4328bb94bb407f952", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -489,7 +489,11 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n-        // with items in 'raw_proc_macros'\n+        // with items in 'raw_proc_macros'.\n+        // NOTE: If you update the order of macros in 'proc_macro_data' for any reason,\n+        // you must also update src/libsyntax_ext/proc_macro_harness.rs\n+        // Failing to do so will result in incorrect data being associated\n+        // with proc macros when deserialized.\n         let pos = self.root.proc_macro_data.unwrap().decode(self).position(|i| i == id).unwrap();\n         &self.raw_proc_macros.unwrap()[pos]\n     }"}, {"sha": "cd8e95e6c3a1101786cd08bc55fba6b8bc0c7a37", "filename": "src/librustc_metadata/error_codes.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_metadata%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_metadata%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ferror_codes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,6 +1,4 @@\n-use syntax::{register_diagnostics, register_long_diagnostics};\n-\n-register_long_diagnostics! {\n+syntax::register_diagnostics! {\n E0454: r##\"\n A link name was given with an empty name. Erroneous code example:\n \n@@ -84,10 +82,7 @@ You need to link your code to the relevant crate in order to be able to use it\n (through Cargo or the `-L` option of rustc example). Plugins are crates as\n well, and you link to them the same way.\n \"##,\n-\n-}\n-\n-register_diagnostics! {\n+;\n     E0456, // plugin `..` is not available for triple `..`\n     E0457, // plugin `..` only found in rlib format, but must be available...\n     E0514, // metadata version mismatch\n@@ -97,5 +92,6 @@ register_diagnostics! {\n     E0464, // multiple matching crates for `..`\n     E0465, // multiple .. candidates for `..` found\n     E0519, // local crate and dependency have same (crate-name, disambiguator)\n-    E0523, // two dependencies have same (crate-name, disambiguator) but different SVH\n+    // two dependencies have same (crate-name, disambiguator) but different SVH\n+    E0523,\n }"}, {"sha": "e6104e629e9fbfefbec87db6c2dc3a602e2137e9", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -8,7 +8,6 @@\n #![feature(nll)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(specialization)]\n@@ -23,7 +22,7 @@ extern crate rustc;\n #[macro_use]\n extern crate rustc_data_structures;\n \n-mod error_codes;\n+pub mod error_codes;\n \n mod index;\n mod encoder;\n@@ -68,5 +67,3 @@ pub fn validate_crate_name(\n         sess.unwrap().abort_if_errors();\n     }\n }\n-\n-__build_diagnostic_array! { librustc_metadata, DIAGNOSTICS }"}, {"sha": "ada1a8c615d44743ac3d9ce3f5171c7322f8ae22", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -8,7 +8,7 @@ use rustc_target::spec::abi::Abi;\n use syntax::attr;\n use syntax::source_map::Span;\n use syntax::feature_gate::{self, GateIssue};\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::{kw, sym, Symbol};\n use syntax::{span_err, struct_span_err};\n \n pub fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n@@ -132,7 +132,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n \n impl Collector<'tcx> {\n     fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLibrary) {\n-        if lib.name.as_ref().map(|s| s.as_str().is_empty()).unwrap_or(false) {\n+        if lib.name.as_ref().map(|&s| s == kw::Invalid).unwrap_or(false) {\n             match span {\n                 Some(span) => {\n                     struct_span_err!(self.tcx.sess, span, E0454,\n@@ -159,15 +159,15 @@ impl Collector<'tcx> {\n                                            sym::link_cfg,\n                                            span.unwrap(),\n                                            GateIssue::Language,\n-                                           \"is feature gated\");\n+                                           \"is unstable\");\n         }\n         if lib.kind == cstore::NativeStaticNobundle &&\n            !self.tcx.features().static_nobundle {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n                                            sym::static_nobundle,\n                                            span.unwrap_or_else(|| syntax_pos::DUMMY_SP),\n                                            GateIssue::Language,\n-                                           \"kind=\\\"static-nobundle\\\" is feature gated\");\n+                                           \"kind=\\\"static-nobundle\\\" is unstable\");\n         }\n         self.libs.push(lib);\n     }"}, {"sha": "0691390bead4beaeffd0053589277a192fd17788", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -24,6 +24,6 @@ rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-byteorder = { version = \"1.1\", features = [\"i128\"] }\n+byteorder = { version = \"1.3\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "db19cbc3175f8c60be5c0edbcdd637525134cc49", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -317,7 +317,7 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n         // so extract `temp`.\n         let temp = if let &mir::Place {\n             base: mir::PlaceBase::Local(temp),\n-            projection: None,\n+            projection: box [],\n         } = assigned_place {\n             temp\n         } else {"}, {"sha": "81359c6a46e992822ea40fb9266ceb30f3bfa3af", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -2,8 +2,8 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, Projection, PlaceRef,\n-    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue,\n+    Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n@@ -98,7 +98,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 &self.describe_place_with_options(moved_place, IncludingDowncast(true))\n                     .unwrap_or_else(|| \"_\".to_owned()),\n             );\n-            err.span_label(span, format!(\"use of possibly uninitialized {}\", item_msg));\n+            err.span_label(span, format!(\"use of possibly-uninitialized {}\", item_msg));\n \n             use_spans.var_span_label(\n                 &mut err,\n@@ -244,7 +244,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 let span = if let Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } = place {\n                     let decl = &self.body.local_decls[*local];\n                     Some(decl.source_info.span)\n@@ -614,17 +614,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = first_borrowed_place;\n \n-                let mut current = projection;\n+                let mut cursor = &**projection;\n+                while let [proj_base @ .., elem] = cursor {\n+                    cursor = proj_base;\n \n-                while let Some(box Projection { base: base_proj, elem }) = current {\n                     match elem {\n-                        ProjectionElem::Field(field, _) if union_ty(base, base_proj).is_some() => {\n+                        ProjectionElem::Field(field, _) if union_ty(base, proj_base).is_some() => {\n                             return Some((PlaceRef {\n                                 base: base,\n-                                projection: base_proj,\n+                                projection: proj_base,\n                             }, field));\n                         },\n-                        _ => current = base_proj,\n+                        _ => {},\n                     }\n                 }\n                 None\n@@ -637,9 +638,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = second_borrowed_place;\n \n-                let mut current = projection;\n+                let mut cursor = &**projection;\n+                while let [proj_base @ .., elem] = cursor {\n+                    cursor = proj_base;\n \n-                while let Some(box Projection { base: proj_base, elem }) = current {\n                     if let ProjectionElem::Field(field, _) = elem {\n                         if let Some(union_ty) = union_ty(base, proj_base) {\n                             if field != target_field\n@@ -660,8 +662,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                         }\n                     }\n-\n-                    current = proj_base;\n                 }\n                 None\n             })\n@@ -707,7 +707,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n-        assert!(root_place.projection.is_none());\n+        assert!(root_place.projection.is_empty());\n         let proper_span = match root_place.base {\n             PlaceBase::Local(local) => self.body.local_decls[*local].source_info.span,\n             _ => drop_span,\n@@ -716,7 +716,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if self.access_place_error_reported\n             .contains(&(Place {\n                 base: root_place.base.clone(),\n-                projection: root_place.projection.clone(),\n+                projection: root_place.projection.to_vec().into_boxed_slice(),\n             }, borrow_span))\n         {\n             debug!(\n@@ -729,7 +729,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.access_place_error_reported\n             .insert((Place {\n                 base: root_place.base.clone(),\n-                projection: root_place.projection.clone(),\n+                projection: root_place.projection.to_vec().into_boxed_slice(),\n             }, borrow_span));\n \n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n@@ -1107,7 +1107,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let local_kind = match borrow.borrowed_place {\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } => {\n                     match self.body.local_kind(local) {\n                         LocalKind::ReturnPointer\n@@ -1136,7 +1136,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 .unwrap();\n             let local = if let PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } = root_place {\n                 local\n             } else {\n@@ -1446,7 +1446,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         let (from_arg, local_decl) = if let Place {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: box [],\n         } = *err_place {\n             if let LocalKind::Arg = self.body.local_kind(local) {\n                 (true, Some(&self.body.local_decls[local]))\n@@ -1519,28 +1519,29 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn classify_drop_access_kind(&self, place: PlaceRef<'cx, 'tcx>) -> StorageDeadOrDrop<'tcx> {\n         let tcx = self.infcx.tcx;\n         match place.projection {\n-            None => {\n+            [] => {\n                 StorageDeadOrDrop::LocalStorageDead\n             }\n-            Some(box Projection { ref base, ref elem }) => {\n+            [proj_base @ .., elem] => {\n+                // FIXME(spastorino) make this iterate\n                 let base_access = self.classify_drop_access_kind(PlaceRef {\n                     base: place.base,\n-                    projection: base,\n+                    projection: proj_base,\n                 });\n                 match elem {\n                     ProjectionElem::Deref => match base_access {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                Place::ty_from(&place.base, base, self.body, tcx).ty.is_box(),\n+                                Place::ty_from(&place.base, proj_base, self.body, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = Place::ty_from(&place.base, base, self.body, tcx).ty;\n+                        let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n                         match base_ty.sty {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n@@ -1598,7 +1599,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"annotate_argument_and_return_for_borrow: location={:?}\",\n             location\n         );\n-        if let Some(&Statement { kind: StatementKind::Assign(ref reservation, _), ..})\n+        if let Some(&Statement { kind: StatementKind::Assign(box(ref reservation, _)), ..})\n              = &self.body[location.block].statements.get(location.statement_index)\n         {\n             debug!(\n@@ -1609,7 +1610,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let mut target = *match reservation {\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } if self.body.local_kind(*local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n@@ -1623,11 +1624,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     target, stmt\n                 );\n                 if let StatementKind::Assign(\n-                    Place {\n-                        base: PlaceBase::Local(assigned_to),\n-                        projection: None,\n-                    },\n-                    box rvalue\n+                    box(\n+                        Place {\n+                            base: PlaceBase::Local(assigned_to),\n+                            projection: box [],\n+                        },\n+                        rvalue\n+                    )\n                 ) = &stmt.kind {\n                     debug!(\n                         \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n@@ -1753,7 +1756,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let TerminatorKind::Call {\n                 destination: Some((Place {\n                     base: PlaceBase::Local(assigned_to),\n-                    projection: None,\n+                    projection: box [],\n                 }, _)),\n                 args,\n                 .."}, {"sha": "5bccd2835c980d32f6d75caee10ead5fa486e834", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -41,7 +41,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut target = place.local_or_deref_local();\n         for stmt in &self.body[location.block].statements[location.statement_index..] {\n             debug!(\"add_moved_or_invoked_closure_note: stmt={:?} target={:?}\", stmt, target);\n-            if let StatementKind::Assign(into, box Rvalue::Use(from)) = &stmt.kind {\n+            if let StatementKind::Assign(box(into, Rvalue::Use(from))) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n                 match from {\n                     Operand::Copy(ref place) |\n@@ -152,7 +152,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 self.append_local_to_string(*local, buf)?;\n             }\n@@ -162,7 +162,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         kind: StaticKind::Promoted(..),\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 buf.push_str(\"promoted\");\n             }\n@@ -173,15 +173,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         def_id,\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n             }\n             PlaceRef {\n                 base,\n-                projection: Some(ref proj),\n+                projection: [proj_base @ .., elem],\n             } => {\n-                match proj.elem {\n+                match elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection =\n                             self.is_upvar_field_projection(place);\n@@ -199,20 +199,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 self.append_place_to_string(\n                                     PlaceRef {\n                                         base,\n-                                        projection: &proj.base,\n+                                        projection: proj_base,\n                                     },\n                                     buf,\n                                     autoderef,\n                                     &including_downcast,\n                                 )?;\n                             } else {\n-                                match (&proj.base, base) {\n-                                    (None, PlaceBase::Local(local)) => {\n+                                match (proj_base, base) {\n+                                    ([], PlaceBase::Local(local)) => {\n                                         if self.body.local_decls[*local].is_ref_for_guard() {\n                                             self.append_place_to_string(\n                                                 PlaceRef {\n                                                     base,\n-                                                    projection: &proj.base,\n+                                                    projection: proj_base,\n                                                 },\n                                                 buf,\n                                                 autoderef,\n@@ -224,7 +224,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                             self.append_place_to_string(\n                                                 PlaceRef {\n                                                     base,\n-                                                    projection: &proj.base,\n+                                                    projection: proj_base,\n                                                 },\n                                                 buf,\n                                                 autoderef,\n@@ -238,7 +238,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                         self.append_place_to_string(\n                                             PlaceRef {\n                                                 base,\n-                                                projection: &proj.base,\n+                                                projection: proj_base,\n                                             },\n                                             buf,\n                                             autoderef,\n@@ -253,7 +253,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.append_place_to_string(\n                             PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             buf,\n                             autoderef,\n@@ -275,12 +275,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         } else {\n                             let field_name = self.describe_field(PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n-                            }, field);\n+                                projection: proj_base,\n+                            }, *field);\n                             self.append_place_to_string(\n                                 PlaceRef {\n                                     base,\n-                                    projection: &proj.base,\n+                                    projection: proj_base,\n                                 },\n                                 buf,\n                                 autoderef,\n@@ -295,14 +295,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.append_place_to_string(\n                             PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n                         )?;\n                         buf.push_str(\"[\");\n-                        if self.append_local_to_string(index, buf).is_err() {\n+                        if self.append_local_to_string(*index, buf).is_err() {\n                             buf.push_str(\"_\");\n                         }\n                         buf.push_str(\"]\");\n@@ -315,7 +315,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.append_place_to_string(\n                             PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             buf,\n                             autoderef,\n@@ -349,28 +349,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 let local = &self.body.local_decls[*local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n             PlaceRef {\n                 base: PlaceBase::Static(static_),\n-                projection: None,\n+                projection: [],\n             } =>\n                 self.describe_field_from_ty(&static_.ty, field, None),\n             PlaceRef {\n                 base,\n-                projection: Some(proj),\n-            } => match proj.elem {\n-                ProjectionElem::Deref => self.describe_field(PlaceRef {\n-                    base,\n-                    projection: &proj.base,\n-                }, field),\n+                projection: [proj_base @ .., elem],\n+            } => match elem {\n+                ProjectionElem::Deref => {\n+                    self.describe_field(PlaceRef {\n+                        base,\n+                        projection: proj_base,\n+                    }, field)\n+                }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty =\n                         Place::ty_from(place.base, place.projection, self.body, self.infcx.tcx).ty;\n-                    self.describe_field_from_ty(&base_ty, field, Some(variant_index))\n+                    self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n                     self.describe_field_from_ty(&field_type, field, None)\n@@ -380,7 +382,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 | ProjectionElem::Subslice { .. } => {\n                     self.describe_field(PlaceRef {\n                         base,\n-                        projection: &proj.base,\n+                        projection: proj_base,\n                     }, field)\n                 }\n             },\n@@ -445,7 +447,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 def_id,\n                 ..\n             }),\n-            projection: None,\n+            projection: [],\n         } = place_ref {\n             let attrs = self.infcx.tcx.get_attrs(*def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n@@ -790,8 +792,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n         if let  StatementKind::Assign(\n-            _,\n-            box Rvalue::Aggregate(ref kind, ref places)\n+            box(_, Rvalue::Aggregate(ref kind, ref places))\n         ) = stmt.kind {\n             let (def_id, is_generator) = match kind {\n                 box AggregateKind::Closure(def_id, _) => (def_id, false),\n@@ -828,10 +829,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .get(location.statement_index)\n         {\n             Some(&Statement {\n-                kind: StatementKind::Assign(Place {\n+                kind: StatementKind::Assign(box(Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n-                }, _),\n+                    projection: box [],\n+                }, _)),\n                 ..\n             }) => local,\n             _ => return OtherUse(use_span),\n@@ -844,7 +845,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n             if let StatementKind::Assign(\n-                _, box Rvalue::Aggregate(ref kind, ref places)\n+                box(_, Rvalue::Aggregate(ref kind, ref places))\n             ) = stmt.kind {\n                 let (def_id, is_generator) = match kind {\n                     box AggregateKind::Closure(def_id, _) => (def_id, false),"}, {"sha": "1d3576244c4afc0d597389a18b5231e0a32fbf6d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 44, "deletions": 49, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -10,10 +10,10 @@ use rustc::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT};\n use rustc::middle::borrowck::SignalledError;\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{\n-    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceRef,\n-    Static, StaticKind\n+    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceElem,\n+    PlaceRef, Static, StaticKind\n };\n-use rustc::mir::{Field, Projection, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n+use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt};\n@@ -164,8 +164,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n         };\n \n     let mdpe = MoveDataParamEnv {\n-        move_data: move_data,\n-        param_env: param_env,\n+        move_data,\n+        param_env,\n     };\n \n     let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n@@ -259,7 +259,10 @@ fn do_mir_borrowck<'a, 'tcx>(\n         move_error_reported: BTreeMap::new(),\n         uninitialized_error_reported: Default::default(),\n         errors_buffer,\n-        disable_error_downgrading: false,\n+        // Only downgrade errors on Rust 2015 and refuse to do so on Rust 2018.\n+        // FIXME(Centril): In Rust 1.40.0, refuse doing so on 2015 as well and\n+        // proceed to throwing out the migration infrastructure.\n+        disable_error_downgrading: body.span.rust_2018(),\n         nonlexical_regioncx: regioncx,\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n@@ -543,7 +546,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n         self.check_activations(location, span, flow_state);\n \n         match stmt.kind {\n-            StatementKind::Assign(ref lhs, ref rhs) => {\n+            StatementKind::Assign(box(ref lhs, ref rhs)) => {\n                 self.consume_rvalue(\n                     location,\n                     (rhs, span),\n@@ -558,7 +561,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                     flow_state,\n                 );\n             }\n-            StatementKind::FakeRead(_, ref place) => {\n+            StatementKind::FakeRead(_, box ref place) => {\n                 // Read for match doesn't access any memory and is used to\n                 // assert that a place is safe and live. So we don't have to\n                 // do any checks here.\n@@ -902,7 +905,7 @@ enum InitializationRequiringAction {\n \n struct RootPlace<'d, 'tcx> {\n     place_base: &'d PlaceBase<'tcx>,\n-    place_projection: &'d Option<Box<Projection<'tcx>>>,\n+    place_projection: &'d [PlaceElem<'tcx>],\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n \n@@ -1188,7 +1191,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // before (at this point in the flow).\n         if let Place {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: box [],\n         } = place_span.0 {\n             if let Mutability::Not = self.body.local_decls[*local].mutability {\n                 // check for reassignments to immutable local variables\n@@ -1328,7 +1331,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn propagate_closure_used_mut_upvar(&mut self, operand: &Operand<'tcx>) {\n         let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n-            if place.projection.is_some() {\n+            if !place.projection.is_empty() {\n                 if let Some(field) = this.is_upvar_field_projection(place.as_ref()) {\n                     this.used_mut_upvars.push(field);\n                 }\n@@ -1343,11 +1346,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match *operand {\n             Operand::Move(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }) |\n             Operand::Copy(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }) if self.body.local_decls[local].is_user_variable.is_none() => {\n                 if self.body.local_decls[local].ty.is_mutable_ptr() {\n                     // The variable will be marked as mutable by the borrow.\n@@ -1384,7 +1387,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let stmt = &bbd.statements[loc.statement_index];\n                 debug!(\"temporary assigned in: stmt={:?}\", stmt);\n \n-                if let StatementKind::Assign(_, box Rvalue::Ref(_, _, ref source)) = stmt.kind {\n+                if let StatementKind::Assign(box(_, Rvalue::Ref(_, _, ref source))) = stmt.kind {\n                     propagate_closure_used_mut_place(self, source);\n                 } else {\n                     bug!(\"closures should only capture user variables \\\n@@ -1465,7 +1468,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n-        assert!(root_place.projection.is_none());\n+        assert!(root_place.projection.is_empty());\n         let (might_be_alive, will_be_dropped) = match root_place.base {\n             PlaceBase::Static(box Static {\n                 kind: StaticKind::Promoted(..),\n@@ -1753,13 +1756,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n-        // recur down place; dispatch to external checks when necessary\n-        let mut place_projection = &place.projection;\n \n         // None case => assigning to `x` does not require `x` be initialized.\n-        while let Some(proj) = place_projection {\n-            let Projection { ref base, ref elem } = **proj;\n-            match *elem {\n+        let mut cursor = &*place.projection;\n+        while let [proj_base @ .., elem] = cursor {\n+            cursor = proj_base;\n+\n+            match elem {\n                 ProjectionElem::Index(_/*operand*/) |\n                 ProjectionElem::ConstantIndex { .. } |\n                 // assigning to P[i] requires P to be valid.\n@@ -1775,7 +1778,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         location, InitializationRequiringAction::Use,\n                         (PlaceRef {\n                             base: &place.base,\n-                            projection: base,\n+                            projection: proj_base,\n                         }, span), flow_state);\n                     // (base initialized; no need to\n                     // recur further)\n@@ -1792,14 +1795,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // assigning to `P.f` requires `P` itself\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&place.base, base, self.body, tcx).ty;\n+                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n                     match base_ty.sty {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n                                 (PlaceRef {\n                                     base: &place.base,\n-                                    projection: base,\n+                                    projection: proj_base,\n                                 }, span), flow_state);\n \n                             // (base initialized; no need to\n@@ -1812,7 +1815,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ty::Adt(..) | ty::Tuple(..) => {\n                             check_parent_of_field(self, location, PlaceRef {\n                                 base: &place.base,\n-                                projection: base,\n+                                projection: proj_base,\n                             }, span, flow_state);\n \n                             if let PlaceBase::Local(local) = place.base {\n@@ -1832,8 +1835,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }\n                 }\n             }\n-\n-            place_projection = base;\n         }\n \n         fn check_parent_of_field<'cx, 'tcx>(\n@@ -2081,7 +2082,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match root_place {\n             RootPlace {\n                 place_base: PlaceBase::Local(local),\n-                place_projection: None,\n+                place_projection: [],\n                 is_local_mutation_allowed,\n             } => {\n                 // If the local may have been initialized, and it is now currently being\n@@ -2100,7 +2101,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } => {}\n             RootPlace {\n                 place_base,\n-                place_projection: place_projection @ Some(_),\n+                place_projection: place_projection @ [.., _],\n                 is_local_mutation_allowed: _,\n             } => {\n                 if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n@@ -2112,7 +2113,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             RootPlace {\n                 place_base: PlaceBase::Static(..),\n-                place_projection: None,\n+                place_projection: [],\n                 is_local_mutation_allowed: _,\n             } => {}\n         }\n@@ -2128,7 +2129,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 let local = &self.body.local_decls[*local];\n                 match local.mutability {\n@@ -2159,7 +2160,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     kind: StaticKind::Promoted(..),\n                     ..\n                 }),\n-                projection: None,\n+                projection: [],\n             } =>\n                 Ok(RootPlace {\n                     place_base: place.base,\n@@ -2172,7 +2173,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     def_id,\n                     ..\n                 }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 if !self.infcx.tcx.is_mutable_static(*def_id) {\n                     Err(place)\n@@ -2186,12 +2187,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             PlaceRef {\n                 base: _,\n-                projection: Some(proj),\n+                projection: [proj_base @ .., elem],\n             } => {\n-                match proj.elem {\n+                match elem {\n                     ProjectionElem::Deref => {\n                         let base_ty =\n-                            Place::ty_from(place.base, &proj.base, self.body, self.infcx.tcx).ty;\n+                            Place::ty_from(place.base, proj_base, self.body, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n@@ -2213,7 +2214,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                                         self.is_mutable(PlaceRef {\n                                             base: place.base,\n-                                            projection: &proj.base,\n+                                            projection: proj_base,\n                                         }, mode)\n                                     }\n                                 }\n@@ -2237,7 +2238,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             _ if base_ty.is_box() => {\n                                 self.is_mutable(PlaceRef {\n                                     base: place.base,\n-                                    projection: &proj.base,\n+                                    projection: proj_base,\n                                 }, is_local_mutation_allowed)\n                             }\n                             // Deref should only be for reference, pointers or boxes\n@@ -2294,7 +2295,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     // ```\n                                     let _ = self.is_mutable(PlaceRef {\n                                         base: place.base,\n-                                        projection: &proj.base,\n+                                        projection: proj_base,\n                                     }, is_local_mutation_allowed)?;\n                                     Ok(RootPlace {\n                                         place_base: place.base,\n@@ -2306,7 +2307,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         } else {\n                             self.is_mutable(PlaceRef {\n                                 base: place.base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             }, is_local_mutation_allowed)\n                         }\n                     }\n@@ -2323,21 +2324,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut place_projection = place_ref.projection;\n         let mut by_ref = false;\n \n-        if let Some(box Projection {\n-            base,\n-            elem: ProjectionElem::Deref,\n-        }) = place_projection {\n-            place_projection = &base;\n+        if let [proj_base @ .., ProjectionElem::Deref] = place_projection {\n+            place_projection = proj_base;\n             by_ref = true;\n         }\n \n         match place_projection {\n-            Some(box Projection {\n-                base,\n-                elem: ProjectionElem::Field(field, _ty),\n-            }) => {\n+            [base @ .., ProjectionElem::Field(field, _ty)] => {\n                 let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.base, &base, self.body, tcx).ty;\n+                let base_ty = Place::ty_from(place_ref.base, base, self.body, tcx).ty;\n \n                 if (base_ty.is_closure() || base_ty.is_generator()) &&\n                     (!by_ref || self.upvars[field.index()].by_ref) {"}, {"sha": "aa732b0092a223f300a5528c6420ceab3498115b", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -89,11 +89,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 // If that ever stops being the case, then the ever initialized\n                 // flow could be used.\n                 if let Some(StatementKind::Assign(\n-                    Place {\n-                        base: PlaceBase::Local(local),\n-                        projection: None,\n-                    },\n-                    box Rvalue::Use(Operand::Move(move_from)),\n+                    box(\n+                        Place {\n+                            base: PlaceBase::Local(local),\n+                            projection: box [],\n+                        },\n+                        Rvalue::Use(Operand::Move(move_from))\n+                    )\n                 )) = self.body.basic_blocks()[location.block]\n                     .statements\n                     .get(location.statement_index)\n@@ -274,16 +276,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         place: &Place<'tcx>,\n         span: Span\n     ) -> DiagnosticBuilder<'a> {\n-        let description = if place.projection.is_none() {\n+        let description = if place.projection.is_empty() {\n             format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n         } else {\n-            let mut base_static = &place.projection;\n-            while let Some(box Projection { base: Some(ref proj), .. }) = base_static {\n-                base_static = &proj.base;\n-            }\n             let base_static = PlaceRef {\n                 base: &place.base,\n-                projection: base_static,\n+                projection: &place.projection[..1],\n             };\n \n             format!(\n@@ -309,17 +307,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let upvar_field = self.prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n-        let deref_base = match deref_target_place.projection {\n-            Some(box Projection { ref base, elem: ProjectionElem::Deref }) => PlaceRef {\n-                base: &deref_target_place.base,\n-                projection: base,\n-            },\n+        let deref_base = match &deref_target_place.projection {\n+            box [proj_base @ .., ProjectionElem::Deref] => {\n+                PlaceRef {\n+                    base: &deref_target_place.base,\n+                    projection: proj_base,\n+                }\n+            }\n             _ => bug!(\"deref_target_place is not a deref projection\"),\n         };\n \n         if let PlaceRef {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: [],\n         } = deref_base {\n             let decl = &self.body.local_decls[*local];\n             if decl.is_ref_for_guard() {"}, {"sha": "14b76d97b3e57f02172ca2e6e0af5c39ff659c90", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 31, "deletions": 73, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n use rustc::mir::{\n-    Mutability, Place, PlaceRef, PlaceBase, Projection, ProjectionElem, Static, StaticKind\n+    Mutability, Place, PlaceRef, PlaceBase, ProjectionElem, Static, StaticKind\n };\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -47,12 +47,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         match the_place_err {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 if let Place {\n                     base: PlaceBase::Local(_),\n-                    projection: None,\n+                    projection: box [],\n                 } = access_place {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n@@ -65,14 +65,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base,\n-                        elem: ProjectionElem::Field(upvar_index, _),\n-                    }),\n+                projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(&the_place_err.base, &base, self.body, self.infcx.tcx).ty\n+                    Place::ty_from(&the_place_err.base, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -86,14 +82,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base,\n-                        elem: ProjectionElem::Deref,\n-                    }),\n+                projection: [proj_base @ .., ProjectionElem::Deref],\n             } => {\n                 if the_place_err.base == &PlaceBase::Local(Local::new(1)) &&\n-                    base.is_none() &&\n+                    proj_base.is_empty() &&\n                     !self.upvars.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n@@ -114,7 +106,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             \", as `Fn` closures cannot mutate their captured variables\".to_string()\n                         }\n                 } else if {\n-                    if let (PlaceBase::Local(local), None) = (&the_place_err.base, base) {\n+                    if let (PlaceBase::Local(local), []) = (&the_place_err.base, proj_base) {\n                         self.body.local_decls[*local].is_ref_for_guard()\n                     } else {\n                         false\n@@ -125,7 +117,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 } else {\n                     let source = self.borrowed_content_source(PlaceRef {\n                         base: the_place_err.base,\n-                        projection: base,\n+                        projection: proj_base,\n                     });\n                     let pointer_type = source.describe_for_immutable_place();\n                     opt_source = Some(source);\n@@ -151,7 +143,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         kind: StaticKind::Promoted(..),\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => unreachable!(),\n \n             PlaceRef {\n@@ -161,11 +153,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         def_id,\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 if let Place {\n                     base: PlaceBase::Static(_),\n-                    projection: None,\n+                    projection: box [],\n                 } = access_place {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n@@ -178,33 +170,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base: _,\n-                        elem: ProjectionElem::Index(_),\n-                    }),\n+                projection: [.., ProjectionElem::Index(_)],\n             }\n             | PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base: _,\n-                        elem: ProjectionElem::ConstantIndex { .. },\n-                    }),\n+                projection: [.., ProjectionElem::ConstantIndex { .. }],\n             }\n             | PlaceRef {\n                 base: _,\n-                projection: Some(box Projection {\n-                    base: _,\n-                    elem: ProjectionElem::Subslice { .. },\n-                }),\n+                projection: [.., ProjectionElem::Subslice { .. }],\n             }\n             | PlaceRef {\n                 base: _,\n-                projection: Some(box Projection {\n-                    base: _,\n-                    elem: ProjectionElem::Downcast(..),\n-                }),\n+                projection: [.., ProjectionElem::Downcast(..)],\n             } => bug!(\"Unexpected immutable place.\"),\n         }\n \n@@ -262,22 +240,17 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // after the field access).\n             PlaceRef {\n                 base,\n-                projection: Some(box Projection {\n-                    base: Some(box Projection {\n-                        base: Some(box Projection {\n-                            base: base_proj,\n-                            elem: ProjectionElem::Deref,\n-                        }),\n-                        elem: ProjectionElem::Field(field, _),\n-                    }),\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [proj_base @ ..,\n+                             ProjectionElem::Deref,\n+                             ProjectionElem::Field(field, _),\n+                             ProjectionElem::Deref,\n+                ],\n             } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(&base, &base_proj, self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(base, proj_base, self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -292,7 +265,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // Suggest removing a `&mut` from the use of a mutable reference.\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } if {\n                 self.body.local_decls.get(*local).map(|local_decl| {\n                     if let ClearCrossCrate::Set(\n@@ -328,7 +301,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // variable) mutations...\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } if self.body.local_decls[*local].can_be_made_mutable() => {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n@@ -349,13 +322,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // Also suggest adding mut for upvars\n             PlaceRef {\n                 base,\n-                projection: Some(box Projection {\n-                    base: proj_base,\n-                    elem: ProjectionElem::Field(upvar_index, _),\n-                }),\n+                projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(&base, &proj_base, self.body, self.infcx.tcx).ty\n+                    Place::ty_from(base, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -385,7 +355,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // a local variable, then just suggest the user remove it.\n             PlaceRef {\n                 base: PlaceBase::Local(_),\n-                projection: None,\n+                projection: [],\n             } if {\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n@@ -400,10 +370,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             } if {\n                 if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n                     self.body.local_decls[*local].is_user_variable\n@@ -427,10 +394,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // arbitrary base for the projection?\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             } if self.body.local_decls[*local].is_user_variable.is_some() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n@@ -510,10 +474,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base,\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             // FIXME document what is this 1 magic number about\n             } if *base == PlaceBase::Local(Local::new(1)) &&\n                   !self.upvars.is_empty() =>\n@@ -527,10 +488,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection: Some(box Projection {\n-                    base: _,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [.., ProjectionElem::Deref],\n             } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n "}, {"sha": "1e5f613aedc233b20a0c3a84c91f6b6e377cf767", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -8,9 +8,8 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, Projection,\n-    ProjectionElem, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind,\n-    UserTypeProjection,\n+    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, ProjectionElem, Rvalue,\n+    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n };\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty};\n@@ -229,14 +228,11 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n             match place {\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } |\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: Some(box Projection {\n-                        base: None,\n-                        elem: ProjectionElem::Deref,\n-                    }),\n+                    projection: box [ProjectionElem::Deref],\n                 } => {\n                     debug!(\n                         \"Recording `killed` facts for borrows of local={:?} at location={:?}\",\n@@ -261,7 +257,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n \n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: Some(_),\n+                    projection: box [.., _],\n                 } => {\n                     // Kill conflicting borrows of the innermost local.\n                     debug!("}, {"sha": "eae2f832ba7918c80ed68a97061100a312ff8073", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -274,7 +274,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n                         if let Place {\n                             base: PlaceBase::Local(borrowed_local),\n-                            projection: None,\n+                            projection: box [],\n                         } = place {\n                              if body.local_decls[*borrowed_local].name.is_some()\n                                 && local != *borrowed_local\n@@ -495,11 +495,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             Operand::Constant(c) => c.span,\n                             Operand::Copy(Place {\n                                 base: PlaceBase::Local(l),\n-                                projection: None,\n+                                projection: box [],\n                             }) |\n                             Operand::Move(Place {\n                                 base: PlaceBase::Local(l),\n-                                projection: None,\n+                                projection: box [],\n                             }) => {\n                                 let local_decl = &self.body.local_decls[*l];\n                                 if local_decl.name.is_none() {\n@@ -541,10 +541,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n         let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(Place {\n+            kind: StatementKind::Assign(box(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n-            }, _),\n+                projection: box [],\n+            }, _)),\n             ..\n         }) = stmt\n         {\n@@ -567,7 +567,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"was_captured_by_trait_object: stmt={:?}\", stmt);\n \n                 // The only kind of statement that we care about is assignments...\n-                if let StatementKind::Assign(place, box rvalue) = &stmt.kind {\n+                if let StatementKind::Assign(box(place, rvalue)) = &stmt.kind {\n                     let into = match place.local_or_deref_local() {\n                         Some(into) => into,\n                         None => {\n@@ -583,11 +583,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         Rvalue::Use(operand) => match operand {\n                             Operand::Copy(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                             | Operand::Move(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                                 if *from == target =>\n                             {\n@@ -602,11 +602,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ) => match operand {\n                             Operand::Copy(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                             | Operand::Move(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                                 if *from == target =>\n                             {\n@@ -639,7 +639,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if let TerminatorKind::Call {\n                     destination: Some((Place {\n                         base: PlaceBase::Local(dest),\n-                        projection: None,\n+                        projection: box [],\n                     }, block)),\n                     args,\n                     ..\n@@ -653,7 +653,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let found_target = args.iter().any(|arg| {\n                         if let Operand::Move(Place {\n                             base: PlaceBase::Local(potential),\n-                            projection: None,\n+                            projection: box [],\n                         }) = arg {\n                             *potential == target\n                         } else {"}, {"sha": "1d429e3a6dee6c721daa18e3e2b26d6700ccbda8", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -66,7 +66,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.check_activations(location);\n \n         match statement.kind {\n-            StatementKind::Assign(ref lhs, ref rhs) => {\n+            StatementKind::Assign(box(ref lhs, ref rhs)) => {\n                 self.consume_rvalue(\n                     location,\n                     rhs,"}, {"sha": "26a89b4e7a8d1ec412b1e0efbb7342ee4cb30452", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 128, "deletions": 115, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -13,7 +13,7 @@ use rustc::infer::NLLRegionVariableOrigin;\n use rustc::mir::{ConstraintCategory, Location, Body};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder};\n+use rustc_errors::DiagnosticBuilder;\n use std::collections::VecDeque;\n use syntax::errors::Applicability;\n use syntax::symbol::kw;\n@@ -22,7 +22,7 @@ use syntax_pos::Span;\n mod region_name;\n mod var_name;\n \n-crate use self::region_name::{RegionName, RegionNameSource};\n+crate use self::region_name::{RegionName, RegionNameSource, RegionErrorNamingCtx};\n \n impl ConstraintDescription for ConstraintCategory {\n     fn description(&self) -> &'static str {\n@@ -54,6 +54,39 @@ enum Trace {\n     NotVisited,\n }\n \n+/// Various pieces of state used when reporting borrow checker errors.\n+pub struct ErrorReportingCtx<'a, 'b, 'tcx> {\n+    /// The region inference context used for borrow chekcing this MIR body.\n+    #[allow(dead_code)] // FIXME(mark-i-m): used by outlives suggestions\n+    region_infcx: &'b RegionInferenceContext<'tcx>,\n+\n+    /// The inference context used for type checking.\n+    infcx: &'b InferCtxt<'a, 'tcx>,\n+\n+    /// The MIR def we are reporting errors on.\n+    mir_def_id: DefId,\n+\n+    /// The MIR body we are reporting errors on (for convenience).\n+    body: &'b Body<'tcx>,\n+\n+    /// Any upvars for the MIR body we have kept track of during borrow checking.\n+    upvars: &'b [Upvar],\n+}\n+\n+/// Information about the various region constraints involved in a borrow checker error.\n+#[derive(Clone, Debug)]\n+pub struct ErrorConstraintInfo {\n+    // fr: outlived_fr\n+    fr: RegionVid,\n+    fr_is_local: bool,\n+    outlived_fr: RegionVid,\n+    outlived_fr_is_local: bool,\n+\n+    // Category and span for best blame constraint\n+    category: ConstraintCategory,\n+    span: Span,\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Tries to find the best constraint to blame for the fact that\n     /// `R: from_region`, where `R` is some region that meets\n@@ -257,16 +290,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     ///\n     /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n-    pub(super) fn report_error(\n-        &self,\n+    pub(super) fn report_error<'a>(\n+        &'a self,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'a> {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n         let (category, _, span) = self.best_blame_constraint(body, fr, |r| {\n@@ -279,8 +312,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n             let nice = NiceRegionError::new_from_span(infcx, span, o, f, Some(tables));\n             if let Some(diag) = nice.try_report_from_nll() {\n-                diag.buffer(errors_buffer);\n-                return;\n+                return diag;\n             }\n         }\n \n@@ -293,45 +325,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             \"report_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n             fr_is_local, outlived_fr_is_local, category\n         );\n+\n+        let errctx = ErrorReportingCtx {\n+            region_infcx: self,\n+            infcx,\n+            mir_def_id,\n+            body,\n+            upvars,\n+        };\n+\n+        let errci = ErrorConstraintInfo {\n+            fr, outlived_fr, fr_is_local, outlived_fr_is_local, category, span\n+        };\n+\n         match (category, fr_is_local, outlived_fr_is_local) {\n             (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) => {\n-                self.report_fnmut_error(\n-                    body,\n-                    upvars,\n-                    infcx,\n-                    mir_def_id,\n-                    fr,\n-                    outlived_fr,\n-                    span,\n-                    errors_buffer,\n-                )\n+                self.report_fnmut_error(&errctx, &errci, renctx)\n             }\n             (ConstraintCategory::Assignment, true, false)\n-            | (ConstraintCategory::CallArgument, true, false) => self.report_escaping_data_error(\n-                body,\n-                upvars,\n-                infcx,\n-                mir_def_id,\n-                fr,\n-                outlived_fr,\n-                category,\n-                span,\n-                errors_buffer,\n-            ),\n-            _ => self.report_general_error(\n-                body,\n-                upvars,\n-                infcx,\n-                mir_def_id,\n-                fr,\n-                fr_is_local,\n-                outlived_fr,\n-                outlived_fr_is_local,\n-                category,\n-                span,\n-                errors_buffer,\n-            ),\n-        };\n+            | (ConstraintCategory::CallArgument, true, false) =>\n+                self.report_escaping_data_error(&errctx, &errci, renctx),\n+            _ => self.report_general_error(&errctx, &errci, renctx),\n+        }\n     }\n \n     /// We have a constraint `fr1: fr2` that is not satisfied, where\n@@ -379,19 +394,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n-        _fr: RegionVid,\n-        outlived_fr: RegionVid,\n-        span: Span,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n-        let mut diag = infcx\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        errci: &ErrorConstraintInfo,\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'_> {\n+        let ErrorConstraintInfo {\n+            outlived_fr, span, ..\n+        } = errci;\n+\n+        let mut diag = errctx\n+            .infcx\n             .tcx\n             .sess\n-            .struct_span_err(span, \"captured variable cannot escape `FnMut` closure body\");\n+            .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n \n         // We should check if the return type of this closure is in fact a closure - in that\n         // case, we can special case the error further.\n@@ -403,11 +418,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             \"returns a reference to a captured variable which escapes the closure body\"\n         };\n \n-        diag.span_label(span, message);\n+        diag.span_label(*span, message);\n \n-        match self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_fr, &mut 1)\n-            .unwrap().source\n-        {\n+        match self.give_region_a_name(errctx, renctx, *outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -427,7 +440,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n         diag.note(\"...therefore, they cannot allow references to captured variables to escape\");\n \n-        diag.buffer(errors_buffer);\n+        diag\n     }\n \n     /// Reports a error specifically for when data is escaping a closure.\n@@ -444,20 +457,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_escaping_data_error(\n         &self,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n-        fr: RegionVid,\n-        outlived_fr: RegionVid,\n-        category: ConstraintCategory,\n-        span: Span,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        errci: &ErrorConstraintInfo,\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'_> {\n+        let ErrorReportingCtx {\n+            infcx, body, upvars, ..\n+        } = errctx;\n+\n+        let ErrorConstraintInfo {\n+            span, category, ..\n+        } = errci;\n+\n         let fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, errci.fr);\n         let outlived_fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, outlived_fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, errci.outlived_fr);\n \n         let escapes_from = match self.universal_regions.defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n@@ -469,27 +484,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Revert to the normal error in these cases.\n         // Assignments aren't \"escapes\" in function items.\n         if (fr_name_and_span.is_none() && outlived_fr_name_and_span.is_none())\n-            || (category == ConstraintCategory::Assignment && escapes_from == \"function\")\n+            || (*category == ConstraintCategory::Assignment && escapes_from == \"function\")\n             || escapes_from == \"const\"\n         {\n             return self.report_general_error(\n-                body,\n-                upvars,\n-                infcx,\n-                mir_def_id,\n-                fr,\n-                true,\n-                outlived_fr,\n-                false,\n-                category,\n-                span,\n-                errors_buffer,\n+                errctx,\n+                &ErrorConstraintInfo {\n+                    fr_is_local: true,\n+                    outlived_fr_is_local: false,\n+                    .. *errci\n+                },\n+                renctx,\n             );\n         }\n \n         let mut diag = borrowck_errors::borrowed_data_escapes_closure(\n             infcx.tcx,\n-            span,\n+            *span,\n             escapes_from,\n         );\n \n@@ -513,12 +524,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             );\n \n             diag.span_label(\n-                span,\n+                *span,\n                 format!(\"`{}` escapes the {} body here\", fr_name, escapes_from),\n             );\n         }\n \n-        diag.buffer(errors_buffer);\n+        diag\n     }\n \n     /// Reports a region inference error for the general case with named/synthesized lifetimes to\n@@ -538,41 +549,37 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n-        fr: RegionVid,\n-        fr_is_local: bool,\n-        outlived_fr: RegionVid,\n-        outlived_fr_is_local: bool,\n-        category: ConstraintCategory,\n-        span: Span,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        errci: &ErrorConstraintInfo,\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'_> {\n+        let ErrorReportingCtx {\n+            infcx, mir_def_id, ..\n+        } = errctx;\n+        let ErrorConstraintInfo {\n+            fr, fr_is_local, outlived_fr, outlived_fr_is_local, span, category, ..\n+        } = errci;\n+\n         let mut diag = infcx.tcx.sess.struct_span_err(\n-            span,\n+            *span,\n             \"lifetime may not live long enough\"\n         );\n \n-        let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(\n-            infcx, body, upvars, mir_def_id, fr, counter).unwrap();\n-        fr_name.highlight_region_name(&mut diag);\n-        let outlived_fr_name =\n-            self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_fr, counter).unwrap();\n-        outlived_fr_name.highlight_region_name(&mut diag);\n-\n-        let mir_def_name = if infcx.tcx.is_closure(mir_def_id) {\n+        let mir_def_name = if infcx.tcx.is_closure(*mir_def_id) {\n             \"closure\"\n         } else {\n             \"function\"\n         };\n \n+        let fr_name = self.give_region_a_name(errctx, renctx, *fr).unwrap();\n+        fr_name.highlight_region_name(&mut diag);\n+        let outlived_fr_name = self.give_region_a_name(errctx, renctx, *outlived_fr).unwrap();\n+        outlived_fr_name.highlight_region_name(&mut diag);\n+\n         match (category, outlived_fr_is_local, fr_is_local) {\n             (ConstraintCategory::Return, true, _) => {\n                 diag.span_label(\n-                    span,\n+                    *span,\n                     format!(\n                         \"{} was supposed to return data with lifetime `{}` but it is returning \\\n                          data with lifetime `{}`\",\n@@ -582,7 +589,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n             _ => {\n                 diag.span_label(\n-                    span,\n+                    *span,\n                     format!(\n                         \"{}requires that `{}` must outlive `{}`\",\n                         category.description(),\n@@ -593,9 +600,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        self.add_static_impl_trait_suggestion(infcx, &mut diag, fr, fr_name, outlived_fr);\n+        self.add_static_impl_trait_suggestion(infcx, &mut diag, *fr, fr_name, *outlived_fr);\n \n-        diag.buffer(errors_buffer);\n+        diag\n     }\n \n     /// Adds a suggestion to errors where a `impl Trait` is returned.\n@@ -704,8 +711,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             borrow_region,\n             |r| self.provides_universal_region(r, borrow_region, outlived_region)\n         );\n-        let outlived_fr_name =\n-            self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_region, &mut 1);\n+\n+        let mut renctx = RegionErrorNamingCtx::new();\n+        let errctx = ErrorReportingCtx {\n+            infcx, body, upvars, mir_def_id,\n+            region_infcx: self,\n+        };\n+        let outlived_fr_name = self.give_region_a_name(&errctx, &mut renctx, outlived_region);\n+\n         (category, from_closure, span, outlived_fr_name)\n     }\n "}, {"sha": "6fa94269107f583388ea5f71819150d454983f5f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 127, "deletions": 71, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,5 +1,9 @@\n use std::fmt::{self, Display};\n-use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n+\n+use crate::borrow_check::nll::region_infer::{\n+    RegionInferenceContext,\n+    error_reporting::ErrorReportingCtx,\n+};\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ToRegionVid;\n use crate::borrow_check::Upvar;\n@@ -13,29 +17,75 @@ use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n use syntax::symbol::kw;\n-use syntax_pos::Span;\n-use syntax_pos::symbol::InternedString;\n+use rustc_data_structures::fx::FxHashMap;\n+use syntax_pos::{Span, symbol::InternedString};\n \n-#[derive(Debug)]\n+/// A name for a particular region used in emitting diagnostics. This name could be a generated\n+/// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n+#[derive(Debug, Clone)]\n crate struct RegionName {\n+    /// The name of the region (interned).\n     crate name: InternedString,\n+    /// Where the region comes from.\n     crate source: RegionNameSource,\n }\n \n-#[derive(Debug)]\n+/// Denotes the source of a region that is named by a `RegionName`. For example, a free region that\n+/// was named by the user would get `NamedFreeRegion` and `'static` lifetime would get `Static`.\n+/// This helps to print the right kinds of diagnostics.\n+#[derive(Debug, Clone)]\n crate enum RegionNameSource {\n+    /// A bound (not free) region that was substituted at the def site (not an HRTB).\n     NamedEarlyBoundRegion(Span),\n+    /// A free region that the user has a name (`'a`) for.\n     NamedFreeRegion(Span),\n+    /// The `'static` region.\n     Static,\n+    /// The free region corresponding to the environment of a closure.\n     SynthesizedFreeEnvRegion(Span, String),\n+    /// The region name corresponds to a region where the type annotation is completely missing\n+    /// from the code, e.g. in a closure arguments `|x| { ... }`, where `x` is a reference.\n     CannotMatchHirTy(Span, String),\n+    /// The region name corresponds a reference that was found by traversing the type in the HIR.\n     MatchedHirTy(Span),\n+    /// A region name from the generics list of a struct/enum/union.\n     MatchedAdtAndSegment(Span),\n+    /// The region corresponding to a closure upvar.\n     AnonRegionFromUpvar(Span, String),\n+    /// The region corresponding to the return type of a closure.\n     AnonRegionFromOutput(Span, String, String),\n     AnonRegionFromYieldTy(Span, String),\n }\n \n+/// Records region names that have been assigned before so that we can use the same ones in later\n+/// diagnostics.\n+#[derive(Debug, Clone)]\n+crate struct RegionErrorNamingCtx {\n+    /// Record the region names generated for each region in the given\n+    /// MIR def so that we can reuse them later in help/error messages.\n+    renctx: FxHashMap<RegionVid, RegionName>,\n+\n+    /// The counter for generating new region names.\n+    counter: usize,\n+}\n+\n+impl RegionErrorNamingCtx {\n+    crate fn new() -> Self {\n+        Self {\n+            counter: 1,\n+            renctx: FxHashMap::default(),\n+        }\n+    }\n+\n+    crate fn get(&self, region: &RegionVid) -> Option<&RegionName> {\n+        self.renctx.get(region)\n+    }\n+\n+    crate fn insert(&mut self, region: RegionVid, name: RegionName) {\n+        self.renctx.insert(region, name);\n+    }\n+}\n+\n impl RegionName {\n     #[allow(dead_code)]\n     crate fn was_named(&self) -> bool {\n@@ -63,43 +113,40 @@ impl RegionName {\n         self.name\n     }\n \n-    crate fn highlight_region_name(\n-        &self,\n-        diag: &mut DiagnosticBuilder<'_>\n-    ) {\n+    crate fn highlight_region_name(&self, diag: &mut DiagnosticBuilder<'_>) {\n         match &self.source {\n-            RegionNameSource::NamedFreeRegion(span) |\n-            RegionNameSource::NamedEarlyBoundRegion(span) => {\n-                diag.span_label(\n-                    *span,\n-                    format!(\"lifetime `{}` defined here\", self),\n-                );\n-            },\n+            RegionNameSource::NamedFreeRegion(span)\n+            | RegionNameSource::NamedEarlyBoundRegion(span) => {\n+                diag.span_label(*span, format!(\"lifetime `{}` defined here\", self));\n+            }\n             RegionNameSource::SynthesizedFreeEnvRegion(span, note) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"lifetime `{}` represents this closure's body\", self),\n                 );\n                 diag.note(&note);\n-            },\n+            }\n             RegionNameSource::CannotMatchHirTy(span, type_name) => {\n                 diag.span_label(*span, format!(\"has type `{}`\", type_name));\n-            },\n+            }\n             RegionNameSource::MatchedHirTy(span) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"let's call the lifetime of this reference `{}`\", self),\n                 );\n-            },\n+            }\n             RegionNameSource::MatchedAdtAndSegment(span) => {\n                 diag.span_label(*span, format!(\"let's call this `{}`\", self));\n-            },\n+            }\n             RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n                 diag.span_label(\n                     *span,\n-                    format!(\"lifetime `{}` appears in the type of `{}`\", self, upvar_name),\n+                    format!(\n+                        \"lifetime `{}` appears in the type of `{}`\",\n+                        self, upvar_name\n+                    ),\n                 );\n-            },\n+            }\n             RegionNameSource::AnonRegionFromOutput(span, mir_description, type_name) => {\n                 diag.span_label(\n                     *span,\n@@ -151,39 +198,49 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// and then return the name `'1` for us to use.\n     crate fn give_region_a_name(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        mir_def_id: DefId,\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        renctx: &mut RegionErrorNamingCtx,\n         fr: RegionVid,\n-        counter: &mut usize,\n     ) -> Option<RegionName> {\n-        debug!(\"give_region_a_name(fr={:?}, counter={})\", fr, counter);\n+        let ErrorReportingCtx {\n+            infcx, body, mir_def_id, upvars, ..\n+        } = errctx;\n+\n+        debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n \n         assert!(self.universal_regions.is_universal_region(fr));\n \n-        let value = self.give_name_from_error_region(infcx.tcx, mir_def_id, fr, counter)\n+        if let Some(value) = renctx.get(&fr) {\n+            return Some(value.clone());\n+        }\n+\n+        let value = self\n+            .give_name_from_error_region(infcx.tcx, *mir_def_id, fr, renctx)\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_arguments(\n-                    infcx, body, mir_def_id, fr, counter,\n+                    infcx, body, *mir_def_id, fr, renctx,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_upvars(\n-                    infcx.tcx, upvars, fr, counter,\n+                    infcx.tcx, upvars, fr, renctx\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_output(\n-                    infcx, body, mir_def_id, fr, counter,\n+                    infcx, body, *mir_def_id, fr, renctx,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_yield_ty(\n-                    infcx, body, mir_def_id, fr, counter,\n+                    infcx, body, *mir_def_id, fr, renctx,\n                 )\n             });\n \n+        if let Some(ref value) = value {\n+            renctx.insert(fr, value.clone());\n+        }\n+\n         debug!(\"give_region_a_name: gave name {:?}\", value);\n         value\n     }\n@@ -197,7 +254,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n@@ -208,7 +265,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     let span = self.get_named_span(tcx, error_region, ebr.name);\n                     Some(RegionName {\n                         name: ebr.name,\n-                        source: RegionNameSource::NamedEarlyBoundRegion(span)\n+                        source: RegionNameSource::NamedEarlyBoundRegion(span),\n                     })\n                 } else {\n                     None\n@@ -227,12 +284,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         name,\n                         source: RegionNameSource::NamedFreeRegion(span),\n                     })\n-                },\n+                }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = tcx.hir()\n-                                        .as_local_hir_id(mir_def_id)\n-                                        .expect(\"non-local mir\");\n+                    let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n                     let def_ty = self.universal_regions.defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n@@ -243,7 +298,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         } else {\n                             bug!(\"Closure is not defined by a closure expr\");\n                         };\n-                        let region_name = self.synthesize_region_name(counter);\n+                        let region_name = self.synthesize_region_name(renctx);\n \n                         let closure_kind_ty = substs.closure_kind_ty(def_id, tcx);\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n@@ -265,7 +320,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             name: region_name,\n                             source: RegionNameSource::SynthesizedFreeEnvRegion(\n                                 args_span,\n-                                note.to_string()\n+                                note.to_string(),\n                             ),\n                         })\n                     } else {\n@@ -335,7 +390,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n         let argument_index = self.get_argument_index_for_region(infcx.tcx, fr)?;\n@@ -349,12 +404,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             fr,\n             arg_ty,\n             argument_index,\n-            counter,\n+            renctx,\n         ) {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(infcx, body, fr, arg_ty, counter)\n+        self.give_name_if_we_cannot_match_hir_ty(infcx, body, fr, arg_ty, renctx)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n@@ -365,7 +420,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n@@ -379,15 +434,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 body,\n                 needle_fr,\n                 argument_ty,\n-                counter,\n+                renctx,\n             ),\n \n             _ => self.give_name_if_we_can_match_hir_ty(\n                 infcx.tcx,\n                 needle_fr,\n                 argument_ty,\n                 argument_hir_ty,\n-                counter,\n+                renctx,\n             ),\n         }\n     }\n@@ -409,10 +464,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n+        let counter = renctx.counter;\n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(needle_fr, *counter);\n+        highlight.highlighting_region_vid(needle_fr, counter);\n         let type_name = infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n \n         debug!(\n@@ -428,7 +484,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // This counter value will already have been used, so this function will increment\n                 // it so the next value will be used next and return the region name that would\n                 // have been used.\n-                name: self.synthesize_region_name(counter),\n+                name: self.synthesize_region_name(renctx),\n                 source: RegionNameSource::CannotMatchHirTy(span, type_name),\n             })\n         } else {\n@@ -455,7 +511,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// type. Once we find that, we can use the span of the `hir::Ty`\n     /// to add the highlight.\n     ///\n-    /// This is a somewhat imperfect process, so long the way we also\n+    /// This is a somewhat imperfect process, so along the way we also\n     /// keep track of the **closest** type we've found. If we fail to\n     /// find the exact `&` or `'_` to highlight, then we may fall back\n     /// to highlighting that closest type instead.\n@@ -465,7 +521,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> =\n             &mut vec![(argument_ty, argument_hir_ty)];\n@@ -483,7 +539,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n-                        let region_name = self.synthesize_region_name(counter);\n+                        let region_name = self.synthesize_region_name(renctx);\n \n                         // Just grab the first character, the `&`.\n                         let source_map = tcx.sess.source_map();\n@@ -515,7 +571,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                                 substs,\n                                 needle_fr,\n                                 last_segment,\n-                                counter,\n+                                renctx,\n                                 search_stack,\n                             ) {\n                                 return Some(name);\n@@ -559,18 +615,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         substs: SubstsRef<'tcx>,\n         needle_fr: RegionVid,\n         last_segment: &'hir hir::PathSegment,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n     ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n         let args = last_segment.args.as_ref()?;\n-        let lifetime = self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n+        let lifetime =\n+            self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n         match lifetime.name {\n             hir::LifetimeName::Param(_)\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static\n             | hir::LifetimeName::Underscore => {\n-                let region_name = self.synthesize_region_name(counter);\n+                let region_name = self.synthesize_region_name(renctx);\n                 let ampersand_span = lifetime.span;\n                 Some(RegionName {\n                     name: region_name,\n@@ -657,12 +714,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n         let (upvar_name, upvar_span) =\n             self.get_upvar_name_and_span_for_region(tcx, upvars, upvar_index);\n-        let region_name = self.synthesize_region_name(counter);\n+        let region_name = self.synthesize_region_name(renctx);\n \n         Some(RegionName {\n             name: region_name,\n@@ -680,7 +737,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let tcx = infcx.tcx;\n \n@@ -694,7 +751,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, *counter);\n+        highlight.highlighting_region_vid(fr, renctx.counter);\n         let type_name = infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n@@ -725,11 +782,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // This counter value will already have been used, so this function will increment it\n             // so the next value will be used next and return the region name that would have been\n             // used.\n-            name: self.synthesize_region_name(counter),\n+            name: self.synthesize_region_name(renctx),\n             source: RegionNameSource::AnonRegionFromOutput(\n                 return_span,\n                 mir_description.to_string(),\n-                type_name\n+                type_name,\n             ),\n         })\n     }\n@@ -740,7 +797,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n@@ -757,7 +814,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, *counter);\n+        highlight.highlighting_region_vid(fr, renctx.counter);\n         let type_name = infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n@@ -780,16 +837,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         Some(RegionName {\n-            name: self.synthesize_region_name(counter),\n+            name: self.synthesize_region_name(renctx),\n             source: RegionNameSource::AnonRegionFromYieldTy(yield_span, type_name),\n         })\n     }\n \n-    /// Creates a synthetic region named `'1`, incrementing the\n-    /// counter.\n-    fn synthesize_region_name(&self, counter: &mut usize) -> InternedString {\n-        let c = *counter;\n-        *counter += 1;\n+    /// Creates a synthetic region named `'1`, incrementing the counter.\n+    fn synthesize_region_name(&self, renctx: &mut RegionErrorNamingCtx) -> InternedString {\n+        let c = renctx.counter;\n+        renctx.counter += 1;\n \n         InternedString::intern(&format!(\"'{:?}\", c))\n     }"}, {"sha": "78e7943598d68ad7eb8761fe5f3bd935b04ef2c1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -1,15 +1,20 @@\n-use super::universal_regions::UniversalRegions;\n-use crate::borrow_check::nll::constraints::graph::NormalConstraintGraph;\n-use crate::borrow_check::nll::constraints::{\n-    ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n-};\n-use crate::borrow_check::nll::member_constraints::{MemberConstraintSet, NllMemberConstraintIndex};\n-use crate::borrow_check::nll::region_infer::values::{\n-    PlaceholderIndices, RegionElement, ToElementIndex,\n+use std::rc::Rc;\n+\n+use crate::borrow_check::nll::{\n+    constraints::{\n+        graph::NormalConstraintGraph,\n+        ConstraintSccIndex,\n+        OutlivesConstraint,\n+        OutlivesConstraintSet,\n+    },\n+    member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n+    region_infer::values::{\n+        PlaceholderIndices, RegionElement, ToElementIndex\n+    },\n+    type_check::{free_region_relations::UniversalRegionRelations, Locations},\n };\n-use crate::borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n-use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::Upvar;\n+\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryOutlivesConstraint;\n use rustc::infer::opaque_types;\n@@ -31,16 +36,16 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use syntax_pos::Span;\n \n-use std::rc::Rc;\n+crate use self::error_reporting::{RegionName, RegionNameSource, RegionErrorNamingCtx};\n+use self::values::{LivenessValues, RegionValueElements, RegionValues};\n+use super::universal_regions::UniversalRegions;\n+use super::ToRegionVid;\n \n mod dump_mir;\n mod error_reporting;\n-crate use self::error_reporting::{RegionName, RegionNameSource};\n mod graphviz;\n-pub mod values;\n-use self::values::{LivenessValues, RegionValueElements, RegionValues};\n \n-use super::ToRegionVid;\n+pub mod values;\n \n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable. Region\n@@ -487,13 +492,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             errors_buffer,\n         );\n \n+        // If we produce any errors, we keep track of the names of all regions, so that we can use\n+        // the same error names in any suggestions we produce. Note that we need names to be unique\n+        // across different errors for the same MIR def so that we can make suggestions that fix\n+        // multiple problems.\n+        let mut region_naming = RegionErrorNamingCtx::new();\n+\n         self.check_universal_regions(\n             infcx,\n             body,\n             upvars,\n             mir_def_id,\n             outlives_requirements.as_mut(),\n             errors_buffer,\n+            &mut region_naming,\n         );\n \n         self.check_member_constraints(infcx, mir_def_id, errors_buffer);\n@@ -1312,6 +1324,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n     ) {\n         for (fr, fr_definition) in self.definitions.iter_enumerated() {\n             match fr_definition.origin {\n@@ -1327,6 +1340,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         fr,\n                         &mut propagated_outlives_requirements,\n                         errors_buffer,\n+                        region_naming,\n                     );\n                 }\n \n@@ -1358,6 +1372,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n     ) {\n         debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n@@ -1385,6 +1400,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n+                region_naming,\n             );\n             return;\n         }\n@@ -1401,8 +1417,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n+                region_naming,\n             ) {\n                 // continuing to iterate just reports more errors than necessary\n+                //\n+                // FIXME It would also allow us to report more Outlives Suggestions, though, so\n+                // it's not clear that that's a bad thing. Somebody should try commenting out this\n+                // line and see it is actually a regression.\n                 return;\n             }\n         }\n@@ -1418,6 +1439,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n     ) -> Option<ErrorReported> {\n         // If it is known that `fr: o`, carry on.\n         if self.universal_region_relations.outlives(longer_fr, shorter_fr) {\n@@ -1466,7 +1488,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         //\n         // Note: in this case, we use the unapproximated regions to report the\n         // error. This gives better error messages in some cases.\n-        self.report_error(body, upvars, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+        let db = self.report_error(\n+            body,\n+            upvars,\n+            infcx,\n+            mir_def_id,\n+            longer_fr,\n+            shorter_fr,\n+            region_naming,\n+        );\n+\n+        db.buffer(errors_buffer);\n+\n         Some(ErrorReported)\n     }\n "}, {"sha": "6a764b19c4ddf7dfdb07f10a8446ad0d971323e7", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 99, "deletions": 103, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -421,107 +421,104 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n \n-        place.iterate(|place_base, place_projection| {\n-            let mut place_ty = match place_base {\n-                PlaceBase::Local(index) =>\n-                    PlaceTy::from_ty(self.body.local_decls[*index].ty),\n-                PlaceBase::Static(box Static { kind, ty: sty, def_id }) => {\n-                    let sty = self.sanitize_type(place, sty);\n-                    let check_err =\n-                        |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n-                         place: &Place<'tcx>,\n-                         ty,\n-                         sty| {\n-                            if let Err(terr) = verifier.cx.eq_types(\n-                                sty,\n-                                ty,\n-                                location.to_locations(),\n-                                ConstraintCategory::Boring,\n-                            ) {\n-                                span_mirbug!(\n-                                verifier,\n-                                place,\n-                                \"bad promoted type ({:?}: {:?}): {:?}\",\n-                                ty,\n-                                sty,\n-                                terr\n-                            );\n-                            };\n+        let mut place_ty = match &place.base {\n+            PlaceBase::Local(index) =>\n+                PlaceTy::from_ty(self.body.local_decls[*index].ty),\n+            PlaceBase::Static(box Static { kind, ty: sty, def_id }) => {\n+                let sty = self.sanitize_type(place, sty);\n+                let check_err =\n+                    |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n+                     place: &Place<'tcx>,\n+                     ty,\n+                     sty| {\n+                        if let Err(terr) = verifier.cx.eq_types(\n+                            sty,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Boring,\n+                        ) {\n+                            span_mirbug!(\n+                            verifier,\n+                            place,\n+                            \"bad promoted type ({:?}: {:?}): {:?}\",\n+                            ty,\n+                            sty,\n+                            terr\n+                        );\n                         };\n-                    match kind {\n-                        StaticKind::Promoted(promoted, _) => {\n-                            if !self.errors_reported {\n-                                let promoted_body = &self.promoted[*promoted];\n-                                self.sanitize_promoted(promoted_body, location);\n-\n-                                let promoted_ty = promoted_body.return_ty();\n-                                check_err(self, place, promoted_ty, sty);\n-                            }\n+                    };\n+                match kind {\n+                    StaticKind::Promoted(promoted, _) => {\n+                        if !self.errors_reported {\n+                            let promoted_body = &self.promoted[*promoted];\n+                            self.sanitize_promoted(promoted_body, location);\n+\n+                            let promoted_ty = promoted_body.return_ty();\n+                            check_err(self, place, promoted_ty, sty);\n                         }\n-                        StaticKind::Static => {\n-                            let ty = self.tcx().type_of(*def_id);\n-                            let ty = self.cx.normalize(ty, location);\n+                    }\n+                    StaticKind::Static => {\n+                        let ty = self.tcx().type_of(*def_id);\n+                        let ty = self.cx.normalize(ty, location);\n \n-                            check_err(self, place, ty, sty);\n-                        }\n+                        check_err(self, place, ty, sty);\n                     }\n-                    PlaceTy::from_ty(sty)\n                 }\n-            };\n+                PlaceTy::from_ty(sty)\n+            }\n+        };\n \n-            // FIXME use place_projection.is_empty() when is available\n-            if place.projection.is_none() {\n-                if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-                    let is_promoted = match place {\n-                        Place {\n-                            base: PlaceBase::Static(box Static {\n-                                kind: StaticKind::Promoted(..),\n-                                ..\n-                            }),\n-                            projection: None,\n-                        } => true,\n-                        _ => false,\n-                    };\n+        if place.projection.is_empty() {\n+            if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n+                let is_promoted = match place {\n+                    Place {\n+                        base: PlaceBase::Static(box Static {\n+                            kind: StaticKind::Promoted(..),\n+                            ..\n+                        }),\n+                        projection: box [],\n+                    } => true,\n+                    _ => false,\n+                };\n \n-                    if !is_promoted {\n-                        let tcx = self.tcx();\n-                        let trait_ref = ty::TraitRef {\n-                            def_id: tcx.lang_items().copy_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n-                        };\n+                if !is_promoted {\n+                    let tcx = self.tcx();\n+                    let trait_ref = ty::TraitRef {\n+                        def_id: tcx.lang_items().copy_trait().unwrap(),\n+                        substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+                    };\n \n-                        // In order to have a Copy operand, the type T of the\n-                        // value must be Copy. Note that we prove that T: Copy,\n-                        // rather than using the `is_copy_modulo_regions`\n-                        // test. This is important because\n-                        // `is_copy_modulo_regions` ignores the resulting region\n-                        // obligations and assumes they pass. This can result in\n-                        // bounds from Copy impls being unsoundly ignored (e.g.,\n-                        // #29149). Note that we decide to use Copy before knowing\n-                        // whether the bounds fully apply: in effect, the rule is\n-                        // that if a value of some type could implement Copy, then\n-                        // it must.\n-                        self.cx.prove_trait_ref(\n-                            trait_ref,\n-                            location.to_locations(),\n-                            ConstraintCategory::CopyBound,\n-                        );\n-                    }\n+                    // To have a `Copy` operand, the type `T` of the\n+                    // value must be `Copy`. Note that we prove that `T: Copy`,\n+                    // rather than using the `is_copy_modulo_regions`\n+                    // test. This is important because\n+                    // `is_copy_modulo_regions` ignores the resulting region\n+                    // obligations and assumes they pass. This can result in\n+                    // bounds from `Copy` impls being unsoundly ignored (e.g.,\n+                    // #29149). Note that we decide to use `Copy` before knowing\n+                    // whether the bounds fully apply: in effect, the rule is\n+                    // that if a value of some type could implement `Copy`, then\n+                    // it must.\n+                    self.cx.prove_trait_ref(\n+                        trait_ref,\n+                        location.to_locations(),\n+                        ConstraintCategory::CopyBound,\n+                    );\n                 }\n             }\n+        }\n \n-            for proj in place_projection {\n-                if place_ty.variant_index.is_none() {\n-                    if place_ty.ty.references_error() {\n-                        assert!(self.errors_reported);\n-                        return PlaceTy::from_ty(self.tcx().types.err);\n-                    }\n+        for elem in place.projection.iter() {\n+            if place_ty.variant_index.is_none() {\n+                if place_ty.ty.references_error() {\n+                    assert!(self.errors_reported);\n+                    return PlaceTy::from_ty(self.tcx().types.err);\n                 }\n-                place_ty = self.sanitize_projection(place_ty, &proj.elem, place, location)\n             }\n+            place_ty = self.sanitize_projection(place_ty, elem, place, location)\n+        }\n \n-            place_ty\n-        })\n+        place_ty\n     }\n \n     fn sanitize_promoted(&mut self, promoted_body: &'b Body<'tcx>, location: Location) {\n@@ -1346,15 +1343,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n-            StatementKind::Assign(ref place, ref rv) => {\n+            StatementKind::Assign(box(ref place, ref rv)) => {\n                 // Assignments to temporaries are not \"interesting\";\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n                 let category = match *place {\n                     Place {\n                         base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: None,\n+                        projection: box [],\n                     } => if let BorrowCheckContext {\n                         universal_regions:\n                             UniversalRegions {\n@@ -1373,7 +1370,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     },\n                     Place {\n                         base: PlaceBase::Local(l),\n-                        projection: None,\n+                        projection: box [],\n                     } if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n@@ -1453,7 +1450,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::AscribeUserType(ref place, variance, box ref projection) => {\n+            StatementKind::AscribeUserType(box(ref place, ref projection), variance) => {\n                 let place_ty = place.ty(body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n@@ -1660,7 +1657,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 let category = match *dest {\n                     Place {\n                         base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: None,\n+                        projection: box [],\n                     } => {\n                         if let BorrowCheckContext {\n                             universal_regions:\n@@ -1682,7 +1679,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                     Place {\n                         base: PlaceBase::Local(l),\n-                        projection: None,\n+                        projection: box [],\n                     } if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n@@ -2002,6 +1999,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ),\n                             &traits::SelectionError::Unimplemented,\n                             false,\n+                            false,\n                         );\n                     }\n                 }\n@@ -2416,19 +2414,21 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // *p`, where the `p` has type `&'b mut Foo`, for example, we\n         // need to ensure that `'b: 'a`.\n \n-        let mut borrowed_projection = &borrowed_place.projection;\n-\n         debug!(\n             \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n             location, borrow_region, borrowed_place\n         );\n-        while let Some(box proj) = borrowed_projection {\n-            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_projection);\n \n-            match proj.elem {\n+        let mut cursor = &*borrowed_place.projection;\n+        while let [proj_base @ .., elem] = cursor {\n+            cursor = proj_base;\n+\n+            debug!(\"add_reborrow_constraint - iteration {:?}\", elem);\n+\n+            match elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&borrowed_place.base, &proj.base, body, tcx).ty;\n+                    let base_ty = Place::ty_from(&borrowed_place.base, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n@@ -2490,10 +2490,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // other field access\n                 }\n             }\n-\n-            // The \"propagate\" case. We need to check that our base is valid\n-            // for the borrow's lifetime.\n-            borrowed_projection = &proj.base;\n         }\n     }\n "}, {"sha": "411fa5b59676530dd004a67d12474d1f79c884d7", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -25,55 +25,54 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        self.iterate(|place_base, place_projection| {\n-            let ignore = match place_base {\n-                // If a local variable is immutable, then we only need to track borrows to guard\n-                // against two kinds of errors:\n-                // * The variable being dropped while still borrowed (e.g., because the fn returns\n-                //   a reference to a local variable)\n-                // * The variable being moved while still borrowed\n-                //\n-                // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n-                // so we don't have to worry about mutation while borrowed.\n-                PlaceBase::Local(index) => {\n-                    match locals_state_at_exit {\n-                        LocalsStateAtExit::AllAreInvalidated => false,\n-                        LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                            let ignore = !has_storage_dead_or_moved.contains(*index) &&\n-                                body.local_decls[*index].mutability == Mutability::Not;\n-                            debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n-                            ignore\n-                        }\n+        let ignore = match self.base {\n+            // If a local variable is immutable, then we only need to track borrows to guard\n+            // against two kinds of errors:\n+            // * The variable being dropped while still borrowed (e.g., because the fn returns\n+            //   a reference to a local variable)\n+            // * The variable being moved while still borrowed\n+            //\n+            // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n+            // so we don't have to worry about mutation while borrowed.\n+            PlaceBase::Local(index) => {\n+                match locals_state_at_exit {\n+                    LocalsStateAtExit::AllAreInvalidated => false,\n+                    LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n+                        let ignore = !has_storage_dead_or_moved.contains(index) &&\n+                            body.local_decls[index].mutability == Mutability::Not;\n+                        debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n+                        ignore\n                     }\n                 }\n-                PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) =>\n-                    false,\n-                PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n-                    tcx.is_mutable_static(*def_id)\n-                }\n-            };\n+            }\n+            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) =>\n+                false,\n+            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n+                tcx.is_mutable_static(def_id)\n+            }\n+        };\n \n-            for proj in place_projection {\n-                if proj.elem == ProjectionElem::Deref {\n-                    let ty = Place::ty_from(place_base, &proj.base, body, tcx).ty;\n-                    match ty.sty {\n-                        // For both derefs of raw pointers and `&T`\n-                        // references, the original path is `Copy` and\n-                        // therefore not significant.  In particular,\n-                        // there is nothing the user can do to the\n-                        // original path that would invalidate the\n-                        // newly created reference -- and if there\n-                        // were, then the user could have copied the\n-                        // original path into a new variable and\n-                        // borrowed *that* one, leaving the original\n-                        // path unborrowed.\n-                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => return true,\n-                        _ => {}\n-                    }\n+        for (i, elem) in self.projection.iter().enumerate() {\n+            let proj_base = &self.projection[..i];\n+\n+            if *elem == ProjectionElem::Deref {\n+                let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n+                if let ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) = ty.sty {\n+                    // For both derefs of raw pointers and `&T`\n+                    // references, the original path is `Copy` and\n+                    // therefore not significant.  In particular,\n+                    // there is nothing the user can do to the\n+                    // original path that would invalidate the\n+                    // newly created reference -- and if there\n+                    // were, then the user could have copied the\n+                    // original path into a new variable and\n+                    // borrowed *that* one, leaving the original\n+                    // path unborrowed.\n+                    return true;\n                 }\n             }\n+        }\n \n-            ignore\n-        })\n+        ignore\n     }\n }"}, {"sha": "dafa0b6631fe2cc44fff700a819f50ec361900dd", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 162, "deletions": 156, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -3,8 +3,7 @@ use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n use rustc::mir::{\n-    Body, BorrowKind, Place, PlaceBase, PlaceRef, Projection, ProjectionElem, ProjectionsIter,\n-    StaticKind,\n+    Body, BorrowKind, Place, PlaceBase, PlaceElem, PlaceRef, ProjectionElem, StaticKind,\n };\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n@@ -67,39 +66,35 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n     // it's so common that it's a speed win to check for it first.\n     if let Place {\n         base: PlaceBase::Local(l1),\n-        projection: None,\n+        projection: box [],\n     } = borrow_place {\n         if let PlaceRef {\n             base: PlaceBase::Local(l2),\n-            projection: None,\n+            projection: [],\n         } = access_place {\n             return l1 == l2;\n         }\n     }\n \n-    borrow_place.iterate(|borrow_base, borrow_projections| {\n-        access_place.iterate(|access_base, access_projections| {\n-            place_components_conflict(\n-                tcx,\n-                param_env,\n-                body,\n-                (borrow_base, borrow_projections),\n-                borrow_kind,\n-                (access_base, access_projections),\n-                access,\n-                bias,\n-            )\n-        })\n-    })\n+    place_components_conflict(\n+        tcx,\n+        param_env,\n+        body,\n+        borrow_place,\n+        borrow_kind,\n+        access_place,\n+        access,\n+        bias,\n+    )\n }\n \n fn place_components_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n-    borrow_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n+    borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n-    access_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n+    access_place: PlaceRef<'_, 'tcx>,\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {\n@@ -145,8 +140,8 @@ fn place_components_conflict<'tcx>(\n     //    and either equal or disjoint.\n     //  - If we did run out of access, the borrow can access a part of it.\n \n-    let borrow_base = borrow_projections.0;\n-    let access_base = access_projections.0;\n+    let borrow_base = &borrow_place.base;\n+    let access_base = access_place.base;\n \n     match place_base_conflict(tcx, param_env, borrow_base, access_base) {\n         Overlap::Arbitrary => {\n@@ -163,147 +158,157 @@ fn place_components_conflict<'tcx>(\n         }\n     }\n \n-    let mut borrow_projections = borrow_projections.1;\n-    let mut access_projections = access_projections.1;\n-\n-    loop {\n-        // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-        if let Some(borrow_c) = borrow_projections.next() {\n-            debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n+    // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+    for (i, (borrow_c, access_c)) in\n+        borrow_place.projection.iter().zip(access_place.projection.iter()).enumerate()\n+    {\n+        debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n+        let borrow_proj_base = &borrow_place.projection[..i];\n \n-            if let Some(access_c) = access_projections.next() {\n-                debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n+        debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n \n-                // Borrow and access path both have more components.\n-                //\n-                // Examples:\n-                //\n-                // - borrow of `a.(...)`, access to `a.(...)`\n-                // - borrow of `a.(...)`, access to `b.(...)`\n-                //\n-                // Here we only see the components we have checked so\n-                // far (in our examples, just the first component). We\n-                // check whether the components being borrowed vs\n-                // accessed are disjoint (as in the second example,\n-                // but not the first).\n-                match place_projection_conflict(tcx, body, borrow_base, borrow_c, access_c, bias) {\n-                    Overlap::Arbitrary => {\n-                        // We have encountered different fields of potentially\n-                        // the same union - the borrow now partially overlaps.\n-                        //\n-                        // There is no *easy* way of comparing the fields\n-                        // further on, because they might have different types\n-                        // (e.g., borrows of `u.a.0` and `u.b.y` where `.0` and\n-                        // `.y` come from different structs).\n-                        //\n-                        // We could try to do some things here - e.g., count\n-                        // dereferences - but that's probably not a good\n-                        // idea, at least for now, so just give up and\n-                        // report a conflict. This is unsafe code anyway so\n-                        // the user could always use raw pointers.\n-                        debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n-                        return true;\n-                    }\n-                    Overlap::EqualOrDisjoint => {\n-                        // This is the recursive case - proceed to the next element.\n-                    }\n-                    Overlap::Disjoint => {\n-                        // We have proven the borrow disjoint - further\n-                        // projections will remain disjoint.\n-                        debug!(\"borrow_conflicts_with_place: disjoint\");\n-                        return false;\n-                    }\n-                }\n-            } else {\n-                // Borrow path is longer than the access path. Examples:\n+        // Borrow and access path both have more components.\n+        //\n+        // Examples:\n+        //\n+        // - borrow of `a.(...)`, access to `a.(...)`\n+        // - borrow of `a.(...)`, access to `b.(...)`\n+        //\n+        // Here we only see the components we have checked so\n+        // far (in our examples, just the first component). We\n+        // check whether the components being borrowed vs\n+        // accessed are disjoint (as in the second example,\n+        // but not the first).\n+        match place_projection_conflict(\n+            tcx,\n+            body,\n+            borrow_base,\n+            borrow_proj_base,\n+            borrow_c,\n+            access_c,\n+            bias,\n+        ) {\n+            Overlap::Arbitrary => {\n+                // We have encountered different fields of potentially\n+                // the same union - the borrow now partially overlaps.\n                 //\n-                // - borrow of `a.b.c`, access to `a.b`\n+                // There is no *easy* way of comparing the fields\n+                // further on, because they might have different types\n+                // (e.g., borrows of `u.a.0` and `u.b.y` where `.0` and\n+                // `.y` come from different structs).\n                 //\n-                // Here, we know that the borrow can access a part of\n-                // our place. This is a conflict if that is a part our\n-                // access cares about.\n+                // We could try to do some things here - e.g., count\n+                // dereferences - but that's probably not a good\n+                // idea, at least for now, so just give up and\n+                // report a conflict. This is unsafe code anyway so\n+                // the user could always use raw pointers.\n+                debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                return true;\n+            }\n+            Overlap::EqualOrDisjoint => {\n+                // This is the recursive case - proceed to the next element.\n+            }\n+            Overlap::Disjoint => {\n+                // We have proven the borrow disjoint - further\n+                // projections will remain disjoint.\n+                debug!(\"borrow_conflicts_with_place: disjoint\");\n+                return false;\n+            }\n+        }\n+    }\n+\n+    if borrow_place.projection.len() > access_place.projection.len() {\n+        for (i, elem) in borrow_place.projection[access_place.projection.len()..].iter().enumerate()\n+        {\n+            // Borrow path is longer than the access path. Examples:\n+            //\n+            // - borrow of `a.b.c`, access to `a.b`\n+            //\n+            // Here, we know that the borrow can access a part of\n+            // our place. This is a conflict if that is a part our\n+            // access cares about.\n \n-                let base = &borrow_c.base;\n-                let elem = &borrow_c.elem;\n-                let base_ty = Place::ty_from(borrow_base, base, body, tcx).ty;\n+            let proj_base = &borrow_place.projection[..access_place.projection.len() + i];\n+            let base_ty = Place::ty_from(borrow_base, proj_base, body, tcx).ty;\n \n-                match (elem, &base_ty.sty, access) {\n-                    (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n-                    | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n-                        // The array length is like  additional fields on the\n-                        // type; it does not overlap any existing data there.\n-                        // Furthermore, if cannot actually be a prefix of any\n-                        // borrowed place (at least in MIR as it is currently.)\n-                        //\n-                        // e.g., a (mutable) borrow of `a[5]` while we read the\n-                        // array length of `a`.\n-                        debug!(\"borrow_conflicts_with_place: implicit field\");\n-                        return false;\n-                    }\n+            match (elem, &base_ty.sty, access) {\n+                (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n+                | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n+                    // The array length is like  additional fields on the\n+                    // type; it does not overlap any existing data there.\n+                    // Furthermore, if cannot actually be a prefix of any\n+                    // borrowed place (at least in MIR as it is currently.)\n+                    //\n+                    // e.g., a (mutable) borrow of `a[5]` while we read the\n+                    // array length of `a`.\n+                    debug!(\"borrow_conflicts_with_place: implicit field\");\n+                    return false;\n+                }\n \n-                    (ProjectionElem::Deref, _, Shallow(None)) => {\n-                        // e.g., a borrow of `*x.y` while we shallowly access `x.y` or some\n-                        // prefix thereof - the shallow access can't touch anything behind\n-                        // the pointer.\n-                        debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n-                        return false;\n-                    }\n-                    (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n-                        // Shouldn't be tracked\n-                        bug!(\"Tracking borrow behind shared reference.\");\n-                    }\n-                    (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n-                        // Values behind a mutable reference are not access either by dropping a\n-                        // value, or by StorageDead\n-                        debug!(\"borrow_conflicts_with_place: drop access behind ptr\");\n-                        return false;\n-                    }\n+                (ProjectionElem::Deref, _, Shallow(None)) => {\n+                    // e.g., a borrow of `*x.y` while we shallowly access `x.y` or some\n+                    // prefix thereof - the shallow access can't touch anything behind\n+                    // the pointer.\n+                    debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n+                    return false;\n+                }\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n+                    // Shouldn't be tracked\n+                    bug!(\"Tracking borrow behind shared reference.\");\n+                }\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n+                    // Values behind a mutable reference are not access either by dropping a\n+                    // value, or by StorageDead\n+                    debug!(\"borrow_conflicts_with_place: drop access behind ptr\");\n+                    return false;\n+                }\n \n-                    (ProjectionElem::Field { .. }, ty::Adt(def, _), AccessDepth::Drop) => {\n-                        // Drop can read/write arbitrary projections, so places\n-                        // conflict regardless of further projections.\n-                        if def.has_dtor(tcx) {\n-                            return true;\n-                        }\n+                (ProjectionElem::Field { .. }, ty::Adt(def, _), AccessDepth::Drop) => {\n+                    // Drop can read/write arbitrary projections, so places\n+                    // conflict regardless of further projections.\n+                    if def.has_dtor(tcx) {\n+                        return true;\n                     }\n+                }\n \n-                    (ProjectionElem::Deref, _, Deep)\n-                    | (ProjectionElem::Deref, _, AccessDepth::Drop)\n-                    | (ProjectionElem::Field { .. }, _, _)\n-                    | (ProjectionElem::Index { .. }, _, _)\n-                    | (ProjectionElem::ConstantIndex { .. }, _, _)\n-                    | (ProjectionElem::Subslice { .. }, _, _)\n-                    | (ProjectionElem::Downcast { .. }, _, _) => {\n-                        // Recursive case. This can still be disjoint on a\n-                        // further iteration if this a shallow access and\n-                        // there's a deref later on, e.g., a borrow\n-                        // of `*x.y` while accessing `x`.\n-                    }\n+                (ProjectionElem::Deref, _, Deep)\n+                | (ProjectionElem::Deref, _, AccessDepth::Drop)\n+                | (ProjectionElem::Field { .. }, _, _)\n+                | (ProjectionElem::Index { .. }, _, _)\n+                | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                | (ProjectionElem::Subslice { .. }, _, _)\n+                | (ProjectionElem::Downcast { .. }, _, _) => {\n+                    // Recursive case. This can still be disjoint on a\n+                    // further iteration if this a shallow access and\n+                    // there's a deref later on, e.g., a borrow\n+                    // of `*x.y` while accessing `x`.\n                 }\n             }\n-        } else {\n-            // Borrow path ran out but access path may not\n-            // have. Examples:\n-            //\n-            // - borrow of `a.b`, access to `a.b.c`\n-            // - borrow of `a.b`, access to `a.b`\n-            //\n-            // In the first example, where we didn't run out of\n-            // access, the borrow can access all of our place, so we\n-            // have a conflict.\n-            //\n-            // If the second example, where we did, then we still know\n-            // that the borrow can access a *part* of our place that\n-            // our access cares about, so we still have a conflict.\n-            if borrow_kind == BorrowKind::Shallow && access_projections.next().is_some() {\n-                debug!(\"borrow_conflicts_with_place: shallow borrow\");\n-                return false;\n-            } else {\n-                debug!(\"borrow_conflicts_with_place: full borrow, CONFLICT\");\n-                return true;\n-            }\n         }\n     }\n+\n+    // Borrow path ran out but access path may not\n+    // have. Examples:\n+    //\n+    // - borrow of `a.b`, access to `a.b.c`\n+    // - borrow of `a.b`, access to `a.b`\n+    //\n+    // In the first example, where we didn't run out of\n+    // access, the borrow can access all of our place, so we\n+    // have a conflict.\n+    //\n+    // If the second example, where we did, then we still know\n+    // that the borrow can access a *part* of our place that\n+    // our access cares about, so we still have a conflict.\n+    if borrow_kind == BorrowKind::Shallow\n+        && borrow_place.projection.len() < access_place.projection.len()\n+    {\n+        debug!(\"borrow_conflicts_with_place: shallow borrow\");\n+        false\n+    } else {\n+        debug!(\"borrow_conflicts_with_place: full borrow, CONFLICT\");\n+        true\n+    }\n }\n \n // Given that the bases of `elem1` and `elem2` are always either equal\n@@ -381,11 +386,12 @@ fn place_projection_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     pi1_base: &PlaceBase<'tcx>,\n-    pi1: &Projection<'tcx>,\n-    pi2: &Projection<'tcx>,\n+    pi1_proj_base: &[PlaceElem<'tcx>],\n+    pi1_elem: &PlaceElem<'tcx>,\n+    pi2_elem: &PlaceElem<'tcx>,\n     bias: PlaceConflictBias,\n ) -> Overlap {\n-    match (&pi1.elem, &pi2.elem) {\n+    match (pi1_elem, pi2_elem) {\n         (ProjectionElem::Deref, ProjectionElem::Deref) => {\n             // derefs (e.g., `*x` vs. `*x`) - recur.\n             debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n@@ -397,7 +403,7 @@ fn place_projection_conflict<'tcx>(\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                let ty = Place::ty_from(pi1_base, &pi1.base, body, tcx).ty;\n+                let ty = Place::ty_from(pi1_base, pi1_proj_base, body, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.is_union() => {\n                         // Different fields of a union, we are basically stuck.\n@@ -493,7 +499,7 @@ fn place_projection_conflict<'tcx>(\n             // element (like -1 in Python) and `min_length` the first.\n             // Therefore, `min_length - offset_from_end` gives the minimal possible\n             // offset from the beginning\n-            if *offset_from_begin >= min_length - offset_from_end {\n+            if *offset_from_begin >= *min_length - *offset_from_end {\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-FE\");\n                 Overlap::EqualOrDisjoint\n             } else {\n@@ -538,8 +544,8 @@ fn place_projection_conflict<'tcx>(\n         | (ProjectionElem::Subslice { .. }, _)\n         | (ProjectionElem::Downcast(..), _) => bug!(\n             \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n-            pi1,\n-            pi2\n+            pi1_elem,\n+            pi2_elem\n         ),\n     }\n }"}, {"sha": "0a268ec1340233ed425159ec283ffab59a9e955c", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 97, "deletions": 104, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e", "patch": "@@ -19,17 +19,9 @@ pub trait IsPrefixOf<'cx, 'tcx> {\n \n impl<'cx, 'tcx> IsPrefixOf<'cx, 'tcx> for PlaceRef<'cx, 'tcx> {\n     fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool {\n-        let mut cursor = other.projection;\n-        loop {\n-            if self.projection == cursor {\n-                return self.base == other.base;\n-            }\n-\n-            match cursor {\n-                None => return false,\n-                Some(proj) => cursor = &proj.base,\n-            }\n-        }\n+        self.base == other.base\n+            && self.projection.len() <= other.projection.len()\n+            && self.projection == &other.projection[..self.projection.len()]\n     }\n }\n \n@@ -81,112 +73,113 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n         // downcasts here, but may return a base of a downcast).\n \n         'cursor: loop {\n-            let proj = match &cursor {\n+            match &cursor {\n                 PlaceRef {\n                     base: PlaceBase::Local(_),\n-                    projection: None,\n+                    projection: [],\n                 }\n                 | // search yielded this leaf\n                 PlaceRef {\n                     base: PlaceBase::Static(_),\n-                    projection: None,\n+                    projection: [],\n                 } => {\n                     self.next = None;\n                     return Some(cursor);\n                 }\n                 PlaceRef {\n                     base: _,\n-                    projection: Some(proj),\n-                } => proj,\n-            };\n-\n-            match proj.elem {\n-                ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n-                    // FIXME: add union handling\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n-                }\n-                ProjectionElem::Downcast(..) |\n-                ProjectionElem::Subslice { .. } |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Index(_) => {\n-                    cursor = PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    };\n-                    continue 'cursor;\n-                }\n-                ProjectionElem::Deref => {\n-                    // (handled below)\n-                }\n-            }\n-\n-            assert_eq!(proj.elem, ProjectionElem::Deref);\n-\n-            match self.kind {\n-                PrefixSet::Shallow => {\n-                    // shallow prefixes are found by stripping away\n-                    // fields, but stop at *any* dereference.\n-                    // So we can just stop the traversal now.\n-                    self.next = None;\n-                    return Some(cursor);\n-                }\n-                PrefixSet::All => {\n-                    // all prefixes: just blindly enqueue the base\n-                    // of the projection.\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n-                }\n-                PrefixSet::Supporting => {\n-                    // fall through!\n-                }\n-            }\n-\n-            assert_eq!(self.kind, PrefixSet::Supporting);\n-            // supporting prefixes: strip away fields and\n-            // derefs, except we stop at the deref of a shared\n-            // reference.\n-\n-            let ty = Place::ty_from(cursor.base, &proj.base, self.body, self.tcx).ty;\n-            match ty.sty {\n-                ty::RawPtr(_) |\n-                ty::Ref(\n-                    _, /*rgn*/\n-                    _, /*ty*/\n-                    hir::MutImmutable\n-                    ) => {\n-                    // don't continue traversing over derefs of raw pointers or shared borrows.\n-                    self.next = None;\n-                    return Some(cursor);\n-                }\n-\n-                ty::Ref(\n-                    _, /*rgn*/\n-                    _, /*ty*/\n-                    hir::MutMutable,\n-                    ) => {\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n-                }\n-\n-                ty::Adt(..) if ty.is_box() => {\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n+                    projection: [proj_base @ .., elem],\n+                } => {\n+                    match elem {\n+                        ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n+                            // FIXME: add union handling\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+                        ProjectionElem::Downcast(..) |\n+                        ProjectionElem::Subslice { .. } |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        ProjectionElem::Index(_) => {\n+                            cursor = PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            };\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Deref => {\n+                            // (handled below)\n+                        }\n+                    }\n+\n+                    assert_eq!(*elem, ProjectionElem::Deref);\n+\n+                    match self.kind {\n+                        PrefixSet::Shallow => {\n+                            // Shallow prefixes are found by stripping away\n+                            // fields, but stop at *any* dereference.\n+                            // So we can just stop the traversal now.\n+                            self.next = None;\n+                            return Some(cursor);\n+                        }\n+                        PrefixSet::All => {\n+                            // All prefixes: just blindly enqueue the base\n+                            // of the projection.\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+                        PrefixSet::Supporting => {\n+                            // Fall through!\n+                        }\n+                    }\n+\n+                    assert_eq!(self.kind, PrefixSet::Supporting);\n+                    // Supporting prefixes: strip away fields and\n+                    // derefs, except we stop at the deref of a shared\n+                    // reference.\n+\n+                    let ty = Place::ty_from(cursor.base, proj_base, self.body, self.tcx).ty;\n+                    match ty.sty {\n+                        ty::RawPtr(_) |\n+                        ty::Ref(\n+                            _, /*rgn*/\n+                            _, /*ty*/\n+                            hir::MutImmutable\n+                            ) => {\n+                            // don't continue traversing over derefs of raw pointers or shared\n+                            // borrows.\n+                            self.next = None;\n+                            return Some(cursor);\n+                        }\n+\n+                        ty::Ref(\n+                            _, /*rgn*/\n+                            _, /*ty*/\n+                            hir::MutMutable,\n+                            ) => {\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+\n+                        ty::Adt(..) if ty.is_box() => {\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+\n+                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n+                    }\n                 }\n-\n-                _ => panic!(\"unknown type fed to Projection Deref.\"),\n             }\n         }\n     }"}, {"sha": "695080dfe23d90e2e41b0d7ef870b576d3e17930", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "3ed6b4ff346784c66e27a4fc17a664ece3acae91", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "09b33c6654a9db084a0bc431d1ed99bc81e54ec8", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "7dfe98cbebfc27f0e09d07d55de1138eaf344c8d", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "45f4a1685360624983dceb733a847435e4f11481", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "2b0237c7c08b98f98407d5cd7a8f2c2c27baa1f8", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "647d7515fe98df36baad06b6f4386c05100fcbe4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "ee6d42de388d9bd0ecbdf122fd1dfd33d45c8d06", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "435159827e6c30d419b0e3ecc008ccf8adedfb82", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "444cc008ae785432f1ed2165e45c8e7f2dec896b", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "886044c0692829e2c283e2e3cb10586c16ef1ef0", "filename": "src/librustc_mir/dataflow/generic.rs", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "a86fcb30f4d36ca97bbf7c94fec381eaf69e9834", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "0f66b13fdc51af33d7404e3113583334aec274d9", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "5ab4e25b683cb2f077fd7a7b5f65bc145d52fb26", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 12, "deletions": 35, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "698c50166270a2bea6b3b5d684df8ded2d746a1b", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 67, "deletions": 68, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "156c19c6363e58a74ffd4077f7af571112617979", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "ba299e9463b8d90af04308adba8b5953ca654ce1", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 19, "deletions": 83, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "a6d955f3369100e7b1a007202a5fc0dcb9923c97", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "161c58a17557966d31c8c7eb5f810e9c4877e299", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 119, "deletions": 193, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "4aaa5e8ee259af8da1fd94e4eba4f73e313093fe", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "78996ed6939d8148a19624b7cc4ec4dc6b7e8ebb", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "95647ce642c5b6a5f9ec218da548805849ab1bc5", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 145, "deletions": 116, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "ec09e69ec853741e1b24964925e91334263434e6", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "1e765a4ed982c7c56c19d1df26803088da0352cb", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "0c61be283dfd0d8469db45343145e7e5f7332a6a", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "dd214c4a031f7f9b2ff52f13e65e51669d0dc8b8", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 62, "deletions": 42, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "c3660fb7a2e28ffe07758838cbd994fb904ece10", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 53, "deletions": 43, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "affca10bf5265e01db586b9e71eb60e50185841f", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "8310ef02f96692798446d5222fe862da2f257f8d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "9a03719ab61f5013bfdc053a701046d557d07f2d", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "6daca5e261431f7d4149c79b1945badd4e355f53", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "833c8b1646bb68d2ec31ad55f5db9a8809c927e2", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "39aa5c717acc13696687b12dddb5b0a4bd396c9e", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 114, "deletions": 113, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "ea173279aa07321604650d5ae7fb19ec33b93895", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "614d5d2a4a2fbd5174564b233523934b1274ef63", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "28f97f41b50cf7027d4d0181f3e6e71fcedab517", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "c1224be6324e20bd58379e882864c0e89420d1e2", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "a9c66b3c8c6d18dac2a90fa39358599414668692", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "caf588af851dd3a4fed82162e5e2a090484d3256", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 39, "deletions": 47, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "5ad026dc143c9574c4dbce509b8371555877eacf", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "0e04e63af4522ae1daeed981d59d345cf2e9b341", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "7d1b96b8be170dc89d11cde8d5194285a88cf723", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "7cc1e634cf812da820c6aa6428d4e134eef85e83", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 242, "deletions": 253, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "80e020a9eb7e65b8442040178ddb657c975c554e", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "70b11944e2fbcc463288cf09b745cd47a5121fc1", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "68fa082d2940786ab737eca0b02c30fcb1b73a17", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "34ad5cb5dc787d8762262a0b327a54e3a7fb476d", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 102, "deletions": 87, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "b3565d40b8e217e9bdab4f4f2a737adfb3654481", "filename": "src/librustc_mir/util/aggregate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Faggregate.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "a75c1af04f0475b51874cf422494237451d0e939", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "cf9ef55c17b3464422f7c83988e278605361178c", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "52ad97bbde1d7ce6a471d9ccc33d8dcaf22f06d1", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "2ea9924af7f28d427ccb150392262f8ce2032056", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "c35c9e4da9f4846be217a9cabc0ed3205f56d0c9", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "a81786ee36d04e946f486a1d02504d72d1a4ab6d", "filename": "src/librustc_msan/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_msan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_msan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2Fbuild.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "af07c790e2a8799a35e82878719ab7d1af97d0f4", "filename": "src/librustc_passes/error_codes.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "a5a8315a1e73f9f4d024e0385d644304de10aff0", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "7b3f01c0ee11144b6cea496836470e049e398462", "filename": "src/librustc_plugin/error_codes.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_plugin%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_plugin%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Ferror_codes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "4e1a47c503e59fd3675e8f576714dbbf74b8a3e2", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "67066466f1d222d0d0af63a786a193a46f45f137", "filename": "src/librustc_privacy/error_codes.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_privacy%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_privacy%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Ferror_codes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "1e61f78c357dfa5d3260c4c5cbf7f31cb750608c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "11dcf5b4b00194f48614fcf54005da42efd2ce8e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 97, "deletions": 50, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "c479912b4ef814949d839341736555384865445f", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "adbff67cc8dac2942728becb3c9039b9533023a2", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "aae283b74523650aebf14d07eed96a9040273bd2", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 456, "deletions": 380, "changes": 836, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "0c86d8494fde833afcf0f92760d8b8821a14c219", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "74f68e514712623af4f8eda8d66831f1b706c873", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 51, "deletions": 26, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "3900a3dbb387235ece44e06090aeeb3384b838cc", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "e77e8290f1faa9f911cdaf0ecb96f43da07818a3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 70, "deletions": 40, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "55f6b91e7143106e336086ffb4ef0142f6969222", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 77, "deletions": 139, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "055ccf6c2c4f83c3270fbb4d71dbf3f00f33f481", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "f7551aa768dfc6ac457844525df7defac6267a38", "filename": "src/librustc_target/spec/apple_base.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_base.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "fdbb1bd5db34b6c1a4a9dbf181afee886b8cd8bb", "filename": "src/librustc_target/spec/apple_ios_base.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "27d05823bf21e15bf50fde7239d164a05633f0bd", "filename": "src/librustc_target/spec/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_apple_darwin.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "c60f7b422d18f4a7d272f14f0fb80df6ba0860a7", "filename": "src/librustc_target/spec/i686_unknown_uefi.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fi686_unknown_uefi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fi686_unknown_uefi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_unknown_uefi.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "626fa374a1bd467a765cbd670dc779d93d878c34", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "86978c05b15d0dbef4f3fd9fdd87518a7320c0ad", "filename": "src/librustc_target/spec/wasm32_wasi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "d059e44c5c82ac82656bcc7399c452dadfb6ee72", "filename": "src/librustc_target/spec/x86_64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_darwin.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "f9333e15023277832c69de2aa524f2357734a39a", "filename": "src/librustc_tsan/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_tsan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_tsan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2Fbuild.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "09e6b76900396de821f7010af30c52db6186a7dc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}, {"sha": "50fd72f06131904e927b65f83dfe0801b39ba703", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b16496e6c39e9928c5f7091d005d184889884e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=66b16496e6c39e9928c5f7091d005d184889884e"}]}