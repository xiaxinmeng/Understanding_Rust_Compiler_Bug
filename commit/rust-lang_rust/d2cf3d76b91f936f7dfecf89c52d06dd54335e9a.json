{"sha": "d2cf3d76b91f936f7dfecf89c52d06dd54335e9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyY2YzZDc2YjkxZjkzNmY3ZGZlY2Y4OWM1MmQwNmRkNTQzMzVlOWE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-10T22:46:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-10T23:15:58Z"}, "message": "update for allocator API", "tree": {"sha": "ab23f1850fd83743e4df4b99ba680957931c1a0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab23f1850fd83743e4df4b99ba680957931c1a0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2cf3d76b91f936f7dfecf89c52d06dd54335e9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2cf3d76b91f936f7dfecf89c52d06dd54335e9a", "html_url": "https://github.com/rust-lang/rust/commit/d2cf3d76b91f936f7dfecf89c52d06dd54335e9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2cf3d76b91f936f7dfecf89c52d06dd54335e9a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e60f11f52cea83322721a24985ffb1f95c041555", "url": "https://api.github.com/repos/rust-lang/rust/commits/e60f11f52cea83322721a24985ffb1f95c041555", "html_url": "https://github.com/rust-lang/rust/commit/e60f11f52cea83322721a24985ffb1f95c041555"}], "stats": {"total": 172, "additions": 95, "deletions": 77}, "files": [{"sha": "ba9b13f07c978af696407af9bcf0ef7294314318", "filename": "src/memory.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2cf3d76b91f936f7dfecf89c52d06dd54335e9a/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cf3d76b91f936f7dfecf89c52d06dd54335e9a/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=d2cf3d76b91f936f7dfecf89c52d06dd54335e9a", "patch": "@@ -223,10 +223,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: Pointer, old_size: u64, new_size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n+    pub fn reallocate(&mut self, ptr: Pointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64) -> EvalResult<'tcx, Pointer> {\n         use std::cmp::min;\n \n-        assert!(align.is_power_of_two());\n         // TODO(solson): Report error about non-__rust_allocate'd pointer.\n         if ptr.offset != 0 || self.get(ptr.alloc_id).is_err() {\n             return Err(EvalError::ReallocateNonBasePtr);\n@@ -236,9 +235,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n-        let new_ptr = self.allocate(new_size, align)?;\n-        self.copy(PrimVal::Ptr(ptr), PrimVal::Ptr(new_ptr), min(old_size, new_size), align, /*nonoverlapping*/true)?;\n-        self.deallocate(ptr, Some((old_size, align)))?;\n+        let new_ptr = self.allocate(new_size, new_align)?;\n+        self.copy(PrimVal::Ptr(ptr), PrimVal::Ptr(new_ptr), min(old_size, new_size), min(old_align, new_align), /*nonoverlapping*/true)?;\n+        self.deallocate(ptr, Some((old_size, old_align)))?;\n \n         Ok(new_ptr)\n     }"}, {"sha": "38fd4654741732242ee5cd9f7eb5ce4ca15a5108", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 91, "deletions": 72, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/d2cf3d76b91f936f7dfecf89c52d06dd54335e9a/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2cf3d76b91f936f7dfecf89c52d06dd54335e9a/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=d2cf3d76b91f936f7dfecf89c52d06dd54335e9a", "patch": "@@ -520,37 +520,111 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         sig: ty::FnSig<'tcx>,\n         path: String,\n     ) -> EvalResult<'tcx> {\n+        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n+        match &path[..] {\n+            \"std::panicking::rust_panic_with_hook\" |\n+            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n+            _ => {},\n+        }\n+\n+        let dest_ty = sig.output();\n+        let (dest, dest_block) = destination.ok_or_else(|| EvalError::NoMirFor(path.clone()))?;\n+\n         if sig.abi == Abi::C {\n             // An external C function\n-            let ty = sig.output();\n-            let (ret, target) = destination.unwrap();\n-            self.call_c_abi(instance.def_id(), arg_operands, ret, ty, target)?;\n+            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n+            // unify these two mechanisms for \"hooking into missing functions\".\n+            self.call_c_abi(instance.def_id(), arg_operands, dest, dest_ty, dest_block)?;\n             return Ok(());\n         }\n+\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        let usize = self.tcx.types.usize;\n     \n-        // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n-        // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n         match &path[..] {\n+            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n+            \"alloc::heap::::__rust_alloc\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_alloc_zeroed\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align)?;\n+                self.memory.write_repeat(PrimVal::Ptr(ptr), 0, size)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_dealloc\" => {\n+                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if old_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                self.memory.deallocate(ptr, Some((old_size, align)))?;\n+            }\n+            \"alloc::heap::::__rust_realloc\" => {\n+                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n+                let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n+                if old_size == 0 || new_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !old_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(old_align));\n+                }\n+                if !new_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n+                }\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align)?;\n+                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+            }\n+\n+            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n+            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n             \"std::io::_print\" => {\n                 trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n-                self.goto_block(destination.unwrap().1);\n-                Ok(())\n-            },\n-            \"std::thread::Builder::new\" => Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n-            \"std::env::args\" => Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n-            \"std::panicking::rust_panic_with_hook\" |\n-            \"std::rt::begin_panic_fmt\" => Err(EvalError::Panic),\n+            }\n+            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n+            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n             \"std::panicking::panicking\" |\n             \"std::rt::panicking\" => {\n-                let (lval, block) = destination.expect(\"std::rt::panicking does not diverge\");\n                 // we abort on panic -> `std::rt::panicking` always returns false\n                 let bool = self.tcx.types.bool;\n-                self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n-                self.goto_block(block);\n-                Ok(())\n+                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n             }\n-            _ => Err(EvalError::NoMirFor(path)),\n+            _ => return Err(EvalError::NoMirFor(path)),\n         }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n+        return Ok(());\n     }\n \n     fn call_c_abi(\n@@ -609,61 +683,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 return Err(EvalError::Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n             }\n \n-            \"__rust_allocate\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-\n-            \"__rust_allocate_zeroed\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align)?;\n-                self.memory.write_repeat(PrimVal::Ptr(ptr), 0, size)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-\n-            \"__rust_deallocate\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if old_size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                self.memory.deallocate(ptr, Some((old_size, align)))?;\n-            },\n-\n-            \"__rust_reallocate\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let size = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[3], usize)?.to_u64()?;\n-                if old_size == 0 || size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, size, align)?;\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n-            }\n-\n             \"__rust_maybe_catch_panic\" => {\n                 // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n                 // We abort on panic, so not much is going on here, but we still have to call the closure"}]}