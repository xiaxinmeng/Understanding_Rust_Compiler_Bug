{"sha": "5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "node_id": "C_kwDOAAsO6NoAKDVkOWU0ZDA3ZmNiZDUyNjQzNWIyOGYyZmNjYjdkOTg4OGEyMzc3YjY", "commit": {"author": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-07-25T03:06:22Z"}, "committer": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-08-22T10:08:46Z"}, "message": "get rid of `RefCell` in `TransitiveRelation`", "tree": {"sha": "cd3eff3a6efcf8046fcd5cb6218ed4aad9782738", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd3eff3a6efcf8046fcd5cb6218ed4aad9782738"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "html_url": "https://github.com/rust-lang/rust/commit/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/comments", "author": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9bb589cd678e034d194193fa892942315b10e2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bb589cd678e034d194193fa892942315b10e2a", "html_url": "https://github.com/rust-lang/rust/commit/a9bb589cd678e034d194193fa892942315b10e2a"}], "stats": {"total": 295, "additions": 178, "deletions": 117}, "files": [{"sha": "7c10047e9dc83c5ddeaa599d1ab4e3c2582b82a2", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "patch": "@@ -1,5 +1,5 @@\n use rustc_data_structures::frozen::Frozen;\n-use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use rustc_data_structures::transitive_relation::{TransitiveRelation, TransitiveRelationBuilder};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n@@ -61,25 +61,13 @@ pub(crate) fn create<'tcx>(\n         constraints,\n         universal_regions: universal_regions.clone(),\n         region_bound_pairs: Default::default(),\n-        relations: UniversalRegionRelations {\n-            universal_regions: universal_regions.clone(),\n-            outlives: Default::default(),\n-            inverse_outlives: Default::default(),\n-        },\n+        outlives: Default::default(),\n+        inverse_outlives: Default::default(),\n     }\n     .create()\n }\n \n impl UniversalRegionRelations<'_> {\n-    /// Records in the `outlives_relation` (and\n-    /// `inverse_outlives_relation`) that `fr_a: fr_b`. Invoked by the\n-    /// builder below.\n-    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n-        debug!(\"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\", fr_a, fr_b);\n-        self.outlives.add(fr_a, fr_b);\n-        self.inverse_outlives.add(fr_b, fr_a);\n-    }\n-\n     /// Given two universal regions, returns the postdominating\n     /// upper-bound (effectively the least upper bound).\n     ///\n@@ -216,11 +204,20 @@ struct UniversalRegionRelationsBuilder<'this, 'tcx> {\n     constraints: &'this mut MirTypeckRegionConstraints<'tcx>,\n \n     // outputs:\n-    relations: UniversalRegionRelations<'tcx>,\n+    outlives: TransitiveRelationBuilder<RegionVid>,\n+    inverse_outlives: TransitiveRelationBuilder<RegionVid>,\n     region_bound_pairs: RegionBoundPairs<'tcx>,\n }\n \n impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n+    /// Records in the `outlives_relation` (and\n+    /// `inverse_outlives_relation`) that `fr_a: fr_b`.\n+    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n+        debug!(\"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\", fr_a, fr_b);\n+        self.outlives.add(fr_a, fr_b);\n+        self.inverse_outlives.add(fr_b, fr_a);\n+    }\n+\n     pub(crate) fn create(mut self) -> CreateResult<'tcx> {\n         let unnormalized_input_output_tys = self\n             .universal_regions\n@@ -292,9 +289,9 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         let fr_fn_body = self.universal_regions.fr_fn_body;\n         for fr in self.universal_regions.universal_regions() {\n             debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n-            self.relations.relate_universal_regions(fr, fr);\n-            self.relations.relate_universal_regions(fr_static, fr);\n-            self.relations.relate_universal_regions(fr, fr_fn_body);\n+            self.relate_universal_regions(fr, fr);\n+            self.relate_universal_regions(fr_static, fr);\n+            self.relate_universal_regions(fr, fr_fn_body);\n         }\n \n         for data in &constraint_sets {\n@@ -313,7 +310,11 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         }\n \n         CreateResult {\n-            universal_region_relations: Frozen::freeze(self.relations),\n+            universal_region_relations: Frozen::freeze(UniversalRegionRelations {\n+                universal_regions: self.universal_regions,\n+                outlives: self.outlives.freeze(),\n+                inverse_outlives: self.inverse_outlives.freeze(),\n+            }),\n             region_bound_pairs: self.region_bound_pairs,\n             normalized_inputs_and_output,\n         }\n@@ -356,7 +357,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                     // The bound says that `r1 <= r2`; we store `r2: r1`.\n                     let r1 = self.universal_regions.to_region_vid(r1);\n                     let r2 = self.universal_regions.to_region_vid(r2);\n-                    self.relations.relate_universal_regions(r2, r1);\n+                    self.relate_universal_regions(r2, r1);\n                 }\n \n                 OutlivesBound::RegionSubParam(r_a, param_b) => {"}, {"sha": "f016c391fe777cfc83c21e317c080db6440086e2", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 67, "deletions": 54, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "patch": "@@ -1,45 +1,57 @@\n+use crate::frozen::Frozen;\n use crate::fx::FxIndexSet;\n-use crate::sync::Lock;\n use rustc_index::bit_set::BitMatrix;\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n+use std::ops::Deref;\n \n #[cfg(test)]\n mod tests;\n \n #[derive(Clone, Debug)]\n-pub struct TransitiveRelation<T> {\n+pub struct TransitiveRelationBuilder<T> {\n     // List of elements. This is used to map from a T to a usize.\n     elements: FxIndexSet<T>,\n \n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n     edges: Vec<Edge>,\n+}\n+\n+#[derive(Debug)]\n+pub struct TransitiveRelation<T> {\n+    // Frozen transitive relation elements and edges.\n+    builder: Frozen<TransitiveRelationBuilder<T>>,\n \n-    // This is a cached transitive closure derived from the edges.\n-    // Currently, we build it lazily and just throw out any existing\n-    // copy whenever a new edge is added. (The Lock is to permit\n-    // the lazy computation.) This is kind of silly, except for the\n-    // fact its size is tied to `self.elements.len()`, so I wanted to\n-    // wait before building it up to avoid reallocating as new edges\n-    // are added with new elements. Perhaps better would be to ask the\n-    // user for a batch of edges to minimize this effect, but I\n-    // already wrote the code this way. :P -nmatsakis\n-    closure: Lock<Option<BitMatrix<usize, usize>>>,\n+    // Cached transitive closure derived from the edges.\n+    closure: Frozen<BitMatrix<usize, usize>>,\n }\n \n-// HACK(eddyb) manual impl avoids `Default` bound on `T`.\n-impl<T: Eq + Hash> Default for TransitiveRelation<T> {\n-    fn default() -> Self {\n+impl<T> Deref for TransitiveRelation<T> {\n+    type Target = Frozen<TransitiveRelationBuilder<T>>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.builder\n+    }\n+}\n+\n+impl<T: Clone> Clone for TransitiveRelation<T> {\n+    fn clone(&self) -> Self {\n         TransitiveRelation {\n-            elements: Default::default(),\n-            edges: Default::default(),\n-            closure: Default::default(),\n+            builder: Frozen::freeze(self.builder.deref().clone()),\n+            closure: Frozen::freeze(self.closure.deref().clone()),\n         }\n     }\n }\n \n+// HACK(eddyb) manual impl avoids `Default` bound on `T`.\n+impl<T: Eq + Hash> Default for TransitiveRelationBuilder<T> {\n+    fn default() -> Self {\n+        TransitiveRelationBuilder { elements: Default::default(), edges: Default::default() }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n struct Index(usize);\n \n@@ -49,7 +61,7 @@ struct Edge {\n     target: Index,\n }\n \n-impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n+impl<T: Eq + Hash + Copy> TransitiveRelationBuilder<T> {\n     pub fn is_empty(&self) -> bool {\n         self.edges.is_empty()\n     }\n@@ -63,23 +75,19 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n-        let (index, added) = self.elements.insert_full(a);\n-        if added {\n-            // if we changed the dimensions, clear the cache\n-            *self.closure.get_mut() = None;\n-        }\n+        let (index, _added) = self.elements.insert_full(a);\n         Index(index)\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n-    /// relation. If `f` returns `None` for any end-point, returns\n-    /// `None`.\n-    pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n+    /// relation builder. If `f` returns `None` for any end-point,\n+    /// returns `None`.\n+    pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelationBuilder<U>>\n     where\n         F: FnMut(T) -> Option<U>,\n         U: Clone + Debug + Eq + Hash + Copy,\n     {\n-        let mut result = TransitiveRelation::default();\n+        let mut result = TransitiveRelationBuilder::default();\n         for edge in &self.edges {\n             result.add(f(self.elements[edge.source.0])?, f(self.elements[edge.target.0])?);\n         }\n@@ -93,10 +101,38 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n         let edge = Edge { source: a, target: b };\n         if !self.edges.contains(&edge) {\n             self.edges.push(edge);\n+        }\n+    }\n+\n+    /// Compute the transitive closure derived from the edges, and converted to\n+    /// the final result. After this, all elements will be immutable to maintain\n+    /// the correctness of the result.\n+    pub fn freeze(self) -> TransitiveRelation<T> {\n+        let mut matrix = BitMatrix::new(self.elements.len(), self.elements.len());\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            for edge in &self.edges {\n+                // add an edge from S -> T\n+                changed |= matrix.insert(edge.source.0, edge.target.0);\n \n-            // added an edge, clear the cache\n-            *self.closure.get_mut() = None;\n+                // add all outgoing edges from T into S\n+                changed |= matrix.union_rows(edge.target.0, edge.source.0);\n+            }\n         }\n+        TransitiveRelation { builder: Frozen::freeze(self), closure: Frozen::freeze(matrix) }\n+    }\n+}\n+\n+impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n+    /// Applies the (partial) function to each edge and returns a new\n+    /// relation including transitive closures.\n+    pub fn maybe_map<F, U>(&self, f: F) -> Option<TransitiveRelation<U>>\n+    where\n+        F: FnMut(T) -> Option<U>,\n+        U: Clone + Debug + Eq + Hash + Copy,\n+    {\n+        Some(self.builder.maybe_map(f)?.freeze())\n     }\n \n     /// Checks whether `a < target` (transitively)\n@@ -322,30 +358,7 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n     where\n         OP: FnOnce(&BitMatrix<usize, usize>) -> R,\n     {\n-        let mut closure_cell = self.closure.borrow_mut();\n-        let mut closure = closure_cell.take();\n-        if closure.is_none() {\n-            closure = Some(self.compute_closure());\n-        }\n-        let result = op(closure.as_ref().unwrap());\n-        *closure_cell = closure;\n-        result\n-    }\n-\n-    fn compute_closure(&self) -> BitMatrix<usize, usize> {\n-        let mut matrix = BitMatrix::new(self.elements.len(), self.elements.len());\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            for edge in &self.edges {\n-                // add an edge from S -> T\n-                changed |= matrix.insert(edge.source.0, edge.target.0);\n-\n-                // add all outgoing edges from T into S\n-                changed |= matrix.union_rows(edge.target.0, edge.source.0);\n-            }\n-        }\n-        matrix\n+        op(&self.closure)\n     }\n \n     /// Lists all the base edges in the graph: the initial _non-transitive_ set of element"}, {"sha": "e756c546e41ba705f0b6fe4a839199acd8633d23", "filename": "compiler/rustc_data_structures/src/transitive_relation/tests.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs?ref=5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "patch": "@@ -10,9 +10,10 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n \n #[test]\n fn test_one_step() {\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"b\");\n     relation.add(\"a\", \"c\");\n+    let relation = relation.freeze();\n     assert!(relation.contains(\"a\", \"c\"));\n     assert!(relation.contains(\"a\", \"b\"));\n     assert!(!relation.contains(\"b\", \"a\"));\n@@ -21,7 +22,7 @@ fn test_one_step() {\n \n #[test]\n fn test_many_steps() {\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"b\");\n     relation.add(\"a\", \"c\");\n     relation.add(\"a\", \"f\");\n@@ -31,6 +32,7 @@ fn test_many_steps() {\n     relation.add(\"b\", \"e\");\n \n     relation.add(\"e\", \"g\");\n+    let relation = relation.freeze();\n \n     assert!(relation.contains(\"a\", \"b\"));\n     assert!(relation.contains(\"a\", \"c\"));\n@@ -51,9 +53,10 @@ fn mubs_triangle() {\n     //      ^\n     //      |\n     //      b\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"tcx\");\n     relation.add(\"b\", \"tcx\");\n+    let relation = relation.freeze();\n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"tcx\"]);\n     assert_eq!(relation.parents(\"a\"), vec![\"tcx\"]);\n     assert_eq!(relation.parents(\"b\"), vec![\"tcx\"]);\n@@ -72,14 +75,15 @@ fn mubs_best_choice1() {\n     // need the second pare down call to get the right result (after\n     // intersection, we have [1, 2], but 2 -> 1).\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n     relation.add(\"2\", \"1\");\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"2\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"2\"]);\n@@ -99,14 +103,15 @@ fn mubs_best_choice2() {\n     // Like the preceding test, but in this case intersection is [2,\n     // 1], and hence we rely on the first pare down call.\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n     relation.add(\"1\", \"2\");\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"1\"]);\n@@ -118,12 +123,13 @@ fn mubs_best_choice2() {\n fn mubs_no_best_choice() {\n     // in this case, the intersection yields [1, 2], and the \"pare\n     // down\" calls find nothing to remove.\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\", \"2\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"1\", \"2\"]);\n@@ -135,7 +141,7 @@ fn mubs_best_choice_scc() {\n     // in this case, 1 and 2 form a cycle; we pick arbitrarily (but\n     // consistently).\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n@@ -144,6 +150,7 @@ fn mubs_best_choice_scc() {\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"1\"]);\n@@ -157,13 +164,14 @@ fn pdub_crisscross() {\n     //   /\\       |\n     // b -> b1 ---+\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"a1\");\n     relation.add(\"a\", \"b1\");\n     relation.add(\"b\", \"a1\");\n     relation.add(\"b\", \"b1\");\n     relation.add(\"a1\", \"x\");\n     relation.add(\"b1\", \"x\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"a1\", \"b1\"]);\n     assert_eq!(relation.postdom_upper_bound(\"a\", \"b\"), Some(\"x\"));\n@@ -179,7 +187,7 @@ fn pdub_crisscross_more() {\n     //   /\\    /\\             |\n     // b -> b1 -> b2 ---------+\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"a1\");\n     relation.add(\"a\", \"b1\");\n     relation.add(\"b\", \"a1\");\n@@ -194,6 +202,7 @@ fn pdub_crisscross_more() {\n \n     relation.add(\"a3\", \"x\");\n     relation.add(\"b2\", \"x\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"a1\", \"b1\"]);\n     assert_eq!(relation.minimal_upper_bounds(\"a1\", \"b1\"), vec![\"a2\", \"b2\"]);\n@@ -210,11 +219,12 @@ fn pdub_lub() {\n     //            |\n     // b -> b1 ---+\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"a1\");\n     relation.add(\"b\", \"b1\");\n     relation.add(\"a1\", \"x\");\n     relation.add(\"b1\", \"x\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"x\"]);\n     assert_eq!(relation.postdom_upper_bound(\"a\", \"b\"), Some(\"x\"));\n@@ -233,10 +243,11 @@ fn mubs_intermediate_node_on_one_side_only() {\n     //           b\n \n     // \"digraph { a -> c -> d; b -> d; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"b\", \"d\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"d\"]);\n }\n@@ -252,12 +263,13 @@ fn mubs_scc_1() {\n     //           b\n \n     // \"digraph { a -> c -> d; d -> c; a -> d; b -> d; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"c\");\n     relation.add(\"a\", \"d\");\n     relation.add(\"b\", \"d\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -272,12 +284,13 @@ fn mubs_scc_2() {\n     //      +--- b\n \n     // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"c\");\n     relation.add(\"b\", \"d\");\n     relation.add(\"b\", \"c\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -292,13 +305,14 @@ fn mubs_scc_3() {\n     //           b ---+\n \n     // \"digraph { a -> c -> d -> e -> c; b -> d; b -> e; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"e\");\n     relation.add(\"e\", \"c\");\n     relation.add(\"b\", \"d\");\n     relation.add(\"b\", \"e\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -314,13 +328,14 @@ fn mubs_scc_4() {\n     //           b ---+\n \n     // \"digraph { a -> c -> d -> e -> c; a -> d; b -> e; }\"\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"e\");\n     relation.add(\"e\", \"c\");\n     relation.add(\"a\", \"d\");\n     relation.add(\"b\", \"e\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -352,10 +367,11 @@ fn parent() {\n         (1, /*->*/ 3),\n     ];\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     for (a, b) in pairs {\n         relation.add(a, b);\n     }\n+    let relation = relation.freeze();\n \n     let p = relation.postdom_parent(3);\n     assert_eq!(p, Some(0));"}, {"sha": "728d691a2be7d27bc42121264409fe23e33a6138", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "patch": "@@ -27,13 +27,13 @@ impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, Default)]\n+#[derive(Clone, Debug)]\n pub struct FreeRegionMap<'tcx> {\n     // Stores the relation `a < b`, where `a` and `b` are regions.\n     //\n     // Invariant: only free regions like `'x` or `'static` are stored\n     // in this relation, not scopes.\n-    relation: TransitiveRelation<Region<'tcx>>,\n+    pub(crate) relation: TransitiveRelation<Region<'tcx>>,\n }\n \n impl<'tcx> FreeRegionMap<'tcx> {\n@@ -45,15 +45,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         self.relation.is_empty()\n     }\n \n-    // Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n-    // (with the exception that `'static: 'x` is not notable)\n-    pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n-        debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n-        if sub.is_free_or_static() && sup.is_free() {\n-            self.relation.add(sub, sup)\n-        }\n-    }\n-\n     /// Tests whether `r_a <= r_b`.\n     ///\n     /// Both regions must meet `is_free_or_static`."}, {"sha": "7841d59cacaf75f3a07c8917e7a2947fc1561435", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "patch": "@@ -2,6 +2,7 @@ use crate::infer::free_regions::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxIndexSet;\n+use rustc_data_structures::transitive_relation::TransitiveRelationBuilder;\n use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n \n use super::explicit_outlives_bounds;\n@@ -51,23 +52,39 @@ pub struct OutlivesEnvironment<'tcx> {\n     region_bound_pairs: RegionBoundPairs<'tcx>,\n }\n \n+/// Builder of OutlivesEnvironment. Use this structure if you need to add more outlives\n+/// bounds than `explicit_outlives_bounds(param_env)`.\n+pub struct OutlivesEnvironmentBuilder<'tcx> {\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    region_relation: TransitiveRelationBuilder<Region<'tcx>>,\n+\n+    region_bound_pairs: RegionBoundPairs<'tcx>,\n+}\n+\n /// \"Region-bound pairs\" tracks outlives relations that are known to\n /// be true, either because of explicit where-clauses like `T: 'a` or\n /// because of implied bounds.\n pub type RegionBoundPairs<'tcx> =\n     FxIndexSet<ty::OutlivesPredicate<GenericKind<'tcx>, Region<'tcx>>>;\n \n-impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n-    pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n-        let mut env = OutlivesEnvironment {\n+impl<'tcx> OutlivesEnvironment<'tcx> {\n+    /// Create a builder using `ParamEnv` and add explicit outlives bounds into it.\n+    pub fn builder(param_env: ty::ParamEnv<'tcx>) -> OutlivesEnvironmentBuilder<'tcx> {\n+        let mut builder = OutlivesEnvironmentBuilder {\n             param_env,\n-            free_region_map: Default::default(),\n+            region_relation: Default::default(),\n             region_bound_pairs: Default::default(),\n         };\n \n-        env.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n+        builder.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n+\n+        builder\n+    }\n \n-        env\n+    #[inline]\n+    /// Create a new `OutlivesEnvironment` without extra outlives bounds.\n+    pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n+        Self::builder(param_env).build()\n     }\n \n     /// Borrows current value of the `free_region_map`.\n@@ -79,6 +96,26 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n     pub fn region_bound_pairs(&self) -> &RegionBoundPairs<'tcx> {\n         &self.region_bound_pairs\n     }\n+}\n+\n+impl<'a, 'tcx> OutlivesEnvironmentBuilder<'tcx> {\n+    #[inline]\n+    pub fn build(self) -> OutlivesEnvironment<'tcx> {\n+        OutlivesEnvironment {\n+            param_env: self.param_env,\n+            free_region_map: FreeRegionMap { relation: self.region_relation.freeze() },\n+            region_bound_pairs: self.region_bound_pairs,\n+        }\n+    }\n+\n+    // Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n+    // (with the exception that `'static: 'x` is not notable)\n+    fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n+        debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n+        if sub.is_free_or_static() && sup.is_free() {\n+            self.region_relation.add(sub, sup)\n+        }\n+    }\n \n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n     ///\n@@ -122,7 +159,7 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n                         // system to be more general and to make use\n                         // of *every* relationship that arises here,\n                         // but presently we do not.)\n-                        self.free_region_map.relate_regions(r_a, r_b);\n+                        self.relate_regions(r_a, r_b);\n                     }\n                 }\n             }"}, {"sha": "d645084375f98ce2fc39fe4e4f4f83ad2baedefe", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "patch": "@@ -401,8 +401,9 @@ fn compare_predicate_entailment<'tcx>(\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        let mut outlives_environment = OutlivesEnvironment::builder(param_env);\n         outlives_environment.add_implied_bounds(infcx, wf_tys, impl_m_hir_id);\n+        let outlives_environment = outlives_environment.build();\n         infcx.check_region_obligations_and_report_errors(\n             impl_m.def_id.expect_local(),\n             &outlives_environment,\n@@ -1513,8 +1514,9 @@ pub fn check_type_bounds<'tcx>(\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        let mut outlives_environment = OutlivesEnvironment::builder(param_env);\n         outlives_environment.add_implied_bounds(&infcx, assumed_wf_types, impl_ty_hir_id);\n+        let outlives_environment = outlives_environment.build();\n         infcx.check_region_obligations_and_report_errors(\n             impl_ty.def_id.expect_local(),\n             &outlives_environment,"}, {"sha": "bcc1ea38c9d0f2a3519e1cab0ab7afd4ad3ee78d", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "patch": "@@ -1,7 +1,7 @@\n use crate::outlives::outlives_bounds::InferCtxtExt as _;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::outlives::env::OutlivesEnvironmentBuilder;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::Ty;\n \n@@ -14,7 +14,7 @@ pub(crate) trait OutlivesEnvironmentExt<'tcx> {\n     );\n }\n \n-impl<'tcx> OutlivesEnvironmentExt<'tcx> for OutlivesEnvironment<'tcx> {\n+impl<'tcx> OutlivesEnvironmentExt<'tcx> for OutlivesEnvironmentBuilder<'tcx> {\n     /// This method adds \"implied bounds\" into the outlives environment.\n     /// Implied bounds are outlives relationships that we can deduce\n     /// on the basis that certain types must be well-formed -- these are"}, {"sha": "4f080c0cdfa95de17a0e942ffaa1ffe075c4f94d", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "patch": "@@ -104,8 +104,9 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n             return;\n         }\n \n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        let mut outlives_environment = OutlivesEnvironment::builder(param_env);\n         outlives_environment.add_implied_bounds(infcx, assumed_wf_types, body_id);\n+        let outlives_environment = outlives_environment.build();\n         infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n     })\n }\n@@ -694,8 +695,9 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     // region constraints get added and solved there and we need to test each\n     // call individually.\n     tcx.infer_ctxt().enter(|infcx| {\n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        let mut outlives_environment = OutlivesEnvironment::builder(param_env);\n         outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id);\n+        let outlives_environment = outlives_environment.build();\n         let region_bound_pairs = outlives_environment.region_bound_pairs();\n \n         add_constraints(&infcx, region_bound_pairs);"}, {"sha": "e841d79d940e770530f64dc6e3fe7c1f332e4800", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9e4d07fcbd526435b28f2fccb7d9888a2377b6/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=5d9e4d07fcbd526435b28f2fccb7d9888a2377b6", "patch": "@@ -166,8 +166,7 @@ fn get_impl_substs<'tcx>(\n             return None;\n         };\n         Some((impl1_substs, impl2_substs))\n-    })\n-}\n+    })}\n \n /// Returns a list of all of the unconstrained subst of the given impl.\n ///"}]}