{"sha": "d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MmI0MzU4ZDI3OGFmYjZmMDE3MmY0Y2RkYjVhNjBlYmNkZmY3Y2E=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-06-01T22:59:12Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-06-09T20:05:52Z"}, "message": "rustpkg: Accept package IDs like github.com/foo/bar#0.3\n\nIf the package ID is of the form s#v, where v is a valid version\nstring, fetch tag v of that package.", "tree": {"sha": "6f77781c48337073b6f8c10856e22d95c6785a65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f77781c48337073b6f8c10856e22d95c6785a65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "html_url": "https://github.com/rust-lang/rust/commit/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53b83525521960b4ae6f9dc90b82429013346708", "url": "https://api.github.com/repos/rust-lang/rust/commits/53b83525521960b4ae6f9dc90b82429013346708", "html_url": "https://github.com/rust-lang/rust/commit/53b83525521960b4ae6f9dc90b82429013346708"}], "stats": {"total": 883, "additions": 542, "deletions": 341}, "files": [{"sha": "5e8139063deca25484f69104136b499f10968c72", "filename": "src/librustpkg/crate.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Fcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Fcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate.rs?ref=d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::path::Path;\n+use core::vec;\n+\n+/// A crate is a unit of Rust code to be compiled into a binary or library\n+pub struct Crate {\n+    file: Path,\n+    flags: ~[~str],\n+    cfgs: ~[~str]\n+}\n+\n+impl Crate {\n+\n+    pub fn new(p: &Path) -> Crate {\n+        Crate {\n+            file: copy *p,\n+            flags: ~[],\n+            cfgs: ~[]\n+        }\n+    }\n+\n+    fn flag(&self, flag: ~str) -> Crate {\n+        Crate {\n+            flags: vec::append(copy self.flags, [flag]),\n+            .. copy *self\n+        }\n+    }\n+\n+    fn flags(&self, flags: ~[~str]) -> Crate {\n+        Crate {\n+            flags: vec::append(copy self.flags, flags),\n+            .. copy *self\n+        }\n+    }\n+\n+    fn cfg(&self, cfg: ~str) -> Crate {\n+        Crate {\n+            cfgs: vec::append(copy self.cfgs, [cfg]),\n+            .. copy *self\n+        }\n+    }\n+\n+    fn cfgs(&self, cfgs: ~[~str]) -> Crate {\n+        Crate {\n+            cfgs: vec::append(copy self.cfgs, cfgs),\n+            .. copy *self\n+        }\n+    }\n+}"}, {"sha": "022acc29c8bca93e0795698a7c476143e448444d", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "patch": "@@ -9,11 +9,8 @@\n // except according to those terms.\n \n pub use package_path::{RemotePath, LocalPath, normalize, hash};\n-use extra::semver;\n use core::prelude::*;\n-use core::result;\n-use core::prelude::*;\n-use version::{default_version, try_getting_version, Version};\n+use version::{try_getting_version, Version, NoVersion, split_version};\n \n /// Path-fragment identifier of a package such as\n /// 'github.com/graydon/test'; path must be a relative\n@@ -38,6 +35,21 @@ impl PkgId {\n     pub fn new(s: &str) -> PkgId {\n         use conditions::bad_pkg_id::cond;\n \n+        let mut given_version = None;\n+\n+        // Did the user request a specific version?\n+        let s = match split_version(s) {\n+            Some((path, v)) => {\n+                debug!(\"s = %s, path = %s, v = %s\", s, path, v.to_str());\n+                given_version = Some(v);\n+                path\n+            }\n+            None => {\n+                debug!(\"%s has no explicit version\", s);\n+                s\n+            }\n+        };\n+\n         let p = Path(s);\n         if p.is_absolute {\n             return cond.raise((p, ~\"absolute pkgid\"));\n@@ -49,9 +61,12 @@ impl PkgId {\n         let local_path = normalize(copy remote_path);\n         let short_name = (copy local_path).filestem().expect(fmt!(\"Strange path! %s\", s));\n \n-        let version = match try_getting_version(remote_path) {\n+        let version = match given_version {\n             Some(v) => v,\n-            None => default_version()\n+            None => match try_getting_version(&remote_path) {\n+                Some(v) => v,\n+                None => NoVersion\n+            }\n         };\n \n         PkgId {\n@@ -69,13 +84,17 @@ impl PkgId {\n     }\n \n     pub fn short_name_with_version(&self) -> ~str {\n-        fmt!(\"%s-%s\", self.short_name, self.version.to_str())\n+        fmt!(\"%s%s\", self.short_name, self.version.to_str())\n     }\n }\n \n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n+        let maybe_dash = match self.version {\n+            NoVersion => \"\",\n+            _         => \"-\"\n+        };\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.local_path.to_str(), self.version.to_str())\n+        fmt!(\"%s%s%s\", self.local_path.to_str(), maybe_dash, self.version.to_str())\n     }\n }"}, {"sha": "7c4c63781240bdbebabe9d8c6fc101c4a1e902e4", "filename": "src/librustpkg/package_source.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "patch": "@@ -0,0 +1,239 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::*;\n+use package_id::PkgId;\n+use core::path::Path;\n+use core::option::*;\n+use core::{os, run, str, vec};\n+use context::*;\n+use crate::Crate;\n+use path_util::pkgid_src_in_workspace;\n+use util::{compile_crate, note};\n+use version::{ExactRevision, SemanticVersion, NoVersion};\n+\n+// An enumeration of the unpacked source of a package workspace.\n+// This contains a list of files found in the source workspace.\n+pub struct PkgSrc {\n+    root: Path, // root of where the package source code lives\n+    dst_dir: Path, // directory where we will put the compiled output\n+    id: PkgId,\n+    libs: ~[Crate],\n+    mains: ~[Crate],\n+    tests: ~[Crate],\n+    benchs: ~[Crate],\n+}\n+\n+condition! {\n+    build_err: (~str) -> ();\n+}\n+\n+impl PkgSrc {\n+\n+    pub fn new(src_dir: &Path, dst_dir: &Path,\n+                  id: &PkgId) -> PkgSrc {\n+        PkgSrc {\n+            root: copy *src_dir,\n+            dst_dir: copy *dst_dir,\n+            id: copy *id,\n+            libs: ~[],\n+            mains: ~[],\n+            tests: ~[],\n+            benchs: ~[]\n+        }\n+    }\n+\n+\n+    fn check_dir(&self) -> Path {\n+        use conditions::nonexistent_package::cond;\n+\n+        debug!(\"Pushing onto root: %s | %s\", self.id.remote_path.to_str(),\n+               self.root.to_str());\n+        let dir;\n+        let dirs = pkgid_src_in_workspace(&self.id, &self.root);\n+        debug!(\"Checking dirs: %?\", dirs);\n+        let path = dirs.find(|d| os::path_exists(d));\n+        match path {\n+            Some(d) => dir = d,\n+            None => dir = match self.fetch_git() {\n+                None => cond.raise((copy self.id, ~\"supplied path for package dir does not \\\n+                                      exist, and couldn't interpret it as a URL fragment\")),\n+                Some(d) => d\n+            }\n+        }\n+        if !os::path_is_dir(&dir) {\n+            cond.raise((copy self.id, ~\"supplied path for package dir is a \\\n+                                        non-directory\"));\n+        }\n+\n+        dir\n+    }\n+\n+    /// Try interpreting self's package id as a remote package, and try\n+    /// fetching it and caching it in a local directory. Return the cached directory\n+    /// if this was successful, None otherwise\n+    /// (right now we only support git)\n+    pub fn fetch_git(&self) -> Option<Path> {\n+\n+        let mut local = self.root.push(\"src\");\n+        local = local.push(self.id.to_str());\n+        // Git can't clone into a non-empty directory\n+        os::remove_dir_recursive(&local);\n+\n+        let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n+        let branch_args = match self.id.version {\n+                      NoVersion => ~[],\n+                      ExactRevision(ref s) => ~[~\"--branch\", copy *s],\n+                      SemanticVersion(ref s) => ~[~\"--branch\", s.to_str()]\n+        };\n+\n+\n+        note(fmt!(\"git clone %s %s %?\", url, local.to_str(), branch_args));\n+\n+        if run::process_output(\"git\",\n+                               ~[~\"clone\", copy url, local.to_str()] + branch_args).status != 0 {\n+            note(fmt!(\"fetching %s failed: can't clone repository\", url));\n+            None\n+        }\n+        else {\n+            Some(local)\n+        }\n+    }\n+\n+\n+    // If a file named \"pkg.rs\" in the current directory exists,\n+    // return the path for it. Otherwise, None\n+    pub fn package_script_option(&self, cwd: &Path) -> Option<Path> {\n+        let maybe_path = cwd.push(\"pkg.rs\");\n+        if os::path_exists(&maybe_path) {\n+            Some(maybe_path)\n+        }\n+        else {\n+            None\n+        }\n+    }\n+\n+    /// True if the given path's stem is self's pkg ID's stem\n+    /// or if the pkg ID's stem is <rust-foo> and the given path's\n+    /// stem is foo\n+    /// Requires that dashes in p have already been normalized to\n+    /// underscores\n+    fn stem_matches(&self, p: &Path) -> bool {\n+        let self_id = self.id.local_path.filestem();\n+        if self_id == p.filestem() {\n+            return true;\n+        }\n+        else {\n+            for self_id.each |pth| {\n+                if pth.starts_with(\"rust_\") // because p is already normalized\n+                    && match p.filestem() {\n+                           Some(s) => str::eq_slice(s, pth.slice(5, pth.len())),\n+                           None => false\n+                       } { return true; }\n+            }\n+        }\n+        false\n+    }\n+\n+    fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n+        assert!(p.components.len() > prefix);\n+        let mut sub = Path(\"\");\n+        for vec::slice(p.components, prefix,\n+                       p.components.len()).each |c| {\n+            sub = sub.push(*c);\n+        }\n+        debug!(\"found crate %s\", sub.to_str());\n+        cs.push(Crate::new(&sub));\n+    }\n+\n+    /// Infers crates to build. Called only in the case where there\n+    /// is no custom build logic\n+    pub fn find_crates(&mut self) {\n+        use conditions::missing_pkg_files::cond;\n+\n+        let dir = self.check_dir();\n+        debug!(\"Called check_dir, I'm in %s\", dir.to_str());\n+        let prefix = dir.components.len();\n+        debug!(\"Matching against %?\", self.id.local_path.filestem());\n+        for os::walk_dir(&dir) |pth| {\n+            match pth.filename() {\n+                Some(~\"lib.rs\") => PkgSrc::push_crate(&mut self.libs,\n+                                                      prefix,\n+                                                      pth),\n+                Some(~\"main.rs\") => PkgSrc::push_crate(&mut self.mains,\n+                                                       prefix,\n+                                                       pth),\n+                Some(~\"test.rs\") => PkgSrc::push_crate(&mut self.tests,\n+                                                       prefix,\n+                                                       pth),\n+                Some(~\"bench.rs\") => PkgSrc::push_crate(&mut self.benchs,\n+                                                        prefix,\n+                                                        pth),\n+                _ => ()\n+            }\n+        }\n+\n+        if self.libs.is_empty() && self.mains.is_empty()\n+            && self.tests.is_empty() && self.benchs.is_empty() {\n+\n+            note(~\"Couldn't infer any crates to build.\\n\\\n+                         Try naming a crate `main.rs`, `lib.rs`, \\\n+                         `test.rs`, or `bench.rs`.\");\n+            cond.raise(copy self.id);\n+        }\n+\n+        debug!(\"found %u libs, %u mains, %u tests, %u benchs\",\n+               self.libs.len(),\n+               self.mains.len(),\n+               self.tests.len(),\n+               self.benchs.len())\n+    }\n+\n+    fn build_crates(&self,\n+                    ctx: &Ctx,\n+                    dst_dir: &Path,\n+                    src_dir: &Path,\n+                    crates: &[Crate],\n+                    cfgs: &[~str],\n+                    what: OutputType) {\n+        for crates.each |&crate| {\n+            let path = &src_dir.push_rel(&crate.file).normalize();\n+            note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n+            note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n+\n+            let result = compile_crate(ctx,\n+                                       &self.id,\n+                                       path,\n+                                       dst_dir,\n+                                       crate.flags,\n+                                       crate.cfgs + cfgs,\n+                                       false,\n+                                       what);\n+            if !result {\n+                build_err::cond.raise(fmt!(\"build failure on %s\",\n+                                           path.to_str()));\n+            }\n+            debug!(\"Result of compiling %s was %?\",\n+                   path.to_str(), result);\n+        }\n+    }\n+\n+    pub fn build(&self, ctx: &Ctx, dst_dir: Path, cfgs: ~[~str]) {\n+        let dir = self.check_dir();\n+        debug!(\"Building libs in %s\", dir.to_str());\n+        self.build_crates(ctx, &dst_dir, &dir, self.libs, cfgs, Lib);\n+        debug!(\"Building mains\");\n+        self.build_crates(ctx, &dst_dir, &dir, self.mains, cfgs, Main);\n+        debug!(\"Building tests\");\n+        self.build_crates(ctx, &dst_dir, &dir, self.tests, cfgs, Test);\n+        debug!(\"Building benches\");\n+        self.build_crates(ctx, &dst_dir, &dir, self.benchs, cfgs, Bench);\n+    }\n+}"}, {"sha": "af6b23ba75544f877f979bcc38626fbe0e629f0d", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "patch": "@@ -12,7 +12,7 @@\n \n use core::prelude::*;\n pub use package_path::{RemotePath, LocalPath};\n-pub use package_id::{PkgId, Version};\n+pub use package_id::PkgId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use core::os::mkdir_recursive;\n@@ -210,11 +210,17 @@ pub fn target_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n }\n \n \n-/// Returns the executable that would be installed for <pkgid>\n-/// in <workspace>\n+/// Returns the installed path for <built_library> in <workspace>\n /// As a side effect, creates the lib-dir if it doesn't exist\n-pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Lib, Install)\n+pub fn target_library_in_workspace(workspace: &Path,\n+                                   built_library: &Path) -> Path {\n+    use conditions::bad_path::cond;\n+    let result = workspace.push(\"lib\");\n+    if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n+        cond.raise((copy result, ~\"I couldn't create the library directory\"));\n+    }\n+    result.push(built_library.filename().expect(fmt!(\"I don't know how to treat %s as a library\",\n+                                                   built_library.to_str())))\n }\n \n /// Returns the test executable that would be installed for <pkgid>"}, {"sha": "37b8c2ad43384e304c6dc52b0d2673cf8cda5e42", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 9, "deletions": 259, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "patch": "@@ -36,18 +36,21 @@ use rustc::metadata::filesearch;\n use extra::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n-use path_util::{build_pkg_id_in_workspace, pkgid_src_in_workspace, first_pkgid_src_in_workspace};\n+use path_util::{build_pkg_id_in_workspace, first_pkgid_src_in_workspace};\n use path_util::u_rwx;\n use path_util::{built_executable_in_workspace, built_library_in_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use workspace::pkg_parent_workspaces;\n use context::Ctx;\n use package_id::PkgId;\n+use package_source::PkgSrc;\n \n mod conditions;\n mod context;\n+mod crate;\n mod package_id;\n mod package_path;\n+mod package_source;\n mod path_util;\n mod search;\n mod target;\n@@ -337,11 +340,11 @@ impl Ctx {\n         let maybe_executable = built_executable_in_workspace(id, workspace);\n         let maybe_library = built_library_in_workspace(id, workspace);\n         let target_exec = target_executable_in_workspace(id, workspace);\n-        let target_lib = target_library_in_workspace(id, workspace);\n+        let target_lib = maybe_library.map(|p| target_library_in_workspace(workspace, p));\n \n-        debug!(\"target_exec = %s target_lib = %s \\\n+        debug!(\"target_exec = %s target_lib = %? \\\n                 maybe_executable = %? maybe_library = %?\",\n-               target_exec.to_str(), target_lib.to_str(),\n+               target_exec.to_str(), target_lib,\n                maybe_executable, maybe_library);\n \n         for maybe_executable.each |exec| {\n@@ -352,6 +355,8 @@ impl Ctx {\n             }\n         }\n         for maybe_library.each |lib| {\n+            let target_lib = (copy target_lib).expect(fmt!(\"I built %s but apparently \\\n+                                                didn't install it!\", lib.to_str()));\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n             if !(os::mkdir_recursive(&target_lib.dir_path(), u_rwx) &&\n                  os::copy_file(lib, &target_lib)) {\n@@ -432,51 +437,6 @@ pub fn main() {\n     }.run(cmd, args);\n }\n \n-/// A crate is a unit of Rust code to be compiled into a binary or library\n-pub struct Crate {\n-    file: Path,\n-    flags: ~[~str],\n-    cfgs: ~[~str]\n-}\n-\n-impl Crate {\n-    pub fn new(p: &Path) -> Crate {\n-        Crate {\n-            file: copy *p,\n-            flags: ~[],\n-            cfgs: ~[]\n-        }\n-    }\n-\n-    pub fn flag(&self, flag: ~str) -> Crate {\n-        Crate {\n-            flags: vec::append(copy self.flags, [flag]),\n-            .. copy *self\n-        }\n-    }\n-\n-    pub fn flags(&self, flags: ~[~str]) -> Crate {\n-        Crate {\n-            flags: vec::append(copy self.flags, flags),\n-            .. copy *self\n-        }\n-    }\n-\n-    pub fn cfg(&self, cfg: ~str) -> Crate {\n-        Crate {\n-            cfgs: vec::append(copy self.cfgs, [cfg]),\n-            .. copy *self\n-        }\n-    }\n-\n-    pub fn cfgs(&self, cfgs: ~[~str]) -> Crate {\n-        Crate {\n-            cfgs: vec::append(copy self.cfgs, cfgs),\n-            .. copy *self\n-        }\n-    }\n-}\n-\n /**\n  * Get the working directory of the package script.\n  * Assumes that the package script has been compiled\n@@ -495,213 +455,3 @@ pub fn work_dir() -> Path {\n pub fn src_dir() -> Path {\n     os::getcwd()\n }\n-\n-// An enumeration of the unpacked source of a package workspace.\n-// This contains a list of files found in the source workspace.\n-pub struct PkgSrc {\n-    root: Path, // root of where the package source code lives\n-    dst_dir: Path, // directory where we will put the compiled output\n-    id: PkgId,\n-    libs: ~[Crate],\n-    mains: ~[Crate],\n-    tests: ~[Crate],\n-    benchs: ~[Crate],\n-}\n-\n-condition! {\n-    build_err: (~str) -> ();\n-}\n-\n-impl PkgSrc {\n-\n-    fn new(src_dir: &Path, dst_dir: &Path,\n-                  id: &PkgId) -> PkgSrc {\n-        PkgSrc {\n-            root: copy *src_dir,\n-            dst_dir: copy *dst_dir,\n-            id: copy *id,\n-            libs: ~[],\n-            mains: ~[],\n-            tests: ~[],\n-            benchs: ~[]\n-        }\n-    }\n-\n-\n-    fn check_dir(&self) -> Path {\n-        use conditions::nonexistent_package::cond;\n-\n-        debug!(\"Pushing onto root: %s | %s\", self.id.remote_path.to_str(),\n-               self.root.to_str());\n-        let dir;\n-        let dirs = pkgid_src_in_workspace(&self.id, &self.root);\n-        debug!(\"Checking dirs: %?\", dirs);\n-        let path = dirs.find(|d| os::path_exists(d));\n-        match path {\n-            Some(d) => dir = d,\n-            None => dir = match self.fetch_git() {\n-                None => cond.raise((copy self.id, ~\"supplied path for package dir does not \\\n-                                      exist, and couldn't interpret it as a URL fragment\")),\n-                Some(d) => d\n-            }\n-        }\n-        if !os::path_is_dir(&dir) {\n-            cond.raise((copy self.id, ~\"supplied path for package dir is a \\\n-                                        non-directory\"));\n-        }\n-\n-        dir\n-    }\n-\n-    /// Try interpreting self's package id as a remote package, and try\n-    /// fetching it and caching it in a local directory. Return the cached directory\n-    /// if this was successful, None otherwise\n-    /// (right now we only support git)\n-    fn fetch_git(&self) -> Option<Path> {\n-\n-        let mut local = self.root.push(\"src\");\n-        local = local.push(self.id.to_str());\n-        // Git can't clone into a non-empty directory\n-        os::remove_dir_recursive(&local);\n-\n-        let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n-        util::note(fmt!(\"git clone %s %s\", url, local.to_str()));\n-\n-        if run::process_output(\"git\", [~\"clone\", copy url, local.to_str()]).status != 0 {\n-            util::note(fmt!(\"fetching %s failed: can't clone repository\", url));\n-            None\n-        }\n-        else {\n-            Some(local)\n-        }\n-    }\n-\n-\n-    // If a file named \"pkg.rs\" in the current directory exists,\n-    // return the path for it. Otherwise, None\n-    fn package_script_option(&self, cwd: &Path) -> Option<Path> {\n-        let maybe_path = cwd.push(\"pkg.rs\");\n-        if os::path_exists(&maybe_path) {\n-            Some(maybe_path)\n-        }\n-        else {\n-            None\n-        }\n-    }\n-\n-    /// True if the given path's stem is self's pkg ID's stem\n-    /// or if the pkg ID's stem is <rust-foo> and the given path's\n-    /// stem is foo\n-    /// Requires that dashes in p have already been normalized to\n-    /// underscores\n-    fn stem_matches(&self, p: &Path) -> bool {\n-        let self_id = self.id.local_path.filestem();\n-        if self_id == p.filestem() {\n-            return true;\n-        }\n-        else {\n-            for self_id.each |pth| {\n-                if pth.starts_with(\"rust_\") // because p is already normalized\n-                    && match p.filestem() {\n-                           Some(s) => str::eq_slice(s, pth.slice(5, pth.len())),\n-                           None => false\n-                       } { return true; }\n-            }\n-        }\n-        false\n-    }\n-\n-    fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n-        assert!(p.components.len() > prefix);\n-        let mut sub = Path(\"\");\n-        for vec::slice(p.components, prefix,\n-                       p.components.len()).each |c| {\n-            sub = sub.push(*c);\n-        }\n-        debug!(\"found crate %s\", sub.to_str());\n-        cs.push(Crate::new(&sub));\n-    }\n-\n-    /// Infers crates to build. Called only in the case where there\n-    /// is no custom build logic\n-    fn find_crates(&mut self) {\n-        use conditions::missing_pkg_files::cond;\n-\n-        let dir = self.check_dir();\n-        let prefix = dir.components.len();\n-        debug!(\"Matching against %?\", self.id.local_path.filestem());\n-        for os::walk_dir(&dir) |pth| {\n-            match pth.filename() {\n-                Some(~\"lib.rs\") => PkgSrc::push_crate(&mut self.libs,\n-                                                      prefix,\n-                                                      pth),\n-                Some(~\"main.rs\") => PkgSrc::push_crate(&mut self.mains,\n-                                                       prefix,\n-                                                       pth),\n-                Some(~\"test.rs\") => PkgSrc::push_crate(&mut self.tests,\n-                                                       prefix,\n-                                                       pth),\n-                Some(~\"bench.rs\") => PkgSrc::push_crate(&mut self.benchs,\n-                                                        prefix,\n-                                                        pth),\n-                _ => ()\n-            }\n-        }\n-\n-        if self.libs.is_empty() && self.mains.is_empty()\n-            && self.tests.is_empty() && self.benchs.is_empty() {\n-\n-            util::note(\"Couldn't infer any crates to build.\\n\\\n-                        Try naming a crate `main.rs`, `lib.rs`, \\\n-                        `test.rs`, or `bench.rs`.\");\n-            cond.raise(copy self.id);\n-        }\n-\n-        debug!(\"found %u libs, %u mains, %u tests, %u benchs\",\n-               self.libs.len(),\n-               self.mains.len(),\n-               self.tests.len(),\n-               self.benchs.len())\n-    }\n-\n-    fn build_crates(&self,\n-                    ctx: &Ctx,\n-                    dst_dir: &Path,\n-                    src_dir: &Path,\n-                    crates: &[Crate],\n-                    cfgs: &[~str],\n-                    what: OutputType) {\n-        for crates.each |&crate| {\n-            let path = &src_dir.push_rel(&crate.file).normalize();\n-            util::note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n-            util::note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n-\n-            let result = util::compile_crate(ctx,\n-                                             &self.id,\n-                                             path,\n-                                             dst_dir,\n-                                             crate.flags,\n-                                             crate.cfgs + cfgs,\n-                                             false,\n-                                             what);\n-            if !result {\n-                build_err::cond.raise(fmt!(\"build failure on %s\",\n-                                           path.to_str()));\n-            }\n-            debug!(\"Result of compiling %s was %?\",\n-                   path.to_str(), result);\n-        }\n-    }\n-\n-    fn build(&self, ctx: &Ctx, dst_dir: Path, cfgs: ~[~str]) {\n-        let dir = self.check_dir();\n-        debug!(\"Building libs\");\n-        self.build_crates(ctx, &dst_dir, &dir, self.libs, cfgs, Lib);\n-        debug!(\"Building mains\");\n-        self.build_crates(ctx, &dst_dir, &dir, self.mains, cfgs, Main);\n-        debug!(\"Building tests\");\n-        self.build_crates(ctx, &dst_dir, &dir, self.tests, cfgs, Test);\n-        debug!(\"Building benches\");\n-        self.build_crates(ctx, &dst_dir, &dir, self.benchs, cfgs, Bench);\n-    }\n-}"}, {"sha": "8df84b27fccf46038b693a5479408e388923ca42", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 85, "deletions": 36, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "patch": "@@ -19,11 +19,14 @@ use core::result;\n use extra::tempfile::mkdtemp;\n use package_path::*;\n use package_id::PkgId;\n-use version::{default_version, ExactRevision};\n+use package_source::*;\n+use version::{ExactRevision, NoVersion, Version};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n                make_dir_rwx, u_rwx,\n-               built_bench_in_workspace, built_test_in_workspace};\n+               built_bench_in_workspace, built_test_in_workspace,\n+               built_library_in_workspace, built_executable_in_workspace,\n+                installed_library_in_workspace};\n \n fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n     Ctx {\n@@ -40,7 +43,7 @@ fn fake_pkg() -> PkgId {\n         local_path: normalize(copy remote),\n         remote_path: remote,\n         short_name: sn,\n-        version: default_version()\n+        version: NoVersion\n     }\n }\n \n@@ -50,17 +53,7 @@ fn remote_pkg() -> PkgId {\n         local_path: normalize(copy remote),\n         remote_path: remote,\n         short_name: ~\"test_pkg\",\n-        version: default_version()\n-    }\n-}\n-\n-fn remote_versioned_pkg() -> PkgId {\n-    let remote = RemotePath(Path(\"github.com/catamorphism/test_pkg_version\"));\n-    PkgId {\n-        local_path: normalize(copy remote),\n-        remote_path: remote,\n-        short_name: ~\"test_pkg_version\",\n-        version: default_version()\n+        version: NoVersion\n     }\n }\n \n@@ -71,11 +64,21 @@ fn writeFile(file_path: &Path, contents: &str) {\n     out.write_line(contents);\n }\n \n-fn mk_temp_workspace(short_name: &LocalPath) -> Path {\n+fn mk_empty_workspace(short_name: &LocalPath, version: &Version) -> Path {\n     let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n     // include version number in directory name\n-    let package_dir = workspace.push(\"src\").push(fmt!(\"%s-0.1\", short_name.to_str()));\n+    let package_dir = workspace.push(\"src\").push(fmt!(\"%s%s\",\n+                                                      short_name.to_str(), version.to_str()));\n     assert!(os::mkdir_recursive(&package_dir, u_rwx));\n+    package_dir.pop().pop()\n+}\n+\n+fn mk_temp_workspace(short_name: &LocalPath, version: &Version) -> Path {\n+    let package_dir = mk_empty_workspace(short_name,\n+                                         version).push(\"src\").push(fmt!(\"%s%s\",\n+                                                            short_name.to_str(),\n+                                                            version.to_str()));\n+\n     debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n@@ -87,7 +90,7 @@ fn mk_temp_workspace(short_name: &LocalPath) -> Path {\n               \"#[test] pub fn f() { (); }\");\n     writeFile(&package_dir.push(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n-    workspace\n+    package_dir.pop().pop()\n }\n \n fn is_rwx(p: &Path) -> bool {\n@@ -131,7 +134,7 @@ fn test_install_valid() {\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = fake_pkg();\n-    let temp_workspace = mk_temp_workspace(&temp_pkg_id.local_path);\n+    let temp_workspace = mk_temp_workspace(&temp_pkg_id.local_path, &NoVersion);\n     // should have test, bench, lib, and main\n     ctxt.install(&temp_workspace, &temp_pkg_id);\n     // Check that all files exist\n@@ -189,7 +192,10 @@ fn test_install_url() {\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n-    let lib = target_library_in_workspace(&temp_pkg_id, &workspace);\n+    let built_lib =\n+        built_library_in_workspace(&temp_pkg_id,\n+                                   &workspace).expect(\"test_install_url: built lib should exist\");\n+    let lib = target_library_in_workspace(&workspace, &built_lib);\n     debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n@@ -223,24 +229,19 @@ fn test_package_ids_must_be_relative_path_like() {\n \n     */\n \n-    let default_version_str = \"0.1\";\n-    let addversion = |s| {\n-        fmt!(\"%s-%s\", s, default_version_str)\n-    };\n-\n     let whatever = PkgId::new(\"foo\");\n \n-    assert_eq!(addversion(\"foo\"), whatever.to_str());\n-    assert!(addversion(\"github.com/mozilla/rust\") ==\n-            PkgId::new(\"github.com/mozilla/rust\").to_str());\n+    assert_eq!(~\"foo\", whatever.to_str());\n+    assert!(\"github.com/catamorphism/test_pkg\" ==\n+            PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n     do cond.trap(|(p, e)| {\n         assert!(\"\" == p.to_str());\n         assert!(\"0-length pkgid\" == e);\n         copy whatever\n     }).in {\n         let x = PkgId::new(\"\");\n-        assert_eq!(addversion(\"foo\"), x.to_str());\n+        assert_eq!(~\"foo\", x.to_str());\n     }\n \n     do cond.trap(|(p, e)| {\n@@ -249,22 +250,70 @@ fn test_package_ids_must_be_relative_path_like() {\n         copy whatever\n     }).in {\n         let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n-        assert_eq!(addversion(\"foo\"), z.to_str());\n+        assert_eq!(~\"foo\", z.to_str());\n     }\n \n }\n \n #[test]\n fn test_package_version() {\n-    let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n-    let sysroot = test_sysroot();\n-    debug!(\"sysroot = %s\", sysroot.to_str());\n-    let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = PkgId::new(\"github.com/catamorphism/test_pkg_version\");\n     match temp_pkg_id.version {\n-        ExactRevision(0.2) => (),\n-        _ => fail!(fmt!(\"test_package_version: package version was %?, expected Some(0.2)\",\n+        ExactRevision(~\"0.4\") => (),\n+        _ => fail!(fmt!(\"test_package_version: package version was %?, expected Some(0.4)\",\n+                        temp_pkg_id.version))\n+    }\n+    let temp = mk_empty_workspace(&LocalPath(Path(\"test_pkg_version\")), &temp_pkg_id.version);\n+    let ctx = fake_ctxt(Some(@test_sysroot()));\n+    ctx.build(&temp, &temp_pkg_id);\n+    assert!(match built_library_in_workspace(&temp_pkg_id, &temp) {\n+        Some(p) => p.to_str().ends_with(fmt!(\"0.4%s\", os::consts::DLL_SUFFIX)),\n+        None    => false\n+    });\n+    assert!(built_executable_in_workspace(&temp_pkg_id, &temp)\n+            == Some(temp.push(\"build\").\n+                    push(\"github.com\").\n+                    push(\"catamorphism\").\n+                    push(\"test_pkg_version\").\n+                    push(\"test_pkg_version\")));\n+}\n+\n+// FIXME #7006: Fails on linux for some reason\n+#[test]\n+#[ignore(cfg(target_os = \"linux\"))]\n+fn test_package_request_version() {\n+    let temp_pkg_id = PkgId::new(\"github.com/catamorphism/test_pkg_version#0.3\");\n+    let temp = mk_empty_workspace(&LocalPath(Path(\"test_pkg_version\")), &ExactRevision(~\"0.3\"));\n+    let pkg_src = PkgSrc::new(&temp, &temp, &temp_pkg_id);\n+    match temp_pkg_id.version {\n+        ExactRevision(~\"0.3\") => {\n+            match pkg_src.fetch_git() {\n+                Some(p) => {\n+                    assert!(os::path_exists(&p.push(\"version-0.3-file.txt\")));\n+                    assert!(!os::path_exists(&p.push(\"version-0.4-file.txt\")));\n+\n+                }\n+                None => fail!(\"test_package_request_version: fetch_git failed\")\n+            }\n+        }\n+        ExactRevision(n) => {\n+            fail!(\"n is %? and %? %s %?\", n, n, if n == ~\"0.3\" { \"==\" } else { \"!=\" }, \"0.3\");\n+        }\n+        _ => fail!(fmt!(\"test_package_version: package version was %?, expected ExactRevision(0.3)\",\n                         temp_pkg_id.version))\n     }\n-    // also check that file paths are right\n+    let c = fake_ctxt(Some(@test_sysroot()));\n+    c.install(&temp, &temp_pkg_id);\n+    debug!(\"installed_library_in_workspace(%s, %s) = %?\", temp_pkg_id.short_name, temp.to_str(),\n+           installed_library_in_workspace(temp_pkg_id.short_name, &temp));\n+    assert!(match installed_library_in_workspace(temp_pkg_id.short_name, &temp) {\n+        Some(p) => {\n+            debug!(\"installed: %s\", p.to_str());\n+            p.to_str().ends_with(fmt!(\"0.3%s\", os::consts::DLL_SUFFIX))\n+        }\n+        None    => false\n+    });\n+    assert!(target_executable_in_workspace(&temp_pkg_id, &temp)\n+            == temp.push(\"bin\").push(\"test_pkg_version\"));\n+\n }"}, {"sha": "10d2d139a145b39ac5d0a37fc85c63b0d91d8aba", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "patch": "@@ -26,7 +26,7 @@ use rustc::driver::driver::compile_upto;\n use rustc::driver::session::{lib_crate, bin_crate};\n use context::Ctx;\n use package_id::PkgId;\n-use path_util::target_library_in_workspace;\n+use path_util::{target_library_in_workspace, built_library_in_workspace};\n use search::find_library_in_search_path;\n pub use target::{OutputType, Main, Lib, Bench, Test};\n \n@@ -274,7 +274,7 @@ pub fn compile_input(ctxt: &Ctx,\n                  ~[@dummy_spanned(meta_name_value(@~\"name\",\n                                       mk_string_lit(@short_name_to_use))),\n                    @dummy_spanned(meta_name_value(@~\"vers\",\n-                                      mk_string_lit(@(copy pkg_id.version.to_str()))))])))],\n+                         mk_string_lit(@pkg_id.version.to_str_nonempty())))])))],\n             ..copy crate.node});\n     }\n \n@@ -371,9 +371,14 @@ fn find_and_install_dependencies(ctxt: &Ctx,\n                         // Try to install it\n                         let pkg_id = PkgId::new(*lib_name);\n                         my_ctxt.install(&my_workspace, &pkg_id);\n+                        let built_lib =\n+                            built_library_in_workspace(&pkg_id,\n+                                &my_workspace).expect(fmt!(\"find_and_install_dependencies: \\\n+                                I thought I already built %s, but the library doesn't seem \\\n+                                to exist\", *lib_name));\n                         // Also, add an additional search path\n-                        let installed_path = target_library_in_workspace(&pkg_id,\n-                                                                         &my_workspace).pop();\n+                        let installed_path = target_library_in_workspace(&my_workspace,\n+                                                                         &built_lib).pop();\n                         debug!(\"Great, I installed %s, and it's in %s\",\n                                *lib_name, installed_path.to_str());\n                         save(installed_path);"}, {"sha": "92906f5af543d86e638cad2a0789a84609a270b0", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 104, "deletions": 29, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92b4358d278afb6f0172f4cddb5a60ebcdff7ca/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=d92b4358d278afb6f0172f4cddb5a60ebcdff7ca", "patch": "@@ -13,44 +13,46 @@\n \n extern mod std;\n \n-use std::semver;\n+use extra::semver;\n use core::prelude::*;\n-use core::run;\n+use core::{char, os, result, run, str};\n use package_path::RemotePath;\n-use std::tempfile::mkdtemp;\n+use extra::tempfile::mkdtemp;\n \n+#[deriving(Eq)]\n pub enum Version {\n-    ExactRevision(float),\n-    SemVersion(semver::Version)\n+    ExactRevision(~str), // Should look like a m.n.(...).x\n+    SemanticVersion(semver::Version),\n+    NoVersion // user didn't specify a version\n }\n \n \n impl Ord for Version {\n     fn lt(&self, other: &Version) -> bool {\n         match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 < f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 < v2,\n+            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 < f2,\n+            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 < v2,\n             _ => false // incomparable, really\n         }\n     }\n     fn le(&self, other: &Version) -> bool {\n         match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 <= f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 <= v2,\n+            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 <= f2,\n+            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 <= v2,\n             _ => false // incomparable, really\n         }\n     }\n     fn ge(&self, other: &Version) -> bool {\n         match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 > f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 > v2,\n+            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 > f2,\n+            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 > v2,\n             _ => false // incomparable, really\n         }\n     }\n     fn gt(&self, other: &Version) -> bool {\n         match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 >= f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 >= v2,\n+            (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 >= f2,\n+            (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 >= v2,\n             _ => false // incomparable, really\n         }\n     }\n@@ -60,12 +62,25 @@ impl Ord for Version {\n impl ToStr for Version {\n     fn to_str(&self) -> ~str {\n         match *self {\n-            ExactRevision(ref n) => n.to_str(),\n-            SemVersion(ref v) => v.to_str()\n+            ExactRevision(ref n) => fmt!(\"%s\", n.to_str()),\n+            SemanticVersion(ref v) => fmt!(\"%s\", v.to_str()),\n+            NoVersion => ~\"\"\n         }\n     }\n }\n \n+impl Version {\n+    /// Fills in a bogus default version for NoVersion -- for use when\n+    /// injecting link_meta attributes\n+    fn to_str_nonempty(&self) -> ~str {\n+        match *self {\n+            NoVersion => ~\"0.1\",\n+            _ => self.to_str()\n+        }\n+    }\n+}\n+\n+\n pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n     match semver::parse(vers) {\n         Some(vers) => result::Ok(vers),\n@@ -87,11 +102,14 @@ pub fn try_getting_version(remote_path: &RemotePath) -> Option<Version> {\n         let outp  = run::process_output(\"git\", [~\"clone\", fmt!(\"https://%s\", remote_path.to_str()),\n                                                 tmp_dir.to_str()]);\n         if outp.status == 0 {\n-            debug!(\"Cloned it... ( %s, %s )\", str::from_bytes(outp.output), str::from_bytes(outp.error));\n+            debug!(\"Cloned it... ( %s, %s )\",\n+                   str::from_bytes(outp.output),\n+                   str::from_bytes(outp.error));\n             let mut output = None;\n             debug!(\"executing {git --git-dir=%s tag -l}\", tmp_dir.push(\".git\").to_str());\n-            let outp = run::process_output(\"git\", [fmt!(\"--git-dir=%s\", tmp_dir.push(\".git\").to_str()),\n-                                                           ~\"tag\", ~\"-l\"]);\n+            let outp = run::process_output(\"git\",\n+                                           [fmt!(\"--git-dir=%s\", tmp_dir.push(\".git\").to_str()),\n+                                            ~\"tag\", ~\"-l\"]);\n             let output_text = str::from_bytes(outp.output);\n             debug!(\"Full output: ( %s ) [%?]\", output_text, outp.status);\n             for output_text.each_split_char('\\n') |l| {\n@@ -111,30 +129,87 @@ pub fn try_getting_version(remote_path: &RemotePath) -> Option<Version> {\n         None\n     }\n }\n-    \n+\n+// Being lazy since we don't have a regexp library now\n+#[deriving(Eq)]\n+enum ParseState {\n+    Start,\n+    SawDigit,\n+    SawDot\n+}\n+\n fn try_parsing_version(s: &str) -> Option<Version> {\n     let s = s.trim();\n     debug!(\"Attempting to parse: %s\", s);\n-    match float::from_str(s) {\n-        Some(f) => {\n-            debug!(\"%s -> %f\", s, f);\n-            Some(ExactRevision(f)) // semver not handled yet\n+    let mut parse_state = Start;\n+    // I gave up on using external iterators (tjc)\n+    for str::to_chars(s).each() |&c| {\n+        if char::is_digit(c) {\n+            parse_state = SawDigit;\n         }\n-        None => {\n-            debug!(\"None!!\");\n-            None\n+        else if c == '.' && parse_state == SawDigit {\n+            parse_state = SawDot;\n         }\n+        else {\n+            return None;\n+        }\n+    }\n+    match parse_state {\n+        SawDigit => Some(ExactRevision(s.to_owned())),\n+        _        => None\n     }\n }\n \n-/// Placeholder\n-pub fn default_version() -> Version { ExactRevision(0.1) }\n-\n /// Just an approximation\n fn is_url_like(p: &RemotePath) -> bool {\n     let mut n = 0;\n     for p.to_str().each_split_char('/') |_| {\n         n += 1;\n     }\n     n > 2\n+}\n+\n+/// If s is of the form foo#bar, where bar is a valid version\n+/// number, return the prefix before the # and the version.\n+/// Otherwise, return None.\n+pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n+    // reject strings with multiple '#'s\n+    if { let mut i: uint = 0; for str::to_chars(s).each |&c| { if c == '#' { i += 1; } }; i > 1 } {\n+        return None;\n+    }\n+    match str::rfind_char(s, '#') {\n+        Some(i) => {\n+            debug!(\"in %s, i = %?\", s, i);\n+            let path = s.slice(0, i);\n+            debug!(\"path = %s\", path);\n+            // n.b. for now, assuming an exact revision is intended, not a SemVer\n+            Some((path, ExactRevision(s.slice(i + 1, s.len()).to_owned())))\n+        }\n+        None => {\n+            debug!(\"%s doesn't look like an explicit-version thing\", s);\n+            None\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_parse_version() {\n+    assert!(try_parsing_version(\"1.2\") == Some(ExactRevision(~\"1.2\")));\n+    assert!(try_parsing_version(\"1.0.17\") == Some(ExactRevision(~\"1.0.17\")));\n+    assert!(try_parsing_version(\"you're_a_kitty\") == None);\n+    assert!(try_parsing_version(\"42..1\") == None);\n+    assert!(try_parsing_version(\"17\") == Some(ExactRevision(~\"17\")));\n+    assert!(try_parsing_version(\".1.2.3\") == None);\n+    assert!(try_parsing_version(\"2.3.\") == None);\n+}\n+\n+#[test]\n+fn test_split_version() {\n+    let s = \"a/b/c#0.1\";\n+    debug!(\"== %? ==\", split_version(s));\n+    assert!(split_version(s) == Some((s.slice(0, 5), ExactRevision(~\"0.1\"))));\n+    assert!(split_version(\"a/b/c\") == None);\n+    let s = \"a#1.2\";\n+    assert!(split_version(s) == Some((s.slice(0, 1), ExactRevision(~\"1.2\"))));\n+    assert!(split_version(\"a#a#3.4\") == None);\n }\n\\ No newline at end of file"}]}