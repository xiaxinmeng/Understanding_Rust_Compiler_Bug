{"sha": "078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3OGUzZmQ0YmFiNjAxZjFmOGVjZmRjMWU3ZmRiNjEwM2U5ZTJiNmM=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-04-26T23:00:55Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-09-17T19:34:47Z"}, "message": "Add another case of fallback to () avoid breakage\n\nThis adds src/test/ui/never_type/fallback-closure-ret.rs as a test case which\nshowcases the failure mode fixed by this commit.", "tree": {"sha": "bdae5c17e2b1d6bc1e19ea19d967fd9dfe295c9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdae5c17e2b1d6bc1e19ea19d967fd9dfe295c9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "html_url": "https://github.com/rust-lang/rust/commit/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59dc2013e27adc5a251e81317331890d4015cdf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/59dc2013e27adc5a251e81317331890d4015cdf0", "html_url": "https://github.com/rust-lang/rust/commit/59dc2013e27adc5a251e81317331890d4015cdf0"}], "stats": {"total": 248, "additions": 239, "deletions": 9}, "files": [{"sha": "a12f7dc759c09aa7d5a415896568cb5d557041e1", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "patch": "@@ -1,5 +1,6 @@\n use crate::infer::InferCtxt;\n use crate::traits::Obligation;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, ToPredicate, Ty, WithConstness};\n@@ -73,6 +74,8 @@ pub trait TraitEngine<'tcx>: 'tcx {\n     }\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships>;\n }\n \n pub trait TraitEngineExt<'tcx> {"}, {"sha": "cc81ddbcc01b9806268b7db9f09121013a5d0c01", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "patch": "@@ -2090,3 +2090,16 @@ impl<'tcx> fmt::Debug for SymbolName<'tcx> {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n+\n+#[derive(Debug, Default, Copy, Clone)]\n+pub struct FoundRelationships {\n+    /// This is true if we identified that this Ty (`?T`) is found in a `?T: Foo`\n+    /// obligation, where:\n+    ///\n+    ///  * `Foo` is not `Sized`\n+    ///  * `(): Foo` may be satisfied\n+    pub self_in_trait: bool,\n+    /// This is true if we identified that this Ty (`?T`) is found in a `<_ as\n+    /// _>::AssocType = ?T`\n+    pub output: bool,\n+}"}, {"sha": "ec62ee400688ca2f62cae140fc32b1f40da8bf5e", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "patch": "@@ -7,16 +7,21 @@ use crate::traits::{\n     ChalkEnvironmentAndGoal, FulfillmentError, FulfillmentErrorCode, ObligationCause,\n     PredicateObligation, SelectionError, TraitEngine,\n };\n-use rustc_data_structures::fx::FxIndexSet;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_middle::ty::{self, Ty};\n \n pub struct FulfillmentContext<'tcx> {\n     obligations: FxIndexSet<PredicateObligation<'tcx>>,\n+\n+    relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n }\n \n impl FulfillmentContext<'tcx> {\n     crate fn new() -> Self {\n-        FulfillmentContext { obligations: FxIndexSet::default() }\n+        FulfillmentContext {\n+            obligations: FxIndexSet::default(),\n+            relationships: FxHashMap::default(),\n+        }\n     }\n }\n \n@@ -39,6 +44,8 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         assert!(!infcx.is_in_snapshot());\n         let obligation = infcx.resolve_vars_if_possible(obligation);\n \n+        super::relationships::update(self, infcx, &obligation);\n+\n         self.obligations.insert(obligation);\n     }\n \n@@ -146,4 +153,8 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.obligations.iter().cloned().collect()\n     }\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n+        &mut self.relationships\n+    }\n }"}, {"sha": "61462f23886ce650c6e911ad02857ff5fe549bee", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "patch": "@@ -1,4 +1,5 @@\n use crate::infer::{InferCtxt, TyOrConstInferVar};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n@@ -53,6 +54,9 @@ pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n+\n+    relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n+\n     // Should this fulfillment context register type-lives-for-region\n     // obligations on its parent infcx? In some cases, region\n     // obligations are either already known to hold (normalization) or\n@@ -97,6 +101,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            relationships: FxHashMap::default(),\n             register_region_obligations: true,\n             usable_in_snapshot: false,\n         }\n@@ -105,6 +110,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            relationships: FxHashMap::default(),\n             register_region_obligations: true,\n             usable_in_snapshot: true,\n         }\n@@ -113,6 +119,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            relationships: FxHashMap::default(),\n             register_region_obligations: false,\n             usable_in_snapshot: false,\n         }\n@@ -210,6 +217,8 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n         assert!(!infcx.is_in_snapshot() || self.usable_in_snapshot);\n \n+        super::relationships::update(self, infcx, &obligation);\n+\n         self.predicates\n             .register_obligation(PendingPredicateObligation { obligation, stalled_on: vec![] });\n     }\n@@ -265,6 +274,10 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.predicates.map_pending_obligations(|o| o.obligation.clone())\n     }\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n+        &mut self.relationships\n+    }\n }\n \n struct FulfillProcessor<'a, 'b, 'tcx> {"}, {"sha": "df2422048b9d7b90d60f97b7fc09f26b52675db8", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "patch": "@@ -15,6 +15,7 @@ mod object_safety;\n mod on_unimplemented;\n mod project;\n pub mod query;\n+pub(crate) mod relationships;\n mod select;\n mod specialize;\n mod structural_match;"}, {"sha": "7751dd84f4cac95d4b61f62d6706e67c7c23df16", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "patch": "@@ -0,0 +1,69 @@\n+use crate::infer::InferCtxt;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt;\n+use crate::traits::{ObligationCause, PredicateObligation};\n+use rustc_infer::traits::TraitEngine;\n+use rustc_middle::ty::{self, ToPredicate};\n+\n+pub(crate) fn update<'tcx, T>(\n+    engine: &mut T,\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    obligation: &PredicateObligation<'tcx>,\n+) where\n+    T: TraitEngine<'tcx>,\n+{\n+    // (*) binder skipped\n+    if let ty::PredicateKind::Trait(predicate) = obligation.predicate.kind().skip_binder() {\n+        if let Some(ty) =\n+            infcx.shallow_resolve(predicate.self_ty()).ty_vid().map(|t| infcx.root_var(t))\n+        {\n+            if infcx\n+                .tcx\n+                .lang_items()\n+                .sized_trait()\n+                .map_or(false, |st| st != predicate.trait_ref.def_id)\n+            {\n+                let new_self_ty = infcx.tcx.types.unit;\n+\n+                let trait_ref = ty::TraitRef {\n+                    substs: infcx\n+                        .tcx\n+                        .mk_substs_trait(new_self_ty, &predicate.trait_ref.substs[1..]),\n+                    ..predicate.trait_ref\n+                };\n+\n+                // Then contstruct a new obligation with Self = () added\n+                // to the ParamEnv, and see if it holds.\n+                let o = rustc_infer::traits::Obligation::new(\n+                    ObligationCause::dummy(),\n+                    obligation.param_env,\n+                    obligation\n+                        .predicate\n+                        .kind()\n+                        .map_bound(|_| {\n+                            // (*) binder moved here\n+                            ty::PredicateKind::Trait(ty::TraitPredicate {\n+                                trait_ref,\n+                                constness: predicate.constness,\n+                            })\n+                        })\n+                        .to_predicate(infcx.tcx),\n+                );\n+                // Don't report overflow errors. Otherwise equivalent to may_hold.\n+                if let Ok(result) = infcx.probe(|_| infcx.evaluate_obligation(&o)) {\n+                    if result.may_apply() {\n+                        engine.relationships().entry(ty).or_default().self_in_trait = true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    if let ty::PredicateKind::Projection(predicate) = obligation.predicate.kind().skip_binder() {\n+        // If the projection predicate (Foo::Bar == X) has X as a non-TyVid,\n+        // we need to make it into one.\n+        if let Some(vid) = predicate.ty.ty_vid() {\n+            debug!(\"relationship: {:?}.output = true\", vid);\n+            engine.relationships().entry(vid).or_default().output = true;\n+        }\n+    }\n+}"}, {"sha": "296e45337ed1035b3ed1868396f371ba6b045c86", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "patch": "@@ -11,9 +11,19 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     /// Performs type inference fallback, returning true if any fallback\n     /// occurs.\n     pub(super) fn type_inference_fallback(&self) -> bool {\n+        debug!(\n+            \"type-inference-fallback start obligations: {:#?}\",\n+            self.fulfillment_cx.borrow_mut().pending_obligations()\n+        );\n+\n         // All type checking constraints were added, try to fallback unsolved variables.\n         self.select_obligations_where_possible(false, |_| {});\n \n+        debug!(\n+            \"type-inference-fallback post selection obligations: {:#?}\",\n+            self.fulfillment_cx.borrow_mut().pending_obligations()\n+        );\n+\n         // Check if we have any unsolved varibales. If not, no need for fallback.\n         let unsolved_variables = self.unsolved_variables();\n         if unsolved_variables.is_empty() {\n@@ -251,6 +261,8 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     ) -> FxHashMap<Ty<'tcx>, Ty<'tcx>> {\n         debug!(\"calculate_diverging_fallback({:?})\", unsolved_variables);\n \n+        let relationships = self.fulfillment_cx.borrow_mut().relationships().clone();\n+\n         // Construct a coercion graph where an edge `A -> B` indicates\n         // a type variable is that is coerced\n         let coercion_graph = self.create_coercion_graph();\n@@ -334,21 +346,63 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             roots_reachable_from_non_diverging,\n         );\n \n+        debug!(\"inherited: {:#?}\", self.inh.fulfillment_cx.borrow_mut().pending_obligations());\n+        debug!(\"obligations: {:#?}\", self.fulfillment_cx.borrow_mut().pending_obligations());\n+        debug!(\"relationships: {:#?}\", relationships);\n+\n         // For each diverging variable, figure out whether it can\n         // reach a member of N. If so, it falls back to `()`. Else\n         // `!`.\n         let mut diverging_fallback = FxHashMap::default();\n+        diverging_fallback.reserve(diverging_vids.len());\n         for &diverging_vid in &diverging_vids {\n             let diverging_ty = self.tcx.mk_ty_var(diverging_vid);\n             let root_vid = self.infcx.root_var(diverging_vid);\n             let can_reach_non_diverging = coercion_graph\n                 .depth_first_search(root_vid)\n                 .any(|n| roots_reachable_from_non_diverging.visited(n));\n-            if can_reach_non_diverging {\n-                debug!(\"fallback to (): {:?}\", diverging_vid);\n+\n+            let mut relationship = ty::FoundRelationships { self_in_trait: false, output: false };\n+\n+            for (vid, rel) in relationships.iter() {\n+                if self.infcx.root_var(*vid) == root_vid {\n+                    relationship.self_in_trait |= rel.self_in_trait;\n+                    relationship.output |= rel.output;\n+                }\n+            }\n+\n+            if relationship.self_in_trait && relationship.output {\n+                // This case falls back to () to ensure that the code pattern in\n+                // src/test/ui/never_type/fallback-closure-ret.rs continues to\n+                // compile when never_type_fallback is enabled.\n+                //\n+                // This rule is not readily explainable from first principles,\n+                // but is rather intended as a patchwork fix to ensure code\n+                // which compiles before the stabilization of never type\n+                // fallback continues to work.\n+                //\n+                // Typically this pattern is encountered in a function taking a\n+                // closure as a parameter, where the return type of that closure\n+                // (checked by `relationship.output`) is expected to implement\n+                // some trait (checked by `relationship.self_in_trait`). This\n+                // can come up in non-closure cases too, so we do not limit this\n+                // rule to specifically `FnOnce`.\n+                //\n+                // When the closure's body is something like `panic!()`, the\n+                // return type would normally be inferred to `!`. However, it\n+                // needs to fall back to `()` in order to still compile, as the\n+                // trait is specifically implemented for `()` but not `!`.\n+                //\n+                // For details on the requirements for these relationships to be\n+                // set, see the relationship finding module in\n+                // compiler/rustc_trait_selection/src/traits/relationships.rs.\n+                debug!(\"fallback to () - found trait and projection: {:?}\", diverging_vid);\n+                diverging_fallback.insert(diverging_ty, self.tcx.types.unit);\n+            } else if can_reach_non_diverging {\n+                debug!(\"fallback to () - reached non-diverging: {:?}\", diverging_vid);\n                 diverging_fallback.insert(diverging_ty, self.tcx.types.unit);\n             } else {\n-                debug!(\"fallback to !: {:?}\", diverging_vid);\n+                debug!(\"fallback to ! - all diverging: {:?}\", diverging_vid);\n                 diverging_fallback.insert(diverging_ty, self.tcx.mk_diverging_default());\n             }\n         }\n@@ -369,10 +423,23 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n                 obligation.predicate.kind().no_bound_vars()\n             })\n             .filter_map(|atom| {\n-                if let ty::PredicateKind::Coerce(ty::CoercePredicate { a, b }) = atom {\n-                    let a_vid = self.root_vid(a)?;\n-                    let b_vid = self.root_vid(b)?;\n-                    Some((a_vid, b_vid))\n+                // We consider both subtyping and coercion to imply 'flow' from\n+                // some position in the code `a` to a different position `b`.\n+                // This is then used to determine which variables interact with\n+                // live code, and as such must fall back to `()` to preserve\n+                // soundness.\n+                //\n+                // In practice currently the two ways that this happens is\n+                // coercion and subtyping.\n+                let (a, b) = if let ty::PredicateKind::Coerce(ty::CoercePredicate { a, b }) = atom {\n+                    (a, b)\n+                } else if let ty::PredicateKind::Subtype(ty::SubtypePredicate {\n+                    a_is_expected: _,\n+                    a,\n+                    b,\n+                }) = atom\n+                {\n+                    (a, b)\n                 } else {\n                     return None;\n                 };"}, {"sha": "5c8ce48cbb0b6abf750b6bc99bebb778222399f8", "filename": "src/test/ui/never_type/fallback-closure-ret.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-ret.rs?ref=078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "patch": "@@ -0,0 +1,23 @@\n+// This test verifies that never type fallback preserves the following code in a\n+// compiling state. This pattern is fairly common in the wild, notably seen in\n+// wasmtime v0.16. Typically this is some closure wrapper that expects a\n+// collection of 'known' signatures, and -> ! is not included in that set.\n+//\n+// This test is specifically targeted by the unit type fallback when\n+// encountering a set of obligations like `?T: Foo` and `Trait::Projection =\n+// ?T`. In the code below, these are `R: Bar` and `Fn::Output = R`.\n+//\n+// revisions: nofallback fallback\n+// check-pass\n+\n+#![cfg_attr(fallback, feature(never_type_fallback))]\n+\n+trait Bar { }\n+impl Bar for () {  }\n+impl Bar for u32 {  }\n+\n+fn foo<R: Bar>(_: impl Fn() -> R) {}\n+\n+fn main() {\n+    foo(|| panic!());\n+}"}, {"sha": "af0577ac0609fcb24d9eaad0302819b6f5787771", "filename": "src/test/ui/never_type/fallback-closure-wrap.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs?ref=078e3fd4bab601f1f8ecfdc1e7fdb6103e9e2b6c", "patch": "@@ -0,0 +1,30 @@\n+// This is a minified example from Crater breakage observed when attempting to\n+// stabilize never type, nstoddard/webgl-gui @ 22f0169f.\n+//\n+// This particular test case currently fails as the inference to `()` rather\n+// than `!` happens as a result of an `as` cast, which is not currently tracked.\n+// Crater did not find many cases of this occuring, but it is included for\n+// awareness.\n+//\n+// revisions: nofallback fallback\n+//[nofallback] check-pass\n+//[fallback] check-fail\n+\n+#![cfg_attr(fallback, feature(never_type_fallback))]\n+\n+use std::marker::PhantomData;\n+\n+fn main() {\n+    let error = Closure::wrap(Box::new(move || {\n+        //[fallback]~^ ERROR type mismatch resolving\n+        panic!(\"Can't connect to server.\");\n+    }) as Box<dyn FnMut()>);\n+}\n+\n+struct Closure<T: ?Sized>(PhantomData<T>);\n+\n+impl<T: ?Sized> Closure<T> {\n+    fn wrap(data: Box<T>) -> Closure<T> {\n+        todo!()\n+    }\n+}"}]}