{"sha": "cd1ef390e731ed77b90b11b1f77e2c5ca641b261", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMWVmMzkwZTczMWVkNzdiOTBiMTFiMWY3N2UyYzVjYTY0MWIyNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-31T18:35:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-31T18:35:16Z"}, "message": "Auto merge of #67073 - ssomers:btree_navigation, r=cuviper\n\nBundle and document 6 BTreeMap navigation algorithms\n\n- Expose a function to step through trees, without necessarily extracting the KV pair, that helps future operations like drain/retain (as demonstrated in [this drain_filter implementation](https://github.com/ssomers/rust/compare/btree_navigation_v3...ssomers:btree_drain_filter?expand=1))\n- ~~Also aligns the implementation of the 2 x 3 iterators already using such navigation:~~\n  - ~~Delay the moment the K,V references are plucked from the tree, for the 4 iterators on immutable and owned maps, just for symmetry. The same had to be done to the two iterators for mutable maps in #58431.~~\n  - ~~Always explicitly use ptr::read to derive two handles from one handle. While the existing implementations for immutable maps (i.e. Range::next_unchecked and Range::next_back_unchecked) rely on implicit copying. There's no change in unsafe tags because these two functions were already (erroneously? prophetically?) tagged unsafe. I don't know whether they should be tagged unsafe. I guess they should be for mutable and owned maps, because you can change the map through one handle and leave the other handle invalid.~~\n  - Preserve the way two handles are (temporarily) derived from one handle: implementations for immutable maps (i.e. Range::next_unchecked and Range::next_back_unchecked) rely on copying (implicitly before, explicitly now) and the others do `ptr::read`.\n  - ~~I think the functions that support iterators on immutable trees (i.e. `Range::next_unchecked` and `Range::next_back_unchecked`) are erroneously tagged unsafe since you can already create multiple instances of such ranges, thus obtain multiple handles into the same tree. I did not change that but removed unsafe from the functions underneath.~~\n\nTested with miri in liballoc/tests/btree, except those that should_panic.\n\ncargo benchcmp the best of 3 samples of all btree benchmarks before and after this PR:\n```\nname                                           old1.txt ns/iter  new2.txt ns/iter  diff ns/iter  diff %  speedup\nbtree::map::find_rand_100                      17                17                           0   0.00%   x 1.00\nbtree::map::find_rand_10_000                   57                55                          -2  -3.51%   x 1.04\nbtree::map::find_seq_100                       17                17                           0   0.00%   x 1.00\nbtree::map::find_seq_10_000                    42                39                          -3  -7.14%   x 1.08\nbtree::map::first_and_last_0                   14                14                           0   0.00%   x 1.00\nbtree::map::first_and_last_100                 36                37                           1   2.78%   x 0.97\nbtree::map::first_and_last_10k                 52                52                           0   0.00%   x 1.00\nbtree::map::insert_rand_100                    34                34                           0   0.00%   x 1.00\nbtree::map::insert_rand_10_000                 34                34                           0   0.00%   x 1.00\nbtree::map::insert_seq_100                     46                46                           0   0.00%   x 1.00\nbtree::map::insert_seq_10_000                  90                89                          -1  -1.11%   x 1.01\nbtree::map::iter_1000                          2,811             2,771                      -40  -1.42%   x 1.01\nbtree::map::iter_100000                        360,635           355,995                 -4,640  -1.29%   x 1.01\nbtree::map::iter_20                            39                42                           3   7.69%   x 0.93\nbtree::map::iter_mut_1000                      2,662             2,864                      202   7.59%   x 0.93\nbtree::map::iter_mut_100000                    336,825           346,550                  9,725   2.89%   x 0.97\nbtree::map::iter_mut_20                        40                43                           3   7.50%   x 0.93\nbtree::set::build_and_clear                    4,184             3,994                     -190  -4.54%   x 1.05\nbtree::set::build_and_drop                     4,151             3,976                     -175  -4.22%   x 1.04\nbtree::set::build_and_into_iter                4,196             4,155                      -41  -0.98%   x 1.01\nbtree::set::build_and_pop_all                  5,176             5,241                       65   1.26%   x 0.99\nbtree::set::build_and_remove_all               6,868             6,903                       35   0.51%   x 0.99\nbtree::set::difference_random_100_vs_100       721               691                        -30  -4.16%   x 1.04\nbtree::set::difference_random_100_vs_10k       2,420             2,411                       -9  -0.37%   x 1.00\nbtree::set::difference_random_10k_vs_100       54,726            52,215                  -2,511  -4.59%   x 1.05\nbtree::set::difference_random_10k_vs_10k       164,384           170,256                  5,872   3.57%   x 0.97\nbtree::set::difference_staggered_100_vs_100    739               709                        -30  -4.06%   x 1.04\nbtree::set::difference_staggered_100_vs_10k    2,320             2,265                      -55  -2.37%   x 1.02\nbtree::set::difference_staggered_10k_vs_10k    68,020            70,246                   2,226   3.27%   x 0.97\nbtree::set::intersection_100_neg_vs_100_pos    23                24                           1   4.35%   x 0.96\nbtree::set::intersection_100_neg_vs_10k_pos    28                29                           1   3.57%   x 0.97\nbtree::set::intersection_100_pos_vs_100_neg    24                24                           0   0.00%   x 1.00\nbtree::set::intersection_100_pos_vs_10k_neg    28                28                           0   0.00%   x 1.00\nbtree::set::intersection_10k_neg_vs_100_pos    27                27                           0   0.00%   x 1.00\nbtree::set::intersection_10k_neg_vs_10k_pos    30                29                          -1  -3.33%   x 1.03\nbtree::set::intersection_10k_pos_vs_100_neg    27                28                           1   3.70%   x 0.96\nbtree::set::intersection_10k_pos_vs_10k_neg    29                29                           0   0.00%   x 1.00\nbtree::set::intersection_random_100_vs_100     592               572                        -20  -3.38%   x 1.03\nbtree::set::intersection_random_100_vs_10k     2,271             2,269                       -2  -0.09%   x 1.00\nbtree::set::intersection_random_10k_vs_100     2,301             2,333                       32   1.39%   x 0.99\nbtree::set::intersection_random_10k_vs_10k     147,879           150,148                  2,269   1.53%   x 0.98\nbtree::set::intersection_staggered_100_vs_100  622               632                         10   1.61%   x 0.98\nbtree::set::intersection_staggered_100_vs_10k  2,101             2,032                      -69  -3.28%   x 1.03\nbtree::set::intersection_staggered_10k_vs_10k  60,341            61,834                   1,493   2.47%   x 0.98\nbtree::set::is_subset_100_vs_100               417               426                          9   2.16%   x 0.98\nbtree::set::is_subset_100_vs_10k               1,281             1,324                       43   3.36%   x 0.97\nbtree::set::is_subset_10k_vs_100               2                 2                            0   0.00%   x 1.00\nbtree::set::is_subset_10k_vs_10k               41,054            41,612                     558   1.36%   x 0.99\n```\n\nr? cuviper", "tree": {"sha": "7d7c0009a57a5fcdc5be4fc02c25bceaffa03bd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d7c0009a57a5fcdc5be4fc02c25bceaffa03bd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd1ef390e731ed77b90b11b1f77e2c5ca641b261", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd1ef390e731ed77b90b11b1f77e2c5ca641b261", "html_url": "https://github.com/rust-lang/rust/commit/cd1ef390e731ed77b90b11b1f77e2c5ca641b261", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd1ef390e731ed77b90b11b1f77e2c5ca641b261/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5371ddf8c6937e90ffb279c24ac3e79d17833399", "url": "https://api.github.com/repos/rust-lang/rust/commits/5371ddf8c6937e90ffb279c24ac3e79d17833399", "html_url": "https://github.com/rust-lang/rust/commit/5371ddf8c6937e90ffb279c24ac3e79d17833399"}, {"sha": "3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0", "html_url": "https://github.com/rust-lang/rust/commit/3cf724d0c122f08ccbb3a9f77cb0ad888d8bebf0"}], "stats": {"total": 550, "additions": 314, "deletions": 236}, "files": [{"sha": "8eabc1773042f5e2d176ae640585bb2cbf18818d", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 42, "deletions": 236, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/cd1ef390e731ed77b90b11b1f77e2c5ca641b261/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1ef390e731ed77b90b11b1f77e2c5ca641b261/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=cd1ef390e731ed77b90b11b1f77e2c5ca641b261", "patch": "@@ -6,10 +6,11 @@ use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::marker::PhantomData;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, RangeBounds};\n-use core::{fmt, intrinsics, mem, ptr};\n+use core::{fmt, mem, ptr};\n \n use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n use super::search::{self, SearchResult::*};\n+use super::unwrap_unchecked;\n \n use Entry::*;\n use UnderflowResult::*;\n@@ -645,7 +646,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let front = first_leaf_edge(self.root.as_ref());\n+        let front = self.root.as_ref().first_leaf_edge();\n         front.right_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -706,7 +707,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let back = last_leaf_edge(self.root.as_ref());\n+        let back = self.root.as_ref().last_leaf_edge();\n         back.left_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -1073,7 +1074,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         self.ensure_root_is_owned();\n-        let mut cur_node = last_leaf_edge(self.root.as_mut()).into_node();\n+        let mut cur_node = self.root.as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1113,7 +1114,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 open_node.push(key, value, right_tree);\n \n                 // Go down to the right-most leaf again.\n-                cur_node = last_leaf_edge(open_node.forget_type()).into_node();\n+                cur_node = open_node.forget_type().last_leaf_edge().into_node();\n             }\n \n             self.length += 1;\n@@ -1411,10 +1412,8 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            unsafe {\n-                let (k, v) = self.range.next_unchecked();\n-                Some((k, v)) // coerce k from `&mut K` to `&K`\n-            }\n+            let (k, v) = unsafe { self.range.next_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n         }\n     }\n \n@@ -1434,7 +1433,8 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            unsafe { Some(self.range.next_back_unchecked()) }\n+            let (k, v) = unsafe { self.range.next_back_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n         }\n     }\n }\n@@ -1460,7 +1460,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n         let len = self.length;\n         mem::forget(self);\n \n-        IntoIter { front: first_leaf_edge(root1), back: last_leaf_edge(root2), length: len }\n+        IntoIter { front: root1.first_leaf_edge(), back: root2.last_leaf_edge(), length: len }\n     }\n }\n \n@@ -1475,9 +1475,9 @@ impl<K, V> Drop for IntoIter<K, V> {\n             }\n \n             if let Some(first_parent) = leaf_node.deallocate_and_ascend() {\n-                let mut cur_node = first_parent.into_node();\n-                while let Some(parent) = cur_node.deallocate_and_ascend() {\n-                    cur_node = parent.into_node()\n+                let mut cur_internal_node = first_parent.into_node();\n+                while let Some(parent) = cur_internal_node.deallocate_and_ascend() {\n+                    cur_internal_node = parent.into_node()\n                 }\n             }\n         }\n@@ -1490,37 +1490,10 @@ impl<K, V> Iterator for IntoIter<K, V> {\n \n     fn next(&mut self) -> Option<(K, V)> {\n         if self.length == 0 {\n-            return None;\n+            None\n         } else {\n             self.length -= 1;\n-        }\n-\n-        let handle = unsafe { ptr::read(&self.front) };\n-\n-        let mut cur_handle = match handle.right_kv() {\n-            Ok(kv) => {\n-                let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                self.front = kv.right_edge();\n-                return Some((k, v));\n-            }\n-            Err(last_edge) => unsafe {\n-                unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-            },\n-        };\n-\n-        loop {\n-            match cur_handle.right_kv() {\n-                Ok(kv) => {\n-                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                    self.front = first_leaf_edge(kv.right_edge().descend());\n-                    return Some((k, v));\n-                }\n-                Err(last_edge) => unsafe {\n-                    cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n-                },\n-            }\n+            Some(unsafe { self.front.next_unchecked() })\n         }\n     }\n \n@@ -1533,37 +1506,10 @@ impl<K, V> Iterator for IntoIter<K, V> {\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> {\n         if self.length == 0 {\n-            return None;\n+            None\n         } else {\n             self.length -= 1;\n-        }\n-\n-        let handle = unsafe { ptr::read(&self.back) };\n-\n-        let mut cur_handle = match handle.left_kv() {\n-            Ok(kv) => {\n-                let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                self.back = kv.left_edge();\n-                return Some((k, v));\n-            }\n-            Err(last_edge) => unsafe {\n-                unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-            },\n-        };\n-\n-        loop {\n-            match cur_handle.left_kv() {\n-                Ok(kv) => {\n-                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                    self.back = last_leaf_edge(kv.left_edge().descend());\n-                    return Some((k, v));\n-                }\n-                Err(last_edge) => unsafe {\n-                    cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n-                },\n-            }\n+            Some(unsafe { self.back.next_back_unchecked() })\n         }\n     }\n }\n@@ -1665,7 +1611,7 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_unchecked()) } }\n+        if self.is_empty() { None } else { unsafe { Some(self.next_unchecked()) } }\n     }\n \n     fn last(mut self) -> Option<(&'a K, &'a V)> {\n@@ -1708,73 +1654,25 @@ impl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n \n impl<'a, K, V> Range<'a, K, V> {\n-    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        let handle = self.front;\n-\n-        let mut cur_handle = match handle.right_kv() {\n-            Ok(kv) => {\n-                let ret = kv.into_kv();\n-                self.front = kv.right_edge();\n-                return ret;\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n+    fn is_empty(&self) -> bool {\n+        self.front == self.back\n+    }\n \n-        loop {\n-            match cur_handle.right_kv() {\n-                Ok(kv) => {\n-                    let ret = kv.into_kv();\n-                    self.front = first_leaf_edge(kv.right_edge().descend());\n-                    return ret;\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n+        self.front.next_unchecked()\n     }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_back_unchecked()) } }\n+        if self.is_empty() { None } else { Some(unsafe { self.next_back_unchecked() }) }\n     }\n }\n \n impl<'a, K, V> Range<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        let handle = self.back;\n-\n-        let mut cur_handle = match handle.left_kv() {\n-            Ok(kv) => {\n-                let ret = kv.into_kv();\n-                self.back = kv.left_edge();\n-                return ret;\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n-\n-        loop {\n-            match cur_handle.left_kv() {\n-                Ok(kv) => {\n-                    let ret = kv.into_kv();\n-                    self.back = last_leaf_edge(kv.left_edge().descend());\n-                    return ret;\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+        self.back.next_back_unchecked()\n     }\n }\n \n@@ -1796,10 +1694,8 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n         if self.is_empty() {\n             None\n         } else {\n-            unsafe {\n-                let (k, v) = self.next_unchecked();\n-                Some((k, v)) // coerce k from `&mut K` to `&K`\n-            }\n+            let (k, v) = unsafe { self.next_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n         }\n     }\n \n@@ -1814,81 +1710,28 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let handle = ptr::read(&self.front);\n-\n-        let mut cur_handle = match handle.right_kv() {\n-            Ok(kv) => {\n-                self.front = ptr::read(&kv).right_edge();\n-                // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                // so we have to do this last.\n-                return kv.into_kv_mut();\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n-\n-        loop {\n-            match cur_handle.right_kv() {\n-                Ok(kv) => {\n-                    self.front = first_leaf_edge(ptr::read(&kv).right_edge().descend());\n-                    // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                    // so we have to do this last.\n-                    return kv.into_kv_mut();\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+        self.front.next_unchecked()\n     }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.is_empty() { None } else { unsafe { Some(self.next_back_unchecked()) } }\n+        if self.is_empty() {\n+            None\n+        } else {\n+            let (k, v) = unsafe { self.next_back_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n+        }\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n-    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n-        let handle = ptr::read(&self.back);\n-\n-        let mut cur_handle = match handle.left_kv() {\n-            Ok(kv) => {\n-                self.back = ptr::read(&kv).left_edge();\n-                // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                // so we have to do this last.\n-                let (k, v) = kv.into_kv_mut();\n-                return (k, v); // coerce k from `&mut K` to `&K`\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n-\n-        loop {\n-            match cur_handle.left_kv() {\n-                Ok(kv) => {\n-                    self.back = last_leaf_edge(ptr::read(&kv).left_edge().descend());\n-                    // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                    // so we have to do this last.\n-                    let (k, v) = kv.into_kv_mut();\n-                    return (k, v); // coerce k from `&mut K` to `&K`\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+    unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+        self.back.next_back_unchecked()\n     }\n }\n \n@@ -1987,32 +1830,6 @@ where\n     }\n }\n \n-fn first_leaf_edge<BorrowType, K, V>(\n-    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n-    loop {\n-        match node.force() {\n-            Leaf(leaf) => return leaf.first_edge(),\n-            Internal(internal) => {\n-                node = internal.first_edge().descend();\n-            }\n-        }\n-    }\n-}\n-\n-fn last_leaf_edge<BorrowType, K, V>(\n-    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n-    loop {\n-        match node.force() {\n-            Leaf(leaf) => return leaf.last_edge(),\n-            Internal(internal) => {\n-                node = internal.last_edge().descend();\n-            }\n-        }\n-    }\n-}\n-\n fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n@@ -2116,17 +1933,6 @@ where\n     }\n }\n \n-#[inline(always)]\n-unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n-    val.unwrap_or_else(|| {\n-        if cfg!(debug_assertions) {\n-            panic!(\"'unchecked' unwrap on None in BTreeMap\");\n-        } else {\n-            intrinsics::unreachable();\n-        }\n-    })\n-}\n-\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n@@ -2153,8 +1959,8 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter {\n             range: Range {\n-                front: first_leaf_edge(self.root.as_ref()),\n-                back: last_leaf_edge(self.root.as_ref()),\n+                front: self.root.as_ref().first_leaf_edge(),\n+                back: self.root.as_ref().last_leaf_edge(),\n             },\n             length: self.length,\n         }\n@@ -2187,8 +1993,8 @@ impl<K, V> BTreeMap<K, V> {\n         let root2 = unsafe { ptr::read(&root1) };\n         IterMut {\n             range: RangeMut {\n-                front: first_leaf_edge(root1),\n-                back: last_leaf_edge(root2),\n+                front: root1.first_leaf_edge(),\n+                back: root2.last_leaf_edge(),\n                 _marker: PhantomData,\n             },\n             length: self.length,\n@@ -2691,7 +2497,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n-                let to_remove = first_leaf_edge(internal.right_edge().descend()).right_kv().ok();\n+                let to_remove = internal.right_edge().descend().first_leaf_edge().right_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n                 let (hole, key, val) = to_remove.remove();"}, {"sha": "fb5825ee21a9e4459551e269026ae2208a59168c", "filename": "src/liballoc/collections/btree/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd1ef390e731ed77b90b11b1f77e2c5ca641b261/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1ef390e731ed77b90b11b1f77e2c5ca641b261/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=cd1ef390e731ed77b90b11b1f77e2c5ca641b261", "patch": "@@ -1,4 +1,5 @@\n pub mod map;\n+mod navigate;\n mod node;\n mod search;\n pub mod set;\n@@ -11,3 +12,14 @@ trait Recover<Q: ?Sized> {\n     fn take(&mut self, key: &Q) -> Option<Self::Key>;\n     fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;\n }\n+\n+#[inline(always)]\n+pub unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n+    val.unwrap_or_else(|| {\n+        if cfg!(debug_assertions) {\n+            panic!(\"'unchecked' unwrap on None in BTreeMap\");\n+        } else {\n+            core::intrinsics::unreachable();\n+        }\n+    })\n+}"}, {"sha": "653218972314f374e0cc87bc3d513b74eacbcfc4", "filename": "src/liballoc/collections/btree/navigate.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/cd1ef390e731ed77b90b11b1f77e2c5ca641b261/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1ef390e731ed77b90b11b1f77e2c5ca641b261/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=cd1ef390e731ed77b90b11b1f77e2c5ca641b261", "patch": "@@ -0,0 +1,244 @@\n+use core::ptr;\n+\n+use super::node::{marker, ForceResult::*, Handle, NodeRef};\n+use super::unwrap_unchecked;\n+\n+macro_rules! def_next {\n+    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n+        /// Given a leaf edge handle into an immutable tree, returns a handle to the next\n+        /// leaf edge and references to the key and value between these edges.\n+        /// Unsafe because the caller must ensure that the given leaf edge has a successor.\n+        unsafe fn $name <'a, K: 'a, V: 'a>(\n+            leaf_edge: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+        ) -> (Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>, &'a K, &'a V) {\n+            let mut cur_handle = match leaf_edge.$next_kv() {\n+                Ok(leaf_kv) => {\n+                    let (k, v) = leaf_kv.into_kv();\n+                    let next_leaf_edge = leaf_kv.$next_edge();\n+                    return (next_leaf_edge, k, v);\n+                }\n+                Err(last_edge) => {\n+                    let next_level = last_edge.into_node().ascend().ok();\n+                    unwrap_unchecked(next_level)\n+                }\n+            };\n+\n+            loop {\n+                cur_handle = match cur_handle.$next_kv() {\n+                    Ok(internal_kv) => {\n+                        let (k, v) = internal_kv.into_kv();\n+                        let next_internal_edge = internal_kv.$next_edge();\n+                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n+                        return (next_leaf_edge, k, v);\n+                    }\n+                    Err(last_edge) => {\n+                        let next_level = last_edge.into_node().ascend().ok();\n+                        unwrap_unchecked(next_level)\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! def_next_mut {\n+    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n+        /// Given a leaf edge handle into a mutable tree, returns handles to the next\n+        /// leaf edge and to the KV between these edges.\n+        /// Unsafe for two reasons:\n+        /// - the caller must ensure that the given leaf edge has a successor;\n+        /// - both returned handles represent mutable references into the same tree\n+        ///   that can easily invalidate each other, even on immutable use.\n+        unsafe fn $name <'a, K: 'a, V: 'a>(\n+            leaf_edge: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+        ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+              Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>) {\n+            let mut cur_handle = match leaf_edge.$next_kv() {\n+                Ok(leaf_kv) => {\n+                    let next_leaf_edge = ptr::read(&leaf_kv).$next_edge();\n+                    return (next_leaf_edge, leaf_kv.forget_node_type());\n+                }\n+                Err(last_edge) => {\n+                    let next_level = last_edge.into_node().ascend().ok();\n+                    unwrap_unchecked(next_level)\n+                }\n+            };\n+\n+            loop {\n+                cur_handle = match cur_handle.$next_kv() {\n+                    Ok(internal_kv) => {\n+                        let next_internal_edge = ptr::read(&internal_kv).$next_edge();\n+                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n+                        return (next_leaf_edge, internal_kv.forget_node_type());\n+                    }\n+                    Err(last_edge) => {\n+                        let next_level = last_edge.into_node().ascend().ok();\n+                        unwrap_unchecked(next_level)\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! def_next_dealloc {\n+    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n+        /// Given a leaf edge handle into an owned tree, returns a handle to the next\n+        /// leaf edge and the key and value between these edges, while deallocating\n+        /// any node left behind.\n+        /// Unsafe for two reasons:\n+        /// - the caller must ensure that the given leaf edge has a successor;\n+        /// - the node pointed at by the given handle, and its ancestors, may be deallocated,\n+        ///   while the reference to those nodes in the surviving ancestors is left dangling;\n+        ///   thus using the returned handle is dangerous.\n+        unsafe fn $name <K, V>(\n+            leaf_edge: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+        ) -> (Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>, K, V) {\n+            let mut cur_handle = match leaf_edge.$next_kv() {\n+                Ok(leaf_kv) => {\n+                    let k = ptr::read(leaf_kv.reborrow().into_kv().0);\n+                    let v = ptr::read(leaf_kv.reborrow().into_kv().1);\n+                    let next_leaf_edge = leaf_kv.$next_edge();\n+                    return (next_leaf_edge, k, v);\n+                }\n+                Err(last_edge) => {\n+                    unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n+                }\n+            };\n+\n+            loop {\n+                cur_handle = match cur_handle.$next_kv() {\n+                    Ok(internal_kv) => {\n+                        let k = ptr::read(internal_kv.reborrow().into_kv().0);\n+                        let v = ptr::read(internal_kv.reborrow().into_kv().1);\n+                        let next_internal_edge = internal_kv.$next_edge();\n+                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n+                        return (next_leaf_edge, k, v);\n+                    }\n+                    Err(last_edge) => {\n+                        unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+def_next! {unsafe fn next_unchecked: right_kv right_edge first_leaf_edge}\n+def_next! {unsafe fn next_back_unchecked: left_kv left_edge last_leaf_edge}\n+def_next_mut! {unsafe fn next_unchecked_mut: right_kv right_edge first_leaf_edge}\n+def_next_mut! {unsafe fn next_back_unchecked_mut: left_kv left_edge last_leaf_edge}\n+def_next_dealloc! {unsafe fn next_unchecked_deallocating: right_kv right_edge first_leaf_edge}\n+def_next_dealloc! {unsafe fn next_back_unchecked_deallocating: left_kv left_edge last_leaf_edge}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Moves the leaf edge handle to the next leaf edge and returns references to the\n+    /// key and value in between.\n+    /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n+    pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n+        let (next_edge, k, v) = next_unchecked(*self);\n+        *self = next_edge;\n+        (k, v)\n+    }\n+\n+    /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n+    /// key and value in between.\n+    /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n+    pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n+        let (next_edge, k, v) = next_back_unchecked(*self);\n+        *self = next_edge;\n+        (k, v)\n+    }\n+}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Moves the leaf edge handle to the next leaf edge and returns references to the\n+    /// key and value in between.\n+    /// Unsafe for two reasons:\n+    /// - The caller must ensure that the leaf edge is not the last one in the tree.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+        let (next_edge, kv) = next_unchecked_mut(ptr::read(self));\n+        *self = next_edge;\n+        // Doing the descend (and perhaps another move) invalidates the references\n+        // returned by `into_kv_mut`, so we have to do this last.\n+        kv.into_kv_mut()\n+    }\n+\n+    /// Moves the leaf edge handle to the previous leaf and returns references to the\n+    /// key and value in between.\n+    /// Unsafe for two reasons:\n+    /// - The caller must ensure that the leaf edge is not the first one in the tree.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+        let (next_edge, kv) = next_back_unchecked_mut(ptr::read(self));\n+        *self = next_edge;\n+        // Doing the descend (and perhaps another move) invalidates the references\n+        // returned by `into_kv_mut`, so we have to do this last.\n+        kv.into_kv_mut()\n+    }\n+}\n+\n+impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n+    /// Moves the leaf edge handle to the next leaf edge and returns the key and value\n+    /// in between, while deallocating any node left behind.\n+    /// Unsafe for three reasons:\n+    /// - The caller must ensure that the leaf edge is not the last one in the tree\n+    ///   and is not a handle previously resulting from counterpart `next_back_unchecked`.\n+    /// - If the leaf edge is the last edge of a node, that node and possibly ancestors\n+    ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n+    ///   is left dangling; thus further use of the leaf edge handle is dangerous.\n+    ///   It is, however, safe to call this method again on the updated handle.\n+    ///   if the two preconditions above hold.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n+        let (next_edge, k, v) = next_unchecked_deallocating(ptr::read(self));\n+        *self = next_edge;\n+        (k, v)\n+    }\n+\n+    /// Moves the leaf edge handle to the previous leaf edge and returns the key\n+    /// and value in between, while deallocating any node left behind.\n+    /// Unsafe for three reasons:\n+    /// - The caller must ensure that the leaf edge is not the first one in the tree\n+    ///   and is not a handle previously resulting from counterpart `next_unchecked`.\n+    /// - If the lead edge is the first edge of a node, that node and possibly ancestors\n+    ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n+    ///   is left dangling; thus further use of the leaf edge handle is dangerous.\n+    ///   It is, however, safe to call this method again on the updated handle.\n+    ///   if the two preconditions above hold.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n+        let (next_edge, k, v) = next_back_unchecked_deallocating(ptr::read(self));\n+        *self = next_edge;\n+        (k, v)\n+    }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Returns the leftmost leaf edge in or underneath a node - in other words, the edge\n+    /// you need first when navigating forward (or last when navigating backward).\n+    #[inline]\n+    pub fn first_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+        let mut node = self;\n+        loop {\n+            match node.force() {\n+                Leaf(leaf) => return leaf.first_edge(),\n+                Internal(internal) => node = internal.first_edge().descend(),\n+            }\n+        }\n+    }\n+\n+    /// Returns the rightmost leaf edge in or underneath a node - in other words, the edge\n+    /// you need last when navigating forward (or first when navigating backward).\n+    #[inline]\n+    pub fn last_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+        let mut node = self;\n+        loop {\n+            match node.force() {\n+                Leaf(leaf) => return leaf.last_edge(),\n+                Internal(internal) => node = internal.last_edge().descend(),\n+            }\n+        }\n+    }\n+}"}, {"sha": "e4123c9a20b196f83f030c0fd981423a7c6894de", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd1ef390e731ed77b90b11b1f77e2c5ca641b261/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1ef390e731ed77b90b11b1f77e2c5ca641b261/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=cd1ef390e731ed77b90b11b1f77e2c5ca641b261", "patch": "@@ -1418,6 +1418,22 @@ unsafe fn move_edges<K, V>(\n     dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n }\n \n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::KV> {\n+    pub fn forget_node_type(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n+        unsafe { Handle::new_kv(self.node.forget_type(), self.idx) }\n+    }\n+}\n+\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV> {\n+    pub fn forget_node_type(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n+        unsafe { Handle::new_kv(self.node.forget_type(), self.idx) }\n+    }\n+}\n+\n impl<BorrowType, K, V, HandleType>\n     Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType>\n {"}]}