{"sha": "5fa55781bd77f7a9fbdb3af8fa4e1b0cd0b1cf06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYTU1NzgxYmQ3N2Y3YTlmYmRiM2FmOGZhNGUxYjBjZDBiMWNmMDY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-07-25T20:32:59Z"}, "committer": {"name": "Jan-Erik Rediger", "email": "janerik@fnordig.de", "date": "2016-07-29T08:29:59Z"}, "message": "test: Remove the execution-engine test\n\nWe don't actually officially support this at all, and the execution engine\nsupport in LLVM we've had to gut as it's not compiling on MinGW, so just delete\nthis test for now.", "tree": {"sha": "0ae46e093535ccc5039703f31fdd3891d8146ed2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ae46e093535ccc5039703f31fdd3891d8146ed2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fa55781bd77f7a9fbdb3af8fa4e1b0cd0b1cf06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa55781bd77f7a9fbdb3af8fa4e1b0cd0b1cf06", "html_url": "https://github.com/rust-lang/rust/commit/5fa55781bd77f7a9fbdb3af8fa4e1b0cd0b1cf06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fa55781bd77f7a9fbdb3af8fa4e1b0cd0b1cf06/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "badboy", "id": 2129, "node_id": "MDQ6VXNlcjIxMjk=", "avatar_url": "https://avatars.githubusercontent.com/u/2129?v=4", "gravatar_id": "", "url": "https://api.github.com/users/badboy", "html_url": "https://github.com/badboy", "followers_url": "https://api.github.com/users/badboy/followers", "following_url": "https://api.github.com/users/badboy/following{/other_user}", "gists_url": "https://api.github.com/users/badboy/gists{/gist_id}", "starred_url": "https://api.github.com/users/badboy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/badboy/subscriptions", "organizations_url": "https://api.github.com/users/badboy/orgs", "repos_url": "https://api.github.com/users/badboy/repos", "events_url": "https://api.github.com/users/badboy/events{/privacy}", "received_events_url": "https://api.github.com/users/badboy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8f76661f13620f075626d27f94750ea94d6cf2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f76661f13620f075626d27f94750ea94d6cf2e", "html_url": "https://github.com/rust-lang/rust/commit/e8f76661f13620f075626d27f94750ea94d6cf2e"}], "stats": {"total": 303, "additions": 0, "deletions": 303}, "files": [{"sha": "4c818cd99e2d795561535831d6653e323c54f113", "filename": "src/test/run-make/execution-engine/Makefile", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e8f76661f13620f075626d27f94750ea94d6cf2e/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/e8f76661f13620f075626d27f94750ea94d6cf2e/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile?ref=e8f76661f13620f075626d27f94750ea94d6cf2e", "patch": "@@ -1,21 +0,0 @@\n--include ../tools.mk\n-\n-# FIXME: ignore freebsd\n-# This is a basic test of LLVM ExecutionEngine functionality using compiled\n-# Rust code built using the `rustc` crate.\n-\n-ifeq ($(filter executionengine,$(LLVM_COMPONENTS)),executionengine)\n-\n-ifneq ($(shell uname),FreeBSD)\n-all:\n-\t$(RUSTC) test.rs\n-\t$(call RUN,test $(RUSTC))\n-else\n-all:\n-\n-endif\n-\n-else\n-all:\n-\n-endif"}, {"sha": "b58295d47f21d2633160a79b350e378db8b43d09", "filename": "src/test/run-make/execution-engine/test.rs", "status": "removed", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/e8f76661f13620f075626d27f94750ea94d6cf2e/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f76661f13620f075626d27f94750ea94d6cf2e/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=e8f76661f13620f075626d27f94750ea94d6cf2e", "patch": "@@ -1,282 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rustc_private)]\n-#![feature(libc)]\n-\n-extern crate libc;\n-extern crate rustc;\n-extern crate rustc_driver;\n-extern crate rustc_lint;\n-extern crate rustc_llvm as llvm;\n-extern crate rustc_metadata;\n-extern crate rustc_resolve;\n-extern crate rustc_errors;\n-extern crate rustc_errors as errors;\n-extern crate rustc_trans;\n-#[macro_use] extern crate syntax;\n-\n-use std::ffi::{CStr, CString};\n-use std::mem::transmute;\n-use std::path::PathBuf;\n-use std::rc::Rc;\n-use std::thread::Builder;\n-\n-use rustc::dep_graph::DepGraph;\n-use rustc::hir::map as ast_map;\n-use rustc::middle::cstore::LinkagePreference;\n-use rustc::ty;\n-use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n-use rustc::session::build_session;\n-use rustc_driver::{driver, abort_on_err};\n-use rustc_resolve::MakeGlobMap;\n-use rustc_metadata::cstore::CStore;\n-use rustc_trans::ModuleSource;\n-use libc::c_void;\n-\n-use rustc_errors::registry::Registry;\n-\n-fn main() {\n-    // Currently trips an assertion on i686-msvc, presumably because the support\n-    // in LLVM is a little young.\n-    if cfg!(target_env = \"msvc\") && cfg!(target_arch = \"x86\") {\n-        return\n-    }\n-\n-    let program = r#\"\n-    #[no_mangle]\n-    pub static TEST_STATIC: i32 = 42;\n-    \"#;\n-\n-    let program2 = r#\"\n-    #[no_mangle]\n-    pub fn test_add(a: i32, b: i32) -> i32 { a + b }\n-    \"#;\n-\n-    let mut path = match std::env::args().nth(2) {\n-        Some(path) => PathBuf::from(&path),\n-        None => panic!(\"missing rustc path\")\n-    };\n-\n-    // Remove two segments from rustc path to get sysroot.\n-    path.pop();\n-    path.pop();\n-\n-    let mut ee = ExecutionEngine::new(program, path);\n-\n-    let test_static = match ee.get_global(\"TEST_STATIC\") {\n-        Some(g) => g as *const i32,\n-        None => panic!(\"failed to get global\")\n-    };\n-\n-    assert_eq!(unsafe { *test_static }, 42);\n-\n-    ee.add_module(program2);\n-\n-    let test_add: fn(i32, i32) -> i32;\n-\n-    test_add = match ee.get_function(\"test_add\") {\n-        Some(f) => unsafe { transmute(f) },\n-        None => panic!(\"failed to get function\")\n-    };\n-\n-    assert_eq!(test_add(1, 2), 3);\n-}\n-\n-struct ExecutionEngine {\n-    ee: llvm::ExecutionEngineRef,\n-    modules: Vec<llvm::ModuleRef>,\n-    sysroot: PathBuf,\n-}\n-\n-impl ExecutionEngine {\n-    pub fn new(program: &str, sysroot: PathBuf) -> ExecutionEngine {\n-        let (llmod, deps) = compile_program(program, sysroot.clone())\n-            .expect(\"failed to compile program\");\n-\n-        let ee = unsafe { llvm::LLVMBuildExecutionEngine(llmod) };\n-\n-        if ee.is_null() {\n-            panic!(\"Failed to create ExecutionEngine: {}\", llvm_error());\n-        }\n-\n-        let ee = ExecutionEngine{\n-            ee: ee,\n-            modules: vec![llmod],\n-            sysroot: sysroot,\n-        };\n-\n-        ee.load_deps(&deps);\n-        ee\n-    }\n-\n-    pub fn add_module(&mut self, program: &str) {\n-        let (llmod, deps) = compile_program(program, self.sysroot.clone())\n-            .expect(\"failed to compile program in add_module\");\n-\n-        unsafe { llvm::LLVMExecutionEngineAddModule(self.ee, llmod); }\n-\n-        self.modules.push(llmod);\n-        self.load_deps(&deps);\n-    }\n-\n-    /// Returns a raw pointer to the named function.\n-    pub fn get_function(&mut self, name: &str) -> Option<*const c_void> {\n-        let s = CString::new(name.as_bytes()).unwrap();\n-\n-        for &m in &self.modules {\n-            let fv = unsafe { llvm::LLVMGetNamedFunction(m, s.as_ptr()) };\n-\n-            if !fv.is_null() {\n-                let fp = unsafe { llvm::LLVMGetPointerToGlobal(self.ee, fv) };\n-\n-                assert!(!fp.is_null());\n-                return Some(fp);\n-            }\n-        }\n-        None\n-    }\n-\n-    /// Returns a raw pointer to the named global item.\n-    pub fn get_global(&mut self, name: &str) -> Option<*const c_void> {\n-        let s = CString::new(name.as_bytes()).unwrap();\n-\n-        for &m in &self.modules {\n-            let gv = unsafe { llvm::LLVMGetNamedGlobal(m, s.as_ptr()) };\n-\n-            if !gv.is_null() {\n-                let gp = unsafe { llvm::LLVMGetPointerToGlobal(self.ee, gv) };\n-\n-                assert!(!gp.is_null());\n-                return Some(gp);\n-            }\n-        }\n-        None\n-    }\n-\n-    /// Loads all dependencies of compiled code.\n-    /// Expects a series of paths to dynamic library files.\n-    fn load_deps(&self, deps: &[PathBuf]) {\n-        for path in deps {\n-            let s = match path.as_os_str().to_str() {\n-                Some(s) => s,\n-                None => panic!(\n-                    \"Could not convert crate path to UTF-8 string: {:?}\", path)\n-            };\n-            let cs = CString::new(s).unwrap();\n-\n-            let res = unsafe { llvm::LLVMRustLoadDynamicLibrary(cs.as_ptr()) };\n-\n-            if res == 0 {\n-                panic!(\"Failed to load crate {:?}: {}\",\n-                    path.display(), llvm_error());\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for ExecutionEngine {\n-    fn drop(&mut self) {\n-        unsafe { llvm::LLVMDisposeExecutionEngine(self.ee) };\n-    }\n-}\n-\n-/// Returns last error from LLVM wrapper code.\n-fn llvm_error() -> String {\n-    String::from_utf8_lossy(\n-        unsafe { CStr::from_ptr(llvm::LLVMRustGetLastError()).to_bytes() })\n-        .into_owned()\n-}\n-\n-fn build_exec_options(sysroot: PathBuf) -> Options {\n-    let mut opts = basic_options();\n-\n-    // librustc derives sysroot from the executable name.\n-    // Since we are not rustc, we must specify it.\n-    opts.maybe_sysroot = Some(sysroot);\n-\n-    // Prefer faster build time\n-    opts.optimize = config::OptLevel::No;\n-\n-    // Don't require a `main` function\n-    opts.crate_types = vec![config::CrateTypeDylib];\n-\n-    opts\n-}\n-\n-/// Compiles input up to phase 4, translation to LLVM.\n-///\n-/// Returns the LLVM `ModuleRef` and a series of paths to dynamic libraries\n-/// for crates used in the given input.\n-fn compile_program(input: &str, sysroot: PathBuf)\n-                   -> Option<(llvm::ModuleRef, Vec<PathBuf>)> {\n-    let input = Input::Str {\n-        name: driver::anon_src(),\n-        input: input.to_string(),\n-    };\n-    let thread = Builder::new().name(\"compile_program\".to_string());\n-\n-    let handle = thread.spawn(move || {\n-        let opts = build_exec_options(sysroot);\n-        let dep_graph = DepGraph::new(opts.build_dep_graph());\n-        let cstore = Rc::new(CStore::new(&dep_graph));\n-        let sess = build_session(opts,\n-                                 &dep_graph,\n-                                 None,\n-                                 Registry::new(&rustc::DIAGNOSTICS),\n-                                 cstore.clone());\n-        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-        let cfg = build_configuration(&sess);\n-\n-        let id = \"input\".to_string();\n-\n-        let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n-\n-        let driver::ExpansionResult { defs, analysis, resolutions, mut hir_forest, .. } = {\n-            driver::phase_2_configure_and_expand(\n-                &sess, &cstore, krate, &id, None, MakeGlobMap::No, |_| Ok(()),\n-            ).expect(\"phase_2 returned `None`\")\n-        };\n-\n-        let arenas = ty::CtxtArenas::new();\n-        let ast_map = ast_map::map_crate(&mut hir_forest, defs);\n-\n-        abort_on_err(driver::phase_3_run_analysis_passes(\n-            &sess, ast_map, analysis, resolutions, &arenas, &id,\n-            |tcx, mir_map, analysis, _| {\n-\n-            let trans = driver::phase_4_translate_to_llvm(tcx, mir_map.unwrap(), analysis);\n-\n-            let crates = tcx.sess.cstore.used_crates(LinkagePreference::RequireDynamic);\n-\n-            // Collect crates used in the session.\n-            // Reverse order finds dependencies first.\n-            let deps = crates.into_iter().rev()\n-                .filter_map(|(_, p)| p).collect();\n-\n-            assert_eq!(trans.modules.len(), 1);\n-            let llmod = match trans.modules[0].source {\n-                ModuleSource::Preexisting(_) => unimplemented!(),\n-                ModuleSource::Translated(llvm) => llvm.llmod,\n-            };\n-\n-            // Workaround because raw pointers do not impl Send\n-            let modp = llmod as usize;\n-\n-            (modp, deps)\n-        }), &sess)\n-    }).unwrap();\n-\n-    match handle.join() {\n-        Ok((llmod, deps)) => Some((llmod as llvm::ModuleRef, deps)),\n-        Err(_) => None\n-    }\n-}"}]}