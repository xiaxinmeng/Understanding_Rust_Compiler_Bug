{"sha": "727a565f1e65c415b018f26d878a0d3ebdc9e3ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyN2E1NjVmMWU2NWM0MTViMDE4ZjI2ZDg3OGEwZDNlYmRjOWUzZWE=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2013-03-27T19:50:57Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2013-03-27T22:41:58Z"}, "message": "librustc: Move inline asm stuff to different mod.", "tree": {"sha": "938dcff9f30e406d09fdcf03a97e3815f25a1db6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/938dcff9f30e406d09fdcf03a97e3815f25a1db6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/727a565f1e65c415b018f26d878a0d3ebdc9e3ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/727a565f1e65c415b018f26d878a0d3ebdc9e3ea", "html_url": "https://github.com/rust-lang/rust/commit/727a565f1e65c415b018f26d878a0d3ebdc9e3ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/727a565f1e65c415b018f26d878a0d3ebdc9e3ea/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30b1957cd447f91d206513d909f564d270410e82", "url": "https://api.github.com/repos/rust-lang/rust/commits/30b1957cd447f91d206513d909f564d270410e82", "html_url": "https://github.com/rust-lang/rust/commit/30b1957cd447f91d206513d909f564d270410e82"}], "stats": {"total": 233, "additions": 133, "deletions": 100}, "files": [{"sha": "ceb1b7ed1ecdaef2b80fed0296ccf211d3b484b5", "filename": "src/librustc/middle/trans/asm.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/727a565f1e65c415b018f26d878a0d3ebdc9e3ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727a565f1e65c415b018f26d878a0d3ebdc9e3ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=727a565f1e65c415b018f26d878a0d3ebdc9e3ea", "patch": "@@ -0,0 +1,130 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+# Translation of inline assembly.\n+*/\n+\n+use core::prelude::*;\n+\n+use lib;\n+use middle::trans::build::*;\n+use middle::trans::callee;\n+use middle::trans::common::*;\n+use middle::ty;\n+\n+use syntax::ast;\n+use syntax::ast::*;\n+\n+// Take an inline assembly expression and splat it out via LLVM\n+pub fn trans_inline_asm(bcx: block, asm: @~str, ins: &[(@~str, @expr)], outs: &[(@~str, @expr)],\n+                        clobs: @~str, volatile: bool, alignstack: bool) -> block {\n+\n+    let mut bcx = bcx;\n+    let mut constraints = ~[];\n+    let mut cleanups = ~[];\n+    let mut aoutputs = ~[];\n+\n+    // Prepare the output operands\n+    let outputs = do outs.map |&(c, out)| {\n+        constraints.push(copy *c);\n+\n+        let aoutty = ty::arg {\n+            mode: ast::expl(ast::by_copy),\n+            ty: expr_ty(bcx, out)\n+        };\n+        aoutputs.push(unpack_result!(bcx, {\n+            callee::trans_arg_expr(bcx, aoutty, out, &mut cleanups, None, callee::DontAutorefArg)\n+        }));\n+\n+        let e = match out.node {\n+            ast::expr_addr_of(_, e) => e,\n+            _ => fail!(~\"Expression must be addr of\")\n+        };\n+\n+        let outty = ty::arg {\n+            mode: ast::expl(ast::by_copy),\n+            ty: expr_ty(bcx, e)\n+        };\n+\n+        unpack_result!(bcx, {\n+            callee::trans_arg_expr(bcx, outty, e, &mut cleanups, None, callee::DontAutorefArg)\n+        })\n+\n+    };\n+\n+    for cleanups.each |c| {\n+        revoke_clean(bcx, *c);\n+    }\n+    cleanups.clear();\n+\n+    // Now the input operands\n+    let inputs = do ins.map |&(c, in)| {\n+        constraints.push(copy *c);\n+\n+        let inty = ty::arg {\n+            mode: ast::expl(ast::by_copy),\n+            ty: expr_ty(bcx, in)\n+        };\n+\n+        unpack_result!(bcx, {\n+            callee::trans_arg_expr(bcx, inty, in, &mut cleanups, None, callee::DontAutorefArg)\n+        })\n+\n+    };\n+\n+    for cleanups.each |c| {\n+        revoke_clean(bcx, *c);\n+    }\n+\n+    let mut constraints = str::connect(constraints, \",\");\n+\n+    // Add the clobbers to our constraints list\n+    if *clobs != ~\"\" && constraints != ~\"\" {\n+        constraints += ~\",\" + *clobs;\n+    } else {\n+        constraints += *clobs;\n+    }\n+\n+    debug!(\"Asm Constraints: %?\", constraints);\n+\n+    let numOutputs = outputs.len();\n+\n+    // Depending on how many outputs we have, the return type is different\n+    let output = if numOutputs == 0 {\n+        T_void()\n+    } else if numOutputs == 1 {\n+        val_ty(outputs[0])\n+    } else {\n+        T_struct(outputs.map(|o| val_ty(*o)))\n+    };\n+\n+    let r = do str::as_c_str(*asm) |a| {\n+        do str::as_c_str(constraints) |c| {\n+            // XXX: Allow selection of at&t or intel\n+            InlineAsmCall(bcx, a, c, inputs, output, volatile, alignstack, lib::llvm::AD_ATT)\n+        }\n+    };\n+\n+    // Again, based on how many outputs we have \n+    if numOutputs == 1 {\n+        let op = PointerCast(bcx, aoutputs[0], T_ptr(val_ty(outputs[0])));\n+        Store(bcx, r, op);\n+    } else {\n+        for aoutputs.eachi |i, o| {\n+            let v = ExtractValue(bcx, r, i);\n+            let op = PointerCast(bcx, *o, T_ptr(val_ty(outputs[i])));\n+            Store(bcx, v, op);\n+        }\n+    }\n+\n+    return bcx;\n+\n+}"}, {"sha": "3138fe420a97fee5c43b86c7156f23aa3622597e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 100, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/727a565f1e65c415b018f26d878a0d3ebdc9e3ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727a565f1e65c415b018f26d878a0d3ebdc9e3ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=727a565f1e65c415b018f26d878a0d3ebdc9e3ea", "patch": "@@ -127,6 +127,7 @@ use lib::llvm::{ValueRef, TypeRef, llvm, True};\n use middle::borrowck::root_map_key;\n use middle::trans::_match;\n use middle::trans::adt;\n+use middle::trans::asm;\n use middle::trans::base;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -559,106 +560,7 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n         }\n         ast::expr_inline_asm(asm, ref ins, ref outs,\n                              clobs, volatile, alignstack) => {\n-            let mut constraints = ~[];\n-            let mut cleanups = ~[];\n-            let mut aoutputs = ~[];\n-\n-            let outputs = do outs.map |&(c, out)| {\n-                constraints.push(copy *c);\n-\n-                let aoutty = ty::arg {\n-                    mode: ast::expl(ast::by_copy),\n-                    ty: expr_ty(bcx, out)\n-                };\n-                aoutputs.push(unpack_result!(bcx, {\n-                    callee::trans_arg_expr(bcx, aoutty, out, &mut cleanups,\n-                                           None, callee::DontAutorefArg)\n-                    }));\n-\n-                let e = match out.node {\n-                    ast::expr_addr_of(_, e) => e,\n-                    _ => fail!(~\"Expression must be addr of\")\n-                };\n-\n-                let outty = ty::arg {\n-                    mode: ast::expl(ast::by_copy),\n-                    ty: expr_ty(bcx, e)\n-                };\n-\n-                unpack_result!(bcx, {\n-                    callee::trans_arg_expr(bcx, outty, e, &mut cleanups,\n-                                           None, callee::DontAutorefArg)\n-                })\n-\n-            };\n-\n-            for cleanups.each |c| {\n-                revoke_clean(bcx, *c);\n-            }\n-            cleanups = ~[];\n-\n-            let inputs = do ins.map |&(c, in)| {\n-                constraints.push(copy *c);\n-\n-                let inty = ty::arg {\n-                    mode: ast::expl(ast::by_copy),\n-                    ty: expr_ty(bcx, in)\n-                };\n-\n-                unpack_result!(bcx, {\n-                    callee::trans_arg_expr(bcx, inty, in, &mut cleanups,\n-                                           None, callee::DontAutorefArg)\n-                })\n-\n-            };\n-\n-            for cleanups.each |c| {\n-                revoke_clean(bcx, *c);\n-            }\n-\n-            let mut constraints = str::connect(constraints, \",\");\n-\n-            // Add the clobbers\n-            if *clobs != ~\"\" {\n-                if constraints == ~\"\" {\n-                    constraints += *clobs;\n-                } else {\n-                    constraints += ~\",\" + *clobs;\n-                }\n-            } else {\n-                constraints += *clobs;\n-            }\n-\n-            debug!(\"Asm Constraints: %?\", constraints);\n-\n-            let output = if outputs.len() == 0 {\n-                T_void()\n-            } else if outputs.len() == 1 {\n-                val_ty(outputs[0])\n-            } else {\n-                T_struct(outputs.map(|o| val_ty(*o)))\n-            };\n-\n-            let r = do str::as_c_str(*asm) |a| {\n-                do str::as_c_str(constraints) |c| {\n-                    InlineAsmCall(bcx, a, c, inputs, output, volatile,\n-                                  alignstack, lib::llvm::AD_ATT)\n-                }\n-            };\n-\n-            if outputs.len() == 1 {\n-                let op = PointerCast(bcx, aoutputs[0],\n-                                     T_ptr(val_ty(outputs[0])));\n-                Store(bcx, r, op);\n-            } else {\n-                for aoutputs.eachi |i, o| {\n-                    let v = ExtractValue(bcx, r, i);\n-                    let op = PointerCast(bcx, *o, T_ptr(val_ty(outputs[i])));\n-                    Store(bcx, v, op);\n-                }\n-            }\n-\n-            return bcx;\n+            return asm::trans_inline_asm(bcx, asm, *ins, *outs, clobs, volatile, alignstack);\n         }\n         _ => {\n             bcx.tcx().sess.span_bug("}, {"sha": "456f9743afab40b2f1e5644465ff65a826094be5", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/727a565f1e65c415b018f26d878a0d3ebdc9e3ea/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/727a565f1e65c415b018f26d878a0d3ebdc9e3ea/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=727a565f1e65c415b018f26d878a0d3ebdc9e3ea", "patch": "@@ -80,6 +80,7 @@ pub mod middle {\n         pub mod reachable;\n         pub mod machine;\n         pub mod adt;\n+        pub mod asm;\n     }\n     pub mod ty;\n     pub mod resolve;"}]}