{"sha": "f213957c2e01067ab20ba74f71371093ed0b43bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMTM5NTdjMmUwMTA2N2FiMjBiYTc0ZjcxMzcxMDkzZWQwYjQzYmI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-01T14:42:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-01T14:42:56Z"}, "message": "Rollup merge of #73806 - Aaron1011:feature/approx-universal-upper, r=estebank\n\nUse an 'approximate' universal upper bound when reporting region errors\n\nFixes #67765\n\nWhen reporting errors during MIR region inference, we sometimes use\n`universal_upper_bound` to obtain a named universal region that we\ncan display to the user. However, this is not always possible - in a\ncase like `fn foo<'a, 'b>() { .. }`, the only upper bound for a region\ncontaining `'a` and `'b` is `'static`. When displaying diagnostics, it's\nusually better to display *some* named region (even if there are\nmultiple involved) rather than fall back to a generic error involving\n`'static`.\n\nThis commit adds a new `approx_universal_upper_bound` method, which\nuses the lowest-numbered universal region if the only alternative is to\nreturn `'static`.", "tree": {"sha": "9e2b13066ae0bbf661fd1beb7eecd2a30183e472", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e2b13066ae0bbf661fd1beb7eecd2a30183e472"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f213957c2e01067ab20ba74f71371093ed0b43bb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/KDwCRBK7hj4Ov3rIwAAdHIIACATnaHSifhPTa8ZBWLRgQz5\npe+yOpwaOg0KG477PJO9f2Hh84/GqEzXN/W9CVCEjzUtDasEE70gW9CiC2UaVOnH\niN/QDmdQGkxhuR11NKon7NYfbFG0zsTaKg2Q9jbZcR2J/jvILxwJ7hVyX6+6YWH3\nwUjRCLJQUbzTrTlkSSVlLUTCpLlp80Swi+on9qhO0sfDA4o9zCubLW7ktIYftdZX\nGAvqXfGQI72KYEgXLXB4vxD4fVnhClAPHR9HwqDkAsnI12mLxUDA1S7m4dbhmpie\nWauGf0tdUDDJLabIww7JSui7yPjbICI+YQN8SM/vNSYjdFUyDk9n1YND3gYv91g=\n=JxSv\n-----END PGP SIGNATURE-----\n", "payload": "tree 9e2b13066ae0bbf661fd1beb7eecd2a30183e472\nparent 178b0c2e9954ede56d552f8a625ef59524ab3f60\nparent 517d361a1f78cf13d589d0f6b94f5ca005bef540\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593614576 -0700\ncommitter GitHub <noreply@github.com> 1593614576 -0700\n\nRollup merge of #73806 - Aaron1011:feature/approx-universal-upper, r=estebank\n\nUse an 'approximate' universal upper bound when reporting region errors\n\nFixes #67765\n\nWhen reporting errors during MIR region inference, we sometimes use\n`universal_upper_bound` to obtain a named universal region that we\ncan display to the user. However, this is not always possible - in a\ncase like `fn foo<'a, 'b>() { .. }`, the only upper bound for a region\ncontaining `'a` and `'b` is `'static`. When displaying diagnostics, it's\nusually better to display *some* named region (even if there are\nmultiple involved) rather than fall back to a generic error involving\n`'static`.\n\nThis commit adds a new `approx_universal_upper_bound` method, which\nuses the lowest-numbered universal region if the only alternative is to\nreturn `'static`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f213957c2e01067ab20ba74f71371093ed0b43bb", "html_url": "https://github.com/rust-lang/rust/commit/f213957c2e01067ab20ba74f71371093ed0b43bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f213957c2e01067ab20ba74f71371093ed0b43bb/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "178b0c2e9954ede56d552f8a625ef59524ab3f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/178b0c2e9954ede56d552f8a625ef59524ab3f60", "html_url": "https://github.com/rust-lang/rust/commit/178b0c2e9954ede56d552f8a625ef59524ab3f60"}, {"sha": "517d361a1f78cf13d589d0f6b94f5ca005bef540", "url": "https://api.github.com/repos/rust-lang/rust/commits/517d361a1f78cf13d589d0f6b94f5ca005bef540", "html_url": "https://github.com/rust-lang/rust/commit/517d361a1f78cf13d589d0f6b94f5ca005bef540"}], "stats": {"total": 113, "additions": 101, "deletions": 12}, "files": [{"sha": "26c2aea41d5dc616b9fc4953966ee7061a14b4c1", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=f213957c2e01067ab20ba74f71371093ed0b43bb", "patch": "@@ -122,7 +122,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if self.regioncx.universal_regions().is_universal_region(r) {\n             Some(r)\n         } else {\n-            let upper_bound = self.regioncx.universal_upper_bound(r);\n+            // We just want something nameable, even if it's not\n+            // actually an upper bound.\n+            let upper_bound = self.regioncx.approx_universal_upper_bound(r);\n \n             if self.regioncx.upper_bound_in_region_scc(r, upper_bound) {\n                 self.to_error_region_vid(upper_bound)"}, {"sha": "081125cb625c237a1dca978be4aa403c701412e4", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=f213957c2e01067ab20ba74f71371093ed0b43bb", "patch": "@@ -1114,6 +1114,40 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         lub\n     }\n \n+    /// Like `universal_upper_bound`, but returns an approximation more suitable\n+    /// for diagnostics. If `r` contains multiple disjoint universal regions\n+    /// (e.g. 'a and 'b in `fn foo<'a, 'b> { ... }`, we pick the lower-numbered region.\n+    /// This corresponds to picking named regions over unnamed regions\n+    /// (e.g. picking early-bound regions over a closure late-bound region).\n+    ///\n+    /// This means that the returned value may not be a true upper bound, since\n+    /// only 'static is known to outlive disjoint universal regions.\n+    /// Therefore, this method should only be used in diagnostic code,\n+    /// where displaying *some* named universal region is better than\n+    /// falling back to 'static.\n+    pub(in crate::borrow_check) fn approx_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n+        debug!(\"approx_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n+\n+        // Find the smallest universal region that contains all other\n+        // universal regions within `region`.\n+        let mut lub = self.universal_regions.fr_fn_body;\n+        let r_scc = self.constraint_sccs.scc(r);\n+        let static_r = self.universal_regions.fr_static;\n+        for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n+            let new_lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n+            debug!(\"approx_universal_upper_bound: ur={:?} lub={:?} new_lub={:?}\", ur, lub, new_lub);\n+            if ur != static_r && lub != static_r && new_lub == static_r {\n+                lub = std::cmp::min(ur, lub);\n+            } else {\n+                lub = new_lub;\n+            }\n+        }\n+\n+        debug!(\"approx_universal_upper_bound: r={:?} lub={:?}\", r, lub);\n+\n+        lub\n+    }\n+\n     /// Tests if `test` is true when applied to `lower_bound` at\n     /// `point`.\n     fn eval_verify_bound("}, {"sha": "325dca8c8ca9997425f6f062f6e67065787ace33", "filename": "src/librustc_mir/borrow_check/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=f213957c2e01067ab20ba74f71371093ed0b43bb", "patch": "@@ -141,7 +141,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     {\n         tcx.fold_regions(&ty, &mut false, |region, _| match *region {\n             ty::ReVar(vid) => {\n-                let upper_bound = self.universal_upper_bound(vid);\n+                // Find something that we can name\n+                let upper_bound = self.approx_universal_upper_bound(vid);\n                 self.definitions[upper_bound].external_name.unwrap_or(region)\n             }\n             _ => region,"}, {"sha": "5093916e73a45b68aa0672aae38da94b83fc1fbe", "filename": "src/test/ui/async-await/issue-67765-async-diagnostic.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.rs?ref=f213957c2e01067ab20ba74f71371093ed0b43bb", "patch": "@@ -0,0 +1,16 @@\n+// edition:2018\n+//\n+// Regression test for issue #67765\n+// Tests that we point at the proper location when giving\n+// a lifetime error.\n+fn main() {}\n+\n+async fn func<'a>() -> Result<(), &'a str> {\n+    let s = String::new();\n+\n+    let b = &s[..];\n+\n+    Err(b)?; //~ ERROR cannot return value referencing local variable `s`\n+\n+    Ok(())\n+}"}, {"sha": "78253042bee1c35eb4ace7a201f892bbf5d3a92e", "filename": "src/test/ui/async-await/issue-67765-async-diagnostic.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr?ref=f213957c2e01067ab20ba74f71371093ed0b43bb", "patch": "@@ -0,0 +1,12 @@\n+error[E0515]: cannot return value referencing local variable `s`\n+  --> $DIR/issue-67765-async-diagnostic.rs:13:11\n+   |\n+LL |     let b = &s[..];\n+   |              - `s` is borrowed here\n+LL | \n+LL |     Err(b)?;\n+   |           ^ returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "8deb3655158409ae252528e7d023615c19e8b419", "filename": "src/test/ui/lifetimes/unnamed-closure-doesnt-life-long-enough-issue-67634.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.rs?ref=f213957c2e01067ab20ba74f71371093ed0b43bb", "patch": "@@ -1,3 +1,3 @@\n fn main() {\n-    [0].iter().flat_map(|a| [0].iter().map(|_| &a)); //~ ERROR `a` does not live long enough\n+    [0].iter().flat_map(|a| [0].iter().map(|_| &a)); //~ ERROR closure may outlive\n }"}, {"sha": "34470119112fbf60b35265029b804dfcf4fc9dad", "filename": "src/test/ui/lifetimes/unnamed-closure-doesnt-life-long-enough-issue-67634.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.stderr?ref=f213957c2e01067ab20ba74f71371093ed0b43bb", "patch": "@@ -1,15 +1,21 @@\n-error[E0597]: `a` does not live long enough\n-  --> $DIR/unnamed-closure-doesnt-life-long-enough-issue-67634.rs:2:49\n+error[E0373]: closure may outlive the current function, but it borrows `a`, which is owned by the current function\n+  --> $DIR/unnamed-closure-doesnt-life-long-enough-issue-67634.rs:2:44\n    |\n LL |     [0].iter().flat_map(|a| [0].iter().map(|_| &a));\n-   |                                             -   ^- ...but `a` will be dropped here, when the enclosing closure returns\n-   |                                             |   |\n-   |                                             |   `a` would have to be valid for `'_`...\n-   |                                             has type `&i32`\n+   |                                            ^^^  - `a` is borrowed here\n+   |                                            |\n+   |                                            may outlive borrowed value `a`\n    |\n-   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#dangling-references>\n+note: closure is returned here\n+  --> $DIR/unnamed-closure-doesnt-life-long-enough-issue-67634.rs:2:29\n+   |\n+LL |     [0].iter().flat_map(|a| [0].iter().map(|_| &a));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^\n+help: to force the closure to take ownership of `a` (and any other referenced variables), use the `move` keyword\n+   |\n+LL |     [0].iter().flat_map(|a| [0].iter().map(move |_| &a));\n+   |                                            ^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0373`."}, {"sha": "d0feb3b65e12ac09bab1b0c7a7d8686725308952", "filename": "src/test/ui/return-disjoint-regions.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Freturn-disjoint-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Freturn-disjoint-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn-disjoint-regions.rs?ref=f213957c2e01067ab20ba74f71371093ed0b43bb", "patch": "@@ -0,0 +1,7 @@\n+// See https://github.com/rust-lang/rust/pull/67911#issuecomment-576023915\n+fn f<'a, 'b>(x: i32) -> (&'a i32, &'b i32) {\n+    let y = &x;\n+    (y, y) //~ ERROR cannot return\n+}\n+\n+fn main() {}"}, {"sha": "ed159298804ae89265c0e2cc321e3689c7a0ced1", "filename": "src/test/ui/return-disjoint-regions.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Freturn-disjoint-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f213957c2e01067ab20ba74f71371093ed0b43bb/src%2Ftest%2Fui%2Freturn-disjoint-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn-disjoint-regions.stderr?ref=f213957c2e01067ab20ba74f71371093ed0b43bb", "patch": "@@ -0,0 +1,11 @@\n+error[E0515]: cannot return value referencing function parameter `x`\n+  --> $DIR/return-disjoint-regions.rs:4:5\n+   |\n+LL |     let y = &x;\n+   |             -- `x` is borrowed here\n+LL |     (y, y)\n+   |     ^^^^^^ returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}]}