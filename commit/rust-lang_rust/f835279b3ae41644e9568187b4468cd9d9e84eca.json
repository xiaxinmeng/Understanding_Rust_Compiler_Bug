{"sha": "f835279b3ae41644e9568187b4468cd9d9e84eca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MzUyNzliM2FlNDE2NDRlOTU2ODE4N2I0NDY4Y2Q5ZDllODRlY2E=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-21T11:48:25Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-21T11:48:25Z"}, "message": "Move out completion pattern tests", "tree": {"sha": "fc5b37d8257674d0c5fa7a8e8c1177e21dc4750c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc5b37d8257674d0c5fa7a8e8c1177e21dc4750c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f835279b3ae41644e9568187b4468cd9d9e84eca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f835279b3ae41644e9568187b4468cd9d9e84eca", "html_url": "https://github.com/rust-lang/rust/commit/f835279b3ae41644e9568187b4468cd9d9e84eca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f835279b3ae41644e9568187b4468cd9d9e84eca/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2aa7782d65c4f2765f68b99f00f4203e1f143c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2aa7782d65c4f2765f68b99f00f4203e1f143c1", "html_url": "https://github.com/rust-lang/rust/commit/c2aa7782d65c4f2765f68b99f00f4203e1f143c1"}], "stats": {"total": 816, "additions": 349, "deletions": 467}, "files": [{"sha": "e40ec6280d8a0ea1b68f85433523d2d6467e0427", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f835279b3ae41644e9568187b4468cd9d9e84eca/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f835279b3ae41644e9568187b4468cd9d9e84eca/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=f835279b3ae41644e9568187b4468cd9d9e84eca", "patch": "@@ -372,28 +372,6 @@ fn quux() -> i32 {\n         );\n     }\n \n-    #[test]\n-    fn test_mut_in_ref_and_in_fn_parameters_list() {\n-        check(\n-            r\"fn my_fn(&$0) {}\",\n-            expect![[r#\"\n-                kw mut\n-            \"#]],\n-        );\n-        check(\n-            r\"fn my_fn($0) {}\",\n-            expect![[r#\"\n-                kw mut\n-            \"#]],\n-        );\n-        check(\n-            r\"fn my_fn() { let &$0 }\",\n-            expect![[r#\"\n-                kw mut\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn no_keyword_completion_in_comments() {\n         cov_mark::check!(no_keyword_completion_in_comments);"}, {"sha": "bd13a62d7571e953d4bb6ef5fb83343f45939855", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 0, "deletions": 395, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/f835279b3ae41644e9568187b4468cd9d9e84eca/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f835279b3ae41644e9568187b4468cd9d9e84eca/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=f835279b3ae41644e9568187b4468cd9d9e84eca", "patch": "@@ -55,398 +55,3 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n     });\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-\n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Reference);\n-        expect.assert_eq(&actual)\n-    }\n-\n-    fn check_snippet(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Snippet);\n-        expect.assert_eq(&actual)\n-    }\n-\n-    #[test]\n-    fn completes_enum_variants_and_modules() {\n-        check(\n-            r#\"\n-enum E { X }\n-use self::E::X;\n-const Z: E = E::X;\n-mod m {}\n-\n-static FOO: E = E::X;\n-struct Bar { f: u32 }\n-\n-fn foo() {\n-   match E::X { a$0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                en E\n-                ct Z\n-                st Bar\n-                ev X\n-                md m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn does_not_complete_non_fn_macros() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-enum E { X }\n-\n-#[rustc_builtin_macro]\n-macro Clone {}\n-\n-fn foo() {\n-   match E::X { $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev E::X  ()\n-                en E\n-                ma m!(\u2026) macro_rules! m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_simple_macro_call() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-enum E { X }\n-\n-fn foo() {\n-   m!(match E::X { a$0 })\n-}\n-\"#,\n-            expect![[r#\"\n-                ev E::X  ()\n-                en E\n-                ma m!(\u2026) macro_rules! m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_irrefutable_let() {\n-        check(\n-            r#\"\n-enum E { X }\n-use self::E::X;\n-const Z: E = E::X;\n-mod m {}\n-\n-static FOO: E = E::X;\n-struct Bar { f: u32 }\n-\n-fn foo() {\n-   let a$0\n-}\n-\"#,\n-            expect![[r#\"\n-                st Bar\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_param() {\n-        check(\n-            r#\"\n-enum E { X }\n-\n-static FOO: E = E::X;\n-struct Bar { f: u32 }\n-\n-fn foo(a$0) {\n-}\n-\"#,\n-            expect![[r#\"\n-                st Bar\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_pat_in_let() {\n-        check_snippet(\n-            r#\"\n-struct Bar { f: u32 }\n-\n-fn foo() {\n-   let a$0\n-}\n-\"#,\n-            expect![[r#\"\n-                bn Bar Bar { f$1 }$0\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_param_pattern() {\n-        check_snippet(\n-            r#\"\n-struct Foo { bar: String, baz: String }\n-struct Bar(String, String);\n-struct Baz;\n-fn outer(a$0) {}\n-\"#,\n-            expect![[r#\"\n-                bn Foo Foo { bar$1, baz$2 }: Foo$0\n-                bn Bar Bar($1, $2): Bar$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_let_pattern() {\n-        check_snippet(\n-            r#\"\n-struct Foo { bar: String, baz: String }\n-struct Bar(String, String);\n-struct Baz;\n-fn outer() {\n-    let a$0\n-}\n-\"#,\n-            expect![[r#\"\n-                bn Foo Foo { bar$1, baz$2 }$0\n-                bn Bar Bar($1, $2)$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_refutable_pattern() {\n-        check_snippet(\n-            r#\"\n-struct Foo { bar: i32, baz: i32 }\n-struct Bar(String, String);\n-struct Baz;\n-fn outer() {\n-    match () {\n-        a$0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                bn Foo Foo { bar$1, baz$2 }$0\n-                bn Bar Bar($1, $2)$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn omits_private_fields_pat() {\n-        check_snippet(\n-            r#\"\n-mod foo {\n-    pub struct Foo { pub bar: i32, baz: i32 }\n-    pub struct Bar(pub String, String);\n-    pub struct Invisible(String, String);\n-}\n-use foo::*;\n-\n-fn outer() {\n-    match () {\n-        a$0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                bn Foo Foo { bar$1, .. }$0\n-                bn Bar Bar($1, ..)$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn only_shows_ident_completion() {\n-        check_edit(\n-            \"Foo\",\n-            r#\"\n-struct Foo(i32);\n-fn main() {\n-    match Foo(92) {\n-        a$0(92) => (),\n-    }\n-}\n-\"#,\n-            r#\"\n-struct Foo(i32);\n-fn main() {\n-    match Foo(92) {\n-        Foo(92) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_self_pats() {\n-        check_snippet(\n-            r#\"\n-struct Foo(i32);\n-impl Foo {\n-    fn foo() {\n-        match () {\n-            a$0\n-        }\n-    }\n-}\n-    \"#,\n-            expect![[r#\"\n-                bn Self Self($1)$0\n-                bn Foo  Foo($1)$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_qualified_variant() {\n-        check_snippet(\n-            r#\"\n-enum Foo {\n-    Bar { baz: i32 }\n-}\n-impl Foo {\n-    fn foo() {\n-        match {Foo::Bar { baz: 0 }} {\n-            B$0\n-        }\n-    }\n-}\n-    \"#,\n-            expect![[r#\"\n-                bn Self::Bar Self::Bar { baz$1 }$0\n-                bn Foo::Bar  Foo::Bar { baz$1 }$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_matcharm() {\n-        check(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-\n-fn main() {\n-    let foo = Foo::Quux;\n-    match foo { Qu$0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev Foo::Bar  ()\n-                ev Foo::Baz  ()\n-                ev Foo::Quux ()\n-                en Foo\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_matcharm_ref() {\n-        check(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-\n-fn main() {\n-    let foo = Foo::Quux;\n-    match &foo { Qu$0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev Foo::Bar  ()\n-                ev Foo::Baz  ()\n-                ev Foo::Quux ()\n-                en Foo\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_iflet() {\n-        check(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-\n-fn main() {\n-    let foo = Foo::Quux;\n-    if let Qu$0 = foo { }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev Foo::Bar  ()\n-                ev Foo::Baz  ()\n-                ev Foo::Quux ()\n-                en Foo\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_impl() {\n-        check(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-impl Foo {\n-    fn foo() { match Foo::Bar { Q$0 } }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev Self::Bar  ()\n-                ev Self::Baz  ()\n-                ev Self::Quux ()\n-                ev Foo::Bar   ()\n-                ev Foo::Baz   ()\n-                ev Foo::Quux  ()\n-                sp Self\n-                en Foo\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_in_record_field_pat() {\n-        check_snippet(\n-            r#\"\n-struct Foo { bar: Bar }\n-struct Bar(u32);\n-fn outer(Foo { bar: $0 }: Foo) {}\n-\"#,\n-            expect![[r#\"\n-                bn Foo Foo { bar$1 }$0\n-                bn Bar Bar($1)$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn skips_in_record_field_pat_name() {\n-        check_snippet(\n-            r#\"\n-struct Foo { bar: Bar }\n-struct Bar(u32);\n-fn outer(Foo { bar$0 }: Foo) {}\n-\"#,\n-            expect![[r#\"\"#]],\n-        )\n-    }\n-}"}, {"sha": "819fa3a430cdcf6eeb13cedab846897f38c58677", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f835279b3ae41644e9568187b4468cd9d9e84eca/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f835279b3ae41644e9568187b4468cd9d9e84eca/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=f835279b3ae41644e9568187b4468cd9d9e84eca", "patch": "@@ -134,56 +134,6 @@ fn foo() {\n         );\n     }\n \n-    #[test]\n-    fn bind_pat_and_path_ignore_at() {\n-        check(\n-            r#\"\n-enum Enum { A, B }\n-fn quux(x: Option<Enum>) {\n-    match x {\n-        None => (),\n-        Some(en$0 @ Enum::A) => (),\n-    }\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn bind_pat_and_path_ignore_ref() {\n-        check(\n-            r#\"\n-enum Enum { A, B }\n-fn quux(x: Option<Enum>) {\n-    match x {\n-        None => (),\n-        Some(ref en$0) => (),\n-    }\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn bind_pat_and_path() {\n-        check(\n-            r#\"\n-enum Enum { A, B }\n-fn quux(x: Option<Enum>) {\n-    match x {\n-        None => (),\n-        Some(En$0) => (),\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                en Enum\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_bindings_from_let() {\n         check("}, {"sha": "7af8c903b3d4599da8610284bebc9de64eba9fd8", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f835279b3ae41644e9568187b4468cd9d9e84eca/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f835279b3ae41644e9568187b4468cd9d9e84eca/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=f835279b3ae41644e9568187b4468cd9d9e84eca", "patch": "@@ -7,6 +7,7 @@\n mod item_list;\n mod use_tree;\n mod items;\n+mod pattern;\n \n use hir::{PrefixKind, Semantics};\n use ide_db::{"}, {"sha": "1ad5ccd97afa61d3b0f9746490e908c378fbaf60", "filename": "crates/ide_completion/src/tests/pattern.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/f835279b3ae41644e9568187b4468cd9d9e84eca/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f835279b3ae41644e9568187b4468cd9d9e84eca/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs?ref=f835279b3ae41644e9568187b4468cd9d9e84eca", "patch": "@@ -0,0 +1,348 @@\n+//! Completions tests for pattern position.\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::completion_list;\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual)\n+}\n+\n+fn check_with(ra_fixture: &str, expect: Expect) {\n+    let base = r#\"\n+enum Enum { TupleV(u32), RecordV { field: u32 }, UnitV }\n+use self::Enum::TupleV;\n+mod module {}\n+\n+static STATIC: Unit = Unit;\n+const CONST: Unit = Unit;\n+struct Record { field: u32 }\n+struct Tuple(u32);\n+struct Unit\n+macro_rules! makro {}\n+\"#;\n+    let actual = completion_list(&format!(\"{}\\n{}\", base, ra_fixture));\n+    expect.assert_eq(&actual)\n+}\n+\n+#[test]\n+fn ident_rebind_pat() {\n+    check(\n+        r#\"\n+fn quux() {\n+    let en$0 @ x\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn ident_ref_pat() {\n+    check(\n+        r#\"\n+fn quux() {\n+    let ref en$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn quux() {\n+    let ref en$0 @ x\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn ident_ref_mut_pat() {\n+    // FIXME mut is already here, don't complete it again\n+    check(\n+        r#\"\n+fn quux() {\n+    let ref mut en$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn quux() {\n+    let ref mut en$0 @ x\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn ref_pat() {\n+    check(\n+        r#\"\n+fn quux() {\n+    let &en$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+    // FIXME mut is already here, don't complete it again\n+    check(\n+        r#\"\n+fn quux() {\n+    let &mut en$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn refutable() {\n+    check_with(\n+        r#\"\n+fn foo() {\n+    if let a$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Record    Record { field$1 }$0\n+            st Record\n+            en Enum\n+            bn Tuple     Tuple($1)$0\n+            st Tuple\n+            md module\n+            bn TupleV    TupleV($1)$0\n+            ev TupleV\n+            st Unit\n+            ct CONST\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn irrefutable() {\n+    check_with(\n+        r#\"\n+fn foo() {\n+   let a$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Record    Record { field$1 }$0\n+            st Record\n+            bn Tuple     Tuple($1)$0\n+            st Tuple\n+            st Unit\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn in_param() {\n+    check_with(\n+        r#\"\n+fn foo(a$0) {\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Record    Record { field$1 }: Record$0\n+            st Record\n+            bn Tuple     Tuple($1): Tuple$0\n+            st Tuple\n+            st Unit\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn only_fn_like_macros() {\n+    check(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+\n+#[rustc_builtin_macro]\n+macro Clone {}\n+\n+fn foo() {\n+    let x$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            ma m!(\u2026) macro_rules! m\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn in_simple_macro_call() {\n+    check(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+enum E { X }\n+\n+fn foo() {\n+   m!(match E::X { a$0 })\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            ev E::X  ()\n+            en E\n+            ma m!(\u2026) macro_rules! m\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn omits_private_fields_pat() {\n+    check(\n+        r#\"\n+mod foo {\n+    pub struct Record { pub field: i32, _field: i32 }\n+    pub struct Tuple(pub u32, u32);\n+    pub struct Invisible(u32, u32);\n+}\n+use foo::*;\n+\n+fn outer() {\n+    if let a$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Record    Record { field$1, .. }$0\n+            st Record\n+            bn Tuple     Tuple($1, ..)$0\n+            st Tuple\n+            st Invisible\n+            md foo\n+        \"#]],\n+    )\n+}\n+\n+// #[test]\n+// fn only_shows_ident_completion() {\n+//     check_edit(\n+//         \"Foo\",\n+//         r#\"\n+// struct Foo(i32);\n+// fn main() {\n+//     match Foo(92) {\n+//         a$0(92) => (),\n+//     }\n+// }\n+// \"#,\n+//         r#\"\n+// struct Foo(i32);\n+// fn main() {\n+//     match Foo(92) {\n+//         Foo(92) => (),\n+//     }\n+// }\n+// \"#,\n+//     );\n+// }\n+\n+#[test]\n+fn completes_self_pats() {\n+    check(\n+        r#\"\n+struct Foo(i32);\n+impl Foo {\n+    fn foo() {\n+        match Foo(0) {\n+            a$0\n+        }\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Self Self($1)$0\n+            sp Self\n+            bn Foo  Foo($1)$0\n+            st Foo\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn completes_qualified_variant() {\n+    check(\n+        r#\"\n+enum Foo {\n+    Bar { baz: i32 }\n+}\n+impl Foo {\n+    fn foo() {\n+        match {Foo::Bar { baz: 0 }} {\n+            B$0\n+        }\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Self::Bar Self::Bar { baz$1 }$0\n+            ev Self::Bar { baz: i32 }\n+            bn Foo::Bar  Foo::Bar { baz$1 }$0\n+            ev Foo::Bar  { baz: i32 }\n+            sp Self\n+            en Foo\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn completes_in_record_field_pat() {\n+    check(\n+        r#\"\n+struct Foo { bar: Bar }\n+struct Bar(u32);\n+fn outer(Foo { bar: $0 }: Foo) {}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Foo Foo { bar$1 }$0\n+            st Foo\n+            bn Bar Bar($1)$0\n+            st Bar\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn skips_in_record_field_pat_name() {\n+    check(\n+        r#\"\n+struct Foo { bar: Bar }\n+struct Bar(u32);\n+fn outer(Foo { bar$0 }: Foo) {}\n+\"#,\n+        expect![[r#\"\"#]],\n+    )\n+}"}]}