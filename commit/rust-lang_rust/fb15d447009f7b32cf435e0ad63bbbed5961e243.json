{"sha": "fb15d447009f7b32cf435e0ad63bbbed5961e243", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMTVkNDQ3MDA5ZjdiMzJjZjQzNWUwYWQ2M2JiYmVkNTk2MWUyNDM=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-04-18T13:01:26Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-04-26T13:50:31Z"}, "message": "rustc_trans: generalize cabi_* to any context type.", "tree": {"sha": "99b439b7831b1bce3b22e64de36c4ce5639aaeac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99b439b7831b1bce3b22e64de36c4ce5639aaeac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb15d447009f7b32cf435e0ad63bbbed5961e243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb15d447009f7b32cf435e0ad63bbbed5961e243", "html_url": "https://github.com/rust-lang/rust/commit/fb15d447009f7b32cf435e0ad63bbbed5961e243", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb15d447009f7b32cf435e0ad63bbbed5961e243/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c45dda92feedaaed22bd9d74ec24164dc206da44", "url": "https://api.github.com/repos/rust-lang/rust/commits/c45dda92feedaaed22bd9d74ec24164dc206da44", "html_url": "https://github.com/rust-lang/rust/commit/c45dda92feedaaed22bd9d74ec24164dc206da44"}], "stats": {"total": 481, "additions": 303, "deletions": 178}, "files": [{"sha": "8b508d2bdcca5eb35ead8c79901f1f27a1efe60c", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -784,18 +784,18 @@ pub trait LayoutOf {\n     fn layout_of(self, ty: Self::Ty) -> Self::TyLayout;\n }\n \n-pub trait TyLayoutMethods<'a, C: LayoutOf>: Sized {\n+pub trait TyLayoutMethods<'a, C: LayoutOf<Ty = Self>>: Sized {\n     fn for_variant(this: TyLayout<'a, Self>, cx: C, variant_index: usize) -> TyLayout<'a, Self>;\n     fn field(this: TyLayout<'a, Self>, cx: C, i: usize) -> C::TyLayout;\n }\n \n impl<'a, Ty> TyLayout<'a, Ty> {\n     pub fn for_variant<C>(self, cx: C, variant_index: usize) -> Self\n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf {\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> {\n         Ty::for_variant(self, cx, variant_index)\n     }\n     pub fn field<C>(self, cx: C, i: usize) -> C::TyLayout \n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf {\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> {\n         Ty::field(self, cx, i)\n     }\n }"}, {"sha": "978ead51b05abe74dc1067a7ccb6faf3176e722b", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -397,6 +397,16 @@ pub struct Target {\n     pub options: TargetOptions,\n }\n \n+pub trait HasTargetSpec: Copy {\n+    fn target_spec(&self) -> &Target;\n+}\n+\n+impl<'a> HasTargetSpec for &'a Target {\n+    fn target_spec(&self) -> &Target {\n+        self\n+    }\n+}\n+\n /// Optional aspects of a target specification.\n ///\n /// This has an implementation of `Default`, see each field for what the default is. In general,"}, {"sha": "51e3921a543ee0b4db4630c85786f3280f5baf72", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -36,8 +36,10 @@ use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n \n+use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n+use rustc_target::spec::HasTargetSpec;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, LayoutOf, Size, TyLayout};\n+use rustc::ty::layout;\n \n use libc::c_uint;\n use std::cmp;\n@@ -142,12 +144,13 @@ impl LlvmType for Reg {\n     }\n }\n \n-pub trait LayoutExt<'tcx> {\n+pub trait LayoutExt<'a, Ty>: Sized {\n     fn is_aggregate(&self) -> bool;\n-    fn homogeneous_aggregate<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<Reg>;\n+    fn homogeneous_aggregate<C>(&self, cx: C) -> Option<Reg>\n+        where Ty: TyLayoutMethods<'a, C> + Copy, C: LayoutOf<Ty = Ty, TyLayout = Self> + Copy;\n }\n \n-impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n+impl<'a, Ty> LayoutExt<'a, Ty> for TyLayout<'a, Ty> {\n     fn is_aggregate(&self) -> bool {\n         match self.abi {\n             layout::Abi::Uninhabited |\n@@ -158,7 +161,9 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn homogeneous_aggregate<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<Reg> {\n+    fn homogeneous_aggregate<C>(&self, cx: C) -> Option<Reg> \n+        where Ty: TyLayoutMethods<'a, C> + Copy, C: LayoutOf<Ty = Ty, TyLayout = Self> + Copy\n+    {\n         match self.abi {\n             layout::Abi::Uninhabited => None,\n \n@@ -280,17 +285,17 @@ impl LlvmType for CastTarget {\n /// Information about how to pass an argument to,\n /// or return a value from, a function, under some ABI.\n #[derive(Debug)]\n-pub struct ArgType<'tcx> {\n-    pub layout: TyLayout<'tcx>,\n+pub struct ArgType<'tcx, Ty = ty::Ty<'tcx>> {\n+    pub layout: TyLayout<'tcx, Ty>,\n \n     /// Dummy argument, which is emitted before the real argument.\n     pub pad: Option<Reg>,\n \n     pub mode: PassMode,\n }\n \n-impl<'a, 'tcx> ArgType<'tcx> {\n-    fn new(layout: TyLayout<'tcx>) -> ArgType<'tcx> {\n+impl<'a, 'tcx, Ty> ArgType<'tcx, Ty> {\n+    fn new(layout: TyLayout<'tcx, Ty>) -> Self {\n         ArgType {\n             layout,\n             pad: None,\n@@ -364,7 +369,9 @@ impl<'a, 'tcx> ArgType<'tcx> {\n     pub fn is_ignore(&self) -> bool {\n         self.mode == PassMode::Ignore\n     }\n+}\n \n+impl<'a, 'tcx> ArgType<'tcx> {\n     /// Get the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n     pub fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n@@ -451,12 +458,12 @@ impl<'a, 'tcx> ArgType<'tcx> {\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n #[derive(Debug)]\n-pub struct FnType<'tcx> {\n+pub struct FnType<'tcx, Ty = ty::Ty<'tcx>> {\n     /// The LLVM types of each argument.\n-    pub args: Vec<ArgType<'tcx>>,\n+    pub args: Vec<ArgType<'tcx, Ty>>,\n \n     /// LLVM return type.\n-    pub ret: ArgType<'tcx>,\n+    pub ret: ArgType<'tcx, Ty>,\n \n     pub variadic: bool,\n \n@@ -474,15 +481,15 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n     pub fn new(cx: &CodegenCx<'a, 'tcx>,\n                sig: ty::FnSig<'tcx>,\n-               extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n+               extra_args: &[Ty<'tcx>]) -> Self {\n         let mut fn_ty = FnType::unadjusted(cx, sig, extra_args);\n         fn_ty.adjust_for_abi(cx, sig.abi);\n         fn_ty\n     }\n \n     pub fn new_vtable(cx: &CodegenCx<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n-                      extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n+                      extra_args: &[Ty<'tcx>]) -> Self {\n         let mut fn_ty = FnType::unadjusted(cx, sig, extra_args);\n         // Don't pass the vtable, it's not an argument of the virtual fn.\n         {\n@@ -507,7 +514,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n     pub fn unadjusted(cx: &CodegenCx<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n-                      extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n+                      extra_args: &[Ty<'tcx>]) -> Self {\n         debug!(\"FnType::unadjusted({:?}, {:?})\", sig, extra_args);\n \n         use self::Abi::*;\n@@ -569,7 +576,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         // Handle safe Rust thin and fat pointers.\n         let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n                                       scalar: &layout::Scalar,\n-                                      layout: TyLayout<'tcx>,\n+                                      layout: TyLayout<'tcx, Ty<'tcx>>,\n                                       offset: Size,\n                                       is_return: bool| {\n             // Booleans are always an i1 that needs to be zero-extended.\n@@ -742,7 +749,18 @@ impl<'a, 'tcx> FnType<'tcx> {\n             return;\n         }\n \n-        match &cx.sess().target.target.arch[..] {\n+        if let Err(msg) = self.adjust_for_cabi(cx, abi) {\n+            cx.sess().fatal(&msg);\n+        }\n+    }\n+}\n+\n+impl<'a, Ty> FnType<'a, Ty> {\n+    fn adjust_for_cabi<C>(&mut self, cx: C, abi: Abi) -> Result<(), String>\n+        where Ty: TyLayoutMethods<'a, C> + Copy,\n+              C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n+    {\n+        match &cx.target_spec().arch[..] {\n             \"x86\" => {\n                 let flavor = if abi == Abi::Fastcall {\n                     cabi_x86::Flavor::Fastcall\n@@ -753,7 +771,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n             },\n             \"x86_64\" => if abi == Abi::SysV64 {\n                 cabi_x86_64::compute_abi_info(cx, self);\n-            } else if abi == Abi::Win64 || cx.sess().target.target.options.is_like_windows {\n+            } else if abi == Abi::Win64 || cx.target_spec().options.is_like_windows {\n                 cabi_x86_win64::compute_abi_info(self);\n             } else {\n                 cabi_x86_64::compute_abi_info(cx, self);\n@@ -767,10 +785,10 @@ impl<'a, 'tcx> FnType<'tcx> {\n             \"s390x\" => cabi_s390x::compute_abi_info(cx, self),\n             \"asmjs\" => cabi_asmjs::compute_abi_info(cx, self),\n             \"wasm32\" => {\n-                if cx.sess().opts.target_triple.triple().contains(\"emscripten\") {\n+                if cx.target_spec().llvm_target.contains(\"emscripten\") {\n                     cabi_asmjs::compute_abi_info(cx, self)\n                 } else {\n-                    cabi_wasm32::compute_abi_info(cx, self)\n+                    cabi_wasm32::compute_abi_info(self)\n                 }\n             }\n             \"msp430\" => cabi_msp430::compute_abi_info(self),\n@@ -779,14 +797,18 @@ impl<'a, 'tcx> FnType<'tcx> {\n             \"nvptx\" => cabi_nvptx::compute_abi_info(self),\n             \"nvptx64\" => cabi_nvptx64::compute_abi_info(self),\n             \"hexagon\" => cabi_hexagon::compute_abi_info(self),\n-            a => cx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n+            a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n \n         if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n             attrs.set(ArgAttribute::StructRet);\n         }\n+\n+        Ok(())\n     }\n+}\n \n+impl<'a, 'tcx> FnType<'tcx> {\n     pub fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         let mut llargument_tys = Vec::new();\n "}, {"sha": "127f2dd194fe46b252aa2a6b230a58ceb922f6f1", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -9,10 +9,13 @@\n // except according to those terms.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CodegenCx;\n+use rustc_target::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n-                                     -> Option<Uniform> {\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n+                                     -> Option<Uniform> \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         let size = arg.layout.size;\n \n@@ -38,7 +41,10 @@ fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgTyp\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n@@ -69,7 +75,10 @@ fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n@@ -100,7 +109,10 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n     arg.make_indirect();\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret);\n     }"}, {"sha": "395a1db754f8e33d67c1f17ea1e2b99ff79756df", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -9,11 +9,15 @@\n // except according to those terms.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CodegenCx;\n+use rustc_target::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use rustc_target::spec::HasTargetSpec;\n use llvm::CallConv;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n-                                     -> Option<Uniform> {\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n+                                     -> Option<Uniform> \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         let size = arg.layout.size;\n \n@@ -39,7 +43,10 @@ fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgTyp\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>, vfp: bool) {\n+fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>, vfp: bool)\n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n@@ -71,7 +78,10 @@ fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>,\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>, vfp: bool) {\n+fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>, vfp: bool) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n@@ -92,10 +102,13 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>,\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n+{\n     // If this is a target with a hard-float ABI, and the function is not explicitly\n     // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates.\n-    let vfp = cx.sess().target.target.llvm_target.ends_with(\"hf\")\n+    let vfp = cx.target_spec().llvm_target.ends_with(\"hf\")\n         && fty.cconv != CallConv::ArmAapcsCallConv\n         && !fty.variadic;\n "}, {"sha": "82879fcf0324000b3d0b664aba1b0c0006667bb8", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -9,14 +9,17 @@\n // except according to those terms.\n \n use abi::{FnType, ArgType, LayoutExt, Uniform};\n-use context::CodegenCx;\n+use rustc_target::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n \n // See the https://github.com/kripken/emscripten-fastcomp-clang repository.\n // The class `EmscriptenABIInfo` in `/lib/CodeGen/TargetInfo.cpp` contains the ABI definitions.\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if ret.layout.is_aggregate() {\n         if let Some(unit) = ret.layout.homogeneous_aggregate(cx) {\n             let size = ret.layout.size;\n@@ -33,13 +36,16 @@ fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>)\n     }\n }\n \n-fn classify_arg_ty(arg: &mut ArgType) {\n+fn classify_arg_ty<Ty>(arg: &mut ArgType<Ty>) {\n     if arg.layout.is_aggregate() {\n         arg.make_indirect_byval();\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret);\n     }"}, {"sha": "45252c25175900a61b43a6866802086bd118bf68", "filename": "src/librustc_trans/cabi_hexagon.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_hexagon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_hexagon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_hexagon.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -12,23 +12,23 @@\n \n use abi::{FnType, ArgType, LayoutExt};\n \n-fn classify_ret_ty(ret: &mut ArgType) {\n+fn classify_ret_ty<Ty>(ret: &mut ArgType<Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {\n         ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg_ty(arg: &mut ArgType) {\n+fn classify_arg_ty<Ty>(arg: &mut ArgType<Ty>) {\n     if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {\n         arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n }\n \n-pub fn compute_abi_info(fty: &mut FnType) {\n+pub fn compute_abi_info<Ty>(fty: &mut FnType<Ty>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(&mut fty.ret);\n     }"}, {"sha": "77297480136a57b331141f4b09065dfa667b1957", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -9,23 +9,24 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CodegenCx;\n \n-use rustc::ty::layout::Size;\n+use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                             ret: &mut ArgType<'tcx>,\n-                             offset: &mut Size) {\n+fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size)\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n+{\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += cx.tcx.data_layout.pointer_size;\n+        *offset += cx.data_layout().pointer_size;\n     }\n }\n \n-fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &cx.tcx.data_layout;\n+fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n+{\n+    let dl = cx.data_layout();\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,7 +45,9 @@ fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>) \n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n+{\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret, &mut offset);"}, {"sha": "9a42f56d919c4f80a00d9e2635037a030b0a2d26", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -9,13 +9,12 @@\n // except according to those terms.\n \n use abi::{ArgAttribute, ArgType, CastTarget, FnType, LayoutExt, PassMode, Reg, RegKind, Uniform};\n-use context::CodegenCx;\n-use rustc::ty::layout::{self, Size};\n+use rustc_target::abi::{self, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n \n-fn extend_integer_width_mips(arg: &mut ArgType, bits: u64) {\n+fn extend_integer_width_mips<Ty>(arg: &mut ArgType<Ty>, bits: u64) {\n     // Always sign extend u32 values on 64-bit mips\n-    if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n-        if let layout::Int(i, signed) = scalar.value {\n+    if let abi::Abi::Scalar(ref scalar) = arg.layout.abi {\n+        if let abi::Int(i, signed) = scalar.value {\n             if !signed && i.size().bits() == 32 {\n                 if let PassMode::Direct(ref mut attrs) = arg.mode {\n                     attrs.set(ArgAttribute::SExt);\n@@ -28,18 +27,24 @@ fn extend_integer_width_mips(arg: &mut ArgType, bits: u64) {\n     arg.extend_integer_width_to(bits);\n }\n \n-fn float_reg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &ArgType<'tcx>, i: usize) -> Option<Reg> {\n+fn float_reg<'a, Ty, C>(cx: C, ret: &ArgType<'a, Ty>, i: usize) -> Option<Reg> \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     match ret.layout.field(cx, i).abi {\n-        layout::Abi::Scalar(ref scalar) => match scalar.value {\n-            layout::F32 => Some(Reg::f32()),\n-            layout::F64 => Some(Reg::f64()),\n+        abi::Abi::Scalar(ref scalar) => match scalar.value {\n+            abi::F32 => Some(Reg::f32()),\n+            abi::F64 => Some(Reg::f64()),\n             _ => None\n         },\n         _ => None\n     }\n }\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !ret.layout.is_aggregate() {\n         extend_integer_width_mips(ret, 64);\n         return;\n@@ -52,7 +57,7 @@ fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>)\n         // use of float registers to structures (not unions) containing exactly one or two\n         // float fields.\n \n-        if let layout::FieldPlacement::Arbitrary { .. } = ret.layout.fields {\n+        if let abi::FieldPlacement::Arbitrary { .. } = ret.layout.fields {\n             if ret.layout.fields.count() == 1 {\n                 if let Some(reg) = float_reg(cx, ret, 0) {\n                     ret.cast_to(reg);\n@@ -78,27 +83,30 @@ fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>)\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !arg.layout.is_aggregate() {\n         extend_integer_width_mips(arg, 64);\n         return;\n     }\n \n-    let dl = &cx.tcx.data_layout;\n+    let dl = cx.data_layout();\n     let size = arg.layout.size;\n     let mut prefix = [None; 8];\n     let mut prefix_index = 0;\n \n     match arg.layout.fields {\n-        layout::FieldPlacement::Array { .. } => {\n+        abi::FieldPlacement::Array { .. } => {\n             // Arrays are passed indirectly\n             arg.make_indirect();\n             return;\n         }\n-        layout::FieldPlacement::Union(_) => {\n+        abi::FieldPlacement::Union(_) => {\n             // Unions and are always treated as a series of 64-bit integer chunks\n         },\n-        layout::FieldPlacement::Arbitrary { .. } => {\n+        abi::FieldPlacement::Arbitrary { .. } => {\n             // Structures are split up into a series of 64-bit integer chunks, but any aligned\n             // doubles not part of another aggregate are passed as floats.\n             let mut last_offset = Size::from_bytes(0);\n@@ -108,8 +116,8 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                 let offset = arg.layout.fields.offset(i);\n \n                 // We only care about aligned doubles\n-                if let layout::Abi::Scalar(ref scalar) = field.abi {\n-                    if let layout::F64 = scalar.value {\n+                if let abi::Abi::Scalar(ref scalar) = field.abi {\n+                    if let abi::F64 = scalar.value {\n                         if offset.is_abi_aligned(dl.f64_align) {\n                             // Insert enough integers to cover [last_offset, offset)\n                             assert!(last_offset.is_abi_aligned(dl.f64_align));\n@@ -143,7 +151,10 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret);\n     }"}, {"sha": "309465a8026262e64a9c52990d0788e9e40ff332", "filename": "src/librustc_trans/cabi_msp430.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_msp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_msp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_msp430.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -19,23 +19,23 @@ use abi::{ArgType, FnType, LayoutExt};\n // returned by reference. To pass a structure or union by reference, the caller\n // places its address in the appropriate location: either in a register or on\n // the stack, according to its position in the argument list. (..)\"\n-fn classify_ret_ty(ret: &mut ArgType) {\n+fn classify_ret_ty<Ty>(ret: &mut ArgType<Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 32 {\n         ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(16);\n     }\n }\n \n-fn classify_arg_ty(arg: &mut ArgType) {\n+fn classify_arg_ty<Ty>(arg: &mut ArgType<Ty>) {\n     if arg.layout.is_aggregate() && arg.layout.size.bits() > 32 {\n         arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(16);\n     }\n }\n \n-pub fn compute_abi_info(fty: &mut FnType) {\n+pub fn compute_abi_info<Ty>(fty: &mut FnType<Ty>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(&mut fty.ret);\n     }"}, {"sha": "d245ca8c21bb2fee238a76fa838f4ada56fd71fe", "filename": "src/librustc_trans/cabi_nvptx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -13,23 +13,23 @@\n \n use abi::{ArgType, FnType, LayoutExt};\n \n-fn classify_ret_ty(ret: &mut ArgType) {\n+fn classify_ret_ty<Ty>(ret: &mut ArgType<Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 32 {\n         ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg_ty(arg: &mut ArgType) {\n+fn classify_arg_ty<Ty>(arg: &mut ArgType<Ty>) {\n     if arg.layout.is_aggregate() && arg.layout.size.bits() > 32 {\n         arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n }\n \n-pub fn compute_abi_info(fty: &mut FnType) {\n+pub fn compute_abi_info<Ty>(fty: &mut FnType<Ty>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(&mut fty.ret);\n     }"}, {"sha": "c938b944f46b80fccd661596813781e91609acbd", "filename": "src/librustc_trans/cabi_nvptx64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx64.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -13,23 +13,23 @@\n \n use abi::{ArgType, FnType, LayoutExt};\n \n-fn classify_ret_ty(ret: &mut ArgType) {\n+fn classify_ret_ty<Ty>(ret: &mut ArgType<Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {\n         ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(64);\n     }\n }\n \n-fn classify_arg_ty(arg: &mut ArgType) {\n+fn classify_arg_ty<Ty>(arg: &mut ArgType<Ty>) {\n     if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {\n         arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(64);\n     }\n }\n \n-pub fn compute_abi_info(fty: &mut FnType) {\n+pub fn compute_abi_info<Ty>(fty: &mut FnType<Ty>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(&mut fty.ret);\n     }"}, {"sha": "d85f6875d14cc697e2a8f6a2159538be953d1131", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -9,23 +9,24 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CodegenCx;\n \n-use rustc::ty::layout::Size;\n+use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                             ret: &mut ArgType<'tcx>,\n-                             offset: &mut Size) {\n+fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size)\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n+{\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += cx.tcx.data_layout.pointer_size;\n+        *offset += cx.data_layout().pointer_size;\n     }\n }\n \n-fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &cx.tcx.data_layout;\n+fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n+{\n+    let dl = cx.data_layout();\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,7 +45,9 @@ fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n+{\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret, &mut offset);"}, {"sha": "a8120e47cbf17208145630eb3fae4e87226179ce", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -13,8 +13,8 @@\n // need to be fixed when PowerPC vector support is added.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CodegenCx;\n-use rustc::ty::layout;\n+\n+use rustc_target::abi::{Align, Endian, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n enum ABI {\n@@ -23,10 +23,11 @@ enum ABI {\n }\n use self::ABI::*;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                      arg: &mut ArgType<'tcx>,\n-                                      abi: ABI)\n-                                     -> Option<Uniform> {\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>, abi: ABI) \n+                                       -> Option<Uniform>\n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{                                   \n     arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n         // ELFv2 passes up to eight uniquely addressable members.\n@@ -52,7 +53,10 @@ fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>, abi: ABI) {\n+fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>, abi: ABI)\n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n@@ -92,7 +96,10 @@ fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>,\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n+fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n@@ -112,7 +119,7 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>,\n             if size.bits() <= 64 {\n                 (Reg { kind: RegKind::Integer, size }, size)\n             } else {\n-                let align = layout::Align::from_bits(64, 64).unwrap();\n+                let align = Align::from_bits(64, 64).unwrap();\n                 (Reg::i64(), size.abi_align(align))\n             }\n         },\n@@ -128,11 +135,13 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>,\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n-    let abi = match cx.sess().target.target.target_endian.as_str() {\n-        \"big\" => ELFv1,\n-        \"little\" => ELFv2,\n-        _ => unimplemented!(),\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n+    let abi = match cx.data_layout().endian {\n+        Endian::Big => ELFv1,\n+        Endian::Little => ELFv2,\n     };\n \n     if !fty.ret.is_ignore() {"}, {"sha": "d18ceda2397cdee57065be2cac1a0b5a05a6a7eb", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -12,28 +12,31 @@\n // for a pre-z13 machine or using -mno-vx.\n \n use abi::{FnType, ArgType, LayoutExt, Reg};\n-use context::CodegenCx;\n \n-use rustc::ty::layout::{self, TyLayout};\n+use rustc_target::abi::{self, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn classify_ret_ty(ret: &mut ArgType) {\n+fn classify_ret_ty<'a, Ty, C>(ret: &mut ArgType<Ty>) \n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n+{\n     if !ret.layout.is_aggregate() && ret.layout.size.bits() <= 64 {\n         ret.extend_integer_width_to(64);\n     } else {\n         ret.make_indirect();\n     }\n }\n \n-fn is_single_fp_element<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                  layout: TyLayout<'tcx>) -> bool {\n+fn is_single_fp_element<'a, Ty, C>(cx: C, layout: TyLayout<'a, Ty>) -> bool\n+    where Ty: TyLayoutMethods<'a, C>,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     match layout.abi {\n-        layout::Abi::Scalar(ref scalar) => {\n+        abi::Abi::Scalar(ref scalar) => {\n             match scalar.value {\n-                layout::F32 | layout::F64 => true,\n+                abi::F32 | abi::F64 => true,\n                 _ => false\n             }\n         }\n-        layout::Abi::Aggregate { .. } => {\n+        abi::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(cx, layout.field(cx, 0))\n             } else {\n@@ -44,7 +47,10 @@ fn is_single_fp_element<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !arg.layout.is_aggregate() && arg.layout.size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n         return;\n@@ -67,7 +73,10 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(&mut fty.ret);\n     }"}, {"sha": "a2580189bb40e96ed46e643131b262cc81e814c1", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -9,23 +9,24 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CodegenCx;\n \n-use rustc::ty::layout::Size;\n+use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                             ret: &mut ArgType<'tcx>,\n-                             offset: &mut Size) {\n+fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size) \n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n+{\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += cx.tcx.data_layout.pointer_size;\n+        *offset += cx.data_layout().pointer_size;\n     }\n }\n \n-fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &cx.tcx.data_layout;\n+fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n+{\n+    let dl = cx.data_layout();\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,7 +45,9 @@ fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n+{\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret, &mut offset);"}, {"sha": "c8a7e646cd854cd8cbf634d0e34fbc7ca9a2803f", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -11,10 +11,13 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CodegenCx;\n+use rustc_target::abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n-                                     -> Option<Uniform> {\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n+                                     -> Option<Uniform>\n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout \n+{\n     arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n         if arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n@@ -38,7 +41,10 @@ fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgTyp\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout \n+{\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n@@ -72,7 +78,10 @@ fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout \n+{\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n@@ -95,7 +104,10 @@ fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)  \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout \n+{\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret);\n     }"}, {"sha": "873c2a1b40521f398a8e132c608ddc661d3babb5", "filename": "src/librustc_trans/cabi_wasm32.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_wasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_wasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_wasm32.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -9,19 +9,18 @@\n // except according to those terms.\n \n use abi::{FnType, ArgType};\n-use context::CodegenCx;\n \n-fn classify_ret_ty<'a, 'tcx>(_cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<Ty>(ret: &mut ArgType<Ty>) {\n     ret.extend_integer_width_to(32);\n }\n \n-fn classify_arg_ty(arg: &mut ArgType) {\n+fn classify_arg_ty<Ty>(arg: &mut ArgType<Ty>) {\n     arg.extend_integer_width_to(32);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<Ty>(fty: &mut FnType<Ty>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {"}, {"sha": "874ceb0be91853ffb98e72b19b589a746e125b99", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -9,26 +9,27 @@\n // except according to those terms.\n \n use abi::{ArgAttribute, FnType, LayoutExt, PassMode, Reg, RegKind};\n-use common::CodegenCx;\n-\n-use rustc::ty::layout::{self, TyLayout};\n+use rustc_target::abi::{self, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use rustc_target::spec::HasTargetSpec;\n \n #[derive(PartialEq)]\n pub enum Flavor {\n     General,\n     Fastcall\n }\n \n-fn is_single_fp_element<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                  layout: TyLayout<'tcx>) -> bool {\n+fn is_single_fp_element<'a, Ty, C>(cx: C, layout: TyLayout<'a, Ty>) -> bool\n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     match layout.abi {\n-        layout::Abi::Scalar(ref scalar) => {\n+        abi::Abi::Scalar(ref scalar) => {\n             match scalar.value {\n-                layout::F32 | layout::F64 => true,\n+                abi::F32 | abi::F64 => true,\n                 _ => false\n             }\n         }\n-        layout::Abi::Aggregate { .. } => {\n+        abi::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(cx, layout.field(cx, 0))\n             } else {\n@@ -39,9 +40,10 @@ fn is_single_fp_element<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                  fty: &mut FnType<'tcx>,\n-                                  flavor: Flavor) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>, flavor: Flavor) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n+{\n     if !fty.ret.is_ignore() {\n         if fty.ret.layout.is_aggregate() {\n             // Returning a structure. Most often, this will use\n@@ -51,7 +53,7 @@ pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             // Some links:\n             // http://www.angelcode.com/dev/callconv/callconv.html\n             // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n-            let t = &cx.sess().target.target;\n+            let t = cx.target_spec();\n             if t.options.abi_return_struct_as_int {\n                 // According to Clang, everyone but MSVC returns single-element\n                 // float aggregates directly in a floating-point register."}, {"sha": "cde6133f756f754a293819ed53799ce960b1ff27", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -12,9 +12,7 @@\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n use abi::{ArgType, CastTarget, FnType, LayoutExt, Reg, RegKind};\n-use context::CodegenCx;\n-\n-use rustc::ty::layout::{self, TyLayout, Size};\n+use rustc_target::abi::{self, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n \n /// Classification of \"eightbyte\" components.\n // NB: the order of the variants is from general to specific,\n@@ -33,13 +31,16 @@ struct Memory;\n const LARGEST_VECTOR_SIZE: usize = 512;\n const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n \n-fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n-                          -> Result<[Option<Class>; MAX_EIGHTBYTES], Memory> {\n-    fn classify<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                          layout: TyLayout<'tcx>,\n-                          cls: &mut [Option<Class>],\n-                          off: Size)\n-                          -> Result<(), Memory> {\n+fn classify_arg<'a, Ty, C>(cx: C, arg: &ArgType<'a, Ty>)\n+                          -> Result<[Option<Class>; MAX_EIGHTBYTES], Memory> \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n+    fn classify<'a, Ty, C>(cx: C, layout: TyLayout<'a, Ty>,\n+                          cls: &mut [Option<Class>], off: Size) -> Result<(), Memory> \n+        where Ty: TyLayoutMethods<'a, C> + Copy,\n+            C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+    {\n         if !off.is_abi_aligned(layout.align) {\n             if !layout.is_zst() {\n                 return Err(Memory);\n@@ -48,31 +49,31 @@ fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n         }\n \n         let mut c = match layout.abi {\n-            layout::Abi::Uninhabited => return Ok(()),\n+            abi::Abi::Uninhabited => return Ok(()),\n \n-            layout::Abi::Scalar(ref scalar) => {\n+            abi::Abi::Scalar(ref scalar) => {\n                 match scalar.value {\n-                    layout::Int(..) |\n-                    layout::Pointer => Class::Int,\n-                    layout::F32 |\n-                    layout::F64 => Class::Sse\n+                    abi::Int(..) |\n+                    abi::Pointer => Class::Int,\n+                    abi::F32 |\n+                    abi::F64 => Class::Sse\n                 }\n             }\n \n-            layout::Abi::Vector { .. } => Class::Sse,\n+            abi::Abi::Vector { .. } => Class::Sse,\n \n-            layout::Abi::ScalarPair(..) |\n-            layout::Abi::Aggregate { .. } => {\n+            abi::Abi::ScalarPair(..) |\n+            abi::Abi::Aggregate { .. } => {\n                 match layout.variants {\n-                    layout::Variants::Single { .. } => {\n+                    abi::Variants::Single { .. } => {\n                         for i in 0..layout.fields.count() {\n                             let field_off = off + layout.fields.offset(i);\n                             classify(cx, layout.field(cx, i), cls, field_off)?;\n                         }\n                         return Ok(());\n                     }\n-                    layout::Variants::Tagged { .. } |\n-                    layout::Variants::NicheFilling { .. } => return Err(Memory),\n+                    abi::Variants::Tagged { .. } |\n+                    abi::Variants::NicheFilling { .. } => return Err(Memory),\n                 }\n             }\n \n@@ -178,11 +179,14 @@ fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n     target\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>) \n+    where Ty: TyLayoutMethods<'a, C> + Copy,\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n     let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n     let mut sse_regs = 8; // XMM0-7\n \n-    let mut x86_64_ty = |arg: &mut ArgType<'tcx>, is_arg: bool| {\n+    let mut x86_64_ty = |arg: &mut ArgType<'a, Ty>, is_arg: bool| {\n         let mut cls_or_mem = classify_arg(cx, arg);\n \n         let mut needed_int = 0;"}, {"sha": "12578162fa12a22f8b5f272fcaec36e4ed934786", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -10,16 +10,16 @@\n \n use abi::{ArgType, FnType, Reg};\n \n-use rustc::ty::layout;\n+use rustc_target::abi;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n-pub fn compute_abi_info(fty: &mut FnType) {\n-    let fixup = |a: &mut ArgType| {\n+pub fn compute_abi_info<Ty>(fty: &mut FnType<Ty>) {\n+    let fixup = |a: &mut ArgType<Ty>| {\n         match a.layout.abi {\n-            layout::Abi::Uninhabited => {}\n-            layout::Abi::ScalarPair(..) |\n-            layout::Abi::Aggregate { .. } => {\n+            abi::Abi::Uninhabited => {}\n+            abi::Abi::ScalarPair(..) |\n+            abi::Abi::Aggregate { .. } => {\n                 match a.layout.size.bits() {\n                     8 => a.cast_to(Reg::i8()),\n                     16 => a.cast_to(Reg::i16()),\n@@ -28,11 +28,11 @@ pub fn compute_abi_info(fty: &mut FnType) {\n                     _ => a.make_indirect()\n                 }\n             }\n-            layout::Abi::Vector { .. } => {\n+            abi::Abi::Vector { .. } => {\n                 // FIXME(eddyb) there should be a size cap here\n                 // (probably what clang calls \"illegal vectors\").\n             }\n-            layout::Abi::Scalar(_) => {\n+            abi::Abi::Scalar(_) => {\n                 if a.layout.size.bytes() > 8 {\n                     a.make_indirect();\n                 } else {"}, {"sha": "76f8be9ee98a6c4ea72551e237e8c546d27daa96", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb15d447009f7b32cf435e0ad63bbbed5961e243/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=fb15d447009f7b32cf435e0ad63bbbed5961e243", "patch": "@@ -31,6 +31,7 @@ use rustc::session::Session;\n use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n+use rustc_target::spec::{HasTargetSpec, Target};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -453,6 +454,12 @@ impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CodegenCx<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> HasTargetSpec for &'a CodegenCx<'a, 'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.tcx.sess.target.target\n+    }\n+}\n+\n impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CodegenCx<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.tcx"}]}