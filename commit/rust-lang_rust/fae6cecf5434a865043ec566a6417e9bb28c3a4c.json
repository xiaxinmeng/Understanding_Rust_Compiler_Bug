{"sha": "fae6cecf5434a865043ec566a6417e9bb28c3a4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZTZjZWNmNTQzNGE4NjUwNDNlYzU2NmE2NDE3ZTliYjI4YzNhNGM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-01T08:21:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-01T08:21:17Z"}, "message": "Merge #3799\n\n3799: Streamline flycheck implementation r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "61d8ea097f59043803b9b66d7bba5f52ffddfc50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61d8ea097f59043803b9b66d7bba5f52ffddfc50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fae6cecf5434a865043ec566a6417e9bb28c3a4c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehE79CRBK7hj4Ov3rIwAAdHIIABEk/+ziuHeHWzrd6BUSQLWQ\nvpTdoCFpxz23+LJnWHO543adfZB4iOXOMN/X2PI3XKlrWTaH9lVKL85Mv8te82LJ\nZwDMK/KX7XdRZt/Va3ab3KceQQAbmB2lfemrh+twj6NFIuJ771WzbKBFyOQJ+kA/\njdYSgaHGhTXSum+UiCuqNOfKJK/tuB9WYO3NCmldXW0W7aVnFnTY9wLaQxVPO599\nGZHx0mYRwQ5qLYMd71jQubQbiQEr3K9FUGc1ELjIgA9zCTbuvfFLjCixlXkjwqA6\nEBUbX1dt/nC3AU2nFAseXEddH/JEwdklkpgXmR/K2CNHMKbdvQP9x9LMgzGRyik=\n=VNSS\n-----END PGP SIGNATURE-----\n", "payload": "tree 61d8ea097f59043803b9b66d7bba5f52ffddfc50\nparent f77fc158fc6502cede48c94bbabb040c77b38c08\nparent c86d8d40c2f17735e81b6d5d43b49950cbc9d86f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585729277 +0000\ncommitter GitHub <noreply@github.com> 1585729277 +0000\n\nMerge #3799\n\n3799: Streamline flycheck implementation r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fae6cecf5434a865043ec566a6417e9bb28c3a4c", "html_url": "https://github.com/rust-lang/rust/commit/fae6cecf5434a865043ec566a6417e9bb28c3a4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fae6cecf5434a865043ec566a6417e9bb28c3a4c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f77fc158fc6502cede48c94bbabb040c77b38c08", "url": "https://api.github.com/repos/rust-lang/rust/commits/f77fc158fc6502cede48c94bbabb040c77b38c08", "html_url": "https://github.com/rust-lang/rust/commit/f77fc158fc6502cede48c94bbabb040c77b38c08"}, {"sha": "c86d8d40c2f17735e81b6d5d43b49950cbc9d86f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c86d8d40c2f17735e81b6d5d43b49950cbc9d86f", "html_url": "https://github.com/rust-lang/rust/commit/c86d8d40c2f17735e81b6d5d43b49950cbc9d86f"}], "stats": {"total": 163, "additions": 76, "deletions": 87}, "files": [{"sha": "f6f9171add8eddfc38919ccea21e06be5811373e", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 76, "deletions": 87, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/fae6cecf5434a865043ec566a6417e9bb28c3a4c/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae6cecf5434a865043ec566a6417e9bb28c3a4c/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=fae6cecf5434a865043ec566a6417e9bb28c3a4c", "patch": "@@ -1,12 +1,8 @@\n //! cargo_check provides the functionality needed to run `cargo check` or\n //! another compatible command (f.x. clippy) in a background thread and provide\n //! LSP diagnostics based on the output of the command.\n-use cargo_metadata::Message;\n-use crossbeam_channel::{never, select, unbounded, Receiver, RecvError, Sender};\n-use lsp_types::{\n-    CodeAction, CodeActionOrCommand, Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin,\n-    WorkDoneProgressEnd, WorkDoneProgressReport,\n-};\n+mod conv;\n+\n use std::{\n     error, fmt,\n     io::{BufRead, BufReader},\n@@ -15,7 +11,12 @@ use std::{\n     time::Instant,\n };\n \n-mod conv;\n+use cargo_metadata::Message;\n+use crossbeam_channel::{never, select, unbounded, Receiver, RecvError, Sender};\n+use lsp_types::{\n+    CodeAction, CodeActionOrCommand, Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin,\n+    WorkDoneProgressEnd, WorkDoneProgressReport,\n+};\n \n use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic};\n \n@@ -78,17 +79,25 @@ pub enum CheckCommand {\n struct CheckWatcherThread {\n     options: CheckConfig,\n     workspace_root: PathBuf,\n-    watcher: WatchThread,\n     last_update_req: Option<Instant>,\n+    // XXX: drop order is significant\n+    message_recv: Receiver<CheckEvent>,\n+    /// WatchThread exists to wrap around the communication needed to be able to\n+    /// run `cargo check` without blocking. Currently the Rust standard library\n+    /// doesn't provide a way to read sub-process output without blocking, so we\n+    /// have to wrap sub-processes output handling in a thread and pass messages\n+    /// back over a channel.\n+    check_process: Option<jod_thread::JoinHandle<()>>,\n }\n \n impl CheckWatcherThread {\n     fn new(options: CheckConfig, workspace_root: PathBuf) -> CheckWatcherThread {\n         CheckWatcherThread {\n             options,\n             workspace_root,\n-            watcher: WatchThread::dummy(),\n             last_update_req: None,\n+            message_recv: never(),\n+            check_process: None,\n         }\n     }\n \n@@ -105,25 +114,21 @@ impl CheckWatcherThread {\n                         break;\n                     },\n                 },\n-                recv(self.watcher.message_recv) -> msg => match msg {\n+                recv(self.message_recv) -> msg => match msg {\n                     Ok(msg) => self.handle_message(msg, task_send),\n                     Err(RecvError) => {\n                         // Watcher finished, replace it with a never channel to\n                         // avoid busy-waiting.\n-                        std::mem::replace(&mut self.watcher.message_recv, never());\n+                        self.message_recv = never();\n+                        self.check_process = None;\n                     },\n                 }\n             };\n \n             if self.should_recheck() {\n-                self.last_update_req.take();\n+                self.last_update_req = None;\n                 task_send.send(CheckTask::ClearDiagnostics).unwrap();\n-\n-                // Replace with a dummy watcher first so we drop the original and wait for completion\n-                std::mem::replace(&mut self.watcher, WatchThread::dummy());\n-\n-                // Then create the actual new watcher\n-                self.watcher = WatchThread::new(&self.options, &self.workspace_root);\n+                self.restart_check_process();\n             }\n         }\n     }\n@@ -206,6 +211,59 @@ impl CheckWatcherThread {\n             CheckEvent::Msg(Message::Unknown) => {}\n         }\n     }\n+\n+    fn restart_check_process(&mut self) {\n+        // First, clear and cancel the old thread\n+        self.message_recv = never();\n+        self.check_process = None;\n+        if !self.options.enable {\n+            return;\n+        }\n+\n+        let mut args: Vec<String> = vec![\n+            self.options.command.clone(),\n+            \"--workspace\".to_string(),\n+            \"--message-format=json\".to_string(),\n+            \"--manifest-path\".to_string(),\n+            format!(\"{}/Cargo.toml\", self.workspace_root.display()),\n+        ];\n+        if self.options.all_targets {\n+            args.push(\"--all-targets\".to_string());\n+        }\n+        args.extend(self.options.args.iter().cloned());\n+\n+        let (message_send, message_recv) = unbounded();\n+        let workspace_root = self.workspace_root.to_owned();\n+        self.message_recv = message_recv;\n+        self.check_process = Some(jod_thread::spawn(move || {\n+            // If we trigger an error here, we will do so in the loop instead,\n+            // which will break out of the loop, and continue the shutdown\n+            let _ = message_send.send(CheckEvent::Begin);\n+\n+            let res = run_cargo(&args, Some(&workspace_root), &mut |message| {\n+                // Skip certain kinds of messages to only spend time on what's useful\n+                match &message {\n+                    Message::CompilerArtifact(artifact) if artifact.fresh => return true,\n+                    Message::BuildScriptExecuted(_) => return true,\n+                    Message::Unknown => return true,\n+                    _ => {}\n+                }\n+\n+                // if the send channel was closed, we want to shutdown\n+                message_send.send(CheckEvent::Msg(message)).is_ok()\n+            });\n+\n+            if let Err(err) = res {\n+                // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n+                // to display user-caused misconfiguration errors instead of just logging them here\n+                log::error!(\"Cargo watcher failed {:?}\", err);\n+            }\n+\n+            // We can ignore any error here, as we are already in the progress\n+            // of shutting down.\n+            let _ = message_send.send(CheckEvent::End);\n+        }))\n+    }\n }\n \n #[derive(Debug)]\n@@ -214,19 +272,6 @@ pub struct DiagnosticWithFixes {\n     fixes: Vec<CodeAction>,\n }\n \n-/// WatchThread exists to wrap around the communication needed to be able to\n-/// run `cargo check` without blocking. Currently the Rust standard library\n-/// doesn't provide a way to read sub-process output without blocking, so we\n-/// have to wrap sub-processes output handling in a thread and pass messages\n-/// back over a channel.\n-/// The correct way to dispose of the thread is to drop it, on which the\n-/// sub-process will be killed, and the thread will be joined.\n-struct WatchThread {\n-    // XXX: drop order is significant\n-    message_recv: Receiver<CheckEvent>,\n-    _handle: Option<jod_thread::JoinHandle<()>>,\n-}\n-\n enum CheckEvent {\n     Begin,\n     Msg(cargo_metadata::Message),\n@@ -316,59 +361,3 @@ fn run_cargo(\n \n     Err(CargoError(err_msg))\n }\n-\n-impl WatchThread {\n-    fn dummy() -> WatchThread {\n-        WatchThread { message_recv: never(), _handle: None }\n-    }\n-\n-    fn new(options: &CheckConfig, workspace_root: &Path) -> WatchThread {\n-        let mut args: Vec<String> = vec![\n-            options.command.clone(),\n-            \"--workspace\".to_string(),\n-            \"--message-format=json\".to_string(),\n-            \"--manifest-path\".to_string(),\n-            format!(\"{}/Cargo.toml\", workspace_root.display()),\n-        ];\n-        if options.all_targets {\n-            args.push(\"--all-targets\".to_string());\n-        }\n-        args.extend(options.args.iter().cloned());\n-\n-        let (message_send, message_recv) = unbounded();\n-        let workspace_root = workspace_root.to_owned();\n-        let handle = if options.enable {\n-            Some(jod_thread::spawn(move || {\n-                // If we trigger an error here, we will do so in the loop instead,\n-                // which will break out of the loop, and continue the shutdown\n-                let _ = message_send.send(CheckEvent::Begin);\n-\n-                let res = run_cargo(&args, Some(&workspace_root), &mut |message| {\n-                    // Skip certain kinds of messages to only spend time on what's useful\n-                    match &message {\n-                        Message::CompilerArtifact(artifact) if artifact.fresh => return true,\n-                        Message::BuildScriptExecuted(_) => return true,\n-                        Message::Unknown => return true,\n-                        _ => {}\n-                    }\n-\n-                    // if the send channel was closed, we want to shutdown\n-                    message_send.send(CheckEvent::Msg(message)).is_ok()\n-                });\n-\n-                if let Err(err) = res {\n-                    // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n-                    // to display user-caused misconfiguration errors instead of just logging them here\n-                    log::error!(\"Cargo watcher failed {:?}\", err);\n-                }\n-\n-                // We can ignore any error here, as we are already in the progress\n-                // of shutting down.\n-                let _ = message_send.send(CheckEvent::End);\n-            }))\n-        } else {\n-            None\n-        };\n-        WatchThread { message_recv, _handle: handle }\n-    }\n-}"}]}