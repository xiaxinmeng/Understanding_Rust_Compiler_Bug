{"sha": "920112d723e3d4162e72ad29070ebf9cf65feb38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMDExMmQ3MjNlM2Q0MTYyZTcyYWQyOTA3MGViZjljZjY1ZmViMzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-09T15:05:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-09T15:05:38Z"}, "message": "Auto merge of #3824 - phansch:adding_lints, r=phansch\n\nAdd lint writing documentation\n\n[Rendered](https://github.com/phansch/rust-clippy/blob/adding_lints/doc/adding_lints.md)\n\nThis adds a new documentation page that explains how to write Clippy\nlints. It guides the reader through creating a `foo` function lint.\n\nI plan to iterate a bit more on the prose of some sections, but I think the\ngeneral structure is fine now, so I'm looking forward to feedback =)\n\nOne thing I'm not sure about: I felt like this is too big for CONTRIBUTING.md\nso I put it into a new `doc/` directory. I can imagine having more\ndocumentation in the future, so we might even want to create a book using\nmdbook instead? Or should everything go into CONTRIBUTING.md?\n\nFurther things left to do:\n\n- [x] Link from CONTRIBUTING.md\n- [x] Remove things covered in this guide from CONTRIBUTING.md\n- [x] Section about `clippy::author` attribute\n- [x] Run `remark-lint` on CI over the `doc` directory and fix things", "tree": {"sha": "5d54b0d5d1607fc2f37f2f8bdc927e7a574849d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d54b0d5d1607fc2f37f2f8bdc927e7a574849d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/920112d723e3d4162e72ad29070ebf9cf65feb38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/920112d723e3d4162e72ad29070ebf9cf65feb38", "html_url": "https://github.com/rust-lang/rust/commit/920112d723e3d4162e72ad29070ebf9cf65feb38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/920112d723e3d4162e72ad29070ebf9cf65feb38/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccfbfb80975ff1233f664a50163cb5f983aab916", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccfbfb80975ff1233f664a50163cb5f983aab916", "html_url": "https://github.com/rust-lang/rust/commit/ccfbfb80975ff1233f664a50163cb5f983aab916"}, {"sha": "34685a5f6039ec406962730cf2613044a4d8f31c", "url": "https://api.github.com/repos/rust-lang/rust/commits/34685a5f6039ec406962730cf2613044a4d8f31c", "html_url": "https://github.com/rust-lang/rust/commit/34685a5f6039ec406962730cf2613044a4d8f31c"}], "stats": {"total": 572, "additions": 455, "deletions": 117}, "files": [{"sha": "3eff20cead74f36cf8acf5498f64db9553becad3", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 114, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/920112d723e3d4162e72ad29070ebf9cf65feb38/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/920112d723e3d4162e72ad29070ebf9cf65feb38/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=920112d723e3d4162e72ad29070ebf9cf65feb38", "patch": "@@ -14,11 +14,6 @@ All contributors are expected to follow the [Rust Code of Conduct](http://www.ru\n * [Getting started](#getting-started)\n   * [Finding something to fix/improve](#finding-something-to-fiximprove)\n * [Writing code](#writing-code)\n-  * [Author lint](#author-lint)\n-  * [Documentation](#documentation)\n-  * [Running test suite](#running-test-suite)\n-  * [Running rustfmt](#running-rustfmt)\n-  * [Testing manually](#testing-manually)\n * [How Clippy works](#how-clippy-works)\n * [Fixing nightly build failures](#fixing-build-failures-caused-by-rust)\n * [Issue and PR Triage](#issue-and-pr-triage)\n@@ -73,121 +68,15 @@ an AST expression). `match_def_path()` in Clippy's `utils` module can also be us\n \n ## Writing code\n \n-Clippy depends on the current git master version of rustc, which can change rapidly. Make sure you're\n-working near rust-clippy's master, and use the `setup-toolchain.sh` script to configure the appropriate\n-toolchain for this directory.\n-\n-[Llogiq's blog post on lints](https://llogiq.github.io/2015/06/04/workflows.html) is a nice primer\n-to lint-writing, though it does get into advanced stuff. Most lints consist of an implementation of\n-`LintPass` with one or more of its default methods overridden. See the existing lints for examples\n-of this.\n+Have a look at the [docs for writing lints](doc/adding_lints.md) for more details. [Llogiq's blog post on lints](https://llogiq.github.io/2015/06/04/workflows.html) is also a nice primer\n+to lint-writing, though it does get into advanced stuff and may be a bit\n+outdated.\n \n If you want to add a new lint or change existing ones apart from bugfixing, it's\n also a good idea to give the [stability guarantees][rfc_stability] and\n [lint categories][rfc_lint_cats] sections of the [Clippy 1.0 RFC][clippy_rfc] a\n quick read.\n \n-### Author lint\n-\n-There is also the internal `author` lint to generate Clippy code that detects the offending pattern. It does not work for all of the Rust syntax, but can give a good starting point.\n-\n-First, create a new UI test file in the `tests/ui/` directory with the pattern you want to match:\n-\n-```rust\n-// ./tests/ui/my_lint.rs\n-fn main() {\n-    #[clippy::author]\n-    let arr: [i32; 1] = [7]; // Replace line with the code you want to match\n-}\n-```\n-\n-Now you run `TESTNAME=ui/my_lint cargo uitest` to produce\n-a `.stdout` file with the generated code:\n-\n-```rust\n-// ./tests/ui/my_lint.stdout\n-\n-if_chain! {\n-    if let ExprKind::Array(ref elements) = stmt.node;\n-    if elements.len() == 1;\n-    if let ExprKind::Lit(ref lit) = elements[0].node;\n-    if let LitKind::Int(7, _) = lit.node;\n-    then {\n-        // report your lint here\n-    }\n-}\n-```\n-\n-If the command was executed successfully, you can copy the code over to where you are implementing your lint.\n-\n-### Documentation\n-\n-Please document your lint with a doc comment akin to the following:\n-\n-```rust\n-/// **What it does:** Checks for ... (describe what the lint matches).\n-///\n-/// **Why is this bad?** Supply the reason for linting the code.\n-///\n-/// **Known problems:** None. (Or describe where it could go wrong.)\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// // Bad\n-/// Insert a short example of code that triggers the lint\n-///\n-/// // Good\n-/// Insert a short example of improved code that doesn't trigger the lint\n-/// ```\n-```\n-\n-Once your lint is merged it will show up in the [lint list](https://rust-lang.github.io/rust-clippy/master/index.html)\n-\n-### Running test suite\n-\n-Use `cargo test` to run the whole testsuite.\n-\n-If you don't want to wait for all tests to finish, you can also execute a single test file by using `TESTNAME` to specify the test to run:\n-\n-```bash\n-TESTNAME=ui/empty_line_after_outer_attr cargo uitest\n-```\n-\n-Clippy uses UI tests. UI tests check that the output of the compiler is exactly as expected.\n-Of course there's little sense in writing the output yourself or copying it around.\n-Therefore you should use `tests/ui/update-all-references.sh` (after running\n-`cargo test`) and check whether the output looks as you expect with `git diff`. Commit all\n-`*.stderr` files, too.\n-\n-If the lint you are working on is making use of structured suggestions, the\n-test file should include a `// run-rustfix` comment at the top. This will\n-additionally run [rustfix](https://github.com/rust-lang-nursery/rustfix) for\n-that test. Rustfix will apply the suggestions from the lint to the code of the\n-test file and compare that to the contents of a `.fixed` file.\n-\n-Use `tests/ui/update-all-references.sh` to automatically generate the\n-`.fixed` file after running `cargo test`.\n-\n-### Running rustfmt\n-\n-[Rustfmt](https://github.com/rust-lang/rustfmt) is a tool for formatting Rust code according\n-to style guidelines. The code has to be formatted by `rustfmt` before a PR will be merged.\n-\n-It can be installed via `rustup`:\n-```bash\n-rustup component add rustfmt\n-```\n-\n-Use `cargo fmt --all` to format the whole codebase.\n-\n-### Testing manually\n-\n-Manually testing against an example file is useful if you have added some\n-`println!`s and test suite output becomes unreadable.  To try Clippy with your\n-local modifications, run `env CLIPPY_TESTS=true cargo run --bin clippy-driver -- -L ./target/debug input.rs`\n-from the working copy root.\n-\n ## How Clippy works\n \n Clippy is a [rustc compiler plugin][compiler_plugin]. The main entry point is at [`src/lib.rs`][main_entry]. In there, the lint registration is delegated to the [`clippy_lints`][lint_crate] crate."}, {"sha": "0fd7c557dd61019f5950a3d56c854de7568da867", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/920112d723e3d4162e72ad29070ebf9cf65feb38/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/920112d723e3d4162e72ad29070ebf9cf65feb38/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=920112d723e3d4162e72ad29070ebf9cf65feb38", "patch": "@@ -107,13 +107,13 @@ script:\n   - cargo clippy\n   # if you want the build job to fail when encountering warnings, use\n   - cargo clippy -- -D warnings\n-  # in order to also check tests and none-default crate features, use\n+  # in order to also check tests and non-default crate features, use\n   - cargo clippy --all-targets --all-features -- -D warnings\n   - cargo test\n   # etc.\n ```\n \n-It might happen that Clippy is not available for a certain nightly release.\n+If you are on nightly, It might happen that Clippy is not available for a certain nightly release.\n In this case you can try to conditionally install Clippy from the git repo.\n \n ```yaml"}, {"sha": "fbb5d1cba48dd4b59611d2be587f4e88cd50419e", "filename": "ci/base-tests.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/920112d723e3d4162e72ad29070ebf9cf65feb38/ci%2Fbase-tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/920112d723e3d4162e72ad29070ebf9cf65feb38/ci%2Fbase-tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fbase-tests.sh?ref=920112d723e3d4162e72ad29070ebf9cf65feb38", "patch": "@@ -4,7 +4,7 @@ echo \"Running clippy base tests\"\n \n PATH=$PATH:./node_modules/.bin\n if [ \"$TRAVIS_OS_NAME\" == \"linux\" ]; then\n-  remark -f *.md > /dev/null\n+  remark -f *.md -f doc/*.md > /dev/null\n fi\n # build clippy in debug mode and run tests\n cargo build --features debugging"}, {"sha": "53e671e17e034f2db5bf2965df39510fa38d156a", "filename": "doc/adding_lints.md", "status": "added", "additions": 449, "deletions": 0, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/920112d723e3d4162e72ad29070ebf9cf65feb38/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/920112d723e3d4162e72ad29070ebf9cf65feb38/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=920112d723e3d4162e72ad29070ebf9cf65feb38", "patch": "@@ -0,0 +1,449 @@\n+## Adding a new lint\n+\n+You are probably here because you want to add a new lint to Clippy. If this is\n+the first time you're contributing to Clippy, this document guides you through\n+creating an example lint from scratch.\n+\n+To get started, we will create a lint that detects functions called `foo`,\n+because that's clearly a non-descriptive name.\n+\n+* [Setup](#Setup)\n+* [Testing](#Testing)\n+* [Rustfix tests](#Rustfix-tests)\n+* [Lint declaration](#Lint-declaration)\n+* [Lint passes](#Lint-passes)\n+* [Emitting a lint](#Emitting-a-lint)\n+* [Adding the lint logic](#Adding-the-lint-logic)\n+* [Author lint](#Author-lint)\n+* [Documentation](#Documentation)\n+* [Running rustfmt](#Running-rustfmt)\n+* [Debugging](#Debugging)\n+* [PR Checklist](#PR-Checklist)\n+* [Cheatsheet](#Cheatsheet)\n+\n+### Setup\n+\n+When working on Clippy, you will need the current git master version of rustc,\n+which can change rapidly. Make sure you're working near rust-clippy's master,\n+and use the `setup-toolchain.sh` script to configure the appropriate toolchain\n+for the Clippy directory.\n+\n+### Testing\n+\n+Let's write some tests first that we can execute while we iterate on our lint.\n+\n+Clippy uses UI tests for testing. UI tests check that the output of Clippy is\n+exactly as expected. Each test is just a plain Rust file that contains the code\n+we want to check. The output of Clippy is compared against a `.stderr` file.\n+Note that you don't have to create this file yourself, we'll get to\n+generating the `.stderr` files further down.\n+\n+We start by creating the test file at `tests/ui/foo_functions.rs`. It doesn't\n+really matter what the file is called, but it's a good convention to name it\n+after the lint it is testing, so `foo_functions.rs` it is.\n+\n+Inside the file we put some examples to get started:\n+\n+```rust\n+#![warn(clippy::foo_functions)]\n+\n+// Impl methods\n+struct A;\n+impl A {\n+    pub fn fo(&self) {}\n+    pub fn foo(&self) {}\n+    pub fn food(&self) {}\n+}\n+\n+// Default trait methods\n+trait B {\n+    pub fn fo(&self) {}\n+    pub fn foo(&self) {}\n+    pub fn food(&self) {}\n+}\n+\n+// Plain functions\n+fn fo() {}\n+fn foo() {}\n+fn food() {}\n+\n+fn main() {\n+    // We also don't want to lint method calls\n+    foo();\n+    let a = A;\n+    a.foo();\n+}\n+\n+```\n+\n+Now we can run the test with `TESTNAME=ui/foo_functions cargo uitest`.\n+Currently this test will fail. If you go through the output you will see that we\n+are told that `clippy::foo_functions` is an unknown lint, which is expected.\n+\n+While we are working on implementing our lint, we can keep running the UI\n+test. That allows us to check if the output is turning into what we want.\n+\n+Once we are satisfied with the output, we need to run\n+`tests/ui/update-all-references.sh` to update the `.stderr` file for our lint.\n+Running `TESTNAME=ui/foo_functions cargo uitest` should pass then. When we\n+commit our lint, we need to commit the generated `.stderr` files, too.\n+\n+### Rustfix tests\n+\n+If the lint you are working on is making use of structured suggestions, the\n+test file should include a `// run-rustfix` comment at the top. This will\n+additionally run [rustfix](https://github.com/rust-lang-nursery/rustfix) for\n+that test. Rustfix will apply the suggestions from the lint to the code of the\n+test file and compare that to the contents of a `.fixed` file.\n+\n+Use `tests/ui/update-all-references.sh` to automatically generate the\n+`.fixed` file after running the tests.\n+\n+With tests in place, let's have a look at implementing our lint now.\n+\n+### Testing manually\n+\n+Manually testing against an example file can be useful if you have added some\n+`println!`s and the test suite output becomes unreadable. To try Clippy with\n+your local modifications, run `env CLIPPY_TESTS=true cargo run --bin\n+clippy-driver -- -L ./target/debug input.rs` from the working copy root.\n+\n+### Lint declaration\n+\n+We start by creating a new file in the `clippy_lints` crate. That's the crate\n+where all the lint code is. We are going to call the file\n+`clippy_lints/src/foo_functions.rs` and import some initial things we need:\n+\n+```rust\n+use rustc::lint::{LintArray, LintPass};\n+use rustc::{declare_tool_lint, lint_array};\n+```\n+\n+The next step is to provide a lint declaration. Lints are declared using the\n+[`declare_clippy_lint!`][declare_clippy_lint] macro:\n+\n+```rust\n+declare_clippy_lint! {\n+    pub FOO_FUNCTIONS,\n+    pedantic,\n+    \"function named `foo`, which is not a descriptive name\"\n+}\n+```\n+\n+* `FOO_FUNCTIONS` is the name of our lint. Be sure to follow the [lint naming\n+guidelines][lint_naming] here when naming your lint. In short, the name should\n+state the thing that is being checked for and read well when used with\n+`allow`/`warn`/`deny`.\n+* `pedantic` sets the lint level to `Allow`.\n+  The exact mapping can be found [here][category_level_mapping]\n+* The last part should be a text that explains what exactly is wrong with the\n+  code\n+\n+With our lint declaration done, we will now make sure that it is assigned to a\n+lint pass:\n+\n+```rust\n+// clippy_lints/src/foo_functions.rs\n+\n+// .. imports and lint declaration ..\n+\n+#[derive(Copy, Clone)]\n+pub struct FooFunctionsPass;\n+\n+impl LintPass for FooFunctionsPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(\n+            FOO_FUNCTIONS,\n+        )\n+    }\n+\n+    fn name(&self) -> &'static str {\n+        \"FooFunctions\"\n+    }\n+}\n+```\n+\n+Don't worry about the `name` method here. As long as it includes the name of the\n+lint pass it should be fine.\n+\n+Next we need to run `util/dev update_lints` to register the lint in various\n+places, mainly in `clippy_lints/src/lib.rs`.\n+\n+While `update_lints` automates some things, it doesn't automate everything. We\n+will have to register our lint pass manually in the `register_plugins` function\n+in `clippy_lints/src/lib.rs`:\n+\n+```rust\n+reg.register_early_lint_pass(box foo_functions::FooFunctionsPass);\n+```\n+\n+This should fix the `unknown clippy lint: clippy::foo_functions` error that we\n+saw when we executed our tests the first time. The next decision we have to make\n+is which lint pass our lint is going to need.\n+\n+### Lint passes\n+\n+Writing a lint that only checks for the name of a function means that we only\n+have to deal with the AST and don't have to deal with the type system at all.\n+This is good, because it makes writing this particular lint less complicated.\n+\n+We have to make this decision with every new Clippy lint. It boils down to using\n+either [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass].\n+\n+In short, the `LateLintPass` has access to type information while the\n+`EarlyLintPass` doesn't. If you don't need access to type information, use the\n+`EarlyLintPass`. The `EarlyLintPass` is also faster. However linting speed\n+hasn't really been a concern with Clippy so far.\n+\n+Since we don't need type information for checking the function name, we are\n+going to use the `EarlyLintPass`. It has to be imported as well, changing our\n+imports to:\n+\n+```rust\n+use rustc::lint::{LintArray, LintPass, EarlyLintPass, EarlyContext};\n+use rustc::{declare_tool_lint, lint_array};\n+```\n+\n+### Emitting a lint\n+\n+With UI tests and the lint declaration in place, we can start working on the\n+implementation of the lint logic.\n+\n+Let's start by implementing the `EarlyLintPass` for our `FooFunctionsPass`:\n+\n+```rust\n+impl EarlyLintPass for FooFunctionsPass {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: &FnDecl, span: Span, _: NodeId) {\n+        // TODO: Emit lint here\n+    }\n+}\n+```\n+\n+We implement the [`check_fn`][check_fn] method from the\n+[`EarlyLintPass`][early_lint_pass] trait. This gives us access to various\n+information about the function that is currently being checked. More on that in\n+the next section. Let's worry about the details later and emit our lint for\n+*every* function definition first.\n+\n+Depending on how complex we want our lint message to be, we can choose from a\n+variety of lint emission functions. They can all be found in\n+[`clippy_lints/src/utils/diagnostics.rs`][diagnostics].\n+\n+`span_help_and_lint` seems most appropriate in this case. It allows us to\n+provide an extra help message and we can't really suggest a better name\n+automatically. This is how it looks:\n+\n+```rust\n+impl EarlyLintPass for Pass {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, _: FnKind<'_>, _: &FnDecl, span: Span, _: NodeId) {\n+        span_help_and_lint(\n+            cx,\n+            FOO_FUNCTIONS,\n+            span,\n+            \"function named `foo`\",\n+            \"consider using a more meaningful name\"\n+        );\n+    }\n+}\n+```\n+\n+Running our UI test should now produce output that contains the lint message.\n+\n+### Adding the lint logic\n+\n+Writing the logic for your lint will most likely be different from our example,\n+so this section is kept rather short.\n+\n+Using the [`check_fn`][check_fn] method gives us access to [`FnKind`][fn_kind]\n+that has two relevant variants for us `FnKind::ItemFn` and `FnKind::Method`.\n+Both provide access to the name of the function/method via an [`Ident`][ident].\n+\n+With that we can expand our `check_fn` method to:\n+\n+```rust\n+impl EarlyLintPass for Pass {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: &FnDecl, span: Span, _: NodeId) {\n+        if is_foo_fn(fn_kind) {\n+            span_help_and_lint(\n+                cx,\n+                FOO_FUNCTIONS,\n+                span,\n+                \"function named `foo`\",\n+                \"consider using a more meaningful name\"\n+            );\n+        }\n+    }\n+}\n+```\n+\n+We separate the lint conditional from the lint emissions because it makes the\n+code a bit easier to read. In some cases this separation would also allow to\n+write some unit tests (as opposed to only UI tests) for the separate function.\n+\n+In our example, `is_foo_fn` looks like:\n+\n+```rust\n+// use statements, impl EarlyLintPass, check_fn, ..\n+\n+fn is_foo_fn(fn_kind: FnKind<'_>) -> bool {\n+    match fn_kind {\n+        FnKind::ItemFn(ident, ..) | FnKind::Method(ident, ..) => {\n+            ident.name == \"foo\"\n+        },\n+        FnKind::Closure(..) => false\n+    }\n+}\n+```\n+\n+Now we should also run the full test suite with `cargo test`. At this point\n+running `cargo test` should produce the expected output. Remember to run\n+`tests/ui/update-all-references.sh` to update the `.stderr` file.\n+\n+`cargo test` (as opposed to `cargo uitest`) will also ensure that our lint\n+implementation is not violating any Clippy lints itself.\n+\n+If you are still following the example, you will see that `FooFunctionsPass`\n+violates a Clippy lint. So we are going to rename that struct to just `Pass`:\n+\n+```rust\n+#[derive(Copy, Clone)]\n+pub struct Pass;\n+\n+impl LintPass for Pass { /* .. */ }\n+```\n+\n+That should be it for the lint implementation. Running `cargo test` should now\n+pass.\n+\n+### Author lint\n+\n+If you have trouble implementing your lint, there is also the internal `author`\n+lint to generate Clippy code that detects the offending pattern. It does not\n+work for all of the Rust syntax, but can give a good starting point.\n+\n+The quickest way to use it, is the [Rust playground][play].rust-lang.org).\n+Put the code you want to lint into the editor and add the `#[clippy::author]`\n+attribute above the item. Then run Clippy via `Tools -> Clippy` and you should\n+see the generated code in the output below.\n+\n+[Here][author_example] is an example on the playground.\n+\n+If the command was executed successfully, you can copy the code over to where\n+you are implementing your lint.\n+\n+### Documentation\n+\n+The final thing before submitting our PR is to add some documentation to our\n+lint declaration.\n+\n+Please document your lint with a doc comment akin to the following:\n+\n+```rust\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for ... (describe what the lint matches).\n+    ///\n+    /// **Why is this bad?** Supply the reason for linting the code.\n+    ///\n+    /// **Known problems:** None. (Or describe where it could go wrong.)\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// Insert a short example of code that triggers the lint\n+    ///\n+    /// // Good\n+    /// Insert a short example of improved code that doesn't trigger the lint\n+    /// ```\n+    pub FOO_FUNCTIONS,\n+    pedantic,\n+    \"function named `foo`, which is not a descriptive name\"\n+}\n+```\n+\n+Once your lint is merged, this documentation will show up in the [lint\n+list][lint_list].\n+\n+### Running rustfmt\n+\n+[Rustfmt](https://github.com/rust-lang/rustfmt) is a tool for formatting Rust code according\n+to style guidelines. Your code has to be formatted by `rustfmt` before a PR can be merged.\n+\n+It can be installed via `rustup`:\n+\n+```bash\n+rustup component add rustfmt\n+```\n+\n+Use `cargo fmt --all` to format the whole codebase.\n+\n+### Debugging\n+\n+If you want to debug parts of your lint implementation, you can use the `dbg!`\n+macro anywhere in your code. Running the tests should then include the debug\n+output in the `stdout` part.\n+\n+### PR Checklist\n+\n+Before submitting your PR make sure you followed all of the basic requirements:\n+\n+- [ ] Followed [lint naming conventions][lint_naming]\n+- [ ] Added passing UI tests (including committed `.stderr` file)\n+- [ ] `cargo test` passes locally\n+- [ ] Executed `util/dev update_lints`\n+- [ ] Added lint documentation\n+\n+### Cheatsheet\n+\n+Here are some pointers to things you are likely going to need for every lint:\n+\n+* [Clippy utils][utils] - Various helper functions. Maybe the function you need\n+  is already in here (`implements_trait`, `match_path`, `snippet`, etc)\n+* [Clippy diagnostics][diagnostics]\n+* [The `if_chain` macro][if_chain]\n+* [`in_macro`][in_macro] and [`in_external_macro`][in_external_macro]\n+* [`Span`][span]\n+* [`Applicability`][applicability]\n+* [The rustc guide][rustc_guide] explains a lot of internal compiler concepts\n+* [The nightly rustc docs][nightly_docs] which has been linked to throughout\n+  this guide\n+\n+For `EarlyLintPass` lints:\n+\n+* [`EarlyLintPass`][early_lint_pass]\n+* [`syntax::ast`][ast]\n+\n+For `LateLintPass` lints:\n+\n+* [`LateLintPass`][late_lint_pass]\n+* [`Ty::TyKind`][ty]\n+\n+\n+While most of Clippy's lint utils are documented, most of rustc's internals lack\n+documentation currently. This is unfortunate, but in most cases you can probably\n+get away with copying things from existing similar lints. If you are stuck,\n+don't hesitate to ask on Discord, IRC or in the issue/PR.\n+\n+[lint_list]: https://rust-lang.github.io/rust-clippy/master/index.html\n+[lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n+[category_level_mapping]: https://github.com/rust-lang/rust-clippy/blob/bd23cb89ec0ea63403a17d3fc5e50c88e38dd54f/clippy_lints/src/lib.rs#L43\n+[declare_clippy_lint]: https://github.com/rust-lang/rust-clippy/blob/a71acac1da7eaf667ab90a1d65d10e5cc4b80191/clippy_lints/src/lib.rs#L39\n+[compilation_stages]: https://rust-lang.github.io/rustc-guide/high-level-overview.html#the-main-stages-of-compilation\n+[check_fn]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.EarlyLintPass.html#method.check_fn\n+[early_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.EarlyLintPass.html\n+[late_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.LateLintPass.html\n+[fn_kind]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/visit/enum.FnKind.html\n+[diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/diagnostics.rs\n+[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/mod.rs\n+[ident]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/symbol/struct.Ident.html\n+[span]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax_pos/struct.Span.html\n+[applicability]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html\n+[if_chain]: https://docs.rs/if_chain/0.1.2/if_chain/\n+[ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/sty/index.html\n+[ast]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/index.html\n+[in_macro]: https://github.com/rust-lang/rust-clippy/blob/d0717d1f9531a03d154aaeb0cad94c243915a146/clippy_lints/src/utils/mod.rs#L94\n+[in_external_macro]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/fn.in_external_macro.html\n+[play]: https://play.rust-lang.org\n+[author_example]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f093b986e80ad62f3b67a1f24f5e66e2\n+[rustc_guide]: https://rust-lang.github.io/rustc-guide/\n+[nightly_docs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/"}]}