{"sha": "88591ba2399f29e7b9490eada7b1bbc0fbb22878", "node_id": "C_kwDOAAsO6NoAKDg4NTkxYmEyMzk5ZjI5ZTdiOTQ5MGVhZGE3YjFiYmMwZmJiMjI4Nzg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-30T04:04:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-30T04:04:08Z"}, "message": "Auto merge of #8666 - Jarcho:while_let_loop_7913, r=dswij\n\nDon't lint `while_let_loop` when significant drop order would change\n\nfixes #7226\nfixes #7913\nfixes #5717\n\nFor #5717 it may not stay fully fixed. This is only completely fixed right now due to all the allowed drop impls have `#[may_dangle]` on their drop impls. This may get changed in the future based on how significant drops are determined, but the example listed with `RefCell` shouldn't break.\n\nchangelog: Don't lint `while_let_loop` when the order of significant drops would change", "tree": {"sha": "cd96a13da066843018242b6694018a7a91495209", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd96a13da066843018242b6694018a7a91495209"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88591ba2399f29e7b9490eada7b1bbc0fbb22878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88591ba2399f29e7b9490eada7b1bbc0fbb22878", "html_url": "https://github.com/rust-lang/rust/commit/88591ba2399f29e7b9490eada7b1bbc0fbb22878", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88591ba2399f29e7b9490eada7b1bbc0fbb22878/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70f1d0d8fd702d8d761ce5c15df5b238ab59c250", "url": "https://api.github.com/repos/rust-lang/rust/commits/70f1d0d8fd702d8d761ce5c15df5b238ab59c250", "html_url": "https://github.com/rust-lang/rust/commit/70f1d0d8fd702d8d761ce5c15df5b238ab59c250"}, {"sha": "adbc8499d392f61cbc563895fe50a85ed8c63892", "url": "https://api.github.com/repos/rust-lang/rust/commits/adbc8499d392f61cbc563895fe50a85ed8c63892", "html_url": "https://github.com/rust-lang/rust/commit/adbc8499d392f61cbc563895fe50a85ed8c63892"}], "stats": {"total": 347, "additions": 207, "deletions": 140}, "files": [{"sha": "45af6be2653f3d4478fb026d65392fc191cccf1a", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 50, "deletions": 56, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/88591ba2399f29e7b9490eada7b1bbc0fbb22878/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88591ba2399f29e7b9490eada7b1bbc0fbb22878/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=88591ba2399f29e7b9490eada7b1bbc0fbb22878", "patch": "@@ -2,71 +2,60 @@ use super::WHILE_LET_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, MatchSource, Pat, StmtKind};\n-use rustc_lint::{LateContext, LintContext};\n-use rustc_middle::lint::in_external_macro;\n+use rustc_hir::{Block, Expr, ExprKind, Local, MatchSource, Pat, StmtKind};\n+use rustc_lint::LateContext;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n-    // extract the expression from the first statement (if any) in a block\n-    let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n-    // or extract the first expression (if any) from the block\n-    if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n-        if let Some(higher::IfLet {\n-            let_pat,\n-            let_expr,\n-            if_else: Some(if_else),\n-            ..\n-        }) = higher::IfLet::hir(cx, inner)\n-        {\n-            if is_simple_break_expr(if_else) {\n-                could_be_while_let(cx, expr, let_pat, let_expr);\n+    let (init, has_trailing_exprs) = match (loop_block.stmts, loop_block.expr) {\n+        ([stmt, stmts @ ..], expr) => {\n+            if let StmtKind::Local(&Local { init: Some(e), .. }) | StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind {\n+                (e, !stmts.is_empty() || expr.is_some())\n+            } else {\n+                return;\n             }\n-        }\n-\n-        if let ExprKind::Match(matchexpr, arms, MatchSource::Normal) = inner.kind {\n-            if arms.len() == 2\n-                && arms[0].guard.is_none()\n-                && arms[1].guard.is_none()\n-                && is_simple_break_expr(arms[1].body)\n-            {\n-                could_be_while_let(cx, expr, arms[0].pat, matchexpr);\n-            }\n-        }\n-    }\n-}\n+        },\n+        ([], Some(e)) => (e, false),\n+        _ => return,\n+    };\n \n-/// If a block begins with a statement (possibly a `let` binding) and has an\n-/// expression, return it.\n-fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    if let Some(first_stmt) = block.stmts.get(0) {\n-        if let StmtKind::Local(local) = first_stmt.kind {\n-            return local.init;\n-        }\n+    if let Some(if_let) = higher::IfLet::hir(cx, init)\n+        && let Some(else_expr) = if_let.if_else\n+        && is_simple_break_expr(else_expr)\n+    {\n+        could_be_while_let(cx, expr, if_let.let_pat, if_let.let_expr, has_trailing_exprs);\n+    } else if let ExprKind::Match(scrutinee, [arm1, arm2], MatchSource::Normal) = init.kind\n+        && arm1.guard.is_none()\n+        && arm2.guard.is_none()\n+        && is_simple_break_expr(arm2.body)\n+    {\n+        could_be_while_let(cx, expr, arm1.pat, scrutinee, has_trailing_exprs);\n     }\n-    None\n }\n \n-/// If a block begins with an expression (with or without semicolon), return it.\n-fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    match block.expr {\n-        Some(expr) if block.stmts.is_empty() => Some(expr),\n-        None if !block.stmts.is_empty() => match block.stmts[0].kind {\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => Some(expr),\n-            StmtKind::Local(..) | StmtKind::Item(..) => None,\n-        },\n-        _ => None,\n-    }\n+/// Returns `true` if expr contains a single break expression without a label or eub-expression.\n+fn is_simple_break_expr(e: &Expr<'_>) -> bool {\n+    matches!(peel_blocks(e).kind, ExprKind::Break(dest, None) if dest.label.is_none())\n }\n \n-/// Returns `true` if expr contains a single break expr without destination label\n-/// and\n-/// passed expression. The expression may be within a block.\n-fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprKind::Block(b, _) => extract_first_expr(b).map_or(false, is_simple_break_expr),\n-        _ => false,\n+/// Removes any blocks containing only a single expression.\n+fn peel_blocks<'tcx>(e: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    if let ExprKind::Block(b, _) = e.kind {\n+        match (b.stmts, b.expr) {\n+            ([s], None) => {\n+                if let StmtKind::Expr(e) | StmtKind::Semi(e) = s.kind {\n+                    peel_blocks(e)\n+                } else {\n+                    e\n+                }\n+            },\n+            ([], Some(e)) => peel_blocks(e),\n+            _ => e,\n+        }\n+    } else {\n+        e\n     }\n }\n \n@@ -75,8 +64,13 @@ fn could_be_while_let<'tcx>(\n     expr: &'tcx Expr<'_>,\n     let_pat: &'tcx Pat<'_>,\n     let_expr: &'tcx Expr<'_>,\n+    has_trailing_exprs: bool,\n ) {\n-    if in_external_macro(cx.sess(), expr.span) {\n+    if has_trailing_exprs\n+        && (needs_ordered_drop(cx, cx.typeck_results().expr_ty(let_expr))\n+            || any_temporaries_need_ordered_drop(cx, let_expr))\n+    {\n+        // Switching to a `while let` loop will extend the lifetime of some values.\n         return;\n     }\n "}, {"sha": "8499e050af2426898ede4a71210d0a4ef8451785", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 4, "deletions": 80, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/88591ba2399f29e7b9490eada7b1bbc0fbb22878/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88591ba2399f29e7b9490eada7b1bbc0fbb22878/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=88591ba2399f29e7b9490eada7b1bbc0fbb22878", "patch": "@@ -3,16 +3,13 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::needs_ordered_drop;\n-use clippy_utils::{higher, match_def_path};\n-use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n+use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n+use clippy_utils::{higher, is_lang_ctor, is_trait_method, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, PollPending};\n-use rustc_hir::{\n-    intravisit::{walk_expr, Visitor},\n-    Arm, Block, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp,\n-};\n+use rustc_hir::{Arm, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n use rustc_span::sym;\n@@ -47,79 +44,6 @@ fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n     }\n }\n \n-// Checks if there are any temporaries created in the given expression for which drop order\n-// matters.\n-fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    struct V<'a, 'tcx> {\n-        cx: &'a LateContext<'tcx>,\n-        res: bool,\n-    }\n-    impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n-        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-            match expr.kind {\n-                // Taking the reference of a value leaves a temporary\n-                // e.g. In `&String::new()` the string is a temporary value.\n-                // Remaining fields are temporary values\n-                // e.g. In `(String::new(), 0).1` the string is a temporary value.\n-                ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n-                    if !matches!(expr.kind, ExprKind::Path(_)) {\n-                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n-                            self.res = true;\n-                        } else {\n-                            self.visit_expr(expr);\n-                        }\n-                    }\n-                },\n-                // the base type is always taken by reference.\n-                // e.g. In `(vec![0])[0]` the vector is a temporary value.\n-                ExprKind::Index(base, index) => {\n-                    if !matches!(base.kind, ExprKind::Path(_)) {\n-                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n-                            self.res = true;\n-                        } else {\n-                            self.visit_expr(base);\n-                        }\n-                    }\n-                    self.visit_expr(index);\n-                },\n-                // Method calls can take self by reference.\n-                // e.g. In `String::new().len()` the string is a temporary value.\n-                ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n-                    if !matches!(self_arg.kind, ExprKind::Path(_)) {\n-                        let self_by_ref = self\n-                            .cx\n-                            .typeck_results()\n-                            .type_dependent_def_id(expr.hir_id)\n-                            .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n-                        if self_by_ref && needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n-                            self.res = true;\n-                        } else {\n-                            self.visit_expr(self_arg);\n-                        }\n-                    }\n-                    args.iter().for_each(|arg| self.visit_expr(arg));\n-                },\n-                // Either explicitly drops values, or changes control flow.\n-                ExprKind::DropTemps(_)\n-                | ExprKind::Ret(_)\n-                | ExprKind::Break(..)\n-                | ExprKind::Yield(..)\n-                | ExprKind::Block(Block { expr: None, .. }, _)\n-                | ExprKind::Loop(..) => (),\n-\n-                // Only consider the final expression.\n-                ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n-\n-                _ => walk_expr(self, expr),\n-            }\n-        }\n-    }\n-\n-    let mut v = V { cx, res: false };\n-    v.visit_expr(expr);\n-    v.res\n-}\n-\n fn find_sugg_for_if_let<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n@@ -191,7 +115,7 @@ fn find_sugg_for_if_let<'tcx>(\n     // scrutinee would be, so they have to be considered as well.\n     // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n     // for the duration if body.\n-    let needs_drop = needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n+    let needs_drop = needs_ordered_drop(cx, check_ty) || any_temporaries_need_ordered_drop(cx, let_expr);\n \n     // check that `while_let_on_iterator` lint does not trigger\n     if_chain! {"}, {"sha": "68cfa8c1aa8ec22e5a96a53e473759943cd018fa", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 127, "deletions": 4, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/88591ba2399f29e7b9490eada7b1bbc0fbb22878/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88591ba2399f29e7b9490eada7b1bbc0fbb22878/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=88591ba2399f29e7b9490eada7b1bbc0fbb22878", "patch": "@@ -1,16 +1,18 @@\n+use crate::ty::needs_ordered_drop;\n use crate::{get_enclosing_block, path_to_local_id};\n use core::ops::ControlFlow;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::intravisit::{self, walk_block, walk_expr, Visitor};\n use rustc_hir::{\n-    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Stmt, UnOp, UnsafeSource,\n-    Unsafety,\n+    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Let, QPath, Stmt, UnOp,\n+    UnsafeSource, Unsafety,\n };\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty;\n+use rustc_middle::ty::adjustment::Adjust;\n+use rustc_middle::ty::{self, Ty, TypeckResults};\n \n /// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n /// bodies (i.e. closures) are visited.\n@@ -494,3 +496,124 @@ pub fn for_each_local_use_after_expr<'tcx, B>(\n         ControlFlow::Continue(())\n     }\n }\n+\n+// Calls the given function for every unconsumed temporary created by the expression. Note the\n+// function is only guaranteed to be called for types which need to be dropped, but it may be called\n+// for other types.\n+pub fn for_each_unconsumed_temporary<'tcx, B>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'tcx>,\n+    mut f: impl FnMut(Ty<'tcx>) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    // Todo: Handle partially consumed values.\n+    fn helper<'tcx, B>(\n+        typeck: &'tcx TypeckResults<'tcx>,\n+        consume: bool,\n+        e: &'tcx Expr<'tcx>,\n+        f: &mut impl FnMut(Ty<'tcx>) -> ControlFlow<B>,\n+    ) -> ControlFlow<B> {\n+        if !consume\n+            || matches!(\n+                typeck.expr_adjustments(e),\n+                [adjust, ..] if matches!(adjust.kind, Adjust::Borrow(_) | Adjust::Deref(_))\n+            )\n+        {\n+            match e.kind {\n+                ExprKind::Path(QPath::Resolved(None, p))\n+                    if matches!(p.res, Res::Def(DefKind::Ctor(_, CtorKind::Const), _)) =>\n+                {\n+                    f(typeck.expr_ty(e))?;\n+                },\n+                ExprKind::Path(_)\n+                | ExprKind::Unary(UnOp::Deref, _)\n+                | ExprKind::Index(..)\n+                | ExprKind::Field(..)\n+                | ExprKind::AddrOf(..) => (),\n+                _ => f(typeck.expr_ty(e))?,\n+            }\n+        }\n+        match e.kind {\n+            ExprKind::AddrOf(_, _, e)\n+            | ExprKind::Field(e, _)\n+            | ExprKind::Unary(UnOp::Deref, e)\n+            | ExprKind::Match(e, ..)\n+            | ExprKind::Let(&Let { init: e, .. }) => {\n+                helper(typeck, false, e, f)?;\n+            },\n+            ExprKind::Block(&Block { expr: Some(e), .. }, _)\n+            | ExprKind::Box(e)\n+            | ExprKind::Cast(e, _)\n+            | ExprKind::Unary(_, e) => {\n+                helper(typeck, true, e, f)?;\n+            },\n+            ExprKind::Call(callee, args) => {\n+                helper(typeck, true, callee, f)?;\n+                for arg in args {\n+                    helper(typeck, true, arg, f)?;\n+                }\n+            },\n+            ExprKind::MethodCall(_, args, _) | ExprKind::Tup(args) | ExprKind::Array(args) => {\n+                for arg in args {\n+                    helper(typeck, true, arg, f)?;\n+                }\n+            },\n+            ExprKind::Index(borrowed, consumed)\n+            | ExprKind::Assign(borrowed, consumed, _)\n+            | ExprKind::AssignOp(_, borrowed, consumed) => {\n+                helper(typeck, false, borrowed, f)?;\n+                helper(typeck, true, consumed, f)?;\n+            },\n+            ExprKind::Binary(_, lhs, rhs) => {\n+                helper(typeck, true, lhs, f)?;\n+                helper(typeck, true, rhs, f)?;\n+            },\n+            ExprKind::Struct(_, fields, default) => {\n+                for field in fields {\n+                    helper(typeck, true, field.expr, f)?;\n+                }\n+                if let Some(default) = default {\n+                    helper(typeck, false, default, f)?;\n+                }\n+            },\n+            ExprKind::If(cond, then, else_expr) => {\n+                helper(typeck, true, cond, f)?;\n+                helper(typeck, true, then, f)?;\n+                if let Some(else_expr) = else_expr {\n+                    helper(typeck, true, else_expr, f)?;\n+                }\n+            },\n+            ExprKind::Type(e, _) => {\n+                helper(typeck, consume, e, f)?;\n+            },\n+\n+            // Either drops temporaries, jumps out of the current expression, or has no sub expression.\n+            ExprKind::DropTemps(_)\n+            | ExprKind::Ret(_)\n+            | ExprKind::Break(..)\n+            | ExprKind::Yield(..)\n+            | ExprKind::Block(..)\n+            | ExprKind::Loop(..)\n+            | ExprKind::Repeat(..)\n+            | ExprKind::Lit(_)\n+            | ExprKind::ConstBlock(_)\n+            | ExprKind::Closure { .. }\n+            | ExprKind::Path(_)\n+            | ExprKind::Continue(_)\n+            | ExprKind::InlineAsm(_)\n+            | ExprKind::Err => (),\n+        }\n+        ControlFlow::Continue(())\n+    }\n+    helper(cx.typeck_results(), true, e, &mut f)\n+}\n+\n+pub fn any_temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'tcx>) -> bool {\n+    for_each_unconsumed_temporary(cx, e, |ty| {\n+        if needs_ordered_drop(cx, ty) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    })\n+    .is_break()\n+}"}, {"sha": "c42e2a79a9bf9048dd19ea4942348a1df7695543", "filename": "tests/ui/while_let_loop.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/88591ba2399f29e7b9490eada7b1bbc0fbb22878/tests%2Fui%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88591ba2399f29e7b9490eada7b1bbc0fbb22878/tests%2Fui%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_loop.rs?ref=88591ba2399f29e7b9490eada7b1bbc0fbb22878", "patch": "@@ -117,3 +117,29 @@ fn issue1948() {\n         }\n     };\n }\n+\n+fn issue_7913(m: &std::sync::Mutex<Vec<u32>>) {\n+    // Don't lint. The lock shouldn't be held while printing.\n+    loop {\n+        let x = if let Some(x) = m.lock().unwrap().pop() {\n+            x\n+        } else {\n+            break;\n+        };\n+\n+        println!(\"{}\", x);\n+    }\n+}\n+\n+fn issue_5715(mut m: core::cell::RefCell<Option<u32>>) {\n+    // Don't lint. The temporary from `borrow_mut` must be dropped before overwriting the `RefCell`.\n+    loop {\n+        let x = if let &mut Some(x) = &mut *m.borrow_mut() {\n+            x\n+        } else {\n+            break;\n+        };\n+\n+        m = core::cell::RefCell::new(Some(x + 1));\n+    }\n+}"}]}