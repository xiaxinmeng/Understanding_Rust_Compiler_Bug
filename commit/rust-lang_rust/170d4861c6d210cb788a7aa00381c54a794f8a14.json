{"sha": "170d4861c6d210cb788a7aa00381c54a794f8a14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MGQ0ODYxYzZkMjEwY2I3ODhhN2FhMDAzODFjNTRhNzk0ZjhhMTQ=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-08-10T04:00:27Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-08-10T04:00:27Z"}, "message": "Simplify `wrong_self_convention` code\n\nUse actual types instead of hir types.", "tree": {"sha": "129d81343021c707d66a9250fa75174ba994be5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/129d81343021c707d66a9250fa75174ba994be5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/170d4861c6d210cb788a7aa00381c54a794f8a14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/170d4861c6d210cb788a7aa00381c54a794f8a14", "html_url": "https://github.com/rust-lang/rust/commit/170d4861c6d210cb788a7aa00381c54a794f8a14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/170d4861c6d210cb788a7aa00381c54a794f8a14/comments", "author": null, "committer": null, "parents": [{"sha": "ebd24985bfcde17223043165e49e73590c7b803c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd24985bfcde17223043165e49e73590c7b803c", "html_url": "https://github.com/rust-lang/rust/commit/ebd24985bfcde17223043165e49e73590c7b803c"}], "stats": {"total": 229, "additions": 76, "deletions": 153}, "files": [{"sha": "fcf5bbd0ab5013a146c10acc867f60e42022508c", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 76, "deletions": 153, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/170d4861c6d210cb788a7aa00381c54a794f8a14/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/170d4861c6d210cb788a7aa00381c54a794f8a14/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=170d4861c6d210cb788a7aa00381c54a794f8a14", "patch": "@@ -23,10 +23,10 @@ use crate::utils::sugg;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro, is_copy,\n-    is_ctor_function, is_expn_of, is_self, is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path,\n-    match_qpath, match_trait_method, match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty,\n-    same_tys, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+    is_ctor_function, is_expn_of, iter_input_pats, last_path_segment, match_def_path, match_qpath, match_trait_method,\n+    match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path,\n+    snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_sugg,\n+    span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1002,51 +1002,58 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n         let ty = cx.tcx.type_of(def_id);\n         if_chain! {\n             if let hir::ImplItemKind::Method(ref sig, id) = impl_item.node;\n-            if let Some(first_arg_ty) = sig.decl.inputs.get(0);\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n-            if let hir::ItemKind::Impl(_, _, _, _, None, ref self_ty, _) = item.node;\n+            if let hir::ItemKind::Impl(_, _, _, _, None, _, _) = item.node;\n             then {\n-                if cx.access_levels.is_exported(impl_item.hir_id) {\n-                // check missing trait implementations\n-                    for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                        if name == method_name &&\n-                        sig.decl.inputs.len() == n_args &&\n-                        out_type.matches(cx, &sig.decl.output) &&\n-                        self_kind.matches(cx, first_arg_ty, first_arg, self_ty, false, &impl_item.generics) {\n-                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n-                                \"defining a method called `{}` on this type; consider implementing \\\n-                                the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n-                        }\n-                    }\n-                }\n+                let method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n+                let method_sig = cx.tcx.fn_sig(method_def_id);\n+                let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n+\n+                let first_arg_ty = &method_sig.inputs().iter().next();\n \n                 // check conventions w.r.t. conversion method names and predicates\n-                let is_copy = is_copy(cx, ty);\n-                for &(ref conv, self_kinds) in &CONVENTIONS {\n-                    if conv.check(&name) {\n-                        if !self_kinds\n-                                .iter()\n-                                .any(|k| k.matches(cx, first_arg_ty, first_arg, self_ty, is_copy, &impl_item.generics)) {\n-                            let lint = if item.vis.node.is_pub() {\n-                                WRONG_PUB_SELF_CONVENTION\n-                            } else {\n-                                WRONG_SELF_CONVENTION\n-                            };\n-                            span_lint(cx,\n-                                      lint,\n-                                      first_arg.pat.span,\n-                                      &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n-                                                ambiguous name\",\n-                                               conv,\n-                                               &self_kinds.iter()\n-                                                          .map(|k| k.description())\n-                                                          .collect::<Vec<_>>()\n-                                                          .join(\" or \")));\n+                if let Some(first_arg_ty) = first_arg_ty {\n+\n+                    if cx.access_levels.is_exported(impl_item.hir_id) {\n+                    // check missing trait implementations\n+                        for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                            if name == method_name &&\n+                            sig.decl.inputs.len() == n_args &&\n+                            out_type.matches(cx, &sig.decl.output) &&\n+                            self_kind.matches(cx, ty, first_arg_ty) {\n+                                span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n+                                    \"defining a method called `{}` on this type; consider implementing \\\n+                                    the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                            }\n                         }\n+                    }\n \n-                        // Only check the first convention to match (CONVENTIONS should be listed from most to least\n-                        // specific)\n-                        break;\n+                    for &(ref conv, self_kinds) in &CONVENTIONS {\n+                        if conv.check(&name) {\n+                            if !self_kinds\n+                                    .iter()\n+                                    .any(|k| k.matches(cx, ty, first_arg_ty)) {\n+                                let lint = if item.vis.node.is_pub() {\n+                                    WRONG_PUB_SELF_CONVENTION\n+                                } else {\n+                                    WRONG_SELF_CONVENTION\n+                                };\n+                                span_lint(cx,\n+                                          lint,\n+                                          first_arg.pat.span,\n+                                          &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n+                                                    ambiguous name\",\n+                                                   conv,\n+                                                   &self_kinds.iter()\n+                                                              .map(|k| k.description())\n+                                                              .collect::<Vec<_>>()\n+                                                              .join(\" or \")));\n+                            }\n+\n+                            // Only check the first convention to match (CONVENTIONS should be listed from most to least\n+                            // specific)\n+                            break;\n+                        }\n                     }\n                 }\n             }\n@@ -2539,55 +2546,33 @@ enum SelfKind {\n }\n \n impl SelfKind {\n-    fn matches(\n-        self,\n-        cx: &LateContext<'_, '_>,\n-        ty: &hir::Ty,\n-        arg: &hir::Arg,\n-        self_ty: &hir::Ty,\n-        allow_value_for_ref: bool,\n-        generics: &hir::Generics,\n-    ) -> bool {\n-        // Self types in the HIR are desugared to explicit self types. So it will\n-        // always be `self:\n-        // SomeType`,\n-        // where SomeType can be `Self` or an explicit impl self type (e.g., `Foo` if\n-        // the impl is on `Foo`)\n-        // Thus, we only need to test equality against the impl self type or if it is\n-        // an explicit\n-        // `Self`. Furthermore, the only possible types for `self: ` are `&Self`,\n-        // `Self`, `&mut Self`,\n-        // and `Box<Self>`, including the equivalent types with `Foo`.\n-\n-        let is_actually_self = |ty| is_self_ty(ty) || SpanlessEq::new(cx).eq_ty(ty, self_ty);\n-        if is_self(arg) {\n-            match self {\n-                Self::Value => is_actually_self(ty),\n-                Self::Ref | Self::RefMut => {\n-                    if allow_value_for_ref && is_actually_self(ty) {\n-                        return true;\n-                    }\n-                    match ty.node {\n-                        hir::TyKind::Rptr(_, ref mt_ty) => {\n-                            let mutability_match = if self == Self::Ref {\n-                                mt_ty.mutbl == hir::MutImmutable\n-                            } else {\n-                                mt_ty.mutbl == hir::MutMutable\n-                            };\n-                            is_actually_self(&mt_ty.ty) && mutability_match\n-                        },\n-                        _ => false,\n-                    }\n-                },\n-                _ => false,\n-            }\n-        } else {\n-            match self {\n-                Self::Value => false,\n-                Self::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n-                Self::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n-                Self::No => true,\n+    fn matches<'a>(self, cx: &LateContext<'_, 'a>, parent_ty: Ty<'a>, ty: Ty<'a>) -> bool {\n+        fn matches_ref<'a>(\n+            cx: &LateContext<'_, 'a>,\n+            mutability: hir::Mutability,\n+            parent_ty: Ty<'a>,\n+            ty: Ty<'a>,\n+        ) -> bool {\n+            if let ty::Ref(_, t, m) = ty.sty {\n+                return m == mutability && t == parent_ty;\n             }\n+\n+            let trait_path = match mutability {\n+                hir::Mutability::MutImmutable => &paths::ASREF_TRAIT,\n+                hir::Mutability::MutMutable => &paths::ASMUT_TRAIT,\n+            };\n+\n+            let trait_def_id = get_trait_def_id(cx, trait_path).expect(\"trait def id not found\");\n+            implements_trait(cx, ty, trait_def_id, &[parent_ty.into()])\n+        }\n+\n+        match self {\n+            Self::Value => ty == parent_ty,\n+            Self::Ref => {\n+                matches_ref(cx, hir::Mutability::MutImmutable, parent_ty, ty) || ty == parent_ty && is_copy(cx, ty)\n+            },\n+            Self::RefMut => matches_ref(cx, hir::Mutability::MutMutable, parent_ty, ty),\n+            Self::No => ty != parent_ty,\n         }\n     }\n \n@@ -2601,68 +2586,6 @@ impl SelfKind {\n     }\n }\n \n-fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n-    single_segment_ty(ty).map_or(false, |seg| {\n-        generics.params.iter().any(|param| match param.kind {\n-            hir::GenericParamKind::Type { .. } => {\n-                param.name.ident().name == seg.ident.name\n-                    && param.bounds.iter().any(|bound| {\n-                        if let hir::GenericBound::Trait(ref ptr, ..) = *bound {\n-                            let path = &ptr.trait_ref.path;\n-                            match_path(path, name)\n-                                && path.segments.last().map_or(false, |s| {\n-                                    if let Some(ref params) = s.args {\n-                                        if params.parenthesized {\n-                                            false\n-                                        } else {\n-                                            // FIXME(flip1995): messy, improve if there is a better option\n-                                            // in the compiler\n-                                            let types: Vec<_> = params\n-                                                .args\n-                                                .iter()\n-                                                .filter_map(|arg| match arg {\n-                                                    hir::GenericArg::Type(ty) => Some(ty),\n-                                                    _ => None,\n-                                                })\n-                                                .collect();\n-                                            types.len() == 1 && (is_self_ty(&types[0]) || is_ty(&*types[0], self_ty))\n-                                        }\n-                                    } else {\n-                                        false\n-                                    }\n-                                })\n-                        } else {\n-                            false\n-                        }\n-                    })\n-            },\n-            _ => false,\n-        })\n-    })\n-}\n-\n-fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n-    match (&ty.node, &self_ty.node) {\n-        (\n-            &hir::TyKind::Path(hir::QPath::Resolved(_, ref ty_path)),\n-            &hir::TyKind::Path(hir::QPath::Resolved(_, ref self_ty_path)),\n-        ) => ty_path\n-            .segments\n-            .iter()\n-            .map(|seg| seg.ident.name)\n-            .eq(self_ty_path.segments.iter().map(|seg| seg.ident.name)),\n-        _ => false,\n-    }\n-}\n-\n-fn single_segment_ty(ty: &hir::Ty) -> Option<&hir::PathSegment> {\n-    if let hir::TyKind::Path(ref path) = ty.node {\n-        single_segment_path(path)\n-    } else {\n-        None\n-    }\n-}\n-\n impl Convention {\n     fn check(&self, other: &str) -> bool {\n         match *self {"}]}