{"sha": "5f18674c31540de79d26410bc09ca9c3a14ccc1e", "node_id": "C_kwDOAAsO6NoAKDVmMTg2NzRjMzE1NDBkZTc5ZDI2NDEwYmMwOWNhOWMzYTE0Y2NjMWU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-24T17:57:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-25T09:52:31Z"}, "message": "use rustc-build-sysroot instead of xargo", "tree": {"sha": "0ed993cf808331cf92842570b7e172059e974301", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ed993cf808331cf92842570b7e172059e974301"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f18674c31540de79d26410bc09ca9c3a14ccc1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f18674c31540de79d26410bc09ca9c3a14ccc1e", "html_url": "https://github.com/rust-lang/rust/commit/5f18674c31540de79d26410bc09ca9c3a14ccc1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f18674c31540de79d26410bc09ca9c3a14ccc1e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8683f50fb11779bd5d748255f0994627fbe5a71", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8683f50fb11779bd5d748255f0994627fbe5a71", "html_url": "https://github.com/rust-lang/rust/commit/e8683f50fb11779bd5d748255f0994627fbe5a71"}], "stats": {"total": 385, "additions": 166, "deletions": 219}, "files": [{"sha": "4cda24bb1894e5a4cccfdd54c5022fe6a557e5d7", "filename": "src/tools/miri/.github/workflows/ci.yml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml?ref=5f18674c31540de79d26410bc09ca9c3a14ccc1e", "patch": "@@ -57,15 +57,14 @@ jobs:\n             # contains package information of crates installed via `cargo install`.\n             ~/.cargo/.crates.toml\n             ~/.cargo/.crates2.json\n-          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock', 'cargo-miri/src/version.rs') }}\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n           restore-keys: ${{ runner.os }}-cargo\n \n-      - name: Install rustup-toolchain-install-master and xargo\n+      - name: Install rustup-toolchain-install-master\n         if: ${{ steps.cache.outputs.cache-hit == 'false' }}\n         shell: bash\n         run: |\n           cargo install -f rustup-toolchain-install-master\n-          cargo install -f xargo\n \n       - name: Install \"master\" toolchain\n         shell: bash"}, {"sha": "a88e69115ba38728fd01ff650bff5e9d75fdf6ae", "filename": "src/tools/miri/CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCONTRIBUTING.md?ref=5f18674c31540de79d26410bc09ca9c3a14ccc1e", "patch": "@@ -38,7 +38,7 @@ for you. If you don't want all of these to happen, you can add individual `.auto\n ## Building and testing Miri\n \n Invoking Miri requires getting a bunch of flags right and setting up a custom\n-sysroot with xargo. The `miri` script takes care of that for you. With the\n+sysroot. The `miri` script takes care of that for you. With the\n build environment prepared, compiling Miri is just one command away:\n \n ```"}, {"sha": "a1fc5b84406327db581c4226e3c0a914b207aac9", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=5f18674c31540de79d26410bc09ca9c3a14ccc1e", "patch": "@@ -447,7 +447,7 @@ binaries, and as such worth documenting:\n   some compiler flags to prepare the code for interpretation; with `host`, this is not done.\n   This environment variable is useful to be sure that the compiled `rlib`s are compatible\n   with Miri.\n-* `MIRI_CALLED_FROM_XARGO` is set during the Miri-induced `xargo` sysroot build,\n+* `MIRI_CALLED_FROM_SETUP` is set during the Miri sysroot build,\n   which will re-invoke `cargo-miri` as the `rustc` to use for this build.\n * `MIRI_CALLED_FROM_RUSTDOC` when set to any value tells `cargo-miri` that it is\n   running as a child process of `rustdoc`, which invokes it twice for each doc-test"}, {"sha": "1a99957f10fa62f9e6025b94169312114867e291", "filename": "src/tools/miri/cargo-miri/Cargo.lock", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.lock?ref=5f18674c31540de79d26410bc09ca9c3a14ccc1e", "patch": "@@ -35,6 +35,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata\",\n  \"directories\",\n+ \"rustc-build-sysroot\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"serde\",\n@@ -142,6 +143,12 @@ dependencies = [\n  \"percent-encoding\",\n ]\n \n+[[package]]\n+name = \"fuchsia-cprng\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba\"\n+\n [[package]]\n name = \"getrandom\"\n version = \"0.2.3\"\n@@ -322,6 +329,43 @@ dependencies = [\n  \"proc-macro2\",\n ]\n \n+[[package]]\n+name = \"rand\"\n+version = \"0.4.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"552840b97013b1a26992c11eac34bdd778e464601a4c2054b5f0bff7c6761293\"\n+dependencies = [\n+ \"fuchsia-cprng\",\n+ \"libc\",\n+ \"rand_core 0.3.1\",\n+ \"rdrand\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b\"\n+dependencies = [\n+ \"rand_core 0.4.2\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.4.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9c33a3c44ca05fa6f1807d8e6743f3824e8509beca625669633be0acbdf509dc\"\n+\n+[[package]]\n+name = \"rdrand\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2\"\n+dependencies = [\n+ \"rand_core 0.3.1\",\n+]\n+\n [[package]]\n name = \"redox_syscall\"\n version = \"0.2.10\"\n@@ -341,6 +385,26 @@ dependencies = [\n  \"redox_syscall\",\n ]\n \n+[[package]]\n+name = \"remove_dir_all\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3acd125665422973a33ac9d3dd2df85edad0f4ae9b00dafb1a05e43a9f5ef8e7\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"rustc-build-sysroot\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ea9e30aa5a34196fe1b2899704f1e1dccbc91fa0981f6c36b749899f924fcadd\"\n+dependencies = [\n+ \"anyhow\",\n+ \"rustc_version\",\n+ \"tempdir\",\n+]\n+\n [[package]]\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n@@ -419,6 +483,16 @@ dependencies = [\n  \"unicode-ident\",\n ]\n \n+[[package]]\n+name = \"tempdir\"\n+version = \"0.3.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"15f2b5fb00ccdf689e0149d1b1b3c03fead81c2b37735d812fa8bddbbf41b6d8\"\n+dependencies = [\n+ \"rand\",\n+ \"remove_dir_all\",\n+]\n+\n [[package]]\n name = \"thiserror\"\n version = \"1.0.30\""}, {"sha": "e9753d3369eebb37b1b721c250f788ef44c22ec4", "filename": "src/tools/miri/cargo-miri/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.toml?ref=5f18674c31540de79d26410bc09ca9c3a14ccc1e", "patch": "@@ -18,6 +18,7 @@ directories = \"3\"\n rustc_version = \"0.4\"\n serde_json = \"1.0.40\"\n cargo_metadata = \"0.15.0\"\n+rustc-build-sysroot = \"0.2.1\"\n \n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`"}, {"sha": "9b5fa7ae8736e2079b90850b8a3569e2e33f4816", "filename": "src/tools/miri/cargo-miri/src/main.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs?ref=5f18674c31540de79d26410bc09ca9c3a14ccc1e", "patch": "@@ -6,7 +6,6 @@ mod util;\n mod arg;\n mod phases;\n mod setup;\n-mod version;\n \n use std::{env, iter};\n \n@@ -22,8 +21,8 @@ fn main() {\n     // Dispatch to `cargo-miri` phase. Here is a rough idea of \"who calls who\".\n     //\n     // Initially, we are invoked as `cargo-miri miri run/test`. We first run the setup phase:\n-    // - We call `xargo`, and set `RUSTC` back to us, together with `MIRI_CALLED_FROM_XARGO`,\n-    //   so that xargo's rustc invocations end up in `phase_rustc` with `RustcPhase::Setup`.\n+    // - We use `rustc-build-sysroot`, and set `RUSTC` back to us, together with `MIRI_CALLED_FROM_SETUP`,\n+    //   so that the sysroot build rustc invocations end up in `phase_rustc` with `RustcPhase::Setup`.\n     //   There we then call the Miri driver with `MIRI_BE_RUSTC` to perform the actual build.\n     //\n     // Then we call `cargo run/test`, exactly forwarding all user flags, plus some configuration so\n@@ -52,7 +51,7 @@ fn main() {\n     //     the Miri driver for interpretation.\n \n     // Dispatch running as part of sysroot compilation.\n-    if env::var_os(\"MIRI_CALLED_FROM_XARGO\").is_some() {\n+    if env::var_os(\"MIRI_CALLED_FROM_SETUP\").is_some() {\n         phase_rustc(args, RustcPhase::Setup);\n         return;\n     }"}, {"sha": "a76bb447b9c9242b2c23bff766159793cadcebcd", "filename": "src/tools/miri/cargo-miri/src/phases.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs?ref=5f18674c31540de79d26410bc09ca9c3a14ccc1e", "patch": "@@ -7,6 +7,8 @@ use std::io::BufReader;\n use std::path::PathBuf;\n use std::process::Command;\n \n+use rustc_version::VersionMeta;\n+\n use crate::{setup::*, util::*};\n \n const CARGO_MIRI_HELP: &str = r#\"Runs binary crates and tests in Miri\n@@ -90,12 +92,14 @@ pub fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     let verbose = num_arg_flag(\"-v\");\n \n     // Determine the involved architectures.\n-    let host = version_info().host;\n+    let rustc_version = VersionMeta::for_command(miri_for_host())\n+        .expect(\"failed to determine underlying rustc version of Miri\");\n+    let host = &rustc_version.host;\n     let target = get_arg_flag_value(\"--target\");\n-    let target = target.as_ref().unwrap_or(&host);\n+    let target = target.as_ref().unwrap_or(host);\n \n     // We always setup.\n-    setup(&subcommand, &host, target);\n+    setup(&subcommand, target, &rustc_version);\n \n     // Invoke actual cargo for the job, but with different flags.\n     // We re-use `cargo test` and `cargo run`, which makes target and binary handling very easy but\n@@ -146,7 +150,7 @@ pub fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     if get_arg_flag_value(\"--target\").is_none() {\n         // No target given. Explicitly pick the host.\n         cmd.arg(\"--target\");\n-        cmd.arg(&host);\n+        cmd.arg(host);\n     }\n \n     // Set ourselves as runner for al binaries invoked by cargo.\n@@ -204,7 +208,7 @@ pub fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n \n #[derive(Debug, Copy, Clone, PartialEq)]\n pub enum RustcPhase {\n-    /// `rustc` called via `xargo` for sysroot build.\n+    /// `rustc` called during sysroot build.\n     Setup,\n     /// `rustc` called by `cargo` for regular build.\n     Build,\n@@ -264,7 +268,7 @@ pub fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n     let verbose = std::env::var(\"MIRI_VERBOSE\")\n         .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n     let target_crate = is_target_crate();\n-    // Determine whether this is cargo/xargo invoking rustc to get some infos.\n+    // Determine whether this is cargo invoking rustc to get some infos.\n     let info_query = get_arg_flag_value(\"--print\").is_some() || has_arg_flag(\"-vV\");\n \n     let store_json = |info: CrateRunInfo| {"}, {"sha": "72d8ef2f752248d0cd7a7187b40957768e61ebf7", "filename": "src/tools/miri/cargo-miri/src/setup.rs", "status": "modified", "additions": 73, "deletions": 174, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs?ref=5f18674c31540de79d26410bc09ca9c3a14ccc1e", "patch": "@@ -1,64 +1,19 @@\n-//! Implements `cargo miri setup` via xargo\n+//! Implements `cargo miri setup`.\n \n use std::env;\n use std::ffi::OsStr;\n-use std::fs::{self};\n-use std::io::BufRead;\n-use std::ops::Not;\n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n use std::process::{self, Command};\n \n-use crate::{util::*, version::*};\n+use rustc_build_sysroot::{BuildMode, Sysroot, SysrootConfig};\n+use rustc_version::VersionMeta;\n \n-fn xargo_version() -> Option<(u32, u32, u32)> {\n-    let out = xargo_check().arg(\"--version\").output().ok()?;\n-    if !out.status.success() {\n-        return None;\n-    }\n-    // Parse output. The first line looks like \"xargo 0.3.12 (b004f1c 2018-12-13)\".\n-    let line = out\n-        .stderr\n-        .lines()\n-        .next()\n-        .expect(\"malformed `xargo --version` output: not at least one line\")\n-        .expect(\"malformed `xargo --version` output: error reading first line\");\n-    let (name, version) = {\n-        let mut split = line.split(' ');\n-        (\n-            split.next().expect(\"malformed `xargo --version` output: empty\"),\n-            split.next().expect(\"malformed `xargo --version` output: not at least two words\"),\n-        )\n-    };\n-    if name != \"xargo\" {\n-        // This is some fork of xargo\n-        return None;\n-    }\n-    let mut version_pieces = version.split('.');\n-    let major = version_pieces\n-        .next()\n-        .expect(\"malformed `xargo --version` output: not a major version piece\")\n-        .parse()\n-        .expect(\"malformed `xargo --version` output: major version is not an integer\");\n-    let minor = version_pieces\n-        .next()\n-        .expect(\"malformed `xargo --version` output: not a minor version piece\")\n-        .parse()\n-        .expect(\"malformed `xargo --version` output: minor version is not an integer\");\n-    let patch = version_pieces\n-        .next()\n-        .expect(\"malformed `xargo --version` output: not a patch version piece\")\n-        .parse()\n-        .expect(\"malformed `xargo --version` output: patch version is not an integer\");\n-    if version_pieces.next().is_some() {\n-        panic!(\"malformed `xargo --version` output: more than three pieces in version\");\n-    }\n-    Some((major, minor, patch))\n-}\n+use crate::util::*;\n \n /// Performs the setup required to make `cargo miri` work: Getting a custom-built libstd. Then sets\n /// `MIRI_SYSROOT`. Skipped if `MIRI_SYSROOT` is already set, in which case we expect the user has\n /// done all this already.\n-pub fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n+pub fn setup(subcommand: &MiriCommand, target: &str, rustc_version: &VersionMeta) {\n     let only_setup = matches!(subcommand, MiriCommand::Setup);\n     let ask_user = !only_setup;\n     let print_sysroot = only_setup && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n@@ -69,21 +24,8 @@ pub fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n         return;\n     }\n \n-    // First, we need xargo.\n-    if xargo_version().map_or(true, |v| v < XARGO_MIN_VERSION) {\n-        if std::env::var_os(\"XARGO_CHECK\").is_some() {\n-            // The user manually gave us a xargo binary; don't do anything automatically.\n-            show_error!(\"xargo is too old; please upgrade to the latest version\")\n-        }\n-        let mut cmd = cargo();\n-        cmd.args([\"install\", \"xargo\"]);\n-        ask_to_run(cmd, ask_user, \"install a recent enough xargo\");\n-    }\n-\n-    // Determine where the rust sources are located.  The env vars manually setting the source\n-    // (`MIRI_LIB_SRC`, `XARGO_RUST_SRC`) trump auto-detection.\n-    let rust_src_env_var =\n-        std::env::var_os(\"MIRI_LIB_SRC\").or_else(|| std::env::var_os(\"XARGO_RUST_SRC\"));\n+    // Determine where the rust sources are located.  The env var trumps auto-detection.\n+    let rust_src_env_var = std::env::var_os(\"MIRI_LIB_SRC\");\n     let rust_src = match rust_src_env_var {\n         Some(path) => {\n             let path = PathBuf::from(path);\n@@ -92,22 +34,9 @@ pub fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n         }\n         None => {\n             // Check for `rust-src` rustup component.\n-            let output = miri_for_host()\n-                .args([\"--print\", \"sysroot\"])\n-                .output()\n-                .expect(\"failed to determine sysroot\");\n-            if !output.status.success() {\n-                show_error!(\n-                    \"Failed to determine sysroot; Miri said:\\n{}\",\n-                    String::from_utf8_lossy(&output.stderr).trim_end()\n-                );\n-            }\n-            let sysroot = std::str::from_utf8(&output.stdout).unwrap();\n-            let sysroot = Path::new(sysroot.trim_end_matches('\\n'));\n-            // Check for `$SYSROOT/lib/rustlib/src/rust/library`; test if that contains `std/Cargo.toml`.\n-            let rustup_src =\n-                sysroot.join(\"lib\").join(\"rustlib\").join(\"src\").join(\"rust\").join(\"library\");\n-            if !rustup_src.join(\"std\").join(\"Cargo.toml\").exists() {\n+            let rustup_src = rustc_build_sysroot::rustc_sysroot_src(miri_for_host())\n+                .expect(\"could not determine sysroot source directory\");\n+            if !rustup_src.exists() {\n                 // Ask the user to install the `rust-src` component, and use that.\n                 let mut cmd = Command::new(\"rustup\");\n                 cmd.args([\"component\", \"add\", \"rust-src\"]);\n@@ -131,115 +60,85 @@ pub fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n         );\n     }\n \n-    // Next, we need our own libstd. Prepare a xargo project for that purpose.\n-    // We will do this work in whatever is a good cache dir for this platform.\n-    let dirs = directories::ProjectDirs::from(\"org\", \"rust-lang\", \"miri\").unwrap();\n-    let dir = dirs.cache_dir();\n-    if !dir.exists() {\n-        fs::create_dir_all(dir).unwrap();\n-    }\n-    // The interesting bit: Xargo.toml (only needs content if we actually need std)\n-    let xargo_toml = if std::env::var_os(\"MIRI_NO_STD\").is_some() {\n-        \"\"\n+    // Determine where to put the sysroot.\n+    let user_dirs = directories::ProjectDirs::from(\"org\", \"rust-lang\", \"miri\").unwrap();\n+    let sysroot_dir = user_dirs.cache_dir();\n+    // Sysroot configuration and build details.\n+    let sysroot_config = if std::env::var_os(\"MIRI_NO_STD\").is_some() {\n+        SysrootConfig::NoStd\n     } else {\n-        r#\"\n-[dependencies.std]\n-default_features = false\n-# We support unwinding, so enable that panic runtime.\n-features = [\"panic_unwind\", \"backtrace\"]\n-\n-[dependencies.test]\n-\"#\n+        SysrootConfig::WithStd { std_features: &[\"panic_unwind\", \"backtrace\"] }\n     };\n-    write_to_file(&dir.join(\"Xargo.toml\"), xargo_toml);\n-    // The boring bits: a dummy project for xargo.\n-    // FIXME: With xargo-check, can we avoid doing this?\n-    write_to_file(\n-        &dir.join(\"Cargo.toml\"),\n-        r#\"\n-[package]\n-name = \"miri-xargo\"\n-description = \"A dummy project for building libstd with xargo.\"\n-version = \"0.0.0\"\n-\n-[lib]\n-path = \"lib.rs\"\n-\"#,\n-    );\n-    write_to_file(&dir.join(\"lib.rs\"), \"#![no_std]\");\n+    let cargo_cmd = || {\n+        let mut command = cargo();\n+        // Use Miri as rustc to build a libstd compatible with us (and use the right flags).\n+        // However, when we are running in bootstrap, we cannot just overwrite `RUSTC`,\n+        // because we still need bootstrap to distinguish between host and target crates.\n+        // In that case we overwrite `RUSTC_REAL` instead which determines the rustc used\n+        // for target crates.\n+        // We set ourselves (`cargo-miri`) instead of Miri directly to be able to patch the flags\n+        // for `libpanic_abort` (usually this is done by bootstrap but we have to do it ourselves).\n+        // The `MIRI_CALLED_FROM_SETUP` will mean we dispatch to `phase_setup_rustc`.\n+        let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n+        if env::var_os(\"RUSTC_STAGE\").is_some() {\n+            assert!(env::var_os(\"RUSTC\").is_some());\n+            command.env(\"RUSTC_REAL\", &cargo_miri_path);\n+        } else {\n+            command.env(\"RUSTC\", &cargo_miri_path);\n+        }\n+        command.env(\"MIRI_CALLED_FROM_SETUP\", \"1\");\n+        // Make sure there are no other wrappers getting in our way (Cc\n+        // https://github.com/rust-lang/miri/issues/1421,\n+        // https://github.com/rust-lang/miri/issues/2429). Looks like setting\n+        // `RUSTC_WRAPPER` to the empty string overwrites `build.rustc-wrapper` set via\n+        // `config.toml`.\n+        command.env(\"RUSTC_WRAPPER\", \"\");\n \n-    // Figure out where xargo will build its stuff.\n-    // Unfortunately, it puts things into a different directory when the\n-    // architecture matches the host.\n-    let sysroot = if target == host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n+        if only_setup {\n+            if print_sysroot {\n+                // Be extra sure there is no noise on stdout.\n+                command.stdout(process::Stdio::null());\n+            }\n+        } else {\n+            command.stdout(process::Stdio::null());\n+            command.stderr(process::Stdio::null());\n+        }\n+        // Disable debug assertions in the standard library -- Miri is already slow enough.\n+        // But keep the overflow checks, they are cheap. This completely overwrites flags\n+        // the user might have set, which is consistent with normal `cargo build` that does\n+        // not apply `RUSTFLAGS` to the sysroot either.\n+        let rustflags = vec![\"-Cdebug-assertions=off\".into(), \"-Coverflow-checks=on\".into()];\n+        (command, rustflags)\n+    };\n     // Make sure all target-level Miri invocations know their sysroot.\n-    std::env::set_var(\"MIRI_SYSROOT\", &sysroot);\n+    std::env::set_var(\"MIRI_SYSROOT\", sysroot_dir);\n \n-    // Now invoke xargo.\n-    let mut command = xargo_check();\n-    command.arg(\"check\").arg(\"-q\");\n-    command.current_dir(dir);\n-    command.env(\"XARGO_HOME\", dir);\n-    command.env(\"XARGO_RUST_SRC\", &rust_src);\n-    // We always need to set a target so rustc bootstrap can tell apart host from target crates.\n-    command.arg(\"--target\").arg(target);\n-    // Use Miri as rustc to build a libstd compatible with us (and use the right flags).\n-    // However, when we are running in bootstrap, we cannot just overwrite `RUSTC`,\n-    // because we still need bootstrap to distinguish between host and target crates.\n-    // In that case we overwrite `RUSTC_REAL` instead which determines the rustc used\n-    // for target crates.\n-    // We set ourselves (`cargo-miri`) instead of Miri directly to be able to patch the flags\n-    // for `libpanic_abort` (usually this is done by bootstrap but we have to do it ourselves).\n-    // The `MIRI_CALLED_FROM_XARGO` will mean we dispatch to `phase_setup_rustc`.\n-    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n-    if env::var_os(\"RUSTC_STAGE\").is_some() {\n-        assert!(env::var_os(\"RUSTC\").is_some());\n-        command.env(\"RUSTC_REAL\", &cargo_miri_path);\n-    } else {\n-        command.env(\"RUSTC\", &cargo_miri_path);\n-    }\n-    command.env(\"MIRI_CALLED_FROM_XARGO\", \"1\");\n-    // Make sure there are no other wrappers getting in our way\n-    // (Cc https://github.com/rust-lang/miri/issues/1421, https://github.com/rust-lang/miri/issues/2429).\n-    // Looks like setting `RUSTC_WRAPPER` to the empty string overwrites `build.rustc-wrapper` set via `config.toml`.\n-    command.env(\"RUSTC_WRAPPER\", \"\");\n-    // Disable debug assertions in the standard library -- Miri is already slow enough. But keep the\n-    // overflow checks, they are cheap. This completely overwrites flags the user might have set,\n-    // which is consistent with normal `cargo build` that does not apply `RUSTFLAGS` to the sysroot\n-    // either.\n-    command.env(\"RUSTFLAGS\", \"-Cdebug-assertions=off -Coverflow-checks=on\");\n-    // Manage the output the user sees.\n+    // Do the build.\n     if only_setup {\n         // We want to be explicit.\n         eprintln!(\"Preparing a sysroot for Miri (target: {target})...\");\n-        if print_sysroot {\n-            // Be extra sure there is no noise on stdout.\n-            command.stdout(process::Stdio::null());\n-        }\n     } else {\n         // We want to be quiet, but still let the user know that something is happening.\n         eprint!(\"Preparing a sysroot for Miri (target: {target})... \");\n-        command.stdout(process::Stdio::null());\n-        command.stderr(process::Stdio::null());\n     }\n-\n-    // Finally run it!\n-    if command.status().expect(\"failed to run xargo\").success().not() {\n-        if only_setup {\n-            show_error!(\"failed to run xargo, see error details above\")\n-        } else {\n-            show_error!(\"failed to run xargo; run `cargo miri setup` to see the error details\")\n-        }\n-    }\n-\n-    // Figure out what to print.\n+    Sysroot::new(sysroot_dir, target)\n+        .build_from_source(&rust_src, BuildMode::Check, sysroot_config, rustc_version, cargo_cmd)\n+        .unwrap_or_else(|_| {\n+            if only_setup {\n+                show_error!(\"failed to build sysroot, see error details above\")\n+            } else {\n+                show_error!(\n+                    \"failed to build sysroot; run `cargo miri setup` to see the error details\"\n+                )\n+            }\n+        });\n     if only_setup {\n-        eprintln!(\"A sysroot for Miri is now available in `{}`.\", sysroot.display());\n+        eprintln!(\"A sysroot for Miri is now available in `{}`.\", sysroot_dir.display());\n     } else {\n         eprintln!(\"done\");\n     }\n     if print_sysroot {\n         // Print just the sysroot and nothing else to stdout; this way we do not need any escaping.\n-        println!(\"{}\", sysroot.display());\n+        println!(\"{}\", sysroot_dir.display());\n     }\n }"}, {"sha": "aabe5547e5c9a9e26caf73aa7e3ae56e1bbb02d5", "filename": "src/tools/miri/cargo-miri/src/util.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f18674c31540de79d26410bc09ca9c3a14ccc1e/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Futil.rs?ref=5f18674c31540de79d26410bc09ca9c3a14ccc1e", "patch": "@@ -2,14 +2,13 @@ use std::collections::HashMap;\n use std::env;\n use std::ffi::OsString;\n use std::fmt::Write as _;\n-use std::fs::{self, File};\n+use std::fs::File;\n use std::io::{self, BufWriter, Read, Write};\n use std::ops::Not;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use cargo_metadata::{Metadata, MetadataCommand};\n-use rustc_version::VersionMeta;\n use serde::{Deserialize, Serialize};\n \n pub use crate::arg::*;\n@@ -111,19 +110,10 @@ pub fn miri_for_host() -> Command {\n     cmd\n }\n \n-pub fn version_info() -> VersionMeta {\n-    VersionMeta::for_command(miri_for_host())\n-        .expect(\"failed to determine underlying rustc version of Miri\")\n-}\n-\n pub fn cargo() -> Command {\n     Command::new(env::var_os(\"CARGO\").unwrap_or_else(|| OsString::from(\"cargo\")))\n }\n \n-pub fn xargo_check() -> Command {\n-    Command::new(env::var_os(\"XARGO_CHECK\").unwrap_or_else(|| OsString::from(\"xargo-check\")))\n-}\n-\n /// Execute the `Command`, where possible by replacing the current process with a new process\n /// described by the `Command`. Then exit this process with the exit code of the new process.\n pub fn exec(mut cmd: Command) -> ! {\n@@ -203,23 +193,6 @@ pub fn ask_to_run(mut cmd: Command, ask: bool, text: &str) {\n     }\n }\n \n-/// Writes the given content to the given file *cross-process atomically*, in the sense that another\n-/// process concurrently reading that file will see either the old content or the new content, but\n-/// not some intermediate (e.g., empty) state.\n-///\n-/// We assume no other parts of this same process are trying to read or write that file.\n-pub fn write_to_file(filename: &Path, content: &str) {\n-    // Create a temporary file with the desired contents.\n-    let mut temp_filename = filename.as_os_str().to_os_string();\n-    temp_filename.push(&format!(\".{}\", std::process::id()));\n-    let mut temp_file = File::create(&temp_filename).unwrap();\n-    temp_file.write_all(content.as_bytes()).unwrap();\n-    drop(temp_file);\n-\n-    // Move file to the desired location.\n-    fs::rename(temp_filename, filename).unwrap();\n-}\n-\n // Computes the extra flags that need to be passed to cargo to make it behave like the current\n // cargo invocation.\n fn cargo_extra_flags() -> Vec<String> {"}, {"sha": "366e90df179835ed89d6dffc5932e724a7d4a136", "filename": "src/tools/miri/cargo-miri/src/version.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8683f50fb11779bd5d748255f0994627fbe5a71/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8683f50fb11779bd5d748255f0994627fbe5a71/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fversion.rs?ref=e8683f50fb11779bd5d748255f0994627fbe5a71", "patch": "@@ -1,2 +0,0 @@\n-// We put this in a separate file so that it can be hashed for GHA caching.\n-pub const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 26);"}]}