{"sha": "bad79484fb99d40f48e3b84776699526a37513e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZDc5NDg0ZmI5OWQ0MGY0OGUzYjg0Nzc2Njk5NTI2YTM3NTEzZTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-21T19:37:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T11:55:29Z"}, "message": "avoid allocating a vector when the coercion sites are known upfront", "tree": {"sha": "9651942ab9acdb6027d28ac4ca1acd1d9073ac7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9651942ab9acdb6027d28ac4ca1acd1d9073ac7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bad79484fb99d40f48e3b84776699526a37513e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bad79484fb99d40f48e3b84776699526a37513e0", "html_url": "https://github.com/rust-lang/rust/commit/bad79484fb99d40f48e3b84776699526a37513e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bad79484fb99d40f48e3b84776699526a37513e0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "609bfe82fd1c1207ab59f6c08bbadf45e587bd4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/609bfe82fd1c1207ab59f6c08bbadf45e587bd4a", "html_url": "https://github.com/rust-lang/rust/commit/609bfe82fd1c1207ab59f6c08bbadf45e587bd4a"}], "stats": {"total": 213, "additions": 154, "deletions": 59}, "files": [{"sha": "5ca8f2c01c58992159dd57b836bf227af9057e04", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=bad79484fb99d40f48e3b84776699526a37513e0", "patch": "@@ -474,7 +474,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => ety,\n                 _ => self.next_ty_var(TypeVariableOrigin::MiscVariable(expr.span)),\n             };\n-            CoerceMany::new(coerce_first)\n+            CoerceMany::with_coercion_sites(coerce_first, arms)\n         };\n \n         for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {"}, {"sha": "647adbbb82f2d02dc5f1becda4c5c0c657e8df8c", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=bad79484fb99d40f48e3b84776699526a37513e0", "patch": "@@ -12,6 +12,7 @@ use astconv::AstConv;\n \n use super::FnCtxt;\n \n+use check::coercion::AsCoercionSite;\n use rustc::infer::InferOk;\n use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n@@ -148,16 +149,16 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         self.fcx.resolve_type_vars_if_possible(&self.cur_ty)\n     }\n \n-    pub fn finalize<'b, I>(self, pref: LvaluePreference, exprs: I)\n-        where I: IntoIterator<Item = &'b hir::Expr>\n+    pub fn finalize<E>(self, pref: LvaluePreference, exprs: &[E])\n+        where E: AsCoercionSite\n     {\n         let fcx = self.fcx;\n         fcx.register_infer_ok_obligations(self.finalize_as_infer_ok(pref, exprs));\n     }\n \n-    pub fn finalize_as_infer_ok<'b, I>(self, pref: LvaluePreference, exprs: I)\n-                                       -> InferOk<'tcx, ()>\n-        where I: IntoIterator<Item = &'b hir::Expr>\n+    pub fn finalize_as_infer_ok<E>(self, pref: LvaluePreference, exprs: &[E])\n+                                   -> InferOk<'tcx, ()>\n+        where E: AsCoercionSite\n     {\n         let methods: Vec<_> = self.steps\n             .iter()\n@@ -176,6 +177,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                self.obligations);\n \n         for expr in exprs {\n+            let expr = expr.as_coercion_site();\n             debug!(\"finalize - finalizing #{} - {:?}\", expr.id, expr);\n             for (n, method) in methods.iter().enumerate() {\n                 if let &Some(method) = method {"}, {"sha": "f9bc947a973584a270acb9e82cc3ea7c9be60447", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=bad79484fb99d40f48e3b84776699526a37513e0", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             })\n             .next();\n         let callee_ty = autoderef.unambiguous_final_ty();\n-        autoderef.finalize(LvaluePreference::NoPreference, Some(callee_expr));\n+        autoderef.finalize(LvaluePreference::NoPreference, &[callee_expr]);\n \n         let output = match result {\n             None => {"}, {"sha": "eba58df781f1b59dbbe164aa1b4cb0c464d0e70c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 133, "deletions": 41, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=bad79484fb99d40f48e3b84776699526a37513e0", "patch": "@@ -76,6 +76,7 @@ use rustc::ty::relate::RelateResult;\n use rustc::ty::subst::Subst;\n use syntax::abi;\n use syntax::feature_gate;\n+use syntax::ptr::P;\n \n use std::collections::VecDeque;\n use std::ops::Deref;\n@@ -155,11 +156,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn coerce<'a, E, I>(&self, exprs: &E, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n-        where E: Fn() -> I,\n-              I: IntoIterator<Item = &'a hir::Expr>\n+    fn coerce<E>(&self, exprs: &[E], a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n+        where E: AsCoercionSite\n     {\n-\n         let a = self.shallow_resolve(a);\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n@@ -239,15 +238,14 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n-    fn coerce_borrowed_pointer<'a, E, I>(&self,\n-                                         exprs: &E,\n-                                         a: Ty<'tcx>,\n-                                         b: Ty<'tcx>,\n-                                         r_b: &'tcx ty::Region,\n-                                         mt_b: TypeAndMut<'tcx>)\n-                                         -> CoerceResult<'tcx>\n-        where E: Fn() -> I,\n-              I: IntoIterator<Item = &'a hir::Expr>\n+    fn coerce_borrowed_pointer<E>(&self,\n+                                  exprs: &[E],\n+                                  a: Ty<'tcx>,\n+                                  b: Ty<'tcx>,\n+                                  r_b: &'tcx ty::Region,\n+                                  mt_b: TypeAndMut<'tcx>)\n+                                  -> CoerceResult<'tcx>\n+        where E: AsCoercionSite\n     {\n \n         debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n@@ -424,7 +422,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                autoref);\n \n         let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n-        obligations.extend(autoderef.finalize_as_infer_ok(pref, exprs()).obligations);\n+        obligations.extend(autoderef.finalize_as_infer_ok(pref, exprs).obligations);\n \n         success(Adjust::DerefRef {\n             autoderefs: autoderefs,\n@@ -699,7 +697,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n         let coerce = Coerce::new(self, cause);\n         self.commit_if_ok(|_| {\n-            let ok = coerce.coerce(&|| Some(expr), source, target)?;\n+            let ok = coerce.coerce(&[expr], source, target)?;\n             let adjustment = self.register_infer_ok_obligations(ok);\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n@@ -718,15 +716,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// This is really an internal helper. From outside the coercion\n     /// module, you should instantiate a `CoerceMany` instance.\n-    fn try_find_coercion_lub<'b, E, I>(&self,\n-                                       cause: &ObligationCause<'tcx>,\n-                                       exprs: E,\n-                                       prev_ty: Ty<'tcx>,\n-                                       new: &'b hir::Expr,\n-                                       new_ty: Ty<'tcx>)\n-                                       -> RelateResult<'tcx, Ty<'tcx>>\n-        where E: Fn() -> I,\n-              I: IntoIterator<Item = &'b hir::Expr>\n+    fn try_find_coercion_lub<E>(&self,\n+                                cause: &ObligationCause<'tcx>,\n+                                exprs: &[E],\n+                                prev_ty: Ty<'tcx>,\n+                                new: &hir::Expr,\n+                                new_ty: Ty<'tcx>)\n+                                -> RelateResult<'tcx, Ty<'tcx>>\n+        where E: AsCoercionSite\n     {\n \n         let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n@@ -758,7 +755,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // Reify both sides and return the reified fn pointer type.\n                 let fn_ptr = self.tcx.mk_fn_ptr(fty);\n-                for expr in exprs().into_iter().chain(Some(new)) {\n+                for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n                     // No adjustments can produce a fn item, so this should never trip.\n                     assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n                     self.write_adjustment(expr.id, Adjustment {\n@@ -778,7 +775,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n-            let result = self.commit_if_ok(|_| coerce.coerce(&|| Some(new), new_ty, prev_ty));\n+            let result = self.commit_if_ok(|_| coerce.coerce(&[new], new_ty, prev_ty));\n             match result {\n                 Ok(ok) => {\n                     let adjustment = self.register_infer_ok_obligations(ok);\n@@ -794,7 +791,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Then try to coerce the previous expressions to the type of the new one.\n         // This requires ensuring there are no coercions applied to *any* of the\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n-        for expr in exprs() {\n+        for expr in exprs {\n+            let expr = expr.as_coercion_site();\n             let noop = match self.tables.borrow().adjustments.get(&expr.id).map(|adj| adj.kind) {\n                 Some(Adjust::DerefRef {\n                     autoderefs: 1,\n@@ -838,7 +836,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let adjustment = self.register_infer_ok_obligations(ok);\n                 if !adjustment.is_identity() {\n                     let mut tables = self.tables.borrow_mut();\n-                    for expr in exprs() {\n+                    for expr in exprs {\n+                        let expr = expr.as_coercion_site();\n                         if let Some(&mut Adjustment {\n                             kind: Adjust::NeverToAny,\n                             ref mut target\n@@ -897,25 +896,61 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n /// let final_ty = coerce.complete(fcx);\n /// ```\n #[derive(Clone)] // (*)\n-pub struct CoerceMany<'gcx: 'tcx, 'tcx> {\n+pub struct CoerceMany<'gcx, 'tcx, 'exprs, E>\n+    where 'gcx: 'tcx, E: 'exprs + AsCoercionSite,\n+{\n     expected_ty: Ty<'tcx>,\n     final_ty: Option<Ty<'tcx>>,\n-    expressions: Vec<&'gcx hir::Expr>,\n+    expressions: Expressions<'gcx, 'exprs, E>,\n+    pushed: usize,\n+}\n+\n+/// The type of a `CoerceMany` that is storing up the expressions into\n+/// a buffer. We use this in `check/mod.rs` for things like `break`.\n+pub type DynamicCoerceMany<'gcx, 'tcx> = CoerceMany<'gcx, 'tcx, 'static, hir::Expr>;\n+\n+#[derive(Clone)] // (*)\n+enum Expressions<'gcx, 'exprs, E>\n+    where E: 'exprs + AsCoercionSite,\n+{\n+    Dynamic(Vec<&'gcx hir::Expr>),\n+    UpFront(&'exprs [E]),\n }\n \n // (*) this is clone because `FnCtxt` is clone, but it seems dubious -- nmatsakis\n \n-impl<'gcx, 'tcx> CoerceMany<'gcx, 'tcx> {\n+impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n+    where 'gcx: 'tcx, E: 'exprs + AsCoercionSite,\n+{\n+    /// The usual case; collect the set of expressions dynamically.\n+    /// If the full set of coercion sites is known before hand,\n+    /// consider `with_coercion_sites()` instead to avoid allocation.\n     pub fn new(expected_ty: Ty<'tcx>) -> Self {\n+        Self::make(expected_ty, Expressions::Dynamic(vec![]))\n+    }\n+\n+    /// As an optimization, you can create a `CoerceMany` with a\n+    /// pre-existing slice of expressions. In this case, you are\n+    /// expected to pass each element in the slice to `coerce(...)` in\n+    /// order. This is used with arrays in particular to avoid\n+    /// needlessly cloning the slice.\n+    pub fn with_coercion_sites(expected_ty: Ty<'tcx>,\n+                               coercion_sites: &'exprs [E])\n+                      -> Self {\n+        Self::make(expected_ty, Expressions::UpFront(coercion_sites))\n+    }\n+\n+    fn make(expected_ty: Ty<'tcx>, expressions: Expressions<'gcx, 'exprs, E>) -> Self {\n         CoerceMany {\n             expected_ty,\n             final_ty: None,\n-            expressions: vec![],\n+            expressions,\n+            pushed: 0,\n         }\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        self.expressions.is_empty()\n+        self.pushed == 0\n     }\n \n     /// Return the \"expected type\" with which this coercion was\n@@ -997,16 +1032,25 @@ impl<'gcx, 'tcx> CoerceMany<'gcx, 'tcx> {\n \n         // Handle the actual type unification etc.\n         let result = if let Some(expression) = expression {\n-            if self.expressions.is_empty() {\n+            if self.pushed == 0 {\n                 // Special-case the first expression we are coercing.\n                 // To be honest, I'm not entirely sure why we do this.\n                 fcx.try_coerce(expression, expression_ty, self.expected_ty)\n             } else {\n-                fcx.try_find_coercion_lub(cause,\n-                                          || self.expressions.iter().cloned(),\n-                                          self.merged_ty(),\n-                                          expression,\n-                                          expression_ty)\n+                match self.expressions {\n+                    Expressions::Dynamic(ref exprs) =>\n+                        fcx.try_find_coercion_lub(cause,\n+                                                  exprs,\n+                                                  self.merged_ty(),\n+                                                  expression,\n+                                                  expression_ty),\n+                    Expressions::UpFront(ref coercion_sites) =>\n+                        fcx.try_find_coercion_lub(cause,\n+                                                  &coercion_sites[0..self.pushed],\n+                                                  self.merged_ty(),\n+                                                  expression,\n+                                                  expression_ty),\n+                }\n             }\n         } else {\n             // this is a hack for cases where we default to `()` because\n@@ -1034,7 +1078,17 @@ impl<'gcx, 'tcx> CoerceMany<'gcx, 'tcx> {\n         match result {\n             Ok(v) => {\n                 self.final_ty = Some(v);\n-                self.expressions.extend(expression);\n+                if let Some(e) = expression {\n+                    match self.expressions {\n+                        Expressions::Dynamic(ref mut buffer) => buffer.push(e),\n+                        Expressions::UpFront(coercion_sites) => {\n+                            // if the user gave us an array to validate, check that we got\n+                            // the next expression in the list, as expected\n+                            assert_eq!(coercion_sites[self.pushed].as_coercion_site().id, e.id);\n+                        }\n+                    }\n+                    self.pushed += 1;\n+                }\n             }\n             Err(err) => {\n                 let (expected, found) = if expression.is_none() {\n@@ -1076,8 +1130,46 @@ impl<'gcx, 'tcx> CoerceMany<'gcx, 'tcx> {\n         } else {\n             // If we only had inputs that were of type `!` (or no\n             // inputs at all), then the final type is `!`.\n-            assert!(self.expressions.is_empty());\n+            assert_eq!(self.pushed, 0);\n             fcx.tcx.types.never\n         }\n     }\n }\n+\n+/// Something that can be converted into an expression to which we can\n+/// apply a coercion.\n+pub trait AsCoercionSite {\n+    fn as_coercion_site(&self) -> &hir::Expr;\n+}\n+\n+impl AsCoercionSite for hir::Expr {\n+    fn as_coercion_site(&self) -> &hir::Expr {\n+        self\n+    }\n+}\n+\n+impl AsCoercionSite for P<hir::Expr> {\n+    fn as_coercion_site(&self) -> &hir::Expr {\n+        self\n+    }\n+}\n+\n+impl<'a, T> AsCoercionSite for &'a T\n+    where T: AsCoercionSite\n+{\n+    fn as_coercion_site(&self) -> &hir::Expr {\n+        (**self).as_coercion_site()\n+    }\n+}\n+\n+impl AsCoercionSite for ! {\n+    fn as_coercion_site(&self) -> &hir::Expr {\n+        unreachable!()\n+    }\n+}\n+\n+impl AsCoercionSite for hir::Arm {\n+    fn as_coercion_site(&self) -> &hir::Expr {\n+        &self.body\n+    }\n+}"}, {"sha": "73f6cd76290aa0a82fb9f835a16ece2d778dbaf7", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=bad79484fb99d40f48e3b84776699526a37513e0", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         assert_eq!(n, pick.autoderefs);\n \n         autoderef.unambiguous_final_ty();\n-        autoderef.finalize(LvaluePreference::NoPreference, Some(self.self_expr));\n+        autoderef.finalize(LvaluePreference::NoPreference, &[self.self_expr]);\n \n         let target = pick.unsize.unwrap_or(autoderefd_ty);\n         let target = target.adjust_for_autoref(self.tcx, autoref);\n@@ -444,7 +444,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                       \"expr was deref-able {} times but now isn't?\",\n                                       autoderefs);\n                         });\n-                        autoderef.finalize(PreferMutLvalue, Some(expr));\n+                        autoderef.finalize(PreferMutLvalue, &[expr]);\n                     }\n                 }\n                 Some(_) | None => {}"}, {"sha": "4b7d9a0fd3aaecf50c13f2517c1e2aa9ded32b04", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bad79484fb99d40f48e3b84776699526a37513e0", "patch": "@@ -77,7 +77,7 @@ type parameter).\n */\n \n pub use self::Expectation::*;\n-use self::coercion::CoerceMany;\n+use self::coercion::{CoerceMany, DynamicCoerceMany};\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n@@ -420,7 +420,7 @@ pub struct BreakableCtxt<'gcx: 'tcx, 'tcx> {\n \n     // this is `null` for loops where break with a value is illegal,\n     // such as `while`, `for`, and `while let`\n-    coerce: Option<CoerceMany<'gcx, 'tcx>>,\n+    coerce: Option<DynamicCoerceMany<'gcx, 'tcx>>,\n }\n \n #[derive(Clone)]\n@@ -450,7 +450,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // expects the types within the function to be consistent.\n     err_count_on_creation: usize,\n \n-    ret_coercion: Option<RefCell<CoerceMany<'gcx, 'tcx>>>,\n+    ret_coercion: Option<RefCell<DynamicCoerceMany<'gcx, 'tcx>>>,\n \n     ps: RefCell<UnsafetyState>,\n \n@@ -2245,12 +2245,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 expr, base_expr, adj_ty, autoderefs,\n                 false, lvalue_pref, idx_ty)\n             {\n-                autoderef.finalize(lvalue_pref, Some(base_expr));\n+                autoderef.finalize(lvalue_pref, &[base_expr]);\n                 return Some(final_mt);\n             }\n \n             if let ty::TyArray(element_ty, _) = adj_ty.sty {\n-                autoderef.finalize(lvalue_pref, Some(base_expr));\n+                autoderef.finalize(lvalue_pref, &[base_expr]);\n                 let adjusted_ty = self.tcx.mk_slice(element_ty);\n                 return self.try_index_step(\n                     MethodCall::expr(expr.id), expr, base_expr,\n@@ -2861,7 +2861,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // (`only_has_type`); otherwise, we just go with a\n         // fresh type variable.\n         let coerce_to_ty = expected.only_has_type_or_fresh_var(self, sp);\n-        let mut coerce = CoerceMany::new(coerce_to_ty);\n+        let mut coerce: DynamicCoerceMany = CoerceMany::new(coerce_to_ty);\n \n         let if_cause = self.cause(sp, ObligationCauseCode::IfExpression);\n         coerce.coerce(self, &if_cause, then_expr, then_ty);\n@@ -2908,7 +2908,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n-                            autoderef.finalize(lvalue_pref, Some(base));\n+                            autoderef.finalize(lvalue_pref, &[base]);\n                             self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n \n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n@@ -3032,7 +3032,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Some(field_ty) = field {\n-                autoderef.finalize(lvalue_pref, Some(base));\n+                autoderef.finalize(lvalue_pref, &[base]);\n                 self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n                 return field_ty;\n             }\n@@ -3768,7 +3768,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               let element_ty = if !args.is_empty() {\n                   let coerce_to = uty.unwrap_or_else(\n                       || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n-                  let mut coerce = CoerceMany::new(coerce_to);\n+                  let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n                   for e in args {\n                       let e_ty = self.check_expr_with_hint(e, coerce_to);\n                       let cause = self.misc(e.span);"}, {"sha": "0bde9fefeba0c833d53c7b66f820aacf944e85a0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bad79484fb99d40f48e3b84776699526a37513e0/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=bad79484fb99d40f48e3b84776699526a37513e0", "patch": "@@ -79,6 +79,7 @@ This API is completely unstable and subject to change.\n #![feature(conservative_impl_trait)]\n #![cfg_attr(stage0,feature(field_init_shorthand))]\n #![feature(loop_break_value)]\n+#![feature(never_type)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}]}