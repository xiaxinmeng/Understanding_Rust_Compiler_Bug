{"sha": "a3ef360368ac4c97883dc45287e752517e308f0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZWYzNjAzNjhhYzRjOTc4ODNkYzQ1Mjg3ZTc1MjUxN2UzMDhmMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-14T06:47:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-14T06:47:38Z"}, "message": "Auto merge of #70679 - tmandry:issue-68112, r=nikomatsakis\n\nImprove async-await/generator obligation errors in some cases\n\nFixes #68112.\n\nThis change is best read one commit at a time (I add a test at the beginning and update it in each change after).\n\nThe `test2` function is a case I found while writing the test that we don't handle with this code yet. I don't attempt to fix it in this PR, but it's a good candidate for future work.\n\nr? @davidtwco, @nikomatsakis", "tree": {"sha": "6ef048145715383fd1dbaa53a1e1f7fb1798f3c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ef048145715383fd1dbaa53a1e1f7fb1798f3c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3ef360368ac4c97883dc45287e752517e308f0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ef360368ac4c97883dc45287e752517e308f0e", "html_url": "https://github.com/rust-lang/rust/commit/a3ef360368ac4c97883dc45287e752517e308f0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3ef360368ac4c97883dc45287e752517e308f0e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "513a6473d69b3af34e6cdaa4efb288fe5283c3e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/513a6473d69b3af34e6cdaa4efb288fe5283c3e9", "html_url": "https://github.com/rust-lang/rust/commit/513a6473d69b3af34e6cdaa4efb288fe5283c3e9"}, {"sha": "4326d959f460321ed6f818a015f157af46ec5848", "url": "https://api.github.com/repos/rust-lang/rust/commits/4326d959f460321ed6f818a015f157af46ec5848", "html_url": "https://github.com/rust-lang/rust/commit/4326d959f460321ed6f818a015f157af46ec5848"}], "stats": {"total": 517, "additions": 411, "deletions": 106}, "files": [{"sha": "2fc58efbf0e7fda71a4da46510e12c937b2d2d8a", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -590,6 +590,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             await_span,\n             self.allow_gen_future.clone(),\n         );\n+        let expr = self.lower_expr(expr);\n \n         let pinned_ident = Ident::with_dummy_span(sym::pinned);\n         let (pinned_pat, pinned_pat_hid) =\n@@ -671,7 +672,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let unit = self.expr_unit(span);\n             let yield_expr = self.expr(\n                 span,\n-                hir::ExprKind::Yield(unit, hir::YieldSource::Await),\n+                hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr.hir_id) }),\n                 ThinVec::new(),\n             );\n             let yield_expr = self.arena.alloc(yield_expr);\n@@ -704,7 +705,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // match <expr> {\n         //     mut pinned => loop { .. }\n         // }\n-        let expr = self.lower_expr(expr);\n         hir::ExprKind::Match(expr, arena_vec![self; pinned_arm], hir::MatchSource::AwaitDesugar)\n     }\n "}, {"sha": "b66e6101b504b8b8f5c23f242b648e541975fa5c", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -1736,15 +1736,24 @@ pub struct Destination {\n #[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub enum YieldSource {\n     /// An `<expr>.await`.\n-    Await,\n+    Await { expr: Option<HirId> },\n     /// A plain `yield`.\n     Yield,\n }\n \n+impl YieldSource {\n+    pub fn is_await(&self) -> bool {\n+        match self {\n+            YieldSource::Await { .. } => true,\n+            YieldSource::Yield => false,\n+        }\n+    }\n+}\n+\n impl fmt::Display for YieldSource {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(match self {\n-            YieldSource::Await => \"`await`\",\n+            YieldSource::Await { .. } => \"`await`\",\n             YieldSource::Yield => \"`yield`\",\n         })\n     }\n@@ -1755,7 +1764,7 @@ impl From<GeneratorKind> for YieldSource {\n         match kind {\n             // Guess based on the kind of the current generator.\n             GeneratorKind::Gen => Self::Yield,\n-            GeneratorKind::Async(_) => Self::Await,\n+            GeneratorKind::Async(_) => Self::Await { expr: None },\n         }\n     }\n }"}, {"sha": "254db6cb869b1bfa537fd6316258f887c5130fef", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 162, "deletions": 82, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -10,7 +10,7 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::Node;\n+use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n     self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n@@ -127,13 +127,14 @@ pub trait InferCtxtExt<'tcx> {\n         scope_span: &Option<Span>,\n         expr: Option<hir::HirId>,\n         snippet: String,\n-        first_generator: DefId,\n-        last_generator: Option<DefId>,\n+        inner_generator_body: Option<&hir::Body<'_>>,\n+        outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'_>,\n         target_ty: Ty<'tcx>,\n         tables: &ty::TypeckTables<'_>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n+        from_awaited_ty: Option<Span>,\n     );\n \n     fn note_obligation_cause_code<T>(\n@@ -1094,6 +1095,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             obligation.predicate, obligation.cause.span\n         );\n         let source_map = self.tcx.sess.source_map();\n+        let hir = self.tcx.hir();\n \n         // Attempt to detect an async-await error by looking at the obligation causes, looking\n         // for a generator to be present.\n@@ -1118,16 +1120,17 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // - `BindingObligation` with `impl_send (Send requirement)\n         //\n         // The first obligation in the chain is the most useful and has the generator that captured\n-        // the type. The last generator has information about where the bound was introduced. At\n-        // least one generator should be present for this diagnostic to be modified.\n+        // the type. The last generator (`outer_generator` below) has information about where the\n+        // bound was introduced. At least one generator should be present for this diagnostic to be\n+        // modified.\n         let (mut trait_ref, mut target_ty) = match obligation.predicate {\n             ty::Predicate::Trait(p, _) => {\n                 (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty()))\n             }\n             _ => (None, None),\n         };\n         let mut generator = None;\n-        let mut last_generator = None;\n+        let mut outer_generator = None;\n         let mut next_code = Some(&obligation.cause.code);\n         while let Some(code) = next_code {\n             debug!(\"maybe_note_obligation_cause_for_async_await: code={:?}\", code);\n@@ -1144,7 +1147,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     match ty.kind {\n                         ty::Generator(did, ..) => {\n                             generator = generator.or(Some(did));\n-                            last_generator = Some(did);\n+                            outer_generator = Some(did);\n                         }\n                         ty::GeneratorWitness(..) => {}\n                         _ if generator.is_none() => {\n@@ -1176,7 +1179,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let span = self.tcx.def_span(generator_did);\n \n         // Do not ICE on closure typeck (#66868).\n-        if self.tcx.hir().as_local_hir_id(generator_did).is_none() {\n+        if hir.as_local_hir_id(generator_did).is_none() {\n             return false;\n         }\n \n@@ -1202,58 +1205,85 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n+        let generator_body = hir\n+            .as_local_hir_id(generator_did)\n+            .and_then(|hir_id| hir.maybe_body_owned_by(hir_id))\n+            .map(|body_id| hir.body(body_id));\n+        let mut visitor = AwaitsVisitor::default();\n+        if let Some(body) = generator_body {\n+            visitor.visit_body(body);\n+        }\n+        debug!(\"maybe_note_obligation_cause_for_async_await: awaits = {:?}\", visitor.awaits);\n+\n         // Look for a type inside the generator interior that matches the target type to get\n         // a span.\n         let target_ty_erased = self.tcx.erase_regions(&target_ty);\n+        let ty_matches = |ty| -> bool {\n+            // Careful: the regions for types that appear in the\n+            // generator interior are not generally known, so we\n+            // want to erase them when comparing (and anyway,\n+            // `Send` and other bounds are generally unaffected by\n+            // the choice of region).  When erasing regions, we\n+            // also have to erase late-bound regions. This is\n+            // because the types that appear in the generator\n+            // interior generally contain \"bound regions\" to\n+            // represent regions that are part of the suspended\n+            // generator frame. Bound regions are preserved by\n+            // `erase_regions` and so we must also call\n+            // `erase_late_bound_regions`.\n+            let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(ty));\n+            let ty_erased = self.tcx.erase_regions(&ty_erased);\n+            let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n+            debug!(\n+                \"maybe_note_obligation_cause_for_async_await: ty_erased={:?} \\\n+                    target_ty_erased={:?} eq={:?}\",\n+                ty_erased, target_ty_erased, eq\n+            );\n+            eq\n+        };\n         let target_span = tables\n             .generator_interior_types\n             .iter()\n-            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| {\n-                // Careful: the regions for types that appear in the\n-                // generator interior are not generally known, so we\n-                // want to erase them when comparing (and anyway,\n-                // `Send` and other bounds are generally unaffected by\n-                // the choice of region).  When erasing regions, we\n-                // also have to erase late-bound regions. This is\n-                // because the types that appear in the generator\n-                // interior generally contain \"bound regions\" to\n-                // represent regions that are part of the suspended\n-                // generator frame. Bound regions are preserved by\n-                // `erase_regions` and so we must also call\n-                // `erase_late_bound_regions`.\n-                let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(*ty));\n-                let ty_erased = self.tcx.erase_regions(&ty_erased);\n-                let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n-                debug!(\n-                    \"maybe_note_obligation_cause_for_async_await: ty_erased={:?} \\\n-                        target_ty_erased={:?} eq={:?}\",\n-                    ty_erased, target_ty_erased, eq\n-                );\n-                eq\n-            })\n-            .map(|ty::GeneratorInteriorTypeCause { span, scope_span, expr, .. }| {\n-                (span, source_map.span_to_snippet(*span), scope_span, expr)\n+            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| ty_matches(ty))\n+            .map(|cause| {\n+                // Check to see if any awaited expressions have the target type.\n+                let from_awaited_ty = visitor\n+                    .awaits\n+                    .into_iter()\n+                    .map(|id| hir.expect_expr(id))\n+                    .find(|await_expr| {\n+                        let ty = tables.expr_ty_adjusted(&await_expr);\n+                        debug!(\n+                            \"maybe_note_obligation_cause_for_async_await: await_expr={:?}\",\n+                            await_expr\n+                        );\n+                        ty_matches(ty)\n+                    })\n+                    .map(|expr| expr.span);\n+                let ty::GeneratorInteriorTypeCause { span, scope_span, expr, .. } = cause;\n+                (span, source_map.span_to_snippet(*span), scope_span, expr, from_awaited_ty)\n             });\n \n         debug!(\n             \"maybe_note_obligation_cause_for_async_await: target_ty={:?} \\\n                 generator_interior_types={:?} target_span={:?}\",\n             target_ty, tables.generator_interior_types, target_span\n         );\n-        if let Some((target_span, Ok(snippet), scope_span, expr)) = target_span {\n+        if let Some((target_span, Ok(snippet), scope_span, expr, from_awaited_ty)) = target_span {\n             self.note_obligation_cause_for_async_await(\n                 err,\n                 *target_span,\n                 scope_span,\n                 *expr,\n                 snippet,\n-                generator_did,\n-                last_generator,\n+                generator_body,\n+                outer_generator,\n                 trait_ref,\n                 target_ty,\n                 tables,\n                 obligation,\n                 next_code,\n+                from_awaited_ty,\n             );\n             true\n         } else {\n@@ -1270,35 +1300,27 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         scope_span: &Option<Span>,\n         expr: Option<hir::HirId>,\n         snippet: String,\n-        first_generator: DefId,\n-        last_generator: Option<DefId>,\n+        inner_generator_body: Option<&hir::Body<'_>>,\n+        outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'_>,\n         target_ty: Ty<'tcx>,\n         tables: &ty::TypeckTables<'_>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n+        from_awaited_ty: Option<Span>,\n     ) {\n         let source_map = self.tcx.sess.source_map();\n \n-        let is_async_fn = self\n-            .tcx\n-            .parent(first_generator)\n-            .map(|parent_did| self.tcx.asyncness(parent_did))\n-            .map(|parent_asyncness| parent_asyncness == hir::IsAsync::Async)\n-            .unwrap_or(false);\n-        let is_async_move = self\n-            .tcx\n-            .hir()\n-            .as_local_hir_id(first_generator)\n-            .and_then(|hir_id| self.tcx.hir().maybe_body_owned_by(hir_id))\n-            .map(|body_id| self.tcx.hir().body(body_id))\n+        let is_async = inner_generator_body\n             .and_then(|body| body.generator_kind())\n             .map(|generator_kind| match generator_kind {\n                 hir::GeneratorKind::Async(..) => true,\n                 _ => false,\n             })\n             .unwrap_or(false);\n-        let await_or_yield = if is_async_fn || is_async_move { \"await\" } else { \"yield\" };\n+        let (await_or_yield, an_await_or_yield) =\n+            if is_async { (\"await\", \"an await\") } else { (\"yield\", \"a yield\") };\n+        let future_or_generator = if is_async { \"future\" } else { \"generator\" };\n \n         // Special case the primary error message when send or sync is the trait that was\n         // not implemented.\n@@ -1311,22 +1333,34 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n             err.clear_code();\n             err.set_primary_message(format!(\n-                \"future cannot be {} between threads safely\",\n-                trait_verb\n+                \"{} cannot be {} between threads safely\",\n+                future_or_generator, trait_verb\n             ));\n \n             let original_span = err.span.primary_span().unwrap();\n             let mut span = MultiSpan::from_span(original_span);\n \n-            let message = if let Some(name) = last_generator\n-                .and_then(|generator_did| self.tcx.parent(generator_did))\n-                .and_then(|parent_did| hir.as_local_hir_id(parent_did))\n-                .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n-            {\n-                format!(\"future returned by `{}` is not {}\", name, trait_name)\n-            } else {\n-                format!(\"future is not {}\", trait_name)\n-            };\n+            let message = outer_generator\n+                .and_then(|generator_did| {\n+                    Some(match self.tcx.generator_kind(generator_did).unwrap() {\n+                        GeneratorKind::Gen => format!(\"generator is not {}\", trait_name),\n+                        GeneratorKind::Async(AsyncGeneratorKind::Fn) => self\n+                            .tcx\n+                            .parent(generator_did)\n+                            .and_then(|parent_did| hir.as_local_hir_id(parent_did))\n+                            .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n+                            .map(|name| {\n+                                format!(\"future returned by `{}` is not {}\", name, trait_name)\n+                            })?,\n+                        GeneratorKind::Async(AsyncGeneratorKind::Block) => {\n+                            format!(\"future created by async block is not {}\", trait_name)\n+                        }\n+                        GeneratorKind::Async(AsyncGeneratorKind::Closure) => {\n+                            format!(\"future created by async closure is not {}\", trait_name)\n+                        }\n+                    })\n+                })\n+                .unwrap_or_else(|| format!(\"{} is not {}\", future_or_generator, trait_name));\n \n             span.push_span_label(original_span, message);\n             err.set_span(span);\n@@ -1336,31 +1370,56 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             format!(\"does not implement `{}`\", trait_ref.print_only_trait_path())\n         };\n \n-        // Look at the last interior type to get a span for the `.await`.\n-        let await_span = tables.generator_interior_types.iter().map(|t| t.span).last().unwrap();\n-        let mut span = MultiSpan::from_span(await_span);\n-        span.push_span_label(\n-            await_span,\n-            format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n-        );\n+        if let Some(await_span) = from_awaited_ty {\n+            // The type causing this obligation is one being awaited at await_span.\n+            let mut span = MultiSpan::from_span(await_span);\n \n-        span.push_span_label(target_span, format!(\"has type `{}`\", target_ty));\n+            span.push_span_label(\n+                await_span,\n+                format!(\"await occurs here on type `{}`, which {}\", target_ty, trait_explanation),\n+            );\n \n-        // If available, use the scope span to annotate the drop location.\n-        if let Some(scope_span) = scope_span {\n+            err.span_note(\n+                span,\n+                &format!(\n+                    \"future {not_trait} as it awaits another future which {not_trait}\",\n+                    not_trait = trait_explanation\n+                ),\n+            );\n+        } else {\n+            // Look at the last interior type to get a span for the `.await`.\n+            debug!(\n+                \"note_obligation_cause_for_async_await generator_interior_types: {:#?}\",\n+                tables.generator_interior_types\n+            );\n+            let await_span = tables.generator_interior_types.iter().map(|t| t.span).last().unwrap();\n+            let mut span = MultiSpan::from_span(await_span);\n             span.push_span_label(\n-                source_map.end_point(*scope_span),\n-                format!(\"`{}` is later dropped here\", snippet),\n+                await_span,\n+                format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n             );\n-        }\n \n-        err.span_note(\n-            span,\n-            &format!(\n-                \"future {} as this value is used across an {}\",\n-                trait_explanation, await_or_yield,\n-            ),\n-        );\n+            span.push_span_label(\n+                target_span,\n+                format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n+            );\n+\n+            // If available, use the scope span to annotate the drop location.\n+            if let Some(scope_span) = scope_span {\n+                span.push_span_label(\n+                    source_map.end_point(*scope_span),\n+                    format!(\"`{}` is later dropped here\", snippet),\n+                );\n+            }\n+\n+            err.span_note(\n+                span,\n+                &format!(\n+                    \"{} {} as this value is used across {}\",\n+                    future_or_generator, trait_explanation, an_await_or_yield\n+                ),\n+            );\n+        }\n \n         if let Some(expr_id) = expr {\n             let expr = hir.expect_expr(expr_id);\n@@ -1705,6 +1764,27 @@ impl<'v> Visitor<'v> for ReturnsVisitor<'v> {\n     }\n }\n \n+/// Collect all the awaited expressions within the input expression.\n+#[derive(Default)]\n+struct AwaitsVisitor {\n+    awaits: Vec<hir::HirId>,\n+}\n+\n+impl<'v> Visitor<'v> for AwaitsVisitor {\n+    type Map = hir::intravisit::ErasedMap<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        if let hir::ExprKind::Yield(_, hir::YieldSource::Await { expr: Some(id) }) = ex.kind {\n+            self.awaits.push(id)\n+        }\n+        hir::intravisit::walk_expr(self, ex)\n+    }\n+}\n+\n pub trait NextTypeParamName {\n     fn next_type_param_name(&self, name: Option<&str>) -> String;\n }"}, {"sha": "7cb51b4d6d833d8d6fa13978de7c2efa623e2bf3", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -1797,7 +1797,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // we know that the yield type must be `()`; however, the context won't contain this\n             // information. Hence, we check the source of the yield expression here and check its\n             // value's type against `()` (this check should always hold).\n-            None if src == &hir::YieldSource::Await => {\n+            None if src.is_await() => {\n                 self.check_expr_coercable_to_type(&value, self.tcx.mk_unit());\n                 self.tcx.mk_unit()\n             }"}, {"sha": "d36d59f1f68f6b6be7d4493dc42084999b9cc7a2", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -12,7 +12,7 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/async-fn-nonsend.rs:24:5\n    |\n LL |     let x = non_send();\n-   |         - has type `impl std::fmt::Debug`\n+   |         - has type `impl std::fmt::Debug` which is not `Send`\n LL |     drop(x);\n LL |     fut().await;\n    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n@@ -33,7 +33,7 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/async-fn-nonsend.rs:33:20\n    |\n LL |     match Some(non_send()) {\n-   |                ---------- has type `impl std::fmt::Debug`\n+   |                ---------- has type `impl std::fmt::Debug` which is not `Send`\n LL |         Some(_) => fut().await,\n    |                    ^^^^^^^^^^^ await occurs here, with `non_send()` maybe used later\n ...\n@@ -54,7 +54,7 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/async-fn-nonsend.rs:42:9\n    |\n LL |     let f: &mut std::fmt::Formatter = panic!();\n-   |         - has type `&mut std::fmt::Formatter<'_>`\n+   |         - has type `&mut std::fmt::Formatter<'_>` which is not `Send`\n LL |     if non_sync().fmt(f).unwrap() == () {\n LL |         fut().await;\n    |         ^^^^^^^^^^^ await occurs here, with `f` maybe used later"}, {"sha": "42e9e4642cea521257bf28b233038ef5b73d4266", "filename": "src/test/ui/async-await/issue-64130-1-sync.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -12,7 +12,7 @@ note: future is not `Sync` as this value is used across an await\n   --> $DIR/issue-64130-1-sync.rs:15:5\n    |\n LL |     let x = Foo;\n-   |         - has type `Foo`\n+   |         - has type `Foo` which is not `Sync`\n LL |     baz().await;\n    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n LL | }"}, {"sha": "f6f834618d36f26bb6c70df18b3a33cb84243522", "filename": "src/test/ui/async-await/issue-64130-2-send.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -12,7 +12,7 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/issue-64130-2-send.rs:15:5\n    |\n LL |     let x = Foo;\n-   |         - has type `Foo`\n+   |         - has type `Foo` which is not `Send`\n LL |     baz().await;\n    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n LL | }"}, {"sha": "3475b66b375dd6b4c471dcbf874cb2d6da7ee3b6", "filename": "src/test/ui/async-await/issue-64130-3-other.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -16,7 +16,7 @@ note: future does not implement `Qux` as this value is used across an await\n   --> $DIR/issue-64130-3-other.rs:18:5\n    |\n LL |     let x = Foo;\n-   |         - has type `Foo`\n+   |         - has type `Foo` which does not implement `Qux`\n LL |     baz().await;\n    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n LL | }"}, {"sha": "fc231d394c11f6ddbb1b175991e64d4a588383ef", "filename": "src/test/ui/async-await/issue-64130-4-async-move.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -2,7 +2,7 @@ error: future cannot be sent between threads safely\n   --> $DIR/issue-64130-4-async-move.rs:15:17\n    |\n LL |   pub fn foo() -> impl Future + Send {\n-   |                   ^^^^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+   |                   ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n ...\n LL | /     async move {\n LL | |         match client.status() {\n@@ -18,7 +18,7 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/issue-64130-4-async-move.rs:21:26\n    |\n LL |         match client.status() {\n-   |               ------ has type `&Client`\n+   |               ------ has type `&Client` which is not `Send`\n LL |             200 => {\n LL |                 let _x = get().await;\n    |                          ^^^^^^^^^^^ await occurs here, with `client` maybe used later"}, {"sha": "f72757339cc5ef1e152116a3b708088f23d6df6e", "filename": "src/test/ui/async-await/issue-64130-non-send-future-diags.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -12,7 +12,7 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/issue-64130-non-send-future-diags.rs:15:5\n    |\n LL |     let g = x.lock().unwrap();\n-   |         - has type `std::sync::MutexGuard<'_, u32>`\n+   |         - has type `std::sync::MutexGuard<'_, u32>` which is not `Send`\n LL |     baz().await;\n    |     ^^^^^^^^^^^ await occurs here, with `g` maybe used later\n LL | }"}, {"sha": "b43478ee2070bc4fe1d6cb04bec50d21ed8f80a3", "filename": "src/test/ui/async-await/issue-67252-unnamed-future.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-67252-unnamed-future.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-67252-unnamed-future.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-67252-unnamed-future.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -5,14 +5,14 @@ LL | fn spawn<T: Send>(_: T) {}\n    |             ---- required by this bound in `spawn`\n ...\n LL |     spawn(async {\n-   |     ^^^^^ future is not `Send`\n+   |     ^^^^^ future created by async block is not `Send`\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `*mut ()`\n note: future is not `Send` as this value is used across an await\n   --> $DIR/issue-67252-unnamed-future.rs:20:9\n    |\n LL |         let _a = std::ptr::null_mut::<()>(); // `*mut ()` is not `Send`\n-   |             -- has type `*mut ()`\n+   |             -- has type `*mut ()` which is not `Send`\n LL |         AFuture.await;\n    |         ^^^^^^^^^^^^^ await occurs here, with `_a` maybe used later\n LL |     });"}, {"sha": "11b178368080745b1b1c2eb4a5e067587faf2ddb", "filename": "src/test/ui/async-await/issue-68112.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.rs?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -0,0 +1,64 @@\n+// edition:2018\n+\n+use std::{\n+    future::Future,\n+    cell::RefCell,\n+    sync::Arc,\n+    pin::Pin,\n+    task::{Context, Poll},\n+};\n+\n+fn require_send(_: impl Send) {}\n+\n+struct Ready<T>(Option<T>);\n+impl<T> Future for Ready<T> {\n+    type Output = T;\n+    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<T> {\n+        Poll::Ready(self.0.take().unwrap())\n+    }\n+}\n+fn ready<T>(t: T) -> Ready<T> {\n+    Ready(Some(t))\n+}\n+\n+fn make_non_send_future1() -> impl Future<Output = Arc<RefCell<i32>>> {\n+    ready(Arc::new(RefCell::new(0)))\n+}\n+\n+fn test1() {\n+    let send_fut = async {\n+        let non_send_fut = make_non_send_future1();\n+        let _ = non_send_fut.await;\n+        ready(0).await;\n+    };\n+    require_send(send_fut);\n+    //~^ ERROR future cannot be sent between threads\n+}\n+\n+fn test1_no_let() {\n+    let send_fut = async {\n+        let _ = make_non_send_future1().await;\n+        ready(0).await;\n+    };\n+    require_send(send_fut);\n+    //~^ ERROR future cannot be sent between threads\n+}\n+\n+async fn ready2<T>(t: T) -> T { t }\n+fn make_non_send_future2() -> impl Future<Output = Arc<RefCell<i32>>> {\n+    ready2(Arc::new(RefCell::new(0)))\n+}\n+\n+// Ideally this test would have diagnostics similar to the test above, but right\n+// now it doesn't.\n+fn test2() {\n+    let send_fut = async {\n+        let non_send_fut = make_non_send_future2();\n+        let _ = non_send_fut.await;\n+        ready(0).await;\n+    };\n+    require_send(send_fut);\n+    //~^ ERROR `std::cell::RefCell<i32>` cannot be shared between threads safely\n+}\n+\n+fn main() {}"}, {"sha": "6ded3e475bc377107d676bda29c546fad761ff27", "filename": "src/test/ui/async-await/issue-68112.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -0,0 +1,56 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/issue-68112.rs:34:5\n+   |\n+LL | fn require_send(_: impl Send) {}\n+   |                         ---- required by this bound in `require_send`\n+...\n+LL |     require_send(send_fut);\n+   |     ^^^^^^^^^^^^ future created by async block is not `Send`\n+   |\n+   = help: the trait `std::marker::Sync` is not implemented for `std::cell::RefCell<i32>`\n+note: future is not `Send` as it awaits another future which is not `Send`\n+  --> $DIR/issue-68112.rs:31:17\n+   |\n+LL |         let _ = non_send_fut.await;\n+   |                 ^^^^^^^^^^^^ await occurs here on type `impl std::future::Future`, which is not `Send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/issue-68112.rs:43:5\n+   |\n+LL | fn require_send(_: impl Send) {}\n+   |                         ---- required by this bound in `require_send`\n+...\n+LL |     require_send(send_fut);\n+   |     ^^^^^^^^^^^^ future created by async block is not `Send`\n+   |\n+   = help: the trait `std::marker::Sync` is not implemented for `std::cell::RefCell<i32>`\n+note: future is not `Send` as it awaits another future which is not `Send`\n+  --> $DIR/issue-68112.rs:40:17\n+   |\n+LL |         let _ = make_non_send_future1().await;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^ await occurs here on type `impl std::future::Future`, which is not `Send`\n+\n+error[E0277]: `std::cell::RefCell<i32>` cannot be shared between threads safely\n+  --> $DIR/issue-68112.rs:60:5\n+   |\n+LL | fn require_send(_: impl Send) {}\n+   |                         ---- required by this bound in `require_send`\n+...\n+LL |     require_send(send_fut);\n+   |     ^^^^^^^^^^^^ `std::cell::RefCell<i32>` cannot be shared between threads safely\n+   |\n+   = help: the trait `std::marker::Sync` is not implemented for `std::cell::RefCell<i32>`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc<std::cell::RefCell<i32>>`\n+   = note: required because it appears within the type `[static generator@$DIR/issue-68112.rs:47:31: 47:36 t:std::sync::Arc<std::cell::RefCell<i32>> {}]`\n+   = note: required because it appears within the type `std::future::from_generator::GenFuture<[static generator@$DIR/issue-68112.rs:47:31: 47:36 t:std::sync::Arc<std::cell::RefCell<i32>> {}]>`\n+   = note: required because it appears within the type `impl std::future::Future`\n+   = note: required because it appears within the type `impl std::future::Future`\n+   = note: required because it appears within the type `impl std::future::Future`\n+   = note: required because it appears within the type `{std::future::ResumeTy, impl std::future::Future, (), i32, Ready<i32>}`\n+   = note: required because it appears within the type `[static generator@$DIR/issue-68112.rs:55:26: 59:6 {std::future::ResumeTy, impl std::future::Future, (), i32, Ready<i32>}]`\n+   = note: required because it appears within the type `std::future::from_generator::GenFuture<[static generator@$DIR/issue-68112.rs:55:26: 59:6 {std::future::ResumeTy, impl std::future::Future, (), i32, Ready<i32>}]>`\n+   = note: required because it appears within the type `impl std::future::Future`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "49cd30e11a0c17b8fd329662aa3c494d0afa202f", "filename": "src/test/ui/async-await/issues/issue-65436-raw-ptr-not-send.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -5,7 +5,7 @@ LL | fn assert_send<T: Send>(_: T) {}\n    |                   ---- required by this bound in `assert_send`\n ...\n LL |     assert_send(async {\n-   |     ^^^^^^^^^^^ future returned by `main` is not `Send`\n+   |     ^^^^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `*const u8`\n note: future is not `Send` as this value is used across an await\n@@ -14,7 +14,7 @@ note: future is not `Send` as this value is used across an await\n LL |         bar(Foo(std::ptr::null())).await;\n    |         ^^^^^^^^----------------^^^^^^^^- `std::ptr::null()` is later dropped here\n    |         |       |\n-   |         |       has type `*const u8`\n+   |         |       has type `*const u8` which is not `Send`\n    |         await occurs here, with `std::ptr::null()` maybe used later\n help: consider moving this into a `let` binding to create a shorter lived borrow\n   --> $DIR/issue-65436-raw-ptr-not-send.rs:14:13"}, {"sha": "9ab2abf740572049a22c93b11c18fb4b091b56bf", "filename": "src/test/ui/generator/issue-68112.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fgenerator%2Fissue-68112.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fgenerator%2Fissue-68112.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-68112.rs?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -0,0 +1,56 @@\n+#![feature(generators, generator_trait)]\n+\n+use std::{\n+    cell::RefCell,\n+    sync::Arc,\n+    pin::Pin,\n+    ops::{Generator, GeneratorState},\n+};\n+\n+pub struct Ready<T>(Option<T>);\n+impl<T> Generator<()> for Ready<T> {\n+    type Return = T;\n+    type Yield = ();\n+    fn resume(mut self: Pin<&mut Self>, _args: ()) -> GeneratorState<(), T> {\n+        GeneratorState::Complete(self.0.take().unwrap())\n+    }\n+}\n+pub fn make_gen1<T>(t: T) -> Ready<T> {\n+    Ready(Some(t))\n+}\n+\n+fn require_send(_: impl Send) {}\n+\n+fn make_non_send_generator() -> impl Generator<Return = Arc<RefCell<i32>>> {\n+    make_gen1(Arc::new(RefCell::new(0)))\n+}\n+\n+fn test1() {\n+    let send_gen = || {\n+        let _non_send_gen = make_non_send_generator();\n+        yield;\n+    };\n+    require_send(send_gen);\n+    //~^ ERROR generator cannot be sent between threads\n+}\n+\n+pub fn make_gen2<T>(t: T) -> impl Generator<Return = T> {\n+    || {\n+        yield;\n+        t\n+    }\n+}\n+fn make_non_send_generator2() -> impl Generator<Return = Arc<RefCell<i32>>> {\n+    make_gen2(Arc::new(RefCell::new(0)))\n+}\n+\n+fn test2() {\n+    let send_gen = || {\n+        let _non_send_gen = make_non_send_generator2();\n+        yield;\n+    };\n+    require_send(send_gen);\n+    //~^ ERROR `std::cell::RefCell<i32>` cannot be shared between threads safely\n+}\n+\n+fn main() {}"}, {"sha": "83536f2af140631122d8f2425a76671783a8ff14", "filename": "src/test/ui/generator/issue-68112.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fgenerator%2Fissue-68112.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fgenerator%2Fissue-68112.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-68112.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -0,0 +1,40 @@\n+error: generator cannot be sent between threads safely\n+  --> $DIR/issue-68112.rs:33:5\n+   |\n+LL | fn require_send(_: impl Send) {}\n+   |                         ---- required by this bound in `require_send`\n+...\n+LL |     require_send(send_gen);\n+   |     ^^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: the trait `std::marker::Sync` is not implemented for `std::cell::RefCell<i32>`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/issue-68112.rs:31:9\n+   |\n+LL |         let _non_send_gen = make_non_send_generator();\n+   |             ------------- has type `impl std::ops::Generator` which is not `Send`\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `_non_send_gen` maybe used later\n+LL |     };\n+   |     - `_non_send_gen` is later dropped here\n+\n+error[E0277]: `std::cell::RefCell<i32>` cannot be shared between threads safely\n+  --> $DIR/issue-68112.rs:52:5\n+   |\n+LL | fn require_send(_: impl Send) {}\n+   |                         ---- required by this bound in `require_send`\n+...\n+LL |     require_send(send_gen);\n+   |     ^^^^^^^^^^^^ `std::cell::RefCell<i32>` cannot be shared between threads safely\n+   |\n+   = help: the trait `std::marker::Sync` is not implemented for `std::cell::RefCell<i32>`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc<std::cell::RefCell<i32>>`\n+   = note: required because it appears within the type `[generator@$DIR/issue-68112.rs:38:5: 41:6 t:std::sync::Arc<std::cell::RefCell<i32>> {()}]`\n+   = note: required because it appears within the type `impl std::ops::Generator`\n+   = note: required because it appears within the type `impl std::ops::Generator`\n+   = note: required because it appears within the type `{impl std::ops::Generator, ()}`\n+   = note: required because it appears within the type `[generator@$DIR/issue-68112.rs:48:20: 51:6 {impl std::ops::Generator, ()}]`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8ca5565fb2ab551982a5143b50682bedee8f3919", "filename": "src/test/ui/generator/not-send-sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     fn assert_send<T: Send>(_: T) {}\n \n     assert_sync(|| {\n-        //~^ ERROR: future cannot be shared between threads safely\n+        //~^ ERROR: generator cannot be shared between threads safely\n         let a = Cell::new(2);\n         yield;\n     });"}, {"sha": "5df2c1b52fb8a0cae66ec01e14e75ecd01b9317e", "filename": "src/test/ui/generator/not-send-sync.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ef360368ac4c97883dc45287e752517e308f0e/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr?ref=a3ef360368ac4c97883dc45287e752517e308f0e", "patch": "@@ -11,21 +11,21 @@ LL |     assert_send(|| {\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&std::cell::Cell<i32>`\n    = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:16:17: 20:6 a:&std::cell::Cell<i32> _]`\n \n-error: future cannot be shared between threads safely\n+error: generator cannot be shared between threads safely\n   --> $DIR/not-send-sync.rs:9:5\n    |\n LL |     fn assert_sync<T: Sync>(_: T) {}\n    |                       ---- required by this bound in `main::assert_sync`\n ...\n LL |     assert_sync(|| {\n-   |     ^^^^^^^^^^^ future returned by `main` is not `Sync`\n+   |     ^^^^^^^^^^^ generator is not `Sync`\n    |\n    = help: within `[generator@$DIR/not-send-sync.rs:9:17: 13:6 {std::cell::Cell<i32>, ()}]`, the trait `std::marker::Sync` is not implemented for `std::cell::Cell<i32>`\n-note: future is not `Sync` as this value is used across an yield\n+note: generator is not `Sync` as this value is used across a yield\n   --> $DIR/not-send-sync.rs:12:9\n    |\n LL |         let a = Cell::new(2);\n-   |             - has type `std::cell::Cell<i32>`\n+   |             - has type `std::cell::Cell<i32>` which is not `Sync`\n LL |         yield;\n    |         ^^^^^ yield occurs here, with `a` maybe used later\n LL |     });"}]}