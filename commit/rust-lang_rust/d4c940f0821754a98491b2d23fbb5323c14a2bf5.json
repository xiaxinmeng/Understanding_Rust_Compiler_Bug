{"sha": "d4c940f0821754a98491b2d23fbb5323c14a2bf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0Yzk0MGYwODIxNzU0YTk4NDkxYjJkMjNmYmI1MzIzYzE0YTJiZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-07T06:40:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-07T06:40:53Z"}, "message": "Auto merge of #75244 - Manishearth:rollup-dzfyjva, r=Manishearth\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #74774 (adds [*mut|*const] ptr::set_ptr_value)\n - #75079 (Disallow linking to items with a mismatched disambiguator)\n - #75203 (Make `IntoIterator` lifetime bounds of `&BTreeMap` match with `&HashMap` )\n - #75227 (Fix ICE when using asm! on an unsupported architecture)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ba9153869f4b175962c534009c784af190f58324", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba9153869f4b175962c534009c784af190f58324"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4c940f0821754a98491b2d23fbb5323c14a2bf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4c940f0821754a98491b2d23fbb5323c14a2bf5", "html_url": "https://github.com/rust-lang/rust/commit/d4c940f0821754a98491b2d23fbb5323c14a2bf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4c940f0821754a98491b2d23fbb5323c14a2bf5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98922795f68e86b0bca5aea8cfc66499d58eba1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/98922795f68e86b0bca5aea8cfc66499d58eba1a", "html_url": "https://github.com/rust-lang/rust/commit/98922795f68e86b0bca5aea8cfc66499d58eba1a"}, {"sha": "9ab750d05dfc112b132ea4774ae105ca00474e46", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ab750d05dfc112b132ea4774ae105ca00474e46", "html_url": "https://github.com/rust-lang/rust/commit/9ab750d05dfc112b132ea4774ae105ca00474e46"}], "stats": {"total": 501, "additions": 447, "deletions": 54}, "files": [{"sha": "1d5fa73d228e2a2938bcd68e6156874ca0aab212", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -1294,7 +1294,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K: 'a, V: 'a> IntoIterator for &'a BTreeMap<K, V> {\n+impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n \n@@ -1363,7 +1363,7 @@ impl<K, V> Clone for Iter<'_, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K: 'a, V: 'a> IntoIterator for &'a mut BTreeMap<K, V> {\n+impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n "}, {"sha": "a16970e9fd1802863411b74ac32da08acf1a24b2", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -656,6 +656,38 @@ impl<T: ?Sized> *const T {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n \n+    /// Sets the pointer value to `ptr`.\n+    ///\n+    /// In case `self` is a (fat) pointer to an unsized type, this operation\n+    /// will only affect the pointer part, whereas for (thin) pointers to\n+    /// sized types, this has the same effect as a simple assignment.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This function is primarily useful for allowing byte-wise pointer\n+    /// arithmetic on potentially fat pointers:\n+    ///\n+    /// ```\n+    /// #![feature(set_ptr_value)]\n+    /// # use core::fmt::Debug;\n+    /// let arr: [i32; 3] = [1, 2, 3];\n+    /// let mut ptr = &arr[0] as *const dyn Debug;\n+    /// let thin = ptr as *const u8;\n+    /// ptr = ptr.set_ptr_value(unsafe { thin.add(8).cast() });\n+    /// assert_eq!(unsafe { *(ptr as *const i32) }, 3);\n+    /// ```\n+    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[inline]\n+    pub fn set_ptr_value(mut self, val: *const ()) -> Self {\n+        let thin = &mut self as *mut *const T as *mut *const ();\n+        // SAFETY: In case of a thin pointer, this operations is identical\n+        // to a simple assignment. In case of a fat pointer, with the current\n+        // fat pointer layout implementation, the first field of such a\n+        // pointer is always the data pointer, which is likewise assigned.\n+        unsafe { *thin = val };\n+        self\n+    }\n+\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///"}, {"sha": "b47f90c59962926462cd306ac87baf8d4f05f580", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -712,6 +712,38 @@ impl<T: ?Sized> *mut T {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n \n+    /// Sets the pointer value to `ptr`.\n+    ///\n+    /// In case `self` is a (fat) pointer to an unsized type, this operation\n+    /// will only affect the pointer part, whereas for (thin) pointers to\n+    /// sized types, this has the same effect as a simple assignment.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This function is primarily useful for allowing byte-wise pointer\n+    /// arithmetic on potentially fat pointers:\n+    ///\n+    /// ```\n+    /// #![feature(set_ptr_value)]\n+    /// # use core::fmt::Debug;\n+    /// let mut arr: [i32; 3] = [1, 2, 3];\n+    /// let mut ptr = &mut arr[0] as *mut dyn Debug;\n+    /// let thin = ptr as *mut u8;\n+    /// ptr = ptr.set_ptr_value(unsafe { thin.add(8).cast() });\n+    /// assert_eq!(unsafe { *(ptr as *mut i32) }, 3);\n+    /// ```\n+    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[inline]\n+    pub fn set_ptr_value(mut self, val: *mut ()) -> Self {\n+        let thin = &mut self as *mut *mut T as *mut *mut ();\n+        // SAFETY: In case of a thin pointer, this operations is identical\n+        // to a simple assignment. In case of a fat pointer, with the current\n+        // fat pointer layout implementation, the first field of such a\n+        // pointer is always the data pointer, which is likewise assigned.\n+        unsafe { *thin = val };\n+        self\n+    }\n+\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///"}, {"sha": "f9e54903a661acc6734bad331f7325360317b907", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -1067,7 +1067,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             .collect();\n \n         // Stop if there were any errors when lowering the register classes\n-        if operands.len() != asm.operands.len() {\n+        if operands.len() != asm.operands.len() || sess.asm_arch.is_none() {\n             return hir::ExprKind::Err;\n         }\n "}, {"sha": "618f3e99c3f04a3a38617585c1f33bd51e551f80", "filename": "src/librustc_hir/def.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -150,7 +150,7 @@ impl DefKind {\n         }\n     }\n \n-    pub fn matches_ns(&self, ns: Namespace) -> bool {\n+    pub fn ns(&self) -> Option<Namespace> {\n         match self {\n             DefKind::Mod\n             | DefKind::Struct\n@@ -163,17 +163,17 @@ impl DefKind {\n             | DefKind::ForeignTy\n             | DefKind::TraitAlias\n             | DefKind::AssocTy\n-            | DefKind::TyParam => ns == Namespace::TypeNS,\n+            | DefKind::TyParam => Some(Namespace::TypeNS),\n \n             DefKind::Fn\n             | DefKind::Const\n             | DefKind::ConstParam\n             | DefKind::Static\n             | DefKind::Ctor(..)\n             | DefKind::AssocFn\n-            | DefKind::AssocConst => ns == Namespace::ValueNS,\n+            | DefKind::AssocConst => Some(Namespace::ValueNS),\n \n-            DefKind::Macro(..) => ns == Namespace::MacroNS,\n+            DefKind::Macro(..) => Some(Namespace::MacroNS),\n \n             // Not namespaced.\n             DefKind::AnonConst\n@@ -185,7 +185,7 @@ impl DefKind {\n             | DefKind::Use\n             | DefKind::ForeignMod\n             | DefKind::GlobalAsm\n-            | DefKind::Impl => false,\n+            | DefKind::Impl => None,\n         }\n     }\n }\n@@ -453,7 +453,7 @@ impl<Id> Res<Id> {\n \n     pub fn matches_ns(&self, ns: Namespace) -> bool {\n         match self {\n-            Res::Def(kind, ..) => kind.matches_ns(ns),\n+            Res::Def(kind, ..) => kind.ns() == Some(ns),\n             Res::PrimTy(..) | Res::SelfTy(..) | Res::ToolMod => ns == Namespace::TypeNS,\n             Res::SelfCtor(..) | Res::Local(..) => ns == Namespace::ValueNS,\n             Res::NonMacroAttr(..) => ns == Namespace::MacroNS,"}, {"sha": "069d333de183426c724a2a5302cf960b6d8ab569", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -607,6 +607,9 @@ pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n         Res::Def(DefKind::TyAlias, i) => (i, TypeKind::Typedef),\n         Res::Def(DefKind::Enum, i) => (i, TypeKind::Enum),\n         Res::Def(DefKind::Trait, i) => (i, TypeKind::Trait),\n+        Res::Def(DefKind::AssocTy | DefKind::AssocFn | DefKind::AssocConst, i) => {\n+            (cx.tcx.parent(i).unwrap(), TypeKind::Trait)\n+        }\n         Res::Def(DefKind::Struct, i) => (i, TypeKind::Struct),\n         Res::Def(DefKind::Union, i) => (i, TypeKind::Union),\n         Res::Def(DefKind::Mod, i) => (i, TypeKind::Module),"}, {"sha": "f84486347afcdbeca231eccb782e54ee83eec9a2", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 145, "deletions": 43, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -17,6 +17,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n \n+use std::cell::Cell;\n use std::ops::Range;\n \n use crate::clean::*;\n@@ -62,11 +63,15 @@ struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n     // NOTE: this may not necessarily be a module in the current crate\n     mod_ids: Vec<DefId>,\n+    /// This is used to store the kind of associated items,\n+    /// because `clean` and the disambiguator code expect them to be different.\n+    /// See the code for associated items on inherent impls for details.\n+    kind_side_channel: Cell<Option<DefKind>>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        LinkCollector { cx, mod_ids: Vec::new() }\n+        LinkCollector { cx, mod_ids: Vec::new(), kind_side_channel: Cell::new(None) }\n     }\n \n     fn variant_field(\n@@ -174,7 +179,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn resolve(\n         &self,\n         path_str: &str,\n-        disambiguator: Option<&str>,\n+        disambiguator: Option<Disambiguator>,\n         ns: Namespace,\n         current_item: &Option<String>,\n         parent_id: Option<DefId>,\n@@ -214,7 +219,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     Res::Def(DefKind::Mod, _) => {\n                         // This resolved to a module, but if we were passed `type@`,\n                         // we want primitive types to take precedence instead.\n-                        if disambiguator == Some(\"type\") {\n+                        if disambiguator == Some(Disambiguator::Namespace(Namespace::TypeNS)) {\n                             if let Some(prim) = is_primitive(path_str, ns) {\n                                 if extra_fragment.is_some() {\n                                     return Err(ErrorKind::AnchorFailure(AnchorFailure::Primitive));\n@@ -347,6 +352,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 AnchorFailure::AssocConstant\n                             }))\n                         } else {\n+                            // HACK(jynelson): `clean` expects the type, not the associated item.\n+                            // but the disambiguator logic expects the associated item.\n+                            // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                            self.kind_side_channel.replace(Some(item.kind.as_def_kind()));\n                             Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                         }\n                     } else {\n@@ -415,7 +424,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 AnchorFailure::Method\n                             }))\n                         } else {\n-                            Ok((ty_res, Some(format!(\"{}.{}\", kind, item_name))))\n+                            let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                            Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n                         }\n                     } else {\n                         self.variant_field(path_str, current_item, module_id)\n@@ -574,46 +584,14 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             };\n             let resolved_self;\n             let mut path_str;\n+            let disambiguator;\n             let (res, fragment) = {\n-                let mut kind = None;\n-                let mut disambiguator = None;\n-                path_str = if let Some(prefix) =\n-                    [\"struct@\", \"enum@\", \"type@\", \"trait@\", \"union@\", \"module@\", \"mod@\"]\n-                        .iter()\n-                        .find(|p| link.starts_with(**p))\n-                {\n-                    kind = Some(TypeNS);\n-                    disambiguator = Some(&prefix[..prefix.len() - 1]);\n-                    link.trim_start_matches(prefix)\n-                } else if let Some(prefix) =\n-                    [\"const@\", \"static@\", \"value@\", \"function@\", \"fn@\", \"method@\"]\n-                        .iter()\n-                        .find(|p| link.starts_with(**p))\n-                {\n-                    kind = Some(ValueNS);\n-                    disambiguator = Some(&prefix[..prefix.len() - 1]);\n-                    link.trim_start_matches(prefix)\n-                } else if link.ends_with(\"!()\") {\n-                    kind = Some(MacroNS);\n-                    link.trim_end_matches(\"!()\")\n-                } else if link.ends_with(\"()\") {\n-                    kind = Some(ValueNS);\n-                    disambiguator = Some(\"fn\");\n-                    link.trim_end_matches(\"()\")\n-                } else if link.starts_with(\"macro@\") {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"macro\");\n-                    link.trim_start_matches(\"macro@\")\n-                } else if link.starts_with(\"derive@\") {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"derive\");\n-                    link.trim_start_matches(\"derive@\")\n-                } else if link.ends_with('!') {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"macro\");\n-                    link.trim_end_matches('!')\n+                path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n+                    disambiguator = Some(d);\n+                    path\n                 } else {\n-                    &link[..]\n+                    disambiguator = None;\n+                    &link\n                 }\n                 .trim();\n \n@@ -646,7 +624,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                 }\n \n-                match kind {\n+                match disambiguator.map(Disambiguator::ns) {\n                     Some(ns @ ValueNS) => {\n                         match self.resolve(\n                             path_str,\n@@ -789,6 +767,42 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             } else {\n                 debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n \n+                // Disallow e.g. linking to enums with `struct@`\n+                if let Res::Def(kind, id) = res {\n+                    debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n+                    match (self.kind_side_channel.take().unwrap_or(kind), disambiguator) {\n+                        | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n+                        // NOTE: this allows 'method' to mean both normal functions and associated functions\n+                        // This can't cause ambiguity because both are in the same namespace.\n+                        | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n+                        // These are namespaces; allow anything in the namespace to match\n+                        | (_, Some(Disambiguator::Namespace(_)))\n+                        // If no disambiguator given, allow anything\n+                        | (_, None)\n+                        // All of these are valid, so do nothing\n+                        => {}\n+                        (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n+                        (_, Some(Disambiguator::Kind(expected))) => {\n+                            // The resolved item did not match the disambiguator; give a better error than 'not found'\n+                            let msg = format!(\"incompatible link kind for `{}`\", path_str);\n+                            report_diagnostic(cx, &msg, &item, &dox, link_range, |diag, sp| {\n+                                // HACK(jynelson): by looking at the source I saw the DefId we pass\n+                                // for `expected.descr()` doesn't matter, since it's not a crate\n+                                let note = format!(\"this link resolved to {} {}, which is not {} {}\", kind.article(), kind.descr(id), expected.article(), expected.descr(id));\n+                                let suggestion = Disambiguator::display_for(kind, path_str);\n+                                let help_msg = format!(\"to link to the {}, use its disambiguator\", kind.descr(id));\n+                                diag.note(&note);\n+                                if let Some(sp) = sp {\n+                                    diag.span_suggestion(sp, &help_msg, suggestion, Applicability::MaybeIncorrect);\n+                                } else {\n+                                    diag.help(&format!(\"{}: {}\", help_msg, suggestion));\n+                                }\n+                            });\n+                            continue;\n+                        }\n+                    }\n+                }\n+\n                 // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n                 if let Some((src_id, dst_id)) = res\n                     .opt_def_id()\n@@ -837,6 +851,94 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum Disambiguator {\n+    Kind(DefKind),\n+    Namespace(Namespace),\n+}\n+\n+impl Disambiguator {\n+    /// (disambiguator, path_str)\n+    fn from_str(link: &str) -> Result<(Self, &str), ()> {\n+        use Disambiguator::{Kind, Namespace as NS};\n+\n+        let find_suffix = || {\n+            let suffixes = [\n+                (\"!()\", DefKind::Macro(MacroKind::Bang)),\n+                (\"()\", DefKind::Fn),\n+                (\"!\", DefKind::Macro(MacroKind::Bang)),\n+            ];\n+            for &(suffix, kind) in &suffixes {\n+                if link.ends_with(suffix) {\n+                    return Ok((Kind(kind), link.trim_end_matches(suffix)));\n+                }\n+            }\n+            Err(())\n+        };\n+\n+        if let Some(idx) = link.find('@') {\n+            let (prefix, rest) = link.split_at(idx);\n+            let d = match prefix {\n+                \"struct\" => Kind(DefKind::Struct),\n+                \"enum\" => Kind(DefKind::Enum),\n+                \"trait\" => Kind(DefKind::Trait),\n+                \"union\" => Kind(DefKind::Union),\n+                \"module\" | \"mod\" => Kind(DefKind::Mod),\n+                \"const\" | \"constant\" => Kind(DefKind::Const),\n+                \"static\" => Kind(DefKind::Static),\n+                \"function\" | \"fn\" | \"method\" => Kind(DefKind::Fn),\n+                \"derive\" => Kind(DefKind::Macro(MacroKind::Derive)),\n+                \"type\" => NS(Namespace::TypeNS),\n+                \"value\" => NS(Namespace::ValueNS),\n+                \"macro\" => NS(Namespace::MacroNS),\n+                _ => return find_suffix(),\n+            };\n+            Ok((d, &rest[1..]))\n+        } else {\n+            find_suffix()\n+        }\n+    }\n+\n+    fn display_for(kind: DefKind, path_str: &str) -> String {\n+        if kind == DefKind::Macro(MacroKind::Bang) {\n+            return format!(\"{}!\", path_str);\n+        } else if kind == DefKind::Fn || kind == DefKind::AssocFn {\n+            return format!(\"{}()\", path_str);\n+        }\n+        let prefix = match kind {\n+            DefKind::Struct => \"struct\",\n+            DefKind::Enum => \"enum\",\n+            DefKind::Trait => \"trait\",\n+            DefKind::Union => \"union\",\n+            DefKind::Mod => \"mod\",\n+            DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst => {\n+                \"const\"\n+            }\n+            DefKind::Static => \"static\",\n+            DefKind::Macro(MacroKind::Derive) => \"derive\",\n+            // Now handle things that don't have a specific disambiguator\n+            _ => match kind\n+                .ns()\n+                .expect(\"tried to calculate a disambiguator for a def without a namespace?\")\n+            {\n+                Namespace::TypeNS => \"type\",\n+                Namespace::ValueNS => \"value\",\n+                Namespace::MacroNS => \"macro\",\n+            },\n+        };\n+        format!(\"{}@{}\", prefix, path_str)\n+    }\n+\n+    fn ns(self) -> Namespace {\n+        match self {\n+            Self::Namespace(n) => n,\n+            Self::Kind(k) => {\n+                k.ns().expect(\"only DefKinds with a valid namespace can be disambiguators\")\n+            }\n+        }\n+    }\n+}\n+\n /// Reports a diagnostic for an intra-doc link.\n ///\n /// If no link range is provided, or the source span of the link cannot be determined, the span of"}, {"sha": "1a7a2fce7a3f22afb2718df3b32777a713c1fa21", "filename": "src/test/rustdoc-ui/intra-links-disambiguator-mismatch.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -0,0 +1,68 @@\n+#![deny(broken_intra_doc_links)]\n+//~^ NOTE lint level is defined\n+pub enum S {}\n+\n+macro_rules! m {\n+    () => {};\n+}\n+\n+static s: usize = 0;\n+const c: usize = 0;\n+\n+trait T {}\n+\n+/// Link to [struct@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [mod@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [union@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [trait@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [struct@T]\n+//~^ ERROR incompatible link kind for `T`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [derive@m]\n+//~^ ERROR incompatible link kind for `m`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [const@s]\n+//~^ ERROR incompatible link kind for `s`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [static@c]\n+//~^ ERROR incompatible link kind for `c`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [fn@c]\n+//~^ ERROR incompatible link kind for `c`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [c()]\n+//~^ ERROR incompatible link kind for `c`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [const@f]\n+//~^ ERROR incompatible link kind for `f`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+pub fn f() {}"}, {"sha": "9edf838f9d88b7d6e62f32e154c82f8b48bb2d55", "filename": "src/test/rustdoc-ui/intra-links-disambiguator-mismatch.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -0,0 +1,95 @@\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:14:14\n+   |\n+LL | /// Link to [struct@S]\n+   |              ^^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this link resolved to an enum, which is not a struct\n+\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:19:14\n+   |\n+LL | /// Link to [mod@S]\n+   |              ^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+   = note: this link resolved to an enum, which is not a module\n+\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:24:14\n+   |\n+LL | /// Link to [union@S]\n+   |              ^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+   = note: this link resolved to an enum, which is not a union\n+\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:29:14\n+   |\n+LL | /// Link to [trait@S]\n+   |              ^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+   = note: this link resolved to an enum, which is not a trait\n+\n+error: incompatible link kind for `T`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:34:14\n+   |\n+LL | /// Link to [struct@T]\n+   |              ^^^^^^^^ help: to link to the trait, use its disambiguator: `trait@T`\n+   |\n+   = note: this link resolved to a trait, which is not a struct\n+\n+error: incompatible link kind for `m`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:39:14\n+   |\n+LL | /// Link to [derive@m]\n+   |              ^^^^^^^^ help: to link to the macro, use its disambiguator: `m!`\n+   |\n+   = note: this link resolved to a macro, which is not a derive macro\n+\n+error: incompatible link kind for `s`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:44:14\n+   |\n+LL | /// Link to [const@s]\n+   |              ^^^^^^^ help: to link to the static, use its disambiguator: `static@s`\n+   |\n+   = note: this link resolved to a static, which is not a constant\n+\n+error: incompatible link kind for `c`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:49:14\n+   |\n+LL | /// Link to [static@c]\n+   |              ^^^^^^^^ help: to link to the constant, use its disambiguator: `const@c`\n+   |\n+   = note: this link resolved to a constant, which is not a static\n+\n+error: incompatible link kind for `c`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:54:14\n+   |\n+LL | /// Link to [fn@c]\n+   |              ^^^^ help: to link to the constant, use its disambiguator: `const@c`\n+   |\n+   = note: this link resolved to a constant, which is not a function\n+\n+error: incompatible link kind for `c`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:59:14\n+   |\n+LL | /// Link to [c()]\n+   |              ^^^ help: to link to the constant, use its disambiguator: `const@c`\n+   |\n+   = note: this link resolved to a constant, which is not a function\n+\n+error: incompatible link kind for `f`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:64:14\n+   |\n+LL | /// Link to [const@f]\n+   |              ^^^^^^^ help: to link to the function, use its disambiguator: `f()`\n+   |\n+   = note: this link resolved to a function, which is not a constant\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "54270414c9dfe818e9ab51b5fc6c115ca6727ef8", "filename": "src/test/rustdoc/intra-link-trait-item.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Frustdoc%2Fintra-link-trait-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Frustdoc%2Fintra-link-trait-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-trait-item.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -0,0 +1,12 @@\n+// ignore-tidy-linelength\n+#![deny(broken_intra_doc_links)]\n+\n+/// Link to [S::assoc_fn()]\n+/// Link to [Default::default()]\n+// @has intra_link_trait_item/struct.S.html '//*[@href=\"../intra_link_trait_item/struct.S.html#method.assoc_fn\"]' 'S::assoc_fn()'\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default\"]' 'Default::default()'\n+pub struct S;\n+\n+impl S {\n+    pub fn assoc_fn() {}\n+}"}, {"sha": "eeeeb17dd4f3fd200d10e66ad9f1b913706eb4b0", "filename": "src/test/ui/asm/bad-arch.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Fui%2Fasm%2Fbad-arch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Fui%2Fasm%2Fbad-arch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-arch.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: --target wasm32-unknown-unknown\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![no_core]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+fn main() {\n+    unsafe {\n+        asm!(\"\");\n+        //~^ ERROR asm! is unsupported on this target\n+    }\n+}"}, {"sha": "daccc46c6e371694bd9447a93ef871688b237c3a", "filename": "src/test/ui/asm/bad-arch.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Fui%2Fasm%2Fbad-arch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Fui%2Fasm%2Fbad-arch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-arch.stderr?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -0,0 +1,8 @@\n+error[E0472]: asm! is unsupported on this target\n+  --> $DIR/bad-arch.rs:15:9\n+   |\n+LL |         asm!(\"\");\n+   |         ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "fda825bc65e8080cda0417d2b80dc11415232335", "filename": "src/test/ui/btreemap/btreemap_into_iterator_lifetime.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_into_iterator_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_into_iterator_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_into_iterator_lifetime.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+use std::collections::{BTreeMap, HashMap};\n+\n+trait Map\n+where\n+    for<'a> &'a Self: IntoIterator<Item = (&'a Self::Key, &'a Self::Value)>,\n+{\n+    type Key;\n+    type Value;\n+}\n+\n+impl<K, V> Map for HashMap<K, V> {\n+    type Key = K;\n+    type Value = V;\n+}\n+\n+impl<K, V> Map for BTreeMap<K, V> {\n+  type Key = K;\n+  type Value = V;\n+}\n+\n+fn main() {}"}, {"sha": "59f04372fff19218f45d30c178dde71c9349c31e", "filename": "src/test/ui/feature-gates/feature-gate-asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -1,4 +1,4 @@\n-// ignore-emscripten\n+// only-x86_64\n \n fn main() {\n     unsafe {"}, {"sha": "aa63aff1c5e3384a3c80d65bf102211d1f45a173", "filename": "src/test/ui/feature-gates/feature-gate-asm2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4c940f0821754a98491b2d23fbb5323c14a2bf5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs?ref=d4c940f0821754a98491b2d23fbb5323c14a2bf5", "patch": "@@ -1,4 +1,4 @@\n-// ignore-emscripten\n+// only-x86_64\n \n fn main() {\n     unsafe {"}]}