{"sha": "d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNmEyYTM2OGRmMmQxNWNkNGU5YzNlMWMzZThjODY3MjczMDc1MDI=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-02-15T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-02-16T22:52:05Z"}, "message": "Pass MPlaceTy by reference not value", "tree": {"sha": "2d0f2397b7229f5eb8156ea5d7a1524dc688db3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d0f2397b7229f5eb8156ea5d7a1524dc688db3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "html_url": "https://github.com/rust-lang/rust/commit/d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5888556efe102f855f273cd1a7b343fe08d8fc76", "url": "https://api.github.com/repos/rust-lang/rust/commits/5888556efe102f855f273cd1a7b343fe08d8fc76", "html_url": "https://github.com/rust-lang/rust/commit/5888556efe102f855f273cd1a7b343fe08d8fc76"}], "stats": {"total": 137, "additions": 72, "deletions": 65}, "files": [{"sha": "e9a0742d493d24b94168fa513ccc80af985282de", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -72,7 +72,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n             None => InternKind::Constant,\n         }\n     };\n-    intern_const_alloc_recursive(ecx, intern_kind, ret)?;\n+    intern_const_alloc_recursive(ecx, intern_kind, &ret)?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n@@ -137,7 +137,7 @@ pub(super) fn op_to_const<'tcx>(\n         op.try_as_mplace(ecx)\n     };\n \n-    let to_const_value = |mplace: MPlaceTy<'_>| match mplace.ptr {\n+    let to_const_value = |mplace: &MPlaceTy<'_>| match mplace.ptr {\n         Scalar::Ptr(ptr) => {\n             let alloc = ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory();\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n@@ -155,12 +155,12 @@ pub(super) fn op_to_const<'tcx>(\n         }\n     };\n     match immediate {\n-        Ok(mplace) => to_const_value(mplace),\n+        Ok(ref mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n         Err(imm) => match *imm {\n             Immediate::Scalar(x) => match x {\n                 ScalarMaybeUninit::Scalar(s) => ConstValue::Scalar(s),\n-                ScalarMaybeUninit::Uninit => to_const_value(op.assert_mem_place(ecx)),\n+                ScalarMaybeUninit::Uninit => to_const_value(&op.assert_mem_place(ecx)),\n             },\n             Immediate::ScalarPair(a, b) => {\n                 let (data, start) = match a.check_init().unwrap() {"}, {"sha": "14b67fe119413f45e53a54b16893ea2f014cb0a8", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -40,7 +40,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n             assert!(args.len() == 1);\n \n             let msg_place = self.deref_operand(&args[0])?;\n-            let msg = Symbol::intern(self.read_str(msg_place)?);\n+            let msg = Symbol::intern(self.read_str(&msg_place)?);\n             let span = self.find_closest_untracked_caller_location();\n             let (file, line, col) = self.location_triple_for_span(span);\n             Err(ConstEvalErrKind::Panic { msg, file, line, col }.into())"}, {"sha": "a4e1cd2faa3c0244f0c1238d2c787e1b85e3e3ee", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn const_caller_location(\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place).is_err() {\n+    if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &loc_place).is_err() {\n         bug!(\"intern_const_alloc_recursive should not error in this case\")\n     }\n     ConstValue::Scalar(loc_place.ptr)"}, {"sha": "c56f8a40678cf2c2eb31a2c2399aa346c3c5f6c6", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -548,8 +548,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This can fail to provide an answer for extern types.\n     pub(super) fn size_and_align_of(\n         &self,\n-        metadata: MemPlaceMeta<M::PointerTag>,\n-        layout: TyAndLayout<'tcx>,\n+        metadata: &MemPlaceMeta<M::PointerTag>,\n+        layout: &TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n         if !layout.is_unsized() {\n             return Ok(Some((layout.size, layout.align.abi)));\n@@ -577,7 +577,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // the last field).  Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1)?;\n-                let (unsized_size, unsized_align) = match self.size_and_align_of(metadata, field)? {\n+                let (unsized_size, unsized_align) = match self.size_and_align_of(metadata, &field)? {\n                     Some(size_and_align) => size_and_align,\n                     None => {\n                         // A field with extern type.  If this field is at offset 0, we behave\n@@ -645,9 +645,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn size_and_align_of_mplace(\n         &self,\n-        mplace: MPlaceTy<'tcx, M::PointerTag>,\n+        mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n-        self.size_and_align_of(mplace.meta, mplace.layout)\n+        self.size_and_align_of(&mplace.meta, &mplace.layout)\n     }\n \n     pub fn push_stack_frame("}, {"sha": "42601ce2195e73d6d50e9a40c2f3506188c2768a", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -296,7 +296,7 @@ pub enum InternKind {\n pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx, const_eval::MemoryKind>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n-    ret: MPlaceTy<'tcx>,\n+    ret: &MPlaceTy<'tcx>,\n ) -> Result<(), ErrorReported>\n where\n     'tcx: 'mir,\n@@ -328,7 +328,7 @@ where\n         Some(ret.layout.ty),\n     );\n \n-    ref_tracking.track((ret, base_intern_mode), || ());\n+    ref_tracking.track((*ret, base_intern_mode), || ());\n \n     while let Some(((mplace, mode), _)) = ref_tracking.todo.pop() {\n         let res = InternVisitor {\n@@ -435,11 +435,11 @@ impl<'mir, 'tcx: 'mir, M: super::intern::CompileTimeMachine<'mir, 'tcx, !>>\n         layout: TyAndLayout<'tcx>,\n         f: impl FnOnce(\n             &mut InterpCx<'mir, 'tcx, M>,\n-            MPlaceTy<'tcx, M::PointerTag>,\n+            &MPlaceTy<'tcx, M::PointerTag>,\n         ) -> InterpResult<'tcx, ()>,\n     ) -> InterpResult<'tcx, &'tcx Allocation> {\n         let dest = self.allocate(layout, MemoryKind::Stack);\n-        f(self, dest)?;\n+        f(self, &dest)?;\n         let ptr = dest.ptr.assert_ptr();\n         assert_eq!(ptr.offset, Size::ZERO);\n         let mut alloc = self.memory.alloc_map.remove(&ptr.alloc_id).unwrap().1;"}, {"sha": "00f8a3d0ce26d81ce5973bb526854a32e14f041a", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -145,7 +145,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // dereferencable!\n                 let place = self.ref_to_mplace(&self.read_immediate(&args[0])?)?;\n                 let (size, align) = self\n-                    .size_and_align_of_mplace(place)?\n+                    .size_and_align_of_mplace(&place)?\n                     .ok_or_else(|| err_unsup_format!(\"`extern type` does not have known layout\"))?;\n \n                 let result = match intrinsic_name {"}, {"sha": "4dfdc08b875c04fee49a5dbf11e9a1d414d3b849", "filename": "compiler/rustc_mir/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -92,11 +92,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation);\n \n         // Initialize fields.\n-        self.write_immediate(file.to_ref(), &self.mplace_field(location, 0).unwrap().into())\n+        self.write_immediate(file.to_ref(), &self.mplace_field(&location, 0).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n-        self.write_scalar(line, &self.mplace_field(location, 1).unwrap().into())\n+        self.write_scalar(line, &self.mplace_field(&location, 1).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n-        self.write_scalar(col, &self.mplace_field(location, 2).unwrap().into())\n+        self.write_scalar(col, &self.mplace_field(&location, 2).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n \n         location"}, {"sha": "f85191f459fa950c5e0b86efd1cf28f5329db72c", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -180,6 +180,13 @@ impl<'tcx, Tag: Copy> From<MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     }\n }\n \n+impl<'tcx, Tag: Copy> From<&'_ MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+    #[inline(always)]\n+    fn from(mplace: &MPlaceTy<'tcx, Tag>) -> Self {\n+        OpTy { op: Operand::Indirect(**mplace), layout: mplace.layout }\n+    }\n+}\n+\n impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(val: ImmTy<'tcx, Tag>) -> Self {\n@@ -243,7 +250,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace(\n         &self,\n-        mplace: MPlaceTy<'tcx, M::PointerTag>,\n+        mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n@@ -307,11 +314,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         src: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n         Ok(match src.try_as_mplace(self) {\n-            Ok(mplace) => {\n+            Ok(ref mplace) => {\n                 if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n                     Ok(val)\n                 } else {\n-                    Err(mplace)\n+                    Err(*mplace)\n                 }\n             }\n             Err(val) => Ok(val),\n@@ -340,7 +347,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     // Turn the wide MPlace into a string (must already be dereferenced!)\n-    pub fn read_str(&self, mplace: MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n+    pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len))?;\n         let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n@@ -354,7 +361,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base = match op.try_as_mplace(self) {\n-            Ok(mplace) => {\n+            Ok(ref mplace) => {\n                 // We can reuse the mplace field computation logic for indirect operands.\n                 let field = self.mplace_field(mplace, field)?;\n                 return Ok(field.into());\n@@ -397,7 +404,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         } else {\n             // Indexing into a big array. This must be an mplace.\n             let mplace = op.assert_mem_place(self);\n-            Ok(self.mplace_index(mplace, index)?.into())\n+            Ok(self.mplace_index(&mplace, index)?.into())\n         }\n     }\n \n@@ -408,7 +415,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n         Ok(match op.try_as_mplace(self) {\n-            Ok(mplace) => self.mplace_downcast(mplace, variant)?.into(),\n+            Ok(ref mplace) => self.mplace_downcast(mplace, variant)?.into(),\n             Err(..) => {\n                 let layout = op.layout.for_variant(self, variant);\n                 OpTy { layout, ..*op }\n@@ -430,7 +437,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The rest should only occur as mplace, we do not use Immediates for types\n                 // allowing such operations.  This matches place_projection forcing an allocation.\n                 let mplace = base.assert_mem_place(self);\n-                self.mplace_projection(mplace, proj_elem)?.into()\n+                self.mplace_projection(&mplace, proj_elem)?.into()\n             }\n         })\n     }"}, {"sha": "392f739e84fd6dfb2429fc05d7bd9cc9f6f3ab9b", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -183,7 +183,7 @@ impl<Tag> MemPlace<Tag> {\n     }\n }\n \n-impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Copy> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n     pub fn dangling(layout: TyAndLayout<'tcx>, cx: &impl HasDataLayout) -> Self {\n@@ -195,13 +195,13 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n \n     /// Replace ptr tag, maintain vtable tag (if any)\n     #[inline]\n-    pub fn replace_tag(self, new_tag: Tag) -> Self {\n+    pub fn replace_tag(&self, new_tag: Tag) -> Self {\n         MPlaceTy { mplace: self.mplace.replace_tag(new_tag), layout: self.layout }\n     }\n \n     #[inline]\n     pub fn offset(\n-        self,\n+        &self,\n         offset: Size,\n         meta: MemPlaceMeta<Tag>,\n         layout: TyAndLayout<'tcx>,\n@@ -216,7 +216,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn len(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n+    pub(super) fn len(&self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind() {\n@@ -234,7 +234,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn vtable(self) -> Scalar<Tag> {\n+    pub(super) fn vtable(&self) -> Scalar<Tag> {\n         match self.layout.ty.kind() {\n             ty::Dynamic(..) => self.mplace.meta.unwrap_meta(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n@@ -348,7 +348,7 @@ where\n     #[inline]\n     pub(super) fn check_mplace_access(\n         &self,\n-        place: MPlaceTy<'tcx, M::PointerTag>,\n+        place: &MPlaceTy<'tcx, M::PointerTag>,\n         size: Option<Size>,\n     ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n         let size = size.unwrap_or_else(|| {\n@@ -370,13 +370,13 @@ where\n         force_align: Option<Align>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let (size, align) = self\n-            .size_and_align_of_mplace(place)?\n+            .size_and_align_of_mplace(&place)?\n             .unwrap_or((place.layout.size, place.layout.align.abi));\n         assert!(place.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n         // Check (stricter) dynamic alignment, unless forced otherwise.\n         place.mplace.align = force_align.unwrap_or(align);\n         // When dereferencing a pointer, it must be non-NULL, aligned, and live.\n-        if let Some(ptr) = self.check_mplace_access(place, Some(size))? {\n+        if let Some(ptr) = self.check_mplace_access(&place, Some(size))? {\n             place.mplace.ptr = ptr.into();\n         }\n         Ok(place)\n@@ -401,7 +401,7 @@ where\n     #[inline(always)]\n     pub fn mplace_field(\n         &self,\n-        base: MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n         field: usize,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let offset = base.layout.fields.offset(field);\n@@ -412,7 +412,7 @@ where\n             // Re-use parent metadata to determine dynamic field layout.\n             // With custom DSTS, this *will* execute user-defined code, but the same\n             // happens at run-time so that's okay.\n-            let align = match self.size_and_align_of(base.meta, field_layout)? {\n+            let align = match self.size_and_align_of(&base.meta, &field_layout)? {\n                 Some((_, align)) => align,\n                 None if offset == Size::ZERO => {\n                     // An extern type at offset 0, we fall back to its static alignment.\n@@ -442,7 +442,7 @@ where\n     #[inline(always)]\n     pub fn mplace_index(\n         &self,\n-        base: MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n         index: u64,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Not using the layout method because we want to compute on u64\n@@ -472,8 +472,8 @@ where\n     // same by repeatedly calling `mplace_array`.\n     pub(super) fn mplace_array_fields(\n         &self,\n-        base: MPlaceTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'tcx>\n+        base: &'a MPlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'a>\n     {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n@@ -488,7 +488,7 @@ where\n \n     fn mplace_subslice(\n         &self,\n-        base: MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n         from: u64,\n         to: u64,\n         from_end: bool,\n@@ -533,18 +533,18 @@ where\n \n     pub(super) fn mplace_downcast(\n         &self,\n-        base: MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n         assert!(!base.meta.has_meta());\n-        Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n+        Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..*base })\n     }\n \n     /// Project into an mplace\n     pub(super) fn mplace_projection(\n         &self,\n-        base: MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n         proj_elem: mir::PlaceElem<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n@@ -598,7 +598,7 @@ where\n         // FIXME: We could try to be smarter and avoid allocation for fields that span the\n         // entire place.\n         let mplace = self.force_allocation(base)?;\n-        Ok(self.mplace_field(mplace, field)?.into())\n+        Ok(self.mplace_field(&mplace, field)?.into())\n     }\n \n     pub fn place_index(\n@@ -607,7 +607,7 @@ where\n         index: u64,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         let mplace = self.force_allocation(base)?;\n-        Ok(self.mplace_index(mplace, index)?.into())\n+        Ok(self.mplace_index(&mplace, index)?.into())\n     }\n \n     pub fn place_downcast(\n@@ -618,7 +618,7 @@ where\n         // Downcast just changes the layout\n         Ok(match base.place {\n             Place::Ptr(mplace) => {\n-                self.mplace_downcast(MPlaceTy { mplace, layout: base.layout }, variant)?.into()\n+                self.mplace_downcast(&MPlaceTy { mplace, layout: base.layout }, variant)?.into()\n             }\n             Place::Local { .. } => {\n                 let layout = base.layout.for_variant(self, variant);\n@@ -642,7 +642,7 @@ where\n             // This matches `operand_projection`.\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n                 let mplace = self.force_allocation(base)?;\n-                self.mplace_projection(mplace, proj_elem)?.into()\n+                self.mplace_projection(&mplace, proj_elem)?.into()\n             }\n         })\n     }\n@@ -708,7 +708,7 @@ where\n     pub fn write_immediate_to_mplace(\n         &mut self,\n         src: Immediate<M::PointerTag>,\n-        dest: MPlaceTy<'tcx, M::PointerTag>,\n+        dest: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate_to_mplace_no_validate(src, dest)?;\n \n@@ -769,7 +769,7 @@ where\n         let dest = MPlaceTy { mplace, layout: dest.layout };\n \n         // This is already in memory, write there.\n-        self.write_immediate_to_mplace_no_validate(src, dest)\n+        self.write_immediate_to_mplace_no_validate(src, &dest)\n     }\n \n     /// Write an immediate to memory.\n@@ -778,7 +778,7 @@ where\n     fn write_immediate_to_mplace_no_validate(\n         &mut self,\n         value: Immediate<M::PointerTag>,\n-        dest: MPlaceTy<'tcx, M::PointerTag>,\n+        dest: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // Note that it is really important that the type here is the right one, and matches the\n         // type things are read at. In case `src_val` is a `ScalarPair`, we don't do any magic here\n@@ -903,10 +903,10 @@ where\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n \n         let src = self\n-            .check_mplace_access(src, Some(size))\n+            .check_mplace_access(&src, Some(size))\n             .expect(\"places should be checked on creation\");\n         let dest = self\n-            .check_mplace_access(dest, Some(size))\n+            .check_mplace_access(&dest, Some(size))\n             .expect(\"places should be checked on creation\");\n         let (src_ptr, dest_ptr) = match (src, dest) {\n             (Some(src_ptr), Some(dest_ptr)) => (src_ptr, dest_ptr),\n@@ -996,7 +996,7 @@ where\n                             self.layout_of_local(&self.stack()[frame], local, None)?;\n                         // We also need to support unsized types, and hence cannot use `allocate`.\n                         let (size, align) = self\n-                            .size_and_align_of(meta, local_layout)?\n+                            .size_and_align_of(&meta, &local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n                         let ptr = self.memory.allocate(size, align, MemoryKind::Stack);\n                         let mplace = MemPlace { ptr: ptr.into(), align, meta };\n@@ -1005,7 +1005,7 @@ where\n                             // We don't have to validate as we can assume the local\n                             // was already valid for its type.\n                             let mplace = MPlaceTy { mplace, layout: local_layout };\n-                            self.write_immediate_to_mplace_no_validate(value, mplace)?;\n+                            self.write_immediate_to_mplace_no_validate(value, &mplace)?;\n                         }\n                         // Now we can call `access_mut` again, asserting it goes well,\n                         // and actually overwrite things.\n@@ -1146,7 +1146,7 @@ where\n     /// Also return some more information so drop doesn't have to run the same code twice.\n     pub(super) fn unpack_dyn_trait(\n         &self,\n-        mplace: MPlaceTy<'tcx, M::PointerTag>,\n+        mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n         let vtable = mplace.vtable(); // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n@@ -1160,7 +1160,7 @@ where\n             assert_eq!(align, layout.align.abi);\n         }\n \n-        let mplace = MPlaceTy { mplace: MemPlace { meta: MemPlaceMeta::None, ..*mplace }, layout };\n+        let mplace = MPlaceTy { mplace: MemPlace { meta: MemPlaceMeta::None, ..**mplace }, layout };\n         Ok((instance, mplace))\n     }\n }"}, {"sha": "64d7c8ef2c719daa16d3e11e8e77f188f5d3ba1c", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -218,9 +218,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let dest = self.force_allocation(&dest)?;\n                 let length = dest.len(self)?;\n \n-                if let Some(first_ptr) = self.check_mplace_access(dest, None)? {\n+                if let Some(first_ptr) = self.check_mplace_access(&dest, None)? {\n                     // Write the first.\n-                    let first = self.mplace_field(dest, 0)?;\n+                    let first = self.mplace_field(&dest, 0)?;\n                     self.copy_op(&op, &first.into())?;\n \n                     if length > 1 {"}, {"sha": "e4325d6d1e955ba235f28d8ba5ab67e95d30988a", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -444,7 +444,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let (instance, place) = match place.layout.ty.kind() {\n             ty::Dynamic(..) => {\n                 // Dropping a trait object.\n-                self.unpack_dyn_trait(place)?\n+                self.unpack_dyn_trait(&place)?\n             }\n             _ => (instance, place),\n         };"}, {"sha": "f33859f3f863378b102e7d4ce00613daa550a092", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -395,7 +395,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         }\n         // Make sure this is dereferenceable and all.\n         let size_and_align = try_validation!(\n-            self.ecx.size_and_align_of_mplace(place),\n+            self.ecx.size_and_align_of_mplace(&place),\n             self.path,\n             err_ub!(InvalidMeta(msg)) => { \"invalid {} metadata: {}\", kind, msg },\n         );"}, {"sha": "e05a1c0e0b2e34cb0ab0e561af08ba698cc7a428", "filename": "compiler/rustc_mir/src/interpret/visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06a2a368df2d15cd4e9c3e1c3e8c86727307502/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs?ref=d06a2a368df2d15cd4e9c3e1c3e8c86727307502", "patch": "@@ -102,7 +102,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n-        ecx.mplace_downcast(*self, variant)\n+        ecx.mplace_downcast(self, variant)\n     }\n \n     #[inline(always)]\n@@ -111,7 +111,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         field: usize,\n     ) -> InterpResult<'tcx, Self> {\n-        ecx.mplace_field(*self, field)\n+        ecx.mplace_field(self, field)\n     }\n }\n \n@@ -208,7 +208,7 @@ macro_rules! make_value_visitor {\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n                         let dest = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n-                        let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n+                        let inner = self.ecx().unpack_dyn_trait(&dest)?.1;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n                         // recurse with the inner type\n                         return self.visit_field(&v, 0, &Value::from_mem_place(inner));\n@@ -241,7 +241,7 @@ macro_rules! make_value_visitor {\n                         // Now we can go over all the fields.\n                         // This uses the *run-time length*, i.e., if we are a slice,\n                         // the dynamic info from the metadata is used.\n-                        let iter = self.ecx().mplace_array_fields(mplace)?\n+                        let iter = self.ecx().mplace_array_fields(&mplace)?\n                             .map(|f| f.and_then(|f| {\n                                 Ok(Value::from_mem_place(f))\n                             }));"}]}