{"sha": "9a8233d3772fbdb3d496aac3e4693e6d4c30e125", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhODIzM2QzNzcyZmJkYjNkNDk2YWFjM2U0NjkzZTZkNGMzMGUxMjU=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-08-19T20:45:28Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-08-28T16:12:54Z"}, "message": "stabilize core::result\n\nPer API meeting\n\n  https://github.com/rust-lang/meeting-minutes/blob/master/Meeting-API-review-2014-08-13.md\n\nMost of the module is marked as stable or unstable; most of the unstable\nitems are awaiting resolution of conventions issues.\n\n* `collect`: this functionality is being moved to a new `FromIterator`\n  impl.\n* `fold_` is deprecated due to lack of use\n* Several methods found in `core::option` are added here, including\n  `iter`, `as_slice`, and variants.\n\nDue to deprecations, this is a:\n\n[breaking-change]", "tree": {"sha": "ccf71d4fc58395283399be7deba26d2f90ce7810", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccf71d4fc58395283399be7deba26d2f90ce7810"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a8233d3772fbdb3d496aac3e4693e6d4c30e125", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a8233d3772fbdb3d496aac3e4693e6d4c30e125", "html_url": "https://github.com/rust-lang/rust/commit/9a8233d3772fbdb3d496aac3e4693e6d4c30e125", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a8233d3772fbdb3d496aac3e4693e6d4c30e125/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "276b8b125d3f60cebab702542b60207429fbb333", "url": "https://api.github.com/repos/rust-lang/rust/commits/276b8b125d3f60cebab702542b60207429fbb333", "html_url": "https://github.com/rust-lang/rust/commit/276b8b125d3f60cebab702542b60207429fbb333"}], "stats": {"total": 214, "additions": 173, "deletions": 41}, "files": [{"sha": "bf351ecc89b1fd44702ef8c049c730fc6c99aaf2", "filename": "src/libcore/result.rs", "status": "modified", "additions": 173, "deletions": 41, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/9a8233d3772fbdb3d496aac3e4693e6d4c30e125/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a8233d3772fbdb3d496aac3e4693e6d4c30e125/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9a8233d3772fbdb3d496aac3e4693e6d4c30e125", "patch": "@@ -274,17 +274,22 @@\n //! the context. The caller of `fail!` should assume that execution\n //! will not resume after failure, that failure is catastrophic.\n \n+#![stable]\n+\n use clone::Clone;\n use cmp::PartialEq;\n use std::fmt::Show;\n-use iter::{Iterator, FromIterator};\n+use slice;\n+use slice::Slice;\n+use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use option::{None, Option, Some};\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n /// See the [`std::result`](index.html) module documentation for details.\n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show)]\n #[must_use]\n+#[stable]\n pub enum Result<T, E> {\n     /// Contains the success value\n     Ok(T),\n@@ -315,6 +320,7 @@ impl<T, E> Result<T, E> {\n     /// # }\n     /// ~~~\n     #[inline]\n+    #[stable]\n     pub fn is_ok(&self) -> bool {\n         match *self {\n             Ok(_) => true,\n@@ -335,6 +341,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(bogus.is_err());\n     /// ~~~\n     #[inline]\n+    #[stable]\n     pub fn is_err(&self) -> bool {\n         !self.is_ok()\n     }\n@@ -362,6 +369,7 @@ impl<T, E> Result<T, E> {\n     /// let bdays: File = bdays.ok().expect(\"unable to open birthday file\");\n     /// ~~~\n     #[inline]\n+    #[stable]\n     pub fn ok(self) -> Option<T> {\n         match self {\n             Ok(x)  => Some(x),\n@@ -374,6 +382,7 @@ impl<T, E> Result<T, E> {\n     /// Converts `self` into an `Option<T>`, consuming `self`,\n     /// and discarding the value, if any.\n     #[inline]\n+    #[stable]\n     pub fn err(self) -> Option<E> {\n         match self {\n             Ok(_)  => None,\n@@ -390,6 +399,7 @@ impl<T, E> Result<T, E> {\n     /// Produces a new `Result`, containing a reference\n     /// into the original, leaving the original in place.\n     #[inline]\n+    #[stable]\n     pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> {\n         match *self {\n             Ok(ref x) => Ok(x),\n@@ -399,13 +409,28 @@ impl<T, E> Result<T, E> {\n \n     /// Convert from `Result<T, E>` to `Result<&mut T, &mut E>`\n     #[inline]\n+    #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> {\n         match *self {\n             Ok(ref mut x) => Ok(x),\n             Err(ref mut x) => Err(x),\n         }\n     }\n \n+    /// Convert from `Result<T, E>` to `&mut [T]` (without copying)\n+    #[inline]\n+    #[unstable = \"waiting for mut conventions\"]\n+    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n+        match *self {\n+            Ok(ref mut x) => slice::mut_ref_slice(x),\n+            Err(_) => {\n+                // work around lack of implicit coercion from fixed-size array to slice\n+                let emp: &mut [_] = &mut [];\n+                emp\n+            }\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Transforming contained values\n     /////////////////////////////////////////////////////////////////////////\n@@ -441,6 +466,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(sum == 10);\n     /// ~~~\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {\n         match self {\n           Ok(t) => Ok(op(t)),\n@@ -454,19 +480,47 @@ impl<T, E> Result<T, E> {\n     /// This function can be used to pass through a successful result while handling\n     /// an error.\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> {\n         match self {\n           Ok(t) => Ok(t),\n           Err(e) => Err(op(e))\n         }\n     }\n \n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Iterator constructors\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns an iterator over the possibly contained value.\n+    #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n+    pub fn iter<'r>(&'r self) -> Item<&'r T> {\n+        Item{opt: self.as_ref().ok()}\n+    }\n+\n+    /// Returns a mutable iterator over the possibly contained value.\n+    #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n+    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n+        Item{opt: self.as_mut().ok()}\n+    }\n+\n+    /// Returns a consuming iterator over the possibly contained value.\n+    #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n+    pub fn move_iter(self) -> Item<T> {\n+        Item{opt: self.ok()}\n+    }\n+\n     ////////////////////////////////////////////////////////////////////////\n     // Boolean operations on the values, eager and lazy\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n     #[inline]\n+    #[stable]\n     pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(_) => res,\n@@ -478,6 +532,7 @@ impl<T, E> Result<T, E> {\n     ///\n     /// This function can be used for control flow based on result values\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n@@ -487,6 +542,7 @@ impl<T, E> Result<T, E> {\n \n     /// Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n     #[inline]\n+    #[stable]\n     pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n         match self {\n             Ok(_) => self,\n@@ -498,6 +554,7 @@ impl<T, E> Result<T, E> {\n     ///\n     /// This function can be used for control flow based on result values\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -508,6 +565,7 @@ impl<T, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     /// Else it returns `optb`.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or(self, optb: T) -> T {\n         match self {\n             Ok(t) => t,\n@@ -518,6 +576,7 @@ impl<T, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     /// If the value is an `Err` then it calls `op` with its value.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or_else(self, op: |E| -> T) -> T {\n         match self {\n             Ok(t) => t,\n@@ -541,6 +600,7 @@ impl<T, E: Show> Result<T, E> {\n     /// Fails if the value is an `Err`, with a custom failure message provided\n     /// by the `Err`'s value.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n@@ -558,6 +618,7 @@ impl<T: Show, E> Result<T, E> {\n     /// Fails if the value is an `Ok`, with a custom failure message provided\n     /// by the `Ok`'s value.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n@@ -568,57 +629,124 @@ impl<T: Show, E> Result<T, E> {\n }\n \n /////////////////////////////////////////////////////////////////////////////\n-// Free functions\n+// Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Takes each element in the `Iterator`: if it is an `Err`, no further\n-/// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n-/// vector containing the values of each `Result` is returned.\n-///\n-/// Here is an example which increments every integer in a vector,\n-/// checking for overflow:\n-///\n-/// ```rust\n-/// use std::result;\n-/// use std::uint;\n+impl<T, E> Slice<T> for Result<T, E> {\n+    /// Convert from `Result<T, E>` to `&[T]` (without copying)\n+    #[inline]\n+    #[stable]\n+    fn as_slice<'a>(&'a self) -> &'a [T] {\n+        match *self {\n+            Ok(ref x) => slice::ref_slice(x),\n+            Err(_) => {\n+                // work around lack of implicit coercion from fixed-size array to slice\n+                let emp: &[_] = &[];\n+                emp\n+            }\n+        }\n+    }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// The Result Iterator\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// A `Result` iterator that yields either one or zero elements\n ///\n-/// let v = vec!(1u, 2u);\n-/// let res: Result<Vec<uint>, &'static str> = result::collect(v.iter().map(|x: &uint|\n-///     if *x == uint::MAX { Err(\"Overflow!\") }\n-///     else { Ok(x + 1) }\n-/// ));\n-/// assert!(res == Ok(vec!(2u, 3u)));\n-/// ```\n-#[inline]\n-pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Iter) -> Result<V, E> {\n-    // FIXME(#11084): This could be replaced with Iterator::scan when this\n-    // performance bug is closed.\n+/// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n+/// methods on `Result`.\n+#[deriving(Clone)]\n+#[unstable = \"waiting for iterator conventions\"]\n+pub struct Item<T> {\n+    opt: Option<T>\n+}\n+\n+impl<T> Iterator<T> for Item<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.opt.take()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        match self.opt {\n+            Some(_) => (1, Some(1)),\n+            None => (0, Some(0)),\n+        }\n+    }\n+}\n \n-    struct Adapter<Iter, E> {\n-        iter: Iter,\n-        err: Option<E>,\n+impl<A> DoubleEndedIterator<A> for Item<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        self.opt.take()\n     }\n+}\n+\n+impl<A> ExactSize<A> for Item<A> {}\n \n-    impl<T, E, Iter: Iterator<Result<T, E>>> Iterator<T> for Adapter<Iter, E> {\n-        #[inline]\n-        fn next(&mut self) -> Option<T> {\n-            match self.iter.next() {\n-                Some(Ok(value)) => Some(value),\n-                Some(Err(err)) => {\n-                    self.err = Some(err);\n-                    None\n+/////////////////////////////////////////////////////////////////////////////\n+// Free functions\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Deprecated: use `Iterator::collect`.\n+#[inline]\n+#[deprecated = \"use Iterator::collect instead\"]\n+pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(mut iter: Iter)\n+                                                                       -> Result<V, E> {\n+    iter.collect()\n+}\n+\n+impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n+    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n+    /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n+    /// container with the values of each `Result` is returned.\n+    ///\n+    /// Here is an example which increments every integer in a vector,\n+    /// checking for overflow:\n+    ///\n+    /// ```rust\n+    /// use std::uint;\n+    ///\n+    /// let v = vec!(1u, 2u);\n+    /// let res: Result<Vec<uint>, &'static str> = v.iter().map(|x: &uint|\n+    ///     if *x == uint::MAX { Err(\"Overflow!\") }\n+    ///     else { Ok(x + 1) }\n+    /// ).collect();\n+    /// assert!(res == Ok(vec!(2u, 3u)));\n+    /// ```\n+    #[inline]\n+    fn from_iter<I: Iterator<Result<A, E>>>(iter: I) -> Result<V, E> {\n+        // FIXME(#11084): This could be replaced with Iterator::scan when this\n+        // performance bug is closed.\n+\n+        struct Adapter<Iter, E> {\n+            iter: Iter,\n+            err: Option<E>,\n+        }\n+\n+        impl<T, E, Iter: Iterator<Result<T, E>>> Iterator<T> for Adapter<Iter, E> {\n+            #[inline]\n+            fn next(&mut self) -> Option<T> {\n+                match self.iter.next() {\n+                    Some(Ok(value)) => Some(value),\n+                    Some(Err(err)) => {\n+                        self.err = Some(err);\n+                        None\n+                    }\n+                    None => None,\n                 }\n-                None => None,\n             }\n         }\n-    }\n \n-    let mut adapter = Adapter { iter: iter, err: None };\n-    let v: V = FromIterator::from_iter(adapter.by_ref());\n+        let mut adapter = Adapter { iter: iter, err: None };\n+        let v: V = FromIterator::from_iter(adapter.by_ref());\n \n-    match adapter.err {\n-        Some(err) => Err(err),\n-        None => Ok(v),\n+        match adapter.err {\n+            Some(err) => Err(err),\n+            None => Ok(v),\n+        }\n     }\n }\n \n@@ -627,6 +755,7 @@ pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Ite\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n+#[experimental]\n pub fn fold<T,\n             V,\n             E,\n@@ -644,12 +773,15 @@ pub fn fold<T,\n     Ok(init)\n }\n \n+/// Deprecated.\n+///\n /// Perform a trivial fold operation over the result values\n /// from an iterator.\n ///\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, a simple `Ok(())` is returned.\n #[inline]\n+#[deprecated = \"use fold instead\"]\n pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n     fold(iterator, (), |_, _| ())\n }"}]}