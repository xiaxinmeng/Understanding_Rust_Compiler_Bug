{"sha": "7db640e63d36a1c812295e88a3d059ce5c70115d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYjY0MGU2M2QzNmExYzgxMjI5NWU4OGEzZDA1OWNlNWM3MDExNWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-05T20:05:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-07T06:40:31Z"}, "message": "collapse sizeof, alignof into metrics, pass along an instance if avail", "tree": {"sha": "bf85cee1c084d5d8426a476ab2dfbc76c0cc05b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf85cee1c084d5d8426a476ab2dfbc76c0cc05b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7db640e63d36a1c812295e88a3d059ce5c70115d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7db640e63d36a1c812295e88a3d059ce5c70115d", "html_url": "https://github.com/rust-lang/rust/commit/7db640e63d36a1c812295e88a3d059ce5c70115d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7db640e63d36a1c812295e88a3d059ce5c70115d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335", "html_url": "https://github.com/rust-lang/rust/commit/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335"}], "stats": {"total": 125, "additions": 78, "deletions": 47}, "files": [{"sha": "03adeb6843dd0bf78640bcc511c6c79bd9fe9d9f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 65, "deletions": 45, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7db640e63d36a1c812295e88a3d059ce5c70115d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db640e63d36a1c812295e88a3d059ce5c70115d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7db640e63d36a1c812295e88a3d059ce5c70115d", "patch": "@@ -414,14 +414,26 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n                                False);\n }\n \n-fn size_of(cx: @block_ctxt, t: ty::t) -> result {\n-    let {bcx, sz, align} = metrics(cx, t, none);\n-    rslt(bcx, align)\n+fn size_of(bcx: @block_ctxt, t: ty::t) -> result {\n+    assert !ty::type_has_opaque_size(bcx_tcx(bcx), t);\n+    let {bcx, sz, align: _} = metrics(bcx, t, none);\n+    rslt(bcx, sz)\n }\n \n-fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n-    let {bcx, sz, align} = metrics(cx, t, none);\n-    rslt(bcx, align)\n+fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n+    assert !ty::type_has_opaque_size(bcx_tcx(bcx), t);\n+    alt ty::struct(ccx.tcx, t) {\n+      ty::ty_opaque_closure. {\n+        // Hack: the alignment of an opaque closure is always defined as the\n+        // alignment of a pointer.  This is not, however, strictly correct,\n+        // depending on your point of view.  \n+        llalign_of(bcx, T_ptr(T_i8()));\n+      }\n+      _ {\n+        let {bcx, sz: _, align} = metrics(bcx, t, none);\n+        rslt(bcx, align)\n+      }\n+    }\n }\n \n // Computes the size/alignment of the type `t`.  `opt_v`, if provided, should\n@@ -431,11 +443,13 @@ fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n // instance is required.\n fn metrics(bcx: @block_ctxt, t: ty::t, opt_v: option<ValueRef>)\n     -> metrics_result {\n-    let ccx = bcx_ccx(cx);\n+    assert (option::is_some(opt_v) ||\n+            !ty::type_has_opaque_size(bcx_tcx(bcx), t));\n+    let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        let sp = cx.sp;\n-        let sz = llsize_of(bcx_ccx(cx), type_of(ccx, sp, t));\n-        let align = llalign_of(bcx_ccx(cx), type_of(ccx, sp, t));\n+        let sp = bcx.sp;\n+        let sz = llsize_of(bcx_ccx(bcx), type_of(ccx, sp, t));\n+        let align = llalign_of(bcx_ccx(bcx), type_of(ccx, sp, t));\n         ret {bcx: bcx, sz: sz, align: align};\n     } else {\n         ret dynamic_metrics(bcx, t, opt_v);\n@@ -552,11 +566,11 @@ type metrics_result = {\n };\n \n fn dynamic_metrics(bcx: @block_ctxt,\n-                   elts: [ty::t],\n-                   opts_v: option<ValueRef>) -> metrics_result {\n-    fn compute_elements_metrics(bcx: @block_ctxt,\n-                                elts: [ty::t],\n-                                opt_v: option<ValueRef>) -> metrics_result {\n+                   t: ty::t,\n+                   opt_v: option<ValueRef>) -> metrics_result {\n+    fn c_struct_metrics(bcx: @block_ctxt,\n+                        elts: [ty::t],\n+                        opt_v: option<ValueRef>) -> metrics_result {\n         //\n         // C padding rules:\n         //\n@@ -570,40 +584,40 @@ fn dynamic_metrics(bcx: @block_ctxt,\n         let max_align = C_int(bcx_ccx(bcx), 1);\n         for e: ty::t in elts {\n             let opt_ev = option::map(opt_v) {|v| ptr_offs(bcx, v, off) };\n-            let elt_align = align_of(bcx, e, opt_ev);\n-            bcx = elt_align.bcx;\n-            let elt_size = size_of(bcx, e, opt_ev);\n-            bcx = elt_size.bcx;\n-            let aligned_off = align_to(bcx, off, elt_align.val);\n-            off = Add(bcx, aligned_off, elt_size.val);\n-            max_align = umax(bcx, max_align, elt_align.val);\n+            let elt_metrics = metrics(bcx, e, opt_ev);\n+            bcx = elt_metrics.bcx;\n+            let aligned_off = align_to(bcx, off, elt_metrics.align);\n+            off = Add(bcx, aligned_off, elt_metrics.sz);\n+            max_align = umax(bcx, max_align, elt_metrics.align);\n         }\n+        off = align_to(bcx, off, max_align);\n         ret { bcx: bcx, sz: off, align: max_align };\n     }\n \n     alt ty::struct(bcx_tcx(bcx), t) {\n       ty::ty_param(p, _) {\n-        let {bcx, value: szptr} =\n-            field_of_tydesc(bcx, t, false, abi::tydesc_field_size);\n-        let {bcx, value: aptr} =\n-            field_of_tydesc(bcx, t, false, abi::tydesc_field_align);\n-        ret { bcx: bcx, sz: Load(szptr), align: Load(align) };\n+        let ti = none::<@tydesc_info>;\n+        let {bcx, val: tydesc} =\n+            get_tydesc(bcx, t, false, tps_normal, ti).result;\n+        let sz = Load(bcx, GEPi(bcx, tydesc, [0, abi::tydesc_field_size]));\n+        let al = Load(bcx, GEPi(bcx, tydesc, [0, abi::tydesc_field_align]));\n+        ret { bcx: bcx, sz: sz, align: al };\n       }\n       ty::ty_rec(flds) {\n         let tys: [ty::t] = [];\n         for f: ty::field in flds { tys += [f.mt.ty]; }\n-        ret compute_elements_metrics(bcx, tys, opt_v);\n+        ret c_struct_metrics(bcx, tys, opt_v);\n       }\n       ty::ty_tup(elts) {\n         let tys = [];\n         for tp in elts { tys += [tp]; }\n-        ret compute_elements_metrics(bcx, tys, opt_v);\n+        ret c_struct_metrics(bcx, tys, opt_v);\n       }\n       ty::ty_tag(tid, tps) {\n         let bcx = bcx;\n         let ccx = bcx_ccx(bcx);\n-        // Compute max(variant sizes) and max(variant alignments).\n \n+        // Compute max(variant sizes) and max(variant alignments).\n         let max_size: ValueRef = alloca(bcx, ccx.int_type);\n         Store(bcx, C_int(ccx, 0), max_size);\n         let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n@@ -616,9 +630,16 @@ fn dynamic_metrics(bcx: @block_ctxt,\n                 let t = ty::substitute_type_params(bcx_tcx(bcx), tps, raw_ty);\n                 tys += [t];\n             }\n-            let rslt = align_elements(bcx, tys, opt_v);\n+\n+            // Note: we do not pass in opt_v here for the value but rather\n+            // none.  The reason is that what we would want to pass in is a\n+            // ptr to the blob data of the tag, but this is impossible until\n+            // we know the size/alignment of the blob data.  Therefore, it is\n+            // not legal to have a tag type that contains an interior opaque\n+            // type.  Fortunately this will never happen.\n+            let rslt = c_struct_metrics(bcx, tys, none);\n             bcx = rslt.bcx;\n-            let this_size = rslt.val;\n+            let this_size = rslt.sz;\n             let old_max_size = Load(bcx, max_size);\n             Store(bcx, umax(bcx, this_size, old_max_size), max_size);\n         }\n@@ -651,7 +672,7 @@ fn dynamic_metrics(bcx: @block_ctxt,\n         let tdptr = Load(bcx, tdptrptr);\n         let sz = Load(bcx, GEPi(bcx, tdptr, [0, abi::tydesc_field_size]));\n         let align = Load(bcx, GEPi(bcx, tdptr, [0, abi::tydesc_field_align]));\n-        ret { bcx: bcx, sz: sz, align: sz };\n+        ret { bcx: bcx, sz: sz, align: align };\n       }\n     }\n }\n@@ -661,7 +682,7 @@ fn dynamic_metrics(bcx: @block_ctxt,\n // return type, use bump_ptr().\n fn ptr_offs(bcx: @block_ctxt, base: ValueRef, sz: ValueRef) -> ValueRef {\n     let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n-    GEP(bcx, raw, [sz]);\n+    GEP(bcx, raw, [sz])\n }\n \n // Increment a pointer by a given amount and then cast it to be a pointer\n@@ -760,7 +781,7 @@ fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n     let args = [];\n     for typ: ty::t in s.prefix { args += [typ]; }\n     let prefix_ty = ty::mk_tup(bcx_tcx(bcx), args);\n-    let {bcx, val: prefix_sz} = size_of(bcx, prefix_ty);\n+    let {bcx, sz: prefix_sz, align: _} = metrics(bcx, prefix_ty, some(base));\n     let {bcx, val: align} = align_of(bcx, s.target);\n     let sz = align_to(bcx, prefix_sz, align);\n     ret rslt(bcx, bump_ptr(bcx, s.target, base, sz));\n@@ -898,7 +919,6 @@ fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n              GEPi(tydesc.bcx, tydesc.val, [0, field]));\n }\n \n-\n // Given a type containing ty params, build a vector containing a ValueRef for\n // each of the ty params it uses (from the current frame) and a vector of the\n // indices of the ty params present in the type. This is used solely for\n@@ -2003,21 +2023,21 @@ fn call_bzero(cx: @block_ctxt, dst: ValueRef, n_bytes: ValueRef,\n              Call(cx, memset, [dst_ptr, C_u8(0u), size, align, volatile]));\n }\n \n-fn memmove_ty(cx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n+fn memmove_ty(bcx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     @block_ctxt {\n-    let ccx = bcx_ccx(cx);\n+    let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        if ty::type_is_structural(bcx_tcx(cx), t) {\n-            let sp = cx.sp;\n+        if ty::type_is_structural(bcx_tcx(bcx), t) {\n+            let sp = bcx.sp;\n             let llsz = llsize_of(ccx, type_of(ccx, sp, t));\n-            ret call_memmove(cx, dst, src, llsz).bcx;\n+            ret call_memmove(bcx, dst, src, llsz).bcx;\n         }\n-        Store(cx, Load(cx, src), dst);\n-        ret cx;\n+        Store(bcx, Load(bcx, src), dst);\n+        ret bcx;\n     }\n \n-    let llsz = size_of(cx, t);\n-    ret call_memmove(llsz.bcx, dst, src, llsz.val).bcx;\n+    let {bcx, sz: llsz, align: _} = metrics(bcx, t, some(src));\n+    ret call_memmove(bcx, dst, src, llsz).bcx;\n }\n \n tag copy_action { INIT; DROP_EXISTING; }"}, {"sha": "a7b6f58d3931d583764313a3dbbf4bcfd2338937", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7db640e63d36a1c812295e88a3d059ce5c70115d/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db640e63d36a1c812295e88a3d059ce5c70115d/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=7db640e63d36a1c812295e88a3d059ce5c70115d", "patch": "@@ -5,6 +5,7 @@ import trans_build::*;\n import trans::{\n     trans_shared_malloc,\n     type_of_inner,\n+    metrics,\n     size_of,\n     node_id_type,\n     INIT,\n@@ -39,7 +40,7 @@ fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t)\n }\n \n fn alloc_uniq_(bcx: @block_ctxt, uniq_ty: ty::t, opt_v: option<ValueRef>)\n-    : type_is_unique_box(cx, uniq_ty) -> result {\n+    : type_is_unique_box(bcx, uniq_ty) -> result {\n     let contents_ty = content_ty(bcx, uniq_ty);\n     let {bcx, sz: llsz, align: _} = metrics(bcx, contents_ty, opt_v);\n     let ccx = bcx_ccx(bcx);\n@@ -83,7 +84,7 @@ fn duplicate(bcx: @block_ctxt, v: ValueRef, t: ty::t)\n     : type_is_unique_box(bcx, t) -> result {\n \n     let content_ty = content_ty(bcx, t);\n-    let {bcx, val: llptr} = alloc_uniq_(bcx, t, v);\n+    let {bcx, val: llptr} = alloc_uniq_(bcx, t, some(v));\n \n     let src = load_if_immediate(bcx, v, content_ty);\n     let dst = llptr;"}, {"sha": "bcf0cfb69ea0bd1b0524176ab0042646c8328f4f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7db640e63d36a1c812295e88a3d059ce5c70115d/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db640e63d36a1c812295e88a3d059ce5c70115d/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=7db640e63d36a1c812295e88a3d059ce5c70115d", "patch": "@@ -149,6 +149,7 @@ export kind_can_be_copied, kind_can_be_sent, proto_kind, kind_lteq, type_kind;\n export type_err;\n export type_err_to_str;\n export type_has_dynamic_size;\n+export type_has_opaque_size;\n export type_needs_drop;\n export type_is_bool;\n export type_is_bot;\n@@ -1140,6 +1141,15 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     }\n }\n \n+pure fn type_has_opaque_size(cx: ctxt, ty: t) -> bool unchecked {\n+    type_structurally_contains(cx, ty, fn (sty: sty) -> bool {\n+        alt sty {\n+          ty_opaque_closure. { true}\n+          _ { false }\n+        }\n+    })\n+}\n+\n pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool unchecked {\n \n     /* type_structurally_contains can't be declared pure"}]}