{"sha": "f3c79c4026740ea2db0065ae14339d6586918a47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYzc5YzQwMjY3NDBlYTJkYjAwNjVhZTE0MzM5ZDY1ODY5MThhNDc=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-15T19:32:35Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:12:03Z"}, "message": "Enable taskgroup code for newsched spawns.", "tree": {"sha": "b71929511705f081670ef69c4a15c4e9e24c6a23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b71929511705f081670ef69c4a15c4e9e24c6a23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3c79c4026740ea2db0065ae14339d6586918a47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c79c4026740ea2db0065ae14339d6586918a47", "html_url": "https://github.com/rust-lang/rust/commit/f3c79c4026740ea2db0065ae14339d6586918a47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3c79c4026740ea2db0065ae14339d6586918a47/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e1be5ff9e82a46a3fd137954f62b4fa7cdbe5aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e1be5ff9e82a46a3fd137954f62b4fa7cdbe5aa", "html_url": "https://github.com/rust-lang/rust/commit/0e1be5ff9e82a46a3fd137954f62b4fa7cdbe5aa"}], "stats": {"total": 41, "additions": 36, "deletions": 5}, "files": [{"sha": "f098f8b2767cedbf04d66e37fd98566c8908bfb0", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3c79c4026740ea2db0065ae14339d6586918a47/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c79c4026740ea2db0065ae14339d6586918a47/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=f3c79c4026740ea2db0065ae14339d6586918a47", "patch": "@@ -286,8 +286,14 @@ impl<T> Drop for PortOneHack<T> {\n                 STATE_ONE => {\n                     let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n                 }\n-                _ => {\n-                    util::unreachable()\n+                task_as_state => {\n+                    // This case occurs during unwinding, when the blocked\n+                    // receiver was killed awake. The task can't still be\n+                    // blocked (we are it), but we need to free the handle.\n+                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n+                    // FIXME(#7554)(bblum): Make this cfg(test) dependent.\n+                    // in a later commit.\n+                    assert!(recvr.wake().is_none());\n                 }\n             }\n         }"}, {"sha": "b099985b1acea1d24d8b7d179438c6bc2503de9b", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f3c79c4026740ea2db0065ae14339d6586918a47/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c79c4026740ea2db0065ae14339d6586918a47/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=f3c79c4026740ea2db0065ae14339d6586918a47", "patch": "@@ -669,19 +669,44 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n }\n \n fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n-    let f = Cell::new(f);\n+    let child_data = Cell::new(gen_child_taskgroup(opts.linked, opts.supervised));\n+\n+    let child_wrapper: ~fn() = || {\n+        // Child task runs this code.\n+        let child_data = Cell::new(child_data.take()); // :(\n+        let enlist_success = do Local::borrow::<Task, bool> |me| {\n+            let (child_tg, ancestors, is_main) = child_data.take();\n+            let mut ancestors = ancestors;\n+            // FIXME(#7544): Optimize out the xadd in this clone, somehow.\n+            let handle = me.death.kill_handle.get_ref().clone();\n+            // Atomically try to get into all of our taskgroups.\n+            if enlist_many(NewTask(handle), &child_tg, &mut ancestors) {\n+                // Got in. We can run the provided child body, and can also run\n+                // the taskgroup's exit-time-destructor afterward.\n+                me.taskgroup = Some(TCB(child_tg, ancestors, is_main, None));\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+        // Should be run after the local-borrowed task is returned.\n+        if enlist_success {\n+            f()\n+        }\n+    };\n \n     let mut task = unsafe {\n         let sched = Local::unsafe_borrow::<Scheduler>();\n         rtdebug!(\"unsafe borrowed sched\");\n \n         if opts.linked {\n+            let child_wrapper = Cell::new(child_wrapper);\n             do Local::borrow::<Task, ~Task>() |running_task| {\n-                ~running_task.new_child(&mut (*sched).stack_pool, f.take())\n+                ~running_task.new_child(&mut (*sched).stack_pool, child_wrapper.take())\n             }\n         } else {\n             // An unlinked task is a new root in the task tree\n-            ~Task::new_root(&mut (*sched).stack_pool, f.take())\n+            ~Task::new_root(&mut (*sched).stack_pool, child_wrapper)\n         }\n     };\n "}]}