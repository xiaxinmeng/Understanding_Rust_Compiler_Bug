{"sha": "e4f4cd77a07918529cd274f3299a020cbc884974", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZjRjZDc3YTA3OTE4NTI5Y2QyNzRmMzI5OWEwMjBjYmM4ODQ5NzQ=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-12T21:27:19Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-12T21:27:19Z"}, "message": "Do not collect all traits", "tree": {"sha": "1b8889e7bac2c12920893b5d8c5dc68554369b5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b8889e7bac2c12920893b5d8c5dc68554369b5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4f4cd77a07918529cd274f3299a020cbc884974", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f4cd77a07918529cd274f3299a020cbc884974", "html_url": "https://github.com/rust-lang/rust/commit/e4f4cd77a07918529cd274f3299a020cbc884974", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4f4cd77a07918529cd274f3299a020cbc884974/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e008b0805479fa2383eaf6bc346bda4255f6b1ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/e008b0805479fa2383eaf6bc346bda4255f6b1ac", "html_url": "https://github.com/rust-lang/rust/commit/e008b0805479fa2383eaf6bc346bda4255f6b1ac"}], "stats": {"total": 155, "additions": 53, "deletions": 102}, "files": [{"sha": "c4aea2a06703bb956d2d6c1aed19b1c1b64f0732", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 53, "deletions": 102, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/e4f4cd77a07918529cd274f3299a020cbc884974/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f4cd77a07918529cd274f3299a020cbc884974/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=e4f4cd77a07918529cd274f3299a020cbc884974", "patch": "@@ -3,8 +3,7 @@ use crate::{\n     insert_use_statement, AssistId,\n };\n use hir::{\n-    db::{DefDatabase, HirDatabase},\n-    AsAssocItem, AssocItem, AssocItemContainer, Crate, ModPath, Module, ModuleDef, PathResolution,\n+    db::HirDatabase, AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution,\n     SourceAnalyzer, Trait, Type,\n };\n use ra_ide_db::{imports_locator::ImportsLocator, RootDatabase};\n@@ -141,121 +140,73 @@ impl AutoImportAssets {\n         ImportsLocator::new(db)\n             .find_imports(&self.get_search_query())\n             .into_iter()\n-            .map(|module_def| match &self.import_candidate {\n+            .filter_map(|module_def| match &self.import_candidate {\n                 ImportCandidate::TraitAssocItem(assoc_item_type, _) => {\n                     let located_assoc_item = match module_def {\n-                        ModuleDef::Function(located_function) => {\n-                            Some(AssocItem::Function(located_function))\n-                        }\n-                        ModuleDef::Const(located_const) => Some(AssocItem::Const(located_const)),\n+                        ModuleDef::Function(located_function) => located_function\n+                            .as_assoc_item(db)\n+                            .map(|assoc| assoc.container(db))\n+                            .and_then(Self::assoc_to_trait),\n+                        ModuleDef::Const(located_const) => located_const\n+                            .as_assoc_item(db)\n+                            .map(|assoc| assoc.container(db))\n+                            .and_then(Self::assoc_to_trait),\n                         _ => None,\n-                    };\n-\n-                    let mut applicable_traits = Vec::new();\n-                    if let Some(located_assoc_item) = located_assoc_item {\n-                        let trait_candidates: FxHashSet<_> =\n-                            Self::get_trait_candidates(db, located_assoc_item, current_crate)\n-                                .into_iter()\n-                                .map(|trait_candidate| trait_candidate.into())\n-                                .collect();\n-                        if !trait_candidates.is_empty() {\n-                            assoc_item_type.iterate_path_candidates(\n-                                db,\n-                                current_crate,\n-                                &trait_candidates,\n-                                None,\n-                                |_, assoc| {\n-                                    if let AssocItemContainer::Trait(appropriate_trait) =\n-                                        assoc.container(db)\n-                                    {\n-                                        applicable_traits.push(\n-                                            self.module_with_name_to_import\n-                                                .find_use_path(db, appropriate_trait.into()),\n-                                        );\n-                                    };\n-                                    None::<()>\n-                                },\n-                            );\n-                        };\n-                    }\n-                    applicable_traits\n+                    }?;\n+\n+                    let mut trait_candidates = FxHashSet::default();\n+                    trait_candidates.insert(located_assoc_item.into());\n+\n+                    assoc_item_type\n+                        .iterate_path_candidates(\n+                            db,\n+                            current_crate,\n+                            &trait_candidates,\n+                            None,\n+                            |_, assoc| Self::assoc_to_trait(assoc.container(db)),\n+                        )\n+                        .map(ModuleDef::from)\n                 }\n                 ImportCandidate::TraitMethod(function_callee, _) => {\n-                    let mut applicable_traits = Vec::new();\n-                    if let ModuleDef::Function(located_function) = module_def {\n-                        let trait_candidates: FxHashSet<_> = Self::get_trait_candidates(\n+                    let located_assoc_item =\n+                        if let ModuleDef::Function(located_function) = module_def {\n+                            located_function\n+                                .as_assoc_item(db)\n+                                .map(|assoc| assoc.container(db))\n+                                .and_then(Self::assoc_to_trait)\n+                        } else {\n+                            None\n+                        }?;\n+\n+                    let mut trait_candidates = FxHashSet::default();\n+                    trait_candidates.insert(located_assoc_item.into());\n+\n+                    function_callee\n+                        .iterate_method_candidates(\n                             db,\n-                            AssocItem::Function(located_function),\n                             current_crate,\n+                            &trait_candidates,\n+                            None,\n+                            |_, function| {\n+                                Self::assoc_to_trait(function.as_assoc_item(db)?.container(db))\n+                            },\n                         )\n-                        .into_iter()\n-                        .map(|trait_candidate| trait_candidate.into())\n-                        .collect();\n-                        if !trait_candidates.is_empty() {\n-                            function_callee.iterate_method_candidates(\n-                                db,\n-                                current_crate,\n-                                &trait_candidates,\n-                                None,\n-                                |_, function| {\n-                                    if let AssocItemContainer::Trait(appropriate_trait) = function\n-                                        .as_assoc_item(db)\n-                                        .expect(\"Function is an assoc item\")\n-                                        .container(db)\n-                                    {\n-                                        applicable_traits.push(\n-                                            self.module_with_name_to_import\n-                                                .find_use_path(db, appropriate_trait.into()),\n-                                        );\n-                                    };\n-                                    None::<()>\n-                                },\n-                            );\n-                        }\n-                    }\n-                    applicable_traits\n+                        .map(ModuleDef::from)\n                 }\n-                _ => vec![self.module_with_name_to_import.find_use_path(db, module_def)],\n+                _ => Some(module_def),\n             })\n-            .flatten()\n-            .filter_map(std::convert::identity)\n+            .filter_map(|module_def| self.module_with_name_to_import.find_use_path(db, module_def))\n             .filter(|use_path| !use_path.segments.is_empty())\n             .take(20)\n             .collect::<BTreeSet<_>>()\n     }\n \n-    fn get_trait_candidates(\n-        db: &RootDatabase,\n-        called_assoc_item: AssocItem,\n-        root_crate: Crate,\n-    ) -> FxHashSet<Trait> {\n-        let _p = profile(\"auto_import::get_trait_candidates\");\n-        root_crate\n-            .dependencies(db)\n-            .into_iter()\n-            .map(|dependency| db.crate_def_map(dependency.krate.into()))\n-            .chain(std::iter::once(db.crate_def_map(root_crate.into())))\n-            .map(|crate_def_map| {\n-                crate_def_map\n-                    .modules\n-                    .iter()\n-                    .map(|(_, module_data)| module_data.scope.declarations())\n-                    .flatten()\n-                    .filter_map(|module_def_id| match module_def_id.into() {\n-                        ModuleDef::Trait(trait_candidate)\n-                            if trait_candidate\n-                                .items(db)\n-                                .into_iter()\n-                                .any(|item| item == called_assoc_item) =>\n-                        {\n-                            Some(trait_candidate)\n-                        }\n-                        _ => None,\n-                    })\n-                    .collect::<FxHashSet<_>>()\n-            })\n-            .flatten()\n-            .collect()\n+    fn assoc_to_trait(assoc: AssocItemContainer) -> Option<Trait> {\n+        if let AssocItemContainer::Trait(extracted_trait) = assoc {\n+            Some(extracted_trait)\n+        } else {\n+            None\n+        }\n     }\n }\n "}]}