{"sha": "8cbdaf4f93ecc775727d334890014ca929ad2b36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjYmRhZjRmOTNlY2M3NzU3MjdkMzM0ODkwMDE0Y2E5MjlhZDJiMzY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-05-18T22:35:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-19T18:40:16Z"}, "message": "Make trans use span_err for the dreaded \"ty_var in trans::type_of\" error\n\nThis required quite a bit of tiresome plumbing about of spans.\nOn the bright side, now other errors can be converted to span_err too.\n\nIncludes test cases.", "tree": {"sha": "e7be139415bc77add141c15b60261a8536976252", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7be139415bc77add141c15b60261a8536976252"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cbdaf4f93ecc775727d334890014ca929ad2b36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cbdaf4f93ecc775727d334890014ca929ad2b36", "html_url": "https://github.com/rust-lang/rust/commit/8cbdaf4f93ecc775727d334890014ca929ad2b36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cbdaf4f93ecc775727d334890014ca929ad2b36/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d429a76032dc81b5c6660be180bea76a75eb3f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d429a76032dc81b5c6660be180bea76a75eb3f4", "html_url": "https://github.com/rust-lang/rust/commit/0d429a76032dc81b5c6660be180bea76a75eb3f4"}], "stats": {"total": 279, "additions": 158, "deletions": 121}, "files": [{"sha": "75224bb494b6f88c4ed053844e066de7252a790a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 148, "deletions": 121, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/8cbdaf4f93ecc775727d334890014ca929ad2b36/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbdaf4f93ecc775727d334890014ca929ad2b36/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8cbdaf4f93ecc775727d334890014ca929ad2b36", "patch": "@@ -26,6 +26,7 @@ import util::common;\n import util::common::istr;\n import util::common::new_def_hash;\n import util::common::new_str_hash;\n+import util::common::local_rhs_span;\n \n import lib::llvm::llvm;\n import lib::llvm::builder;\n@@ -156,6 +157,7 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          hashmap[ast::def_id, ValueRef] llupvars,\n                          mutable vec[ValueRef] lltydescs,\n                          hashmap[ty::t, derived_tydesc_info] derived_tydescs,\n+                         ast::span sp,\n                          @local_ctxt lcx);\n \n tag cleanup {\n@@ -174,6 +176,7 @@ state type block_ctxt = rec(BasicBlockRef llbb,\n                             block_parent parent,\n                             block_kind kind,\n                             mutable vec[cleanup] cleanups,\n+                            ast::span sp,\n                             @fn_ctxt fcx);\n \n // FIXME: we should be able to use option::t[@block_parent] here but\n@@ -399,8 +402,8 @@ fn T_glue_fn(&type_names tn) -> TypeRef {\n     ret t;\n }\n \n-fn T_dtor(&@crate_ctxt ccx, TypeRef llself_ty) -> TypeRef {\n-    ret type_of_fn_full(ccx, ast::proto_fn, some[TypeRef](llself_ty),\n+fn T_dtor(&@crate_ctxt ccx, &ast::span sp, TypeRef llself_ty) -> TypeRef {\n+    ret type_of_fn_full(ccx, sp, ast::proto_fn, some[TypeRef](llself_ty),\n                         vec::empty[ty::arg](), ty::mk_nil(ccx.tcx), 0u);\n }\n \n@@ -622,17 +625,18 @@ fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n // return value was always meaningless in that case anyhow). Beware!\n //\n // TODO: Enforce via a predicate.\n-fn type_of(&@crate_ctxt cx, &ty::t t) -> TypeRef {\n+fn type_of(&@crate_ctxt cx, &ast::span sp, &ty::t t) -> TypeRef {\n     if (ty::type_has_dynamic_size(cx.tcx, t)) {\n-        log_err \"type_of() called on a type with dynamic size: \" +\n-            ty::ty_to_str(cx.tcx, t);\n+        cx.sess.span_err (sp,\n+          \"type_of() called on a type with dynamic size: \" +\n+                          ty::ty_to_str(cx.tcx, t));\n         fail;\n     }\n \n-    ret type_of_inner(cx, t);\n+    ret type_of_inner(cx, sp, t);\n }\n \n-fn type_of_explicit_args(&@crate_ctxt cx,\n+fn type_of_explicit_args(&@crate_ctxt cx, &ast::span sp,\n                          &vec[ty::arg] inputs) -> vec[TypeRef] {\n     let vec[TypeRef] atys = [];\n     for (ty::arg arg in inputs) {\n@@ -643,10 +647,10 @@ fn type_of_explicit_args(&@crate_ctxt cx,\n             let TypeRef t;\n             alt (arg.mode) {\n                 case (ty::mo_alias) {\n-                    t = T_ptr(type_of_inner(cx, arg.ty));\n+                    t = T_ptr(type_of_inner(cx, sp, arg.ty));\n                 }\n                 case (_) {\n-                    t = type_of_inner(cx, arg.ty);\n+                    t = type_of_inner(cx, sp, arg.ty);\n                 }\n             }\n             atys += [t];\n@@ -663,6 +667,7 @@ fn type_of_explicit_args(&@crate_ctxt cx,\n //  - trans_args\n \n fn type_of_fn_full(&@crate_ctxt cx,\n+                   &ast::span sp,\n                    ast::proto proto,\n                    &option::t[TypeRef] obj_self,\n                    &vec[ty::arg] inputs,\n@@ -674,7 +679,7 @@ fn type_of_fn_full(&@crate_ctxt cx,\n     if (ty::type_has_dynamic_size(cx.tcx, output)) {\n         atys += [T_typaram_ptr(cx.tn)];\n     } else {\n-        atys += [T_ptr(type_of_inner(cx, output))];\n+        atys += [T_ptr(type_of_inner(cx, sp, output))];\n     }\n \n     // Arg 1: task pointer.\n@@ -706,28 +711,29 @@ fn type_of_fn_full(&@crate_ctxt cx,\n         // argument.\n         atys +=\n             [T_fn_pair(cx.tn,\n-                          type_of_fn_full(cx, ast::proto_fn, none[TypeRef],\n+                       type_of_fn_full(cx, sp, ast::proto_fn, none[TypeRef],\n                                           [rec(mode=ty::mo_alias,\n                                                   ty=output)],\n                                           ty::mk_nil(cx.tcx), 0u))];\n     }\n \n     // ... then explicit args.\n-    atys += type_of_explicit_args(cx, inputs);\n+    atys += type_of_explicit_args(cx, sp, inputs);\n \n     ret T_fn(atys, llvm::LLVMVoidType());\n }\n \n fn type_of_fn(&@crate_ctxt cx,\n+              &ast::span sp,\n               ast::proto proto,\n               &vec[ty::arg] inputs,\n               &ty::t output,\n               uint ty_param_count) -> TypeRef {\n-    ret type_of_fn_full(cx, proto, none[TypeRef], inputs, output,\n+    ret type_of_fn_full(cx, sp, proto, none[TypeRef], inputs, output,\n                         ty_param_count);\n }\n \n-fn type_of_native_fn(&@crate_ctxt cx, ast::native_abi abi,\n+fn type_of_native_fn(&@crate_ctxt cx, &ast::span sp, ast::native_abi abi,\n                      &vec[ty::arg] inputs,\n                      &ty::t output,\n                      uint ty_param_count) -> TypeRef {\n@@ -741,11 +747,11 @@ fn type_of_native_fn(&@crate_ctxt cx, ast::native_abi abi,\n             i += 1u;\n         }\n     }\n-    atys += type_of_explicit_args(cx, inputs);\n-    ret T_fn(atys, type_of_inner(cx, output));\n+    atys += type_of_explicit_args(cx, sp, inputs);\n+    ret T_fn(atys, type_of_inner(cx, sp, output));\n }\n \n-fn type_of_inner(&@crate_ctxt cx, &ty::t t) -> TypeRef {\n+fn type_of_inner(&@crate_ctxt cx, &ast::span sp, &ty::t t) -> TypeRef {\n     // Check the cache.\n     if (cx.lltypes.contains_key(t)) {\n         ret cx.lltypes.get(t);\n@@ -781,41 +787,41 @@ fn type_of_inner(&@crate_ctxt cx, &ty::t t) -> TypeRef {\n             if (ty::type_has_dynamic_size(cx.tcx, t)) {\n                 llty = T_opaque_tag(cx.tn);\n             } else {\n-                auto size = static_size_of_tag(cx, t);\n+                auto size = static_size_of_tag(cx, sp, t);\n                 llty = T_tag(cx.tn, size);\n             }\n         }\n         case (ty::ty_box(?mt)) {\n-            llty = T_ptr(T_box(type_of_inner(cx, mt.ty)));\n+            llty = T_ptr(T_box(type_of_inner(cx, sp, mt.ty)));\n         }\n         case (ty::ty_vec(?mt)) {\n-            llty = T_ptr(T_vec(type_of_inner(cx, mt.ty)));\n+            llty = T_ptr(T_vec(type_of_inner(cx, sp, mt.ty)));\n         }\n         case (ty::ty_port(?t)) {\n-            llty = T_ptr(T_port(type_of_inner(cx, t)));\n+            llty = T_ptr(T_port(type_of_inner(cx, sp, t)));\n         }\n         case (ty::ty_chan(?t)) {\n-            llty = T_ptr(T_chan(type_of_inner(cx, t)));\n+            llty = T_ptr(T_chan(type_of_inner(cx, sp, t)));\n         }\n         case (ty::ty_tup(?elts)) {\n             let vec[TypeRef] tys = [];\n             for (ty::mt elt in elts) {\n-                tys += [type_of_inner(cx, elt.ty)];\n+                tys += [type_of_inner(cx, sp, elt.ty)];\n             }\n             llty = T_struct(tys);\n         }\n         case (ty::ty_rec(?fields)) {\n             let vec[TypeRef] tys = [];\n             for (ty::field f in fields) {\n-                tys += [type_of_inner(cx, f.mt.ty)];\n+                tys += [type_of_inner(cx, sp, f.mt.ty)];\n             }\n             llty = T_struct(tys);\n         }\n         case (ty::ty_fn(?proto, ?args, ?out)) {\n-            llty = T_fn_pair(cx.tn, type_of_fn(cx, proto, args, out, 0u));\n+            llty = T_fn_pair(cx.tn, type_of_fn(cx, sp, proto, args, out, 0u));\n         }\n         case (ty::ty_native_fn(?abi, ?args, ?out)) {\n-            auto nft = native_fn_wrapper_type(cx, 0u, t);\n+            auto nft = native_fn_wrapper_type(cx, sp, 0u, t);\n             llty = T_fn_pair(cx.tn, nft);\n         }\n         case (ty::ty_obj(?meths)) {\n@@ -825,7 +831,7 @@ fn type_of_inner(&@crate_ctxt cx, &ty::t t) -> TypeRef {\n             let vec[TypeRef] mtys = [T_ptr(T_i8())];\n             for (ty::method m in meths) {\n                 let TypeRef mty =\n-                    type_of_fn_full(cx, m.proto,\n+                    type_of_fn_full(cx, sp, m.proto,\n                                     some[TypeRef](self_ty),\n                                     m.inputs, m.output, 0u);\n                 mtys += [T_ptr(mty)];\n@@ -840,8 +846,7 @@ fn type_of_inner(&@crate_ctxt cx, &ty::t t) -> TypeRef {\n             llty = abs_pair;\n         }\n         case (ty::ty_var(_)) {\n-            log_err \"ty_var in trans::type_of\";\n-            fail;\n+            cx.tcx.sess.span_err(sp, \"ty_var in trans::type_of\");\n         }\n         case (ty::ty_param(_)) {\n             llty = T_i8();\n@@ -863,7 +868,7 @@ fn type_of_inner(&@crate_ctxt cx, &ty::t t) -> TypeRef {\n     ret llty;\n }\n \n-fn type_of_arg(@local_ctxt cx, &ty::arg arg) -> TypeRef {\n+fn type_of_arg(@local_ctxt cx, &ast::span sp, &ty::arg arg) -> TypeRef {\n     alt (ty::struct(cx.ccx.tcx, arg.ty)) {\n         case (ty::ty_param(_)) {\n             if (arg.mode == ty::mo_alias) {\n@@ -877,25 +882,26 @@ fn type_of_arg(@local_ctxt cx, &ty::arg arg) -> TypeRef {\n \n     auto typ;\n     if (arg.mode == ty::mo_alias) {\n-        typ = T_ptr(type_of_inner(cx.ccx, arg.ty));\n+        typ = T_ptr(type_of_inner(cx.ccx, sp, arg.ty));\n     } else {\n-        typ = type_of_inner(cx.ccx, arg.ty);\n+        typ = type_of_inner(cx.ccx, sp, arg.ty);\n     }\n     ret typ;\n }\n \n-fn type_of_ty_param_count_and_ty(@local_ctxt lcx,\n+fn type_of_ty_param_count_and_ty(@local_ctxt lcx, &ast::span sp,\n                                  &ty::ty_param_count_and_ty tpt) -> TypeRef {\n     alt (ty::struct(lcx.ccx.tcx, tpt._1)) {\n         case (ty::ty_fn(?proto, ?inputs, ?output)) {\n-            auto llfnty = type_of_fn(lcx.ccx, proto, inputs, output, tpt._0);\n+            auto llfnty = type_of_fn(lcx.ccx, sp, proto,\n+                                     inputs, output, tpt._0);\n             ret T_fn_pair(lcx.ccx.tn, llfnty);\n         }\n         case (_) {\n             // fall through\n         }\n     }\n-    ret type_of(lcx.ccx, tpt._1);\n+    ret type_of(lcx.ccx, sp, tpt._1);\n }\n \n \n@@ -1202,14 +1208,14 @@ fn llalign_of(TypeRef t) -> ValueRef {\n \n fn size_of(&@block_ctxt cx, &ty::t t) -> result {\n     if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n-        ret res(cx, llsize_of(type_of(cx.fcx.lcx.ccx, t)));\n+        ret res(cx, llsize_of(type_of(cx.fcx.lcx.ccx, cx.sp, t)));\n     }\n     ret dynamic_size_of(cx, t);\n }\n \n fn align_of(&@block_ctxt cx, &ty::t t) -> result {\n     if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n-        ret res(cx, llalign_of(type_of(cx.fcx.lcx.ccx, t)));\n+        ret res(cx, llalign_of(type_of(cx.fcx.lcx.ccx, cx.sp, t)));\n     }\n     ret dynamic_align_of(cx, t);\n }\n@@ -1244,7 +1250,7 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n }\n \n // Computes the size of the data part of a non-dynamically-sized tag.\n-fn static_size_of_tag(&@crate_ctxt cx, &ty::t t) -> uint {\n+fn static_size_of_tag(&@crate_ctxt cx, &ast::span sp, &ty::t t) -> uint {\n     if (ty::type_has_dynamic_size(cx.tcx, t)) {\n         log_err \"dynamically sized type passed to static_size_of_tag()\";\n         fail;\n@@ -1278,7 +1284,7 @@ fn static_size_of_tag(&@crate_ctxt cx, &ty::t t) -> uint {\n         tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n \n         // Here we possibly do a recursive call.\n-        auto this_size = llsize_of_real(cx, type_of(cx, tup_ty));\n+        auto this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n \n         if (max_size < this_size) {\n             max_size = this_size;\n@@ -1503,7 +1509,7 @@ fn GEP_tup_like(&@block_ctxt cx, &ty::t t,\n         ret res(bcx, bumped);\n     }\n \n-    auto typ = T_ptr(type_of(bcx.fcx.lcx.ccx, s.target));\n+    auto typ = T_ptr(type_of(bcx.fcx.lcx.ccx, bcx.sp, s.target));\n     ret res(bcx, bcx.build.PointerCast(bumped, typ));\n }\n \n@@ -1544,7 +1550,7 @@ fn GEP_tag(@block_ctxt cx,\n     // the blob pointer isn't dynamically sized).\n     let ValueRef llunionptr;\n     if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, tup_ty)) {\n-        auto llty = type_of(cx.fcx.lcx.ccx, tup_ty);\n+        auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, tup_ty);\n         llunionptr = cx.build.TruncOrBitCast(llblobptr, T_ptr(llty));\n     } else {\n         llunionptr = llblobptr;\n@@ -1556,7 +1562,7 @@ fn GEP_tag(@block_ctxt cx,\n     // Cast the result to the appropriate type, if necessary.\n     auto val;\n     if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, elem_ty)) {\n-        auto llelemty = type_of(rslt.bcx.fcx.lcx.ccx, elem_ty);\n+        auto llelemty = type_of(rslt.bcx.fcx.lcx.ccx, cx.sp, elem_ty);\n         val = rslt.bcx.build.PointerCast(rslt.val, T_ptr(llelemty));\n     } else {\n         val = rslt.val;\n@@ -1582,7 +1588,7 @@ fn trans_malloc_boxed(&@block_ctxt cx, ty::t t) -> result {\n                                     [ty::mk_int(cx.fcx.lcx.ccx.tcx), t]);\n     auto box_ptr = ty::mk_imm_box(cx.fcx.lcx.ccx.tcx, t);\n     auto sz = size_of(cx, boxed_body);\n-    auto llty = type_of(cx.fcx.lcx.ccx, box_ptr);\n+    auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, box_ptr);\n     ret trans_raw_malloc(sz.bcx, llty, sz.val);\n }\n \n@@ -1791,15 +1797,15 @@ fn get_static_tydesc(&@block_ctxt cx,\n         }\n         case (none[@tydesc_info]) {\n             cx.fcx.lcx.ccx.stats.n_static_tydescs += 1u;\n-            auto info = declare_tydesc(cx.fcx.lcx, t, ty_params);\n+            auto info = declare_tydesc(cx.fcx.lcx, cx.sp, t, ty_params);\n             cx.fcx.lcx.ccx.tydescs.insert(t, info);\n             ret info;\n         }\n     }\n }\n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-fn declare_tydesc(&@local_ctxt cx, &ty::t t,\n+fn declare_tydesc(&@local_ctxt cx, &ast::span sp, &ty::t t,\n                   vec[uint] ty_params) -> @tydesc_info {\n     log \"+++ declare_tydesc \" + ty::ty_to_str(cx.ccx.tcx, t);\n     auto take_glue = declare_generic_glue(cx, t, T_glue_fn(cx.ccx.tn),\n@@ -1819,7 +1825,7 @@ fn declare_tydesc(&@local_ctxt cx, &ty::t t,\n     auto llsize;\n     auto llalign;\n     if (!ty::type_has_dynamic_size(ccx.tcx, t)) {\n-        auto llty = type_of(ccx, t);\n+        auto llty = type_of(ccx, sp, t);\n         llsize = llsize_of(llty);\n         llalign = llalign_of(llty);\n     } else {\n@@ -1874,12 +1880,12 @@ fn declare_generic_glue(&@local_ctxt cx,\n     ret llfn;\n }\n \n-fn make_generic_glue(&@local_ctxt cx,\n+fn make_generic_glue(&@local_ctxt cx, &ast::span sp,\n                      &ty::t t,\n                      ValueRef llfn,\n                      &make_generic_glue_helper_fn helper,\n                      &vec[uint] ty_params) -> ValueRef {\n-    auto fcx = new_fn_ctxt(cx, llfn);\n+    auto fcx = new_fn_ctxt(cx, sp, llfn);\n \n     llvm::LLVMSetLinkage(llfn, lib::llvm::LLVMInternalLinkage\n                          as llvm::Linkage);\n@@ -1895,7 +1901,7 @@ fn make_generic_glue(&@local_ctxt cx,\n     if (ty::type_has_dynamic_size(cx.ccx.tcx, t)) {\n         llty = T_ptr(T_i8());\n     } else {\n-        llty = T_ptr(type_of(cx.ccx, t));\n+        llty = T_ptr(type_of(cx.ccx, sp, t));\n     }\n \n     auto ty_param_count = vec::len[uint](ty_params);\n@@ -2379,7 +2385,8 @@ fn make_cmp_glue(&@block_ctxt cx,\n                 // i8[]. So we need to cast it to the proper type.\n \n                 if (!ty::type_has_dynamic_size(last_cx.fcx.lcx.ccx.tcx, t)) {\n-                    auto llelemty = T_ptr(type_of(last_cx.fcx.lcx.ccx, t));\n+                    auto llelemty = T_ptr(type_of(last_cx.fcx.lcx.ccx,\n+                                                  last_cx.sp, t));\n                     av = cx.build.PointerCast(av, llelemty);\n                     bv = cx.build.PointerCast(bv, llelemty);\n                 }\n@@ -2858,7 +2865,7 @@ fn iter_sequence_inner(&@block_ctxt cx,\n                   ValueRef src) -> result {\n         auto llptrty;\n         if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, elt_ty)) {\n-            auto llty = type_of(cx.fcx.lcx.ccx, elt_ty);\n+            auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, elt_ty);\n             llptrty = T_ptr(llty);\n         } else {\n             llptrty = T_ptr(T_ptr(T_i8()));\n@@ -2895,7 +2902,7 @@ fn iter_sequence(@block_ctxt cx,\n         if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, elt_ty)) {\n             llunit_ty = T_i8();\n         } else {\n-            llunit_ty = type_of(cx.fcx.lcx.ccx, elt_ty);\n+            llunit_ty = type_of(cx.fcx.lcx.ccx, cx.sp, elt_ty);\n         }\n \n         auto bcx = cx;\n@@ -2966,7 +2973,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                                                  \"take\");\n                         ti.take_glue = some[ValueRef](glue_fn);\n                         auto tg = make_take_glue;\n-                        make_generic_glue(lcx, ti.ty, glue_fn,\n+                        make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                           mgghf_single(tg), ti.ty_params);\n \n                         log #fmt(\"--- lazily_emit_tydesc_glue TAKE %s\",\n@@ -2986,7 +2993,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                                                  \"drop\");\n                         ti.drop_glue = some[ValueRef](glue_fn);\n                         auto dg = make_drop_glue;\n-                        make_generic_glue(lcx, ti.ty, glue_fn,\n+                        make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                           mgghf_single(dg), ti.ty_params);\n                         log #fmt(\"--- lazily_emit_tydesc_glue DROP %s\",\n                                  ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n@@ -3030,7 +3037,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                                                  T_cmp_glue_fn(lcx.ccx.tn),\n                                                  \"cmp\");\n                         ti.cmp_glue = some[ValueRef](glue_fn);\n-                        make_generic_glue(lcx, ti.ty, glue_fn,\n+                        make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                           mgghf_cmp, ti.ty_params);\n                         log #fmt(\"--- lazily_emit_tydesc_glue CMP %s\",\n                                  ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n@@ -3082,7 +3089,7 @@ fn maybe_call_dtor(&@block_ctxt cx, ValueRef v) -> @block_ctxt {\n     dtor_ptr = cx.build.Load(dtor_ptr);\n     auto self_t = llvm::LLVMGetElementType(val_ty(v));\n     dtor_ptr = cx.build.BitCast(dtor_ptr,\n-                                T_ptr(T_dtor(cx.fcx.lcx.ccx, self_t)));\n+                                T_ptr(T_dtor(cx.fcx.lcx.ccx, cx.sp, self_t)));\n \n     auto dtor_cx = new_sub_block_ctxt(cx, \"dtor\");\n     auto after_cx = new_sub_block_ctxt(cx, \"after_dtor\");\n@@ -3354,8 +3361,8 @@ fn node_ann_type(&@crate_ctxt cx, &ast::ann a) -> ty::t {\n     ret target_type(cx, ty::ann_to_monotype(cx.tcx, cx.node_types, a));\n }\n \n-fn node_type(&@crate_ctxt cx, &ast::ann a) -> TypeRef {\n-    ret type_of(cx, node_ann_type(cx, a));\n+fn node_type(&@crate_ctxt cx, &ast::span sp, &ast::ann a) -> TypeRef {\n+    ret type_of(cx, sp, node_ann_type(cx, a));\n }\n \n fn trans_unary(&@block_ctxt cx, ast::unop op,\n@@ -3410,7 +3417,8 @@ fn trans_unary(&@block_ctxt cx, ast::unop op,\n             // make tags work, since tags have a different LLVM type depending\n             // on whether they're boxed or not.\n             if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, e_ty)) {\n-                auto llety = T_ptr(type_of(sub.bcx.fcx.lcx.ccx, e_ty));\n+                auto llety = T_ptr(type_of(sub.bcx.fcx.lcx.ccx, e.span,\n+                                           e_ty));\n                 body = sub.bcx.build.PointerCast(body, llety);\n             }\n \n@@ -3607,7 +3615,7 @@ fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result {\n                 // different types depending on whether they're behind a box\n                 // or not.\n                 if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, mt.ty)) {\n-                    auto llty = type_of(cx.fcx.lcx.ccx, mt.ty);\n+                    auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, mt.ty);\n                     v1 = cx.build.PointerCast(body, T_ptr(llty));\n                 } else {\n                     v1 = body;\n@@ -3800,7 +3808,8 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond,\n             if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n                 expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n             } else {\n-                expr_llty = type_of(else_res.bcx.fcx.lcx.ccx, expr_ty);\n+                expr_llty = type_of(else_res.bcx.fcx.lcx.ccx, elexpr.span,\n+                                    expr_ty);\n                 if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n                     expr_llty = T_ptr(expr_llty);\n                 }\n@@ -4041,15 +4050,15 @@ fn trans_for_each(&@block_ctxt cx,\n     // and pass it in as a first class fn-arg to the iterator.\n \n     auto iter_body_llty =\n-        type_of_fn_full(lcx.ccx, ast::proto_fn,\n+        type_of_fn_full(lcx.ccx, cx.sp, ast::proto_fn,\n                         none[TypeRef],\n                         [rec(mode=ty::mo_alias, ty=decl_ty)],\n                         ty::mk_nil(lcx.ccx.tcx), 0u);\n \n     let ValueRef lliterbody = decl_internal_fastcall_fn(lcx.ccx.llmod,\n                                                        s, iter_body_llty);\n \n-    auto fcx = new_fn_ctxt(lcx, lliterbody);\n+    auto fcx = new_fn_ctxt(lcx, cx.sp, lliterbody);\n \n     auto copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n@@ -4338,7 +4347,7 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr,\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n         expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n     } else {\n-        expr_llty = type_of(cx.fcx.lcx.ccx, expr_ty);\n+        expr_llty = type_of(cx.fcx.lcx.ccx, expr.span, expr_ty);\n         if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n             expr_llty = T_ptr(expr_llty);\n         }\n@@ -4378,7 +4387,8 @@ fn trans_external_path(&@block_ctxt cx, &ast::def_id did,\n     auto lcx = cx.fcx.lcx;\n     auto name = creader::get_symbol(lcx.ccx.sess, did);\n     auto v = get_extern_const(lcx.ccx.externs, lcx.ccx.llmod,\n-                              name, type_of_ty_param_count_and_ty(lcx, tpt));\n+                              name,\n+                              type_of_ty_param_count_and_ty(lcx, cx.sp, tpt));\n     ret lval_val(cx, v);\n }\n \n@@ -4509,7 +4519,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n                                                  tag_ty)) {\n                         lltagty = T_opaque_tag(cx.fcx.lcx.ccx.tn);\n                     } else {\n-                        lltagty = type_of(cx.fcx.lcx.ccx, tag_ty);\n+                        lltagty = type_of(cx.fcx.lcx.ccx, p.span, tag_ty);\n                     }\n                     auto lltagptr = alloc_result.bcx.build.\n                         PointerCast(lltagblob, T_ptr(lltagty));\n@@ -4635,7 +4645,7 @@ fn trans_index(&@block_ctxt cx, &ast::span sp, &@ast::expr base,\n         elt = next_cx.build.GEP(body, [C_int(0), ix_val]);\n \n         // We're crossing a box boundary here, so we may need to pointer cast.\n-        auto llunitty = type_of(next_cx.fcx.lcx.ccx, unit_ty);\n+        auto llunitty = type_of(next_cx.fcx.lcx.ccx, sp, unit_ty);\n         elt = next_cx.build.PointerCast(elt, T_ptr(llunitty));\n     }\n \n@@ -4711,7 +4721,7 @@ fn trans_cast(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n     auto e_res = trans_expr(cx, e);\n     auto llsrctype = val_ty(e_res.val);\n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n-    auto lldsttype = type_of(cx.fcx.lcx.ccx, t);\n+    auto lldsttype = type_of(cx.fcx.lcx.ccx, e.span, t);\n     if (!ty::type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n         // TODO: native-to-native casts\n         if (ty::type_is_native(cx.fcx.lcx.ccx.tcx,\n@@ -4731,6 +4741,7 @@ fn trans_cast(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n }\n \n fn trans_bind_thunk(&@local_ctxt cx,\n+                    &ast::span sp,\n                     &ty::t incoming_fty,\n                     &ty::t outgoing_fty,\n                     &vec[option::t[@ast::expr]] args,\n@@ -4741,16 +4752,17 @@ fn trans_bind_thunk(&@local_ctxt cx,\n     // args forward into a call to outgoing_fty:\n \n     let str s = mangle_name_by_seq(cx.ccx, cx.path, \"thunk\");\n-    let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx.ccx, incoming_fty));\n+    let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx.ccx, sp,\n+                                                    incoming_fty));\n     let ValueRef llthunk = decl_internal_fastcall_fn(cx.ccx.llmod,\n                                                      s, llthunk_ty);\n \n-    auto fcx = new_fn_ctxt(cx, llthunk);\n+    auto fcx = new_fn_ctxt(cx, sp, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n     auto llclosure_ptr_ty =\n-        type_of(cx.ccx, ty::mk_imm_box(cx.ccx.tcx, closure_ty));\n+        type_of(cx.ccx, sp, ty::mk_imm_box(cx.ccx.tcx, closure_ty));\n     auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n \n     auto lltarget = GEP_tup_like(bcx, closure_ty, llclosure,\n@@ -4795,7 +4807,7 @@ fn trans_bind_thunk(&@local_ctxt cx,\n     let int b = 0;\n     let uint outgoing_arg_index = 0u;\n     let vec[TypeRef] llout_arg_tys =\n-        type_of_explicit_args(cx.ccx, outgoing_args);\n+        type_of_explicit_args(cx.ccx, sp, outgoing_args);\n \n     for (option::t[@ast::expr] arg in args) {\n \n@@ -4860,7 +4872,7 @@ fn trans_bind_thunk(&@local_ctxt cx,\n \n     // Cast the outgoing function to the appropriate type (see the comments in\n     // trans_bind below for why this is necessary).\n-    auto lltargetty = type_of_fn(bcx.fcx.lcx.ccx,\n+    auto lltargetty = type_of_fn(bcx.fcx.lcx.ccx, sp,\n                                  ty::ty_fn_proto(bcx.fcx.lcx.ccx.tcx,\n                                                 outgoing_fty),\n                                  outgoing_args,\n@@ -4919,7 +4931,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             ret f_res.res;\n         } else {\n             auto bcx = f_res.res.bcx;\n-            auto pair_t = node_type(cx.fcx.lcx.ccx, ann);\n+            auto pair_t = node_type(cx.fcx.lcx.ccx, cx.sp, ann);\n             auto pair_v = alloca(bcx, pair_t);\n \n             // Translate the bound expressions.\n@@ -4989,7 +5001,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             // specifically, we know how many type descriptors the outgoing\n             // function has, which type_of() doesn't, as only we know which\n             // item the function refers to.\n-            auto llfnty = type_of_fn(bcx.fcx.lcx.ccx,\n+            auto llfnty = type_of_fn(bcx.fcx.lcx.ccx, cx.sp,\n                 ty::ty_fn_proto(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n                 ty::ty_fn_args(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n                 ty::ty_fn_ret(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n@@ -5050,7 +5062,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             let ty::t pair_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n \n             let ValueRef llthunk =\n-                trans_bind_thunk(cx.fcx.lcx, pair_ty, outgoing_fty,\n+                trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty,\n                                  args, closure_ty, bound_tys,\n                                  ty_param_count);\n \n@@ -5191,7 +5203,7 @@ fn trans_args(&@block_ctxt cx,\n         // view, for the sake of making a type-compatible call.\n         llargs +=\n             [cx.build.PointerCast(llretslot,\n-                                     T_ptr(type_of(bcx.fcx.lcx.ccx, retty)))];\n+               T_ptr(type_of(bcx.fcx.lcx.ccx, bcx.sp, retty)))];\n     } else {\n         llargs += [llretslot];\n     }\n@@ -5229,7 +5241,7 @@ fn trans_args(&@block_ctxt cx,\n     // First we figure out the caller's view of the types of the arguments.\n     // This will be needed if this is a generic call, because the callee has\n     // to cast her view of the arguments to the caller's view.\n-    auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx, args);\n+    auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx, cx.sp, args);\n \n     auto i = 0u;\n     for (@ast::expr e in es) {\n@@ -5379,7 +5391,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args,\n     auto vec_val = bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_vec,\n         [bcx.fcx.lltaskptr, data_sz,\n             C_null(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn)))]);\n-    auto llty = type_of(bcx.fcx.lcx.ccx, t);\n+    auto llty = type_of(bcx.fcx.lcx.ccx, bcx.sp, t);\n     vec_val = bcx.build.PointerCast(vec_val, llty);\n \n     find_scope_cx(bcx).cleanups +=\n@@ -5414,7 +5426,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args,\n \n         auto dst_val;\n         if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, unit_ty)) {\n-            auto llunit_ty = type_of(cx.fcx.lcx.ccx, unit_ty);\n+            auto llunit_ty = type_of(cx.fcx.lcx.ccx, bcx.sp, unit_ty);\n             dst_val = bcx.build.PointerCast(dst_res.val, T_ptr(llunit_ty));\n         } else {\n             dst_val = dst_res.val;\n@@ -5486,9 +5498,8 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n     ret res(bcx, rec_val);\n }\n \n-\n-\n fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n+    *cx = rec(sp=e.span with *cx);\n     alt (e.node) {\n         case (ast::expr_lit(?lit, ?ann)) {\n             ret res(cx, trans_lit(cx.fcx.lcx.ccx, *lit, ann));\n@@ -5529,6 +5540,7 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n         }\n \n         case (ast::expr_block(?blk, _)) {\n+            *cx = rec(sp=blk.span with *cx);\n             auto sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n             auto next_cx = new_sub_block_ctxt(cx, \"next\");\n             auto sub = trans_block(sub_cx, blk);\n@@ -5542,6 +5554,7 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n         case (ast::expr_assign(?dst, ?src, ?ann)) {\n             auto lhs_res = trans_lval(cx, dst);\n             assert (lhs_res.is_mem);\n+            *(lhs_res.res.bcx) = rec(sp=src.span with *(lhs_res.res.bcx));\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n             // FIXME: calculate copy init-ness in typestate.\n@@ -5553,6 +5566,7 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n             auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n             auto lhs_res = trans_lval(cx, dst);\n             assert (lhs_res.is_mem);\n+            *(lhs_res.res.bcx) = rec(sp=src.span with *(lhs_res.res.bcx));\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             if (ty::type_is_sequence(cx.fcx.lcx.ccx.tcx, t)) {\n                 alt (op) {\n@@ -5843,7 +5857,8 @@ fn trans_put(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n             auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n                                     cx.fcx.lcx.ccx.node_types, x);\n             auto arg = rec(mode=ty::mo_alias, ty=e_ty);\n-            auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx, [arg]);\n+            auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx,\n+                                                 x.span, [arg]);\n             auto r = trans_arg_expr(bcx, arg, arg_tys.(0), x);\n             bcx = r.bcx;\n             llargs += [r.val];\n@@ -5956,14 +5971,14 @@ fn trans_port(&@block_ctxt cx, &ast::ann ann) -> result {\n         }\n     }\n \n-    auto llunit_ty = type_of(cx.fcx.lcx.ccx, unit_ty);\n+    auto llunit_ty = type_of(cx.fcx.lcx.ccx, cx.sp, unit_ty);\n \n     auto bcx = cx;\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n     auto port_raw_val = bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_port,\n                                        [bcx.fcx.lltaskptr, unit_sz.val]);\n-    auto llty = type_of(cx.fcx.lcx.ccx, t);\n+    auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, t);\n     auto port_val = bcx.build.PointerCast(port_raw_val, llty);\n     auto dropref = clean(bind drop_ty(_, port_val, t));\n     find_scope_cx(bcx).cleanups += [dropref];\n@@ -5982,7 +5997,7 @@ fn trans_chan(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n                                        [bcx.fcx.lltaskptr, prt_val]);\n \n     auto chan_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n-    auto chan_llty = type_of(bcx.fcx.lcx.ccx, chan_ty);\n+    auto chan_llty = type_of(bcx.fcx.lcx.ccx, e.span, chan_ty);\n     auto chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n     auto dropref = clean(bind drop_ty(_, chan_val, chan_ty));\n     find_scope_cx(bcx).cleanups += [dropref];\n@@ -6099,14 +6114,15 @@ fn zero_alloca(&@block_ctxt cx, ValueRef llptr, ty::t t) -> result {\n         bcx = call_bzero(llalign.bcx, llptr,\n                          llsz.val, llalign.val).bcx;\n     } else {\n-        auto llty = type_of(bcx.fcx.lcx.ccx, t);\n+        auto llty = type_of(bcx.fcx.lcx.ccx, cx.sp, t);\n         auto null = lib::llvm::llvm::LLVMConstNull(llty);\n         bcx.build.Store(null, llptr);\n     }\n     ret res(bcx, llptr);\n  }\n \n fn trans_stmt(&@block_ctxt cx, &ast::stmt s) -> result {\n+    *cx = rec(sp=s.span with *cx);\n     auto bcx = cx;\n     alt (s.node) {\n         case (ast::stmt_expr(?e,_)) {\n@@ -6152,6 +6168,7 @@ fn new_block_ctxt(&@fn_ctxt cx, &block_parent parent,\n              parent=parent,\n              kind=kind,\n              mutable cleanups=cleanups,\n+             sp=cx.sp,\n              fcx=cx);\n }\n \n@@ -6180,7 +6197,8 @@ fn new_sub_block_ctxt(&@block_ctxt bcx, &str n) -> @block_ctxt {\n fn new_raw_block_ctxt(&@fn_ctxt fcx, BasicBlockRef llbb) -> @block_ctxt {\n     let vec[cleanup] cleanups = [];\n     ret @rec(llbb=llbb, build=new_builder(llbb), parent=parent_none,\n-             kind=NON_SCOPE_BLOCK, mutable cleanups=cleanups, fcx=fcx);\n+             kind=NON_SCOPE_BLOCK, mutable cleanups=cleanups, sp=fcx.sp,\n+             fcx=fcx);\n }\n \n \n@@ -6230,6 +6248,7 @@ fn llallocas_block_ctxt(&@fn_ctxt fcx) -> @block_ctxt {\n              parent=parent_none,\n              kind=SCOPE_BLOCK,\n              mutable cleanups=cleanups,\n+             sp=fcx.sp,\n              fcx=fcx);\n }\n \n@@ -6246,7 +6265,7 @@ fn alloc_ty(&@block_ctxt cx, &ty::t t) -> result {\n         cx.fcx.llallocas = n.bcx.llbb;\n         val = array_alloca(cx, T_i8(), n.val);\n     } else {\n-        val = alloca(cx, type_of(cx.fcx.lcx.ccx, t));\n+        val = alloca(cx, type_of(cx.fcx.lcx.ccx, cx.sp, t));\n     }\n     // NB: since we've pushed all size calculations in this\n     // function up to the alloca block, we actually return the\n@@ -6268,6 +6287,7 @@ fn trans_block(&@block_ctxt cx, &ast::block b) -> result {\n     auto bcx = cx;\n \n     for each (@ast::local local in block_locals(b)) {\n+        *bcx = rec(sp=local_rhs_span(local, cx.sp) with *bcx);\n         bcx = alloc_local(bcx, local).bcx;\n     }\n     auto r = res(bcx, C_nil());\n@@ -6369,7 +6389,7 @@ fn mk_standard_basic_blocks(ValueRef llfn) ->\n //  - new_fn_ctxt\n //  - trans_args\n \n-fn new_fn_ctxt(@local_ctxt cx,\n+fn new_fn_ctxt(@local_ctxt cx, &ast::span sp,\n                ValueRef llfndecl) -> @fn_ctxt {\n \n     let ValueRef llretptr = llvm::LLVMGetParam(llfndecl, 0u);\n@@ -6401,6 +6421,7 @@ fn new_fn_ctxt(@local_ctxt cx,\n              llupvars=llupvars,\n              mutable lltydescs=vec::empty[ValueRef](),\n              derived_tydescs=derived_tydescs,\n+             sp=sp,\n              lcx=cx);\n }\n \n@@ -6485,7 +6506,7 @@ fn copy_args_to_allocas(@fn_ctxt fcx,\n     let uint arg_n = 0u;\n     for (ast::arg aarg in args) {\n         if (aarg.mode != ast::alias) {\n-            auto arg_t = type_of_arg(bcx.fcx.lcx, arg_tys.(arg_n));\n+            auto arg_t = type_of_arg(bcx.fcx.lcx, fcx.sp, arg_tys.(arg_n));\n             auto a = alloca(bcx, arg_t);\n             auto argval = bcx.fcx.llargs.get(aarg.id);\n             bcx.build.Store(argval, a);\n@@ -6579,7 +6600,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     // fields pointer to the appropriate LLVM type. If not, just leave it as\n     // i8 *.\n     if (!ty::type_has_dynamic_size(fcx.lcx.ccx.tcx, fields_tup_ty)) {\n-        auto llfields_ty = type_of(fcx.lcx.ccx, fields_tup_ty);\n+        auto llfields_ty = type_of(fcx.lcx.ccx, fcx.sp, fields_tup_ty);\n         obj_fields = vi2p(bcx, obj_fields, T_ptr(llfields_ty));\n     } else {\n         obj_fields = vi2p(bcx, obj_fields, T_ptr(T_i8()));\n@@ -6616,12 +6637,12 @@ fn finish_fn(&@fn_ctxt fcx, BasicBlockRef lltop) {\n     new_builder(fcx.llderivedtydescs).Br(lltop);\n }\n \n-fn trans_fn(@local_ctxt cx, &ast::_fn f, ast::def_id fid,\n+fn trans_fn(@local_ctxt cx, &ast::span sp, &ast::_fn f, ast::def_id fid,\n             option::t[tup(TypeRef, ty::t)] ty_self,\n             &vec[ast::ty_param] ty_params, &ast::ann ann) {\n     auto llfndecl = cx.ccx.item_ids.get(fid);\n \n-    auto fcx = new_fn_ctxt(cx, llfndecl);\n+    auto fcx = new_fn_ctxt(cx, sp, llfndecl);\n     create_llargs_for_fn_args(fcx, f.proto,\n                               ty_self, ret_ty_of_fn(cx.ccx, ann),\n                               f.decl.inputs, ty_params);\n@@ -6681,7 +6702,7 @@ fn trans_vtbl(@local_ctxt cx,\n         auto llfnty = T_nil();\n         alt (ty::struct(cx.ccx.tcx, node_ann_type(cx.ccx, m.node.ann))) {\n             case (ty::ty_fn(?proto, ?inputs, ?output)) {\n-                llfnty = type_of_fn_full(cx.ccx, proto,\n+                llfnty = type_of_fn_full(cx.ccx, m.span, proto,\n                                          some[TypeRef](llself_ty),\n                                          inputs, output,\n                                          vec::len[ast::ty_param](ty_params));\n@@ -6695,7 +6716,7 @@ fn trans_vtbl(@local_ctxt cx,\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n         cx.ccx.item_symbols.insert(m.node.id, s);\n \n-        trans_fn(mcx, m.node.meth, m.node.id,\n+        trans_fn(mcx, m.span, m.node.meth, m.node.id,\n                  some[tup(TypeRef, ty::t)](tup(llself_ty, self_ty)),\n                  ty_params, m.node.ann);\n         methods += [llfn];\n@@ -6717,21 +6738,21 @@ fn trans_dtor(@local_ctxt cx,\n               &vec[ast::ty_param] ty_params,\n               &@ast::method dtor) -> ValueRef {\n \n-    auto llfnty = T_dtor(cx.ccx, llself_ty);\n+    auto llfnty = T_dtor(cx.ccx, dtor.span, llself_ty);\n     let @local_ctxt dcx = extend_path(cx, \"drop\");\n     let str s = mangle_name_by_seq(dcx.ccx, dcx.path, \"drop\");\n     let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n     cx.ccx.item_ids.insert(dtor.node.id, llfn);\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n \n-    trans_fn(dcx, dtor.node.meth, dtor.node.id,\n+    trans_fn(dcx, dtor.span, dtor.node.meth, dtor.node.id,\n              some[tup(TypeRef, ty::t)](tup(llself_ty, self_ty)),\n              ty_params, dtor.node.ann);\n \n     ret llfn;\n }\n \n-fn trans_obj(@local_ctxt cx, &ast::_obj ob, ast::def_id oid,\n+fn trans_obj(@local_ctxt cx, &ast::span sp, &ast::_obj ob, ast::def_id oid,\n              &vec[ast::ty_param] ty_params, &ast::ann ann) {\n     auto ccx = cx.ccx;\n     auto llctor_decl = ccx.item_ids.get(oid);\n@@ -6742,7 +6763,7 @@ fn trans_obj(@local_ctxt cx, &ast::_obj ob, ast::def_id oid,\n         fn_args += [rec(mode=ast::alias, ty=f.ty, ident=f.ident, id=f.id)];\n     }\n \n-    auto fcx = new_fn_ctxt(cx, llctor_decl);\n+    auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     create_llargs_for_fn_args(fcx, ast::proto_fn,\n                               none[tup(TypeRef, ty::t)],\n                               ret_ty_of_fn(ccx, ann),\n@@ -6755,7 +6776,7 @@ fn trans_obj(@local_ctxt cx, &ast::_obj ob, ast::def_id oid,\n     auto lltop = bcx.llbb;\n \n     auto self_ty = ret_ty_of_fn(ccx, ann);\n-    auto llself_ty = type_of(ccx, self_ty);\n+    auto llself_ty = type_of(ccx, sp, self_ty);\n     auto pair = bcx.fcx.llretptr;\n \n     auto vtbl = trans_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n@@ -6890,7 +6911,7 @@ fn trans_tag_variant(@local_ctxt cx, ast::def_id tag_id,\n     assert (cx.ccx.item_ids.contains_key(variant.node.id));\n     let ValueRef llfndecl = cx.ccx.item_ids.get(variant.node.id);\n \n-    auto fcx = new_fn_ctxt(cx, llfndecl);\n+    auto fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n \n     create_llargs_for_fn_args(fcx, ast::proto_fn,\n                               none[tup(TypeRef, ty::t)],\n@@ -6986,13 +7007,14 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n     alt (item.node) {\n         case (ast::item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             auto sub_cx = extend_path(cx, name);\n-            trans_fn(sub_cx, f, fid, none[tup(TypeRef, ty::t)], tps, ann);\n+            trans_fn(sub_cx, item.span, f, fid, none[tup(TypeRef, ty::t)],\n+                     tps, ann);\n         }\n         case (ast::item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n             auto sub_cx = @rec(obj_typarams=tps,\n                                obj_fields=ob.fields with\n                                *extend_path(cx, name));\n-            trans_obj(sub_cx, ob, oid.ctor, tps, ann);\n+            trans_obj(sub_cx, item.span, ob, oid.ctor, tps, ann);\n         }\n         case (ast::item_mod(?name, ?m, _)) {\n             auto sub_cx = @rec(path = cx.path + [name],\n@@ -7029,7 +7051,7 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n     ret llvm::LLVMGetElementType(pair_tys.(0));\n }\n \n-fn decl_fn_and_pair(&@crate_ctxt ccx,\n+fn decl_fn_and_pair(&@crate_ctxt ccx, &ast::span sp,\n                     vec[str] path,\n                     str flav,\n                     vec[ast::ty_param] ty_params,\n@@ -7040,7 +7062,7 @@ fn decl_fn_and_pair(&@crate_ctxt ccx,\n     auto llpairty;\n     alt (ty::struct(ccx.tcx, node_ann_type(ccx, ann))) {\n         case (ty::ty_fn(?proto, ?inputs, ?output)) {\n-            llfty = type_of_fn(ccx, proto, inputs, output,\n+            llfty = type_of_fn(ccx, sp, proto, inputs, output,\n                                vec::len[ast::ty_param](ty_params));\n             llpairty = T_fn_pair(ccx.tn, llfty);\n         }\n@@ -7095,17 +7117,18 @@ fn native_fn_ty_param_count(&@crate_ctxt cx, &ast::def_id id) -> uint {\n     ret count;\n }\n \n-fn native_fn_wrapper_type(&@crate_ctxt cx, uint ty_param_count, ty::t x)\n-        -> TypeRef {\n+fn native_fn_wrapper_type(&@crate_ctxt cx, &ast::span sp, uint ty_param_count,\n+                          ty::t x) -> TypeRef {\n     alt (ty::struct(cx.tcx, x)) {\n         case (ty::ty_native_fn(?abi, ?args, ?out)) {\n-            ret type_of_fn(cx, ast::proto_fn, args, out, ty_param_count);\n+            ret type_of_fn(cx, sp, ast::proto_fn, args, out, ty_param_count);\n         }\n     }\n     fail;\n }\n \n fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n+                           &ast::span sp,\n                            vec[str] path,\n                            str name,\n                            &ast::ann ann,\n@@ -7114,7 +7137,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n \n     // Declare the wrapper.\n     auto t = node_ann_type(ccx, ann);\n-    auto wrapper_type = native_fn_wrapper_type(ccx, num_ty_param, t);\n+    auto wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n     let str s = mangle_name_by_seq(ccx, path, \"wrapper\");\n     let ValueRef wrapper_fn = decl_internal_fastcall_fn(ccx.llmod, s,\n                                                         wrapper_type);\n@@ -7126,7 +7149,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n     register_fn_pair(ccx, ps, wrapper_pair_type, wrapper_fn, id);\n \n     // Build the wrapper.\n-    auto fcx = new_fn_ctxt(new_local_ctxt(ccx), wrapper_fn);\n+    auto fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, wrapper_fn);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n@@ -7135,7 +7158,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n     auto fn_type = node_ann_type(ccx, ann);  // NB: has no type params\n \n     auto abi = ty::ty_fn_abi(ccx.tcx, fn_type);\n-    auto llfnty = type_of_native_fn(ccx, abi,\n+    auto llfnty = type_of_native_fn(ccx, sp, abi,\n         ty::ty_fn_args(ccx.tcx, fn_type),\n         ty::ty_fn_ret(ccx.tcx, fn_type), num_ty_param);\n \n@@ -7198,7 +7221,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n         if (mode == ty::mo_val) {\n             if (ty::type_is_integral(cx.fcx.lcx.ccx.tcx, t)) {\n                 auto lldsttype = T_int();\n-                auto llsrctype = type_of(cx.fcx.lcx.ccx, t);\n+                auto llsrctype = type_of(cx.fcx.lcx.ccx, cx.sp, t);\n                 if (llvm::LLVMGetIntTypeWidth(lldsttype) >\n                     llvm::LLVMGetIntTypeWidth(llsrctype)) {\n                     ret cx.build.ZExtOrBitCast(v, T_int());\n@@ -7225,7 +7248,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n \n         auto llnativefnty =\n             T_fn(call_arg_tys,\n-                 type_of(bcx.fcx.lcx.ccx,\n+                 type_of(bcx.fcx.lcx.ccx, bcx.sp,\n                          ty::ty_fn_ret(bcx.fcx.lcx.ccx.tcx, fn_type)));\n \n         auto llnativefn = get_extern_fn(bcx.fcx.lcx.ccx.externs,\n@@ -7341,7 +7364,8 @@ fn collect_native_item(&@crate_ctxt ccx, @walk_ctxt wcx,\n         case (ast::native_item_fn(?name, _, _, _, ?fid, ?ann)) {\n             ccx.native_items.insert(fid, i);\n             if (!ccx.obj_methods.contains_key(fid)) {\n-                decl_native_fn_and_pair(ccx, wcx.path, name, ann, fid);\n+                decl_native_fn_and_pair(ccx, i.span, wcx.path,\n+                                        name, ann, fid);\n             }\n         }\n         case (ast::native_item_ty(_, ?tid)) {\n@@ -7356,7 +7380,7 @@ fn collect_item_1(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item i) {\n     alt (i.node) {\n         case (ast::item_const(?name, _, _, ?cid, ?ann)) {\n             auto typ = node_ann_type(ccx, ann);\n-            auto g = llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ),\n+            auto g = llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ),\n                                         str::buf(ccx.names.next(name)));\n             llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage\n                                 as llvm::Linkage);\n@@ -7386,12 +7410,13 @@ fn collect_item_2(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item i) {\n         case (ast::item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             ccx.items.insert(fid, i);\n             if (!ccx.obj_methods.contains_key(fid)) {\n-                decl_fn_and_pair(ccx, wcx.path, \"fn\", tps, ann, fid);\n+                decl_fn_and_pair(ccx, i.span, wcx.path, \"fn\", tps, ann, fid);\n             }\n         }\n         case (ast::item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n             ccx.items.insert(oid.ctor, i);\n-            decl_fn_and_pair(ccx, wcx.path, \"obj_ctor\", tps, ann, oid.ctor);\n+            decl_fn_and_pair(ccx, i.span, wcx.path,\n+                             \"obj_ctor\", tps, ann, oid.ctor);\n             for (@ast::method m in ob.methods) {\n                 ccx.obj_methods.insert(m.node.id, ());\n             }\n@@ -7422,7 +7447,8 @@ fn collect_tag_ctor(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item i) {\n         case (ast::item_tag(_, ?variants, ?tps, _, _)) {\n             for (ast::variant variant in variants) {\n                 if (vec::len[ast::variant_arg](variant.node.args) != 0u) {\n-                    decl_fn_and_pair(ccx, wcx.path + [variant.node.name],\n+                    decl_fn_and_pair(ccx, i.span,\n+                                     wcx.path + [variant.node.name],\n                                      \"tag\", tps, variant.node.ann,\n                                      variant.node.id);\n                 }\n@@ -7748,7 +7774,7 @@ fn vec_p1_adjusted(&@block_ctxt bcx, ValueRef v,\n     ret bcx.build.GEP(vec_p0(bcx, v), [len]);\n }\n \n-fn trans_vec_append_glue(@local_ctxt cx) {\n+fn trans_vec_append_glue(@local_ctxt cx, &ast::span sp) {\n \n     auto llfn = cx.ccx.glues.vec_append_glue;\n \n@@ -7778,6 +7804,7 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n                     llupvars=new_def_hash[ValueRef](),\n                     mutable lltydescs=vec::empty[ValueRef](),\n                     derived_tydescs=derived_tydescs,\n+                    sp=sp,\n                     lcx=cx);\n \n     auto bcx = new_top_block_ctxt(fcx);\n@@ -8049,7 +8076,7 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n     collect_tag_ctors(ccx, crate);\n     trans_constants(ccx, crate);\n     trans_mod(cx, crate.node.module);\n-    trans_vec_append_glue(cx);\n+    trans_vec_append_glue(cx, crate.span);\n     auto crate_map = create_crate_map(ccx);\n     if (!sess.get_opts().shared) {\n         trans_main_fn(cx, crate_ptr, crate_map);"}, {"sha": "c21d49e34dc4b8e5fb318d6ad04f7a304cc10e47", "filename": "src/test/compile-fail/vector-no-ann-2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8cbdaf4f93ecc775727d334890014ca929ad2b36/src%2Ftest%2Fcompile-fail%2Fvector-no-ann-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbdaf4f93ecc775727d334890014ca929ad2b36/src%2Ftest%2Fcompile-fail%2Fvector-no-ann-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann-2.rs?ref=8cbdaf4f93ecc775727d334890014ca929ad2b36", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern:3:24:3:25\n+fn main() -> () {\n+  let @vec[uint] foo = @[];\n+}\n+// this checks that span_err gets used"}, {"sha": "9b303e607fa1c48e14c34772bbf5f544d5b09f24", "filename": "src/test/compile-fail/vector-no-ann.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8cbdaf4f93ecc775727d334890014ca929ad2b36/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbdaf4f93ecc775727d334890014ca929ad2b36/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs?ref=8cbdaf4f93ecc775727d334890014ca929ad2b36", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern:3:13:3:14\n+fn main() -> () {\n+  auto foo = [];\n+}\n+// this checks that span_err gets used"}]}