{"sha": "63ebfc2c55af8b7581bea067f29276f73c7fa503", "node_id": "C_kwDOAAsO6NoAKDYzZWJmYzJjNTVhZjhiNzU4MWJlYTA2N2YyOTI3NmY3M2M3ZmE1MDM", "commit": {"author": {"name": "Milan Landaverde", "email": "milanlandaverde@gmail.com", "date": "2021-05-11T19:41:32Z"}, "committer": {"name": "Milan", "email": "milanlandaverde@gmail.com", "date": "2021-10-10T18:01:06Z"}, "message": "Add abstract namespace support for Unix domain sockets", "tree": {"sha": "656968c6817ce736908ac4f4bd458c12c3436cc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/656968c6817ce736908ac4f4bd458c12c3436cc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63ebfc2c55af8b7581bea067f29276f73c7fa503", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63ebfc2c55af8b7581bea067f29276f73c7fa503", "html_url": "https://github.com/rust-lang/rust/commit/63ebfc2c55af8b7581bea067f29276f73c7fa503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63ebfc2c55af8b7581bea067f29276f73c7fa503/comments", "author": {"login": "mdaverde", "id": 1067001, "node_id": "MDQ6VXNlcjEwNjcwMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1067001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mdaverde", "html_url": "https://github.com/mdaverde", "followers_url": "https://api.github.com/users/mdaverde/followers", "following_url": "https://api.github.com/users/mdaverde/following{/other_user}", "gists_url": "https://api.github.com/users/mdaverde/gists{/gist_id}", "starred_url": "https://api.github.com/users/mdaverde/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mdaverde/subscriptions", "organizations_url": "https://api.github.com/users/mdaverde/orgs", "repos_url": "https://api.github.com/users/mdaverde/repos", "events_url": "https://api.github.com/users/mdaverde/events{/privacy}", "received_events_url": "https://api.github.com/users/mdaverde/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mdaverde", "id": 1067001, "node_id": "MDQ6VXNlcjEwNjcwMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1067001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mdaverde", "html_url": "https://github.com/mdaverde", "followers_url": "https://api.github.com/users/mdaverde/followers", "following_url": "https://api.github.com/users/mdaverde/following{/other_user}", "gists_url": "https://api.github.com/users/mdaverde/gists{/gist_id}", "starred_url": "https://api.github.com/users/mdaverde/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mdaverde/subscriptions", "organizations_url": "https://api.github.com/users/mdaverde/orgs", "repos_url": "https://api.github.com/users/mdaverde/repos", "events_url": "https://api.github.com/users/mdaverde/events{/privacy}", "received_events_url": "https://api.github.com/users/mdaverde/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c87288f92b7e6365d61cfbcbc453ea4c696c030", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c87288f92b7e6365d61cfbcbc453ea4c696c030", "html_url": "https://github.com/rust-lang/rust/commit/0c87288f92b7e6365d61cfbcbc453ea4c696c030"}], "stats": {"total": 368, "additions": 363, "deletions": 5}, "files": [{"sha": "5c985a28017aa0ba92277c0294145a83e84ffd3d", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 81, "deletions": 3, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/63ebfc2c55af8b7581bea067f29276f73c7fa503/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ebfc2c55af8b7581bea067f29276f73c7fa503/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=63ebfc2c55af8b7581bea067f29276f73c7fa503", "patch": "@@ -2,7 +2,7 @@ use crate::ffi::OsStr;\n use crate::os::unix::ffi::OsStrExt;\n use crate::path::Path;\n use crate::sys::cvt;\n-use crate::{ascii, fmt, io, iter, mem};\n+use crate::{ascii, fmt, io, iter, mem, ptr};\n \n // FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n #[cfg(not(unix))]\n@@ -92,8 +92,8 @@ impl<'a> fmt::Display for AsciiEscaped<'a> {\n #[derive(Clone)]\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct SocketAddr {\n-    addr: libc::sockaddr_un,\n-    len: libc::socklen_t,\n+    pub(super) addr: libc::sockaddr_un,\n+    pub(super) len: libc::socklen_t,\n }\n \n impl SocketAddr {\n@@ -196,6 +196,30 @@ impl SocketAddr {\n         if let AddressKind::Pathname(path) = self.address() { Some(path) } else { None }\n     }\n \n+    /// Returns the contents of this address if it is an abstract namespace\n+    /// without the leading null byte.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let namespace = b\"hidden\";\n+    ///     let namespace_addr = SocketAddr::from_abstract_namespace(&namespace[..])?;\n+    ///     let socket = UnixListener::bind_addr(&namespace_addr)?;\n+    ///     let local_addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(local_addr.as_abstract_namespace(), Some(&namespace[..]));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"42048\")]\n+    pub fn as_abstract_namespace(&self) -> Option<&[u8]> {\n+        if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }\n+    }\n+\n     fn address(&self) -> AddressKind<'_> {\n         let len = self.len as usize - sun_path_offset(&self.addr);\n         let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n@@ -212,6 +236,60 @@ impl SocketAddr {\n             AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n         }\n     }\n+\n+    /// Creates an abstract domain socket address from a namespace\n+    ///\n+    /// An abstract address does not create a file unlike traditional path-based\n+    /// Unix sockets. The advantage of this is that the address will disappear when\n+    /// the socket bound to it is closed, so no filesystem clean up is required.\n+    ///\n+    /// The leading null byte for the abstract namespace is automatically added.\n+    ///\n+    /// This is a Linux-specific extension. See more at [`unix(7)`].\n+    ///\n+    /// [`unix(7)`]: https://man7.org/linux/man-pages/man7/unix.7.html\n+    ///\n+    /// # Errors\n+    ///\n+    /// This will return an error if the given namespace is too long\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let addr = SocketAddr::from_abstract_namespace(b\"hidden\")?;\n+    ///     let listener = match UnixListener::bind_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(err) => {\n+    ///             println!(\"Couldn't bind: {:?}\", err);\n+    ///             return Err(err);\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"42048\")]\n+    pub fn from_abstract_namespace(namespace: &[u8]) -> io::Result<SocketAddr> {\n+        unsafe {\n+            let mut addr: libc::sockaddr_un = mem::zeroed();\n+            addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n+\n+            if namespace.len() + 1 > addr.sun_path.len() {\n+                return Err(io::Error::new_const(\n+                    io::ErrorKind::InvalidInput,\n+                    &\"namespace must be shorter than SUN_LEN\",\n+                ));\n+            }\n+\n+            ptr::copy_nonoverlapping(namespace.as_ptr(), addr.sun_path.as_mut_ptr().offset(1) as *mut u8, namespace.len());\n+            let len = (sun_path_offset(&addr) + 1 + namespace.len()) as libc::socklen_t;\n+            SocketAddr::from_parts(addr, len)\n+        }\n+    }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]"}, {"sha": "bae88af6d1f8e3ed6eeb76b138a176185c49faab", "filename": "library/std/src/os/unix/net/datagram.rs", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/63ebfc2c55af8b7581bea067f29276f73c7fa503/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ebfc2c55af8b7581bea067f29276f73c7fa503/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs?ref=63ebfc2c55af8b7581bea067f29276f73c7fa503", "patch": "@@ -112,6 +112,35 @@ impl UnixDatagram {\n         }\n     }\n \n+    /// Creates a Unix datagram socket bound to an address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAddr};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let addr = SocketAddr::from_abstract_namespace(b\"hidden\")?; // Linux only\n+    ///     let sock = match UnixDatagram::bind_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(err) => {\n+    ///             println!(\"Couldn't bind: {:?}\", err);\n+    ///             return Err(err);\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"42048\")]\n+    pub fn bind_addr(socket_addr: &SocketAddr) -> io::Result<UnixDatagram> {\n+        unsafe {\n+            let socket = UnixDatagram::unbound()?;\n+            cvt(libc::bind(*socket.0.as_inner(), &socket_addr.addr as *const _ as *const _, socket_addr.len as _))?;\n+            Ok(socket)\n+        }\n+    }\n+\n     /// Creates a Unix Datagram socket which is not bound to any address.\n     ///\n     /// # Examples\n@@ -156,7 +185,7 @@ impl UnixDatagram {\n         Ok((UnixDatagram(i1), UnixDatagram(i2)))\n     }\n \n-    /// Connects the socket to the specified address.\n+    /// Connects the socket to the specified path address.\n     ///\n     /// The [`send`] method may be used to send data to the specified address.\n     /// [`recv`] and [`recv_from`] will only receive data from that address.\n@@ -192,6 +221,35 @@ impl UnixDatagram {\n         Ok(())\n     }\n \n+    /// Connects the socket to an address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAddr};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let addr = SocketAddr::from_abstract_namespace(b\"hidden\")?; // Linux only\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     match sock.connect_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(e) => {\n+    ///             println!(\"Couldn't connect: {:?}\", e);\n+    ///             return Err(e)\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"42048\")]\n+    pub fn connect_addr(&self, socket_addr: &SocketAddr) -> io::Result<()> {\n+        unsafe {\n+            cvt(libc::connect(*self.0.as_inner(), &socket_addr.addr as *const _ as *const _, socket_addr.len))?;\n+        }\n+        Ok(())\n+    }\n+\n     /// Creates a new independently owned handle to the underlying socket.\n     ///\n     /// The returned `UnixDatagram` is a reference to the same socket that this\n@@ -473,6 +531,40 @@ impl UnixDatagram {\n         }\n     }\n \n+    /// Sends data on the socket to the specified [SocketAddr].\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// [SocketAddr]: crate::os::unix::net::SocketAddr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAddr};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let addr = SocketAddr::from_abstract_namespace(b\"hidden\")?;\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.send_to_addr(b\"bacon egg and cheese\", &addr).expect(\"send_to_addr function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"42048\")]\n+    pub fn send_to_addr(&self, buf: &[u8], socket_addr: &SocketAddr) -> io::Result<usize> {\n+        unsafe {\n+            let count = cvt(libc::sendto(\n+                *self.0.as_inner(),\n+                buf.as_ptr() as *const _,\n+                buf.len(),\n+                MSG_NOSIGNAL,\n+                &socket_addr.addr as *const _ as *const _,\n+                socket_addr.len,\n+            ))?;\n+            Ok(count as usize)\n+        }\n+    }\n+\n     /// Sends data on the socket to the socket's peer.\n     ///\n     /// The peer address may be set by the `connect` method, and this method"}, {"sha": "3077632764e5145b12c3e285e7ef9293110d8093", "filename": "library/std/src/os/unix/net/listener.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/63ebfc2c55af8b7581bea067f29276f73c7fa503/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ebfc2c55af8b7581bea067f29276f73c7fa503/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs?ref=63ebfc2c55af8b7581bea067f29276f73c7fa503", "patch": "@@ -81,6 +81,40 @@ impl UnixListener {\n         }\n     }\n \n+    /// Creates a new `UnixListener` bound to the specified [`socket address`].\n+    ///\n+    /// [`socket address`]: crate::os::unix::net::SocketAddr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let addr = SocketAddr::from_abstract_namespace(b\"namespace\")?; // Linux only\n+    ///     let listener = match UnixListener::bind_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(err) => {\n+    ///             println!(\"Couldn't bind: {:?}\", err);\n+    ///             return Err(err);\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"42048\")]\n+    pub fn bind_addr(socket_addr: &SocketAddr) -> io::Result<UnixListener> {\n+        unsafe {\n+            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+            cvt(libc::bind(*inner.as_inner(), &socket_addr.addr as *const _ as *const _, socket_addr.len as _))?;\n+            cvt(libc::listen(*inner.as_inner(), 128))?;\n+\n+            Ok(UnixListener(inner))\n+        }\n+    }\n+\n+\n     /// Accepts a new incoming connection to this listener.\n     ///\n     /// This function will block the calling thread until a new Unix connection"}, {"sha": "00a713f0732f0e5413f0113d17593b67c4c3c2f4", "filename": "library/std/src/os/unix/net/stream.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/63ebfc2c55af8b7581bea067f29276f73c7fa503/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ebfc2c55af8b7581bea067f29276f73c7fa503/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs?ref=63ebfc2c55af8b7581bea067f29276f73c7fa503", "patch": "@@ -106,6 +106,37 @@ impl UnixStream {\n         }\n     }\n \n+    /// Connects to the socket specified by [`address`].\n+    ///\n+    /// [`address`]: crate::os::unix::net::SocketAddr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixStream, SocketAddr};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let addr = SocketAddr::from_abstract_namespace(b\"hidden\")?; // Linux only\n+    ///     match UnixStream::connect_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(e) => {\n+    ///             println!(\"Couldn't connect: {:?}\", e);\n+    ///             return Err(e)\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ````\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"42048\")]\n+    pub fn connect_addr(socket_addr: &SocketAddr) -> io::Result<UnixStream> {\n+        unsafe {\n+            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+            cvt(libc::connect(*inner.as_inner(), &socket_addr.addr as *const _ as *const _, socket_addr.len))?;\n+            Ok(UnixStream(inner))\n+        }\n+    }\n+\n     /// Creates an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixStream`s which are connected to each other."}, {"sha": "b13ce0e252adb977cd74012d3e7357abb7f12911", "filename": "library/std/src/os/unix/net/tests.rs", "status": "modified", "additions": 124, "deletions": 1, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/63ebfc2c55af8b7581bea067f29276f73c7fa503/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ebfc2c55af8b7581bea067f29276f73c7fa503/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs?ref=63ebfc2c55af8b7581bea067f29276f73c7fa503", "patch": "@@ -388,10 +388,133 @@ fn test_unix_datagram_timeout_zero_duration() {\n }\n \n #[test]\n-fn abstract_namespace_not_allowed() {\n+fn abstract_namespace_not_allowed_connect() {\n     assert!(UnixStream::connect(\"\\0asdf\").is_err());\n }\n \n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_stream_connect() {\n+    let msg1 = b\"hello\";\n+    let msg2 = b\"world\";\n+\n+    let socket_addr = or_panic!(SocketAddr::from_abstract_namespace(b\"namespace\"));\n+    let listener = or_panic!(UnixListener::bind_addr(&socket_addr));\n+\n+    let thread = thread::spawn(move || {\n+        let mut stream = or_panic!(listener.accept()).0;\n+        let mut buf = [0; 5];\n+        or_panic!(stream.read(&mut buf));\n+        assert_eq!(&msg1[..], &buf[..]);\n+        or_panic!(stream.write_all(msg2));\n+    });\n+\n+    let mut stream = or_panic!(UnixStream::connect_addr(&socket_addr));\n+\n+    let peer = or_panic!(stream.peer_addr());\n+    assert_eq!(peer.as_abstract_namespace().unwrap(), b\"namespace\");\n+\n+    or_panic!(stream.write_all(msg1));\n+    let mut buf = vec![];\n+    or_panic!(stream.read_to_end(&mut buf));\n+    assert_eq!(&msg2[..], &buf[..]);\n+    drop(stream);\n+\n+    thread.join().unwrap();\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_stream_iter() {\n+    let addr = or_panic!(SocketAddr::from_abstract_namespace(b\"hidden\"));\n+    let listener = or_panic!(UnixListener::bind_addr(&addr));\n+\n+    let thread = thread::spawn(move || {\n+        for stream in listener.incoming().take(2) {\n+            let mut stream = or_panic!(stream);\n+            let mut buf = [0];\n+            or_panic!(stream.read(&mut buf));\n+        }\n+    });\n+\n+    for _ in 0..2 {\n+        let mut stream = or_panic!(UnixStream::connect_addr(&addr));\n+        or_panic!(stream.write_all(&[0]));\n+    }\n+\n+    thread.join().unwrap();\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_datagram_bind_send_to_addr() {\n+    let addr1 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns1\"));\n+    let sock1 = or_panic!(UnixDatagram::bind_addr(&addr1));\n+\n+    let local = or_panic!(sock1.local_addr());\n+    assert_eq!(local.as_abstract_namespace().unwrap(), b\"ns1\");\n+\n+    let addr2 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns2\"));\n+    let sock2 = or_panic!(UnixDatagram::bind_addr(&addr2));\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock1.send_to_addr(msg, &addr2));\n+    let mut buf = [0; 11];\n+    let (len, addr) = or_panic!(sock2.recv_from(&mut buf));\n+    assert_eq!(msg, &buf[..]);\n+    assert_eq!(len, 11);\n+    assert_eq!(addr.as_abstract_namespace().unwrap(), b\"ns1\");\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_datagram_connect_addr() {\n+    let addr1 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns3\"));\n+    let bsock1 = or_panic!(UnixDatagram::bind_addr(&addr1));\n+\n+    let sock = or_panic!(UnixDatagram::unbound());\n+    or_panic!(sock.connect_addr(&addr1));\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock.send(msg));\n+    let mut buf = [0; 11];\n+    let (len, addr) = or_panic!(bsock1.recv_from(&mut buf));\n+    assert_eq!(len, 11);\n+    assert_eq!(addr.is_unnamed(), true);\n+    assert_eq!(msg, &buf[..]);\n+\n+    let addr2 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns4\"));\n+    let bsock2 = or_panic!(UnixDatagram::bind_addr(&addr2));\n+\n+    or_panic!(sock.connect_addr(&addr2));\n+    or_panic!(sock.send(msg));\n+    or_panic!(bsock2.recv_from(&mut buf));\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_namespace_too_long() {\n+    match SocketAddr::from_abstract_namespace(\n+        b\"abcdefghijklmnopqrstuvwxyzabcdefghijklmn\\\n+        opqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghi\\\n+        jklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\",\n+    ) {\n+        Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+        Err(e) => panic!(\"unexpected error {}\", e),\n+        Ok(_) => panic!(\"unexpected success\"),\n+    }\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_namespace_no_pathname_and_not_unnamed() {\n+    let namespace = b\"local\";\n+    let addr = or_panic!(SocketAddr::from_abstract_namespace(&namespace[..]));\n+    assert_eq!(addr.as_pathname(), None);\n+    assert_eq!(addr.as_abstract_namespace(), Some(&namespace[..]));\n+    assert_eq!(addr.is_unnamed(), false);\n+}\n+\n #[test]\n fn test_unix_stream_peek() {\n     let (txdone, rxdone) = crate::sync::mpsc::channel();"}]}