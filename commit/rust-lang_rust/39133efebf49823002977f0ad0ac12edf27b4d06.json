{"sha": "39133efebf49823002977f0ad0ac12edf27b4d06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MTMzZWZlYmY0OTgyMzAwMjk3N2YwYWQwYWMxMmVkZjI3YjRkMDY=", "commit": {"author": {"name": "Ruud van Asseldonk", "email": "dev@veniogames.com", "date": "2014-08-19T12:32:20Z"}, "committer": {"name": "Ruud van Asseldonk", "email": "dev@veniogames.com", "date": "2014-08-20T11:55:02Z"}, "message": "libstd: Refactor Duration.\n\nThis changes the internal representation of `Duration` from\n\n    days: i32,\n    secs: i32,\n    nanos: u32\n\nto\n\n    secs: i64,\n    nanos: i32\n\nThis resolves #16466. Some methods now take `i64` instead of `i32` due\nto the increased range. Some methods, like `num_milliseconds`, now\nreturn an `Option<i64>` instead of `i64`, because the range of\n`Duration` is now larger than e.g. 2^63 milliseconds.", "tree": {"sha": "9cab7ff0b07902691631a230c9395979936f52ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cab7ff0b07902691631a230c9395979936f52ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39133efebf49823002977f0ad0ac12edf27b4d06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39133efebf49823002977f0ad0ac12edf27b4d06", "html_url": "https://github.com/rust-lang/rust/commit/39133efebf49823002977f0ad0ac12edf27b4d06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39133efebf49823002977f0ad0ac12edf27b4d06/comments", "author": {"login": "ruuda", "id": 506953, "node_id": "MDQ6VXNlcjUwNjk1Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/506953?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ruuda", "html_url": "https://github.com/ruuda", "followers_url": "https://api.github.com/users/ruuda/followers", "following_url": "https://api.github.com/users/ruuda/following{/other_user}", "gists_url": "https://api.github.com/users/ruuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/ruuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ruuda/subscriptions", "organizations_url": "https://api.github.com/users/ruuda/orgs", "repos_url": "https://api.github.com/users/ruuda/repos", "events_url": "https://api.github.com/users/ruuda/events{/privacy}", "received_events_url": "https://api.github.com/users/ruuda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ruuda", "id": 506953, "node_id": "MDQ6VXNlcjUwNjk1Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/506953?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ruuda", "html_url": "https://github.com/ruuda", "followers_url": "https://api.github.com/users/ruuda/followers", "following_url": "https://api.github.com/users/ruuda/following{/other_user}", "gists_url": "https://api.github.com/users/ruuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/ruuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ruuda/subscriptions", "organizations_url": "https://api.github.com/users/ruuda/orgs", "repos_url": "https://api.github.com/users/ruuda/repos", "events_url": "https://api.github.com/users/ruuda/events{/privacy}", "received_events_url": "https://api.github.com/users/ruuda/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d16a5cd7c4d37c947faf4661b22e994409197809", "url": "https://api.github.com/repos/rust-lang/rust/commits/d16a5cd7c4d37c947faf4661b22e994409197809", "html_url": "https://github.com/rust-lang/rust/commit/d16a5cd7c4d37c947faf4661b22e994409197809"}], "stats": {"total": 496, "additions": 208, "deletions": 288}, "files": [{"sha": "52d3a04432a358e742559d64bd313912253934be", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39133efebf49823002977f0ad0ac12edf27b4d06/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39133efebf49823002977f0ad0ac12edf27b4d06/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=39133efebf49823002977f0ad0ac12edf27b4d06", "patch": "@@ -97,25 +97,31 @@ impl TcpStream {\n     /// the specified duration.\n     ///\n     /// This is the same as the `connect` method, except that if the timeout\n-    /// specified (in milliseconds) elapses before a connection is made an error\n-    /// will be returned. The error's kind will be `TimedOut`.\n+    /// specified elapses before a connection is made an error will be\n+    /// returned. The error's kind will be `TimedOut`.\n     ///\n     /// Note that the `addr` argument may one day be split into a separate host\n     /// and port, similar to the API seen in `connect`.\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n+    /// If the timeout is larger than 2^63 milliseconds, the function also\n+    /// returns `Err` with the error kind set to `TimedOut`.\n     #[experimental = \"the timeout argument may eventually change types\"]\n     pub fn connect_timeout(addr: SocketAddr,\n                            timeout: Duration) -> IoResult<TcpStream> {\n         if timeout <= Duration::milliseconds(0) {\n             return Err(standard_error(TimedOut));\n         }\n+        let timeout_ms = timeout.num_milliseconds().map(|x| { x as u64 });\n+        if timeout_ms.is_none() {\n+            return Err(standard_error(TimedOut));\n+        }\n \n         let SocketAddr { ip, port } = addr;\n         let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n         LocalIo::maybe_raise(|io| {\n-            io.tcp_connect(addr, Some(timeout.num_milliseconds() as u64)).map(TcpStream::new)\n+            io.tcp_connect(addr, timeout_ms).map(TcpStream::new)\n         }).map_err(IoError::from_rtio_error)\n     }\n "}, {"sha": "179855003f9bdece2b969a2d1d8dd18d85bcd0b0", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39133efebf49823002977f0ad0ac12edf27b4d06/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39133efebf49823002977f0ad0ac12edf27b4d06/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=39133efebf49823002977f0ad0ac12edf27b4d06", "patch": "@@ -61,20 +61,26 @@ impl UnixStream {\n     /// Connect to a pipe named by `path`, timing out if the specified number of\n     /// milliseconds.\n     ///\n-    /// This function is similar to `connect`, except that if `timeout_ms`\n+    /// This function is similar to `connect`, except that if `timeout`\n     /// elapses the function will return an error of kind `TimedOut`.\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n+    /// If the timeout is larger than 2^63 milliseconds, the function also\n+    /// returns `Err` with the error kind set to `TimedOut`.\n     #[experimental = \"the timeout argument is likely to change types\"]\n     pub fn connect_timeout<P: ToCStr>(path: &P,\n                                       timeout: Duration) -> IoResult<UnixStream> {\n         if timeout <= Duration::milliseconds(0) {\n             return Err(standard_error(TimedOut));\n         }\n+        let timeout_ms = timeout.num_milliseconds().map(|x| { x as u64 });\n+        if timeout_ms.is_none() {\n+            return Err(standard_error(TimedOut));\n+        }\n \n         LocalIo::maybe_raise(|io| {\n-            let s = io.unix_connect(&path.to_c_str(), Some(timeout.num_milliseconds() as u64));\n+            let s = io.unix_connect(&path.to_c_str(), timeout_ms);\n             s.map(|p| UnixStream { obj: p })\n         }).map_err(IoError::from_rtio_error)\n     }"}, {"sha": "205132aca1d35a4d1fd37eaa5fbaa9be96cd0537", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39133efebf49823002977f0ad0ac12edf27b4d06/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39133efebf49823002977f0ad0ac12edf27b4d06/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=39133efebf49823002977f0ad0ac12edf27b4d06", "patch": "@@ -225,7 +225,7 @@ impl Callback for TimerCallback {\n }\n \n fn in_ms_u64(d: Duration) -> u64 {\n-    let ms = d.num_milliseconds();\n+    let ms = d.num_milliseconds().unwrap_or(0);\n     if ms < 0 { return 0 };\n     return ms as u64;\n }"}, {"sha": "c2030ccceb06de5dbde24bbf0fa09eabc23b5427", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 190, "deletions": 282, "changes": 472, "blob_url": "https://github.com/rust-lang/rust/blob/39133efebf49823002977f0ad0ac12edf27b4d06/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39133efebf49823002977f0ad0ac12edf27b4d06/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=39133efebf49823002977f0ad0ac12edf27b4d06", "patch": "@@ -12,227 +12,182 @@\n \n #![experimental]\n \n-use {fmt, i32};\n+use {fmt, i64};\n use ops::{Add, Sub, Mul, Div, Neg};\n use option::{Option, Some, None};\n use num;\n use num::{CheckedAdd, CheckedMul};\n use result::{Result, Ok, Err};\n \n-\n-/// `Duration`'s `days` component should have no more than this value.\n-static MIN_DAYS: i32 = i32::MIN;\n-/// `Duration`'s `days` component should have no less than this value.\n-static MAX_DAYS: i32 = i32::MAX;\n-\n+/// The number of nanoseconds in a microsecond.\n+static NANOS_PER_MICRO: i32 = 1000;\n+/// The number of nanosecdons in a millisecond.\n+static NANOS_PER_MILLI: i32 = 1000_000;\n /// The number of nanoseconds in seconds.\n static NANOS_PER_SEC: i32 = 1_000_000_000;\n+/// The number of microseconds per second.\n+static MICROS_PER_SEC: i64 = 1000_000;\n+/// The number of milliseconds per second.\n+static MILLIS_PER_SEC: i64 = 1000;\n+/// The number of seconds in a minute.\n+static SECS_PER_MINUTE: i64 = 60;\n+/// The number of seconds in an hour.\n+static SECS_PER_HOUR: i64 = 3600;\n /// The number of (non-leap) seconds in days.\n-static SECS_PER_DAY: i32 = 86400;\n+static SECS_PER_DAY: i64 = 86400;\n+/// The number of (non-leap) seconds in a week.\n+static SECS_PER_WEEK: i64 = 604800;\n \n macro_rules! try_opt(\n     ($e:expr) => (match $e { Some(v) => v, None => return None })\n )\n \n \n-// FIXME #16466: This could be represented as (i64 seconds, u32 nanos)\n /// ISO 8601 time duration with nanosecond precision.\n /// This also allows for the negative duration; see individual methods for details.\n #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct Duration {\n-    days: i32,\n-    secs: u32,  // Always < SECS_PER_DAY\n-    nanos: u32, // Always < NANOS_PR_SECOND\n+    secs: i64,\n+    nanos: i32, // Always 0 <= nanos < NANOS_PER_SEC\n }\n \n /// The minimum possible `Duration`.\n-pub static MIN: Duration = Duration { days: MIN_DAYS, secs: 0, nanos: 0 };\n+pub static MIN: Duration = Duration { secs: i64::MIN, nanos: 0 };\n /// The maximum possible `Duration`.\n-pub static MAX: Duration = Duration { days: MAX_DAYS, secs: SECS_PER_DAY as u32 - 1,\n-                                      nanos: NANOS_PER_SEC as u32 - 1 };\n+pub static MAX: Duration = Duration { secs: i64::MAX, nanos: NANOS_PER_SEC - 1 };\n \n impl Duration {\n     /// Makes a new `Duration` with given number of weeks.\n-    /// Equivalent to `Duration::new(weeks * 7, 0, 0)` with overflow checks.\n-    ///\n+    /// Equivalent to `Duration::seconds(weeks * 7 * 24 * 60 * 60), with overflow checks.\n     /// Fails when the duration is out of bounds.\n     #[inline]\n-    pub fn weeks(weeks: i32) -> Duration {\n-        let days = weeks.checked_mul(&7).expect(\"Duration::weeks out of bounds\");\n-        Duration::days(days)\n+    pub fn weeks(weeks: i64) -> Duration {\n+        let secs = weeks.checked_mul(&SECS_PER_WEEK).expect(\"Duration::weeks out of bounds\");\n+        Duration::seconds(secs)\n     }\n \n     /// Makes a new `Duration` with given number of days.\n-    /// Equivalent to `Duration::new(days, 0, 0)`.\n+    /// Equivalent to `Duration::seconds(days * 24 * 60 * 60)` with overflow checks.\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n-    pub fn days(days: i32) -> Duration {\n-        Duration { days: days, secs: 0, nanos: 0 }\n+    pub fn days(days: i64) -> Duration {\n+        let secs = days.checked_mul(&SECS_PER_DAY).expect(\"Duration::days out of bounds\");\n+        Duration::seconds(secs)\n     }\n \n     /// Makes a new `Duration` with given number of hours.\n-    /// Equivalent to `Duration::new(0, hours * 3600, 0)` with overflow checks.\n+    /// Equivalent to `Duration::seconds(hours * 60 * 60)` with overflow checks.\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n-    pub fn hours(hours: i32) -> Duration {\n-        let (days, hours) = div_mod_floor(hours, (SECS_PER_DAY / 3600));\n-        let secs = hours * 3600;\n-        Duration { secs: secs as u32, ..Duration::days(days) }\n+    pub fn hours(hours: i64) -> Duration {\n+        let secs = hours.checked_mul(&SECS_PER_HOUR).expect(\"Duration::hours ouf of bounds\");\n+        Duration::seconds(secs)\n     }\n \n     /// Makes a new `Duration` with given number of minutes.\n-    /// Equivalent to `Duration::new(0, mins * 60, 0)` with overflow checks.\n+    /// Equivalent to `Duration::seconds(minutes * 60)` with overflow checks.\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n-    pub fn minutes(mins: i32) -> Duration {\n-        let (days, mins) = div_mod_floor(mins, (SECS_PER_DAY / 60));\n-        let secs = mins * 60;\n-        Duration { secs: secs as u32, ..Duration::days(days) }\n+    pub fn minutes(minutes: i64) -> Duration {\n+        let secs = minutes.checked_mul(&SECS_PER_MINUTE).expect(\"Duration::minutes out of bounds\");\n+        Duration::seconds(secs)\n     }\n \n     /// Makes a new `Duration` with given number of seconds.\n-    /// Equivalent to `Duration::new(0, secs, 0)`.\n     #[inline]\n-    pub fn seconds(secs: i32) -> Duration {\n-        let (days, secs) = div_mod_floor(secs, SECS_PER_DAY);\n-        Duration { secs: secs as u32, ..Duration::days(days) }\n+    pub fn seconds(seconds: i64) -> Duration {\n+        Duration { secs: seconds, nanos: 0 }\n     }\n \n     /// Makes a new `Duration` with given number of milliseconds.\n-    /// Equivalent to `Duration::new(0, 0, millis * 1_000_000)` with overflow checks.\n     #[inline]\n-    pub fn milliseconds(millis: i32) -> Duration {\n-        let (secs, millis) = div_mod_floor(millis, (NANOS_PER_SEC / 1_000_000));\n-        let nanos = millis * 1_000_000;\n-        Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n+    pub fn milliseconds(milliseconds: i64) -> Duration {\n+        let (secs, millis) = div_mod_floor_64(milliseconds, MILLIS_PER_SEC);\n+        let nanos = millis as i32 * NANOS_PER_MILLI;\n+        Duration { secs: secs, nanos: nanos }\n     }\n \n     /// Makes a new `Duration` with given number of microseconds.\n-    /// Equivalent to `Duration::new(0, 0, micros * 1_000)` with overflow checks.\n     #[inline]\n-    pub fn microseconds(micros: i32) -> Duration {\n-        let (secs, micros) = div_mod_floor(micros, (NANOS_PER_SEC / 1_000));\n-        let nanos = micros * 1_000;\n-        Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n+    pub fn microseconds(microseconds: i64) -> Duration {\n+        let (secs, micros) = div_mod_floor_64(microseconds, MICROS_PER_SEC);\n+        let nanos = micros as i32 * NANOS_PER_MICRO;\n+        Duration { secs: secs, nanos: nanos }\n     }\n \n     /// Makes a new `Duration` with given number of nanoseconds.\n-    /// Equivalent to `Duration::new(0, 0, nanos)`.\n     #[inline]\n-    pub fn nanoseconds(nanos: i32) -> Duration {\n-        let (secs, nanos) = div_mod_floor(nanos, NANOS_PER_SEC);\n-        Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n-    }\n-\n-    /// Returns a tuple of the number of days, (non-leap) seconds and\n-    /// nanoseconds in the duration.  Note that the number of seconds\n-    /// and nanoseconds are always positive, so that for example\n-    /// `-Duration::seconds(3)` has -1 days and 86,397 seconds.\n-    #[inline]\n-    fn to_tuple_64(&self) -> (i64, u32, u32) {\n-        (self.days as i64, self.secs, self.nanos)\n-    }\n-\n-    /// Negates the duration and returns a tuple like `to_tuple`.\n-    /// This does not overflow and thus is internally used for several methods.\n-    fn to_negated_tuple_64(&self) -> (i64, u32, u32) {\n-        let mut days = -(self.days as i64);\n-        let mut secs = -(self.secs as i32);\n-        let mut nanos = -(self.nanos as i32);\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n-        if secs < 0 {\n-            secs += SECS_PER_DAY;\n-            days -= 1;\n-        }\n-        (days, secs as u32, nanos as u32)\n+    pub fn nanoseconds(nanos: i64) -> Duration {\n+        let (secs, nanos) = div_mod_floor_64(nanos, NANOS_PER_SEC as i64);\n+        Duration { secs: secs, nanos: nanos as i32 }\n     }\n \n     /// Returns the total number of whole weeks in the duration.\n     #[inline]\n-    pub fn num_weeks(&self) -> i32 {\n+    pub fn num_weeks(&self) -> i64 {\n         self.num_days() / 7\n     }\n \n     /// Returns the total number of whole days in the duration.\n-    pub fn num_days(&self) -> i32 {\n-        if self.days < 0 {\n-            let negated = -*self;\n-            -negated.days\n-        } else {\n-            self.days\n-        }\n+    pub fn num_days(&self) -> i64 {\n+        self.num_seconds() / SECS_PER_DAY\n     }\n \n     /// Returns the total number of whole hours in the duration.\n     #[inline]\n     pub fn num_hours(&self) -> i64 {\n-        self.num_seconds() / 3600\n+        self.num_seconds() / SECS_PER_HOUR\n     }\n \n     /// Returns the total number of whole minutes in the duration.\n     #[inline]\n     pub fn num_minutes(&self) -> i64 {\n-        self.num_seconds() / 60\n+        self.num_seconds() / SECS_PER_MINUTE\n     }\n \n     /// Returns the total number of whole seconds in the duration.\n     pub fn num_seconds(&self) -> i64 {\n-        // cannot overflow, 2^32 * 86400 < 2^64\n-        fn secs((days, secs, _): (i64, u32, u32)) -> i64 {\n-            days as i64 * SECS_PER_DAY as i64 + secs as i64\n+        // If secs is negative, nanos should be subtracted from the duration.\n+        if self.secs < 0 && self.nanos > 0 {\n+            self.secs + 1\n+        } else {\n+            self.secs\n         }\n-        if self.days < 0 {-secs(self.to_negated_tuple_64())} else {secs(self.to_tuple_64())}\n-    }\n-\n-    /// Returns the total number of whole milliseconds in the duration.\n-    pub fn num_milliseconds(&self) -> i64 {\n-        // cannot overflow, 2^32 * 86400 * 1000 < 2^64\n-        fn millis((days, secs, nanos): (i64, u32, u32)) -> i64 {\n-            static MILLIS_PER_SEC: i64 = 1_000;\n-            static NANOS_PER_MILLI: i64 = 1_000_000;\n-            (days as i64 * MILLIS_PER_SEC * SECS_PER_DAY as i64 +\n-             secs as i64 * MILLIS_PER_SEC +\n-             nanos as i64 / NANOS_PER_MILLI)\n+    }\n+\n+    /// Returns the number of nanoseconds such that\n+    /// `nanos_mod_sec() + num_seconds() * NANOS_PER_SEC` is the total number of\n+    /// nanoseconds in the duration.\n+    fn nanos_mod_sec(&self) -> i32 {\n+        if self.secs < 0 && self.nanos > 0 {\n+            self.nanos - NANOS_PER_SEC\n+        } else {\n+            self.nanos\n         }\n-        if self.days < 0 {-millis(self.to_negated_tuple_64())} else {millis(self.to_tuple_64())}\n+    }\n+\n+    /// Returns the total number of whole milliseconds in the duration,\n+    /// or `None` on overflow (exceeding 2^63 milliseconds in either direction).\n+    pub fn num_milliseconds(&self) -> Option<i64> {\n+        let secs_part = try_opt!(self.num_seconds().checked_mul(&MILLIS_PER_SEC));\n+        let nanos_part = self.nanos_mod_sec() / NANOS_PER_MILLI;\n+        secs_part.checked_add(&(nanos_part as i64))\n     }\n \n     /// Returns the total number of whole microseconds in the duration,\n-    /// or `None` on the overflow (exceeding 2^63 microseconds in either directions).\n+    /// or `None` on overflow (exceeding 2^63 microseconds in either direction).\n     pub fn num_microseconds(&self) -> Option<i64> {\n-        fn micros((days, secs, nanos): (i64, u32, u32)) -> Option<i64> {\n-            static MICROS_PER_SEC: i64 = 1_000_000;\n-            static MICROS_PER_DAY: i64 = MICROS_PER_SEC * SECS_PER_DAY as i64;\n-            static NANOS_PER_MICRO: i64 = 1_000;\n-            let nmicros = try_opt!((days as i64).checked_mul(&MICROS_PER_DAY));\n-            let nmicros = try_opt!(nmicros.checked_add(&(secs as i64 * MICROS_PER_SEC)));\n-            let nmicros = try_opt!(nmicros.checked_add(&(nanos as i64 / NANOS_PER_MICRO as i64)));\n-            Some(nmicros)\n-        }\n-        if self.days < 0 {\n-            // the final negation won't overflow since we start with positive numbers.\n-            micros(self.to_negated_tuple_64()).map(|micros| -micros)\n-        } else {\n-            micros(self.to_tuple_64())\n-        }\n+        let secs_part = try_opt!(self.num_seconds().checked_mul(&MICROS_PER_SEC));\n+        let nanos_part = self.nanos_mod_sec() / NANOS_PER_MICRO;\n+        secs_part.checked_add(&(nanos_part as i64))\n     }\n \n     /// Returns the total number of whole nanoseconds in the duration,\n-    /// or `None` on the overflow (exceeding 2^63 nanoseconds in either directions).\n+    /// or `None` on overflow (exceeding 2^63 nanoseconds in either direction).\n     pub fn num_nanoseconds(&self) -> Option<i64> {\n-        fn nanos((days, secs, nanos): (i64, u32, u32)) -> Option<i64> {\n-            static NANOS_PER_DAY: i64 = NANOS_PER_SEC as i64 * SECS_PER_DAY as i64;\n-            let nnanos = try_opt!((days as i64).checked_mul(&NANOS_PER_DAY));\n-            let nnanos = try_opt!(nnanos.checked_add(&(secs as i64 * NANOS_PER_SEC as i64)));\n-            let nnanos = try_opt!(nnanos.checked_add(&(nanos as i64)));\n-            Some(nnanos)\n-        }\n-        if self.days < 0 {\n-            // the final negation won't overflow since we start with positive numbers.\n-            nanos(self.to_negated_tuple_64()).map(|micros| -micros)\n-        } else {\n-            nanos(self.to_tuple_64())\n-        }\n+        let secs_part = try_opt!(self.num_seconds().checked_mul(&(NANOS_PER_SEC as i64)));\n+        let nanos_part = self.nanos_mod_sec();\n+        secs_part.checked_add(&(nanos_part as i64))\n     }\n }\n \n@@ -244,191 +199,137 @@ impl num::Bounded for Duration {\n impl num::Zero for Duration {\n     #[inline]\n     fn zero() -> Duration {\n-        Duration { days: 0, secs: 0, nanos: 0 }\n+        Duration { secs: 0, nanos: 0 }\n     }\n \n     #[inline]\n     fn is_zero(&self) -> bool {\n-        self.days == 0 && self.secs == 0 && self.nanos == 0\n+        self.secs == 0 && self.nanos == 0\n     }\n }\n \n impl Neg<Duration> for Duration {\n     #[inline]\n     fn neg(&self) -> Duration {\n-        let (days, secs, nanos) = self.to_negated_tuple_64();\n-        Duration { days: days as i32, secs: secs, nanos: nanos } // FIXME can overflow\n+        if self.secs == i64::MIN && self.nanos == 0 {\n+            // The minimum value cannot be negated due to overflow. Use the\n+            // maximum value, which is one nanosecond less than the negated minimum.\n+            MAX\n+        } else if self.secs == i64::MIN {\n+            Duration { secs: i64::MAX, nanos: NANOS_PER_SEC - self.nanos }\n+        } else if self.nanos == 0 {\n+            Duration { secs: -self.secs, nanos: 0 }\n+        } else {\n+            Duration { secs: -self.secs - 1, nanos: NANOS_PER_SEC - self.nanos }\n+        }\n     }\n }\n \n impl Add<Duration,Duration> for Duration {\n     fn add(&self, rhs: &Duration) -> Duration {\n-        let mut days = self.days + rhs.days;\n         let mut secs = self.secs + rhs.secs;\n         let mut nanos = self.nanos + rhs.nanos;\n-        if nanos >= NANOS_PER_SEC as u32 {\n-            nanos -= NANOS_PER_SEC as u32;\n+        if nanos >= NANOS_PER_SEC {\n+            nanos -= NANOS_PER_SEC;\n             secs += 1;\n         }\n-        if secs >= SECS_PER_DAY as u32 {\n-            secs -= SECS_PER_DAY as u32;\n-            days += 1;\n-        }\n-        Duration { days: days, secs: secs, nanos: nanos }\n+        Duration { secs: secs, nanos: nanos }\n     }\n }\n \n impl num::CheckedAdd for Duration {\n     fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut days = try_opt!(self.days.checked_add(&rhs.days));\n-        let mut secs = self.secs + rhs.secs;\n+        let mut secs = try_opt!(self.secs.checked_add(&rhs.secs));\n         let mut nanos = self.nanos + rhs.nanos;\n-        if nanos >= NANOS_PER_SEC as u32 {\n-            nanos -= NANOS_PER_SEC as u32;\n-            secs += 1;\n+        if nanos >= NANOS_PER_SEC {\n+            nanos -= NANOS_PER_SEC;\n+            secs = try_opt!(secs.checked_add(&1));\n         }\n-        if secs >= SECS_PER_DAY as u32 {\n-            secs -= SECS_PER_DAY as u32;\n-            days = try_opt!(days.checked_add(&1));\n-        }\n-        Some(Duration { days: days, secs: secs, nanos: nanos })\n+        Some(Duration { secs: secs, nanos: nanos }) \n     }\n }\n \n impl Sub<Duration,Duration> for Duration {\n     fn sub(&self, rhs: &Duration) -> Duration {\n-        let mut days = self.days - rhs.days;\n-        let mut secs = self.secs as i32 - rhs.secs as i32;\n-        let mut nanos = self.nanos as i32 - rhs.nanos as i32;\n+        let mut secs = self.secs - rhs.secs;\n+        let mut nanos = self.nanos - rhs.nanos;\n         if nanos < 0 {\n             nanos += NANOS_PER_SEC;\n             secs -= 1;\n         }\n-        if secs < 0 {\n-            secs += SECS_PER_DAY;\n-            days -= 1;\n-        }\n-        Duration { days: days, secs: secs as u32, nanos: nanos as u32 }\n+        Duration { secs: secs, nanos: nanos }\n     }\n }\n \n impl num::CheckedSub for Duration {\n     fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut days = try_opt!(self.days.checked_sub(&rhs.days));\n-        let mut secs = self.secs as i32 - rhs.secs as i32;\n-        let mut nanos = self.nanos as i32 - rhs.nanos as i32;\n+        let mut secs = try_opt!(self.secs.checked_sub(&rhs.secs));\n+        let mut nanos = self.nanos - rhs.nanos;\n         if nanos < 0 {\n             nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n-        if secs < 0 {\n-            secs += SECS_PER_DAY;\n-            days = try_opt!(days.checked_sub(&1));\n+            secs = try_opt!(secs.checked_sub(&1));\n         }\n-        Some(Duration { days: days, secs: secs as u32, nanos: nanos as u32 })\n+        Some(Duration { secs: secs, nanos: nanos })\n     }\n }\n \n impl Mul<i32,Duration> for Duration {\n     fn mul(&self, rhs: &i32) -> Duration {\n-        /// Given `0 <= y < limit <= 2^30`,\n-        /// returns `(h,l)` such that `x * y = h * limit + l` where `0 <= l < limit`.\n-        fn mul_i64_u32_limit(x: i64, y: u32, limit: u32) -> (i64,u32) {\n-            let y = y as i64;\n-            let limit = limit as i64;\n-            let (xh, xl) = div_mod_floor_64(x, limit);\n-            let (h, l) = (xh * y, xl * y);\n-            let (h_, l) = div_rem_64(l, limit);\n-            (h + h_, l as u32)\n-        }\n-\n-        let rhs = *rhs as i64;\n-        let (secs1, nanos) = mul_i64_u32_limit(rhs, self.nanos, NANOS_PER_SEC as u32);\n-        let (days1, secs1) = div_mod_floor_64(secs1, (SECS_PER_DAY as i64));\n-        let (days2, secs2) = mul_i64_u32_limit(rhs, self.secs, SECS_PER_DAY as u32);\n-        let mut days = self.days as i64 * rhs + days1 + days2;\n-        let mut secs = secs1 as u32 + secs2;\n-        if secs >= SECS_PER_DAY as u32 {\n-            secs -= 1;\n-            days += 1;\n-        }\n-        Duration { days: days as i32, secs: secs, nanos: nanos }\n+        // Multiply nanoseconds as i64, because it cannot overflow that way.\n+        let total_nanos = self.nanos as i64 * *rhs as i64;\n+        let (extra_secs, nanos) = div_mod_floor_64(total_nanos, NANOS_PER_SEC as i64);\n+        let secs = self.secs * *rhs as i64 + extra_secs;\n+        Duration { secs: secs, nanos: nanos as i32 }\n     }\n }\n \n impl Div<i32,Duration> for Duration {\n     fn div(&self, rhs: &i32) -> Duration {\n-        let (rhs, days, secs, nanos) = if *rhs < 0 {\n-            let (days, secs, nanos) = self.to_negated_tuple_64();\n-            (-(*rhs as i64), days, secs as i64, nanos as i64)\n-        } else {\n-            (*rhs as i64, self.days as i64, self.secs as i64, self.nanos as i64)\n-        };\n-\n-        let (days, carry) = div_mod_floor_64(days, rhs);\n-        let secs = secs + carry * SECS_PER_DAY as i64;\n-        let (secs, carry) = div_mod_floor_64(secs, rhs);\n-        let nanos = nanos + carry * NANOS_PER_SEC as i64;\n-        let nanos = nanos / rhs;\n-        Duration { days: days as i32, secs: secs as u32, nanos: nanos as u32 }\n+        let mut secs = self.secs / *rhs as i64;\n+        let carry = self.secs - secs * *rhs as i64;\n+        let extra_nanos = carry * NANOS_PER_SEC as i64 / *rhs as i64;\n+        let mut nanos = self.nanos / *rhs + extra_nanos as i32;\n+        if nanos >= NANOS_PER_SEC {\n+            nanos -= NANOS_PER_SEC;\n+            secs += 1;\n+        }\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        Duration { secs: secs, nanos: nanos }\n     }\n }\n \n impl fmt::Show for Duration {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let hasdate = self.days != 0;\n-        let hastime = (self.secs != 0 || self.nanos != 0) || !hasdate;\n+        let days = self.num_days();\n+        let secs = self.secs - days * SECS_PER_DAY;\n+        let hasdate = days != 0;\n+        let hastime = (secs != 0 || self.nanos != 0) || !hasdate;\n \n         try!(write!(f, \"P\"));\n         if hasdate {\n             // technically speaking the negative part is not the valid ISO 8601,\n             // but we need to print it anyway.\n-            try!(write!(f, \"{}D\", self.days));\n+            try!(write!(f, \"{}D\", days));\n         }\n         if hastime {\n             if self.nanos == 0 {\n-                try!(write!(f, \"T{}S\", self.secs));\n-            } else if self.nanos % 1_000_000 == 0 {\n-                try!(write!(f, \"T{}.{:03}S\", self.secs, self.nanos / 1_000_000));\n-            } else if self.nanos % 1_000 == 0 {\n-                try!(write!(f, \"T{}.{:06}S\", self.secs, self.nanos / 1_000));\n+                try!(write!(f, \"T{}S\", secs));\n+            } else if self.nanos % NANOS_PER_MILLI == 0 {\n+                try!(write!(f, \"T{}.{:03}S\", secs, self.nanos / NANOS_PER_MILLI));\n+            } else if self.nanos % NANOS_PER_MICRO == 0 {\n+                try!(write!(f, \"T{}.{:06}S\", secs, self.nanos / NANOS_PER_MICRO));\n             } else {\n-                try!(write!(f, \"T{}.{:09}S\", self.secs, self.nanos));\n+                try!(write!(f, \"T{}.{:09}S\", secs, self.nanos));\n             }\n         }\n         Ok(())\n     }\n }\n \n // Copied from libnum\n-#[inline]\n-fn div_mod_floor(this: i32, other: i32) -> (i32, i32) {\n-    (div_floor(this, other), mod_floor(this, other))\n-}\n-\n-#[inline]\n-fn div_floor(this: i32, other: i32) -> i32 {\n-    match div_rem(this, other) {\n-        (d, r) if (r > 0 && other < 0)\n-               || (r < 0 && other > 0) => d - 1,\n-        (d, _)                         => d,\n-    }\n-}\n-\n-#[inline]\n-fn mod_floor(this: i32, other: i32) -> i32 {\n-    match this % other {\n-        r if (r > 0 && other < 0)\n-          || (r < 0 && other > 0) => r + other,\n-        r                         => r,\n-    }\n-}\n-\n-#[inline]\n-fn div_rem(this: i32, other: i32) -> (i32, i32) {\n-    (this / other, this % other)\n-}\n-\n #[inline]\n fn div_mod_floor_64(this: i64, other: i64) -> (i64, i64) {\n     (div_floor_64(this, other), mod_floor_64(this, other))\n@@ -459,7 +360,7 @@ fn div_rem_64(this: i64, other: i64) -> (i64, i64) {\n \n #[cfg(test)]\n mod tests {\n-    use super::{Duration, MIN_DAYS, MAX_DAYS, MIN, MAX};\n+    use super::{Duration, MIN, MAX};\n     use {i32, i64};\n     use num::{Zero, CheckedAdd, CheckedSub};\n     use option::{Some, None};\n@@ -492,10 +393,8 @@ mod tests {\n         assert_eq!(Duration::seconds(86401).num_days(), 1);\n         assert_eq!(Duration::seconds(-86399).num_days(), 0);\n         assert_eq!(Duration::seconds(-86401).num_days(), -1);\n-        assert_eq!(Duration::days(i32::MAX).num_days(), i32::MAX);\n-        assert_eq!(Duration::days(i32::MIN).num_days(), i32::MIN);\n-        assert_eq!(MAX.num_days(), MAX_DAYS);\n-        assert_eq!(MIN.num_days(), MIN_DAYS);\n+        assert_eq!(Duration::days(i32::MAX as i64).num_days(), i32::MAX as i64);\n+        assert_eq!(Duration::days(i32::MIN as i64).num_days(), i32::MIN as i64);\n     }\n \n     #[test]\n@@ -508,26 +407,26 @@ mod tests {\n         assert_eq!(Duration::milliseconds(1001).num_seconds(), 1);\n         assert_eq!(Duration::milliseconds(-999).num_seconds(), 0);\n         assert_eq!(Duration::milliseconds(-1001).num_seconds(), -1);\n-        assert_eq!(Duration::seconds(i32::MAX).num_seconds(), i32::MAX as i64);\n-        assert_eq!(Duration::seconds(i32::MIN).num_seconds(), i32::MIN as i64);\n-        assert_eq!(MAX.num_seconds(), (MAX_DAYS as i64 + 1) * 86400 - 1);\n-        assert_eq!(MIN.num_seconds(), MIN_DAYS as i64 * 86400);\n+        assert_eq!(Duration::seconds(i64::MAX).num_seconds(), i64::MAX);\n+        assert_eq!(Duration::seconds(i64::MIN).num_seconds(), i64::MIN);\n+        assert_eq!(MAX.num_seconds(), i64::MAX);\n+        assert_eq!(MIN.num_seconds(), i64::MIN);\n     }\n \n     #[test]\n     fn test_duration_num_milliseconds() {\n         let d: Duration = Zero::zero();\n-        assert_eq!(d.num_milliseconds(), 0);\n-        assert_eq!(Duration::milliseconds(1).num_milliseconds(), 1);\n-        assert_eq!(Duration::milliseconds(-1).num_milliseconds(), -1);\n-        assert_eq!(Duration::microseconds(999).num_milliseconds(), 0);\n-        assert_eq!(Duration::microseconds(1001).num_milliseconds(), 1);\n-        assert_eq!(Duration::microseconds(-999).num_milliseconds(), 0);\n-        assert_eq!(Duration::microseconds(-1001).num_milliseconds(), -1);\n-        assert_eq!(Duration::milliseconds(i32::MAX).num_milliseconds(), i32::MAX as i64);\n-        assert_eq!(Duration::milliseconds(i32::MIN).num_milliseconds(), i32::MIN as i64);\n-        assert_eq!(MAX.num_milliseconds(), (MAX_DAYS as i64 + 1) * 86400_000 - 1);\n-        assert_eq!(MIN.num_milliseconds(), MIN_DAYS as i64 * 86400_000);\n+        assert_eq!(d.num_milliseconds(), Some(0));\n+        assert_eq!(Duration::milliseconds(1).num_milliseconds(), Some(1));\n+        assert_eq!(Duration::milliseconds(-1).num_milliseconds(), Some(-1));\n+        assert_eq!(Duration::microseconds(999).num_milliseconds(), Some(0));\n+        assert_eq!(Duration::microseconds(1001).num_milliseconds(), Some(1));\n+        assert_eq!(Duration::microseconds(-999).num_milliseconds(), Some(0));\n+        assert_eq!(Duration::microseconds(-1001).num_milliseconds(), Some(-1));\n+        assert_eq!(Duration::milliseconds(i64::MAX).num_milliseconds(), Some(i64::MAX));\n+        assert_eq!(Duration::milliseconds(i64::MIN).num_milliseconds(), Some(i64::MIN));\n+        assert_eq!(MAX.num_milliseconds(), None);\n+        assert_eq!(MIN.num_milliseconds(), None);\n     }\n \n     #[test]\n@@ -540,19 +439,19 @@ mod tests {\n         assert_eq!(Duration::nanoseconds(1001).num_microseconds(), Some(1));\n         assert_eq!(Duration::nanoseconds(-999).num_microseconds(), Some(0));\n         assert_eq!(Duration::nanoseconds(-1001).num_microseconds(), Some(-1));\n-        assert_eq!(Duration::microseconds(i32::MAX).num_microseconds(), Some(i32::MAX as i64));\n-        assert_eq!(Duration::microseconds(i32::MIN).num_microseconds(), Some(i32::MIN as i64));\n+        assert_eq!(Duration::microseconds(i64::MAX).num_microseconds(), Some(i64::MAX));\n+        assert_eq!(Duration::microseconds(i64::MIN).num_microseconds(), Some(i64::MIN));\n         assert_eq!(MAX.num_microseconds(), None);\n         assert_eq!(MIN.num_microseconds(), None);\n \n         // overflow checks\n         static MICROS_PER_DAY: i64 = 86400_000_000;\n-        assert_eq!(Duration::days((i64::MAX / MICROS_PER_DAY) as i32).num_microseconds(),\n+        assert_eq!(Duration::days(i64::MAX / MICROS_PER_DAY).num_microseconds(),\n                    Some(i64::MAX / MICROS_PER_DAY * MICROS_PER_DAY));\n-        assert_eq!(Duration::days((i64::MIN / MICROS_PER_DAY) as i32).num_microseconds(),\n+        assert_eq!(Duration::days(i64::MIN / MICROS_PER_DAY).num_microseconds(),\n                    Some(i64::MIN / MICROS_PER_DAY * MICROS_PER_DAY));\n-        assert_eq!(Duration::days((i64::MAX / MICROS_PER_DAY + 1) as i32).num_microseconds(), None);\n-        assert_eq!(Duration::days((i64::MIN / MICROS_PER_DAY - 1) as i32).num_microseconds(), None);\n+        assert_eq!(Duration::days(i64::MAX / MICROS_PER_DAY + 1).num_microseconds(), None);\n+        assert_eq!(Duration::days(i64::MIN / MICROS_PER_DAY - 1).num_microseconds(), None);\n     }\n \n     #[test]\n@@ -561,30 +460,30 @@ mod tests {\n         assert_eq!(d.num_nanoseconds(), Some(0));\n         assert_eq!(Duration::nanoseconds(1).num_nanoseconds(), Some(1));\n         assert_eq!(Duration::nanoseconds(-1).num_nanoseconds(), Some(-1));\n-        assert_eq!(Duration::nanoseconds(i32::MAX).num_nanoseconds(), Some(i32::MAX as i64));\n-        assert_eq!(Duration::nanoseconds(i32::MIN).num_nanoseconds(), Some(i32::MIN as i64));\n+        assert_eq!(Duration::nanoseconds(i64::MAX).num_nanoseconds(), Some(i64::MAX));\n+        assert_eq!(Duration::nanoseconds(i64::MIN).num_nanoseconds(), Some(i64::MIN));\n         assert_eq!(MAX.num_nanoseconds(), None);\n         assert_eq!(MIN.num_nanoseconds(), None);\n \n         // overflow checks\n         static NANOS_PER_DAY: i64 = 86400_000_000_000;\n-        assert_eq!(Duration::days((i64::MAX / NANOS_PER_DAY) as i32).num_nanoseconds(),\n+        assert_eq!(Duration::days(i64::MAX / NANOS_PER_DAY).num_nanoseconds(),\n                    Some(i64::MAX / NANOS_PER_DAY * NANOS_PER_DAY));\n-        assert_eq!(Duration::days((i64::MIN / NANOS_PER_DAY) as i32).num_nanoseconds(),\n+        assert_eq!(Duration::days(i64::MIN / NANOS_PER_DAY).num_nanoseconds(),\n                    Some(i64::MIN / NANOS_PER_DAY * NANOS_PER_DAY));\n-        assert_eq!(Duration::days((i64::MAX / NANOS_PER_DAY + 1) as i32).num_nanoseconds(), None);\n-        assert_eq!(Duration::days((i64::MIN / NANOS_PER_DAY - 1) as i32).num_nanoseconds(), None);\n+        assert_eq!(Duration::days(i64::MAX / NANOS_PER_DAY + 1).num_nanoseconds(), None);\n+        assert_eq!(Duration::days(i64::MIN / NANOS_PER_DAY - 1).num_nanoseconds(), None);\n     }\n \n     #[test]\n     fn test_duration_checked_ops() {\n-        assert_eq!(Duration::days(MAX_DAYS).checked_add(&Duration::seconds(86399)),\n-                   Some(Duration::days(MAX_DAYS - 1) + Duration::seconds(86400+86399)));\n-        assert!(Duration::days(MAX_DAYS).checked_add(&Duration::seconds(86400)).is_none());\n+        assert_eq!(Duration::seconds(i64::MAX).checked_add(&Duration::milliseconds(999)),\n+                   Some(Duration::seconds(i64::MAX - 1) + Duration::milliseconds(1999)));\n+        assert!(Duration::seconds(i64::MAX).checked_add(&Duration::milliseconds(1000)).is_none());\n \n-        assert_eq!(Duration::days(MIN_DAYS).checked_sub(&Duration::seconds(0)),\n-                   Some(Duration::days(MIN_DAYS)));\n-        assert!(Duration::days(MIN_DAYS).checked_sub(&Duration::seconds(1)).is_none());\n+        assert_eq!(Duration::seconds(i64::MIN).checked_sub(&Duration::seconds(0)),\n+                   Some(Duration::seconds(i64::MIN)));\n+        assert!(Duration::seconds(i64::MIN).checked_sub(&Duration::seconds(1)).is_none());\n     }\n \n     #[test]\n@@ -601,6 +500,8 @@ mod tests {\n                    Duration::seconds(10) - Duration::nanoseconds(10));\n         assert_eq!((Duration::nanoseconds(1) + Duration::seconds(1) + Duration::days(1)) * 3,\n                    Duration::nanoseconds(3) + Duration::seconds(3) + Duration::days(3));\n+        assert_eq!(Duration::milliseconds(1500) * -2, Duration::seconds(-3));\n+        assert_eq!(Duration::milliseconds(-1500) * 2, Duration::seconds(-3));\n     }\n \n     #[test]\n@@ -612,6 +513,13 @@ mod tests {\n         assert_eq!(Duration::nanoseconds(123_456_789) / -1, -Duration::nanoseconds(123_456_789));\n         assert_eq!(-Duration::nanoseconds(123_456_789) / -1, Duration::nanoseconds(123_456_789));\n         assert_eq!(-Duration::nanoseconds(123_456_789) / 1, -Duration::nanoseconds(123_456_789));\n+        assert_eq!(Duration::seconds(1) / 3, Duration::nanoseconds(333_333_333));\n+        assert_eq!(Duration::seconds(4) / 3, Duration::nanoseconds(1_333_333_333));\n+        assert_eq!(Duration::seconds(-1) / 2, Duration::milliseconds(-500));\n+        assert_eq!(Duration::seconds(1) / -2, Duration::milliseconds(-500));\n+        assert_eq!(Duration::seconds(-1) / -2, Duration::milliseconds(500));\n+        assert_eq!(Duration::seconds(-4) / 3, Duration::nanoseconds(-1_333_333_333));\n+        assert_eq!(Duration::seconds(-4) / -3, Duration::nanoseconds(1_333_333_333));\n     }\n \n     #[test]"}]}