{"sha": "20b99d303d0fb70c98d8c460324c8e1824fef482", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwYjk5ZDMwM2QwZmI3MGM5OGQ4YzQ2MDMyNGM4ZTE4MjRmZWY0ODI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-16T03:54:14Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-04T20:48:51Z"}, "message": "Start importing bindings from globs as soon as the glob path is known.", "tree": {"sha": "a8b903eae5f02fcf3b1bd14b692b9d526d229a2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8b903eae5f02fcf3b1bd14b692b9d526d229a2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20b99d303d0fb70c98d8c460324c8e1824fef482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20b99d303d0fb70c98d8c460324c8e1824fef482", "html_url": "https://github.com/rust-lang/rust/commit/20b99d303d0fb70c98d8c460324c8e1824fef482", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20b99d303d0fb70c98d8c460324c8e1824fef482/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb4710ce21cb26f3caaa9d03ed0078e83018c88d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4710ce21cb26f3caaa9d03ed0078e83018c88d", "html_url": "https://github.com/rust-lang/rust/commit/fb4710ce21cb26f3caaa9d03ed0078e83018c88d"}], "stats": {"total": 360, "additions": 232, "deletions": 128}, "files": [{"sha": "2ab1d637ef934ffce9b407e9cf9fba022462ffca", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20b99d303d0fb70c98d8c460324c8e1824fef482/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b99d303d0fb70c98d8c460324c8e1824fef482/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=20b99d303d0fb70c98d8c460324c8e1824fef482", "patch": "@@ -295,14 +295,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     let module = self.new_extern_crate_module(parent_link, def, is_public, item.id);\n                     self.define(parent, name, TypeNS, (module, sp));\n \n-                    if is_public {\n-                        let export = Export { name: name, def_id: def_id };\n-                        if let Some(def_id) = parent.def_id() {\n-                            let node_id = self.resolver.ast_map.as_local_node_id(def_id).unwrap();\n-                            self.export_map.entry(node_id).or_insert(Vec::new()).push(export);\n-                        }\n-                    }\n-\n                     self.build_reduced_graph_for_external_crate(module);\n                 }\n                 parent"}, {"sha": "2a65b26cc942266c1023fa63eaa83eb55b65998b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 43, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/20b99d303d0fb70c98d8c460324c8e1824fef482/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b99d303d0fb70c98d8c460324c8e1824fef482/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=20b99d303d0fb70c98d8c460324c8e1824fef482", "patch": "@@ -18,6 +18,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(associated_consts)]\n+#![feature(borrow_state)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -832,6 +833,9 @@ pub struct ModuleS<'a> {\n \n     shadowed_traits: RefCell<Vec<&'a NameBinding<'a>>>,\n \n+    glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective)>>,\n+    resolved_globs: RefCell<(Vec<Module<'a>> /* public */, Vec<Module<'a>> /* private */)>,\n+\n     // The number of unresolved globs that this module exports.\n     glob_count: Cell<usize>,\n \n@@ -866,6 +870,8 @@ impl<'a> ModuleS<'a> {\n             unresolved_imports: RefCell::new(Vec::new()),\n             module_children: RefCell::new(NodeMap()),\n             shadowed_traits: RefCell::new(Vec::new()),\n+            glob_importers: RefCell::new(Vec::new()),\n+            resolved_globs: RefCell::new((Vec::new(), Vec::new())),\n             glob_count: Cell::new(0),\n             pub_count: Cell::new(0),\n             pub_glob_count: Cell::new(0),\n@@ -874,54 +880,11 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n-    fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n-                    -> ResolveResult<&'a NameBinding<'a>> {\n-        let glob_count =\n-            if allow_private_imports { self.glob_count.get() } else { self.pub_glob_count.get() };\n-\n-        self.resolutions.borrow().get(&(name, ns)).cloned().unwrap_or_default().result(glob_count)\n-            .and_then(|binding| {\n-                let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n-                if allowed { Success(binding) } else { Failed(None) }\n-            })\n-    }\n-\n-    // Define the name or return the existing binding if there is a collision.\n-    fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n-                        -> Result<(), &'a NameBinding<'a>> {\n-        let binding = self.arenas.alloc_name_binding(binding);\n-        let mut children = self.resolutions.borrow_mut();\n-        let resolution = children.entry((name, ns)).or_insert_with(Default::default);\n-\n-        // FIXME #31379: We can use methods from imported traits shadowed by non-import items\n-        if let Some(old_binding) = resolution.binding {\n-            if !old_binding.is_import() && binding.is_import() {\n-                if let Some(Def::Trait(_)) = binding.def() {\n-                    self.shadowed_traits.borrow_mut().push(binding);\n-                }\n-            }\n-        }\n-\n-        resolution.try_define(binding)\n-    }\n-\n     fn add_import_directive(&self, import_directive: ImportDirective) {\n         let import_directive = self.arenas.alloc_import_directive(import_directive);\n         self.unresolved_imports.borrow_mut().push(import_directive);\n     }\n \n-    fn increment_outstanding_references_for(&self, name: Name, ns: Namespace) {\n-        let mut children = self.resolutions.borrow_mut();\n-        children.entry((name, ns)).or_insert_with(Default::default).outstanding_references += 1;\n-    }\n-\n-    fn decrement_outstanding_references_for(&self, name: Name, ns: Namespace) {\n-        match self.resolutions.borrow_mut().get_mut(&(name, ns)).unwrap().outstanding_references {\n-            0 => panic!(\"No more outstanding references!\"),\n-            ref mut outstanding_references => { *outstanding_references -= 1; }\n-        }\n-    }\n-\n     fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n         for (&(name, ns), name_resolution) in self.resolutions.borrow().iter() {\n             name_resolution.binding.map(|binding| f(name, ns, binding));"}, {"sha": "226b6559e68e9a91e1b0a68484326ff506e2e8c6", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 226, "deletions": 77, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/20b99d303d0fb70c98d8c460324c8e1824fef482/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20b99d303d0fb70c98d8c460324c8e1824fef482/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=20b99d303d0fb70c98d8c460324c8e1824fef482", "patch": "@@ -125,47 +125,163 @@ impl ImportDirective {\n /// Records information about the resolution of a name in a module.\n pub struct NameResolution<'a> {\n     /// The number of unresolved single imports that could define the name.\n-    pub outstanding_references: usize,\n+    outstanding_references: usize,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n+    duplicate_globs: Vec<&'a NameBinding<'a>>,\n }\n \n impl<'a> NameResolution<'a> {\n-    pub fn result(&self, outstanding_globs: usize) -> ResolveResult<&'a NameBinding<'a>> {\n-        // If no unresolved imports (single or glob) can define the name, self.binding is final.\n-        if self.outstanding_references == 0 && outstanding_globs == 0 {\n-            return self.binding.map(Success).unwrap_or(Failed(None));\n-        }\n-\n-        if let Some(binding) = self.binding {\n-            // Single imports will never be shadowable by other single or glob imports.\n-            if !binding.defined_with(DefModifiers::GLOB_IMPORTED) { return Success(binding); }\n-            // Non-PRELUDE glob imports will never be shadowable by other glob imports.\n-            if self.outstanding_references == 0 && !binding.defined_with(DefModifiers::PRELUDE) {\n-                return Success(binding);\n+    fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n+        match self.binding {\n+            Some(old_binding) if !old_binding.defined_with(DefModifiers::PRELUDE) => {\n+                if binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+                    self.duplicate_globs.push(binding);\n+                } else if old_binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+                    self.duplicate_globs.push(old_binding);\n+                    self.binding = Some(binding);\n+                } else {\n+                    return Err(old_binding);\n+                }\n             }\n+            _ => self.binding = Some(binding),\n         }\n \n-        Indeterminate\n+        Ok(())\n     }\n \n-    // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n-        let is_prelude = |binding: &NameBinding| binding.defined_with(DefModifiers::PRELUDE);\n-        let old_binding = match self.binding {\n-            Some(_) if is_prelude(binding) => return Ok(()),\n-            Some(old_binding) if !is_prelude(old_binding) => old_binding,\n-            _ => { self.binding = Some(binding); return Ok(()); }\n+    // Returns the resolution of the name assuming no more globs will define it.\n+    fn result(&self) -> ResolveResult<&'a NameBinding<'a>> {\n+        match self.binding {\n+            Some(binding) if !binding.defined_with(DefModifiers::GLOB_IMPORTED) => Success(binding),\n+            _ if self.outstanding_references > 0 => Indeterminate,\n+            Some(binding) => Success(binding),\n+            None => Failed(None),\n+        }\n+    }\n+\n+    // Returns Some(the resolution of the name), or None if the resolution depends\n+    // on whether more globs can define the name.\n+    fn try_result(&self) -> Option<ResolveResult<&'a NameBinding<'a>>> {\n+        match self.result() {\n+            Success(binding) if binding.defined_with(DefModifiers::PRELUDE) => None,\n+            Failed(_) => None,\n+            result @ _ => Some(result),\n+        }\n+    }\n+\n+    fn report_conflicts<F: FnMut(&NameBinding, &NameBinding)>(&self, mut report: F) {\n+        let binding = match self.binding {\n+            Some(binding) => binding,\n+            None => return,\n         };\n \n-        // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n-        if !old_binding.is_import() && binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n-            if let NameBindingKind::Import { binding, .. } = binding.kind {\n-                if binding.is_import() { return Ok(()); }\n+        for duplicate_glob in self.duplicate_globs.iter() {\n+            if duplicate_glob.defined_with(DefModifiers::PRELUDE) { continue }\n+\n+            // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n+            if !binding.is_import() {\n+                if let NameBindingKind::Import { binding, .. } = duplicate_glob.kind {\n+                    if binding.is_import() { continue }\n+                }\n+            }\n+\n+            report(duplicate_glob, binding);\n+        }\n+    }\n+}\n+\n+impl<'a> ::ModuleS<'a> {\n+    pub fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n+                        -> ResolveResult<&'a NameBinding<'a>> {\n+        let resolutions = match self.resolutions.borrow_state() {\n+            ::std::cell::BorrowState::Unused => self.resolutions.borrow(),\n+            _ => return Failed(None), // This happens when there is a cycle of glob imports\n+        };\n+\n+        let resolution = resolutions.get(&(name, ns)).cloned().unwrap_or_default();\n+        if let Some(result) = resolution.try_result() {\n+            // If the resolution doesn't depend on glob definability, check privacy and return.\n+            return result.and_then(|binding| {\n+                let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n+                if allowed { Success(binding) } else { Failed(None) }\n+            });\n+        }\n+\n+        let (ref mut public_globs, ref mut private_globs) = *self.resolved_globs.borrow_mut();\n+\n+        // Check if the public globs are determined\n+        if self.pub_glob_count.get() > 0 {\n+            return Indeterminate;\n+        }\n+        for module in public_globs.iter() {\n+            if let Indeterminate = module.resolve_name(name, ns, false) {\n+                return Indeterminate;\n+            }\n+        }\n+\n+        if !allow_private_imports {\n+            return Failed(None);\n+        }\n+\n+        // Check if the private globs are determined\n+        if self.glob_count.get() > 0 {\n+            return Indeterminate;\n+        }\n+        for module in private_globs.iter() {\n+            if let Indeterminate = module.resolve_name(name, ns, false) {\n+                return Indeterminate;\n+            }\n+        }\n+\n+        resolution.result()\n+    }\n+\n+    // Define the name or return the existing binding if there is a collision.\n+    pub fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n+                            -> Result<(), &'a NameBinding<'a>> {\n+        if self.resolutions.borrow_state() != ::std::cell::BorrowState::Unused { return Ok(()); }\n+        self.update_resolution(name, ns, |resolution| {\n+            resolution.try_define(self.arenas.alloc_name_binding(binding))\n+        })\n+    }\n+\n+    pub fn increment_outstanding_references_for(&self, name: Name, ns: Namespace) {\n+        let mut resolutions = self.resolutions.borrow_mut();\n+        resolutions.entry((name, ns)).or_insert_with(Default::default).outstanding_references += 1;\n+    }\n+\n+    fn decrement_outstanding_references_for(&self, name: Name, ns: Namespace) {\n+        self.update_resolution(name, ns, |resolution| match resolution.outstanding_references {\n+            0 => panic!(\"No more outstanding references!\"),\n+            ref mut outstanding_references => *outstanding_references -= 1,\n+        })\n+    }\n+\n+    // Use `update` to mutate the resolution for the name.\n+    // If the resolution becomes a success, define it in the module's glob importers.\n+    fn update_resolution<T, F>(&self, name: Name, ns: Namespace, update: F) -> T\n+        where F: FnOnce(&mut NameResolution<'a>) -> T\n+    {\n+        let mut resolutions = self.resolutions.borrow_mut();\n+        let resolution = resolutions.entry((name, ns)).or_insert_with(Default::default);\n+        let was_success = resolution.try_result().and_then(ResolveResult::success).is_some();\n+\n+        let t = update(resolution);\n+        if !was_success {\n+            if let Some(Success(binding)) = resolution.try_result() {\n+                self.define_in_glob_importers(name, ns, binding);\n             }\n         }\n+        t\n+    }\n \n-        Err(old_binding)\n+    fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n+        if !binding.defined_with(DefModifiers::PUBLIC | DefModifiers::IMPORTABLE) { return }\n+        if binding.is_extern_crate() { return }\n+        for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n+            let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n+        }\n     }\n }\n \n@@ -206,11 +322,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             if self.resolver.unresolved_imports == 0 {\n                 debug!(\"(resolving imports) success\");\n+                self.finalize_resolutions(self.resolver.graph_root);\n                 break;\n             }\n \n             if self.resolver.unresolved_imports == prev_unresolved_imports {\n                 // resolving failed\n+                self.finalize_resolutions(self.resolver.graph_root);\n                 if errors.len() > 0 {\n                     for e in errors {\n                         self.import_resolving_error(e)\n@@ -306,7 +424,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import_for_module(&mut self,\n                                  module_: Module<'b>,\n-                                 import_directive: &ImportDirective)\n+                                 import_directive: &'b ImportDirective)\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&import_directive.module_path),\n@@ -343,7 +461,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     fn resolve_import(&mut self,\n                       module_: Module<'b>,\n                       target_module: Module<'b>,\n-                      directive: &ImportDirective)\n+                      directive: &'b ImportDirective)\n                       -> ResolveResult<()> {\n         let (source, target, value_determined, type_determined) = match directive.subclass {\n             SingleImport { source, target, ref value_determined, ref type_determined } =>\n@@ -418,32 +536,24 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success(name_binding)) if !name_binding.is_import() && directive.is_public => {\n-                if !name_binding.is_public() {\n-                    if name_binding.is_extern_crate() {\n-                        let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n-                                           (error E0364), consider declaring with `pub`\",\n-                                           source);\n-                        self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                                       directive.id,\n-                                                       directive.span,\n-                                                       msg);\n-                    } else {\n-                        let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n-                        let note_msg =\n-                            format!(\"consider declaring type or module `{}` with `pub`\", source);\n-                        struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n-                            .span_note(directive.span, &note_msg)\n-                            .emit();\n-                    }\n-                } else if name_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n-                    let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n-                                       (error E0364), consider declaring its enum as `pub`\",\n+            (_, &Success(name_binding)) if !name_binding.is_import() &&\n+                                           directive.is_public &&\n+                                           !name_binding.is_public() => {\n+                if name_binding.is_extern_crate() {\n+                    let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n+                                       (error E0364), consider declaring with `pub`\",\n                                        source);\n                     self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n                                                    directive.id,\n                                                    directive.span,\n                                                    msg);\n+                } else {\n+                    let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n+                    let note_msg =\n+                        format!(\"consider declaring type or module `{}` with `pub`\", source);\n+                    struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n+                        .span_note(directive.span, &note_msg)\n+                        .emit();\n                 }\n             }\n \n@@ -484,36 +594,29 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     fn resolve_glob_import(&mut self,\n                            module_: Module<'b>,\n                            target_module: Module<'b>,\n-                           directive: &ImportDirective)\n+                           directive: &'b ImportDirective)\n                            -> ResolveResult<()> {\n-        // We must bail out if the node has unresolved imports of any kind (including globs).\n-        if target_module.pub_count.get() > 0 {\n-            debug!(\"(resolving glob import) target module has unresolved pub imports; bailing out\");\n-            return Indeterminate;\n-        }\n-\n         if module_.def_id() == target_module.def_id() {\n             // This means we are trying to glob import a module into itself, and it is a no-go\n             let msg = \"Cannot glob-import a module into itself.\".into();\n             return Failed(Some((directive.span, msg)));\n         }\n-\n-        // Add all children from the containing module.\n         build_reduced_graph::populate_module_if_necessary(self.resolver, target_module);\n-        target_module.for_each_child(|name, ns, binding| {\n-            if !binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) { return }\n-            self.define(module_, name, ns, directive.import(binding, None));\n-\n-            if ns == TypeNS && directive.is_public &&\n-               binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n-                let msg = format!(\"variant `{}` is private, and cannot be reexported (error \\\n-                                   E0364), consider declaring its enum as `pub`\", name);\n-                self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                               directive.id,\n-                                               directive.span,\n-                                               msg);\n+\n+        // Add to target_module's glob_importers and module_'s resolved_globs\n+        target_module.glob_importers.borrow_mut().push((module_, directive));\n+        match *module_.resolved_globs.borrow_mut() {\n+            (ref mut public_globs, _) if directive.is_public => public_globs.push(target_module),\n+            (_, ref mut private_globs) => private_globs.push(target_module),\n+        }\n+\n+        for (&(name, ns), resolution) in target_module.resolutions.borrow().iter() {\n+            if let Some(Success(binding)) = resolution.try_result() {\n+                if binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) {\n+                    self.define(module_, name, ns, directive.import(binding, None));\n+                }\n             }\n-        });\n+        }\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n@@ -535,12 +638,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n               binding: NameBinding<'b>) {\n         if let Err(old_binding) = parent.try_define_child(name, ns, binding.clone()) {\n             self.report_conflict(name, ns, &binding, old_binding);\n-        } else if binding.is_public() { // Add to the export map\n-            if let (Some(parent_def_id), Some(def)) = (parent.def_id(), binding.def()) {\n-                let parent_node_id = self.resolver.ast_map.as_local_node_id(parent_def_id).unwrap();\n-                let export = Export { name: name, def_id: def.def_id() };\n-                self.resolver.export_map.entry(parent_node_id).or_insert(Vec::new()).push(export);\n-            }\n         }\n     }\n \n@@ -604,6 +701,58 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             err.emit();\n         }\n     }\n+\n+    // Miscellaneous post-processing, including recording reexports, recording shadowed traits,\n+    // reporting conflicts, and reporting the PRIVATE_IN_PUBLIC lint.\n+    fn finalize_resolutions(&mut self, module: Module<'b>) {\n+        // Since import resolution is finished, globs will not define any more names.\n+        module.pub_glob_count.set(0); module.glob_count.set(0);\n+        *module.resolved_globs.borrow_mut() = (Vec::new(), Vec::new());\n+\n+        let mut reexports = Vec::new();\n+        for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n+            resolution.report_conflicts(|b1, b2| self.report_conflict(name, ns, b1, b2));\n+            let binding = match resolution.binding {\n+                Some(binding) => binding,\n+                None => continue,\n+            };\n+\n+            if binding.is_public() && (binding.is_import() || binding.is_extern_crate()) {\n+                if let Some(def) = binding.def() {\n+                    reexports.push(Export { name: name, def_id: def.def_id() });\n+                }\n+            }\n+\n+            if let NameBindingKind::Import { binding: orig_binding, id, .. } = binding.kind {\n+                if ns == TypeNS && binding.is_public() &&\n+                   orig_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n+                    let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n+                                       (error E0364), consider declaring its enum as `pub`\",\n+                                      name);\n+                    let lint = lint::builtin::PRIVATE_IN_PUBLIC;\n+                    self.resolver.session.add_lint(lint, id, binding.span.unwrap(), msg);\n+                }\n+            }\n+\n+            // FIXME #31379: We can use methods from imported traits shadowed by non-import items\n+            if !binding.is_import() {\n+                for glob_binding in resolution.duplicate_globs.iter() {\n+                    module.shadowed_traits.borrow_mut().push(glob_binding);\n+                }\n+            }\n+        }\n+\n+        if reexports.len() > 0 {\n+            if let Some(def_id) = module.def_id() {\n+                let node_id = self.resolver.ast_map.as_local_node_id(def_id).unwrap();\n+                self.resolver.export_map.insert(node_id, reexports);\n+            }\n+        }\n+\n+        for (_, child) in module.module_children.borrow().iter() {\n+            self.finalize_resolutions(child);\n+        }\n+    }\n }\n \n fn import_path_to_string(names: &[Name], subclass: &ImportDirectiveSubclass) -> String {"}]}