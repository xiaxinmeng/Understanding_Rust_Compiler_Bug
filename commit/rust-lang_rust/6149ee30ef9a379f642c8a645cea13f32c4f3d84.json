{"sha": "6149ee30ef9a379f642c8a645cea13f32c4f3d84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNDllZTMwZWY5YTM3OWY2NDJjOGE2NDVjZWExM2YzMmM0ZjNkODQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-12T12:41:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-12T12:41:55Z"}, "message": "Merge #2221\n\n2221: Disallow regressing crate docs r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "5e62cbb2356383b36a36ae717a99f628580da60c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e62cbb2356383b36a36ae717a99f628580da60c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6149ee30ef9a379f642c8a645cea13f32c4f3d84", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdyqiTCRBK7hj4Ov3rIwAAdHIIAALQaXgymZLAWkRSgQyQ+VDZ\niLKeiFw8msbpl8WeFzDoh+x9j3WOR49wVfyai2c0okNfJaE4Ads8BlIsUW9nqsfy\nVGmPObL8oRMvr8L2XRgqhOX8ySh+uiBspBtfDQ2R3ru299BEy90i8tgjRqpa4xJ6\nJsMnh4lrJt4yMqQAy5RHr8ZFs1rSl+GMjYQL7iuXVekl6UxyxSWq3O1BQRMLJbHe\nUleelvVk1n7UP1qyeV4xV2/KODglUK8tf1ybl+DpG5AKM3sOAke4b4H5S7j9zg86\nphKg/Zl3w1Ijgr2EDODy1PcvGXwTDuuomcOk5wIGpEMxkb0Z7iCoojVb5RNDDQg=\n=Oq4L\n-----END PGP SIGNATURE-----\n", "payload": "tree 5e62cbb2356383b36a36ae717a99f628580da60c\nparent f5e1b0f97c9e46b5186f99d744f4587b2aee397e\nparent 30bf7e43db2667470875ea4477a95aa297896851\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573562515 +0000\ncommitter GitHub <noreply@github.com> 1573562515 +0000\n\nMerge #2221\n\n2221: Disallow regressing crate docs r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6149ee30ef9a379f642c8a645cea13f32c4f3d84", "html_url": "https://github.com/rust-lang/rust/commit/6149ee30ef9a379f642c8a645cea13f32c4f3d84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6149ee30ef9a379f642c8a645cea13f32c4f3d84/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5e1b0f97c9e46b5186f99d744f4587b2aee397e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5e1b0f97c9e46b5186f99d744f4587b2aee397e", "html_url": "https://github.com/rust-lang/rust/commit/f5e1b0f97c9e46b5186f99d744f4587b2aee397e"}, {"sha": "30bf7e43db2667470875ea4477a95aa297896851", "url": "https://api.github.com/repos/rust-lang/rust/commits/30bf7e43db2667470875ea4477a95aa297896851", "html_url": "https://github.com/rust-lang/rust/commit/30bf7e43db2667470875ea4477a95aa297896851"}], "stats": {"total": 1175, "additions": 647, "deletions": 528}, "files": [{"sha": "51d953f6e896a7c34f2172ac4cfd731692a629e2", "filename": "crates/ra_cfg/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_cfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_cfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Flib.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -1,11 +1,12 @@\n //! ra_cfg defines conditional compiling options, `cfg` attibute parser and evaluator\n+\n+mod cfg_expr;\n+\n use std::iter::IntoIterator;\n \n use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n-mod cfg_expr;\n-\n pub use cfg_expr::{parse_cfg, CfgExpr};\n \n /// Configuration options used for conditional compilition on items with `cfg` attributes."}, {"sha": "a30ed4cbb863ea052a2a39392a215f12e823774e", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -1,13 +1,14 @@\n //! This crate provides some utilities for indenting rust code.\n-//!\n+\n+use std::iter::successors;\n+\n use itertools::Itertools;\n use ra_syntax::{\n     ast::{self, AstNode, AstToken},\n     SmolStr, SyntaxKind,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, T,\n };\n-use std::iter::successors;\n \n pub fn reindent(text: &str, indent: &str) -> String {\n     let indent = format!(\"\\n{}\", indent);"}, {"sha": "dd2bae9b4fb48b9ad6a1c83422a5b599abe395f0", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 6, "deletions": 402, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -6,29 +6,18 @@ pub(crate) mod validation;\n \n use std::{ops::Index, sync::Arc};\n \n-use hir_def::{\n-    path::GenericArgs,\n-    type_ref::{Mutability, TypeRef},\n-};\n-use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n+use ra_arena::{map::ArenaMap, Arena};\n use ra_syntax::{ast, AstPtr};\n use rustc_hash::FxHashMap;\n \n-use crate::{\n-    db::HirDatabase,\n-    ty::primitive::{UncertainFloatTy, UncertainIntTy},\n-    DefWithBody, Either, HasSource, Name, Path, Resolver, Source,\n-};\n+use crate::{db::HirDatabase, DefWithBody, Either, HasSource, Resolver, Source};\n \n pub use self::scope::ExprScopes;\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ExprId(RawId);\n-impl_arena_id!(ExprId);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct PatId(RawId);\n-impl_arena_id!(PatId);\n+pub use hir_def::expr::{\n+    ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp, MatchArm,\n+    Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n+};\n \n /// The body of an item (function, const etc.).\n #[derive(Debug, Eq, PartialEq)]\n@@ -187,388 +176,3 @@ impl BodySourceMap {\n         self.field_map[&(expr, field)]\n     }\n }\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum Literal {\n-    String(String),\n-    ByteString(Vec<u8>),\n-    Char(char),\n-    Bool(bool),\n-    Int(u64, UncertainIntTy),\n-    Float(u64, UncertainFloatTy), // FIXME: f64 is not Eq\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum Expr {\n-    /// This is produced if syntax tree does not have a required expression piece.\n-    Missing,\n-    Path(Path),\n-    If {\n-        condition: ExprId,\n-        then_branch: ExprId,\n-        else_branch: Option<ExprId>,\n-    },\n-    Block {\n-        statements: Vec<Statement>,\n-        tail: Option<ExprId>,\n-    },\n-    Loop {\n-        body: ExprId,\n-    },\n-    While {\n-        condition: ExprId,\n-        body: ExprId,\n-    },\n-    For {\n-        iterable: ExprId,\n-        pat: PatId,\n-        body: ExprId,\n-    },\n-    Call {\n-        callee: ExprId,\n-        args: Vec<ExprId>,\n-    },\n-    MethodCall {\n-        receiver: ExprId,\n-        method_name: Name,\n-        args: Vec<ExprId>,\n-        generic_args: Option<GenericArgs>,\n-    },\n-    Match {\n-        expr: ExprId,\n-        arms: Vec<MatchArm>,\n-    },\n-    Continue,\n-    Break {\n-        expr: Option<ExprId>,\n-    },\n-    Return {\n-        expr: Option<ExprId>,\n-    },\n-    RecordLit {\n-        path: Option<Path>,\n-        fields: Vec<RecordLitField>,\n-        spread: Option<ExprId>,\n-    },\n-    Field {\n-        expr: ExprId,\n-        name: Name,\n-    },\n-    Await {\n-        expr: ExprId,\n-    },\n-    Try {\n-        expr: ExprId,\n-    },\n-    TryBlock {\n-        body: ExprId,\n-    },\n-    Cast {\n-        expr: ExprId,\n-        type_ref: TypeRef,\n-    },\n-    Ref {\n-        expr: ExprId,\n-        mutability: Mutability,\n-    },\n-    Box {\n-        expr: ExprId,\n-    },\n-    UnaryOp {\n-        expr: ExprId,\n-        op: UnaryOp,\n-    },\n-    BinaryOp {\n-        lhs: ExprId,\n-        rhs: ExprId,\n-        op: Option<BinaryOp>,\n-    },\n-    Index {\n-        base: ExprId,\n-        index: ExprId,\n-    },\n-    Lambda {\n-        args: Vec<PatId>,\n-        arg_types: Vec<Option<TypeRef>>,\n-        body: ExprId,\n-    },\n-    Tuple {\n-        exprs: Vec<ExprId>,\n-    },\n-    Array(Array),\n-    Literal(Literal),\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum BinaryOp {\n-    LogicOp(LogicOp),\n-    ArithOp(ArithOp),\n-    CmpOp(CmpOp),\n-    Assignment { op: Option<ArithOp> },\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum LogicOp {\n-    And,\n-    Or,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum CmpOp {\n-    Eq { negated: bool },\n-    Ord { ordering: Ordering, strict: bool },\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum Ordering {\n-    Less,\n-    Greater,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ArithOp {\n-    Add,\n-    Mul,\n-    Sub,\n-    Div,\n-    Rem,\n-    Shl,\n-    Shr,\n-    BitXor,\n-    BitOr,\n-    BitAnd,\n-}\n-\n-pub use ra_syntax::ast::PrefixOp as UnaryOp;\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum Array {\n-    ElementList(Vec<ExprId>),\n-    Repeat { initializer: ExprId, repeat: ExprId },\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct MatchArm {\n-    pub pats: Vec<PatId>,\n-    pub guard: Option<ExprId>,\n-    pub expr: ExprId,\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct RecordLitField {\n-    pub name: Name,\n-    pub expr: ExprId,\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum Statement {\n-    Let { pat: PatId, type_ref: Option<TypeRef>, initializer: Option<ExprId> },\n-    Expr(ExprId),\n-}\n-\n-impl Expr {\n-    pub fn walk_child_exprs(&self, mut f: impl FnMut(ExprId)) {\n-        match self {\n-            Expr::Missing => {}\n-            Expr::Path(_) => {}\n-            Expr::If { condition, then_branch, else_branch } => {\n-                f(*condition);\n-                f(*then_branch);\n-                if let Some(else_branch) = else_branch {\n-                    f(*else_branch);\n-                }\n-            }\n-            Expr::Block { statements, tail } => {\n-                for stmt in statements {\n-                    match stmt {\n-                        Statement::Let { initializer, .. } => {\n-                            if let Some(expr) = initializer {\n-                                f(*expr);\n-                            }\n-                        }\n-                        Statement::Expr(e) => f(*e),\n-                    }\n-                }\n-                if let Some(expr) = tail {\n-                    f(*expr);\n-                }\n-            }\n-            Expr::TryBlock { body } => f(*body),\n-            Expr::Loop { body } => f(*body),\n-            Expr::While { condition, body } => {\n-                f(*condition);\n-                f(*body);\n-            }\n-            Expr::For { iterable, body, .. } => {\n-                f(*iterable);\n-                f(*body);\n-            }\n-            Expr::Call { callee, args } => {\n-                f(*callee);\n-                for arg in args {\n-                    f(*arg);\n-                }\n-            }\n-            Expr::MethodCall { receiver, args, .. } => {\n-                f(*receiver);\n-                for arg in args {\n-                    f(*arg);\n-                }\n-            }\n-            Expr::Match { expr, arms } => {\n-                f(*expr);\n-                for arm in arms {\n-                    f(arm.expr);\n-                }\n-            }\n-            Expr::Continue => {}\n-            Expr::Break { expr } | Expr::Return { expr } => {\n-                if let Some(expr) = expr {\n-                    f(*expr);\n-                }\n-            }\n-            Expr::RecordLit { fields, spread, .. } => {\n-                for field in fields {\n-                    f(field.expr);\n-                }\n-                if let Some(expr) = spread {\n-                    f(*expr);\n-                }\n-            }\n-            Expr::Lambda { body, .. } => {\n-                f(*body);\n-            }\n-            Expr::BinaryOp { lhs, rhs, .. } => {\n-                f(*lhs);\n-                f(*rhs);\n-            }\n-            Expr::Index { base, index } => {\n-                f(*base);\n-                f(*index);\n-            }\n-            Expr::Field { expr, .. }\n-            | Expr::Await { expr }\n-            | Expr::Try { expr }\n-            | Expr::Cast { expr, .. }\n-            | Expr::Ref { expr, .. }\n-            | Expr::UnaryOp { expr, .. }\n-            | Expr::Box { expr } => {\n-                f(*expr);\n-            }\n-            Expr::Tuple { exprs } => {\n-                for expr in exprs {\n-                    f(*expr);\n-                }\n-            }\n-            Expr::Array(a) => match a {\n-                Array::ElementList(exprs) => {\n-                    for expr in exprs {\n-                        f(*expr);\n-                    }\n-                }\n-                Array::Repeat { initializer, repeat } => {\n-                    f(*initializer);\n-                    f(*repeat)\n-                }\n-            },\n-            Expr::Literal(_) => {}\n-        }\n-    }\n-}\n-\n-/// Explicit binding annotations given in the HIR for a binding. Note\n-/// that this is not the final binding *mode* that we infer after type\n-/// inference.\n-#[derive(Clone, PartialEq, Eq, Debug, Copy)]\n-pub enum BindingAnnotation {\n-    /// No binding annotation given: this means that the final binding mode\n-    /// will depend on whether we have skipped through a `&` reference\n-    /// when matching. For example, the `x` in `Some(x)` will have binding\n-    /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n-    /// ultimately be inferred to be by-reference.\n-    Unannotated,\n-\n-    /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n-    Mutable,\n-\n-    /// Annotated as `ref`, like `ref x`\n-    Ref,\n-\n-    /// Annotated as `ref mut x`.\n-    RefMut,\n-}\n-\n-impl BindingAnnotation {\n-    fn new(is_mutable: bool, is_ref: bool) -> Self {\n-        match (is_mutable, is_ref) {\n-            (true, true) => BindingAnnotation::RefMut,\n-            (false, true) => BindingAnnotation::Ref,\n-            (true, false) => BindingAnnotation::Mutable,\n-            (false, false) => BindingAnnotation::Unannotated,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct RecordFieldPat {\n-    pub(crate) name: Name,\n-    pub(crate) pat: PatId,\n-}\n-\n-/// Close relative to rustc's hir::PatKind\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum Pat {\n-    Missing,\n-    Wild,\n-    Tuple(Vec<PatId>),\n-    Record {\n-        path: Option<Path>,\n-        args: Vec<RecordFieldPat>,\n-        // FIXME: 'ellipsis' option\n-    },\n-    Range {\n-        start: ExprId,\n-        end: ExprId,\n-    },\n-    Slice {\n-        prefix: Vec<PatId>,\n-        rest: Option<PatId>,\n-        suffix: Vec<PatId>,\n-    },\n-    Path(Path),\n-    Lit(ExprId),\n-    Bind {\n-        mode: BindingAnnotation,\n-        name: Name,\n-        subpat: Option<PatId>,\n-    },\n-    TupleStruct {\n-        path: Option<Path>,\n-        args: Vec<PatId>,\n-    },\n-    Ref {\n-        pat: PatId,\n-        mutability: Mutability,\n-    },\n-}\n-\n-impl Pat {\n-    pub fn walk_child_pats(&self, mut f: impl FnMut(PatId)) {\n-        match self {\n-            Pat::Range { .. } | Pat::Lit(..) | Pat::Path(..) | Pat::Wild | Pat::Missing => {}\n-            Pat::Bind { subpat, .. } => {\n-                subpat.iter().copied().for_each(f);\n-            }\n-            Pat::Tuple(args) | Pat::TupleStruct { args, .. } => {\n-                args.iter().copied().for_each(f);\n-            }\n-            Pat::Ref { pat, .. } => f(*pat),\n-            Pat::Slice { prefix, rest, suffix } => {\n-                let total_iter = prefix.iter().chain(rest.iter()).chain(suffix.iter());\n-                total_iter.copied().for_each(f);\n-            }\n-            Pat::Record { args, .. } => {\n-                args.iter().map(|f| f.pat).for_each(f);\n-            }\n-        }\n-    }\n-}"}, {"sha": "7b0bfd9199907c98b062d37440c31bd6638a5ba8", "filename": "crates/ra_hir/src/expr/lower.rs", "status": "modified", "additions": 15, "deletions": 67, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -1,6 +1,10 @@\n //! FIXME: write short doc here\n \n-use hir_def::{path::GenericArgs, type_ref::TypeRef};\n+use hir_def::{\n+    builtin_type::{BuiltinFloat, BuiltinInt},\n+    path::GenericArgs,\n+    type_ref::TypeRef,\n+};\n use hir_expand::{\n     hygiene::Hygiene,\n     name::{self, AsName, Name},\n@@ -16,15 +20,13 @@ use ra_syntax::{\n use test_utils::tested_by;\n \n use crate::{\n-    db::HirDatabase,\n-    ty::primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n-    AstId, DefWithBody, Either, HirFileId, MacroCallLoc, MacroFileKind, Mutability, Path, Resolver,\n-    Source,\n+    db::HirDatabase, AstId, DefWithBody, Either, HirFileId, MacroCallLoc, MacroFileKind,\n+    Mutability, Path, Resolver, Source,\n };\n \n use super::{\n-    ArithOp, Array, BinaryOp, BindingAnnotation, Body, BodySourceMap, CmpOp, Expr, ExprId, Literal,\n-    LogicOp, MatchArm, Ordering, Pat, PatId, PatPtr, RecordFieldPat, RecordLitField, Statement,\n+    Array, BinaryOp, BindingAnnotation, Body, BodySourceMap, Expr, ExprId, Literal, MatchArm, Pat,\n+    PatId, PatPtr, RecordFieldPat, RecordLitField, Statement,\n };\n \n pub(super) fn lower(\n@@ -46,7 +48,7 @@ pub(super) fn lower(\n             exprs: Arena::default(),\n             pats: Arena::default(),\n             params: Vec::new(),\n-            body_expr: ExprId((!0).into()),\n+            body_expr: ExprId::dummy(),\n         },\n     }\n     .collect(params, body)\n@@ -423,28 +425,18 @@ where\n             ast::Expr::Literal(e) => {\n                 let lit = match e.kind() {\n                     LiteralKind::IntNumber { suffix } => {\n-                        let known_name = suffix\n-                            .and_then(|it| IntTy::from_suffix(&it).map(UncertainIntTy::Known));\n+                        let known_name = suffix.and_then(|it| BuiltinInt::from_suffix(&it));\n \n-                        Literal::Int(\n-                            Default::default(),\n-                            known_name.unwrap_or(UncertainIntTy::Unknown),\n-                        )\n+                        Literal::Int(Default::default(), known_name)\n                     }\n                     LiteralKind::FloatNumber { suffix } => {\n-                        let known_name = suffix\n-                            .and_then(|it| FloatTy::from_suffix(&it).map(UncertainFloatTy::Known));\n+                        let known_name = suffix.and_then(|it| BuiltinFloat::from_suffix(&it));\n \n-                        Literal::Float(\n-                            Default::default(),\n-                            known_name.unwrap_or(UncertainFloatTy::Unknown),\n-                        )\n+                        Literal::Float(Default::default(), known_name)\n                     }\n                     LiteralKind::ByteString => Literal::ByteString(Default::default()),\n                     LiteralKind::String => Literal::String(Default::default()),\n-                    LiteralKind::Byte => {\n-                        Literal::Int(Default::default(), UncertainIntTy::Known(IntTy::u8()))\n-                    }\n+                    LiteralKind::Byte => Literal::Int(Default::default(), Some(BuiltinInt::U8)),\n                     LiteralKind::Bool => Literal::Bool(Default::default()),\n                     LiteralKind::Char => Literal::Char(Default::default()),\n                 };\n@@ -601,47 +593,3 @@ where\n         Path::from_src(path, &hygiene)\n     }\n }\n-\n-impl From<ast::BinOp> for BinaryOp {\n-    fn from(ast_op: ast::BinOp) -> Self {\n-        match ast_op {\n-            ast::BinOp::BooleanOr => BinaryOp::LogicOp(LogicOp::Or),\n-            ast::BinOp::BooleanAnd => BinaryOp::LogicOp(LogicOp::And),\n-            ast::BinOp::EqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n-            ast::BinOp::NegatedEqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: true }),\n-            ast::BinOp::LesserEqualTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: false })\n-            }\n-            ast::BinOp::GreaterEqualTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: false })\n-            }\n-            ast::BinOp::LesserTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: true })\n-            }\n-            ast::BinOp::GreaterTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: true })\n-            }\n-            ast::BinOp::Addition => BinaryOp::ArithOp(ArithOp::Add),\n-            ast::BinOp::Multiplication => BinaryOp::ArithOp(ArithOp::Mul),\n-            ast::BinOp::Subtraction => BinaryOp::ArithOp(ArithOp::Sub),\n-            ast::BinOp::Division => BinaryOp::ArithOp(ArithOp::Div),\n-            ast::BinOp::Remainder => BinaryOp::ArithOp(ArithOp::Rem),\n-            ast::BinOp::LeftShift => BinaryOp::ArithOp(ArithOp::Shl),\n-            ast::BinOp::RightShift => BinaryOp::ArithOp(ArithOp::Shr),\n-            ast::BinOp::BitwiseXor => BinaryOp::ArithOp(ArithOp::BitXor),\n-            ast::BinOp::BitwiseOr => BinaryOp::ArithOp(ArithOp::BitOr),\n-            ast::BinOp::BitwiseAnd => BinaryOp::ArithOp(ArithOp::BitAnd),\n-            ast::BinOp::Assignment => BinaryOp::Assignment { op: None },\n-            ast::BinOp::AddAssign => BinaryOp::Assignment { op: Some(ArithOp::Add) },\n-            ast::BinOp::DivAssign => BinaryOp::Assignment { op: Some(ArithOp::Div) },\n-            ast::BinOp::MulAssign => BinaryOp::Assignment { op: Some(ArithOp::Mul) },\n-            ast::BinOp::RemAssign => BinaryOp::Assignment { op: Some(ArithOp::Rem) },\n-            ast::BinOp::ShlAssign => BinaryOp::Assignment { op: Some(ArithOp::Shl) },\n-            ast::BinOp::ShrAssign => BinaryOp::Assignment { op: Some(ArithOp::Shr) },\n-            ast::BinOp::SubAssign => BinaryOp::Assignment { op: Some(ArithOp::Sub) },\n-            ast::BinOp::BitOrAssign => BinaryOp::Assignment { op: Some(ArithOp::BitOr) },\n-            ast::BinOp::BitAndAssign => BinaryOp::Assignment { op: Some(ArithOp::BitAnd) },\n-            ast::BinOp::BitXorAssign => BinaryOp::Assignment { op: Some(ArithOp::BitXor) },\n-        }\n-    }\n-}"}, {"sha": "6d97923916dc575d914a2bd3820f4d2377ca41bb", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -452,8 +452,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     Ty::apply_one(TypeCtor::Ref(Mutability::Shared), slice_type)\n                 }\n                 Literal::Char(..) => Ty::simple(TypeCtor::Char),\n-                Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int(*ty)),\n-                Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float(*ty)),\n+                Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int((*ty).into())),\n+                Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float((*ty).into())),\n             },\n         };\n         // use a new type variable if we got Ty::Unknown here"}, {"sha": "1832fcf5042e53edfec18dc7f9f8fb4a29dc582e", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -25,7 +25,7 @@ use crate::{\n     generics::{GenericDef, WherePredicate},\n     resolve::{Resolver, TypeNs},\n     ty::{\n-        primitive::{FloatTy, IntTy},\n+        primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n         Adt,\n     },\n     util::make_mut_slice,\n@@ -657,13 +657,41 @@ fn type_for_builtin(def: BuiltinType) -> Ty {\n         BuiltinType::Char => TypeCtor::Char,\n         BuiltinType::Bool => TypeCtor::Bool,\n         BuiltinType::Str => TypeCtor::Str,\n-        BuiltinType::Int(BuiltinInt { signedness, bitness }) => {\n-            TypeCtor::Int(IntTy { signedness, bitness }.into())\n-        }\n-        BuiltinType::Float(BuiltinFloat { bitness }) => TypeCtor::Float(FloatTy { bitness }.into()),\n+        BuiltinType::Int(t) => TypeCtor::Int(IntTy::from(t).into()),\n+        BuiltinType::Float(t) => TypeCtor::Float(FloatTy::from(t).into()),\n     })\n }\n \n+impl From<BuiltinInt> for IntTy {\n+    fn from(t: BuiltinInt) -> Self {\n+        IntTy { signedness: t.signedness, bitness: t.bitness }\n+    }\n+}\n+\n+impl From<BuiltinFloat> for FloatTy {\n+    fn from(t: BuiltinFloat) -> Self {\n+        FloatTy { bitness: t.bitness }\n+    }\n+}\n+\n+impl From<Option<BuiltinInt>> for UncertainIntTy {\n+    fn from(t: Option<BuiltinInt>) -> Self {\n+        match t {\n+            None => UncertainIntTy::Unknown,\n+            Some(t) => UncertainIntTy::Known(t.into()),\n+        }\n+    }\n+}\n+\n+impl From<Option<BuiltinFloat>> for UncertainFloatTy {\n+    fn from(t: Option<BuiltinFloat>) -> Self {\n+        match t {\n+            None => UncertainFloatTy::Unknown,\n+            Some(t) => UncertainFloatTy::Known(t.into()),\n+        }\n+    }\n+}\n+\n fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> FnSig {\n     let struct_data = db.struct_data(def.id.into());\n     let fields = match struct_data.variant_data.fields() {"}, {"sha": "7362de4c3f76bb58a1b5c65c611dd909f1b21c69", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -129,24 +129,6 @@ impl IntTy {\n             (Signedness::Unsigned, IntBitness::X128) => \"u128\",\n         }\n     }\n-\n-    pub(crate) fn from_suffix(suffix: &str) -> Option<IntTy> {\n-        match suffix {\n-            \"isize\" => Some(IntTy::isize()),\n-            \"i8\" => Some(IntTy::i8()),\n-            \"i16\" => Some(IntTy::i16()),\n-            \"i32\" => Some(IntTy::i32()),\n-            \"i64\" => Some(IntTy::i64()),\n-            \"i128\" => Some(IntTy::i128()),\n-            \"usize\" => Some(IntTy::usize()),\n-            \"u8\" => Some(IntTy::u8()),\n-            \"u16\" => Some(IntTy::u16()),\n-            \"u32\" => Some(IntTy::u32()),\n-            \"u64\" => Some(IntTy::u64()),\n-            \"u128\" => Some(IntTy::u128()),\n-            _ => None,\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -181,12 +163,4 @@ impl FloatTy {\n             FloatBitness::X64 => \"f64\",\n         }\n     }\n-\n-    pub(crate) fn from_suffix(suffix: &str) -> Option<FloatTy> {\n-        match suffix {\n-            \"f32\" => Some(FloatTy::f32()),\n-            \"f64\" => Some(FloatTy::f64()),\n-            _ => None,\n-        }\n-    }\n }"}, {"sha": "7447904ea6a4b526342764c560062fd075fe7f53", "filename": "crates/ra_hir_def/src/body.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -0,0 +1,2 @@\n+//! FIXME: write short doc here\n+mod lower;"}, {"sha": "1a144b1f9157a0593a11b9ce163f75749851b124", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -0,0 +1,49 @@\n+//! FIXME: write short doc here\n+\n+use ra_syntax::ast;\n+\n+use crate::expr::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering};\n+\n+impl From<ast::BinOp> for BinaryOp {\n+    fn from(ast_op: ast::BinOp) -> Self {\n+        match ast_op {\n+            ast::BinOp::BooleanOr => BinaryOp::LogicOp(LogicOp::Or),\n+            ast::BinOp::BooleanAnd => BinaryOp::LogicOp(LogicOp::And),\n+            ast::BinOp::EqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n+            ast::BinOp::NegatedEqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: true }),\n+            ast::BinOp::LesserEqualTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: false })\n+            }\n+            ast::BinOp::GreaterEqualTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: false })\n+            }\n+            ast::BinOp::LesserTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: true })\n+            }\n+            ast::BinOp::GreaterTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: true })\n+            }\n+            ast::BinOp::Addition => BinaryOp::ArithOp(ArithOp::Add),\n+            ast::BinOp::Multiplication => BinaryOp::ArithOp(ArithOp::Mul),\n+            ast::BinOp::Subtraction => BinaryOp::ArithOp(ArithOp::Sub),\n+            ast::BinOp::Division => BinaryOp::ArithOp(ArithOp::Div),\n+            ast::BinOp::Remainder => BinaryOp::ArithOp(ArithOp::Rem),\n+            ast::BinOp::LeftShift => BinaryOp::ArithOp(ArithOp::Shl),\n+            ast::BinOp::RightShift => BinaryOp::ArithOp(ArithOp::Shr),\n+            ast::BinOp::BitwiseXor => BinaryOp::ArithOp(ArithOp::BitXor),\n+            ast::BinOp::BitwiseOr => BinaryOp::ArithOp(ArithOp::BitOr),\n+            ast::BinOp::BitwiseAnd => BinaryOp::ArithOp(ArithOp::BitAnd),\n+            ast::BinOp::Assignment => BinaryOp::Assignment { op: None },\n+            ast::BinOp::AddAssign => BinaryOp::Assignment { op: Some(ArithOp::Add) },\n+            ast::BinOp::DivAssign => BinaryOp::Assignment { op: Some(ArithOp::Div) },\n+            ast::BinOp::MulAssign => BinaryOp::Assignment { op: Some(ArithOp::Mul) },\n+            ast::BinOp::RemAssign => BinaryOp::Assignment { op: Some(ArithOp::Rem) },\n+            ast::BinOp::ShlAssign => BinaryOp::Assignment { op: Some(ArithOp::Shl) },\n+            ast::BinOp::ShrAssign => BinaryOp::Assignment { op: Some(ArithOp::Shr) },\n+            ast::BinOp::SubAssign => BinaryOp::Assignment { op: Some(ArithOp::Sub) },\n+            ast::BinOp::BitOrAssign => BinaryOp::Assignment { op: Some(ArithOp::BitOr) },\n+            ast::BinOp::BitAndAssign => BinaryOp::Assignment { op: Some(ArithOp::BitAnd) },\n+            ast::BinOp::BitXorAssign => BinaryOp::Assignment { op: Some(ArithOp::BitXor) },\n+        }\n+    }\n+}"}, {"sha": "5e815714434ff3fdf381ce94f757846351743154", "filename": "crates/ra_hir_def/src/builtin_type.rs", "status": "modified", "additions": 70, "deletions": 16, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -56,22 +56,22 @@ impl BuiltinType {\n         (name::BOOL, BuiltinType::Bool),\n         (name::STR,  BuiltinType::Str ),\n \n-        (name::ISIZE, BuiltinType::Int(BuiltinInt { signedness: Signedness::Signed,   bitness: IntBitness::Xsize })),\n-        (name::I8,    BuiltinType::Int(BuiltinInt { signedness: Signedness::Signed,   bitness: IntBitness::X8    })),\n-        (name::I16,   BuiltinType::Int(BuiltinInt { signedness: Signedness::Signed,   bitness: IntBitness::X16   })),\n-        (name::I32,   BuiltinType::Int(BuiltinInt { signedness: Signedness::Signed,   bitness: IntBitness::X32   })),\n-        (name::I64,   BuiltinType::Int(BuiltinInt { signedness: Signedness::Signed,   bitness: IntBitness::X64   })),\n-        (name::I128,  BuiltinType::Int(BuiltinInt { signedness: Signedness::Signed,   bitness: IntBitness::X128  })),\n-\n-        (name::USIZE, BuiltinType::Int(BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize })),\n-        (name::U8,    BuiltinType::Int(BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X8    })),\n-        (name::U16,   BuiltinType::Int(BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X16   })),\n-        (name::U32,   BuiltinType::Int(BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X32   })),\n-        (name::U64,   BuiltinType::Int(BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X64   })),\n-        (name::U128,  BuiltinType::Int(BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X128  })),\n-\n-        (name::F32, BuiltinType::Float(BuiltinFloat { bitness: FloatBitness::X32 })),\n-        (name::F64, BuiltinType::Float(BuiltinFloat { bitness: FloatBitness::X64 })),\n+        (name::ISIZE, BuiltinType::Int(BuiltinInt::ISIZE)),\n+        (name::I8,    BuiltinType::Int(BuiltinInt::I8)),\n+        (name::I16,   BuiltinType::Int(BuiltinInt::I16)),\n+        (name::I32,   BuiltinType::Int(BuiltinInt::I32)),\n+        (name::I64,   BuiltinType::Int(BuiltinInt::I64)),\n+        (name::I128,  BuiltinType::Int(BuiltinInt::I128)),\n+\n+        (name::USIZE, BuiltinType::Int(BuiltinInt::USIZE)),\n+        (name::U8,    BuiltinType::Int(BuiltinInt::U8)),\n+        (name::U16,   BuiltinType::Int(BuiltinInt::U16)),\n+        (name::U32,   BuiltinType::Int(BuiltinInt::U32)),\n+        (name::U64,   BuiltinType::Int(BuiltinInt::U64)),\n+        (name::U128,  BuiltinType::Int(BuiltinInt::U128)),\n+\n+        (name::F32, BuiltinType::Float(BuiltinFloat::F32)),\n+        (name::F64, BuiltinType::Float(BuiltinFloat::F64)),\n     ];\n }\n \n@@ -104,3 +104,57 @@ impl fmt::Display for BuiltinType {\n         f.write_str(type_name)\n     }\n }\n+\n+#[rustfmt::skip]\n+impl BuiltinInt {\n+    pub const ISIZE: BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::Xsize   };\n+    pub const I8   : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X8      };\n+    pub const I16  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X16     };\n+    pub const I32  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X32     };\n+    pub const I64  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X64     };\n+    pub const I128 : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X128    };\n+\n+    pub const USIZE: BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize };\n+    pub const U8   : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X8    };\n+    pub const U16  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X16   };\n+    pub const U32  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X32   };\n+    pub const U64  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X64   };\n+    pub const U128 : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X128  };\n+\n+\n+    pub fn from_suffix(suffix: &str) -> Option<BuiltinInt> {\n+        let res = match suffix {\n+            \"isize\" => Self::ISIZE,\n+            \"i8\"    => Self::I8,\n+            \"i16\"   => Self::I16,\n+            \"i32\"   => Self::I32,\n+            \"i64\"   => Self::I64,\n+            \"i128\"  => Self::I128,\n+\n+            \"usize\" => Self::USIZE,\n+            \"u8\"    => Self::U8,\n+            \"u16\"   => Self::U16,\n+            \"u32\"   => Self::U32,\n+            \"u64\"   => Self::U64,\n+            \"u128\"  => Self::U128,\n+\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+#[rustfmt::skip]\n+impl BuiltinFloat {\n+    pub const F32: BuiltinFloat = BuiltinFloat { bitness: FloatBitness::X32 };\n+    pub const F64: BuiltinFloat = BuiltinFloat { bitness: FloatBitness::X64 };\n+\n+    pub fn from_suffix(suffix: &str) -> Option<BuiltinFloat> {\n+        let res = match suffix {\n+            \"f32\" => BuiltinFloat::F32,\n+            \"f64\" => BuiltinFloat::F64,\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}"}, {"sha": "12eb0da68b56ddc83f06549cdc17bdf235c41480", "filename": "crates/ra_hir_def/src/expr.rs", "status": "added", "additions": 419, "deletions": 0, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -0,0 +1,419 @@\n+//! This module describes hir-level representation of expressions.\n+//!\n+//! This representaion is:\n+//!\n+//! 1. Identity-based. Each expression has an `id`, so we can distinguish\n+//!    between different `1` in `1 + 1`.\n+//! 2. Independent of syntax. Though syntactic provenance information can be\n+//!    attached separately via id-based side map.\n+//! 3. Unresolved. Paths are stored as sequences of names, and not as defs the\n+//!    names refer to.\n+//! 4. Desugared. There's no `if let`.\n+\n+use hir_expand::name::Name;\n+use ra_arena::{impl_arena_id, RawId};\n+\n+use crate::{\n+    builtin_type::{BuiltinFloat, BuiltinInt},\n+    path::{GenericArgs, Path},\n+    type_ref::{Mutability, TypeRef},\n+};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ExprId(RawId);\n+impl_arena_id!(ExprId);\n+\n+impl ExprId {\n+    pub fn dummy() -> ExprId {\n+        ExprId((!0).into())\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct PatId(RawId);\n+impl_arena_id!(PatId);\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Literal {\n+    String(String),\n+    ByteString(Vec<u8>),\n+    Char(char),\n+    Bool(bool),\n+    Int(u64, Option<BuiltinInt>),\n+    Float(u64, Option<BuiltinFloat>), // FIXME: f64 is not Eq\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Expr {\n+    /// This is produced if syntax tree does not have a required expression piece.\n+    Missing,\n+    Path(Path),\n+    If {\n+        condition: ExprId,\n+        then_branch: ExprId,\n+        else_branch: Option<ExprId>,\n+    },\n+    Block {\n+        statements: Vec<Statement>,\n+        tail: Option<ExprId>,\n+    },\n+    Loop {\n+        body: ExprId,\n+    },\n+    While {\n+        condition: ExprId,\n+        body: ExprId,\n+    },\n+    For {\n+        iterable: ExprId,\n+        pat: PatId,\n+        body: ExprId,\n+    },\n+    Call {\n+        callee: ExprId,\n+        args: Vec<ExprId>,\n+    },\n+    MethodCall {\n+        receiver: ExprId,\n+        method_name: Name,\n+        args: Vec<ExprId>,\n+        generic_args: Option<GenericArgs>,\n+    },\n+    Match {\n+        expr: ExprId,\n+        arms: Vec<MatchArm>,\n+    },\n+    Continue,\n+    Break {\n+        expr: Option<ExprId>,\n+    },\n+    Return {\n+        expr: Option<ExprId>,\n+    },\n+    RecordLit {\n+        path: Option<Path>,\n+        fields: Vec<RecordLitField>,\n+        spread: Option<ExprId>,\n+    },\n+    Field {\n+        expr: ExprId,\n+        name: Name,\n+    },\n+    Await {\n+        expr: ExprId,\n+    },\n+    Try {\n+        expr: ExprId,\n+    },\n+    TryBlock {\n+        body: ExprId,\n+    },\n+    Cast {\n+        expr: ExprId,\n+        type_ref: TypeRef,\n+    },\n+    Ref {\n+        expr: ExprId,\n+        mutability: Mutability,\n+    },\n+    Box {\n+        expr: ExprId,\n+    },\n+    UnaryOp {\n+        expr: ExprId,\n+        op: UnaryOp,\n+    },\n+    BinaryOp {\n+        lhs: ExprId,\n+        rhs: ExprId,\n+        op: Option<BinaryOp>,\n+    },\n+    Index {\n+        base: ExprId,\n+        index: ExprId,\n+    },\n+    Lambda {\n+        args: Vec<PatId>,\n+        arg_types: Vec<Option<TypeRef>>,\n+        body: ExprId,\n+    },\n+    Tuple {\n+        exprs: Vec<ExprId>,\n+    },\n+    Array(Array),\n+    Literal(Literal),\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum BinaryOp {\n+    LogicOp(LogicOp),\n+    ArithOp(ArithOp),\n+    CmpOp(CmpOp),\n+    Assignment { op: Option<ArithOp> },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum LogicOp {\n+    And,\n+    Or,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum CmpOp {\n+    Eq { negated: bool },\n+    Ord { ordering: Ordering, strict: bool },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum Ordering {\n+    Less,\n+    Greater,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ArithOp {\n+    Add,\n+    Mul,\n+    Sub,\n+    Div,\n+    Rem,\n+    Shl,\n+    Shr,\n+    BitXor,\n+    BitOr,\n+    BitAnd,\n+}\n+\n+pub use ra_syntax::ast::PrefixOp as UnaryOp;\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Array {\n+    ElementList(Vec<ExprId>),\n+    Repeat { initializer: ExprId, repeat: ExprId },\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MatchArm {\n+    pub pats: Vec<PatId>,\n+    pub guard: Option<ExprId>,\n+    pub expr: ExprId,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct RecordLitField {\n+    pub name: Name,\n+    pub expr: ExprId,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Statement {\n+    Let { pat: PatId, type_ref: Option<TypeRef>, initializer: Option<ExprId> },\n+    Expr(ExprId),\n+}\n+\n+impl Expr {\n+    pub fn walk_child_exprs(&self, mut f: impl FnMut(ExprId)) {\n+        match self {\n+            Expr::Missing => {}\n+            Expr::Path(_) => {}\n+            Expr::If { condition, then_branch, else_branch } => {\n+                f(*condition);\n+                f(*then_branch);\n+                if let Some(else_branch) = else_branch {\n+                    f(*else_branch);\n+                }\n+            }\n+            Expr::Block { statements, tail } => {\n+                for stmt in statements {\n+                    match stmt {\n+                        Statement::Let { initializer, .. } => {\n+                            if let Some(expr) = initializer {\n+                                f(*expr);\n+                            }\n+                        }\n+                        Statement::Expr(e) => f(*e),\n+                    }\n+                }\n+                if let Some(expr) = tail {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::TryBlock { body } => f(*body),\n+            Expr::Loop { body } => f(*body),\n+            Expr::While { condition, body } => {\n+                f(*condition);\n+                f(*body);\n+            }\n+            Expr::For { iterable, body, .. } => {\n+                f(*iterable);\n+                f(*body);\n+            }\n+            Expr::Call { callee, args } => {\n+                f(*callee);\n+                for arg in args {\n+                    f(*arg);\n+                }\n+            }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                f(*receiver);\n+                for arg in args {\n+                    f(*arg);\n+                }\n+            }\n+            Expr::Match { expr, arms } => {\n+                f(*expr);\n+                for arm in arms {\n+                    f(arm.expr);\n+                }\n+            }\n+            Expr::Continue => {}\n+            Expr::Break { expr } | Expr::Return { expr } => {\n+                if let Some(expr) = expr {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::RecordLit { fields, spread, .. } => {\n+                for field in fields {\n+                    f(field.expr);\n+                }\n+                if let Some(expr) = spread {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::Lambda { body, .. } => {\n+                f(*body);\n+            }\n+            Expr::BinaryOp { lhs, rhs, .. } => {\n+                f(*lhs);\n+                f(*rhs);\n+            }\n+            Expr::Index { base, index } => {\n+                f(*base);\n+                f(*index);\n+            }\n+            Expr::Field { expr, .. }\n+            | Expr::Await { expr }\n+            | Expr::Try { expr }\n+            | Expr::Cast { expr, .. }\n+            | Expr::Ref { expr, .. }\n+            | Expr::UnaryOp { expr, .. }\n+            | Expr::Box { expr } => {\n+                f(*expr);\n+            }\n+            Expr::Tuple { exprs } => {\n+                for expr in exprs {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::Array(a) => match a {\n+                Array::ElementList(exprs) => {\n+                    for expr in exprs {\n+                        f(*expr);\n+                    }\n+                }\n+                Array::Repeat { initializer, repeat } => {\n+                    f(*initializer);\n+                    f(*repeat)\n+                }\n+            },\n+            Expr::Literal(_) => {}\n+        }\n+    }\n+}\n+\n+/// Explicit binding annotations given in the HIR for a binding. Note\n+/// that this is not the final binding *mode* that we infer after type\n+/// inference.\n+#[derive(Clone, PartialEq, Eq, Debug, Copy)]\n+pub enum BindingAnnotation {\n+    /// No binding annotation given: this means that the final binding mode\n+    /// will depend on whether we have skipped through a `&` reference\n+    /// when matching. For example, the `x` in `Some(x)` will have binding\n+    /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n+    /// ultimately be inferred to be by-reference.\n+    Unannotated,\n+\n+    /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n+    Mutable,\n+\n+    /// Annotated as `ref`, like `ref x`\n+    Ref,\n+\n+    /// Annotated as `ref mut x`.\n+    RefMut,\n+}\n+\n+impl BindingAnnotation {\n+    pub fn new(is_mutable: bool, is_ref: bool) -> Self {\n+        match (is_mutable, is_ref) {\n+            (true, true) => BindingAnnotation::RefMut,\n+            (false, true) => BindingAnnotation::Ref,\n+            (true, false) => BindingAnnotation::Mutable,\n+            (false, false) => BindingAnnotation::Unannotated,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct RecordFieldPat {\n+    pub name: Name,\n+    pub pat: PatId,\n+}\n+\n+/// Close relative to rustc's hir::PatKind\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Pat {\n+    Missing,\n+    Wild,\n+    Tuple(Vec<PatId>),\n+    Record {\n+        path: Option<Path>,\n+        args: Vec<RecordFieldPat>,\n+        // FIXME: 'ellipsis' option\n+    },\n+    Range {\n+        start: ExprId,\n+        end: ExprId,\n+    },\n+    Slice {\n+        prefix: Vec<PatId>,\n+        rest: Option<PatId>,\n+        suffix: Vec<PatId>,\n+    },\n+    Path(Path),\n+    Lit(ExprId),\n+    Bind {\n+        mode: BindingAnnotation,\n+        name: Name,\n+        subpat: Option<PatId>,\n+    },\n+    TupleStruct {\n+        path: Option<Path>,\n+        args: Vec<PatId>,\n+    },\n+    Ref {\n+        pat: PatId,\n+        mutability: Mutability,\n+    },\n+}\n+\n+impl Pat {\n+    pub fn walk_child_pats(&self, mut f: impl FnMut(PatId)) {\n+        match self {\n+            Pat::Range { .. } | Pat::Lit(..) | Pat::Path(..) | Pat::Wild | Pat::Missing => {}\n+            Pat::Bind { subpat, .. } => {\n+                subpat.iter().copied().for_each(f);\n+            }\n+            Pat::Tuple(args) | Pat::TupleStruct { args, .. } => {\n+                args.iter().copied().for_each(f);\n+            }\n+            Pat::Ref { pat, .. } => f(*pat),\n+            Pat::Slice { prefix, rest, suffix } => {\n+                let total_iter = prefix.iter().chain(rest.iter()).chain(suffix.iter());\n+                total_iter.copied().for_each(f);\n+            }\n+            Pat::Record { args, .. } => {\n+                args.iter().map(|f| f.pat).for_each(f);\n+            }\n+        }\n+    }\n+}"}, {"sha": "4a758bb835ed45c90a405c3c35ea8a8ec581cd59", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -14,6 +14,8 @@ pub mod type_ref;\n pub mod builtin_type;\n pub mod adt;\n pub mod diagnostics;\n+pub mod expr;\n+pub mod body;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "14121986017db8589e472098f5ca7eeaaf56b98e", "filename": "xtask/tests/tidy-tests/docs.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6149ee30ef9a379f642c8a645cea13f32c4f3d84/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6149ee30ef9a379f642c8a645cea13f32c4f3d84/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs?ref=6149ee30ef9a379f642c8a645cea13f32c4f3d84", "patch": "@@ -1,10 +1,6 @@\n-use std::fs;\n-use std::io::prelude::*;\n-use std::io::BufReader;\n-use std::path::Path;\n+use std::{collections::HashMap, fs, io::prelude::*, io::BufReader, path::Path};\n \n use walkdir::{DirEntry, WalkDir};\n-\n use xtask::project_root;\n \n fn is_exclude_dir(p: &Path) -> bool {\n@@ -37,6 +33,7 @@ fn no_docs_comments() {\n     let crates = project_root().join(\"crates\");\n     let iter = WalkDir::new(crates);\n     let mut missing_docs = Vec::new();\n+    let mut contains_fixme = Vec::new();\n     for f in iter.into_iter().filter_entry(|e| !is_hidden(e)) {\n         let f = f.unwrap();\n         if f.file_type().is_dir() {\n@@ -54,7 +51,12 @@ fn no_docs_comments() {\n         let mut reader = BufReader::new(fs::File::open(f.path()).unwrap());\n         let mut line = String::new();\n         reader.read_line(&mut line).unwrap();\n-        if !line.starts_with(\"//!\") {\n+\n+        if line.starts_with(\"//!\") {\n+            if line.contains(\"FIXME\") {\n+                contains_fixme.push(f.path().to_path_buf())\n+            }\n+        } else {\n             missing_docs.push(f.path().display().to_string());\n         }\n     }\n@@ -65,4 +67,39 @@ fn no_docs_comments() {\n             missing_docs.join(\"\\n\")\n         )\n     }\n+\n+    let whitelist = [\n+        \"ra_batch\",\n+        \"ra_cli\",\n+        \"ra_db\",\n+        \"ra_hir\",\n+        \"ra_hir_expand\",\n+        \"ra_hir_def\",\n+        \"ra_ide_api\",\n+        \"ra_lsp_server\",\n+        \"ra_mbe\",\n+        \"ra_parser\",\n+        \"ra_prof\",\n+        \"ra_project_model\",\n+        \"ra_syntax\",\n+        \"ra_text_edit\",\n+        \"ra_tt\",\n+    ];\n+\n+    let mut has_fixmes = whitelist.iter().map(|it| (*it, false)).collect::<HashMap<&str, bool>>();\n+    'outer: for path in contains_fixme {\n+        for krate in whitelist.iter() {\n+            if path.components().any(|it| it.as_os_str() == *krate) {\n+                has_fixmes.insert(krate, true);\n+                continue 'outer;\n+            }\n+        }\n+        panic!(\"FIXME doc in a fully-documented crate: {}\", path.display())\n+    }\n+\n+    for (krate, has_fixme) in has_fixmes.iter() {\n+        if !has_fixme {\n+            panic!(\"crate {} is fully documented, remove it from the white list\", krate)\n+        }\n+    }\n }"}]}