{"sha": "c9bf84333d4f76417f935e24b7a70340b8f1b1be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5YmY4NDMzM2Q0Zjc2NDE3ZjkzNWUyNGI3YTcwMzQwYjhmMWIxYmU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-10T11:04:45Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T14:18:21Z"}, "message": "rustc: de-@ method and vtable maps.", "tree": {"sha": "f1496e935bc17094e1d8cdf118d12162f1e51ecf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1496e935bc17094e1d8cdf118d12162f1e51ecf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9bf84333d4f76417f935e24b7a70340b8f1b1be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9bf84333d4f76417f935e24b7a70340b8f1b1be", "html_url": "https://github.com/rust-lang/rust/commit/c9bf84333d4f76417f935e24b7a70340b8f1b1be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9bf84333d4f76417f935e24b7a70340b8f1b1be/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "158d7a19b3f39bcdf3c8d7094fda8f0dd6e121b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/158d7a19b3f39bcdf3c8d7094fda8f0dd6e121b5", "html_url": "https://github.com/rust-lang/rust/commit/158d7a19b3f39bcdf3c8d7094fda8f0dd6e121b5"}], "stats": {"total": 435, "additions": 209, "deletions": 226}, "files": [{"sha": "d42e1d6479bafb3558e60e06696bc67af2a3a68c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -146,8 +146,8 @@ fn encode_impl_vtables(ebml_w: &mut Encoder,\n                        ecx: &EncodeContext,\n                        vtables: &typeck::impl_res) {\n     ebml_w.start_tag(tag_item_impl_vtables);\n-    astencode::encode_vtable_res(ecx, ebml_w, vtables.trait_vtables);\n-    astencode::encode_vtable_param_res(ecx, ebml_w, vtables.self_vtables);\n+    astencode::encode_vtable_res(ecx, ebml_w, &vtables.trait_vtables);\n+    astencode::encode_vtable_param_res(ecx, ebml_w, &vtables.self_vtables);\n     ebml_w.end_tag();\n }\n "}, {"sha": "2f3d427dcccf8b9fc615fa0b617021bcea2dc971", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -658,7 +658,7 @@ impl tr for MethodOrigin {\n fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n                               ebml_w: &mut Encoder,\n                               autoderef: u32,\n-                              dr: typeck::vtable_res) {\n+                              dr: &typeck::vtable_res) {\n     ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n         ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n             autoderef.encode(ebml_w)\n@@ -671,19 +671,19 @@ fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n \n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut Encoder,\n-                     dr: typeck::vtable_res) {\n+                     dr: &typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n     ebml_w.emit_from_vec(dr.as_slice(), |ebml_w, param_tables| {\n-        Ok(encode_vtable_param_res(ecx, ebml_w, *param_tables))\n+        Ok(encode_vtable_param_res(ecx, ebml_w, param_tables))\n     }).unwrap()\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut Encoder,\n-                     param_tables: typeck::vtable_param_res) {\n+                     param_tables: &typeck::vtable_param_res) {\n     ebml_w.emit_from_vec(param_tables.as_slice(), |ebml_w, vtable_origin| {\n         Ok(encode_vtable_origin(ecx, ebml_w, vtable_origin))\n     }).unwrap()\n@@ -695,7 +695,7 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                         vtable_origin: &typeck::vtable_origin) {\n     ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n         match *vtable_origin {\n-          typeck::vtable_static(def_id, ref tys, vtable_res) => {\n+          typeck::vtable_static(def_id, ref tys, ref vtable_res) => {\n             ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |ebml_w| {\n                 ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n                     Ok(ebml_w.emit_def_id(def_id))\n@@ -756,21 +756,15 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     fn read_vtable_res(&mut self,\n                        tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res {\n-        @self.read_to_vec(|this|\n-                          Ok(this.read_vtable_param_res(tcx, cdata)))\n-             .unwrap()\n-             .move_iter()\n-             .collect()\n+        self.read_to_vec(|this| Ok(this.read_vtable_param_res(tcx, cdata)))\n+             .unwrap().move_iter().collect()\n     }\n \n     fn read_vtable_param_res(&mut self,\n                              tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_param_res {\n-        @self.read_to_vec(|this|\n-                          Ok(this.read_vtable_origin(tcx, cdata)))\n-             .unwrap()\n-             .move_iter()\n-             .collect()\n+        self.read_to_vec(|this| Ok(this.read_vtable_origin(tcx, cdata)))\n+             .unwrap().move_iter().collect()\n     }\n \n     fn read_vtable_origin(&mut self,\n@@ -1063,7 +1057,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_vtable_res_with_key(ecx, ebml_w, method_call.autoderef, *dr);\n+                encode_vtable_res_with_key(ecx, ebml_w, method_call.autoderef, dr);\n             })\n         })\n     }\n@@ -1087,7 +1081,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                             ebml_w.id(id);\n                             ebml_w.tag(c::tag_table_val, |ebml_w| {\n                                 encode_vtable_res_with_key(ecx, ebml_w,\n-                                                           method_call.autoderef, *dr);\n+                                                           method_call.autoderef, dr);\n                             })\n                         })\n                     }"}, {"sha": "2a7ceb4f681c07cd2fafc3310c9abb4b0456eebd", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -176,14 +176,14 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) ->\n            def_id.repr(bcx.tcx()), node, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n     trans_fn_ref_with_vtables(bcx, def_id, node,\n-                              type_params.as_slice(),\n+                              type_params,\n                               vtables)\n }\n \n fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n                                            def_id: ast::DefId,\n                                            ref_id: ast::NodeId,\n-                                           type_params: &[ty::t],\n+                                           type_params: Vec<ty::t>,\n                                            vtables: Option<typeck::vtable_res>)\n                                            -> Callee<'a> {\n     Callee {bcx: bcx,\n@@ -206,29 +206,32 @@ fn resolve_default_method_vtables(bcx: &Block,\n     let param_substs = Some(@param_substs {\n         tys: substs.tps.clone(),\n         self_ty: substs.self_ty,\n-        vtables: impl_vtables,\n+        vtables: impl_vtables.clone(),\n         self_vtables: None\n     });\n \n-    let trait_vtables_fixed = resolve_vtables_under_param_substs(\n-        bcx.tcx(), param_substs, impl_res.trait_vtables);\n+    let mut param_vtables = resolve_vtables_under_param_substs(\n+        bcx.tcx(), param_substs, impl_res.trait_vtables.as_slice());\n \n     // Now we pull any vtables for parameters on the actual method.\n     let num_method_vtables = method.generics.type_param_defs().len();\n-    let method_vtables = match impl_vtables {\n-        Some(vtables) => {\n+    match impl_vtables {\n+        Some(ref vtables) => {\n             let num_impl_type_parameters =\n                 vtables.len() - num_method_vtables;\n-            Vec::from_slice(vtables.tailn(num_impl_type_parameters))\n+            param_vtables.push_all(vtables.tailn(num_impl_type_parameters))\n         },\n-        None => Vec::from_elem(num_method_vtables, @Vec::new())\n-    };\n-\n-    let method_vtables = method_vtables.as_slice();\n-    let param_vtables = @((*trait_vtables_fixed).clone().append(method_vtables));\n+        None => {\n+            param_vtables.extend(range(0, num_method_vtables).map(\n+                |_| -> typeck::vtable_param_res {\n+                    Vec::new()\n+                }\n+            ))\n+        }\n+    }\n \n     let self_vtables = resolve_param_vtables_under_param_substs(\n-        bcx.tcx(), param_substs, impl_res.self_vtables);\n+        bcx.tcx(), param_substs, impl_res.self_vtables.as_slice());\n \n     (param_vtables, self_vtables)\n }\n@@ -238,7 +241,7 @@ pub fn trans_fn_ref_with_vtables(\n         bcx: &Block,       //\n         def_id: ast::DefId,   // def id of fn\n         node: ExprOrMethodCall,  // node id of use of fn; may be zero if N/A\n-        type_params: &[ty::t], // values for fn's ty params\n+        type_params: Vec<ty::t>, // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n      -> ValueRef {\n     /*!\n@@ -273,9 +276,11 @@ pub fn trans_fn_ref_with_vtables(\n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n \n-    let substs = ty::substs { regions: ty::ErasedRegions,\n-                              self_ty: None,\n-                              tps: /*bad*/ Vec::from_slice(type_params) };\n+    let substs = ty::substs {\n+        regions: ty::ErasedRegions,\n+        self_ty: None,\n+        tps: type_params\n+    };\n \n     // Load the info for the appropriate trait if necessary.\n     match ty::trait_of_method(tcx, def_id) {\n@@ -318,19 +323,20 @@ pub fn trans_fn_ref_with_vtables(\n             // And compose them\n             let new_substs = first_subst.subst(tcx, &substs);\n \n+            debug!(\"trans_fn_with_vtables - default method: \\\n+                    substs = {}, trait_subst = {}, \\\n+                    first_subst = {}, new_subst = {}, \\\n+                    vtables = {}\",\n+                   substs.repr(tcx), trait_ref.substs.repr(tcx),\n+                   first_subst.repr(tcx), new_substs.repr(tcx),\n+                   vtables.repr(tcx));\n \n             let (param_vtables, self_vtables) =\n                 resolve_default_method_vtables(bcx, impl_id,\n                                                method, &substs, vtables);\n \n             debug!(\"trans_fn_with_vtables - default method: \\\n-                    substs = {}, trait_subst = {}, \\\n-                    first_subst = {}, new_subst = {}, \\\n-                    vtables = {}, \\\n                     self_vtable = {}, param_vtables = {}\",\n-                   substs.repr(tcx), trait_ref.substs.repr(tcx),\n-                   first_subst.repr(tcx), new_substs.repr(tcx),\n-                   vtables.repr(tcx),\n                    self_vtables.repr(tcx), param_vtables.repr(tcx));\n \n             (true, source_id,\n@@ -352,7 +358,7 @@ pub fn trans_fn_ref_with_vtables(\n     // intrinsic, or is a default method.  In particular, if we see an\n     // intrinsic that is inlined from a different crate, we want to reemit the\n     // intrinsic instead of trying to call it in the other crate.\n-    let must_monomorphise = if type_params.len() > 0 || is_default {\n+    let must_monomorphise = if substs.tps.len() > 0 || is_default {\n         true\n     } else if def_id.krate == ast::LOCAL_CRATE {\n         let map_node = session::expect(\n@@ -504,7 +510,7 @@ pub fn trans_lang_call<'a>(\n                                 trans_fn_ref_with_vtables_to_callee(bcx,\n                                                                     did,\n                                                                     0,\n-                                                                    [],\n+                                                                    vec!(),\n                                                                     None)\n                              },\n                              ArgVals(args),"}, {"sha": "ab474eacf25e01881227e5991ddf312a744117e6", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -797,41 +797,42 @@ pub fn node_id_type_params(bcx: &Block, node: ExprOrMethodCall) -> Vec<ty::t> {\n \n pub fn node_vtables(bcx: &Block, id: typeck::MethodCall)\n                  -> Option<typeck::vtable_res> {\n-    let vtable_map = bcx.tcx().vtable_map.borrow();\n-    let raw_vtables = vtable_map.find(&id);\n-    raw_vtables.map(|vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n+    bcx.tcx().vtable_map.borrow().find(&id).map(|vts| {\n+        resolve_vtables_in_fn_ctxt(bcx.fcx, vts.as_slice())\n+    })\n }\n \n // Apply the typaram substitutions in the FunctionContext to some\n // vtables. This should eliminate any vtable_params.\n-pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext, vts: typeck::vtable_res)\n-    -> typeck::vtable_res {\n+pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext,\n+                                  vts: &[typeck::vtable_param_res])\n+                                  -> typeck::vtable_res {\n     resolve_vtables_under_param_substs(fcx.ccx.tcx(),\n                                        fcx.param_substs,\n                                        vts)\n }\n \n pub fn resolve_vtables_under_param_substs(tcx: &ty::ctxt,\n                                           param_substs: Option<@param_substs>,\n-                                          vts: typeck::vtable_res)\n-    -> typeck::vtable_res {\n-    @vts.iter().map(|ds|\n+                                          vts: &[typeck::vtable_param_res])\n+                                          -> typeck::vtable_res {\n+    vts.iter().map(|ds| {\n       resolve_param_vtables_under_param_substs(tcx,\n                                                param_substs,\n-                                               *ds))\n-        .collect()\n+                                               ds.as_slice())\n+    }).collect()\n }\n \n pub fn resolve_param_vtables_under_param_substs(\n     tcx: &ty::ctxt,\n     param_substs: Option<@param_substs>,\n-    ds: typeck::vtable_param_res)\n+    ds: &[typeck::vtable_origin])\n     -> typeck::vtable_param_res {\n-    @ds.iter().map(\n-        |d| resolve_vtable_under_param_substs(tcx,\n-                                              param_substs,\n-                                              d))\n-        .collect()\n+    ds.iter().map(|d| {\n+        resolve_vtable_under_param_substs(tcx,\n+                                          param_substs,\n+                                          d)\n+    }).collect()\n }\n \n \n@@ -841,7 +842,7 @@ pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n                                          vt: &typeck::vtable_origin)\n                                          -> typeck::vtable_origin {\n     match *vt {\n-        typeck::vtable_static(trait_id, ref tys, sub) => {\n+        typeck::vtable_static(trait_id, ref tys, ref sub) => {\n             let tys = match param_substs {\n                 Some(substs) => {\n                     tys.iter().map(|t| {\n@@ -855,7 +856,7 @@ pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n             };\n             typeck::vtable_static(\n                 trait_id, tys,\n-                resolve_vtables_under_param_substs(tcx, param_substs, sub))\n+                resolve_vtables_under_param_substs(tcx, param_substs, sub.as_slice()))\n         }\n         typeck::vtable_param(n_param, n_bound) => {\n             match param_substs {\n@@ -881,11 +882,11 @@ pub fn find_vtable(tcx: &ty::ctxt,\n            n_param, n_bound, ps.repr(tcx));\n \n     let param_bounds = match n_param {\n-        typeck::param_self => ps.self_vtables.expect(\"self vtables missing\"),\n+        typeck::param_self => ps.self_vtables.as_ref().expect(\"self vtables missing\"),\n         typeck::param_numbered(n) => {\n-            let tables = ps.vtables\n+            let tables = ps.vtables.as_ref()\n                 .expect(\"vtables missing where they are needed\");\n-            *tables.get(n)\n+            tables.get(n)\n         }\n     };\n     param_bounds.get(n_bound).clone()"}, {"sha": "1c2ef8e092ff5777ca06362883590263ce94c126", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 60, "deletions": 56, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -193,21 +193,21 @@ pub fn trans_static_method_callee(bcx: &Block,\n             name={}\", method_id, expr_id, token::get_name(mname));\n \n     let vtable_key = MethodCall::expr(expr_id);\n-    let vtbls = ccx.tcx.vtable_map.borrow().get_copy(&vtable_key);\n-    let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, vtbls);\n+    let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, ccx.tcx.vtable_map.borrow()\n+                                                       .get(&vtable_key).as_slice());\n \n-    match vtbls.get(bound_index).get(0) {\n-        &typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n+    match vtbls.move_iter().nth(bound_index).unwrap().move_iter().nth(0).unwrap() {\n+        typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n                     bcx, mth_id, ExprId(expr_id),\n-                    rcvr_substs.as_slice(), rcvr_origins);\n+                    rcvr_substs, rcvr_origins);\n \n             let llfn = trans_fn_ref_with_vtables(bcx, mth_id, ExprId(expr_id),\n-                                                 callee_substs.as_slice(),\n+                                                 callee_substs,\n                                                  Some(callee_origins));\n \n             let callee_ty = node_id_type(bcx, expr_id);\n@@ -247,7 +247,7 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n                                   -> Callee<'a> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n     match vtbl {\n-      typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n+      typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n           let mname = ty::trait_method(ccx.tcx(), trait_id, n_method).ident;\n           let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n@@ -257,13 +257,13 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n           let (callee_substs, callee_origins) =\n               combine_impl_and_methods_tps(\n                   bcx, mth_id,  MethodCall(method_call),\n-                  rcvr_substs.as_slice(), rcvr_origins);\n+                  rcvr_substs, rcvr_origins);\n \n           // translate the function\n           let llfn = trans_fn_ref_with_vtables(bcx,\n                                                mth_id,\n                                                MethodCall(method_call),\n-                                               callee_substs.as_slice(),\n+                                               callee_substs,\n                                                Some(callee_origins));\n \n           Callee { bcx: bcx, data: Fn(llfn) }\n@@ -277,9 +277,9 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n fn combine_impl_and_methods_tps(bcx: &Block,\n                                 mth_did: ast::DefId,\n                                 node: ExprOrMethodCall,\n-                                rcvr_substs: &[ty::t],\n+                                rcvr_substs: Vec<ty::t>,\n                                 rcvr_origins: typeck::vtable_res)\n-                                -> (Vec<ty::t> , typeck::vtable_res) {\n+                                -> (Vec<ty::t>, typeck::vtable_res) {\n     /*!\n     *\n     * Creates a concatenated set of substitutions which includes\n@@ -302,10 +302,13 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     let n_m_tps = method.generics.type_param_defs().len();\n     let node_substs = node_id_type_params(bcx, node);\n     debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx()));\n-    let ty_substs\n-        = Vec::from_slice(rcvr_substs).append(node_substs.tailn(node_substs.len() - n_m_tps));\n-    debug!(\"n_m_tps={:?}\", n_m_tps);\n     debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx()));\n+    let mut ty_substs = rcvr_substs;\n+    {\n+        let start = node_substs.len() - n_m_tps;\n+        ty_substs.extend(node_substs.move_iter().skip(start));\n+    }\n+    debug!(\"n_m_tps={:?}\", n_m_tps);\n     debug!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx()));\n \n \n@@ -315,14 +318,20 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n         ExprId(id) => MethodCall::expr(id),\n         MethodCall(method_call) => method_call\n     };\n-    let vtables = node_vtables(bcx, vtable_key);\n-    let r_m_origins = match vtables {\n-        Some(vt) => vt,\n-        None => @Vec::from_elem(node_substs.len(), @Vec::new())\n-    };\n-    let vtables\n-        = @Vec::from_slice(rcvr_origins.as_slice())\n-                           .append(r_m_origins.tailn(r_m_origins.len() - n_m_tps));\n+    let mut vtables = rcvr_origins;\n+    match node_vtables(bcx, vtable_key) {\n+        Some(vt) => {\n+            let start = vt.len() - n_m_tps;\n+            vtables.extend(vt.move_iter().skip(start));\n+        }\n+        None => {\n+            vtables.extend(range(0, n_m_tps).map(\n+                |_| -> typeck::vtable_param_res {\n+                    Vec::new()\n+                }\n+            ));\n+        }\n+    }\n \n     (ty_substs, vtables)\n }\n@@ -422,10 +431,10 @@ pub fn vtable_id(ccx: &CrateContext,\n                  origin: &typeck::vtable_origin)\n               -> mono_id {\n     match origin {\n-        &typeck::vtable_static(impl_id, ref substs, sub_vtables) => {\n+        &typeck::vtable_static(impl_id, ref substs, ref sub_vtables) => {\n             let psubsts = param_substs {\n                 tys: (*substs).clone(),\n-                vtables: Some(sub_vtables),\n+                vtables: Some(sub_vtables.clone()),\n                 self_ty: None,\n                 self_vtables: None\n             };\n@@ -443,10 +452,10 @@ pub fn vtable_id(ccx: &CrateContext,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-pub fn get_vtable(bcx: &Block,\n-                  self_ty: ty::t,\n-                  origins: typeck::vtable_param_res)\n-                  -> ValueRef {\n+fn get_vtable(bcx: &Block,\n+              self_ty: ty::t,\n+              origins: typeck::vtable_param_res)\n+              -> ValueRef {\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n@@ -458,43 +467,33 @@ pub fn get_vtable(bcx: &Block,\n     }\n \n     // Not in the cache. Actually build it.\n-    let mut methods = Vec::new();\n-    for origin in origins.iter() {\n-        match *origin {\n-            typeck::vtable_static(id, ref substs, sub_vtables) => {\n-                let vtable_methods = emit_vtable_methods(bcx,\n-                                                         id,\n-                                                         substs.as_slice(),\n-                                                         sub_vtables);\n-                for vtable_method in vtable_methods.move_iter() {\n-                    methods.push(vtable_method)\n-                }\n+    let methods = origins.move_iter().flat_map(|origin| {\n+        match origin {\n+            typeck::vtable_static(id, substs, sub_vtables) => {\n+                emit_vtable_methods(bcx, id, substs, sub_vtables).move_iter()\n             }\n             _ => ccx.sess().bug(\"get_vtable: expected a static origin\"),\n         }\n-    }\n+    });\n \n     // Generate a destructor for the vtable.\n     let drop_glue = glue::get_drop_glue(ccx, self_ty);\n-    let vtable = make_vtable(ccx, drop_glue, methods.as_slice());\n+    let vtable = make_vtable(ccx, drop_glue, methods);\n \n     ccx.vtables.borrow_mut().insert(hash_id, vtable);\n-    return vtable;\n+    vtable\n }\n \n /// Helper function to declare and initialize the vtable.\n-pub fn make_vtable(ccx: &CrateContext,\n-                   drop_glue: ValueRef,\n-                   ptrs: &[ValueRef])\n-                   -> ValueRef {\n-    unsafe {\n-        let _icx = push_ctxt(\"meth::make_vtable\");\n+pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n+                                          drop_glue: ValueRef,\n+                                          ptrs: I)\n+                                          -> ValueRef {\n+    let _icx = push_ctxt(\"meth::make_vtable\");\n \n-        let mut components = vec!(drop_glue);\n-        for &ptr in ptrs.iter() {\n-            components.push(ptr)\n-        }\n+    let components: Vec<_> = Some(drop_glue).move_iter().chain(ptrs).collect();\n \n+    unsafe {\n         let tbl = C_struct(ccx, components.as_slice(), false);\n         let sym = token::gensym(\"vtable\");\n         let vt_gvar = format!(\"vtable{}\", sym).with_c_str(|buf| {\n@@ -509,7 +508,7 @@ pub fn make_vtable(ccx: &CrateContext,\n \n fn emit_vtable_methods(bcx: &Block,\n                        impl_id: ast::DefId,\n-                       substs: &[ty::t],\n+                       substs: Vec<ty::t>,\n                        vtables: typeck::vtable_res)\n                        -> Vec<ValueRef> {\n     let ccx = bcx.ccx();\n@@ -539,7 +538,8 @@ fn emit_vtable_methods(bcx: &Block,\n                    token::get_ident(ident));\n             C_null(Type::nil(ccx).ptr_to())\n         } else {\n-            trans_fn_ref_with_vtables(bcx, m_id, ExprId(0), substs, Some(vtables))\n+            trans_fn_ref_with_vtables(bcx, m_id, ExprId(0),\n+                                      substs.clone(), Some(vtables.clone()))\n         }\n     }).collect()\n }\n@@ -576,8 +576,12 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    let res = *ccx.tcx.vtable_map.borrow().get(&MethodCall::expr(id));\n-    let origins = *resolve_vtables_in_fn_ctxt(bcx.fcx, res).get(0);\n+    let origins = {\n+        let vtable_map = ccx.tcx.vtable_map.borrow();\n+        resolve_param_vtables_under_param_substs(ccx.tcx(),\n+            bcx.fcx.param_substs,\n+            vtable_map.get(&MethodCall::expr(id)).get(0).as_slice())\n+    };\n     let vtable = get_vtable(bcx, v_ty, origins);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());"}, {"sha": "445aa9f23230931135dee2fd9f0cabbcc0127a04", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -296,7 +296,7 @@ pub fn make_mono_id(ccx: &CrateContext,\n     // .collect() to work.\n     let substs_iter = substs.self_ty.iter().chain(substs.tys.iter());\n     let precise_param_ids: Vec<(ty::t, Option<@Vec<mono_id> >)> = match substs.vtables {\n-      Some(vts) => {\n+      Some(ref vts) => {\n         debug!(\"make_mono_id vtables={} substs={}\",\n                vts.repr(ccx.tcx()), substs.tys.repr(ccx.tcx()));\n         let vts_iter = substs.self_vtables.iter().chain(vts.iter());"}, {"sha": "25af1066ba387a784a6a6c2217059a5433074305", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -1134,8 +1134,8 @@ pub fn mk_ctxt(s: Session,\n         upvar_borrow_map: RefCell::new(HashMap::new()),\n         extern_const_statics: RefCell::new(DefIdMap::new()),\n         extern_const_variants: RefCell::new(DefIdMap::new()),\n-        method_map: @RefCell::new(FnvHashMap::new()),\n-        vtable_map: @RefCell::new(FnvHashMap::new()),\n+        method_map: RefCell::new(FnvHashMap::new()),\n+        vtable_map: RefCell::new(FnvHashMap::new()),\n     }\n }\n "}, {"sha": "910b7e93cf8a6e69bea42e54d9d33b7765a51818", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -265,8 +265,8 @@ impl<'a> Inherited<'a> {\n             node_types: RefCell::new(NodeMap::new()),\n             node_type_substs: RefCell::new(NodeMap::new()),\n             adjustments: RefCell::new(NodeMap::new()),\n-            method_map: @RefCell::new(FnvHashMap::new()),\n-            vtable_map: @RefCell::new(FnvHashMap::new()),\n+            method_map: RefCell::new(FnvHashMap::new()),\n+            vtable_map: RefCell::new(FnvHashMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n         }\n     }"}, {"sha": "520db02cfc7d82dcbed8338c88308b8433a05fd2", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -29,7 +29,6 @@ use util::ppaux::Repr;\n \n use collections::HashSet;\n use std::cell::RefCell;\n-use std::result;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -112,7 +111,7 @@ fn lookup_vtables(vcx: &VtableContext,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()),\n            result.repr(vcx.tcx()));\n-    @result\n+    result\n }\n \n fn lookup_vtables_for_param(vcx: &VtableContext,\n@@ -170,7 +169,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n            ty.repr(vcx.tcx()),\n            param_result.repr(vcx.tcx()));\n \n-    return @param_result;\n+    param_result\n }\n \n fn relate_trait_refs(vcx: &VtableContext,\n@@ -189,8 +188,8 @@ fn relate_trait_refs(vcx: &VtableContext,\n                                    infer::RelateTraitRefs(span),\n                                    act_trait_ref,\n                                    exp_trait_ref) {\n-        result::Ok(()) => {} // Ok.\n-        result::Err(ref err) => {\n+        Ok(()) => {} // Ok.\n+        Err(ref err) => {\n             // There is an error, but we need to do some work to make\n             // the message good.\n             // Resolve any type vars in the trait refs\n@@ -368,8 +367,8 @@ fn search_for_vtable(vcx: &VtableContext,\n                               infer::RelateSelfType(span),\n                               ty,\n                               for_ty) {\n-            result::Err(_) => continue,\n-            result::Ok(()) => ()\n+            Err(_) => continue,\n+            Ok(()) => ()\n         }\n \n         // Now, in the previous example, for_ty is bound to\n@@ -583,7 +582,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                                      is_early);\n \n                       if !is_early {\n-                          insert_vtables(fcx, MethodCall::expr(ex.id), @vec!(vtables));\n+                          insert_vtables(fcx, MethodCall::expr(ex.id), vec!(vtables));\n                       }\n \n                       // Now, if this is &trait, we need to link the\n@@ -743,7 +742,7 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n         [],\n         impl_item.id);\n \n-    let impl_trait_ref = @impl_trait_ref.subst(tcx, &param_env.free_substs);\n+    let impl_trait_ref = impl_trait_ref.subst(tcx, &param_env.free_substs);\n \n     let infcx = &infer::new_infer_ctxt(tcx);\n     let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n@@ -761,7 +760,7 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n     // but that falls out of doing this.\n     let param_bounds = ty::ParamBounds {\n         builtin_bounds: ty::EmptyBuiltinBounds(),\n-        trait_bounds: vec!(impl_trait_ref)\n+        trait_bounds: vec!(@impl_trait_ref)\n     };\n     let t = ty::node_id_to_type(tcx, impl_item.id);\n     let t = t.subst(tcx, &param_env.free_substs);"}, {"sha": "9598b1e9581170dee7055cfdd5e29d8019cb618c", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 63, "deletions": 84, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -51,44 +51,31 @@ fn resolve_type_vars_in_type(fcx: &FnCtxt, sp: Span, typ: ty::t)\n     }\n }\n \n-fn resolve_type_vars_in_types(fcx: &FnCtxt, sp: Span, tys: &[ty::t])\n-                          -> Vec<ty::t> {\n-    tys.iter().map(|t| {\n-        match resolve_type_vars_in_type(fcx, sp, *t) {\n-            Some(t1) => t1,\n-            None => ty::mk_err()\n-        }\n-    }).collect()\n-}\n-\n fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall) {\n     let fcx = wbcx.fcx;\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any method map entry\n-    match fcx.inh.method_map.borrow().find(&method_call) {\n+    match fcx.inh.method_map.borrow_mut().pop(&method_call) {\n         Some(method) => {\n             debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n                    method_call, method.repr(tcx));\n-            let method_ty = match resolve_type_vars_in_type(fcx, sp, method.ty) {\n-                Some(t) => t,\n-                None => {\n-                    wbcx.success = false;\n-                    return;\n-                }\n-            };\n-            let mut new_tps = Vec::new();\n-            for &subst in method.substs.tps.iter() {\n-                match resolve_type_vars_in_type(fcx, sp, subst) {\n-                    Some(t) => new_tps.push(t),\n-                    None => { wbcx.success = false; return; }\n-                }\n-            }\n             let new_method = MethodCallee {\n                 origin: method.origin,\n-                ty: method_ty,\n+                ty: match resolve_type_vars_in_type(fcx, sp, method.ty) {\n+                    Some(t) => t,\n+                    None => {\n+                        wbcx.success = false;\n+                        return;\n+                    }\n+                },\n                 substs: ty::substs {\n-                    tps: new_tps,\n+                    tps: method.substs.tps.move_iter().map(|subst| {\n+                        match resolve_type_vars_in_type(fcx, sp, subst) {\n+                            Some(t) => t,\n+                            None => { wbcx.success = false; ty::mk_err() }\n+                        }\n+                    }).collect(),\n                     regions: ty::ErasedRegions,\n                     self_ty: None\n                 }\n@@ -101,46 +88,46 @@ fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall\n \n fn resolve_vtable_map_entry(fcx: &FnCtxt, sp: Span, vtable_key: MethodCall) {\n     // Resolve any vtable map entry\n-    match fcx.inh.vtable_map.borrow().find_copy(&vtable_key) {\n+    match fcx.inh.vtable_map.borrow_mut().pop(&vtable_key) {\n         Some(origins) => {\n             let r_origins = resolve_origins(fcx, sp, origins);\n-            fcx.tcx().vtable_map.borrow_mut().insert(vtable_key, r_origins);\n             debug!(\"writeback::resolve_vtable_map_entry(vtable_key={}, vtables={:?})\",\n                     vtable_key, r_origins.repr(fcx.tcx()));\n+            fcx.tcx().vtable_map.borrow_mut().insert(vtable_key, r_origins);\n         }\n         None => {}\n     }\n \n     fn resolve_origins(fcx: &FnCtxt, sp: Span,\n                        vtbls: vtable_res) -> vtable_res {\n-        @vtbls.iter().map(|os| @os.iter().map(|origin| {\n+        vtbls.move_iter().map(|os| os.move_iter().map(|origin| {\n             match origin {\n-                &vtable_static(def_id, ref tys, origins) => {\n-                    let r_tys = resolve_type_vars_in_types(fcx,\n-                                                           sp,\n-                                                           tys.as_slice());\n+                vtable_static(def_id, tys, origins) => {\n+                    let r_tys = tys.move_iter().map(|t| {\n+                        match resolve_type_vars_in_type(fcx, sp, t) {\n+                            Some(t1) => t1,\n+                            None => ty::mk_err()\n+                        }\n+                    }).collect();\n                     let r_origins = resolve_origins(fcx, sp, origins);\n                     vtable_static(def_id, r_tys, r_origins)\n                 }\n-                &vtable_param(n, b) => {\n-                    vtable_param(n, b)\n-                }\n+                vtable_param(n, b) => vtable_param(n, b)\n             }\n         }).collect()).collect()\n     }\n }\n \n-fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n-                           -> Option<ty::t> {\n+fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n     let fcx = wbcx.fcx;\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n-    match fcx.inh.adjustments.borrow().find_copy(&id) {\n-        None => (),\n+    let resolved_adj = match fcx.inh.adjustments.borrow_mut().pop(&id) {\n+        None => None,\n \n         Some(adjustment) => {\n-            match *adjustment {\n+            Some(match *adjustment {\n                 ty::AutoAddEnv(store) => {\n                     let r = match store {\n                         ty::RegionTraitStore(r, _) => r,\n@@ -156,6 +143,8 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                                 format!(\"cannot resolve bound for closure: \\\n                                          {}\",\n                                         infer::fixup_err_to_str(e)));\n+                            wbcx.success = false;\n+                            return;\n                         }\n                         Ok(r1) => {\n                             // FIXME(eddyb) #2190 Allow only statically resolved\n@@ -170,15 +159,12 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                                         \"cannot coerce non-statically resolved bare fn\")\n                             }\n \n-                            let resolved_adj = @ty::AutoAddEnv(match store {\n+                            ty::AutoAddEnv(match store {\n                                 ty::RegionTraitStore(..) => {\n                                     ty::RegionTraitStore(r1, ast::MutMutable)\n                                 }\n                                 ty::UniqTraitStore => ty::UniqTraitStore\n-                            });\n-                            debug!(\"Adjustments for node {}: {:?}\",\n-                                   id, resolved_adj);\n-                            tcx.adjustments.borrow_mut().insert(id, resolved_adj);\n+                            })\n                         }\n                     }\n                 }\n@@ -190,69 +176,62 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                         resolve_vtable_map_entry(wbcx.fcx, sp, method_call);\n                     }\n \n-                    let fixup_region = |r| {\n-                        match resolve_region(fcx.infcx(),\n-                                             r,\n-                                             resolve_all | force_all) {\n-                            Ok(r1) => r1,\n-                            Err(e) => {\n-                                // This should not, I think, happen.\n-                                tcx.sess.span_err(\n-                                    sp,\n-                                    format!(\"cannot resolve scope of borrow: \\\n-                                             {}\",\n-                                             infer::fixup_err_to_str(e)));\n-                                r\n-                            }\n-                        }\n-                    };\n-\n-                    let resolved_autoref = match adj.autoref {\n-                        None => None,\n-                        Some(ref r) => Some(r.map_region(fixup_region))\n-                    };\n-\n-                    let resolved_adj = @ty::AutoDerefRef(ty::AutoDerefRef {\n+                    ty::AutoDerefRef(ty::AutoDerefRef {\n                         autoderefs: adj.autoderefs,\n-                        autoref: resolved_autoref,\n-                    });\n-                    debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n-                    tcx.adjustments.borrow_mut().insert(id, resolved_adj);\n+                        autoref: adj.autoref.map(|r| r.map_region(|r| {\n+                            match resolve_region(fcx.infcx(), r,\n+                                                resolve_all | force_all) {\n+                                Ok(r1) => r1,\n+                                Err(e) => {\n+                                    // This should not, I think, happen.\n+                                    tcx.sess.span_err(\n+                                        sp,\n+                                        format!(\"cannot resolve scope of borrow: \\\n+                                                {}\",\n+                                                infer::fixup_err_to_str(e)));\n+                                    r\n+                                }\n+                            }\n+                        })),\n+                    })\n                 }\n \n-                ty::AutoObject(..) => {\n-                    debug!(\"Adjustments for node {}: {:?}\", id, adjustment);\n-                    tcx.adjustments.borrow_mut().insert(id, adjustment);\n-                }\n-            }\n+                adjustment => adjustment\n+            })\n         }\n+    };\n+\n+    debug!(\"Adjustments for node {}: {:?}\",\n+           id, resolved_adj);\n+    match resolved_adj {\n+        Some(adj) => {\n+            tcx.adjustments.borrow_mut().insert(id, @adj);\n+        }\n+        None => {}\n     }\n \n     // Resolve the type of the node with id `id`\n     let n_ty = fcx.node_ty(id);\n     match resolve_type_vars_in_type(fcx, sp, n_ty) {\n       None => {\n         wbcx.success = false;\n-        return None;\n       }\n \n       Some(t) => {\n         debug!(\"resolve_type_vars_for_node(id={}, n_ty={}, t={})\",\n                id, ppaux::ty_to_str(tcx, n_ty), ppaux::ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n-        let mut ret = Some(t);\n         fcx.opt_node_ty_substs(id, |substs| {\n           let mut new_tps = Vec::new();\n           for subst in substs.tps.iter() {\n               match resolve_type_vars_in_type(fcx, sp, *subst) {\n                 Some(t) => new_tps.push(t),\n-                None => { wbcx.success = false; ret = None; break }\n+                None => { wbcx.success = false; break }\n               }\n           }\n           write_substs_to_tcx(tcx, id, new_tps);\n-          ret.is_some()\n+          wbcx.success\n         });\n-        ret\n       }\n     }\n }"}, {"sha": "7382ce5734de919c9e0433733e0dcfcfbd9f026d", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf84333d4f76417f935e24b7a70340b8f1b1be/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=c9bf84333d4f76417f935e24b7a70340b8f1b1be", "patch": "@@ -171,11 +171,11 @@ impl MethodCall {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap = @RefCell<FnvHashMap<MethodCall, MethodCallee>>;\n+pub type MethodMap = RefCell<FnvHashMap<MethodCall, MethodCallee>>;\n \n-pub type vtable_param_res = @Vec<vtable_origin> ;\n+pub type vtable_param_res = Vec<vtable_origin>;\n // Resolutions for bounds of all parameters, left to right, for a given path.\n-pub type vtable_res = @Vec<vtable_param_res> ;\n+pub type vtable_res = Vec<vtable_param_res>;\n \n #[deriving(Clone)]\n pub enum vtable_origin {\n@@ -184,7 +184,7 @@ pub enum vtable_origin {\n       from whence comes the vtable, and tys are the type substs.\n       vtable_res is the vtable itself\n      */\n-    vtable_static(ast::DefId, Vec<ty::t> , vtable_res),\n+    vtable_static(ast::DefId, Vec<ty::t>, vtable_res),\n \n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n@@ -215,7 +215,7 @@ impl Repr for vtable_origin {\n     }\n }\n \n-pub type vtable_map = @RefCell<FnvHashMap<MethodCall, vtable_res>>;\n+pub type vtable_map = RefCell<FnvHashMap<MethodCall, vtable_res>>;\n \n \n // Information about the vtable resolutions for a trait impl."}]}