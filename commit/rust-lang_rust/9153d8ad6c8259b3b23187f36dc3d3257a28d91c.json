{"sha": "9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNTNkOGFkNmM4MjU5YjNiMjMxODdmMzZkYzNkMzI1N2EyOGQ5MWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-05-31T22:53:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-06-13T17:20:24Z"}, "message": "Introduce VecPerParamSpace and use it to represent sets of types and\nparameters\n\nThis involves numerous substeps:\n\n1. Treat Self same as any other parameter.\n2. No longer compute offsets for method parameters.\n3. Store all generic types (both trait/impl and method) with a method,\n   eliminating odd discrepancies.\n4. Stop doing unspeakable things to static methods and instead just use\n   the natural types, now that we can easily add the type parameters from\n   trait into the method's polytype.\n5. No doubt some more. It was hard to separate these into distinct commits.\n\nFixes #13564", "tree": {"sha": "f0190703b6b6281e12629348f68ebf059b6be15a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0190703b6b6281e12629348f68ebf059b6be15a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "html_url": "https://github.com/rust-lang/rust/commit/9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0422934e243ed57a7662ec878db9d4e01ca5b0f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0422934e243ed57a7662ec878db9d4e01ca5b0f9", "html_url": "https://github.com/rust-lang/rust/commit/0422934e243ed57a7662ec878db9d4e01ca5b0f9"}], "stats": {"total": 4797, "additions": 2571, "deletions": 2226}, "files": [{"sha": "5a974aecabcb285978201d3febd9017672933ceb", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -189,9 +189,7 @@ pub static tag_impls_impl: uint = 0x81;\n pub static tag_items_data_item_inherent_impl: uint = 0x82;\n pub static tag_items_data_item_extension_impl: uint = 0x83;\n \n-pub static tag_region_param_def: uint = 0x84;\n-pub static tag_region_param_def_ident: uint = 0x85;\n-pub static tag_region_param_def_def_id: uint = 0x86;\n+// GAP 0x84, 0x85, 0x86\n \n pub static tag_native_libraries: uint = 0x87;\n pub static tag_native_libraries_lib: uint = 0x88;\n@@ -217,3 +215,9 @@ pub struct LinkMeta {\n     pub crateid: CrateId,\n     pub crate_hash: Svh,\n }\n+\n+pub static tag_region_param_def: uint = 0x90;\n+pub static tag_region_param_def_ident: uint = 0x91;\n+pub static tag_region_param_def_def_id: uint = 0x92;\n+pub static tag_region_param_def_space: uint = 0x93;\n+pub static tag_region_param_def_index: uint = 0x94;"}, {"sha": "43c895a201fa687215b4e33f304ee4ffa6fc4b57", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -18,6 +18,7 @@ use metadata::decoder;\n use middle::lang_items;\n use middle::ty;\n use middle::typeck;\n+use middle::subst::VecPerParamSpace;\n \n use serialize::ebml;\n use serialize::ebml::reader;\n@@ -223,8 +224,8 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n         });\n     let ty = decoder::item_type(def, the_field, tcx, &*cdata);\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {type_param_defs: Rc::new(Vec::new()),\n-                                region_param_defs: Rc::new(Vec::new())},\n+        generics: ty::Generics {types: VecPerParamSpace::empty(),\n+                                regions: VecPerParamSpace::empty()},\n         ty: ty\n     }\n }\n@@ -240,7 +241,8 @@ pub fn get_impl_trait(tcx: &ty::ctxt,\n \n // Given a def_id for an impl, return information about its vtables\n pub fn get_impl_vtables(tcx: &ty::ctxt,\n-                        def: ast::DefId) -> typeck::impl_res {\n+                        def: ast::DefId)\n+                        -> typeck::vtable_res {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_vtables(&*cdata, def.node, tcx)"}, {"sha": "68aa2bacd08e20743661c1ba8ec8ec4a534efb67", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -23,6 +23,7 @@ use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n use middle::lang_items;\n use middle::def;\n+use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty;\n use middle::typeck;\n@@ -257,34 +258,44 @@ fn item_ty_param_defs(item: ebml::Doc,\n                       tcx: &ty::ctxt,\n                       cdata: Cmd,\n                       tag: uint)\n-                      -> Rc<Vec<ty::TypeParameterDef> > {\n-    let mut bounds = Vec::new();\n+                      -> subst::VecPerParamSpace<ty::TypeParameterDef> {\n+    let mut bounds = subst::VecPerParamSpace::empty();\n     reader::tagged_docs(item, tag, |p| {\n         let bd = parse_type_param_def_data(\n             p.data, p.start, cdata.cnum, tcx,\n             |_, did| translate_def_id(cdata, did));\n-        bounds.push(bd);\n+        bounds.push(bd.space, bd);\n         true\n     });\n-    Rc::new(bounds)\n+    bounds\n }\n \n fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n-                          -> Rc<Vec<ty::RegionParameterDef> > {\n-    let mut v = Vec::new();\n+                          -> subst::VecPerParamSpace<ty::RegionParameterDef>\n+{\n+    let mut v = subst::VecPerParamSpace::empty();\n     reader::tagged_docs(item_doc, tag_region_param_def, |rp_doc| {\n-            let ident_str_doc = reader::get_doc(rp_doc,\n-                                                tag_region_param_def_ident);\n-            let ident = item_name(&*token::get_ident_interner(), ident_str_doc);\n-            let def_id_doc = reader::get_doc(rp_doc,\n-                                             tag_region_param_def_def_id);\n-            let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n-            let def_id = translate_def_id(cdata, def_id);\n-            v.push(ty::RegionParameterDef { name: ident.name,\n-                                            def_id: def_id });\n-            true\n-        });\n-    Rc::new(v)\n+        let ident_str_doc = reader::get_doc(rp_doc,\n+                                            tag_region_param_def_ident);\n+        let ident = item_name(&*token::get_ident_interner(), ident_str_doc);\n+        let def_id_doc = reader::get_doc(rp_doc,\n+                                         tag_region_param_def_def_id);\n+        let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n+        let def_id = translate_def_id(cdata, def_id);\n+\n+        let doc = reader::get_doc(rp_doc, tag_region_param_def_space);\n+        let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as uint);\n+\n+        let doc = reader::get_doc(rp_doc, tag_region_param_def_index);\n+        let index = reader::doc_as_u64(doc) as uint;\n+\n+        v.push(space, ty::RegionParameterDef { name: ident.name,\n+                                               def_id: def_id,\n+                                               space: space,\n+                                               index: index });\n+        true\n+    });\n+    v\n }\n \n fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n@@ -403,8 +414,8 @@ pub fn get_trait_def(cdata: Cmd,\n     }\n \n     ty::TraitDef {\n-        generics: ty::Generics {type_param_defs: tp_defs,\n-                                region_param_defs: rp_defs},\n+        generics: ty::Generics {types: tp_defs,\n+                                regions: rp_defs},\n         bounds: bounds,\n         trait_ref: Rc::new(item_trait_ref(item_doc, tcx, cdata))\n     }\n@@ -422,8 +433,8 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n     let rp_defs = item_region_param_defs(item, cdata);\n \n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {type_param_defs: tp_defs,\n-                                region_param_defs: rp_defs},\n+        generics: ty::Generics {types: tp_defs,\n+                                regions: rp_defs},\n         ty: t\n     }\n }\n@@ -440,16 +451,13 @@ pub fn get_impl_trait(cdata: Cmd,\n \n pub fn get_impl_vtables(cdata: Cmd,\n                         id: ast::NodeId,\n-                        tcx: &ty::ctxt) -> typeck::impl_res\n+                        tcx: &ty::ctxt)\n+                        -> typeck::vtable_res\n {\n     let item_doc = lookup_item(id, cdata.data());\n     let vtables_doc = reader::get_doc(item_doc, tag_item_impl_vtables);\n     let mut decoder = reader::Decoder::new(vtables_doc);\n-\n-    typeck::impl_res {\n-        trait_vtables: decoder.read_vtable_res(tcx, cdata),\n-        self_vtables: decoder.read_vtable_param_res(tcx, cdata)\n-    }\n+    decoder.read_vtable_res(tcx, cdata)\n }\n \n \n@@ -802,8 +810,8 @@ pub fn get_method(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n     ty::Method::new(\n         name,\n         ty::Generics {\n-            type_param_defs: type_param_defs,\n-            region_param_defs: rp_defs,\n+            types: type_param_defs,\n+            regions: rp_defs,\n         },\n         fty,\n         explicit_self,"}, {"sha": "98d9b45738fd09c138b927b2b7607463d00b9683", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -19,6 +19,7 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n+use middle::subst::VecPerParamSpace;\n use middle::ty::{node_id_to_type, lookup_item_type};\n use middle::astencode;\n use middle::ty;\n@@ -128,10 +129,9 @@ fn encode_trait_ref(ebml_w: &mut Encoder,\n \n fn encode_impl_vtables(ebml_w: &mut Encoder,\n                        ecx: &EncodeContext,\n-                       vtables: &typeck::impl_res) {\n+                       vtables: &typeck::vtable_res) {\n     ebml_w.start_tag(tag_item_impl_vtables);\n-    astencode::encode_vtable_res(ecx, ebml_w, &vtables.trait_vtables);\n-    astencode::encode_vtable_param_res(ecx, ebml_w, &vtables.self_vtables);\n+    astencode::encode_vtable_res(ecx, ebml_w, vtables);\n     ebml_w.end_tag();\n }\n \n@@ -148,7 +148,7 @@ pub fn def_to_str(did: DefId) -> String {\n \n fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n                              ecx: &EncodeContext,\n-                             params: &[ty::TypeParameterDef],\n+                             params: &VecPerParamSpace<ty::TypeParameterDef>,\n                              tag: uint) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n@@ -164,7 +164,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n }\n \n fn encode_region_param_defs(ebml_w: &mut Encoder,\n-                            params: &[ty::RegionParameterDef]) {\n+                            params: &VecPerParamSpace<ty::RegionParameterDef>) {\n     for param in params.iter() {\n         ebml_w.start_tag(tag_region_param_def);\n \n@@ -175,6 +175,12 @@ fn encode_region_param_defs(ebml_w: &mut Encoder,\n         ebml_w.wr_tagged_str(tag_region_param_def_def_id,\n                              def_to_str(param.def_id).as_slice());\n \n+        ebml_w.wr_tagged_u64(tag_region_param_def_space,\n+                             param.space.to_uint() as u64);\n+\n+        ebml_w.wr_tagged_u64(tag_region_param_def_index,\n+                             param.index as u64);\n+\n         ebml_w.end_tag();\n     }\n }\n@@ -191,9 +197,9 @@ fn encode_item_variances(ebml_w: &mut Encoder,\n fn encode_bounds_and_type(ebml_w: &mut Encoder,\n                           ecx: &EncodeContext,\n                           tpt: &ty::ty_param_bounds_and_ty) {\n-    encode_ty_type_param_defs(ebml_w, ecx, tpt.generics.type_param_defs(),\n+    encode_ty_type_param_defs(ebml_w, ecx, &tpt.generics.types,\n                               tag_items_data_item_ty_param_bounds);\n-    encode_region_param_defs(ebml_w, tpt.generics.region_param_defs());\n+    encode_region_param_defs(ebml_w, &tpt.generics.regions);\n     encode_type(ecx, ebml_w, tpt.ty);\n }\n \n@@ -725,8 +731,7 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n                            method_ty: &ty::Method) {\n     encode_def_id(ebml_w, method_ty.def_id);\n     encode_name(ebml_w, method_ty.ident.name);\n-    encode_ty_type_param_defs(ebml_w, ecx,\n-                              method_ty.generics.type_param_defs(),\n+    encode_ty_type_param_defs(ebml_w, ecx, &method_ty.generics.types,\n                               tag_item_method_tps);\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n     encode_visibility(ebml_w, method_ty.vis);\n@@ -770,10 +775,8 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     }\n \n     for &ast_method in ast_method_opt.iter() {\n-        let num_params = tpt.generics.type_param_defs().len();\n-        if num_params > 0u ||\n-                is_default_impl ||\n-                should_inline(ast_method.attrs.as_slice()) {\n+        let any_types = !tpt.generics.types.is_empty();\n+        if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n             encode_inlined_item(ecx, ebml_w,\n                                 IIMethodRef(local_def(parent_id), false,\n                                             &*ast_method));\n@@ -1125,9 +1128,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(ebml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n         encode_ty_type_param_defs(ebml_w, ecx,\n-                                  trait_def.generics.type_param_defs(),\n+                                  &trait_def.generics.types,\n                                   tag_items_data_item_ty_param_bounds);\n-        encode_region_param_defs(ebml_w, trait_def.generics.region_param_defs());\n+        encode_region_param_defs(ebml_w, &trait_def.generics.regions);\n         encode_trait_ref(ebml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ebml_w, item.ident.name);\n         encode_attributes(ebml_w, item.attrs.as_slice());"}, {"sha": "6a60f91a1ae4f18114d4b5fb638258f373df5fb8", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 74, "deletions": 29, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -17,6 +17,7 @@\n #![allow(non_camel_case_types)]\n \n use middle::subst;\n+use middle::subst::VecPerParamSpace;\n use middle::ty;\n \n use std::rc::Rc;\n@@ -114,26 +115,45 @@ pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n     }\n }\n \n+fn data_log_string(data: &[u8], pos: uint) -> String {\n+    let mut buf = String::new();\n+    buf.push_str(\"<<\");\n+    for i in range(pos, data.len()) {\n+        let c = data[i];\n+        if c > 0x20 && c <= 0x7F {\n+            buf.push_char(c as char);\n+        } else {\n+            buf.push_char('.');\n+        }\n+    }\n+    buf.push_str(\">>\");\n+    buf\n+}\n+\n pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                      conv: conv_did) -> ty::t {\n+    debug!(\"parse_ty_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_ty(&mut st, conv)\n }\n \n pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                              conv: conv_did) -> ty::BareFnTy {\n+    debug!(\"parse_bare_fn_ty_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_bare_fn_ty(&mut st, conv)\n }\n \n pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                             conv: conv_did) -> ty::TraitRef {\n+    debug!(\"parse_trait_ref_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_trait_ref(&mut st, conv)\n }\n \n pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                          conv: conv_did) -> subst::Substs {\n+    debug!(\"parse_substs_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_substs(&mut st, conv)\n }\n@@ -162,34 +182,39 @@ fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     }\n }\n \n-fn parse_substs(st: &mut PState, conv: conv_did) -> subst::Substs {\n-    let regions = parse_region_substs(st, |x,y| conv(x,y));\n+fn parse_vec_per_param_space<T>(st: &mut PState,\n+                                f: |&mut PState| -> T)\n+                                -> VecPerParamSpace<T>\n+{\n+    let mut r = VecPerParamSpace::empty();\n+    for &space in subst::ParamSpace::all().iter() {\n+        assert_eq!(next(st), '[');\n+        while peek(st) != ']' {\n+            r.push(space, f(st));\n+        }\n+        assert_eq!(next(st), ']');\n+    }\n+    r\n+}\n \n-    let self_ty = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)) );\n+fn parse_substs(st: &mut PState, conv: conv_did) -> subst::Substs {\n+    let regions =\n+        parse_region_substs(st, |x,y| conv(x,y));\n \n-    assert_eq!(next(st), '[');\n-    let mut params: Vec<ty::t> = Vec::new();\n-    while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n-    st.pos = st.pos + 1u;\n+    let types =\n+        parse_vec_per_param_space(st, |st| parse_ty(st, |x,y| conv(x,y)));\n \n-    return subst::Substs {\n-        regions: regions,\n-        self_ty: self_ty,\n-        tps: params\n-    };\n+    return subst::Substs { types: types,\n+                           regions: regions };\n }\n \n fn parse_region_substs(st: &mut PState, conv: conv_did) -> subst::RegionSubsts {\n     match next(st) {\n         'e' => subst::ErasedRegions,\n         'n' => {\n-            let mut regions = vec!();\n-            while peek(st) != '.' {\n-                let r = parse_region(st, |x,y| conv(x,y));\n-                regions.push(r);\n-            }\n-            assert_eq!(next(st), '.');\n-            subst::NonerasedRegions(regions)\n+            subst::NonerasedRegions(\n+                parse_vec_per_param_space(\n+                    st, |st| parse_region(st, |x,y| conv(x,y))))\n         }\n         _ => fail!(\"parse_bound_region: bad input\")\n     }\n@@ -230,10 +255,12 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n         assert_eq!(next(st), '[');\n         let node_id = parse_uint(st) as ast::NodeId;\n         assert_eq!(next(st), '|');\n+        let space = parse_param_space(st);\n+        assert_eq!(next(st), '|');\n         let index = parse_uint(st);\n         assert_eq!(next(st), '|');\n         let nm = token::str_to_ident(parse_str(st, ']').as_slice());\n-        ty::ReEarlyBound(node_id, index, nm.name)\n+        ty::ReEarlyBound(node_id, space, index, nm.name)\n       }\n       'f' => {\n         assert_eq!(next(st), '[');\n@@ -327,11 +354,11 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'p' => {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n         debug!(\"parsed ty_param: did={:?}\", did);\n-        return ty::mk_param(st.tcx, parse_uint(st), did);\n-      }\n-      's' => {\n-        let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n-        return ty::mk_self(st.tcx, did);\n+        let index = parse_uint(st);\n+        assert_eq!(next(st), '|');\n+        let space = parse_param_space(st);\n+        assert_eq!(next(st), '|');\n+        return ty::mk_param(st.tcx, space, index, did);\n       }\n       '@' => return ty::mk_box(st.tcx, parse_ty(st, |x,y| conv(x,y))),\n       '~' => return ty::mk_uniq(st.tcx, parse_ty(st, |x,y| conv(x,y))),\n@@ -395,6 +422,9 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n+      'e' => {\n+          return ty::mk_err();\n+      }\n       c => { fail!(\"unexpected char in type string: {}\", c);}\n     }\n }\n@@ -427,6 +457,10 @@ fn parse_uint(st: &mut PState) -> uint {\n     };\n }\n \n+fn parse_param_space(st: &mut PState) -> subst::ParamSpace {\n+    subst::ParamSpace::from_uint(parse_uint(st))\n+}\n+\n fn parse_hex(st: &mut PState) -> uint {\n     let mut n = 0u;\n     loop {\n@@ -546,11 +580,22 @@ pub fn parse_type_param_def_data(data: &[u8], start: uint,\n }\n \n fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef {\n+    let ident = parse_ident(st, ':');\n+    let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n+    let space = parse_param_space(st);\n+    assert_eq!(next(st), '|');\n+    let index = parse_uint(st);\n+    assert_eq!(next(st), '|');\n+    let bounds = Rc::new(parse_bounds(st, |x,y| conv(x,y)));\n+    let default = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)));\n+\n     ty::TypeParameterDef {\n-        ident: parse_ident(st, ':'),\n-        def_id: parse_def(st, NominalType, |x,y| conv(x,y)),\n-        bounds: Rc::new(parse_bounds(st, |x,y| conv(x,y))),\n-        default: parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)))\n+        ident: ident,\n+        def_id: def_id,\n+        space: space,\n+        index: index,\n+        bounds: bounds,\n+        default: default\n     }\n }\n "}, {"sha": "b8987a382daedfdfba2b87f1ab9ade03768aa396", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -18,7 +18,8 @@ use std::collections::HashMap;\n use std::io::MemWriter;\n \n use middle::subst;\n-use middle::ty::param_ty;\n+use middle::subst::VecPerParamSpace;\n+use middle::ty::ParamTy;\n use middle::ty;\n \n use syntax::abi::Abi;\n@@ -118,12 +119,23 @@ fn enc_opt<T>(w: &mut MemWriter, t: Option<T>, enc_f: |&mut MemWriter, T|) {\n     }\n }\n \n+fn enc_vec_per_param_space<T>(w: &mut MemWriter,\n+                              cx: &ctxt,\n+                              v: &VecPerParamSpace<T>,\n+                              op: |&mut MemWriter, &ctxt, &T|) {\n+    for &space in subst::ParamSpace::all().iter() {\n+        mywrite!(w, \"[\");\n+        for t in v.get_vec(space).iter() {\n+            op(w, cx, t);\n+        }\n+        mywrite!(w, \"]\");\n+    }\n+}\n+\n pub fn enc_substs(w: &mut MemWriter, cx: &ctxt, substs: &subst::Substs) {\n     enc_region_substs(w, cx, &substs.regions);\n-    enc_opt(w, substs.self_ty, |w, t| enc_ty(w, cx, t));\n-    mywrite!(w, \"[\");\n-    for t in substs.tps.iter() { enc_ty(w, cx, *t); }\n-    mywrite!(w, \"]\");\n+    enc_vec_per_param_space(w, cx, &substs.types,\n+                            |w, cx, &ty| enc_ty(w, cx, ty));\n }\n \n fn enc_region_substs(w: &mut MemWriter, cx: &ctxt, substs: &subst::RegionSubsts) {\n@@ -133,10 +145,8 @@ fn enc_region_substs(w: &mut MemWriter, cx: &ctxt, substs: &subst::RegionSubsts)\n         }\n         subst::NonerasedRegions(ref regions) => {\n             mywrite!(w, \"n\");\n-            for &r in regions.iter() {\n-                enc_region(w, cx, r);\n-            }\n-            mywrite!(w, \".\");\n+            enc_vec_per_param_space(w, cx, regions,\n+                                    |w, cx, &r| enc_region(w, cx, r));\n         }\n     }\n }\n@@ -148,9 +158,10 @@ fn enc_region(w: &mut MemWriter, cx: &ctxt, r: ty::Region) {\n             enc_bound_region(w, cx, br);\n             mywrite!(w, \"]\");\n         }\n-        ty::ReEarlyBound(node_id, index, name) => {\n-            mywrite!(w, \"B[{}|{}|{}]\",\n+        ty::ReEarlyBound(node_id, space, index, name) => {\n+            mywrite!(w, \"B[{}|{}|{}|{}]\",\n                      node_id,\n+                     space.to_uint(),\n                      index,\n                      token::get_name(name));\n         }\n@@ -293,18 +304,17 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n         ty::ty_infer(_) => {\n             cx.diag.handler().bug(\"cannot encode inference variable types\");\n         }\n-        ty::ty_param(param_ty {idx: id, def_id: did}) => {\n-            mywrite!(w, \"p{}|{}\", (cx.ds)(did), id);\n-        }\n-        ty::ty_self(did) => {\n-            mywrite!(w, \"s{}|\", (cx.ds)(did));\n+        ty::ty_param(ParamTy {space, idx: id, def_id: did}) => {\n+            mywrite!(w, \"p{}|{}|{}|\", (cx.ds)(did), id, space.to_uint())\n         }\n         ty::ty_struct(def, ref substs) => {\n             mywrite!(w, \"a[{}|\", (cx.ds)(def));\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_err => fail!(\"shouldn't encode error type\")\n+        ty::ty_err => {\n+            mywrite!(w, \"e\");\n+        }\n     }\n }\n \n@@ -378,7 +388,9 @@ fn enc_bounds(w: &mut MemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n }\n \n pub fn enc_type_param_def(w: &mut MemWriter, cx: &ctxt, v: &ty::TypeParameterDef) {\n-    mywrite!(w, \"{}:{}|\", token::get_ident(v.ident), (cx.ds)(v.def_id));\n+    mywrite!(w, \"{}:{}|{}|{}|\",\n+             token::get_ident(v.ident), (cx.ds)(v.def_id),\n+             v.space.to_uint(), v.index);\n     enc_bounds(w, cx, &*v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n }"}, {"sha": "289c2feef2db160e817339b261bf20103fcb4973", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 81, "deletions": 44, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -25,6 +25,7 @@ use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n                          RegionParameter};\n use metadata::tyencode;\n use middle::subst;\n+use middle::subst::VecPerParamSpace;\n use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n use middle::{ty, typeck};\n use util::ppaux::ty_to_str;\n@@ -39,7 +40,7 @@ use libc;\n use std::io::Seek;\n use std::io::MemWriter;\n use std::mem;\n-use std::rc::Rc;\n+use std::string::String;\n \n use serialize::ebml::reader;\n use serialize::ebml;\n@@ -433,7 +434,7 @@ impl tr for def::Def {\n           def::DefTrait(did) => def::DefTrait(did.tr(xcx)),\n           def::DefTy(did) => def::DefTy(did.tr(xcx)),\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n-          def::DefTyParam(did, v) => def::DefTyParam(did.tr(xcx), v),\n+          def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(xcx), v),\n           def::DefBinding(nid, bm) => def::DefBinding(xcx.tr_id(nid), bm),\n           def::DefUse(did) => def::DefUse(did.tr(xcx)),\n           def::DefUpvar(nid1, def, nid2, nid3) => {\n@@ -476,13 +477,18 @@ impl tr for ty::AutoRef {\n impl tr for ty::Region {\n     fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::Region {\n         match *self {\n-            ty::ReLateBound(id, br) => ty::ReLateBound(xcx.tr_id(id),\n-                                                       br.tr(xcx)),\n-            ty::ReEarlyBound(id, index, ident) => ty::ReEarlyBound(xcx.tr_id(id),\n-                                                                     index,\n-                                                                     ident),\n-            ty::ReScope(id) => ty::ReScope(xcx.tr_id(id)),\n-            ty::ReEmpty | ty::ReStatic | ty::ReInfer(..) => *self,\n+            ty::ReLateBound(id, br) => {\n+                ty::ReLateBound(xcx.tr_id(id), br.tr(xcx))\n+            }\n+            ty::ReEarlyBound(id, space, index, ident) => {\n+                ty::ReEarlyBound(xcx.tr_id(id), space, index, ident)\n+            }\n+            ty::ReScope(id) => {\n+                ty::ReScope(xcx.tr_id(id))\n+            }\n+            ty::ReEmpty | ty::ReStatic | ty::ReInfer(..) => {\n+                *self\n+            }\n             ty::ReFree(ref fr) => {\n                 ty::ReFree(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n                                             bound_region: fr.bound_region.tr(xcx)})\n@@ -634,15 +640,16 @@ fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n }\n \n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n-                     ebml_w: &mut Encoder,\n-                     dr: &typeck::vtable_res) {\n+                         ebml_w: &mut Encoder,\n+                         dr: &typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n-    // ones.  perhaps we should fix this.\n-    ebml_w.emit_from_vec(dr.as_slice(), |ebml_w, param_tables| {\n-        Ok(encode_vtable_param_res(ecx, ebml_w, param_tables))\n-    }).unwrap()\n+    // ones. perhaps we should fix this.\n+    encode_vec_per_param_space(\n+        ebml_w, dr,\n+        |ebml_w, param_tables| encode_vtable_param_res(ecx, ebml_w,\n+                                                       param_tables))\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n@@ -673,7 +680,7 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n             })\n           }\n           typeck::vtable_param(pn, bn) => {\n-            ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u, |ebml_w| {\n+            ebml_w.emit_enum_variant(\"vtable_param\", 1u, 3u, |ebml_w| {\n                 ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n                     pn.encode(ebml_w)\n                 });\n@@ -682,11 +689,19 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                 })\n             })\n           }\n+          typeck::vtable_error => {\n+            ebml_w.emit_enum_variant(\"vtable_error\", 2u, 3u, |_ebml_w| {\n+                Ok(())\n+            })\n+          }\n         }\n     }).unwrap()\n }\n \n pub trait vtable_decoder_helpers {\n+    fn read_vec_per_param_space<T>(&mut self,\n+                                   f: |&mut Self| -> T)\n+                                   -> VecPerParamSpace<T>;\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt,\n                                 cdata: &cstore::crate_metadata)\n@@ -703,6 +718,16 @@ pub trait vtable_decoder_helpers {\n }\n \n impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n+    fn read_vec_per_param_space<T>(&mut self,\n+                                   f: |&mut reader::Decoder<'a>| -> T)\n+                                   -> VecPerParamSpace<T>\n+    {\n+        let types = self.read_to_vec(|this| Ok(f(this))).unwrap();\n+        let selfs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n+        let fns = self.read_to_vec(|this| Ok(f(this))).unwrap();\n+        VecPerParamSpace::new(types, selfs, fns)\n+    }\n+\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt,\n                                 cdata: &cstore::crate_metadata)\n@@ -718,10 +743,12 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-                      -> typeck::vtable_res {\n-        self.read_to_vec(|this| Ok(this.read_vtable_param_res(tcx, cdata)))\n-             .unwrap().move_iter().collect()\n+                       tcx: &ty::ctxt,\n+                       cdata: &cstore::crate_metadata)\n+                       -> typeck::vtable_res\n+    {\n+        self.read_vec_per_param_space(\n+            |this| this.read_vtable_param_res(tcx, cdata))\n     }\n \n     fn read_vtable_param_res(&mut self,\n@@ -737,7 +764,7 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n         self.read_enum(\"vtable_origin\", |this| {\n             this.read_enum_variant([\"vtable_static\",\n                                     \"vtable_param\",\n-                                    \"vtable_self\"],\n+                                    \"vtable_error\"],\n                                    |this, i| {\n                 Ok(match i {\n                   0 => {\n@@ -763,14 +790,28 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                         }).unwrap()\n                     )\n                   }\n-                  // hard to avoid - user input\n+                  2 => {\n+                    typeck::vtable_error\n+                  }\n                   _ => fail!(\"bad enum variant\")\n                 })\n             })\n         }).unwrap()\n     }\n }\n \n+// ___________________________________________________________________________\n+//\n+\n+fn encode_vec_per_param_space<T>(ebml_w: &mut Encoder,\n+                                 v: &subst::VecPerParamSpace<T>,\n+                                 f: |&mut Encoder, &T|) {\n+    for &space in subst::ParamSpace::all().iter() {\n+        ebml_w.emit_from_vec(v.get_vec(space).as_slice(),\n+                             |ebml_w, n| Ok(f(ebml_w, n))).unwrap();\n+    }\n+}\n+\n // ______________________________________________________________________\n // Encoding and decoding the side tables\n \n@@ -827,14 +868,15 @@ impl<'a> ebml_writer_helpers for Encoder<'a> {\n         self.emit_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n             this.emit_struct_field(\"generics\", 0, |this| {\n                 this.emit_struct(\"Generics\", 2, |this| {\n-                    this.emit_struct_field(\"type_param_defs\", 0, |this| {\n-                        this.emit_from_vec(tpbt.generics.type_param_defs(),\n-                                           |this, type_param_def| {\n-                            Ok(this.emit_type_param_def(ecx, type_param_def))\n-                        })\n+                    this.emit_struct_field(\"types\", 0, |this| {\n+                        Ok(encode_vec_per_param_space(\n+                            this, &tpbt.generics.types,\n+                            |this, def| this.emit_type_param_def(ecx, def)))\n                     });\n-                    this.emit_struct_field(\"region_param_defs\", 1, |this| {\n-                        tpbt.generics.region_param_defs().encode(this)\n+                    this.emit_struct_field(\"regions\", 1, |this| {\n+                        Ok(encode_vec_per_param_space(\n+                            this, &tpbt.generics.regions,\n+                            |this, def| def.encode(this).unwrap()))\n                     })\n                 })\n             });\n@@ -1186,22 +1228,17 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n                 generics: this.read_struct_field(\"generics\", 0, |this| {\n                     this.read_struct(\"Generics\", 2, |this| {\n                         Ok(ty::Generics {\n-                            type_param_defs:\n-                                this.read_struct_field(\"type_param_defs\",\n-                                                       0,\n-                                                       |this| {\n-                                    Ok(Rc::new(this.read_to_vec(|this|\n-                                                             Ok(this.read_type_param_def(xcx)))\n-                                                .unwrap()\n-                                                .move_iter()\n-                                                .collect()))\n+                            types:\n+                            this.read_struct_field(\"types\", 0, |this| {\n+                                Ok(this.read_vec_per_param_space(\n+                                    |this| this.read_type_param_def(xcx)))\n                             }).unwrap(),\n-                            region_param_defs:\n-                                this.read_struct_field(\"region_param_defs\",\n-                                                       1,\n-                                                       |this| {\n-                                    Decodable::decode(this)\n-                                }).unwrap()\n+\n+                            regions:\n+                            this.read_struct_field(\"regions\", 1, |this| {\n+                                Ok(this.read_vec_per_param_space(\n+                                    |this| Decodable::decode(this).unwrap()))\n+                            }).unwrap()\n                         })\n                     })\n                 }).unwrap(),"}, {"sha": "7ee8b33b1fa6713e6b0a597f1809d841ff027f35", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::subst::ParamSpace;\n use syntax::ast;\n use syntax::ast_util::local_def;\n \n@@ -27,7 +28,7 @@ pub enum Def {\n     DefTy(ast::DefId),\n     DefTrait(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n-    DefTyParam(ast::DefId, uint),\n+    DefTyParam(ParamSpace, ast::DefId, uint),\n     DefBinding(ast::NodeId, ast::BindingMode),\n     DefUse(ast::DefId),\n     DefUpvar(ast::NodeId,  // id of closed over var\n@@ -61,7 +62,7 @@ impl Def {\n         match *self {\n             DefFn(id, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n             DefForeignMod(id) | DefStatic(id, _) |\n-            DefVariant(_, id, _) | DefTy(id) | DefTyParam(id, _) |\n+            DefVariant(_, id, _) | DefTy(id) | DefTyParam(_, id, _) |\n             DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n                 id\n             }"}, {"sha": "9979f13093535263a723d56c6891ae5ceff61d9c", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 85, "deletions": 58, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -86,12 +86,9 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n                                     span: Span,\n                                     struct_did: DefId) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n-    if !struct_tpt.generics.has_type_params() {\n-        let struct_ty = ty::mk_struct(cx.tcx, struct_did, subst::Substs {\n-            regions: subst::NonerasedRegions(Vec::new()),\n-            self_ty: None,\n-            tps: Vec::new()\n-        });\n+    if !struct_tpt.generics.has_type_params(subst::TypeSpace) {\n+        let struct_ty = ty::mk_struct(cx.tcx, struct_did,\n+                                      subst::Substs::empty());\n         if !ty::type_is_sendable(cx.tcx, struct_ty) {\n             cx.tcx.sess.span_err(span,\n                                  \"cannot implement a destructor on a \\\n@@ -245,51 +242,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     debug!(\"kind::check_expr({})\", expr_to_str(e));\n \n     // Handle any kind bounds on type parameters\n-    {\n-        let method_map = cx.tcx.method_map.borrow();\n-        let method = method_map.find(&typeck::MethodCall::expr(e.id));\n-        let item_substs = cx.tcx.item_substs.borrow();\n-        let r = match method {\n-            Some(method) => Some(&method.substs.tps),\n-            None => item_substs.find(&e.id).map(|s| &s.substs.tps)\n-        };\n-        for ts in r.iter() {\n-            let def_map = cx.tcx.def_map.borrow();\n-            let type_param_defs = match e.node {\n-              ExprPath(_) => {\n-                let did = def_map.get_copy(&e.id).def_id();\n-                ty::lookup_item_type(cx.tcx, did).generics.type_param_defs.clone()\n-              }\n-              _ => {\n-                // Type substitutions should only occur on paths and\n-                // method calls, so this needs to be a method call.\n-\n-                // Even though the callee_id may have been the id with\n-                // node_type_substs, e.id is correct here.\n-                match method {\n-                    Some(method) => {\n-                        ty::method_call_type_param_defs(cx.tcx, method.origin)\n-                    }\n-                    None => {\n-                        cx.tcx.sess.span_bug(e.span,\n-                            \"non path/method call expr has type substs??\");\n-                    }\n-                }\n-              }\n-            };\n-            if ts.len() != type_param_defs.len() {\n-                // Fail earlier to make debugging easier\n-                fail!(\"internal error: in kind::check_expr, length \\\n-                      mismatch between actual and declared bounds: actual = \\\n-                      {}, declared = {}\",\n-                      ts.repr(cx.tcx),\n-                      type_param_defs.repr(cx.tcx));\n-            }\n-            for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n-                check_typaram_bounds(cx, e.span, ty, type_param_def)\n-            }\n-        }\n-    }\n+    check_bounds_on_type_parameters(cx, e);\n \n     match e.node {\n         ExprUnary(UnBox, ref interior) => {\n@@ -331,6 +284,77 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     visit::walk_expr(cx, e, ());\n }\n \n+fn check_bounds_on_type_parameters(cx: &mut Context, e: &Expr) {\n+    let method_map = cx.tcx.method_map.borrow();\n+    let method = method_map.find(&typeck::MethodCall::expr(e.id));\n+\n+    // Find the values that were provided (if any)\n+    let item_substs = cx.tcx.item_substs.borrow();\n+    let (types, is_object_call) = match method {\n+        Some(method) => {\n+            let is_object_call = match method.origin {\n+                typeck::MethodObject(..) => true,\n+                typeck::MethodStatic(..) | typeck::MethodParam(..) => false\n+            };\n+            (&method.substs.types, is_object_call)\n+        }\n+        None => {\n+            match item_substs.find(&e.id) {\n+                None => { return; }\n+                Some(s) => { (&s.substs.types, false) }\n+            }\n+        }\n+    };\n+\n+    // Find the relevant type parameter definitions\n+    let def_map = cx.tcx.def_map.borrow();\n+    let type_param_defs = match e.node {\n+        ExprPath(_) => {\n+            let did = def_map.get_copy(&e.id).def_id();\n+            ty::lookup_item_type(cx.tcx, did).generics.types.clone()\n+        }\n+        _ => {\n+            // Type substitutions should only occur on paths and\n+            // method calls, so this needs to be a method call.\n+\n+            // Even though the callee_id may have been the id with\n+            // node_type_substs, e.id is correct here.\n+            match method {\n+                Some(method) => {\n+                    ty::method_call_type_param_defs(cx.tcx, method.origin)\n+                }\n+                None => {\n+                    cx.tcx.sess.span_bug(e.span,\n+                                         \"non path/method call expr has type substs??\");\n+                }\n+            }\n+        }\n+    };\n+\n+    // Check that the value provided for each definition meets the\n+    // kind requirements\n+    for type_param_def in type_param_defs.iter() {\n+        let ty = *types.get(type_param_def.space, type_param_def.index);\n+\n+        // If this is a call to an object method (`foo.bar()` where\n+        // `foo` has a type like `Trait`), then the self type is\n+        // unknown (after all, this is a virtual call). In that case,\n+        // we will have put a ty_err in the substitutions, and we can\n+        // just skip over validating the bounds (because the bounds\n+        // would have been enforced when the object instance was\n+        // created).\n+        if is_object_call && type_param_def.space == subst::SelfSpace {\n+            assert_eq!(type_param_def.index, 0);\n+            assert!(ty::type_is_error(ty));\n+            continue;\n+        }\n+\n+        debug!(\"type_param_def space={} index={} ty={}\",\n+               type_param_def.space, type_param_def.index, ty.repr(cx.tcx));\n+        check_typaram_bounds(cx, e.span, ty, type_param_def)\n+    }\n+}\n+\n fn check_trait_cast(cx: &mut Context, source_ty: ty::t, target_ty: ty::t, span: Span) {\n     check_cast_for_escaping_regions(cx, source_ty, target_ty, span);\n     match ty::get(target_ty).sty {\n@@ -350,12 +374,10 @@ fn check_ty(cx: &mut Context, aty: &Ty) {\n                     let def_map = cx.tcx.def_map.borrow();\n                     let did = def_map.get_copy(&id).def_id();\n                     let generics = ty::lookup_item_type(cx.tcx, did).generics;\n-                    let type_param_defs = generics.type_param_defs();\n-                    for (&ty, type_param_def) in\n-                        item_substs.substs.tps.iter().zip(\n-                            type_param_defs.iter())\n-                    {\n-                        check_typaram_bounds(cx, aty.span, ty, type_param_def)\n+                    for def in generics.types.iter() {\n+                        let ty = *item_substs.substs.types.get(def.space,\n+                                                               def.index);\n+                        check_typaram_bounds(cx, aty.span, ty, def)\n                     }\n                 }\n             }\n@@ -555,7 +577,12 @@ pub fn check_cast_for_escaping_regions(\n         |ty| {\n             match ty::get(ty).sty {\n                 ty::ty_param(source_param) => {\n-                    if target_params.iter().any(|x| x == &source_param) {\n+                    if source_param.space == subst::SelfSpace {\n+                        // FIXME (#5723) -- there is no reason that\n+                        // Self should be exempt from this check,\n+                        // except for historical accident. Bottom\n+                        // line, we need proper region bounding.\n+                    } else if target_params.iter().any(|x| x == &source_param) {\n                         /* case (2) */\n                     } else {\n                         check_static(cx.tcx, ty, source_span); /* case (3) */"}, {"sha": "47bc2521689ae08c335aa0257ba076014a0de23e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -17,6 +17,7 @@ use middle::def::*;\n use middle::lang_items::LanguageItems;\n use middle::lint::{UnnecessaryQualification, UnusedImports};\n use middle::pat_util::pat_bindings;\n+use middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n use syntax::ast::*;\n@@ -227,25 +228,20 @@ enum FallbackSuggestion {\n }\n \n enum TypeParameters<'a> {\n-    NoTypeParameters,                   //< No type parameters.\n-    HasTypeParameters(&'a Generics,  //< Type parameters.\n-                      NodeId,          //< ID of the enclosing item\n-\n-                      // The index to start numbering the type parameters at.\n-                      // This is zero if this is the outermost set of type\n-                      // parameters, or equal to the number of outer type\n-                      // parameters. For example, if we have:\n-                      //\n-                      //   impl I<T> {\n-                      //     fn method<U>() { ... }\n-                      //   }\n-                      //\n-                      // The index at the method site will be 1, because the\n-                      // outer T had index 0.\n-                      uint,\n-\n-                      // The kind of the rib used for type parameters.\n-                      RibKind)\n+    NoTypeParameters,\n+    HasTypeParameters(\n+        // Type parameters.\n+        &'a Generics,\n+\n+        // Identifies the things that these parameters\n+        // were declared on (type, fn, etc)\n+        ParamSpace,\n+\n+        // ID of the enclosing item.\n+        NodeId,\n+\n+        // The kind of the rib used for type parameters.\n+        RibKind)\n }\n \n // The rib kind controls the translation of argument or local definitions\n@@ -1532,8 +1528,8 @@ impl<'a> Resolver<'a> {\n \n                 self.with_type_parameter_rib(\n                     HasTypeParameters(generics,\n+                                      FnSpace,\n                                       foreign_item.id,\n-                                      0,\n                                       NormalRibKind),\n                     f);\n             }\n@@ -3439,7 +3435,7 @@ impl<'a> Resolver<'a> {\n                   // If the def is a ty param, and came from the parent\n                   // item, it's ok\n                   match def {\n-                    DefTyParam(did, _) if {\n+                    DefTyParam(_, did, _) if {\n                         self.def_map.borrow().find(&did.node).map(|x| *x)\n                             == Some(DefTyParamBinder(item_id))\n                     } => {\n@@ -3574,8 +3570,8 @@ impl<'a> Resolver<'a> {\n                 // but maybe it's okay since the first time will signal an\n                 // error if there is one? -- tjc\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                               TypeSpace,\n                                                                item.id,\n-                                                               0,\n                                                                ItemRibKind),\n                                              |this| {\n                     visit::walk_item(this, item, ());\n@@ -3584,8 +3580,8 @@ impl<'a> Resolver<'a> {\n \n             ItemTy(_, ref generics) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                               TypeSpace,\n                                                                item.id,\n-                                                               0,\n                                                                ItemRibKind),\n                                              |this| {\n                     visit::walk_item(this, item, ());\n@@ -3615,8 +3611,8 @@ impl<'a> Resolver<'a> {\n \n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                               TypeSpace,\n                                                                item.id,\n-                                                               0,\n                                                                NormalRibKind),\n                                              |this| {\n                     this.resolve_type_parameters(&generics.ty_params);\n@@ -3636,8 +3632,8 @@ impl<'a> Resolver<'a> {\n                           ast::Required(ref ty_m) => {\n                             this.with_type_parameter_rib\n                                 (HasTypeParameters(&ty_m.generics,\n+                                                   FnSpace,\n                                                    item.id,\n-                                                   generics.ty_params.len(),\n                                         MethodRibKind(item.id, Required)),\n                                  |this| {\n \n@@ -3655,9 +3651,8 @@ impl<'a> Resolver<'a> {\n                           }\n                           ast::Provided(ref m) => {\n                               this.resolve_method(MethodRibKind(item.id,\n-                                                     Provided(m.id)),\n-                                                  &**m,\n-                                                  generics.ty_params.len())\n+                                                                Provided(m.id)),\n+                                                  &**m)\n                           }\n                         }\n                     }\n@@ -3687,7 +3682,7 @@ impl<'a> Resolver<'a> {\n                             ForeignItemFn(_, ref generics) => {\n                                 this.with_type_parameter_rib(\n                                     HasTypeParameters(\n-                                        generics, foreign_item.id, 0,\n+                                        generics, FnSpace, foreign_item.id,\n                                         ItemRibKind),\n                                     |this| visit::walk_foreign_item(this,\n                                                                 &**foreign_item,\n@@ -3708,8 +3703,8 @@ impl<'a> Resolver<'a> {\n                                       Some(fn_decl),\n                                       HasTypeParameters\n                                         (generics,\n+                                         FnSpace,\n                                          item.id,\n-                                         0,\n                                          ItemRibKind),\n                                       block);\n             }\n@@ -3730,7 +3725,7 @@ impl<'a> Resolver<'a> {\n                                type_parameters: TypeParameters,\n                                f: |&mut Resolver|) {\n         match type_parameters {\n-            HasTypeParameters(generics, node_id, initial_index,\n+            HasTypeParameters(generics, space, node_id,\n                               rib_kind) => {\n \n                 let function_type_rib = Rib::new(rib_kind);\n@@ -3739,9 +3734,9 @@ impl<'a> Resolver<'a> {\n                     let ident = type_parameter.ident;\n                     debug!(\"with_type_parameter_rib: {} {}\", node_id,\n                            type_parameter.id);\n-                    let def_like = DlDef(DefTyParam\n-                        (local_def(type_parameter.id),\n-                         index + initial_index));\n+                    let def_like = DlDef(DefTyParam(space,\n+                                                    local_def(type_parameter.id),\n+                                                    index));\n                     // Associate this type parameter with\n                     // the item that bound it\n                     self.record_def(type_parameter.id,\n@@ -3897,8 +3892,8 @@ impl<'a> Resolver<'a> {\n                       fields: &[StructField]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                       TypeSpace,\n                                                        id,\n-                                                       0,\n                                                        ItemRibKind),\n                                      |this| {\n             // Resolve the type parameters.\n@@ -3948,14 +3943,12 @@ impl<'a> Resolver<'a> {\n     // to be NormalRibKind?\n     fn resolve_method(&mut self,\n                       rib_kind: RibKind,\n-                      method: &Method,\n-                      outer_type_parameter_count: uint) {\n+                      method: &Method) {\n         let method_generics = &method.generics;\n-        let type_parameters =\n-            HasTypeParameters(method_generics,\n-                              method.id,\n-                              outer_type_parameter_count,\n-                              rib_kind);\n+        let type_parameters = HasTypeParameters(method_generics,\n+                                                FnSpace,\n+                                                method.id,\n+                                                rib_kind);\n \n         self.resolve_function(rib_kind, Some(method.decl), type_parameters, method.body);\n     }\n@@ -3992,16 +3985,15 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_implementation(&mut self,\n-                                  id: NodeId,\n-                                  generics: &Generics,\n-                                  opt_trait_reference: &Option<TraitRef>,\n-                                  self_type: &Ty,\n-                                  methods: &[Gc<Method>]) {\n+                              id: NodeId,\n+                              generics: &Generics,\n+                              opt_trait_reference: &Option<TraitRef>,\n+                              self_type: &Ty,\n+                              methods: &[Gc<Method>]) {\n         // If applicable, create a rib for the type parameters.\n-        let outer_type_parameter_count = generics.ty_params.len();\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                       TypeSpace,\n                                                        id,\n-                                                       0,\n                                                        NormalRibKind),\n                                      |this| {\n             // Resolve the type parameters.\n@@ -4016,8 +4008,7 @@ impl<'a> Resolver<'a> {\n                     for method in methods.iter() {\n                         // We also need a new scope for the method-specific type parameters.\n                         this.resolve_method(MethodRibKind(id, Provided(method.id)),\n-                                            &**method,\n-                                            outer_type_parameter_count);\n+                                            &**method);\n                     }\n                 });\n             });"}, {"sha": "f416686efd869e91caf111b4387e6ee9570f56f2", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -18,7 +18,7 @@\n  */\n \n use driver::session::Session;\n-use util::nodemap::NodeMap;\n+use middle::subst;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::owned_slice::OwnedSlice;\n@@ -27,10 +27,24 @@ use syntax::parse::token;\n use syntax::print::pprust::{lifetime_to_str};\n use syntax::visit;\n use syntax::visit::Visitor;\n+use util::nodemap::NodeMap;\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+pub enum DefRegion {\n+    DefStaticRegion,\n+    DefEarlyBoundRegion(/* space */ subst::ParamSpace,\n+                        /* index */ uint,\n+                        /* lifetime decl */ ast::NodeId),\n+    DefLateBoundRegion(/* binder_id */ ast::NodeId,\n+                       /* depth */ uint,\n+                       /* lifetime decl */ ast::NodeId),\n+    DefFreeRegion(/* block scope */ ast::NodeId,\n+                  /* lifetime decl */ ast::NodeId),\n+}\n \n // maps the id of each lifetime reference to the lifetime decl\n // that it corresponds to\n-pub type NamedRegionMap = NodeMap<ast::DefRegion>;\n+pub type NamedRegionMap = NodeMap<DefRegion>;\n \n // Returns an instance of some type that implements std::fmt::Show\n fn lifetime_show(lt_name: &ast::Name) -> token::InternedString {\n@@ -45,7 +59,7 @@ struct LifetimeContext<'a> {\n enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n-    EarlyScope(uint, &'a Vec<ast::Lifetime>, Scope<'a>),\n+    EarlyScope(subst::ParamSpace, &'a Vec<ast::Lifetime>, Scope<'a>),\n     /// LateScope(binder_id, ['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n     LateScope(ast::NodeId, &'a Vec<ast::Lifetime>, Scope<'a>),\n@@ -86,7 +100,7 @@ impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n             ast::ItemImpl(ref generics, _, _, _) |\n             ast::ItemTrait(ref generics, _, _, _) => {\n                 self.check_lifetime_names(&generics.lifetimes);\n-                EarlyScope(0, &generics.lifetimes, &root)\n+                EarlyScope(subst::TypeSpace, &generics.lifetimes, &root)\n             }\n         };\n         debug!(\"entering scope {:?}\", scope);\n@@ -152,33 +166,13 @@ impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n                           lifetime_ref: &ast::Lifetime,\n                           scope: Scope<'a>) {\n         if lifetime_ref.name == special_idents::statik.name {\n-            self.insert_lifetime(lifetime_ref, ast::DefStaticRegion);\n+            self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n         }\n         self.resolve_lifetime_ref(lifetime_ref, scope);\n     }\n }\n \n-impl<'a> ScopeChain<'a> {\n-    fn count_early_params(&self) -> uint {\n-        /*!\n-         * Counts the number of early-bound parameters that are in\n-         * scope.  Used when checking methods: the early-bound\n-         * lifetime parameters declared on the method are assigned\n-         * indices that come after the indices from the type.  Given\n-         * something like `impl<'a> Foo { ... fn bar<'b>(...) }`\n-         * then `'a` gets index 0 and `'b` gets index 1.\n-         */\n-\n-        match *self {\n-            RootScope => 0,\n-            EarlyScope(base, lifetimes, _) => base + lifetimes.len(),\n-            LateScope(_, _, s) => s.count_early_params(),\n-            BlockScope(_, _) => 0,\n-        }\n-    }\n-}\n-\n impl<'a> LifetimeContext<'a> {\n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n     fn visit_fn_decl(&mut self,\n@@ -212,22 +206,19 @@ impl<'a> LifetimeContext<'a> {\n \n         self.check_lifetime_names(&generics.lifetimes);\n \n-        let early_count = scope.count_early_params();\n         let referenced_idents = free_lifetimes(&generics.ty_params);\n         debug!(\"pushing fn scope id={} due to fn item/method\\\n-               referenced_idents={:?} \\\n-               early_count={}\",\n+               referenced_idents={:?}\",\n                n,\n-               referenced_idents.iter().map(lifetime_show).collect::<Vec<token::InternedString>>(),\n-               early_count);\n+               referenced_idents.iter().map(lifetime_show).collect::<Vec<token::InternedString>>());\n         if referenced_idents.is_empty() {\n             let scope1 = LateScope(n, &generics.lifetimes, scope);\n             walk(self, &scope1)\n         } else {\n             let (early, late) = generics.lifetimes.clone().partition(\n                 |l| referenced_idents.iter().any(|&i| i == l.name));\n \n-            let scope1 = EarlyScope(early_count, &early, scope);\n+            let scope1 = EarlyScope(subst::FnSpace, &early, scope);\n             let scope2 = LateScope(n, &late, &scope1);\n \n             walk(self, &scope2);\n@@ -256,11 +247,10 @@ impl<'a> LifetimeContext<'a> {\n                     break;\n                 }\n \n-                EarlyScope(base, lifetimes, s) => {\n+                EarlyScope(space, lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((offset, decl_id)) => {\n-                            let index = base + offset;\n-                            let def = ast::DefEarlyBoundRegion(index, decl_id);\n+                        Some((index, decl_id)) => {\n+                            let def = DefEarlyBoundRegion(space, index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -274,7 +264,7 @@ impl<'a> LifetimeContext<'a> {\n                 LateScope(binder_id, lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n                         Some((_index, decl_id)) => {\n-                            let def = ast::DefLateBoundRegion(binder_id, depth, decl_id);\n+                            let def = DefLateBoundRegion(binder_id, depth, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -325,7 +315,7 @@ impl<'a> LifetimeContext<'a> {\n \n         match search_result {\n             Some((_depth, decl_id)) => {\n-                let def = ast::DefFreeRegion(scope_id, decl_id);\n+                let def = DefFreeRegion(scope_id, decl_id);\n                 self.insert_lifetime(lifetime_ref, def);\n             }\n \n@@ -374,7 +364,7 @@ impl<'a> LifetimeContext<'a> {\n \n     fn insert_lifetime(&mut self,\n                        lifetime_ref: &ast::Lifetime,\n-                       def: ast::DefRegion) {\n+                       def: DefRegion) {\n         if lifetime_ref.id == ast::DUMMY_NODE_ID {\n             self.sess.span_bug(lifetime_ref.span,\n                                \"lifetime reference not renumbered, \\"}, {"sha": "7e26d9c79386e01fb2e6cccbc1301504eb4ffa50", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -231,7 +231,7 @@ impl <'l> DxrVisitor<'l> {\n             def::DefTyParamBinder(_) |\n             def::DefLabel(_) |\n             def::DefStaticMethod(_, _, _) |\n-            def::DefTyParam(_, _) |\n+            def::DefTyParam(..) |\n             def::DefUse(_) |\n             def::DefMethod(_, _) |\n             def::DefPrimTy(_) => {"}, {"sha": "5e7284dbfd1def1a5545c8ac173506d2e153c93c", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 369, "deletions": 84, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -15,75 +15,383 @@ use middle::ty_fold;\n use middle::ty_fold::{TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n+use std::iter::Chain;\n+use std::mem;\n+use std::raw;\n+use std::slice::{Items, MutItems};\n use std::vec::Vec;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n+\n+///////////////////////////////////////////////////////////////////////////\n+// HomogeneousTuple3 trait\n+//\n+// This could be moved into standard library at some point.\n+\n+trait HomogeneousTuple3<T> {\n+    fn len(&self) -> uint;\n+    fn as_slice<'a>(&'a self) -> &'a [T];\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T];\n+    fn iter<'a>(&'a self) -> Items<'a, T>;\n+    fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T>;\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n+}\n+\n+impl<T> HomogeneousTuple3<T> for (T, T, T) {\n+    fn len(&self) -> uint {\n+        3\n+    }\n+\n+    fn as_slice<'a>(&'a self) -> &'a [T] {\n+        unsafe {\n+            let ptr: *T = mem::transmute(self);\n+            let slice = raw::Slice { data: ptr, len: 3 };\n+            mem::transmute(slice)\n+        }\n+    }\n+\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        unsafe {\n+            let ptr: *T = mem::transmute(self);\n+            let slice = raw::Slice { data: ptr, len: 3 };\n+            mem::transmute(slice)\n+        }\n+    }\n+\n+    fn iter<'a>(&'a self) -> Items<'a, T> {\n+        let slice: &'a [T] = self.as_slice();\n+        slice.iter()\n+    }\n+\n+    fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> {\n+        self.as_mut_slice().mut_iter()\n+    }\n+\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n+        self.as_slice().get(index)\n+    }\n+\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n+        Some(&mut self.as_mut_slice()[index]) // wrong: fallible\n+    }\n+}\n \n ///////////////////////////////////////////////////////////////////////////\n \n+/**\n+ * A substitution mapping type/region parameters to new values. We\n+ * identify each in-scope parameter by an *index* and a *parameter\n+ * space* (which indices where the parameter is defined; see\n+ * `ParamSpace`).\n+ */\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n+pub struct Substs {\n+    pub types: VecPerParamSpace<ty::t>,\n+    pub regions: RegionSubsts,\n+}\n+\n /**\n  * Represents the values to use when substituting lifetime parameters.\n  * If the value is `ErasedRegions`, then this subst is occurring during\n  * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum RegionSubsts {\n     ErasedRegions,\n-    NonerasedRegions(Vec<ty::Region>)\n-}\n-\n-/**\n- * The type `Substs` represents the kinds of things that can be substituted to\n- * convert a polytype into a monotype.  Note however that substituting bound\n- * regions other than `self` is done through a different mechanism:\n- *\n- * - `tps` represents the type parameters in scope.  They are indexed\n- *   according to the order in which they were declared.\n- *\n- * - `self_r` indicates the region parameter `self` that is present on nominal\n- *   types (enums, structs) declared as having a region parameter.  `self_r`\n- *   should always be none for types that are not region-parameterized and\n- *   Some(_) for types that are.  The only bound region parameter that should\n- *   appear within a region-parameterized type is `self`.\n- *\n- * - `self_ty` is the type to which `self` should be remapped, if any.  The\n- *   `self` type is rather funny in that it can only appear on traits and is\n- *   always substituted away to the implementing type for a trait. */\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct Substs {\n-    pub self_ty: Option<ty::t>,\n-    pub tps: Vec<ty::t>,\n-    pub regions: RegionSubsts,\n+    NonerasedRegions(VecPerParamSpace<ty::Region>)\n }\n \n impl Substs {\n+    pub fn new(t: VecPerParamSpace<ty::t>,\n+               r: VecPerParamSpace<ty::Region>)\n+               -> Substs\n+    {\n+        Substs { types: t, regions: NonerasedRegions(r) }\n+    }\n+\n+    pub fn new_type(t: Vec<ty::t>,\n+                    r: Vec<ty::Region>)\n+                    -> Substs\n+    {\n+        Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new()),\n+                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n+    }\n+\n+    pub fn new_trait(t: Vec<ty::t>,\n+                     r: Vec<ty::Region>,\n+                     s: ty::t)\n+                    -> Substs\n+    {\n+        Substs::new(VecPerParamSpace::new(t, vec!(s), Vec::new()),\n+                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n+    }\n+\n+    pub fn erased(t: VecPerParamSpace<ty::t>) -> Substs\n+    {\n+        Substs { types: t, regions: ErasedRegions }\n+    }\n+\n     pub fn empty() -> Substs {\n         Substs {\n-            self_ty: None,\n-            tps: Vec::new(),\n-            regions: NonerasedRegions(Vec::new())\n+            types: VecPerParamSpace::empty(),\n+            regions: NonerasedRegions(VecPerParamSpace::empty()),\n         }\n     }\n \n     pub fn trans_empty() -> Substs {\n         Substs {\n-            self_ty: None,\n-            tps: Vec::new(),\n+            types: VecPerParamSpace::empty(),\n             regions: ErasedRegions\n         }\n     }\n \n     pub fn is_noop(&self) -> bool {\n         let regions_is_noop = match self.regions {\n             ErasedRegions => false, // may be used to canonicalize\n-            NonerasedRegions(ref regions) => regions.is_empty()\n+            NonerasedRegions(ref regions) => regions.is_empty(),\n         };\n \n-        self.tps.len() == 0u &&\n-            regions_is_noop &&\n-            self.self_ty.is_none()\n+        regions_is_noop && self.types.is_empty()\n+    }\n+\n+    pub fn self_ty(&self) -> Option<ty::t> {\n+        self.types.get_self().map(|&t| t)\n+    }\n+\n+    pub fn with_self_ty(&self, self_ty: ty::t) -> Substs {\n+        assert!(self.self_ty().is_none());\n+        let mut s = (*self).clone();\n+        s.types.push(SelfSpace, self_ty);\n+        s\n+    }\n+\n+    pub fn regions<'a>(&'a self) -> &'a VecPerParamSpace<ty::Region> {\n+        /*!\n+         * Since ErasedRegions are only to be used in trans, most of\n+         * the compiler can use this method to easily access the set\n+         * of region substitutions.\n+         */\n+\n+        match self.regions {\n+            ErasedRegions => fail!(\"Erased regions only expected in trans\"),\n+            NonerasedRegions(ref r) => r\n+        }\n     }\n \n-    pub fn self_ty(&self) -> ty::t {\n-        self.self_ty.unwrap()\n+    pub fn mut_regions<'a>(&'a mut self) -> &'a mut VecPerParamSpace<ty::Region> {\n+        /*!\n+         * Since ErasedRegions are only to be used in trans, most of\n+         * the compiler can use this method to easily access the set\n+         * of region substitutions.\n+         */\n+\n+        match self.regions {\n+            ErasedRegions => fail!(\"Erased regions only expected in trans\"),\n+            NonerasedRegions(ref mut r) => r\n+        }\n+    }\n+\n+    pub fn with_method_from(self, substs: &Substs) -> Substs {\n+        self.with_method((*substs.types.get_vec(FnSpace)).clone(),\n+                         (*substs.regions().get_vec(FnSpace)).clone())\n+    }\n+\n+    pub fn with_method(self,\n+                       m_types: Vec<ty::t>,\n+                       m_regions: Vec<ty::Region>)\n+                       -> Substs\n+    {\n+        let Substs { types, regions } = self;\n+        let types = types.with_vec(FnSpace, m_types);\n+        let regions = regions.map(m_regions,\n+                                  |r, m_regions| r.with_vec(FnSpace, m_regions));\n+        Substs { types: types, regions: regions }\n+    }\n+}\n+\n+impl RegionSubsts {\n+    fn map<A>(self,\n+              a: A,\n+              op: |VecPerParamSpace<ty::Region>, A| -> VecPerParamSpace<ty::Region>)\n+              -> RegionSubsts {\n+        match self {\n+            ErasedRegions => ErasedRegions,\n+            NonerasedRegions(r) => NonerasedRegions(op(r, a))\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// ParamSpace\n+\n+#[deriving(PartialOrd, Ord, PartialEq, Eq,\n+           Clone, Hash, Encodable, Decodable, Show)]\n+pub enum ParamSpace {\n+    TypeSpace, // Type parameters attached to a type definition, trait, or impl\n+    SelfSpace, // Self parameter on a trait\n+    FnSpace,   // Type parameters attached to a method or fn\n+}\n+\n+impl ParamSpace {\n+    pub fn all() -> [ParamSpace, ..3] {\n+        [TypeSpace, SelfSpace, FnSpace]\n+    }\n+\n+    pub fn to_uint(self) -> uint {\n+        match self {\n+            TypeSpace => 0,\n+            SelfSpace => 1,\n+            FnSpace => 2,\n+        }\n+    }\n+\n+    pub fn from_uint(u: uint) -> ParamSpace {\n+        match u {\n+            0 => TypeSpace,\n+            1 => SelfSpace,\n+            2 => FnSpace,\n+            _ => fail!(\"Invalid ParamSpace: {}\", u)\n+        }\n+    }\n+}\n+\n+/**\n+ * Vector of things sorted by param space. Used to keep\n+ * the set of things declared on the type, self, or method\n+ * distinct.\n+ */\n+#[deriving(PartialEq, Eq, Clone, Hash, Encodable, Decodable)]\n+pub struct VecPerParamSpace<T> {\n+    vecs: (Vec<T>, Vec<T>, Vec<T>)\n+}\n+\n+impl<T> VecPerParamSpace<T> {\n+    pub fn empty() -> VecPerParamSpace<T> {\n+        VecPerParamSpace {\n+            vecs: (Vec::new(), Vec::new(), Vec::new())\n+        }\n+    }\n+\n+    pub fn params_from_type(types: Vec<T>) -> VecPerParamSpace<T> {\n+        VecPerParamSpace::empty().with_vec(TypeSpace, types)\n+    }\n+\n+    pub fn new(t: Vec<T>, s: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n+        VecPerParamSpace {\n+            vecs: (t, s, f)\n+        }\n+    }\n+\n+    pub fn sort(t: Vec<T>, space: |&T| -> ParamSpace) -> VecPerParamSpace<T> {\n+        let mut result = VecPerParamSpace::empty();\n+        for t in t.move_iter() {\n+            result.push(space(&t), t);\n+        }\n+        result\n+    }\n+\n+    pub fn push(&mut self, space: ParamSpace, value: T) {\n+        self.get_mut_vec(space).push(value);\n+    }\n+\n+    pub fn get_self<'a>(&'a self) -> Option<&'a T> {\n+        let v = self.get_vec(SelfSpace);\n+        assert!(v.len() <= 1);\n+        if v.len() == 0 { None } else { Some(v.get(0)) }\n+    }\n+\n+    pub fn len(&self, space: ParamSpace) -> uint {\n+        self.get_vec(space).len()\n+    }\n+\n+    pub fn get_vec<'a>(&'a self, space: ParamSpace) -> &'a Vec<T> {\n+        self.vecs.get(space as uint).unwrap()\n+    }\n+\n+    pub fn get_mut_vec<'a>(&'a mut self, space: ParamSpace) -> &'a mut Vec<T> {\n+        self.vecs.get_mut(space as uint).unwrap()\n+    }\n+\n+    pub fn opt_get<'a>(&'a self,\n+                       space: ParamSpace,\n+                       index: uint)\n+                       -> Option<&'a T> {\n+        let v = self.get_vec(space);\n+        if index < v.len() { Some(v.get(index)) } else { None }\n+    }\n+\n+    pub fn get<'a>(&'a self, space: ParamSpace, index: uint) -> &'a T {\n+        self.get_vec(space).get(index)\n+    }\n+\n+    pub fn get_mut<'a>(&'a mut self,\n+                       space: ParamSpace,\n+                       index: uint) -> &'a mut T {\n+        self.get_mut_vec(space).get_mut(index)\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> Chain<Items<'a,T>,\n+                                       Chain<Items<'a,T>,\n+                                             Items<'a,T>>> {\n+        let (ref r, ref s, ref f) = self.vecs;\n+        r.iter().chain(s.iter().chain(f.iter()))\n+    }\n+\n+    pub fn all_vecs(&self, pred: |&Vec<T>| -> bool) -> bool {\n+        self.vecs.iter().all(pred)\n+    }\n+\n+    pub fn all(&self, pred: |&T| -> bool) -> bool {\n+        self.iter().all(pred)\n+    }\n+\n+    pub fn any(&self, pred: |&T| -> bool) -> bool {\n+        self.iter().any(pred)\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.all_vecs(|v| v.is_empty())\n+    }\n+\n+    pub fn map<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n+        VecPerParamSpace::new(self.vecs.ref0().iter().map(|p| pred(p)).collect(),\n+                              self.vecs.ref1().iter().map(|p| pred(p)).collect(),\n+                              self.vecs.ref2().iter().map(|p| pred(p)).collect())\n+    }\n+\n+    pub fn map_rev<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n+        /*!\n+         * Executes the map but in reverse order. For hacky reasons, we rely\n+         * on this in table.\n+         *\n+         * FIXME(#5527) -- order of eval becomes irrelevant with newer\n+         * trait reform, which features an idempotent algorithm that\n+         * can be run to a fixed point\n+         */\n+\n+        let mut fns: Vec<U> = self.vecs.ref2().iter().rev().map(|p| pred(p)).collect();\n+\n+        // NB: Calling foo.rev().map().rev() causes the calls to map\n+        // to occur in the wrong order. This was somewhat surprising\n+        // to me, though it makes total sense.\n+        fns.reverse();\n+\n+        let mut selfs: Vec<U> = self.vecs.ref1().iter().rev().map(|p| pred(p)).collect();\n+        selfs.reverse();\n+        let mut tys: Vec<U> = self.vecs.ref0().iter().rev().map(|p| pred(p)).collect();\n+        tys.reverse();\n+        VecPerParamSpace::new(tys, selfs, fns)\n+    }\n+\n+    pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>) {\n+        self.vecs\n+    }\n+\n+    pub fn with_vec(mut self, space: ParamSpace, vec: Vec<T>)\n+                    -> VecPerParamSpace<T>\n+    {\n+        assert!(self.get_vec(space).is_empty());\n+        *self.get_mut_vec(space) = vec;\n+        self\n     }\n }\n \n@@ -149,10 +457,10 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n         // the specialized routine\n         // `middle::typeck::check::regionmanip::replace_late_regions_in_fn_sig()`.\n         match r {\n-            ty::ReEarlyBound(_, i, _) => {\n+            ty::ReEarlyBound(_, space, i, _) => {\n                 match self.substs.regions {\n                     ErasedRegions => ty::ReStatic,\n-                    NonerasedRegions(ref regions) => *regions.get(i),\n+                    NonerasedRegions(ref regions) => *regions.get(space, i),\n                 }\n             }\n             _ => r\n@@ -173,52 +481,11 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n \n         let t1 = match ty::get(t).sty {\n             ty::ty_param(p) => {\n-                // FIXME -- This...really shouldn't happen. We should\n-                // never be substituting without knowing what's in\n-                // scope and knowing that the indices will line up!\n-                if p.idx < self.substs.tps.len() {\n-                    *self.substs.tps.get(p.idx)\n-                } else {\n-                    let root_msg = match self.root_ty {\n-                        Some(root) => format!(\" in the substitution of `{}`\",\n-                                              root.repr(self.tcx)),\n-                        None => \"\".to_string()\n-                    };\n-                    let m = format!(\"can't use type parameters from outer \\\n-                                    function{}; try using a local type \\\n-                                    parameter instead\",\n-                                    root_msg);\n-                    match self.span {\n-                        Some(span) => {\n-                            self.tcx.sess.span_err(span, m.as_slice())\n-                        }\n-                        None => self.tcx.sess.err(m.as_slice())\n-                    }\n-                    ty::mk_err()\n-                }\n+                check(self, t, self.substs.types.opt_get(p.space, p.idx))\n             }\n-            ty::ty_self(_) => {\n-                match self.substs.self_ty {\n-                    Some(ty) => ty,\n-                    None => {\n-                        let root_msg = match self.root_ty {\n-                            Some(root) => format!(\" in the substitution of `{}`\",\n-                                                  root.repr(self.tcx)),\n-                            None => \"\".to_string()\n-                        };\n-                        let m = format!(\"missing `Self` type param{}\",\n-                                        root_msg);\n-                        match self.span {\n-                            Some(span) => {\n-                                self.tcx.sess.span_err(span, m.as_slice())\n-                            }\n-                            None => self.tcx.sess.err(m.as_slice())\n-                        }\n-                        ty::mk_err()\n-                    }\n-                }\n+            _ => {\n+                ty_fold::super_fold_ty(self, t)\n             }\n-            _ => ty_fold::super_fold_ty(self, t)\n         };\n \n         assert_eq!(depth + 1, self.ty_stack_depth);\n@@ -227,6 +494,24 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n             self.root_ty = None;\n         }\n \n-        t1\n+        return t1;\n+\n+        fn check(this: &SubstFolder,\n+                 source_ty: ty::t,\n+                 opt_ty: Option<&ty::t>)\n+                 -> ty::t {\n+            match opt_ty {\n+                Some(t) => *t,\n+                None => {\n+                    let span = this.span.unwrap_or(DUMMY_SP);\n+                    this.tcx().sess.span_bug(\n+                        span,\n+                        format!(\"Type parameter {} out of range \\\n+                                 when substituting (root type={})\",\n+                                source_ty.repr(this.tcx()),\n+                                this.root_ty.repr(this.tcx())).as_slice());\n+                }\n+            }\n+        }\n     }\n }"}, {"sha": "3e15d5a1a615ab5c37be936d4bc64a51770b1c40", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -457,11 +457,11 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         did\n     };\n \n-    if !substs.tps.is_empty() || !substs.self_ty.is_none() {\n+    if !substs.types.is_empty() {\n         assert_eq!(did.krate, ast::LOCAL_CRATE);\n \n         let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx(), did.node, substs);\n-        let (val, _) = monomorphize::monomorphic_fn(ccx, did, substs, vtables, None, None);\n+        let (val, _) = monomorphize::monomorphic_fn(ccx, did, substs, vtables, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {"}, {"sha": "8b484e90898c97d2846080b80ca88efaa123b879", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -23,7 +23,7 @@ use lib::llvm::llvm;\n use metadata::csearch;\n use middle::def;\n use middle::subst;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, VecPerParamSpace};\n use middle::trans::base;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -198,45 +198,41 @@ fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n \n fn resolve_default_method_vtables(bcx: &Block,\n                                   impl_id: ast::DefId,\n-                                  method: &ty::Method,\n                                   substs: &subst::Substs,\n                                   impl_vtables: typeck::vtable_res)\n-                          -> (typeck::vtable_res, typeck::vtable_param_res)\n+                                  -> typeck::vtable_res\n {\n-\n     // Get the vtables that the impl implements the trait at\n     let impl_res = ty::lookup_impl_vtables(bcx.tcx(), impl_id);\n \n     // Build up a param_substs that we are going to resolve the\n     // trait_vtables under.\n     let param_substs = param_substs {\n         substs: (*substs).clone(),\n-        vtables: impl_vtables.clone(),\n-        self_vtables: None\n+        vtables: impl_vtables.clone()\n     };\n \n     let mut param_vtables = resolve_vtables_under_param_substs(\n-        bcx.tcx(), &param_substs, impl_res.trait_vtables.as_slice());\n+        bcx.tcx(), &param_substs, &impl_res);\n \n     // Now we pull any vtables for parameters on the actual method.\n-    let num_method_vtables = method.generics.type_param_defs().len();\n-    let num_impl_type_parameters = impl_vtables.len() - num_method_vtables;\n-    param_vtables.push_all(impl_vtables.tailn(num_impl_type_parameters));\n-\n-    let self_vtables = resolve_param_vtables_under_param_substs(\n-        bcx.tcx(), &param_substs, impl_res.self_vtables.as_slice());\n+    param_vtables\n+        .get_mut_vec(subst::FnSpace)\n+        .push_all(\n+            impl_vtables.get_vec(subst::FnSpace).as_slice());\n \n-    (param_vtables, self_vtables)\n+    param_vtables\n }\n \n \n pub fn trans_fn_ref_with_vtables(\n-        bcx: &Block,       //\n-        def_id: ast::DefId,   // def id of fn\n-        node: ExprOrMethodCall,  // node id of use of fn; may be zero if N/A\n-        substs: subst::Substs, // values for fn's ty params\n-        vtables: typeck::vtable_res) // vtables for the call\n-     -> ValueRef {\n+    bcx: &Block,                 //\n+    def_id: ast::DefId,          // def id of fn\n+    node: ExprOrMethodCall,      // node id of use of fn; may be zero if N/A\n+    substs: subst::Substs,       // values for fn's ty params\n+    vtables: typeck::vtable_res) // vtables for the call\n+    -> ValueRef\n+{\n     /*!\n      * Translates a reference to a fn/method item, monomorphizing and\n      * inlining as it goes.\n@@ -264,7 +260,7 @@ pub fn trans_fn_ref_with_vtables(\n            substs.repr(tcx),\n            vtables.repr(tcx));\n \n-    assert!(substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n+    assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n \n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n@@ -280,9 +276,9 @@ pub fn trans_fn_ref_with_vtables(\n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n-    let (is_default, def_id, substs, self_vtables, vtables) =\n+    let (is_default, def_id, substs, vtables) =\n         match ty::provided_source(tcx, def_id) {\n-        None => (false, def_id, substs, None, vtables),\n+        None => (false, def_id, substs, vtables),\n         Some(source_id) => {\n             // There are two relevant substitutions when compiling\n             // default methods. First, there is the substitution for\n@@ -305,7 +301,7 @@ pub fn trans_fn_ref_with_vtables(\n \n             // Compute the first substitution\n             let first_subst = make_substs_for_receiver_types(\n-                tcx, impl_id, &*trait_ref, &*method);\n+                tcx, &*trait_ref, &*method);\n \n             // And compose them\n             let new_substs = first_subst.subst(tcx, &substs);\n@@ -318,16 +314,14 @@ pub fn trans_fn_ref_with_vtables(\n                    first_subst.repr(tcx), new_substs.repr(tcx),\n                    vtables.repr(tcx));\n \n-            let (param_vtables, self_vtables) =\n-                resolve_default_method_vtables(bcx, impl_id,\n-                                               &*method, &substs, vtables);\n+            let param_vtables =\n+                resolve_default_method_vtables(bcx, impl_id, &substs, vtables);\n \n             debug!(\"trans_fn_with_vtables - default method: \\\n-                    self_vtable = {}, param_vtables = {}\",\n-                   self_vtables.repr(tcx), param_vtables.repr(tcx));\n+                    param_vtables = {}\",\n+                   param_vtables.repr(tcx));\n \n-            (true, source_id,\n-             new_substs, Some(self_vtables), param_vtables)\n+            (true, source_id, new_substs, param_vtables)\n         }\n     };\n \n@@ -345,7 +339,7 @@ pub fn trans_fn_ref_with_vtables(\n     // intrinsic, or is a default method.  In particular, if we see an\n     // intrinsic that is inlined from a different crate, we want to reemit the\n     // intrinsic instead of trying to call it in the other crate.\n-    let must_monomorphise = if substs.tps.len() > 0 || is_default {\n+    let must_monomorphise = if !substs.types.is_empty() || is_default {\n         true\n     } else if def_id.krate == ast::LOCAL_CRATE {\n         let map_node = session::expect(\n@@ -375,8 +369,7 @@ pub fn trans_fn_ref_with_vtables(\n \n         let (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs,\n-                                         vtables, self_vtables,\n-                                         opt_ref_id);\n+                                         vtables, opt_ref_id);\n         let mut val = val;\n         if must_cast && node != ExprId(0) {\n             // Monotype of the REFERENCE to the function (type params\n@@ -498,7 +491,7 @@ pub fn trans_lang_call<'a>(\n                                                                     did,\n                                                                     0,\n                                                                     subst::Substs::empty(),\n-                                                                    Vec::new())\n+                                                                    VecPerParamSpace::empty())\n                              },\n                              ArgVals(args),\n                              dest)"}, {"sha": "565ec7d8247106256fe7ba4935d388815d67141e", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -181,25 +181,18 @@ pub type ExternMap = HashMap<String, ValueRef>;\n pub struct param_substs {\n     pub substs: subst::Substs,\n     pub vtables: typeck::vtable_res,\n-    pub self_vtables: Option<typeck::vtable_param_res>\n }\n \n impl param_substs {\n     pub fn empty() -> param_substs {\n         param_substs {\n             substs: subst::Substs::trans_empty(),\n-            vtables: Vec::new(),\n-            self_vtables: None\n+            vtables: subst::VecPerParamSpace::empty(),\n         }\n     }\n \n     pub fn validate(&self) {\n-        for t in self.substs.tps.iter() {\n-            assert!(!ty::type_needs_infer(*t));\n-        }\n-        for t in self.substs.self_ty.iter() {\n-            assert!(!ty::type_needs_infer(*t));\n-        }\n+        assert!(self.substs.types.all(|t| !ty::type_needs_infer(*t)));\n     }\n }\n \n@@ -738,7 +731,7 @@ pub fn node_id_substs(bcx: &Block,\n         }\n     };\n \n-    if !substs.tps.iter().all(|t| !ty::type_needs_infer(*t)) {\n+    if substs.types.any(|t| ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n             format!(\"type parameters for node {:?} include inference types: \\\n                      {}\",\n@@ -752,14 +745,14 @@ pub fn node_id_substs(bcx: &Block,\n pub fn node_vtables(bcx: &Block, id: typeck::MethodCall)\n                  -> typeck::vtable_res {\n     bcx.tcx().vtable_map.borrow().find(&id).map(|vts| {\n-        resolve_vtables_in_fn_ctxt(bcx.fcx, vts.as_slice())\n-    }).unwrap_or_else(|| Vec::new())\n+        resolve_vtables_in_fn_ctxt(bcx.fcx, vts)\n+    }).unwrap_or_else(|| subst::VecPerParamSpace::empty())\n }\n \n // Apply the typaram substitutions in the FunctionContext to some\n // vtables. This should eliminate any vtable_params.\n pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext,\n-                                  vts: &[typeck::vtable_param_res])\n+                                  vts: &typeck::vtable_res)\n                                   -> typeck::vtable_res {\n     resolve_vtables_under_param_substs(fcx.ccx.tcx(),\n                                        fcx.param_substs,\n@@ -768,20 +761,21 @@ pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext,\n \n pub fn resolve_vtables_under_param_substs(tcx: &ty::ctxt,\n                                           param_substs: &param_substs,\n-                                          vts: &[typeck::vtable_param_res])\n-                                          -> typeck::vtable_res {\n-    vts.iter().map(|ds| {\n-      resolve_param_vtables_under_param_substs(tcx,\n-                                               param_substs,\n-                                               ds.as_slice())\n-    }).collect()\n-}\n-\n-pub fn resolve_param_vtables_under_param_substs(\n-    tcx: &ty::ctxt,\n-    param_substs: &param_substs,\n-    ds: &[typeck::vtable_origin])\n-    -> typeck::vtable_param_res {\n+                                          vts: &typeck::vtable_res)\n+                                          -> typeck::vtable_res\n+{\n+    vts.map(|ds| {\n+        resolve_param_vtables_under_param_substs(tcx,\n+                                                 param_substs,\n+                                                 ds)\n+    })\n+}\n+\n+pub fn resolve_param_vtables_under_param_substs(tcx: &ty::ctxt,\n+                                                param_substs: &param_substs,\n+                                                ds: &typeck::vtable_param_res)\n+                                                -> typeck::vtable_param_res\n+{\n     ds.iter().map(|d| {\n         resolve_vtable_under_param_substs(tcx,\n                                           param_substs,\n@@ -794,17 +788,20 @@ pub fn resolve_param_vtables_under_param_substs(\n pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n                                          param_substs: &param_substs,\n                                          vt: &typeck::vtable_origin)\n-                                         -> typeck::vtable_origin {\n+                                         -> typeck::vtable_origin\n+{\n     match *vt {\n         typeck::vtable_static(trait_id, ref vtable_substs, ref sub) => {\n             let vtable_substs = vtable_substs.substp(tcx, param_substs);\n             typeck::vtable_static(\n-                trait_id, vtable_substs,\n-                resolve_vtables_under_param_substs(tcx, param_substs, sub.as_slice()))\n+                trait_id,\n+                vtable_substs,\n+                resolve_vtables_under_param_substs(tcx, param_substs, sub))\n         }\n         typeck::vtable_param(n_param, n_bound) => {\n             find_vtable(tcx, param_substs, n_param, n_bound)\n         }\n+        typeck::vtable_error => typeck::vtable_error\n     }\n }\n \n@@ -816,12 +813,8 @@ pub fn find_vtable(tcx: &ty::ctxt,\n     debug!(\"find_vtable(n_param={:?}, n_bound={}, ps={})\",\n            n_param, n_bound, ps.repr(tcx));\n \n-    let param_bounds = match n_param {\n-        typeck::param_self => ps.self_vtables.as_ref().expect(\"self vtables missing\"),\n-        typeck::param_numbered(n) => {\n-            ps.vtables.get(n)\n-        }\n-    };\n+    let param_bounds = ps.vtables.get(n_param.space,\n+                                      n_param.index);\n     param_bounds.get(n_bound).clone()\n }\n "}, {"sha": "b5a002fd8247e2ff3364e5b63238cfe7f8a280c6", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -520,10 +520,11 @@ impl TypeMap {\n \n             // Maybe check that there is no self type here\n \n-            if substs.tps.len() > 0 {\n+            let tps = substs.types.get_vec(subst::TypeSpace);\n+            if tps.len() > 0 {\n                 output.push_char('<');\n \n-                for &type_parameter in substs.tps.iter() {\n+                for &type_parameter in tps.iter() {\n                     let param_type_id = type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id = type_map.get_unique_type_id_as_string(param_type_id);\n                     output.push_str(param_type_id.as_slice());\n@@ -1209,7 +1210,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                                file_metadata: DIFile,\n                                name_to_append_suffix_to: &mut String)\n                                -> DIArray {\n-        let self_type = param_substs.substs.self_ty;\n+        let self_type = param_substs.substs.self_ty();\n \n         // Only true for static default methods:\n         let has_self_type = self_type.is_some();\n@@ -1263,7 +1264,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         }\n \n         // Handle other generic parameters\n-        let actual_types = &param_substs.substs.tps;\n+        let actual_types = param_substs.substs.types.get_vec(subst::FnSpace);\n         for (index, &ast::TyParam{ ident: ident, .. }) in generics.ty_params.iter().enumerate() {\n             let actual_type = *actual_types.get(index);\n             // Add actual type name to <...> clause of function name\n@@ -2733,13 +2734,11 @@ fn trait_metadata(cx: &CrateContext,\n     let ident_string = token::get_name(last.name());\n     let mut name = ppaux::trait_store_to_str(cx.tcx(), trait_store);\n     name.push_str(ident_string.get());\n+\n     // Add type and region parameters\n-    let name = ppaux::parameterized(cx.tcx(),\n-                                    name.as_slice(),\n-                                    &substs.regions,\n-                                    substs.tps.as_slice(),\n-                                    def_id,\n-                                    true);\n+    let trait_def = ty::lookup_trait_def(cx.tcx(), def_id);\n+    let name = ppaux::parameterized(cx.tcx(), name.as_slice(),\n+                                    substs, &trait_def.generics);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n "}, {"sha": "095645f4d6b679ee33281c5cef5ac9ee6c7ae25b", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -118,18 +118,18 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.external.borrow_mut().insert(fn_id, Some(mth.id));\n             ccx.external_srcs.borrow_mut().insert(mth.id, fn_id);\n \n-          ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n+            ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n \n-          // If this is a default method, we can't look up the\n-          // impl type. But we aren't going to translate anyways, so don't.\n-          if is_provided { return local_def(mth.id); }\n+            // If this is a default method, we can't look up the\n+            // impl type. But we aren't going to translate anyways, so don't.\n+            if is_provided { return local_def(mth.id); }\n \n             let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n-            let num_type_params =\n-                impl_tpt.generics.type_param_defs().len() +\n-                mth.generics.ty_params.len();\n+            let unparameterized =\n+                impl_tpt.generics.types.is_empty() &&\n+                mth.generics.ty_params.is_empty();\n \n-          if num_type_params == 0 {\n+          if unparameterized {\n               let llfn = get_item_val(ccx, mth.id);\n               trans_fn(ccx, &*mth.decl, &*mth.body, llfn,\n                        &param_substs::empty(), mth.id, []);"}, {"sha": "5f37365e74353251c5ebdbe9da049cf2492a0176", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -14,6 +14,7 @@ use arena::TypedArena;\n use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n use lib::llvm::{ValueRef, Pointer, Array, Struct};\n use lib;\n+use middle::subst::FnSpace;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -295,7 +296,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             RetVoid(bcx);\n         }\n         \"size_of\" => {\n-            let tp_ty = *substs.substs.tps.get(0);\n+            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty) as uint));\n         }\n@@ -305,7 +306,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             // if the value is non-immediate. Note that, with\n             // intrinsics, there are no argument cleanups to\n             // concern ourselves with, so we can use an rvalue datum.\n-            let tp_ty = *substs.substs.tps.get(0);\n+            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n             let mode = appropriate_rvalue_mode(ccx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty,\n@@ -314,17 +315,17 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             RetVoid(bcx);\n         }\n         \"min_align_of\" => {\n-            let tp_ty = *substs.substs.tps.get(0);\n+            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty) as uint));\n         }\n         \"pref_align_of\"=> {\n-            let tp_ty = *substs.substs.tps.get(0);\n+            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty) as uint));\n         }\n         \"get_tydesc\" => {\n-            let tp_ty = *substs.substs.tps.get(0);\n+            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n             let static_ti = get_tydesc(ccx, tp_ty);\n             glue::lazily_emit_visit_glue(ccx, &*static_ti);\n \n@@ -339,7 +340,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         \"type_id\" => {\n             let hash = ty::hash_crate_independent(\n                 ccx.tcx(),\n-                *substs.substs.tps.get(0),\n+                *substs.substs.types.get(FnSpace, 0),\n                 &ccx.link_meta.crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n@@ -354,7 +355,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             }\n         }\n         \"init\" => {\n-            let tp_ty = *substs.substs.tps.get(0);\n+            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             match bcx.fcx.llretptr.get() {\n                 Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n@@ -364,7 +365,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         }\n         \"uninit\" => {\n             // Do nothing, this is effectively a no-op\n-            let retty = *substs.substs.tps.get(0);\n+            let retty = *substs.substs.types.get(FnSpace, 0);\n             if type_is_immediate(ccx, retty) && !return_type_is_void(ccx, retty) {\n                 unsafe {\n                     Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n@@ -377,8 +378,8 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             RetVoid(bcx);\n         }\n         \"transmute\" => {\n-            let (in_type, out_type) = (*substs.substs.tps.get(0),\n-                                       *substs.substs.tps.get(1));\n+            let (in_type, out_type) = (*substs.substs.types.get(FnSpace, 0),\n+                                       *substs.substs.types.get(FnSpace, 1));\n             let llintype = type_of::type_of(ccx, in_type);\n             let llouttype = type_of::type_of(ccx, out_type);\n \n@@ -447,11 +448,11 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             }\n         }\n         \"needs_drop\" => {\n-            let tp_ty = *substs.substs.tps.get(0);\n+            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n             Ret(bcx, C_bool(ccx, ty::type_needs_drop(ccx.tcx(), tp_ty)));\n         }\n         \"owns_managed\" => {\n-            let tp_ty = *substs.substs.tps.get(0);\n+            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n             Ret(bcx, C_bool(ccx, ty::type_contents(ccx.tcx(), tp_ty).owns_managed()));\n         }\n         \"visit_tydesc\" => {\n@@ -468,19 +469,26 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             Ret(bcx, lladdr);\n         }\n         \"copy_nonoverlapping_memory\" => {\n-            copy_intrinsic(bcx, false, false, *substs.substs.tps.get(0))\n+            copy_intrinsic(bcx, false, false, *substs.substs.types.get(FnSpace, 0))\n         }\n         \"copy_memory\" => {\n-            copy_intrinsic(bcx, true, false, *substs.substs.tps.get(0))\n+            copy_intrinsic(bcx, true, false, *substs.substs.types.get(FnSpace, 0))\n         }\n         \"set_memory\" => {\n-            memset_intrinsic(bcx, false, *substs.substs.tps.get(0))\n+            memset_intrinsic(bcx, false, *substs.substs.types.get(FnSpace, 0))\n         }\n \n-        \"volatile_copy_nonoverlapping_memory\" =>\n-            copy_intrinsic(bcx, false, true, *substs.substs.tps.get(0)),\n-        \"volatile_copy_memory\" => copy_intrinsic(bcx, true, true, *substs.substs.tps.get(0)),\n-        \"volatile_set_memory\" => memset_intrinsic(bcx, true, *substs.substs.tps.get(0)),\n+        \"volatile_copy_nonoverlapping_memory\" => {\n+            copy_intrinsic(bcx, false, true, *substs.substs.types.get(FnSpace, 0))\n+        }\n+\n+        \"volatile_copy_memory\" => {\n+            copy_intrinsic(bcx, true, true, *substs.substs.types.get(FnSpace, 0))\n+        }\n+\n+        \"volatile_set_memory\" => {\n+            memset_intrinsic(bcx, true, *substs.substs.types.get(FnSpace, 0))\n+        }\n \n         \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n         \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),"}, {"sha": "bde48b94473e6c8459cae7425f112f3e5dd010d9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 42, "deletions": 53, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -155,22 +155,6 @@ pub fn trans_static_method_callee(bcx: &Block,\n \n     ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trait_id);\n \n-    // When we translate a static fn defined in a trait like:\n-    //\n-    //   trait<T1...Tn> Trait {\n-    //       fn foo<M1...Mn>(...) {...}\n-    //   }\n-    //\n-    // this winds up being translated as something like:\n-    //\n-    //   fn foo<T1...Tn,self: Trait<T1...Tn>,M1...Mn>(...) {...}\n-    //\n-    // So when we see a call to this function foo, we have to figure\n-    // out which impl the `Trait<T1...Tn>` bound on the type `self` was\n-    // bound to.\n-    let bound_index = ty::lookup_trait_def(bcx.tcx(), trait_id).\n-        generics.type_param_defs().len();\n-\n     let mname = if method_id.krate == ast::LOCAL_CRATE {\n         match bcx.tcx().map.get(method_id.node) {\n             ast_map::NodeTraitMethod(method) => {\n@@ -189,18 +173,19 @@ pub fn trans_static_method_callee(bcx: &Block,\n             name={}\", method_id, expr_id, token::get_name(mname));\n \n     let vtable_key = MethodCall::expr(expr_id);\n-    let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, ccx.tcx.vtable_map.borrow()\n-                                                       .get(&vtable_key).as_slice());\n+    let vtbls = resolve_vtables_in_fn_ctxt(\n+        bcx.fcx,\n+        ccx.tcx.vtable_map.borrow().get(&vtable_key));\n \n-    match vtbls.move_iter().nth(bound_index).unwrap().move_iter().nth(0).unwrap() {\n-        typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n-            assert!(rcvr_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n+    match *vtbls.get_self().unwrap().get(0) {\n+        typeck::vtable_static(impl_did, ref rcvr_substs, ref rcvr_origins) => {\n+            assert!(rcvr_substs.types.all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n-                    bcx, mth_id, ExprId(expr_id),\n-                    rcvr_substs, rcvr_origins);\n+                    bcx, ExprId(expr_id),\n+                    (*rcvr_substs).clone(), (*rcvr_origins).clone());\n \n             let llfn = trans_fn_ref_with_vtables(bcx, mth_id, ExprId(expr_id),\n                                                  callee_substs,\n@@ -252,8 +237,7 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n           // those from the impl and those from the method:\n           let (callee_substs, callee_origins) =\n               combine_impl_and_methods_tps(\n-                  bcx, mth_id,  MethodCall(method_call),\n-                  rcvr_substs, rcvr_origins);\n+                  bcx, MethodCall(method_call), rcvr_substs, rcvr_origins);\n \n           // translate the function\n           let llfn = trans_fn_ref_with_vtables(bcx,\n@@ -265,13 +249,17 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n           Callee { bcx: bcx, data: Fn(llfn) }\n       }\n       typeck::vtable_param(..) => {\n-          fail!(\"vtable_param left in monomorphized function's vtable substs\");\n+          bcx.tcx().sess.bug(\n+              \"vtable_param left in monomorphized function's vtable substs\");\n+      }\n+      typeck::vtable_error => {\n+          bcx.tcx().sess.bug(\n+              \"vtable_error left in monomorphized function's vtable substs\");\n       }\n     }\n }\n \n fn combine_impl_and_methods_tps(bcx: &Block,\n-                                mth_did: ast::DefId,\n                                 node: ExprOrMethodCall,\n                                 rcvr_substs: subst::Substs,\n                                 rcvr_origins: typeck::vtable_res)\n@@ -295,38 +283,33 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n      */\n \n     let ccx = bcx.ccx();\n-    let method = ty::method(ccx.tcx(), mth_did);\n-    let n_m_tps = method.generics.type_param_defs().len();\n-    let node_substs = node_id_substs(bcx, node);\n-    debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx()));\n-    debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx()));\n-    let rcvr_self_ty = rcvr_substs.self_ty;\n-    let mut tps = rcvr_substs.tps;\n-    {\n-        let start = node_substs.tps.len() - n_m_tps;\n-        tps.extend(node_substs.tps.move_iter().skip(start));\n-    }\n-    debug!(\"n_m_tps={:?}\", n_m_tps);\n-    debug!(\"tps={}\", tps.repr(ccx.tcx()));\n-\n \n-    // Now, do the same work for the vtables.  The vtables might not\n-    // exist, in which case we need to make them.\n     let vtable_key = match node {\n         ExprId(id) => MethodCall::expr(id),\n         MethodCall(method_call) => method_call\n     };\n-    let mut vtables = rcvr_origins;\n-    let vt = node_vtables(bcx, vtable_key);\n-    let start = vt.len() - n_m_tps;\n-    vtables.extend(vt.move_iter().skip(start));\n+    let node_substs = node_id_substs(bcx, node);\n+    let node_vtables = node_vtables(bcx, vtable_key);\n+\n+    debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx()));\n+    debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx()));\n \n+    // Break apart the type parameters from the node and type\n+    // parameters from the receiver.\n+    let (_, _, node_method) = node_substs.types.split();\n+    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.clone().split();\n+    assert!(rcvr_method.is_empty());\n     let ty_substs = subst::Substs {\n-        tps: tps,\n         regions: subst::ErasedRegions,\n-        self_ty: rcvr_self_ty\n+        types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method)\n     };\n \n+    // Now do the same work for the vtables.\n+    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_origins.split();\n+    let (_, _, node_method) = node_vtables.split();\n+    assert!(rcvr_method.is_empty());\n+    let vtables = subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method);\n+\n     (ty_substs, vtables)\n }\n \n@@ -426,7 +409,12 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n fn get_vtable(bcx: &Block,\n               self_ty: ty::t,\n               origins: typeck::vtable_param_res)\n-              -> ValueRef {\n+              -> ValueRef\n+{\n+    debug!(\"get_vtable(self_ty={}, origins={})\",\n+           self_ty.repr(bcx.tcx()),\n+           origins.repr(bcx.tcx()));\n+\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n@@ -503,8 +491,9 @@ fn emit_vtable_methods(bcx: &Block,\n         debug!(\"(making impl vtable) emitting method {} at subst {}\",\n                m.repr(tcx),\n                substs.repr(tcx));\n-        if m.generics.has_type_params() ||\n-           ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n+        if m.generics.has_type_params(subst::FnSpace) ||\n+           ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone()))\n+        {\n             debug!(\"(making impl vtable) method has self or type params: {}\",\n                    token::get_ident(ident));\n             C_null(Type::nil(ccx).ptr_to())\n@@ -551,7 +540,7 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n         let vtable_map = ccx.tcx.vtable_map.borrow();\n         resolve_param_vtables_under_param_substs(ccx.tcx(),\n             bcx.fcx.param_substs,\n-            vtable_map.get(&MethodCall::expr(id)).get(0).as_slice())\n+            vtable_map.get(&MethodCall::expr(id)).get_self().unwrap())\n     };\n     let vtable = get_vtable(bcx, v_ty, origins);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);"}, {"sha": "125fa6828c5562c82fb719ea7b455d0d8eafacdf", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 59, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -33,32 +33,27 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                       fn_id: ast::DefId,\n                       real_substs: &subst::Substs,\n                       vtables: typeck::vtable_res,\n-                      self_vtables: Option<typeck::vtable_param_res>,\n                       ref_id: Option<ast::NodeId>)\n     -> (ValueRef, bool) {\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             real_substs={}, \\\n             vtables={}, \\\n-            self_vtable={}, \\\n             ref_id={:?})\",\n            fn_id.repr(ccx.tcx()),\n            real_substs.repr(ccx.tcx()),\n            vtables.repr(ccx.tcx()),\n-           self_vtables.repr(ccx.tcx()),\n            ref_id);\n \n-    assert!(real_substs.tps.iter().all(|t| {\n+    assert!(real_substs.types.all(|t| {\n         !ty::type_needs_infer(*t) && !ty::type_has_params(*t)\n     }));\n \n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n-    let substs_iter = real_substs.self_ty.iter().chain(real_substs.tps.iter());\n-    let param_ids: Vec<ty::t> = substs_iter.map(|t| *t).collect();\n     let hash_id = MonoId {\n         def: fn_id,\n-        params: param_ids\n+        params: real_substs.types.clone()\n     };\n \n     match ccx.monomorphized.borrow().find(&hash_id) {\n@@ -73,7 +68,6 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     let psubsts = param_substs {\n         substs: (*real_substs).clone(),\n         vtables: vtables,\n-        self_vtables: self_vtables\n     };\n \n     debug!(\"monomorphic_fn(\\\n@@ -87,10 +81,6 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     let tpt = ty::lookup_item_type(ccx.tcx(), fn_id);\n     let llitem_ty = tpt.ty;\n \n-    // We need to do special handling of the substitutions if we are\n-    // calling a static provided method. This is sort of unfortunate.\n-    let mut is_static_provided = None;\n-\n     let map_node = session::expect(\n         ccx.sess(),\n         ccx.tcx.map.find(fn_id.node),\n@@ -108,55 +98,11 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                 return (get_item_val(ccx, fn_id.node), true);\n             }\n         }\n-        ast_map::NodeTraitMethod(method) => {\n-            match *method {\n-                ast::Provided(m) => {\n-                    // If this is a static provided method, indicate that\n-                    // and stash the number of params on the method.\n-                    if m.explicit_self.node == ast::SelfStatic {\n-                        is_static_provided = Some(m.generics.ty_params.len());\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n         _ => {}\n     }\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n-    let mono_ty = match is_static_provided {\n-        None => llitem_ty.subst(ccx.tcx(), real_substs),\n-        Some(num_method_ty_params) => {\n-            // Static default methods are a little unfortunate, in\n-            // that the \"internal\" and \"external\" type of them differ.\n-            // Internally, the method body can refer to Self, but the\n-            // externally visible type of the method has a type param\n-            // inserted in between the trait type params and the\n-            // method type params. The substs that we are given are\n-            // the proper substs *internally* to the method body, so\n-            // we have to use those when compiling it.\n-            //\n-            // In order to get the proper substitution to use on the\n-            // type of the method, we pull apart the substitution and\n-            // stick a substitution for the self type in.\n-            // This is a bit unfortunate.\n-\n-            let idx = real_substs.tps.len() - num_method_ty_params;\n-            let mut tps = Vec::new();\n-            tps.push_all(real_substs.tps.slice(0, idx));\n-            tps.push(real_substs.self_ty.unwrap());\n-            tps.push_all(real_substs.tps.tailn(idx));\n-\n-            let substs = subst::Substs { regions: subst::ErasedRegions,\n-                                         self_ty: None,\n-                                         tps: tps };\n-\n-            debug!(\"static default: changed substitution to {}\",\n-                   substs.repr(ccx.tcx()));\n-\n-            llitem_ty.subst(ccx.tcx(), &substs)\n-        }\n-    };\n+    let mono_ty = llitem_ty.subst(ccx.tcx(), real_substs);\n \n     ccx.stats.n_monos.set(ccx.stats.n_monos.get() + 1);\n \n@@ -306,7 +252,7 @@ pub struct MonoParamId {\n #[deriving(PartialEq, Eq, Hash)]\n pub struct MonoId {\n     pub def: ast::DefId,\n-    pub params: Vec<ty::t>\n+    pub params: subst::VecPerParamSpace<ty::t>\n }\n \n pub fn make_vtable_id(_ccx: &CrateContext,\n@@ -316,7 +262,7 @@ pub fn make_vtable_id(_ccx: &CrateContext,\n         &typeck::vtable_static(impl_id, ref substs, _) => {\n             MonoId {\n                 def: impl_id,\n-                params: substs.tps.iter().map(|subst| *subst).collect()\n+                params: substs.types.clone()\n             }\n         }\n "}, {"sha": "f67fc57bb44073eb0c2cad07c06beab351c62ac1", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -366,7 +366,6 @@ impl<'a, 'b> Reflector<'a, 'b> {\n               let extra = vec!(self.c_uint(p.idx));\n               self.visit(\"param\", extra.as_slice())\n           }\n-          ty::ty_self(..) => self.leaf(\"self\")\n         }\n     }\n "}, {"sha": "4701a9e3225005c331be3d82bb80ea5f6867ad22", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -15,7 +15,6 @@ use middle::trans::adt;\n use middle::trans::common::*;\n use middle::trans::foreign;\n use middle::ty;\n-use util::ppaux;\n use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n@@ -152,7 +151,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n             }\n         }\n \n-        ty::ty_self(_) | ty::ty_infer(..) | ty::ty_param(..) |\n+        ty::ty_infer(..) | ty::ty_param(..) |\n         ty::ty_err(..) | ty::ty_vec(_, None) | ty::ty_str => {\n             cx.sess().bug(format!(\"fictitious type {:?} in sizing_type_of()\",\n                                   ty::get(t).sty).as_slice())\n@@ -205,7 +204,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         // avoids creating more than one copy of the enum when one\n         // of the enum's variants refers to the enum itself.\n         let repr = adt::represent_type(cx, t);\n-        let name = llvm_type_name(cx, an_enum, did, substs.tps.as_slice());\n+        let tps = substs.types.get_vec(subst::TypeSpace);\n+        let name = llvm_type_name(cx, an_enum, did, tps);\n         adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n       ty::ty_box(typ) => {\n@@ -260,17 +260,14 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               // in *after* placing it into the type cache. This prevents\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n-              let name = llvm_type_name(cx,\n-                                        a_struct,\n-                                        did,\n-                                        substs.tps.as_slice());\n+              let tps = substs.types.get_vec(subst::TypeSpace);\n+              let name = llvm_type_name(cx, a_struct, did, tps);\n               adt::incomplete_type_of(cx, &*repr, name.as_slice())\n           }\n       }\n \n       ty::ty_vec(_, None) => cx.sess().bug(\"type_of with unsized ty_vec\"),\n       ty::ty_str => cx.sess().bug(\"type_of with unsized (bare) ty_str\"),\n-      ty::ty_self(..) => cx.sess().unimpl(\"type_of with ty_self\"),\n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n       ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n       ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\")\n@@ -301,19 +298,17 @@ pub enum named_ty { a_struct, an_enum }\n pub fn llvm_type_name(cx: &CrateContext,\n                       what: named_ty,\n                       did: ast::DefId,\n-                      tps: &[ty::t])\n-                      -> String {\n+                      tps: &Vec<ty::t>)\n+                      -> String\n+{\n     let name = match what {\n         a_struct => { \"struct\" }\n         an_enum => { \"enum\" }\n     };\n-    let tstr = ppaux::parameterized(cx.tcx(),\n-                                    ty::item_path_str(cx.tcx(),\n-                                                      did).as_slice(),\n-                                    &subst::ErasedRegions,\n-                                    tps,\n-                                    did,\n-                                    false);\n+\n+    let base = ty::item_path_str(cx.tcx(), did);\n+    let strings: Vec<String> = tps.iter().map(|t| t.repr(cx.tcx())).collect();\n+    let tstr = format!(\"{}<{}>\", base, strings);\n     if did.krate == 0 {\n         format!(\"{}.{}\", name, tstr)\n     } else {"}, {"sha": "e3d94c73bb4e9bab52255bf00933bc6e64d4af05", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 134, "deletions": 145, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -24,7 +24,7 @@ use middle::freevars;\n use middle::resolve;\n use middle::resolve_lifetime;\n use middle::subst;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::ty;\n use middle::typeck;\n use middle::typeck::MethodCall;\n@@ -58,7 +58,6 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::parse::token::InternedString;\n use syntax::{ast, ast_map};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::util::small_vector::SmallVector;\n use std::collections::enum_set::{EnumSet, CLike};\n \n@@ -190,9 +189,8 @@ pub enum ast_ty_to_ty_cache_entry {\n \n #[deriving(Clone, PartialEq, Decodable, Encodable)]\n pub struct ItemVariances {\n-    pub self_param: Option<Variance>,\n-    pub type_params: OwnedSlice<Variance>,\n-    pub region_params: OwnedSlice<Variance>\n+    pub types: VecPerParamSpace<Variance>,\n+    pub regions: VecPerParamSpace<Variance>,\n }\n \n #[deriving(Clone, PartialEq, Decodable, Encodable, Show)]\n@@ -455,7 +453,8 @@ pub struct FnSig {\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct param_ty {\n+pub struct ParamTy {\n+    pub space: subst::ParamSpace,\n     pub idx: uint,\n     pub def_id: DefId\n }\n@@ -466,7 +465,10 @@ pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n     // parameters are substituted.\n-    ReEarlyBound(/* param id */ ast::NodeId, /*index*/ uint, ast::Name),\n+    ReEarlyBound(/* param id */ ast::NodeId,\n+                 subst::ParamSpace,\n+                 /*index*/ uint,\n+                 ast::Name),\n \n     // Region bound in a function scope, which will be substituted when the\n     // function is called. The first argument must be the `binder_id` of\n@@ -713,10 +715,7 @@ pub enum sty {\n     ty_struct(DefId, Substs),\n     ty_tup(Vec<t>),\n \n-    ty_param(param_ty), // type parameter\n-    ty_self(DefId), /* special, implicit `self` type parameter;\n-                      * def_id is the id of the trait */\n-\n+    ty_param(ParamTy), // type parameter\n     ty_infer(InferTy), // something used only during inference/typeck\n     ty_err, // Also only used during inference/typeck, to represent\n             // the type of an erroneous expression (helps cut down\n@@ -734,7 +733,7 @@ pub struct TyTrait {\n #[deriving(PartialEq, Eq, Hash)]\n pub struct TraitRef {\n     pub def_id: DefId,\n-    pub substs: Substs\n+    pub substs: Substs,\n }\n \n #[deriving(Clone, PartialEq)]\n@@ -964,6 +963,8 @@ impl fmt::Show for IntVarValue {\n pub struct TypeParameterDef {\n     pub ident: ast::Ident,\n     pub def_id: ast::DefId,\n+    pub space: subst::ParamSpace,\n+    pub index: uint,\n     pub bounds: Rc<ParamBounds>,\n     pub default: Option<ty::t>\n }\n@@ -972,29 +973,26 @@ pub struct TypeParameterDef {\n pub struct RegionParameterDef {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n+    pub space: subst::ParamSpace,\n+    pub index: uint,\n }\n \n-/// Information about the type/lifetime parameters associated with an item.\n-/// Analogous to ast::Generics.\n+/// Information about the type/lifetime parameters associated with an\n+/// item or method. Analogous to ast::Generics.\n #[deriving(Clone)]\n pub struct Generics {\n-    /// List of type parameters declared on the item.\n-    pub type_param_defs: Rc<Vec<TypeParameterDef>>,\n-\n-    /// List of region parameters declared on the item.\n-    /// For a fn or method, only includes *early-bound* lifetimes.\n-    pub region_param_defs: Rc<Vec<RegionParameterDef>>,\n+    pub types: VecPerParamSpace<TypeParameterDef>,\n+    pub regions: VecPerParamSpace<RegionParameterDef>,\n }\n \n impl Generics {\n-    pub fn has_type_params(&self) -> bool {\n-        !self.type_param_defs.is_empty()\n-    }\n-    pub fn type_param_defs<'a>(&'a self) -> &'a [TypeParameterDef] {\n-        self.type_param_defs.as_slice()\n+    pub fn empty() -> Generics {\n+        Generics { types: VecPerParamSpace::empty(),\n+                   regions: VecPerParamSpace::empty() }\n     }\n-    pub fn region_param_defs<'a>(&'a self) -> &'a [RegionParameterDef] {\n-        self.region_param_defs.as_slice()\n+\n+    pub fn has_type_params(&self, space: subst::ParamSpace) -> bool {\n+        !self.types.get_vec(space).is_empty()\n     }\n }\n \n@@ -1018,11 +1016,8 @@ pub struct ParameterEnvironment {\n     /// parameters in the same way, this only has an affect on regions.\n     pub free_substs: Substs,\n \n-    /// Bound on the Self parameter\n-    pub self_param_bound: Option<Rc<TraitRef>>,\n-\n-    /// Bounds on each numbered type parameter\n-    pub type_param_bounds: Vec<ParamBounds>,\n+    /// Bounds on the various type parameters\n+    pub bounds: VecPerParamSpace<ParamBounds>,\n }\n \n /// A polytype.\n@@ -1162,7 +1157,10 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     }\n     fn sflags(substs: &Substs) -> uint {\n         let mut f = 0u;\n-        for tt in substs.tps.iter() { f |= get(*tt).flags; }\n+        let mut i = substs.types.iter();\n+        for tt in i {\n+            f |= get(*tt).flags;\n+        }\n         match substs.regions {\n             subst::ErasedRegions => {}\n             subst::NonerasedRegions(ref regions) => {\n@@ -1185,9 +1183,14 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       // so we're doing it this way.\n       &ty_bot => flags |= has_ty_bot as uint,\n       &ty_err => flags |= has_ty_err as uint,\n-      &ty_param(_) => flags |= has_params as uint,\n+      &ty_param(ref p) => {\n+          if p.space == subst::SelfSpace {\n+              flags |= has_self as uint;\n+          } else {\n+              flags |= has_params as uint;\n+          }\n+      }\n       &ty_infer(_) => flags |= needs_infer as uint,\n-      &ty_self(_) => flags |= has_self as uint,\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n           flags |= sflags(substs);\n       }\n@@ -1455,10 +1458,16 @@ pub fn mk_float_var(cx: &ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n \n pub fn mk_infer(cx: &ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n \n-pub fn mk_self(cx: &ctxt, did: ast::DefId) -> t { mk_t(cx, ty_self(did)) }\n+pub fn mk_param(cx: &ctxt, space: subst::ParamSpace, n: uint, k: DefId) -> t {\n+    mk_t(cx, ty_param(ParamTy { space: space, idx: n, def_id: k }))\n+}\n+\n+pub fn mk_self_type(cx: &ctxt, did: ast::DefId) -> t {\n+    mk_param(cx, subst::SelfSpace, 0, did)\n+}\n \n-pub fn mk_param(cx: &ctxt, n: uint, k: DefId) -> t {\n-    mk_t(cx, ty_param(param_ty { idx: n, def_id: k }))\n+pub fn mk_param_from_def(cx: &ctxt, def: &TypeParameterDef) -> t {\n+    mk_param(cx, def.space, def.index, def.def_id)\n }\n \n pub fn walk_ty(ty: t, f: |t|) {\n@@ -1471,15 +1480,17 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     }\n     match get(ty).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_str | ty_self(_) |\n-        ty_infer(_) | ty_param(_) | ty_err => {}\n+        ty_str | ty_infer(_) | ty_param(_) | ty_err => {\n+        }\n         ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n         ty_ptr(ref tm) | ty_rptr(_, ref tm) | ty_vec(ref tm, _) => {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n         ty_trait(box TyTrait { ref substs, .. }) => {\n-            for subty in (*substs).tps.iter() { maybe_walk_ty(*subty, |x| f(x)); }\n+            for subty in (*substs).types.iter() {\n+                maybe_walk_ty(*subty, |x| f(x));\n+            }\n         }\n         ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n         ty_bare_fn(ref ft) => {\n@@ -1533,8 +1544,7 @@ pub fn type_needs_subst(ty: t) -> bool {\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n-    tref.substs.self_ty.iter().any(|&t| type_is_error(t)) ||\n-        tref.substs.tps.iter().any(|&t| type_is_error(t))\n+    tref.substs.types.any(|&t| type_is_error(t))\n }\n \n pub fn type_is_ty_var(ty: t) -> bool {\n@@ -1548,7 +1558,7 @@ pub fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n pub fn type_is_self(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_self(..) => true,\n+        ty_param(ref p) => p.space == subst::SelfSpace,\n         _ => false\n     }\n }\n@@ -2103,16 +2113,6 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                                         tp_def.bounds.trait_bounds.as_slice())\n             }\n \n-            ty_self(def_id) => {\n-                // FIXME(#4678)---self should just be a ty param\n-\n-                // Self may be bounded if the associated trait has builtin kinds\n-                // for supertraits. If so we can use those bounds.\n-                let trait_def = lookup_trait_def(cx, def_id);\n-                let traits = [trait_def.trait_ref.clone()];\n-                kind_bounds_to_contents(cx, trait_def.bounds, traits)\n-            }\n-\n             ty_infer(_) => {\n                 // This occurs during coherence, but shouldn't occur at other\n                 // times.\n@@ -2292,7 +2292,6 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             ty_infer(_) |\n             ty_err |\n             ty_param(_) |\n-            ty_self(_) |\n             ty_vec(_, None) => {\n                 false\n             }\n@@ -2688,6 +2687,14 @@ pub fn ty_region(tcx: &ctxt,\n     }\n }\n \n+pub fn free_region_from_def(free_id: ast::NodeId, def: &RegionParameterDef)\n+    -> ty::Region\n+{\n+    ty::ReFree(ty::FreeRegion { scope_id: free_id,\n+                                bound_region: ty::BrNamed(def.def_id,\n+                                                          def.name) })\n+}\n+\n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> t {\n@@ -2937,27 +2944,16 @@ impl AutoRef {\n }\n \n pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n-                                   -> Rc<Vec<TypeParameterDef>> {\n+                                   -> VecPerParamSpace<TypeParameterDef> {\n     match origin {\n         typeck::MethodStatic(did) => {\n-            // n.b.: When we encode impl methods, the bounds\n-            // that we encode include both the impl bounds\n-            // and then the method bounds themselves...\n-            ty::lookup_item_type(tcx, did).generics.type_param_defs\n+            ty::lookup_item_type(tcx, did).generics.types.clone()\n         }\n-        typeck::MethodParam(typeck::MethodParam {\n-            trait_id: trt_id,\n-            method_num: n_mth, ..}) |\n-        typeck::MethodObject(typeck::MethodObject {\n-            trait_id: trt_id,\n-            method_num: n_mth, ..}) => {\n-            // ...trait methods bounds, in contrast, include only the\n-            // method bounds, so we must preprend the tps from the\n-            // trait itself.  This ought to be harmonized.\n-            let trait_type_param_defs =\n-                Vec::from_slice(lookup_trait_def(tcx, trt_id).generics.type_param_defs());\n-            Rc::new(trait_type_param_defs.append(\n-                        ty::trait_method(tcx, trt_id, n_mth).generics.type_param_defs()))\n+        typeck::MethodParam(typeck::MethodParam{trait_id: trt_id,\n+                                                method_num: n_mth, ..}) |\n+        typeck::MethodObject(typeck::MethodObject{trait_id: trt_id,\n+                                                  method_num: n_mth, ..}) => {\n+            ty::trait_method(tcx, trt_id, n_mth).generics.types.clone()\n         }\n     }\n }\n@@ -3176,7 +3172,7 @@ pub fn method_idx(id: ast::Ident, meths: &[Rc<Method>]) -> Option<uint> {\n /// Returns a vector containing the indices of all type parameters that appear\n /// in `ty`.  The vector may contain duplicates.  Probably should be converted\n /// to a bitset or some other representation.\n-pub fn param_tys_in_type(ty: t) -> Vec<param_ty> {\n+pub fn param_tys_in_type(ty: t) -> Vec<ParamTy> {\n     let mut rslt = Vec::new();\n     walk_ty(ty, |ty| {\n         match get(ty).sty {\n@@ -3214,8 +3210,13 @@ pub fn ty_sort_str(cx: &ctxt, t: t) -> String {\n         ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n         ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n         ty_infer(FloatVar(_)) => \"floating-point variable\".to_string(),\n-        ty_param(_) => \"type parameter\".to_string(),\n-        ty_self(_) => \"self\".to_string(),\n+        ty_param(ref p) => {\n+            if p.space == subst::SelfSpace {\n+                \"Self\".to_string()\n+            } else {\n+                \"type parameter\".to_string()\n+            }\n+        }\n         ty_err => \"type error\".to_string(),\n     }\n }\n@@ -3821,7 +3822,7 @@ pub fn lookup_item_type(cx: &ctxt,\n \n pub fn lookup_impl_vtables(cx: &ctxt,\n                            did: ast::DefId)\n-                     -> typeck::impl_res {\n+                           -> typeck::vtable_res {\n     lookup_locally_or_in_crate_store(\n         \"impl_vtables\", did, &mut *cx.impl_vtables.borrow_mut(),\n         || csearch::get_impl_vtables(cx, did) )\n@@ -4103,8 +4104,7 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n                        substs: &subst::Substs)\n                        -> subst::Substs {\n             subst::Substs { regions: subst::ErasedRegions,\n-                            self_ty: substs.self_ty.fold_with(self),\n-                            tps: substs.tps.fold_with(self) }\n+                            types: substs.types.fold_with(self) }\n         }\n \n         fn fold_sig(&mut self,\n@@ -4252,11 +4252,7 @@ pub fn visitor_object_ty(tcx: &ctxt,\n         Ok(id) => id,\n         Err(s) => { return Err(s); }\n     };\n-    let substs = Substs {\n-        regions: subst::NonerasedRegions(Vec::new()),\n-        self_ty: None,\n-        tps: Vec::new()\n-    };\n+    let substs = Substs::empty();\n     let trait_ref = Rc::new(TraitRef { def_id: trait_lang_item, substs: substs });\n     Ok((trait_ref.clone(),\n         mk_trait(tcx,\n@@ -4582,10 +4578,6 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n                 hash!(p.idx);\n                 did(&mut state, p.def_id);\n             }\n-            ty_self(d) => {\n-                byte!(21);\n-                did(&mut state, d);\n-            }\n             ty_infer(_) => unreachable!(),\n             ty_err => byte!(23),\n         }\n@@ -4607,11 +4599,7 @@ impl Variance {\n \n pub fn construct_parameter_environment(\n     tcx: &ctxt,\n-    self_bound: Option<Rc<TraitRef>>,\n-    item_type_params: &[TypeParameterDef],\n-    method_type_params: &[TypeParameterDef],\n-    item_region_params: &[RegionParameterDef],\n-    method_region_params: &[RegionParameterDef],\n+    generics: &ty::Generics,\n     free_id: ast::NodeId)\n     -> ParameterEnvironment\n {\n@@ -4621,75 +4609,76 @@ pub fn construct_parameter_environment(\n     // Construct the free substs.\n     //\n \n-    // map Self => Self\n-    let self_ty = self_bound.as_ref().map(|t| ty::mk_self(tcx, t.def_id));\n-\n-    // map A => A\n-    let num_item_type_params = item_type_params.len();\n-    let num_method_type_params = method_type_params.len();\n-    let num_type_params = num_item_type_params + num_method_type_params;\n-    let type_params = Vec::from_fn(num_type_params, |i| {\n-            let def_id = if i < num_item_type_params {\n-                item_type_params[i].def_id\n-            } else {\n-                method_type_params[i - num_item_type_params].def_id\n-            };\n-\n-            ty::mk_param(tcx, i, def_id)\n-        });\n+    // map T => T\n+    let mut types = VecPerParamSpace::empty();\n+    for &space in subst::ParamSpace::all().iter() {\n+        push_types_from_defs(tcx, &mut types, space,\n+                             generics.types.get_vec(space));\n+    }\n \n     // map bound 'a => free 'a\n-    let region_params = {\n-        fn push_region_params(mut accum: Vec<ty::Region>,\n-                              free_id: ast::NodeId,\n-                              region_params: &[RegionParameterDef])\n-                              -> Vec<ty::Region> {\n-            for r in region_params.iter() {\n-                accum.push(\n-                    ty::ReFree(ty::FreeRegion {\n-                            scope_id: free_id,\n-                            bound_region: ty::BrNamed(r.def_id, r.name)}));\n-            }\n-            accum\n-        }\n-\n-        let t = push_region_params(vec!(), free_id, item_region_params);\n-        push_region_params(t, free_id, method_region_params)\n-    };\n+    let mut regions = VecPerParamSpace::empty();\n+    for &space in subst::ParamSpace::all().iter() {\n+        push_region_params(&mut regions, space, free_id,\n+                           generics.regions.get_vec(space));\n+    }\n \n     let free_substs = Substs {\n-        self_ty: self_ty,\n-        tps: type_params,\n-        regions: subst::NonerasedRegions(region_params)\n+        types: types,\n+        regions: subst::NonerasedRegions(regions)\n     };\n \n     //\n     // Compute the bounds on Self and the type parameters.\n     //\n \n-    let self_bound_substd = self_bound.map(|b| b.subst(tcx, &free_substs));\n-    let type_param_bounds_substd = Vec::from_fn(num_type_params, |i| {\n-        if i < num_item_type_params {\n-            (*item_type_params[i].bounds).subst(tcx, &free_substs)\n-        } else {\n-            let j = i - num_item_type_params;\n-            (*method_type_params[j].bounds).subst(tcx, &free_substs)\n-        }\n-    });\n+    let mut bounds = VecPerParamSpace::empty();\n+    for &space in subst::ParamSpace::all().iter() {\n+        push_bounds_from_defs(tcx, &mut bounds, space, &free_substs,\n+                              generics.types.get_vec(space));\n+    }\n \n     debug!(\"construct_parameter_environment: free_id={} \\\n            free_subst={} \\\n-           self_param_bound={} \\\n-           type_param_bound={}\",\n+           bounds={}\",\n            free_id,\n            free_substs.repr(tcx),\n-           self_bound_substd.repr(tcx),\n-           type_param_bounds_substd.repr(tcx));\n+           bounds.repr(tcx));\n \n-    ty::ParameterEnvironment {\n+    return ty::ParameterEnvironment {\n         free_substs: free_substs,\n-        self_param_bound: self_bound_substd,\n-        type_param_bounds: type_param_bounds_substd,\n+        bounds: bounds\n+    };\n+\n+    fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n+                          space: subst::ParamSpace,\n+                          free_id: ast::NodeId,\n+                          region_params: &Vec<RegionParameterDef>)\n+    {\n+        for r in region_params.iter() {\n+            regions.push(space, ty::free_region_from_def(free_id, r));\n+        }\n+    }\n+\n+    fn push_types_from_defs(tcx: &ty::ctxt,\n+                            types: &mut subst::VecPerParamSpace<ty::t>,\n+                            space: subst::ParamSpace,\n+                            defs: &Vec<TypeParameterDef>) {\n+        for (i, def) in defs.iter().enumerate() {\n+            let ty = ty::mk_param(tcx, space, i, def.def_id);\n+            types.push(space, ty);\n+        }\n+    }\n+\n+    fn push_bounds_from_defs(tcx: &ty::ctxt,\n+                             bounds: &mut subst::VecPerParamSpace<ParamBounds>,\n+                             space: subst::ParamSpace,\n+                             free_substs: &subst::Substs,\n+                             defs: &Vec<TypeParameterDef>) {\n+        for def in defs.iter() {\n+            let b = (*def.bounds).subst(tcx, free_substs);\n+            bounds.push(space, b);\n+        }\n     }\n }\n "}, {"sha": "e5fbe9df98f228228e3c39829d25b913ce8746be", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -11,6 +11,7 @@\n // Generalized type folding mechanism.\n \n use middle::subst;\n+use middle::subst::VecPerParamSpace;\n use middle::ty;\n use middle::typeck;\n use std::rc::Rc;\n@@ -127,6 +128,12 @@ impl<T:TypeFoldable> TypeFoldable for OwnedSlice<T> {\n     }\n }\n \n+impl<T:TypeFoldable> TypeFoldable for VecPerParamSpace<T> {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n+        self.map(|t| t.fold_with(folder))\n+    }\n+}\n+\n impl TypeFoldable for ty::TraitStore {\n     fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::TraitStore {\n         folder.fold_trait_store(*self)\n@@ -212,15 +219,9 @@ impl TypeFoldable for typeck::vtable_origin {\n             typeck::vtable_param(n, b) => {\n                 typeck::vtable_param(n, b)\n             }\n-        }\n-    }\n-}\n-\n-impl TypeFoldable for typeck::impl_res {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> typeck::impl_res {\n-        typeck::impl_res {\n-            trait_vtables: self.trait_vtables.fold_with(folder),\n-            self_vtables: self.self_vtables.fold_with(folder),\n+            typeck::vtable_error => {\n+                typeck::vtable_error\n+            }\n         }\n     }\n }\n@@ -245,6 +246,8 @@ impl TypeFoldable for ty::TypeParameterDef {\n         ty::TypeParameterDef {\n             ident: self.ident,\n             def_id: self.def_id,\n+            space: self.space,\n+            index: self.index,\n             bounds: self.bounds.fold_with(folder),\n             default: self.default.fold_with(folder),\n         }\n@@ -260,8 +263,8 @@ impl TypeFoldable for ty::RegionParameterDef {\n impl TypeFoldable for ty::Generics {\n     fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::Generics {\n         ty::Generics {\n-            type_param_defs: self.type_param_defs.fold_with(folder),\n-            region_param_defs: self.region_param_defs.fold_with(folder)\n+            types: self.types.fold_with(folder),\n+            regions: self.regions.fold_with(folder),\n         }\n     }\n }\n@@ -291,8 +294,7 @@ pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n     };\n \n     subst::Substs { regions: regions,\n-                    self_ty: substs.self_ty.fold_with(this),\n-                    tps: substs.tps.fold_with(this) }\n+                    types: substs.types.fold_with(this) }\n }\n \n pub fn super_fold_sig<T:TypeFolder>(this: &mut T,\n@@ -390,7 +392,7 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n         ty::ty_err | ty::ty_infer(_) |\n-        ty::ty_param(..) | ty::ty_self(_) => {\n+        ty::ty_param(..) => {\n             (*sty).clone()\n         }\n     }"}, {"sha": "83c5be238168a1f163ee8ede7eda4911d9af18a7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 70, "deletions": 55, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -52,6 +52,7 @@\n use middle::const_eval;\n use middle::def;\n use middle::lang_items::FnMutTraitLangItem;\n+use rl = middle::resolve_lifetime;\n use middle::subst::{Subst, Substs};\n use middle::subst;\n use middle::ty::ty_param_substs_and_ty;\n@@ -85,20 +86,20 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n             tcx.sess.span_bug(lifetime.span, \"unresolved lifetime\");\n         }\n \n-        Some(&ast::DefStaticRegion) => {\n+        Some(&rl::DefStaticRegion) => {\n             ty::ReStatic\n         }\n \n-        Some(&ast::DefLateBoundRegion(binder_id, _, id)) => {\n+        Some(&rl::DefLateBoundRegion(binder_id, _, id)) => {\n             ty::ReLateBound(binder_id, ty::BrNamed(ast_util::local_def(id),\n                                                    lifetime.name))\n         }\n \n-        Some(&ast::DefEarlyBoundRegion(index, id)) => {\n-            ty::ReEarlyBound(id, index, lifetime.name)\n+        Some(&rl::DefEarlyBoundRegion(space, index, id)) => {\n+            ty::ReEarlyBound(id, space, index, lifetime.name)\n         }\n \n-        Some(&ast::DefFreeRegion(scope_id, id)) => {\n+        Some(&rl::DefFreeRegion(scope_id, id)) => {\n             ty::ReFree(ty::FreeRegion {\n                     scope_id: scope_id,\n                     bound_region: ty::BrNamed(ast_util::local_def(id),\n@@ -163,10 +164,21 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n \n     let tcx = this.tcx();\n \n+    // ast_path_substs() is only called to convert paths that are\n+    // known to refer to traits, types, or structs. In these cases,\n+    // all type parameters defined for the item being referenced will\n+    // be in the TypeSpace or SelfSpace.\n+    //\n+    // Note: in the case of traits, the self parameter is also\n+    // defined, but we don't currently create a `type_param_def` for\n+    // `Self` because it is implicit.\n+    assert!(decl_generics.regions.all(|d| d.space == subst::TypeSpace));\n+    assert!(decl_generics.types.all(|d| d.space != subst::FnSpace));\n+\n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n-    let expected_num_region_params = decl_generics.region_param_defs().len();\n+    let expected_num_region_params = decl_generics.regions.len(subst::TypeSpace);\n     let supplied_num_region_params = path.segments.last().unwrap().lifetimes.len();\n     let regions = if expected_num_region_params == supplied_num_region_params {\n         path.segments.last().unwrap().lifetimes.iter().map(\n@@ -192,9 +204,10 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     };\n \n     // Convert the type parameters supplied by the user.\n+    let ty_param_defs = decl_generics.types.get_vec(subst::TypeSpace);\n     let supplied_ty_param_count = path.segments.iter().flat_map(|s| s.types.iter()).count();\n-    let formal_ty_param_count = decl_generics.type_param_defs().len();\n-    let required_ty_param_count = decl_generics.type_param_defs().iter()\n+    let formal_ty_param_count = ty_param_defs.len();\n+    let required_ty_param_count = ty_param_defs.iter()\n                                                .take_while(|x| x.default.is_none())\n                                                .count();\n     if supplied_ty_param_count < required_ty_param_count {\n@@ -233,37 +246,29 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n                             .map(|a_t| ast_ty_to_ty(this, rscope, &**a_t))\n                             .collect();\n \n-    let mut substs = subst::Substs {\n-        regions: subst::NonerasedRegions(regions),\n-        self_ty: self_ty,\n-        tps: tps\n-    };\n+    let mut substs = subst::Substs::new_type(tps, regions);\n \n-    for param in decl_generics.type_param_defs()\n-                              .slice_from(supplied_ty_param_count).iter() {\n-        let ty = param.default.unwrap().subst_spanned(tcx, &substs, Some(path.span));\n-        substs.tps.push(ty);\n+    match self_ty {\n+        None => {\n+            // If no self-type is provided, it's still possible that\n+            // one was declared, because this could be an object type.\n+        }\n+        Some(ty) => {\n+            // If a self-type is provided, one should have been\n+            // \"declared\" (in other words, this should be a\n+            // trait-ref).\n+            assert!(decl_generics.types.get_self().is_some());\n+            substs.types.push(subst::SelfSpace, ty);\n+        }\n     }\n \n-    substs\n-}\n-\n-pub fn ast_path_to_substs_and_ty<AC:AstConv,\n-                                 RS:RegionScope>(\n-                                 this: &AC,\n-                                 rscope: &RS,\n-                                 did: ast::DefId,\n-                                 path: &ast::Path)\n-                                 -> ty_param_substs_and_ty {\n-    let tcx = this.tcx();\n-    let ty::ty_param_bounds_and_ty {\n-        generics: generics,\n-        ty: decl_ty\n-    } = this.get_item_ty(did);\n+    for param in ty_param_defs.slice_from(supplied_ty_param_count).iter() {\n+        let default = param.default.unwrap();\n+        let default = default.subst_spanned(tcx, &substs, Some(path.span));\n+        substs.types.push(subst::TypeSpace, default);\n+    }\n \n-    let substs = ast_path_substs(this, rscope, &generics, None, path);\n-    let ty = decl_ty.subst(tcx, &substs);\n-    ty_param_substs_and_ty { substs: substs, ty: ty }\n+    substs\n }\n \n pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n@@ -286,12 +291,14 @@ pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n         path: &ast::Path)\n      -> ty_param_substs_and_ty\n {\n-    // Look up the polytype of the item and then substitute the provided types\n-    // for any type/region parameters.\n-    let ty::ty_param_substs_and_ty {\n-        substs: substs,\n-        ty: ty\n-    } = ast_path_to_substs_and_ty(this, rscope, did, path);\n+    let tcx = this.tcx();\n+    let ty::ty_param_bounds_and_ty {\n+        generics: generics,\n+        ty: decl_ty\n+    } = this.get_item_ty(did);\n+\n+    let substs = ast_path_substs(this, rscope, &generics, None, path);\n+    let ty = decl_ty.subst(tcx, &substs);\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n@@ -519,10 +526,12 @@ fn ast_ty_to_mt<AC:AstConv, RS:RegionScope>(this: &AC,\n \n pub fn trait_ref_for_unboxed_function<AC:AstConv,\n                                       RS:RegionScope>(\n-                                      this: &AC,\n-                                      rscope: &RS,\n-                                      unboxed_function: &ast::UnboxedFnTy)\n-                                      -> ty::TraitRef {\n+                                          this: &AC,\n+                                          rscope: &RS,\n+                                          unboxed_function: &ast::UnboxedFnTy,\n+                                          self_ty: Option<ty::t>)\n+    -> ty::TraitRef\n+{\n     let fn_mut_trait_did = this.tcx()\n                                .lang_items\n                                .require(FnMutTraitLangItem)\n@@ -538,11 +547,14 @@ pub fn trait_ref_for_unboxed_function<AC:AstConv,\n     let output_type = ast_ty_to_ty(this,\n                                    rscope,\n                                    &*unboxed_function.decl.output);\n-    let substs = subst::Substs {\n-        self_ty: None,\n-        tps: vec!(input_tuple, output_type),\n-        regions: subst::NonerasedRegions(Vec::new()),\n-    };\n+    let mut substs = subst::Substs::new_type(vec!(input_tuple, output_type),\n+                                             Vec::new());\n+\n+    match self_ty {\n+        Some(s) => substs.types.push(subst::SelfSpace, s),\n+        None => ()\n+    }\n+\n     ty::TraitRef {\n         def_id: fn_mut_trait_did,\n         substs: substs,\n@@ -590,7 +602,8 @@ fn mk_pointer<AC:AstConv,\n                 substs\n             } = trait_ref_for_unboxed_function(this,\n                                                rscope,\n-                                               &**unboxed_function);\n+                                               &**unboxed_function,\n+                                               None);\n             return ty::mk_trait(this.tcx(),\n                                 def_id,\n                                 substs,\n@@ -801,17 +814,17 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     def::DefTy(did) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n                     }\n-                    def::DefTyParam(id, n) => {\n+                    def::DefTyParam(space, id, n) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        ty::mk_param(tcx, n, id)\n+                        ty::mk_param(tcx, space, n, id)\n                     }\n                     def::DefSelfTy(id) => {\n                         // n.b.: resolve guarantees that the this type only appears in a\n                         // trait, which we rely upon in various places when creating\n                         // substs\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         let did = ast_util::local_def(id);\n-                        ty::mk_self(tcx, did)\n+                        ty::mk_self_type(tcx, did)\n                     }\n                     def::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n@@ -891,7 +904,9 @@ pub fn ty_of_method<AC:AstConv>(\n     fn_style: ast::FnStyle,\n     untransformed_self_ty: ty::t,\n     explicit_self: ast::ExplicitSelf,\n-    decl: &ast::FnDecl) -> ty::BareFnTy {\n+    decl: &ast::FnDecl)\n+    -> ty::BareFnTy\n+{\n     ty_of_method_or_bare_fn(this, id, fn_style, abi::Rust, Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: explicit_self"}, {"sha": "3933c30d5c98b787f892d26ef2b71026e423f4b0", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -127,7 +127,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n \n     // Check to see whether this is an enum or a struct.\n     match *structure_of(pcx.fcx, pat.span, expected) {\n-        ty::ty_enum(_, ref expected_substs) => {\n+        ty::ty_enum(expected_def_id, ref expected_substs) => {\n             // Lookup the enum and variant def ids:\n             let v_def = lookup_def(pcx.fcx, pat.span, pat.id);\n             match v_def.variant_def_ids() {\n@@ -150,18 +150,15 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                     arg_types = {\n                         let vinfo =\n                             ty::enum_variant_with_id(tcx, enm, var);\n-                        let var_tpt = ty::lookup_item_type(tcx, var);\n-                        vinfo.args.iter().map(|t| {\n-                            if var_tpt.generics.type_param_defs().len() ==\n-                                expected_substs.tps.len()\n-                            {\n-                                t.subst(tcx, expected_substs)\n-                            }\n-                            else {\n-                                *t // In this case, an error was already signaled\n-                                    // anyway\n-                            }\n-                        }).collect()\n+                        if enm == expected_def_id {\n+                            vinfo.args.iter()\n+                                .map(|t| t.subst(tcx, expected_substs))\n+                                .collect()\n+                        } else {\n+                            vinfo.args.iter()\n+                                .map(|_| ty::mk_err())\n+                                .collect()\n+                        }\n                     };\n \n                     kind_name = \"variant\";\n@@ -569,11 +566,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                                           fields.as_slice(),\n                                           etc,\n                                           supplied_def_id,\n-                                          &subst::Substs {\n-                                              self_ty: None,\n-                                              tps: Vec::new(),\n-                                              regions: subst::ErasedRegions,\n-                                          });\n+                                          &subst::Substs::empty());\n                     }\n                     _ => () // Error, but we're already in an error case\n                 }"}, {"sha": "aa6877584035def428b0fed06eac426271bc1241", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 57, "deletions": 80, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -91,7 +91,7 @@ use middle::typeck::infer;\n use middle::typeck::MethodCallee;\n use middle::typeck::{MethodOrigin, MethodParam};\n use middle::typeck::{MethodStatic, MethodObject};\n-use middle::typeck::{param_numbered, param_self, param_index};\n+use middle::typeck::{param_index};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use util::common::indenter;\n use util::ppaux;\n@@ -235,31 +235,36 @@ fn construct_transformed_self_ty_for_object(\n     trait_def_id: ast::DefId,\n     rcvr_substs: &subst::Substs,\n     method_ty: &ty::Method)\n-    -> ty::t {\n+    -> ty::t\n+{\n     /*!\n-        * This is a bit tricky. We have a match against a trait method\n-        * being invoked on an object, and we want to generate the\n-        * self-type. As an example, consider a trait\n-        *\n-        *     trait Foo {\n-        *         fn r_method<'a>(&'a self);\n-        *         fn u_method(Box<self>);\n-        *     }\n-        *\n-        * Now, assuming that `r_method` is being called, we want the\n-        * result to be `&'a Foo`. Assuming that `u_method` is being\n-        * called, we want the result to be `Box<Foo>`. Of course,\n-        * this transformation has already been done as part of\n-        * `method_ty.fty.sig.inputs[0]`, but there the type\n-        * is expressed in terms of `Self` (i.e., `&'a Self`, `Box<Self>`).\n-        * Because objects are not standalone types, we can't just substitute\n-        * `s/Self/Foo/`, so we must instead perform this kind of hokey\n-        * match below.\n-        */\n-\n-    let substs = subst::Substs {regions: rcvr_substs.regions.clone(),\n-                                self_ty: None,\n-                                tps: rcvr_substs.tps.clone()};\n+     * This is a bit tricky. We have a match against a trait method\n+     * being invoked on an object, and we want to generate the\n+     * self-type. As an example, consider a trait\n+     *\n+     *     trait Foo {\n+     *         fn r_method<'a>(&'a self);\n+     *         fn u_method(Box<self>);\n+     *     }\n+     *\n+     * Now, assuming that `r_method` is being called, we want the\n+     * result to be `&'a Foo`. Assuming that `u_method` is being\n+     * called, we want the result to be `Box<Foo>`. Of course,\n+     * this transformation has already been done as part of\n+     * `method_ty.fty.sig.inputs[0]`, but there the type\n+     * is expressed in terms of `Self` (i.e., `&'a Self`, `Box<Self>`).\n+     * Because objects are not standalone types, we can't just substitute\n+     * `s/Self/Foo/`, so we must instead perform this kind of hokey\n+     * match below.\n+     */\n+\n+    let mut obj_substs = rcvr_substs.clone();\n+\n+    // The subst we get in has Err as the \"Self\" type. For an object\n+    // type, we don't put any type into the Self paramspace, so let's\n+    // make a copy of rcvr_substs that has the Self paramspace empty.\n+    obj_substs.types.get_mut_vec(subst::SelfSpace).pop().unwrap();\n+\n     match method_ty.explicit_self {\n         ast::SelfStatic => {\n             tcx.sess.span_bug(span, \"static method for object type receiver\");\n@@ -271,13 +276,13 @@ fn construct_transformed_self_ty_for_object(\n             let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n             match ty::get(transformed_self_ty).sty {\n                 ty::ty_rptr(r, mt) => { // must be SelfRegion\n-                    let r = r.subst(tcx, &substs); // handle Early-Bound lifetime\n-                    ty::mk_trait(tcx, trait_def_id, substs,\n+                    let r = r.subst(tcx, rcvr_substs); // handle Early-Bound lifetime\n+                    ty::mk_trait(tcx, trait_def_id, obj_substs,\n                                  RegionTraitStore(r, mt.mutbl),\n                                  ty::empty_builtin_bounds())\n                 }\n                 ty::ty_uniq(_) => { // must be SelfUniq\n-                    ty::mk_trait(tcx, trait_def_id, substs,\n+                    ty::mk_trait(tcx, trait_def_id, obj_substs,\n                                  UniqTraitStore,\n                                  ty::empty_builtin_bounds())\n                 }\n@@ -456,11 +461,6 @@ impl<'a> LookupContext<'a> {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n                 }\n-                ty_self(..) => {\n-                    // Call is of the form \"self.foo()\" and appears in one\n-                    // of a trait's default method implementations.\n-                    self.push_inherent_candidates_from_self(self_ty, restrict_to);\n-                }\n                 _ => { /* No bound methods in these types */ }\n             }\n \n@@ -516,10 +516,7 @@ impl<'a> LookupContext<'a> {\n         //\n         // `confirm_candidate()` also relies upon this substitution\n         // for Self. (fix)\n-        let rcvr_substs = subst::Substs {\n-            self_ty: Some(ty::mk_err()),\n-            ..(*substs).clone()\n-        };\n+        let rcvr_substs = substs.with_self_ty(ty::mk_err());\n         let trait_ref = Rc::new(TraitRef {\n             def_id: did,\n             substs: rcvr_substs.clone()\n@@ -552,35 +549,27 @@ impl<'a> LookupContext<'a> {\n     fn push_inherent_candidates_from_param(&mut self,\n                                            rcvr_ty: ty::t,\n                                            restrict_to: Option<DefId>,\n-                                           param_ty: param_ty) {\n+                                           param_ty: ParamTy) {\n         debug!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n                param_ty);\n-        let i = param_ty.idx;\n-        match self.fcx.inh.param_env.type_param_bounds.as_slice().get(i) {\n-            Some(b) => self.push_inherent_candidates_from_bounds(\n-                            rcvr_ty, b.trait_bounds.as_slice(), restrict_to,\n-                            param_numbered(param_ty.idx)),\n-            None => {}\n-        }\n-    }\n-\n-\n-    fn push_inherent_candidates_from_self(&mut self,\n-                                          rcvr_ty: ty::t,\n-                                          restrict_to: Option<DefId>) {\n-        debug!(\"push_inherent_candidates_from_self()\");\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n-            [self.fcx.inh.param_env.self_param_bound.clone().unwrap()],\n+            param_ty.space,\n+            param_ty.idx,\n             restrict_to,\n-            param_self)\n+            param_index { space: param_ty.space, index: param_ty.idx });\n     }\n \n+\n     fn push_inherent_candidates_from_bounds(&mut self,\n                                             self_ty: ty::t,\n-                                            bounds: &[Rc<TraitRef>],\n+                                            space: subst::ParamSpace,\n+                                            index: uint,\n                                             restrict_to: Option<DefId>,\n                                             param: param_index) {\n+        let bounds =\n+            self.fcx.inh.param_env.bounds.get(space, index).trait_bounds\n+            .as_slice();\n         self.push_inherent_candidates_from_bounds_inner(bounds,\n             |trait_ref, m, method_num, bound_num| {\n                 match restrict_to {\n@@ -937,7 +926,7 @@ impl<'a> LookupContext<'a> {\n             ty_bare_fn(..) | ty_box(..) | ty_uniq(..) | ty_rptr(..) |\n             ty_infer(IntVar(_)) |\n             ty_infer(FloatVar(_)) |\n-            ty_self(_) | ty_param(..) | ty_nil | ty_bot | ty_bool |\n+            ty_param(..) | ty_nil | ty_bot | ty_bool |\n             ty_char | ty_int(..) | ty_uint(..) |\n             ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) | ty_tup(..) |\n             ty_str | ty_vec(..) | ty_trait(..) | ty_closure(..) => {\n@@ -1093,7 +1082,8 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n-                         -> MethodCallee {\n+                         -> MethodCallee\n+    {\n         // This method performs two sets of substitutions, one after the other:\n         // 1. Substitute values for any type/lifetime parameters from the impl and\n         //    method declaration into the method type. This is the function type\n@@ -1117,8 +1107,8 @@ impl<'a> LookupContext<'a> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_tps = self.supplied_tps.len();\n-        let num_method_tps = candidate.method_ty.generics.type_param_defs().len();\n-        let m_substs = {\n+        let num_method_tps = candidate.method_ty.generics.types.len(subst::FnSpace);\n+        let m_types = {\n             if num_supplied_tps == 0u {\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else if num_method_tps == 0u {\n@@ -1129,37 +1119,23 @@ impl<'a> LookupContext<'a> {\n             } else if num_supplied_tps != num_method_tps {\n                 tcx.sess.span_err(\n                     self.span,\n-                    \"incorrect number of type \\\n-                     parameters given for this method\");\n+                    \"incorrect number of type parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else {\n                 Vec::from_slice(self.supplied_tps)\n             }\n         };\n \n-        // Determine values for the early-bound lifetime parameters.\n+        // Create subst for early-bound lifetime parameters, combining\n+        // parameters from the type and those from the method.\n+        //\n         // FIXME -- permit users to manually specify lifetimes\n-        let mut all_regions: Vec<Region> = match candidate.rcvr_substs.regions {\n-            subst::NonerasedRegions(ref v) => {\n-                v.iter().map(|r| r.clone()).collect()\n-            }\n-            subst::ErasedRegions => tcx.sess.span_bug(self.span, \"ErasedRegions\")\n-        };\n         let m_regions =\n             self.fcx.infcx().region_vars_for_defs(\n                 self.span,\n-                candidate.method_ty.generics.region_param_defs.as_slice());\n-        for &r in m_regions.iter() {\n-            all_regions.push(r);\n-        }\n+                candidate.method_ty.generics.regions.get_vec(subst::FnSpace));\n \n-        // Construct the full set of type parameters for the method,\n-        // which is equal to the class tps + the method tps.\n-        let all_substs = subst::Substs {\n-            tps: candidate.rcvr_substs.tps.clone().append(m_substs.as_slice()),\n-            regions: subst::NonerasedRegions(all_regions),\n-            self_ty: candidate.rcvr_substs.self_ty,\n-        };\n+        let all_substs = candidate.rcvr_substs.clone().with_method(m_types, m_regions);\n \n         let ref bare_fn_ty = candidate.method_ty.fty;\n \n@@ -1285,7 +1261,8 @@ impl<'a> LookupContext<'a> {\n             check_for_self_ty(sig.output);\n         }\n \n-        if candidate.method_ty.generics.has_type_params() { // reason (b) above\n+        if candidate.method_ty.generics.has_type_params(subst::FnSpace) {\n+            // reason (b) above\n             self.tcx().sess.span_err(\n                 self.span,\n                 \"cannot call a generic method through an object\");"}, {"sha": "544990d19a51a402038a21a13f7641d403e8bd91", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 453, "deletions": 459, "changes": 912, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -83,10 +83,10 @@ use middle::lint::UnreachableCode;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::subst;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n-use middle::ty::{param_ty, Disr, ExprTyProvider};\n+use middle::ty::{ParamTy, Disr, ExprTyProvider};\n use middle::ty;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n@@ -285,8 +285,7 @@ fn blank_inherited_fields<'a>(ccx: &'a CrateCtxt<'a>) -> Inherited<'a> {\n     // and statement context, but we might as well do write the code only once\n     let param_env = ty::ParameterEnvironment {\n         free_substs: subst::Substs::empty(),\n-        self_param_bound: None,\n-        type_param_bounds: Vec::new()\n+        bounds: subst::VecPerParamSpace::empty()\n     };\n     Inherited::new(ccx.tcx, param_env)\n }\n@@ -453,9 +452,9 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n     let arg_tys = fn_sig.inputs.as_slice();\n     let ret_ty = fn_sig.output;\n \n-    debug!(\"check_fn(arg_tys={:?}, ret_ty={:?})\",\n-           arg_tys.iter().map(|&a| ppaux::ty_to_str(tcx, a)).collect::<Vec<String>>(),\n-           ppaux::ty_to_str(tcx, ret_ty));\n+    debug!(\"check_fn(arg_tys={}, ret_ty={})\",\n+           arg_tys.repr(tcx),\n+           ret_ty.repr(tcx));\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n@@ -647,14 +646,9 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n         let fn_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n \n-        let param_env = ty::construct_parameter_environment(\n-                ccx.tcx,\n-                None,\n-                fn_tpt.generics.type_param_defs(),\n-                [],\n-                [],\n-                fn_tpt.generics.region_param_defs.as_slice(),\n-                body.id);\n+        let param_env = ty::construct_parameter_environment(ccx.tcx,\n+                                                            &fn_tpt.generics,\n+                                                            body.id);\n \n         check_bare_fn(ccx, &**decl, &**body, it.id, fn_tpt.ty, param_env);\n       }\n@@ -663,7 +657,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n         let impl_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         for m in ms.iter() {\n-            check_method_body(ccx, &impl_tpt.generics, None, &**m);\n+            check_method_body(ccx, &impl_tpt.generics, &**m);\n         }\n \n         match *opt_trait_ref {\n@@ -672,7 +666,6 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                     ty::node_id_to_trait_ref(ccx.tcx, ast_trait_ref.ref_id);\n                 check_impl_methods_against_trait(ccx,\n                                              it.span,\n-                                             &impl_tpt.generics,\n                                              ast_trait_ref,\n                                              &*impl_trait_ref,\n                                              ms.as_slice());\n@@ -691,8 +684,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                     // bodies to check.\n                 }\n                 Provided(m) => {\n-                    check_method_body(ccx, &trait_def.generics,\n-                                      Some(trait_def.trait_ref.clone()), &*m);\n+                    check_method_body(ccx, &trait_def.generics, &*m);\n                 }\n             }\n         }\n@@ -712,7 +704,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         } else {\n             for item in m.items.iter() {\n                 let tpt = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n-                if tpt.generics.has_type_params() {\n+                if !tpt.generics.types.is_empty() {\n                     ccx.tcx.sess.span_err(item.span, \"foreign items may not have type parameters\");\n                 }\n \n@@ -734,7 +726,6 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n fn check_method_body(ccx: &CrateCtxt,\n                      item_generics: &ty::Generics,\n-                     self_bound: Option<Rc<ty::TraitRef>>,\n                      method: &ast::Method) {\n     /*!\n      * Type checks a method body.\n@@ -746,25 +737,16 @@ fn check_method_body(ccx: &CrateCtxt,\n      * - `method`: the method definition\n      */\n \n-    debug!(\"check_method_body(item_generics={}, \\\n-            self_bound={}, \\\n-            method.id={})\",\n+    debug!(\"check_method_body(item_generics={}, method.id={})\",\n             item_generics.repr(ccx.tcx),\n-            self_bound.repr(ccx.tcx),\n             method.id);\n     let method_def_id = local_def(method.id);\n     let method_ty = ty::method(ccx.tcx, method_def_id);\n     let method_generics = &method_ty.generics;\n \n-    let param_env =\n-        ty::construct_parameter_environment(\n-            ccx.tcx,\n-            self_bound,\n-            item_generics.type_param_defs(),\n-            method_generics.type_param_defs(),\n-            item_generics.region_param_defs(),\n-            method_generics.region_param_defs(),\n-            method.body.id);\n+    let param_env = ty::construct_parameter_environment(ccx.tcx,\n+                                                        method_generics,\n+                                                        method.body.id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n \n@@ -773,7 +755,6 @@ fn check_method_body(ccx: &CrateCtxt,\n \n fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n                                     impl_span: Span,\n-                                    impl_generics: &ty::Generics,\n                                     ast_trait_ref: &ast::TraitRef,\n                                     impl_trait_ref: &ty::TraitRef,\n                                     impl_methods: &[Gc<ast::Method>]) {\n@@ -795,7 +776,6 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n         match opt_trait_method_ty {\n             Some(trait_method_ty) => {\n                 compare_impl_method(ccx.tcx,\n-                                    impl_generics,\n                                     &*impl_method_ty,\n                                     impl_method.span,\n                                     impl_method.body.id,\n@@ -849,20 +829,17 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n  * - impl_m_span: span to use for reporting errors\n  * - impl_m_body_id: id of the method body\n  * - trait_m: the method in the trait\n- * - trait_substs: the substitutions used on the type of the trait\n+ * - trait_to_impl_substs: the substitutions used on the type of the trait\n  */\n fn compare_impl_method(tcx: &ty::ctxt,\n-                       impl_generics: &ty::Generics,\n                        impl_m: &ty::Method,\n                        impl_m_span: Span,\n                        impl_m_body_id: ast::NodeId,\n                        trait_m: &ty::Method,\n-                       trait_substs: &subst::Substs) {\n+                       trait_to_impl_substs: &subst::Substs) {\n     debug!(\"compare_impl_method()\");\n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    let impl_tps = impl_generics.type_param_defs().len();\n-\n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n     // below, where we construct a canonical function type that\n@@ -897,8 +874,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         }\n     }\n \n-    let num_impl_m_type_params = impl_m.generics.type_param_defs().len();\n-    let num_trait_m_type_params = trait_m.generics.type_param_defs().len();\n+    let num_impl_m_type_params = impl_m.generics.types.len(subst::FnSpace);\n+    let num_trait_m_type_params = trait_m.generics.types.len(subst::FnSpace);\n     if num_impl_m_type_params != num_trait_m_type_params {\n         tcx.sess.span_err(\n             impl_m_span,\n@@ -925,8 +902,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         return;\n     }\n \n-    let it = trait_m.generics.type_param_defs().iter()\n-        .zip(impl_m.generics.type_param_defs().iter());\n+    let it = trait_m.generics.types.get_vec(subst::FnSpace).iter()\n+        .zip(impl_m.generics.types.get_vec(subst::FnSpace).iter());\n \n     for (i, (trait_param_def, impl_param_def)) in it.enumerate() {\n         // Check that the impl does not require any builtin-bounds\n@@ -971,62 +948,89 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         }\n     }\n \n-    // Create a substitution that maps the type parameters on the impl\n-    // to themselves and which replace any references to bound regions\n-    // in the self type with free regions.  So, for example, if the\n-    // impl type is \"&'a str\", then this would replace the self\n-    // type with a free region `self`.\n-    let dummy_impl_tps: Vec<ty::t> =\n-        impl_generics.type_param_defs().iter().enumerate().\n-        map(|(i,t)| ty::mk_param(tcx, i, t.def_id)).\n-        collect();\n-    let dummy_method_tps: Vec<ty::t> =\n-        impl_m.generics.type_param_defs().iter().enumerate().\n-        map(|(i,t)| ty::mk_param(tcx, i + impl_tps, t.def_id)).\n-        collect();\n-    let dummy_impl_regions: Vec<ty::Region> =\n-        impl_generics.region_param_defs().iter().\n-        map(|l| ty::ReFree(ty::FreeRegion {\n-                scope_id: impl_m_body_id,\n-                bound_region: ty::BrNamed(l.def_id, l.name)})).\n-        collect();\n-    let dummy_substs = subst::Substs {\n-        tps: dummy_impl_tps.append(dummy_method_tps.as_slice()),\n-        regions: subst::NonerasedRegions(dummy_impl_regions),\n-        self_ty: None };\n-\n-    // Create a bare fn type for trait/impl\n-    // It'd be nice to refactor so as to provide the bare fn types instead.\n-    let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n+    // This code is best explained by example. Consider a trait:\n+    //\n+    //     trait Trait<T> {\n+    //          fn method<'a,M>(t: T, m: &'a M) -> Self;\n+    //     }\n+    //\n+    // And an impl:\n+    //\n+    //     impl<'i, U> Trait<&'i U> for Foo {\n+    //          fn method<'b,N>(t: &'i U, m: &'b N) -> Foo;\n+    //     }\n+    //\n+    // We wish to decide if those two method types are compatible.\n+    //\n+    // We start out with trait_to_impl_substs, that maps the trait type\n+    // parameters to impl type parameters:\n+    //\n+    //     trait_to_impl_substs = {T => &'i U, Self => Foo}\n+    //\n+    // We create a mapping `dummy_substs` that maps from the impl type\n+    // parameters to fresh types and regions. For type parameters,\n+    // this is the identity transform, but we could as well use any\n+    // skolemized types. For regions, we convert from bound to free\n+    // regions (Note: but only early-bound regions, i.e., those\n+    // declared on the impl or used in type parameter bounds).\n+    //\n+    //     impl_to_skol_substs = {'i => 'i0, U => U0, N => N0 }\n+    //\n+    // Now we can apply skol_substs to the type of the impl method\n+    // to yield a new function type in terms of our fresh, skolemized\n+    // types:\n+    //\n+    //     <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n+    //\n+    // We now want to extract and substitute the type of the *trait*\n+    // method and compare it. To do so, we must create a compound\n+    // substitution by combining trait_to_impl_substs and\n+    // impl_to_skol_substs, and also adding a mapping for the method\n+    // type parameters. We extend the mapping to also include\n+    // the method parameters.\n+    //\n+    //     trait_to_skol_substs = { T => &'i0 U0, Self => Foo, M => N0 }\n+    //\n+    // Applying this to the trait method type yields:\n+    //\n+    //     <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n+    //\n+    // This type is also the same but the name of the bound region ('a\n+    // vs 'b).  However, the normal subtyping rules on fn types handle\n+    // this kind of equivalency just fine.\n+\n+    // Create mapping from impl to skolemized.\n+    let skol_tps =\n+        impl_m.generics.types.map(\n+            |d| ty::mk_param_from_def(tcx, d));\n+    let skol_regions =\n+        impl_m.generics.regions.map(\n+            |l| ty::free_region_from_def(impl_m_body_id, l));\n+    let impl_to_skol_substs =\n+        subst::Substs::new(skol_tps.clone(), skol_regions.clone());\n+\n+    // Compute skolemized form of impl method ty.\n     let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n-\n-    // Perform substitutions so that the trait/impl methods are expressed\n-    // in terms of the same set of type/region parameters:\n-    // - replace trait type parameters with those from `trait_substs`,\n-    //   except with any reference to bound self replaced with `dummy_self_r`\n-    // - replace method parameters on the trait with fresh, dummy parameters\n-    //   that correspond to the parameters we will find on the impl\n-    // - replace self region with a fresh, dummy region\n-    let impl_fty = {\n-        debug!(\"impl_fty (pre-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n-        impl_fty.subst(tcx, &dummy_substs)\n-    };\n-    debug!(\"impl_fty (post-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n-    let trait_fty = {\n-        let subst::Substs { regions: trait_regions,\n-                            tps: trait_tps,\n-                            self_ty: self_ty } = trait_substs.subst(tcx, &dummy_substs);\n-        let substs = subst::Substs {\n-            regions: trait_regions,\n-            tps: trait_tps.append(dummy_method_tps.as_slice()),\n-            self_ty: self_ty,\n-        };\n-        debug!(\"trait_fty (pre-subst): {} substs={}\",\n-               trait_fty.repr(tcx), substs.repr(tcx));\n-        trait_fty.subst(tcx, &substs)\n-    };\n-    debug!(\"trait_fty (post-subst): {}\", trait_fty.repr(tcx));\n-\n+    let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n+\n+    // Compute skolemized form of trait method ty.\n+    let trait_to_skol_substs =\n+        trait_to_impl_substs\n+        .subst(tcx, &impl_to_skol_substs)\n+        .with_method(skol_tps.get_vec(subst::FnSpace).clone(),\n+                     skol_regions.get_vec(subst::FnSpace).clone());\n+    let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n+    let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n+\n+    // Check the impl method type IM is a subtype of the trait method\n+    // type TM. To see why this makes sense, think of a vtable. The\n+    // expected type of the function pointers in the vtable is the\n+    // type TM of the trait method.  The actual type will be the type\n+    // IM of the impl method. Because we know that IM <: TM, that\n+    // means that anywhere a TM is expected, a IM will do instead. In\n+    // other words, anyone expecting to call a method with the type\n+    // from the trait, can safely call a method with the type from the\n+    // impl instead.\n     match infer::mk_subty(&infcx, false, infer::MethodCompatCheck(impl_m_span),\n                           impl_fty, trait_fty) {\n         Ok(()) => {}\n@@ -1792,18 +1796,13 @@ pub fn impl_self_ty(vcx: &VtableContext,\n \n     let ity = ty::lookup_item_type(tcx, did);\n     let (n_tps, rps, raw_ty) =\n-        (ity.generics.type_param_defs().len(),\n-         ity.generics.region_param_defs(),\n+        (ity.generics.types.len(subst::TypeSpace),\n+         ity.generics.regions.get_vec(subst::TypeSpace),\n          ity.ty);\n \n     let rps = vcx.infcx.region_vars_for_defs(span, rps);\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n-\n-    let substs = subst::Substs {\n-        regions: subst::NonerasedRegions(rps),\n-        self_ty: None,\n-        tps: tps,\n-    };\n+    let substs = subst::Substs::new_type(tps, rps);\n     let substd_ty = raw_ty.subst(tcx, &substs);\n \n     ty_param_substs_and_ty { substs: substs, ty: substd_ty }\n@@ -1850,170 +1849,6 @@ enum TupleArgumentsFlag {\n     TupleArguments,\n }\n \n-// Given the provenance of a static method, returns the generics of the static\n-// method's container.\n-fn generics_of_static_method_container(type_context: &ty::ctxt,\n-                                       provenance: def::MethodProvenance)\n-                                       -> ty::Generics {\n-    match provenance {\n-        def::FromTrait(trait_def_id) => {\n-            ty::lookup_trait_def(type_context, trait_def_id).generics.clone()\n-        }\n-        def::FromImpl(impl_def_id) => {\n-            ty::lookup_item_type(type_context, impl_def_id).generics.clone()\n-        }\n-    }\n-}\n-\n-// Verifies that type parameters supplied in paths are in the right\n-// locations.\n-fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n-                                          path: &ast::Path,\n-                                          def: def::Def) {\n-    // We only care about checking the case in which the path has two or\n-    // more segments.\n-    if path.segments.len() < 2 {\n-        return\n-    }\n-\n-    // Verify that no lifetimes or type parameters are present anywhere\n-    // except the final two elements of the path.\n-    for i in range(0, path.segments.len() - 2) {\n-        for lifetime in path.segments.get(i).lifetimes.iter() {\n-            function_context.tcx()\n-                .sess\n-                .span_err(lifetime.span,\n-                          \"lifetime parameters may not \\\n-                          appear here\");\n-            break;\n-        }\n-\n-        for typ in path.segments.get(i).types.iter() {\n-            function_context.tcx()\n-                            .sess\n-                            .span_err(typ.span,\n-                                      \"type parameters may not appear here\");\n-            break;\n-        }\n-    }\n-\n-    // If there are no parameters at all, there is nothing more to do; the\n-    // rest of typechecking will (attempt to) infer everything.\n-    if path.segments\n-           .iter()\n-           .all(|s| s.lifetimes.is_empty() && s.types.is_empty()) {\n-        return\n-    }\n-\n-    match def {\n-        // If this is a static method of a trait or implementation, then\n-        // ensure that the segment of the path which names the trait or\n-        // implementation (the penultimate segment) is annotated with the\n-        // right number of type parameters.\n-        def::DefStaticMethod(_, provenance, _) => {\n-            let generics =\n-                generics_of_static_method_container(function_context.ccx.tcx,\n-                                                    provenance);\n-            let name = match provenance {\n-                def::FromTrait(_) => \"trait\",\n-                def::FromImpl(_) => \"impl\",\n-            };\n-\n-            let trait_segment = &path.segments.get(path.segments.len() - 2);\n-\n-            // Make sure lifetime parameterization agrees with the trait or\n-            // implementation type.\n-            let trait_region_parameter_count = generics.region_param_defs().len();\n-            let supplied_region_parameter_count = trait_segment.lifetimes.len();\n-            if trait_region_parameter_count != supplied_region_parameter_count\n-                && supplied_region_parameter_count != 0 {\n-                function_context.tcx()\n-                    .sess\n-                    .span_err(path.span,\n-                              format!(\"expected {} lifetime parameter{} \\\n-                                       found {} liftime parameter{}\",\n-                                      trait_region_parameter_count,\n-                                      if trait_region_parameter_count == 1 {\"\"}\n-                                        else {\"s\"},\n-                                      supplied_region_parameter_count,\n-                                      if supplied_region_parameter_count == 1 {\"\"}\n-                                        else {\"s\"}).as_slice());\n-            }\n-\n-            // Make sure the number of type parameters supplied on the trait\n-            // or implementation segment equals the number of type parameters\n-            // on the trait or implementation definition.\n-            let formal_ty_param_count = generics.type_param_defs().len();\n-            let required_ty_param_count = generics.type_param_defs().iter()\n-                                                  .take_while(|x| x.default.is_none())\n-                                                  .count();\n-            let supplied_ty_param_count = trait_segment.types.len();\n-            if supplied_ty_param_count < required_ty_param_count {\n-                let msg = if required_ty_param_count < generics.type_param_defs().len() {\n-                    format!(\"the {} referenced by this path needs at least \\\n-                             {} type parameter{}, but {} type parameters were \\\n-                             supplied\",\n-                            name,\n-                            required_ty_param_count,\n-                            if required_ty_param_count == 1 {\"\"} else {\"s\"},\n-                            supplied_ty_param_count)\n-                } else {\n-                    format!(\"the {} referenced by this path needs \\\n-                             {} type parameter{}, but {} type parameters were \\\n-                             supplied\",\n-                            name,\n-                            required_ty_param_count,\n-                            if required_ty_param_count == 1 {\"\"} else {\"s\"},\n-                            supplied_ty_param_count)\n-                };\n-                function_context.tcx().sess.span_err(path.span,\n-                                                     msg.as_slice())\n-            } else if supplied_ty_param_count > formal_ty_param_count {\n-                let msg = if required_ty_param_count < generics.type_param_defs().len() {\n-                    format!(\"the {} referenced by this path needs at most \\\n-                             {} type parameter{}, but {} type parameters were \\\n-                             supplied\",\n-                            name,\n-                            formal_ty_param_count,\n-                            if formal_ty_param_count == 1 {\"\"} else {\"s\"},\n-                            supplied_ty_param_count)\n-                } else {\n-                    format!(\"the {} referenced by this path needs \\\n-                             {} type parameter{}, but {} type parameters were \\\n-                             supplied\",\n-                            name,\n-                            formal_ty_param_count,\n-                            if formal_ty_param_count == 1 {\"\"} else {\"s\"},\n-                            supplied_ty_param_count)\n-                };\n-                function_context.tcx().sess.span_err(path.span,\n-                                                     msg.as_slice())\n-            }\n-        }\n-        _ => {\n-            // Verify that no lifetimes or type parameters are present on\n-            // the penultimate segment of the path.\n-            let segment = &path.segments.get(path.segments.len() - 2);\n-            for lifetime in segment.lifetimes.iter() {\n-                function_context.tcx()\n-                    .sess\n-                    .span_err(lifetime.span,\n-                              \"lifetime parameters may not\n-                              appear here\");\n-                break;\n-            }\n-            for typ in segment.types.iter() {\n-                function_context.tcx()\n-                                .sess\n-                                .span_err(typ.span,\n-                                          \"type parameters may not appear \\\n-                                           here\");\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n /// Invariant:\n /// If an expression has any sub-expressions that result in a type error,\n /// inspecting that expression's type with `ty::type_is_error` will return\n@@ -2689,19 +2524,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Look up the number of type parameters and the raw type, and\n         // determine whether the class is region-parameterized.\n         let item_type = ty::lookup_item_type(tcx, class_id);\n-        let type_parameter_count = item_type.generics.type_param_defs().len();\n-        let region_param_defs = item_type.generics.region_param_defs();\n         let raw_type = item_type.ty;\n \n         // Generate the struct type.\n-        let regions = fcx.infcx().region_vars_for_defs(span, region_param_defs);\n-        let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n-        let substitutions = subst::Substs {\n-            regions: subst::NonerasedRegions(regions),\n-            self_ty: None,\n-            tps: type_parameters\n-        };\n-\n+        let substitutions = fcx.infcx().fresh_substs_for_type(\n+            span, &item_type.generics);\n         let mut struct_type = raw_type.subst(tcx, &substitutions);\n \n         // Look up and check the fields.\n@@ -2745,20 +2572,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Look up the number of type parameters and the raw type, and\n         // determine whether the enum is region-parameterized.\n         let item_type = ty::lookup_item_type(tcx, enum_id);\n-        let type_parameter_count = item_type.generics.type_param_defs().len();\n-        let region_param_defs = item_type.generics.region_param_defs();\n-        let raw_type = item_type.ty;\n-\n-        // Generate the enum type.\n-        let regions = fcx.infcx().region_vars_for_defs(span, region_param_defs);\n-        let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n-        let substitutions = subst::Substs {\n-            regions: subst::NonerasedRegions(regions),\n-            self_ty: None,\n-            tps: type_parameters\n-        };\n-\n-        let enum_type = raw_type.subst(tcx, &substitutions);\n+        let substitutions = fcx.infcx().fresh_substs_for_type(span, &item_type.generics);\n+        let enum_type = item_type.ty.subst(tcx, &substitutions);\n \n         // Look up and check the enum variant fields.\n         let variant_fields = ty::lookup_struct_fields(tcx, variant_id);\n@@ -3039,8 +2854,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprPath(ref pth) => {\n         let defn = lookup_def(fcx, pth.span, id);\n-\n-        check_type_parameter_positions_in_path(fcx, pth, defn);\n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n         instantiate_path(fcx, pth, tpt, defn, expr.span, expr.id);\n       }\n@@ -3983,179 +3796,367 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: &FnCtxt,\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n pub fn instantiate_path(fcx: &FnCtxt,\n-                        pth: &ast::Path,\n-                        tpt: ty_param_bounds_and_ty,\n+                        path: &ast::Path,\n+                        polytype: ty_param_bounds_and_ty,\n                         def: def::Def,\n                         span: Span,\n                         node_id: ast::NodeId) {\n-    debug!(\">>> instantiate_path\");\n-\n-    let ty_param_count = tpt.generics.type_param_defs().len();\n-    let ty_param_req = tpt.generics.type_param_defs().iter()\n-                                                   .take_while(|x| x.default.is_none())\n-                                                   .count();\n-    let mut ty_substs_len = 0;\n-    for segment in pth.segments.iter() {\n-        ty_substs_len += segment.types.len()\n-    }\n+    debug!(\"instantiate_path(path={}, def={}, node_id={}, polytype={})\",\n+           path.repr(fcx.tcx()),\n+           def.repr(fcx.tcx()),\n+           node_id,\n+           polytype.repr(fcx.tcx()));\n+\n+    // We need to extract the type parameters supplied by the user in\n+    // the path `path`. Due to the current setup, this is a bit of a\n+    // tricky-process; the problem is that resolve only tells us the\n+    // end-point of the path resolution, and not the intermediate steps.\n+    // Luckily, we can (at least for now) deduce the intermediate steps\n+    // just from the end-point.\n+    //\n+    // There are basically three cases to consider:\n+    //\n+    // 1. Reference to a *type*, such as a struct or enum:\n+    //\n+    //        mod a { struct Foo<T> { ... } }\n+    //\n+    //    Because we don't allow types to be declared within one\n+    //    another, a path that leads to a type will always look like\n+    //    `a::b::Foo<T>` where `a` and `b` are modules. This implies\n+    //    that only the final segment can have type parameters, and\n+    //    they are located in the TypeSpace.\n+    //\n+    //    *Note:* Generally speaking, references to types don't\n+    //    actually pass through this function, but rather the\n+    //    `ast_ty_to_ty` function in `astconv`. However, in the case\n+    //    of struct patterns (and maybe literals) we do invoke\n+    //    `instantiate_path` to get the general type of an instance of\n+    //    a struct. (In these cases, there are actually no type\n+    //    parameters permitted at present, but perhaps we will allow\n+    //    them in the future.)\n+    //\n+    // 1b. Reference to a enum variant or tuple-like struct:\n+    //\n+    //        struct foo<T>(...)\n+    //        enum E<T> { foo(...) }\n+    //\n+    //    In these cases, the parameters are declared in the type\n+    //    space.\n+    //\n+    // 2. Reference to a *fn item*:\n+    //\n+    //        fn foo<T>() { }\n+    //\n+    //    In this case, the path will again always have the form\n+    //    `a::b::foo::<T>` where only the final segment should have\n+    //    type parameters. However, in this case, those parameters are\n+    //    declared on a value, and hence are in the `FnSpace`.\n+    //\n+    // 3. Reference to a *method*:\n+    //\n+    //        impl<A> SomeStruct<A> {\n+    //            fn foo<B>(...)\n+    //        }\n+    //\n+    //    Here we can have a path like\n+    //    `a::b::SomeStruct::<A>::foo::<B>`, in which case parameters\n+    //    may appear in two places. The penultimate segment,\n+    //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n+    //    final segment, `foo::<B>` contains parameters in fn space.\n+    //\n+    // The first step then is to categorize the segments appropriately.\n \n-    debug!(\"tpt={} ty_param_count={:?} ty_substs_len={:?}\",\n-           tpt.repr(fcx.tcx()),\n-           ty_param_count,\n-           ty_substs_len);\n-\n-    // determine the region parameters, using the value given by the user\n-    // (if any) and otherwise using a fresh region variable\n-    let num_expected_regions = tpt.generics.region_param_defs().len();\n-    let num_supplied_regions = pth.segments.last().unwrap().lifetimes.len();\n-    let regions = if num_expected_regions == num_supplied_regions {\n-        pth.segments.last().unwrap().lifetimes\n-            .iter()\n-            .map(|l| ast_region_to_region(fcx.tcx(), l))\n-            .collect()\n-    } else {\n-        if num_supplied_regions != 0 {\n-            fcx.ccx.tcx.sess.span_err(\n-                span,\n-                format!(\"expected {} lifetime parameter{}, \\\n-                         found {} lifetime parameter{}\",\n-                        num_expected_regions,\n-                        if num_expected_regions == 1 {\"\"} else {\"s\"},\n-                        num_supplied_regions,\n-                        if num_supplied_regions == 1 {\"\"} else {\"s\"}).as_slice());\n+    assert!(path.segments.len() >= 1);\n+    let mut segment_spaces;\n+    match def {\n+        // Case 1 and 1b. Reference to a *type* or *enum variant*.\n+        def::DefSelfTy(..) |\n+        def::DefStruct(..) |\n+        def::DefVariant(..) |\n+        def::DefTyParamBinder(..) |\n+        def::DefTy(..) |\n+        def::DefTrait(..) |\n+        def::DefPrimTy(..) |\n+        def::DefTyParam(..) => {\n+            // Everything but the final segment should have no\n+            // parameters at all.\n+            segment_spaces = Vec::from_elem(path.segments.len() - 1, None);\n+            segment_spaces.push(Some(subst::TypeSpace));\n         }\n \n-        fcx.infcx().region_vars_for_defs(span, tpt.generics.region_param_defs.as_slice())\n-    };\n-    let regions = subst::NonerasedRegions(regions);\n+        // Case 2. Reference to a top-level value.\n+        def::DefFn(..) |\n+        def::DefStatic(..) => {\n+            segment_spaces = Vec::from_elem(path.segments.len() - 1, None);\n+            segment_spaces.push(Some(subst::FnSpace));\n+        }\n \n-    // Special case: If there is a self parameter, omit it from the list of\n-    // type parameters.\n-    //\n-    // Here we calculate the \"user type parameter count\", which is the number\n-    // of type parameters actually manifest in the AST. This will differ from\n-    // the internal type parameter count when there are self types involved.\n-    let (user_ty_param_count, user_ty_param_req, self_parameter_index) = match def {\n-        def::DefStaticMethod(_, provenance @ def::FromTrait(_), _) => {\n-            let generics = generics_of_static_method_container(fcx.ccx.tcx,\n-                                                               provenance);\n-            (ty_param_count - 1, ty_param_req - 1, Some(generics.type_param_defs().len()))\n+        // Case 3. Reference to a method.\n+        def::DefStaticMethod(..) => {\n+            assert!(path.segments.len() >= 2);\n+            segment_spaces = Vec::from_elem(path.segments.len() - 2, None);\n+            segment_spaces.push(Some(subst::TypeSpace));\n+            segment_spaces.push(Some(subst::FnSpace));\n         }\n-        _ => (ty_param_count, ty_param_req, None),\n-    };\n \n-    // determine values for type parameters, using the values given by\n-    // the user (if any) and otherwise using fresh type variables\n-    let (tps, regions) = if ty_substs_len == 0 {\n-        (fcx.infcx().next_ty_vars(ty_param_count), regions)\n-    } else if ty_param_count == 0 {\n-        fcx.ccx.tcx.sess.span_err\n-            (span, \"this item does not take type parameters\");\n-        (fcx.infcx().next_ty_vars(ty_param_count), regions)\n-    } else if ty_substs_len > user_ty_param_count {\n-        let expected = if user_ty_param_req < user_ty_param_count {\n-            \"expected at most\"\n-        } else {\n-            \"expected\"\n-        };\n-        fcx.ccx.tcx.sess.span_err\n-            (span,\n-             format!(\"too many type parameters provided: {} {}, found {}\",\n-                  expected, user_ty_param_count, ty_substs_len).as_slice());\n-        (fcx.infcx().next_ty_vars(ty_param_count), regions)\n-    } else if ty_substs_len < user_ty_param_req {\n-        let expected = if user_ty_param_req < user_ty_param_count {\n-            \"expected at least\"\n-        } else {\n-            \"expected\"\n-        };\n-        fcx.ccx.tcx.sess.span_err(\n-            span,\n-            format!(\"not enough type parameters provided: {} {}, found {}\",\n-                    expected,\n-                    user_ty_param_req,\n-                    ty_substs_len).as_slice());\n-        (fcx.infcx().next_ty_vars(ty_param_count), regions)\n-    } else {\n-        if ty_substs_len > user_ty_param_req\n-            && !fcx.tcx().sess.features.default_type_params.get() {\n-            fcx.tcx().sess.span_err(pth.span, \"default type parameters are \\\n-                                               experimental and possibly buggy\");\n-            fcx.tcx().sess.span_note(pth.span, \"add #![feature(default_type_params)] \\\n-                                                to the crate attributes to enable\");\n+        // Other cases. Various nonsense that really shouldn't show up\n+        // here. If they do, an error will have been reported\n+        // elsewhere. (I hope)\n+        def::DefMod(..) |\n+        def::DefForeignMod(..) |\n+        def::DefArg(..) |\n+        def::DefLocal(..) |\n+        def::DefMethod(..) |\n+        def::DefBinding(..) |\n+        def::DefUse(..) |\n+        def::DefRegion(..) |\n+        def::DefLabel(..) |\n+        def::DefUpvar(..) => {\n+            segment_spaces = Vec::from_elem(path.segments.len(), None);\n         }\n+    }\n+    assert_eq!(segment_spaces.len(), path.segments.len());\n+\n+    debug!(\"segment_spaces={}\", segment_spaces);\n+\n+    // Next, examine the definition, and determine how many type\n+    // parameters we expect from each space.\n+    let type_defs = &polytype.generics.types;\n+    let region_defs = &polytype.generics.regions;\n+\n+    // Now that we have categorized what space the parameters for each\n+    // segment belong to, let's sort out the parameters that the user\n+    // provided (if any) into their appropriate spaces. We'll also report\n+    // errors if type parameters are provided in an inappropriate place.\n+    let mut substs = Substs::empty();\n+    for (opt_space, segment) in segment_spaces.iter().zip(path.segments.iter()) {\n+        match *opt_space {\n+            None => {\n+                report_error_if_segment_contains_type_parameters(fcx, segment);\n+            }\n \n-        // Build up the list of type parameters, inserting the self parameter\n-        // at the appropriate position.\n-        let mut tps = Vec::new();\n-        let mut pushed = false;\n-        for (i, ty) in pth.segments.iter()\n-                                   .flat_map(|segment| segment.types.iter())\n-                                   .map(|ast_type| fcx.to_ty(&**ast_type))\n-                                   .enumerate() {\n-            match self_parameter_index {\n-                Some(index) if index == i => {\n-                    tps.push(*fcx.infcx().next_ty_vars(1).get(0));\n-                    pushed = true;\n-                }\n-                _ => {}\n+            Some(space) => {\n+                push_explicit_parameters_from_segment_to_substs(fcx,\n+                                                                space,\n+                                                                type_defs,\n+                                                                region_defs,\n+                                                                segment,\n+                                                                &mut substs);\n             }\n-            tps.push(ty)\n         }\n+    }\n \n-        let mut substs = subst::Substs {\n-            regions: regions,\n-            self_ty: None,\n-            tps: tps\n-        };\n+    // Now we have to compare the types that the user *actually*\n+    // provided against the types that were *expected*. If the user\n+    // did not provide any types, then we want to substitute inference\n+    // variables. If the user provided some types, we may still need\n+    // to add defaults. If the user provided *too many* types, that's\n+    // a problem.\n+    for &space in ParamSpace::all().iter() {\n+        adjust_type_parameters(fcx, span, space, type_defs, &mut substs);\n+        assert_eq!(substs.types.get_vec(space).len(),\n+                   type_defs.get_vec(space).len());\n+\n+        adjust_region_parameters(fcx, span, space, region_defs, &mut substs);\n+        assert_eq!(substs.regions().get_vec(space).len(),\n+                   region_defs.get_vec(space).len());\n+    }\n \n-        let defaults = tpt.generics.type_param_defs().iter()\n-                          .enumerate().filter_map(|(i, x)| {\n-            match self_parameter_index {\n-                Some(index) if index == i => None,\n-                _ => Some(x.default)\n-            }\n-        });\n-        for (i, default) in defaults.skip(ty_substs_len).enumerate() {\n-            match self_parameter_index {\n-                Some(index) if index == i + ty_substs_len => {\n-                    substs.tps.push(*fcx.infcx().next_ty_vars(1).get(0));\n-                    pushed = true;\n+    fcx.write_ty_substs(node_id, polytype.ty, ty::ItemSubsts {\n+        substs: substs,\n+    });\n+\n+    fn report_error_if_segment_contains_type_parameters(\n+        fcx: &FnCtxt,\n+        segment: &ast::PathSegment)\n+    {\n+        for typ in segment.types.iter() {\n+            fcx.tcx().sess.span_err(\n+                typ.span,\n+                \"type parameters may not appear here\");\n+            break;\n+        }\n+\n+        for lifetime in segment.lifetimes.iter() {\n+            fcx.tcx().sess.span_err(\n+                lifetime.span,\n+                \"lifetime parameters may not appear here\");\n+            break;\n+        }\n+    }\n+\n+    fn push_explicit_parameters_from_segment_to_substs(\n+        fcx: &FnCtxt,\n+        space: subst::ParamSpace,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n+        segment: &ast::PathSegment,\n+        substs: &mut Substs)\n+    {\n+        /*!\n+         * Finds the parameters that the user provided and adds them\n+         * to `substs`. If too many parameters are provided, then\n+         * reports an error and clears the output vector.\n+         *\n+         * We clear the output vector because that will cause the\n+         * `adjust_XXX_parameters()` later to use inference\n+         * variables. This seems less likely to lead to derived\n+         * errors.\n+         *\n+         * Note that we *do not* check for *too few* parameters here.\n+         * Due to the presence of defaults etc that is more\n+         * complicated. I wanted however to do the reporting of *too\n+         * many* parameters here because we can easily use the precise\n+         * span of the N+1'th parameter.\n+         */\n+\n+        {\n+            let type_count = type_defs.get_vec(space).len();\n+            assert_eq!(substs.types.get_vec(space).len(), 0);\n+            for (i, &typ) in segment.types.iter().enumerate() {\n+                let t = fcx.to_ty(&*typ);\n+                if i < type_count {\n+                    substs.types.push(space, t);\n+                } else if i == type_count {\n+                    fcx.tcx().sess.span_err(\n+                        typ.span,\n+                        format!(\n+                            \"too many type parameters provided: \\\n+                             expected at most {} parameter(s) \\\n+                             but found {} parameter(s)\",\n+                            type_count,\n+                            segment.types.len()).as_slice());\n+                    substs.types.get_mut_vec(space).truncate(0);\n                 }\n-                _ => {}\n             }\n-            match default {\n-                Some(default) => {\n-                    let ty = default.subst_spanned(fcx.tcx(), &substs, Some(span));\n-                    substs.tps.push(ty);\n-                }\n-                None => {\n-                    fcx.tcx().sess.span_bug(span,\n-                        \"missing default for a not explicitly provided type param\")\n+        }\n+\n+        {\n+            let region_count = region_defs.get_vec(space).len();\n+            assert_eq!(substs.regions().get_vec(space).len(), 0);\n+            for (i, lifetime) in segment.lifetimes.iter().enumerate() {\n+                let r = ast_region_to_region(fcx.tcx(), lifetime);\n+                if i < region_count {\n+                    substs.mut_regions().push(space, r);\n+                } else if i == region_count {\n+                    fcx.tcx().sess.span_err(\n+                        lifetime.span,\n+                        format!(\n+                            \"too many lifetime parameters provided: \\\n+                             expected {} parameter(s) but found {} parameter(s)\",\n+                            region_count,\n+                            segment.lifetimes.len()).as_slice());\n+                    substs.mut_regions().get_mut_vec(space).truncate(0);\n                 }\n             }\n         }\n+    }\n \n-        // If the self parameter goes at the end, insert it there.\n-        if !pushed && self_parameter_index.is_some() {\n-            substs.tps.push(*fcx.infcx().next_ty_vars(1).get(0))\n+    fn adjust_type_parameters(\n+        fcx: &FnCtxt,\n+        span: Span,\n+        space: ParamSpace,\n+        defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        substs: &mut Substs)\n+    {\n+        let provided_len = substs.types.get_vec(space).len();\n+        let desired = defs.get_vec(space).as_slice();\n+        let required_len = desired.iter()\n+                              .take_while(|d| d.default.is_none())\n+                              .count();\n+\n+        debug!(\"adjust_type_parameters(space={}, \\\n+               provided_len={}, \\\n+               desired_len={}, \\\n+               required_len={})\",\n+               space,\n+               provided_len,\n+               desired.len(),\n+               required_len);\n+\n+        // Enforced by `push_explicit_parameters_from_segment_to_substs()`.\n+        assert!(provided_len <= desired.len());\n+\n+        // Nothing specified at all: supply inference variables for\n+        // everything.\n+        if provided_len == 0 {\n+            let provided = substs.types.get_mut_vec(space);\n+            *provided = fcx.infcx().next_ty_vars(desired.len());\n+            return;\n         }\n \n-        assert_eq!(substs.tps.len(), ty_param_count)\n+        // Too few parameters specified: report an error and use Err\n+        // for everything.\n+        if provided_len < required_len {\n+            let qualifier =\n+                if desired.len() != required_len { \"at least \" } else { \"\" };\n+            fcx.tcx().sess.span_err(\n+                span,\n+                format!(\"too few type parameters provided: \\\n+                             expected {}{} parameter(s) \\\n+                             but found {} parameter(s)\",\n+                            qualifier,\n+                            required_len,\n+                            provided_len).as_slice());\n+            let provided = substs.types.get_mut_vec(space);\n+            *provided = Vec::from_elem(desired.len(), ty::mk_err());\n+            return;\n+        }\n \n-        let subst::Substs {tps, regions, ..} = substs;\n-        (tps, regions)\n-    };\n+        // Otherwise, add in any optional parameters that the user\n+        // omitted. The case of *too many* parameters is handled\n+        // already by\n+        // push_explicit_parameters_from_segment_to_substs(). Note\n+        // that the *default* type are expressed in terms of all prior\n+        // parameters, so we have to substitute as we go with the\n+        // partial substitution that we have built up.\n+        for i in range(provided_len, desired.len()) {\n+            let default = desired[i].default.unwrap();\n+            let default = default.subst_spanned(fcx.tcx(), substs, Some(span));\n+            substs.types.push(space, default);\n+        }\n+        assert_eq!(substs.types.get_vec(space).len(), desired.len());\n \n-    let substs = subst::Substs { regions: regions,\n-                                 self_ty: None,\n-                                 tps: tps };\n+        debug!(\"Final substs: {}\", substs.repr(fcx.tcx()));\n+    }\n \n-    fcx.write_ty_substs(node_id, tpt.ty, ty::ItemSubsts {\n-        substs: substs,\n-    });\n+    fn adjust_region_parameters(\n+        fcx: &FnCtxt,\n+        span: Span,\n+        space: ParamSpace,\n+        defs: &VecPerParamSpace<ty::RegionParameterDef>,\n+        substs: &mut Substs)\n+    {\n+        let provided = substs.mut_regions().get_mut_vec(space);\n+        let desired = defs.get_vec(space);\n+\n+        // Enforced by `push_explicit_parameters_from_segment_to_substs()`.\n+        assert!(provided.len() <= desired.len());\n+\n+        // If nothing was provided, just use inference variables.\n+        if provided.len() == 0 {\n+            *provided = fcx.infcx().region_vars_for_defs(span, desired);\n+            return;\n+        }\n+\n+        // If just the right number were provided, everybody is happy.\n+        if provided.len() == desired.len() {\n+            return;\n+        }\n \n-    debug!(\"<<<\");\n+        // Otherwise, too few were provided. Report an error and then\n+        // use inference variables.\n+        fcx.tcx().sess.span_err(\n+            span,\n+            format!(\n+                \"too few lifetime parameters provided: \\\n+                         expected {} parameter(s) \\\n+                         but found {} parameter(s)\",\n+                desired.len(),\n+                provided.len()).as_slice());\n+\n+        *provided = fcx.infcx().region_vars_for_defs(span, desired);\n+    }\n }\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n@@ -4292,14 +4293,8 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n \n     ty::walk_ty(ty, |t| {\n             match ty::get(t).sty {\n-                #[cfg(stage0)]\n-                ty::ty_param(param_ty {idx, ..}) => {\n-                    debug!(\"Found use of ty param \\\\#{}\", idx);\n-                    *tps_used.get_mut(idx) = true;\n-                }\n-                #[cfg(not(stage0))]\n-                ty::ty_param(param_ty {idx, ..}) => {\n-                    debug!(\"Found use of ty param #{}\", idx);\n+                ty::ty_param(ParamTy {idx, ..}) => {\n+                    debug!(\"Found use of ty param num {}\", idx);\n                     *tps_used.get_mut(idx) = true;\n                 }\n                 _ => ()\n@@ -4318,7 +4313,7 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n \n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     fn param(ccx: &CrateCtxt, n: uint) -> ty::t {\n-        ty::mk_param(ccx.tcx, n, local_def(0))\n+        ty::mk_param(ccx.tcx, subst::FnSpace, n, local_def(0))\n     }\n \n     let tcx = ccx.tcx;\n@@ -4390,11 +4385,10 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"type_id\" => {\n                 let langid = ccx.tcx.lang_items.require(TypeIdLangItem);\n                 match langid {\n-                    Ok(did) => (1u, Vec::new(), ty::mk_struct(ccx.tcx, did, subst::Substs {\n-                                                 self_ty: None,\n-                                                 tps: Vec::new(),\n-                                                 regions: subst::NonerasedRegions(Vec::new())\n-                                                 }) ),\n+                    Ok(did) => (1u,\n+                                Vec::new(),\n+                                ty::mk_struct(ccx.tcx, did,\n+                                              subst::Substs::empty())),\n                     Err(msg) => {\n                         tcx.sess.span_fatal(it.span, msg.as_slice());\n                     }\n@@ -4593,7 +4587,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         }\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n-    let i_n_tps = i_ty.generics.type_param_defs().len();\n+    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     if i_n_tps != n_tps {\n         tcx.sess.span_err(it.span,\n                           format!(\"intrinsic has wrong number of type \\"}, {"sha": "7d2b9d9aa869747466e0547e3146d8122cef6726", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 136, "deletions": 111, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -10,7 +10,7 @@\n \n \n use middle::ty;\n-use middle::ty::{AutoAddEnv, AutoDerefRef, AutoObject, param_ty};\n+use middle::ty::{AutoAddEnv, AutoDerefRef, AutoObject, ParamTy};\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n@@ -20,11 +20,11 @@ use middle::typeck::infer::fixup_err_to_str;\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n use middle::typeck::{vtable_origin, vtable_res, vtable_param_res};\n-use middle::typeck::{vtable_static, vtable_param, impl_res};\n-use middle::typeck::{param_numbered, param_self, param_index};\n+use middle::typeck::{vtable_static, vtable_param, vtable_error};\n+use middle::typeck::{param_index};\n use middle::typeck::MethodCall;\n use middle::subst;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, VecPerParamSpace};\n use util::common::indenter;\n use util::ppaux;\n use util::ppaux::Repr;\n@@ -76,38 +76,32 @@ impl<'a> VtableContext<'a> {\n \n fn lookup_vtables(vcx: &VtableContext,\n                   span: Span,\n-                  type_param_defs: &[ty::TypeParameterDef],\n+                  type_param_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n                   substs: &subst::Substs,\n-                  is_early: bool) -> vtable_res {\n-    debug!(\"lookup_vtables(span={:?}, \\\n-            type_param_defs={}, \\\n-            substs={}\",\n-           span,\n+                  is_early: bool)\n+                  -> VecPerParamSpace<vtable_param_res>\n+{\n+    debug!(\"lookup_vtables(\\\n+           type_param_defs={}, \\\n+           substs={}\",\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()));\n \n     // We do this backwards for reasons discussed above.\n-    assert_eq!(substs.tps.len(), type_param_defs.len());\n-    let mut result: Vec<vtable_param_res> =\n-        substs.tps.iter()\n-        .rev()\n-        .zip(type_param_defs.iter().rev())\n-        .map(|(ty, def)|\n-            lookup_vtables_for_param(vcx, span, Some(substs),\n-                                     &*def.bounds, *ty, is_early))\n-        .collect();\n-    result.reverse();\n-\n-    assert_eq!(substs.tps.len(), result.len());\n+    let result = type_param_defs.map_rev(|def| {\n+        let ty = *substs.types.get(def.space, def.index);\n+        lookup_vtables_for_param(vcx, span, Some(substs),\n+                                 &*def.bounds, ty, is_early)\n+    });\n+\n     debug!(\"lookup_vtables result(\\\n-            span={:?}, \\\n             type_param_defs={}, \\\n             substs={}, \\\n             result={})\",\n-           span,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()),\n            result.repr(vcx.tcx()));\n+\n     result\n }\n \n@@ -117,9 +111,15 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n                             substs: Option<&subst::Substs>,\n                             type_param_bounds: &ty::ParamBounds,\n                             ty: ty::t,\n-                            is_early: bool) -> vtable_param_res {\n+                            is_early: bool)\n+                            -> vtable_param_res {\n     let tcx = vcx.tcx();\n \n+    debug!(\"lookup_vtables_for_param(ty={}, type_param_bounds={}, is_early={})\",\n+           ty.repr(vcx.tcx()),\n+           type_param_bounds.repr(vcx.tcx()),\n+           is_early);\n+\n     // ty is the value supplied for the type parameter A...\n     let mut param_result = Vec::new();\n \n@@ -130,6 +130,10 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n         // ...and here trait_ref is each bound that was declared on A,\n         // expressed in terms of the type parameters.\n \n+        debug!(\"matching ty={} trait_ref={}\",\n+               ty.repr(vcx.tcx()),\n+               trait_ref.repr(vcx.tcx()));\n+\n         ty::populate_implementations_for_trait_if_necessary(tcx,\n                                                             trait_ref.def_id);\n \n@@ -157,11 +161,9 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n     });\n \n     debug!(\"lookup_vtables_for_param result(\\\n-            span={:?}, \\\n             type_param_bounds={}, \\\n             ty={}, \\\n             result={})\",\n-           span,\n            type_param_bounds.repr(vcx.tcx()),\n            ty.repr(vcx.tcx()),\n            param_result.repr(vcx.tcx()));\n@@ -216,10 +218,11 @@ fn lookup_vtable(vcx: &VtableContext,\n                  ty: ty::t,\n                  trait_ref: Rc<ty::TraitRef>,\n                  is_early: bool)\n-                 -> Option<vtable_origin> {\n+                 -> Option<vtable_origin>\n+{\n     debug!(\"lookup_vtable(ty={}, trait_ref={})\",\n-           vcx.infcx.ty_to_str(ty),\n-           vcx.infcx.trait_ref_to_str(&*trait_ref));\n+           ty.repr(vcx.tcx()),\n+           trait_ref.repr(vcx.tcx()));\n     let _i = indenter();\n \n     let ty = match fixup_ty(vcx, span, ty, is_early) {\n@@ -230,32 +233,24 @@ fn lookup_vtable(vcx: &VtableContext,\n             // The type has unconstrained type variables in it, so we can't\n             // do early resolution on it. Return some completely bogus vtable\n             // information: we aren't storing it anyways.\n-            return Some(vtable_param(param_self, 0));\n+            return Some(vtable_error);\n         }\n     };\n \n+    if ty::type_is_error(ty) {\n+        return Some(vtable_error);\n+    }\n+\n     // If the type is self or a param, we look at the trait/supertrait\n     // bounds to see if they include the trait we are looking for.\n     let vtable_opt = match ty::get(ty).sty {\n-        ty::ty_param(param_ty {idx: n, ..}) => {\n-            let env_bounds = &vcx.param_env.type_param_bounds;\n-            if env_bounds.len() > n {\n-                let type_param_bounds: &[Rc<ty::TraitRef>] =\n-                    env_bounds.get(n).trait_bounds.as_slice();\n-                lookup_vtable_from_bounds(vcx, span,\n-                                          type_param_bounds,\n-                                          param_numbered(n),\n-                                          trait_ref.clone())\n-            } else {\n-                None\n-            }\n-        }\n-\n-        ty::ty_self(_) => {\n-            let self_param_bound = vcx.param_env.self_param_bound.clone().unwrap();\n+        ty::ty_param(ParamTy {space, idx: n, ..}) => {\n+            let env_bounds = &vcx.param_env.bounds;\n+            let type_param_bounds = &env_bounds.get(space, n).trait_bounds;\n             lookup_vtable_from_bounds(vcx, span,\n-                                      [self_param_bound],\n-                                      param_self,\n+                                      type_param_bounds.as_slice(),\n+                                      param_index { space: space,\n+                                                    index: n },\n                                       trait_ref.clone())\n         }\n \n@@ -373,8 +368,8 @@ fn search_for_vtable(vcx: &VtableContext,\n         // Now, in the previous example, for_ty is bound to\n         // the type self_ty, and substs is bound to [T].\n         debug!(\"The self ty is {} and its substs are {}\",\n-               vcx.infcx.ty_to_str(for_ty),\n-               vcx.infcx.tys_to_str(substs.tps.as_slice()));\n+               for_ty.repr(tcx),\n+               substs.types.repr(tcx));\n \n         // Next, we unify trait_ref -- the type that we want to cast\n         // to -- with of_trait_ref -- the trait that im implements. At\n@@ -386,12 +381,13 @@ fn search_for_vtable(vcx: &VtableContext,\n         // some value of U) with some_trait<T>. This would fail if T\n         // and U weren't compatible.\n \n-        debug!(\"(checking vtable) {}2 relating trait \\\n-                ty {} to of_trait_ref {}\", \"#\",\n+        let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n+\n+        debug!(\"(checking vtable) num 2 relating trait \\\n+                ty {} to of_trait_ref {}\",\n                vcx.infcx.trait_ref_to_str(&*trait_ref),\n                vcx.infcx.trait_ref_to_str(&*of_trait_ref));\n \n-        let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n         relate_trait_refs(vcx, span, of_trait_ref, trait_ref.clone());\n \n \n@@ -404,11 +400,12 @@ fn search_for_vtable(vcx: &VtableContext,\n         // process of looking up bounds might constrain some of them.\n         let im_generics =\n             ty::lookup_item_type(tcx, impl_did).generics;\n-        let subres = lookup_vtables(vcx, span,\n-                                    im_generics.type_param_defs(), &substs,\n+        let subres = lookup_vtables(vcx,\n+                                    span,\n+                                    &im_generics.types,\n+                                    &substs,\n                                     is_early);\n \n-\n         // substs might contain type variables, so we call\n         // fixup_substs to resolve them.\n         let substs_f = match fixup_substs(vcx, span,\n@@ -419,15 +416,15 @@ fn search_for_vtable(vcx: &VtableContext,\n             None => {\n                 assert!(is_early);\n                 // Bail out with a bogus answer\n-                return Some(vtable_param(param_self, 0));\n+                return Some(vtable_error);\n             }\n         };\n \n         debug!(\"The fixed-up substs are {} - \\\n                 they will be unified with the bounds for \\\n                 the target ty, {}\",\n-               vcx.infcx.tys_to_str(substs_f.tps.as_slice()),\n-               vcx.infcx.trait_ref_to_str(&*trait_ref));\n+               substs_f.types.repr(tcx),\n+               trait_ref.repr(tcx));\n \n         // Next, we unify the fixed-up substitutions for the impl self\n         // ty with the substitutions from the trait type that we're\n@@ -515,7 +512,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n }\n \n fn insert_vtables(fcx: &FnCtxt, vtable_key: MethodCall, vtables: vtable_res) {\n-    debug!(\"insert_vtables(vtable_key={}, vtables={:?})\",\n+    debug!(\"insert_vtables(vtable_key={}, vtables={})\",\n            vtable_key, vtables.repr(fcx.tcx()));\n     fcx.inh.vtable_map.borrow_mut().insert(vtable_key, vtables);\n }\n@@ -560,12 +557,20 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                     };\n \n                       let vcx = fcx.vtable_context();\n+\n+                      // Take the type parameters from the object\n+                      // type, but set the Self type (which is\n+                      // unknown, for the object type) to be the type\n+                      // we are casting from.\n+                      let mut target_types = target_substs.types.clone();\n+                      assert!(target_types.get_self().is_none());\n+                      target_types.push(subst::SelfSpace, typ);\n+\n                       let target_trait_ref = Rc::new(ty::TraitRef {\n                           def_id: target_def_id,\n                           substs: subst::Substs {\n-                              tps: target_substs.tps.clone(),\n                               regions: target_substs.regions.clone(),\n-                              self_ty: Some(typ)\n+                              types: target_types\n                           }\n                       });\n \n@@ -582,7 +587,9 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                                      is_early);\n \n                       if !is_early {\n-                          insert_vtables(fcx, MethodCall::expr(ex.id), vec!(vtables));\n+                          let mut r = VecPerParamSpace::empty();\n+                          r.push(subst::SelfSpace, vtables);\n+                          insert_vtables(fcx, MethodCall::expr(ex.id), r);\n                       }\n \n                       // Now, if this is &trait, we need to link the\n@@ -632,10 +639,10 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n             debug!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));\n             debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n-                   item_ty.generics.type_param_defs().repr(fcx.tcx()));\n+                   item_ty.generics.types.repr(fcx.tcx()));\n             let vcx = fcx.vtable_context();\n             let vtbls = lookup_vtables(&vcx, ex.span,\n-                                       item_ty.generics.type_param_defs(),\n+                                       &item_ty.generics.types,\n                                        &item_substs.substs, is_early);\n             if !is_early {\n                 insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n@@ -657,7 +664,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n               let substs = fcx.method_ty_substs(ex.id);\n               let vcx = fcx.vtable_context();\n               let vtbls = lookup_vtables(&vcx, ex.span,\n-                                         type_param_defs.as_slice(),\n+                                         &type_param_defs,\n                                          &substs, is_early);\n               if !is_early {\n                   insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n@@ -689,8 +696,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                     ty::method_call_type_param_defs(cx.tcx, method.origin);\n                                 let vcx = fcx.vtable_context();\n                                 let vtbls = lookup_vtables(&vcx, ex.span,\n-                                                           type_param_defs.deref()\n-                                                           .as_slice(),\n+                                                           &type_param_defs,\n                                                            &method.substs, is_early);\n                                 if !is_early {\n                                     insert_vtables(fcx, method_call, vtbls);\n@@ -726,80 +732,99 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n                     impl_item: &ast::Item,\n                     impl_generics: &ty::Generics,\n                     impl_trait_ref: &ty::TraitRef) {\n+    /*!\n+     * The situation is as follows. We have some trait like:\n+     *\n+     *    trait Foo<A:Clone> : Bar {\n+     *        fn method() { ... }\n+     *    }\n+     *\n+     * and an impl like:\n+     *\n+     *    impl<B:Clone> Foo<B> for int { ... }\n+     *\n+     * We want to validate that the various requirements of the trait\n+     * are met:\n+     *\n+     *    A:Clone, Self:Bar\n+     *\n+     * But of course after substituting the types from the impl:\n+     *\n+     *    B:Clone, int:Bar\n+     *\n+     * We store these results away as the \"impl_res\" for use by the\n+     * default methods.\n+     */\n+\n     debug!(\"resolve_impl(impl_item.id={})\",\n            impl_item.id);\n \n-    let param_env = ty::construct_parameter_environment(\n-        tcx,\n-        None,\n-        impl_generics.type_param_defs(),\n-        [],\n-        impl_generics.region_param_defs(),\n-        [],\n-        impl_item.id);\n+    let param_env = ty::construct_parameter_environment(tcx,\n+                                                        impl_generics,\n+                                                        impl_item.id);\n \n+    // The impl_trait_ref in our example above would be\n+    //     `Foo<B> for int`\n     let impl_trait_ref = impl_trait_ref.subst(tcx, &param_env.free_substs);\n     debug!(\"impl_trait_ref={}\", impl_trait_ref.repr(tcx));\n \n     let infcx = &infer::new_infer_ctxt(tcx);\n     let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n \n-    // First, check that the impl implements any trait bounds\n-    // on the trait.\n-    let trait_def = ty::lookup_trait_def(tcx, impl_trait_ref.def_id);\n-    let vtbls = lookup_vtables(&vcx, impl_item.span,\n-                               trait_def.generics.type_param_defs(),\n-                               &impl_trait_ref.substs,\n-                               false);\n-\n-    // Now, locate the vtable for the impl itself. The real\n-    // purpose of this is to check for supertrait impls,\n-    // but that falls out of doing this.\n-    let param_bounds = ty::ParamBounds {\n-        builtin_bounds: ty::empty_builtin_bounds(),\n-        trait_bounds: vec!(Rc::new(impl_trait_ref))\n-    };\n-    let t = ty::node_id_to_type(tcx, impl_item.id);\n-    let t = t.subst(tcx, &param_env.free_substs);\n-    debug!(\"=== Doing a self lookup now.\");\n+    // Resolve the vtables for the trait reference on the impl.  This\n+    // serves many purposes, best explained by example. Imagine we have:\n+    //\n+    //    trait A<T:B> : C { fn x(&self) { ... } }\n+    //\n+    // and\n+    //\n+    //    impl A<int> for uint { ... }\n+    //\n+    // In that case, the trait ref will be `A<int> for uint`. Resolving\n+    // this will first check that the various types meet their requirements:\n+    //\n+    // 1. Because of T:B, int must implement the trait B\n+    // 2. Because of the supertrait C, uint must implement the trait C.\n+    //\n+    // Simultaneously, the result of this resolution (`vtbls`), is precisely\n+    // the set of vtable information needed to compile the default method\n+    // `x()` adapted to the impl. (After all, a default method is basically\n+    // the same as:\n+    //\n+    //     fn default_x<T:B, Self:A>(...) { .. .})\n \n-    // Right now, we don't have any place to store this.\n-    // We will need to make one so we can use this information\n-    // for compiling default methods that refer to supertraits.\n-    let self_vtable_res =\n-        lookup_vtables_for_param(&vcx, impl_item.span, None,\n-                                 &param_bounds, t, false);\n+    let trait_def = ty::lookup_trait_def(tcx, impl_trait_ref.def_id);\n+    let vtbls = lookup_vtables(&vcx,\n+                                   impl_item.span,\n+                                   &trait_def.generics.types,\n+                                   &impl_trait_ref.substs,\n+                                   false);\n \n     infcx.resolve_regions_and_report_errors();\n \n-    let res = impl_res {\n-        trait_vtables: vtbls,\n-        self_vtables: self_vtable_res\n-    };\n-    let res = writeback::resolve_impl_res(infcx, impl_item.span, &res);\n+    let vtbls = writeback::resolve_impl_res(infcx, impl_item.span, &vtbls);\n     let impl_def_id = ast_util::local_def(impl_item.id);\n \n     debug!(\"impl_vtables for {} are {}\",\n            impl_def_id.repr(tcx),\n-           res.repr(tcx));\n+           vtbls.repr(tcx));\n \n-    tcx.impl_vtables.borrow_mut().insert(impl_def_id, res);\n+    tcx.impl_vtables.borrow_mut().insert(impl_def_id, vtbls);\n }\n \n /// Resolve vtables for a method call after typeck has finished.\n /// Used by trans to monomorphize artificial method callees (e.g. drop).\n pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n                             substs: &subst::Substs) -> vtable_res {\n     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n-    let type_param_defs = &*generics.type_param_defs;\n     let vcx = VtableContext {\n         infcx: &infer::new_infer_ctxt(tcx),\n-        param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], [], id)\n+        param_env: &ty::construct_parameter_environment(tcx, &ty::Generics::empty(), id)\n     };\n \n     lookup_vtables(&vcx,\n                    tcx.map.span(id),\n-                   type_param_defs.as_slice(),\n+                   &generics.types,\n                    substs,\n                    false)\n }"}, {"sha": "db9e90ecd509d1636e26539d607add9e43423356", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -14,16 +14,15 @@\n \n use middle::def;\n use middle::pat_util;\n-use middle::subst;\n use middle::ty;\n use middle::ty_fold::{TypeFolder,TypeFoldable};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n-use middle::typeck::impl_res;\n use middle::typeck::{MethodCall, MethodCallee};\n+use middle::typeck::vtable_res;\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n use util::ppaux::Repr;\n@@ -66,13 +65,13 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n \n pub fn resolve_impl_res(infcx: &infer::InferCtxt,\n                         span: Span,\n-                        impl_res: &impl_res)\n-                        -> impl_res {\n+                        vtable_res: &vtable_res)\n+                        -> vtable_res {\n     let errors = Cell::new(false); // nobody cares\n     let mut resolver = Resolver::from_infcx(infcx,\n                                             &errors,\n                                             ResolvingImplRes(span));\n-    impl_res.resolve_in(&mut resolver)\n+    vtable_res.resolve_in(&mut resolver)\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -285,22 +284,12 @@ impl<'cx> WritebackCx<'cx> {\n                 debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={})\",\n                        method_call,\n                        method.repr(self.tcx()));\n-                let mut new_method = MethodCallee {\n+                let new_method = MethodCallee {\n                     origin: method.origin,\n                     ty: self.resolve(&method.ty, reason),\n                     substs: self.resolve(&method.substs, reason),\n                 };\n \n-                // Wack. For some reason I don't quite know, we always\n-                // hard-code the self-ty and regions to these\n-                // values. Changing this causes downstream errors I\n-                // don't feel like investigating right now (in\n-                // particular, self_ty is set to mk_err in some cases,\n-                // probably for invocations on objects, and this\n-                // causes encoding failures). -nmatsakis\n-                new_method.substs.self_ty = None;\n-                new_method.substs.regions = subst::ErasedRegions;\n-\n                 self.tcx().method_map.borrow_mut().insert(\n                     method_call,\n                     new_method);"}, {"sha": "04bf939ceb8d147387e11ac675cfb9b83192b81c", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 53, "deletions": 69, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -24,7 +24,7 @@ use middle::ty::{ImplContainer, lookup_item_type};\n use middle::ty::{t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_param, ty_param_bounds_and_ty, ty_ptr};\n-use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n+use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::type_is_ty_var;\n use middle::subst::Subst;\n@@ -43,7 +43,7 @@ use syntax::ast;\n use syntax::ast_map::NodeItem;\n use syntax::ast_map;\n use syntax::ast_util::{local_def};\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token;\n use syntax::visit;\n \n@@ -81,7 +81,7 @@ fn get_base_type(inference_context: &InferCtxt,\n \n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n-        ty_infer(..) | ty_param(..) | ty_self(..) | ty_err |\n+        ty_infer(..) | ty_param(..) | ty_err |\n         ty_box(_) | ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found {:?}\",\n                    get(original_type).sty);\n@@ -338,7 +338,8 @@ impl<'a> CoherenceChecker<'a> {\n     // Creates default method IDs and performs type substitutions for an impl\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n-    fn instantiate_default_methods(&self, impl_id: DefId,\n+    fn instantiate_default_methods(&self,\n+                                   impl_id: DefId,\n                                    trait_ref: &ty::TraitRef,\n                                    all_methods: &mut Vec<DefId>) {\n         let tcx = self.crate_context.tcx;\n@@ -360,6 +361,7 @@ impl<'a> CoherenceChecker<'a> {\n                 Rc::new(subst_receiver_types_in_method_ty(\n                     tcx,\n                     impl_id,\n+                    &impl_poly_type,\n                     trait_ref,\n                     new_did,\n                     &**trait_method,\n@@ -368,17 +370,11 @@ impl<'a> CoherenceChecker<'a> {\n             debug!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n             all_methods.push(new_did);\n \n-            // construct the polytype for the method based on the method_ty\n-            let new_generics = ty::Generics {\n-                type_param_defs:\n-                    Rc::new(Vec::from_slice(impl_poly_type.generics.type_param_defs()).append(\n-                            new_method_ty.generics.type_param_defs())),\n-                region_param_defs:\n-                    Rc::new(Vec::from_slice(impl_poly_type.generics.region_param_defs()).append(\n-                            new_method_ty.generics.region_param_defs()))\n-            };\n+            // construct the polytype for the method based on the\n+            // method_ty.  it will have all the generics from the\n+            // impl, plus its own.\n             let new_polytype = ty::ty_param_bounds_and_ty {\n-                generics: new_generics,\n+                generics: new_method_ty.generics.clone(),\n                 ty: ty::mk_bare_fn(tcx, new_method_ty.fty.clone())\n             };\n             debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n@@ -503,21 +499,11 @@ impl<'a> CoherenceChecker<'a> {\n     // Converts a polytype to a monotype by replacing all parameters with\n     // type variables. Returns the monotype and the type variables created.\n     fn universally_quantify_polytype(&self, polytype: ty_param_bounds_and_ty)\n-                                     -> UniversalQuantificationResult {\n-        let region_parameters =\n-            polytype.generics.region_param_defs().iter()\n-            .map(|d| self.inference_context.next_region_var(\n-                infer::BoundRegionInCoherence(d.name)))\n-            .collect();\n-\n-        let bounds_count = polytype.generics.type_param_defs().len();\n-        let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n-\n-        let substitutions = subst::Substs {\n-            regions: subst::NonerasedRegions(region_parameters),\n-            self_ty: None,\n-            tps: type_parameters\n-        };\n+                                     -> UniversalQuantificationResult\n+    {\n+        let substitutions =\n+            self.inference_context.fresh_substs_for_type(DUMMY_SP,\n+                                                         &polytype.generics);\n         let monotype = polytype.ty.subst(self.crate_context.tcx, &substitutions);\n \n         UniversalQuantificationResult {\n@@ -731,69 +717,67 @@ impl<'a> CoherenceChecker<'a> {\n }\n \n pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n-                                      impl_id: ast::DefId,\n                                       trait_ref: &ty::TraitRef,\n                                       method: &ty::Method)\n-                                      -> subst::Substs {\n+                                      -> subst::Substs\n+{\n     /*!\n      * Substitutes the values for the receiver's type parameters\n      * that are found in method, leaving the method's type parameters\n-     * intact.  This is in fact a mildly complex operation,\n-     * largely because of the hokey way that we concatenate the\n-     * receiver and method generics.\n+     * intact.\n      */\n \n-    let impl_polytype = ty::lookup_item_type(tcx, impl_id);\n-    let num_impl_tps = impl_polytype.generics.type_param_defs().len();\n-    let num_impl_regions = impl_polytype.generics.region_param_defs().len();\n     let meth_tps: Vec<ty::t> =\n-        method.generics.type_param_defs().iter().enumerate()\n-              .map(|(i, t)| ty::mk_param(tcx, i + num_impl_tps, t.def_id))\n+        method.generics.types.get_vec(subst::FnSpace)\n+              .iter()\n+              .map(|def| ty::mk_param_from_def(tcx, def))\n               .collect();\n     let meth_regions: Vec<ty::Region> =\n-        method.generics.region_param_defs().iter().enumerate()\n-              .map(|(i, l)| ty::ReEarlyBound(l.def_id.node, i + num_impl_regions, l.name))\n+        method.generics.regions.get_vec(subst::FnSpace)\n+              .iter()\n+              .map(|def| ty::ReEarlyBound(def.def_id.node, def.space,\n+                                          def.index, def.name))\n               .collect();\n-    let mut combined_tps = trait_ref.substs.tps.clone();\n-    combined_tps.push_all_move(meth_tps);\n-    let combined_regions = match &trait_ref.substs.regions {\n-        &subst::ErasedRegions =>\n-            fail!(\"make_substs_for_receiver_types: unexpected ErasedRegions\"),\n-\n-        &subst::NonerasedRegions(ref rs) => {\n-            let mut rs = rs.clone();\n-            rs.push_all_move(meth_regions);\n-            subst::NonerasedRegions(rs)\n-        }\n-    };\n-\n-    subst::Substs {\n-        regions: combined_regions,\n-        self_ty: trait_ref.substs.self_ty,\n-        tps: combined_tps\n-    }\n+    trait_ref.substs.clone().with_method(meth_tps, meth_regions)\n }\n \n fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n                                      impl_id: ast::DefId,\n+                                     impl_poly_type: &ty::ty_param_bounds_and_ty,\n                                      trait_ref: &ty::TraitRef,\n                                      new_def_id: ast::DefId,\n                                      method: &ty::Method,\n                                      provided_source: Option<ast::DefId>)\n-                                     -> ty::Method {\n-\n-    let combined_substs = make_substs_for_receiver_types(\n-        tcx, impl_id, trait_ref, method);\n+                                     -> ty::Method\n+{\n+    let combined_substs = make_substs_for_receiver_types(tcx, trait_ref, method);\n+\n+    debug!(\"subst_receiver_types_in_method_ty: combined_substs={}\",\n+           combined_substs.repr(tcx));\n+\n+    let mut method_generics = method.generics.subst(tcx, &combined_substs);\n+\n+    // replace the type parameters declared on the trait with those\n+    // from the impl\n+    for &space in [subst::TypeSpace, subst::SelfSpace].iter() {\n+        *method_generics.types.get_mut_vec(space) =\n+            impl_poly_type.generics.types.get_vec(space).clone();\n+        *method_generics.regions.get_mut_vec(space) =\n+            impl_poly_type.generics.regions.get_vec(space).clone();\n+    }\n \n-    ty::Method::new(\n-        method.ident,\n+    debug!(\"subst_receiver_types_in_method_ty: method_generics={}\",\n+           method_generics.repr(tcx));\n \n-        // method types *can* appear in the generic bounds\n-        method.generics.subst(tcx, &combined_substs),\n+    let method_fty = method.fty.subst(tcx, &combined_substs);\n \n-        // method types *can* appear in the fty\n-        method.fty.subst(tcx, &combined_substs),\n+    debug!(\"subst_receiver_types_in_method_ty: method_ty={}\",\n+           method.fty.repr(tcx));\n \n+    ty::Method::new(\n+        method.ident,\n+        method_generics,\n+        method_fty,\n         method.explicit_self,\n         method.vis,\n         new_def_id,"}, {"sha": "55969b79b5241472860ccb652a7eea67a0fcb1fc", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 292, "deletions": 319, "changes": 611, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -36,7 +36,7 @@ use middle::def;\n use middle::lang_items::SizedTraitLangItem;\n use middle::resolve_lifetime;\n use middle::subst;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{Substs};\n use middle::ty::{ImplContainer, MethodContainer, TraitContainer};\n use middle::ty::{ty_param_bounds_and_ty};\n use middle::ty;\n@@ -191,36 +191,35 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n+pub fn ensure_trait_methods(ccx: &CrateCtxt,\n+                            trait_id: ast::NodeId,\n+                            trait_def: &ty::TraitDef) {\n     let tcx = ccx.tcx;\n     match tcx.map.get(trait_id) {\n         ast_map::NodeItem(item) => {\n             match item.node {\n-                ast::ItemTrait(ref generics, _, _, ref ms) => {\n-                    let trait_ty_generics = ty_generics_for_type(ccx, generics);\n-\n+                ast::ItemTrait(_, _, _, ref ms) => {\n                     // For each method, construct a suitable ty::Method and\n                     // store it into the `tcx.methods` table:\n                     for m in ms.iter() {\n                         let ty_method = Rc::new(match m {\n                             &ast::Required(ref m) => {\n                                 ty_method_of_trait_method(\n-                                    ccx, trait_id, &trait_ty_generics,\n+                                    ccx, trait_id, &trait_def.generics,\n                                     &m.id, &m.ident, &m.explicit_self,\n                                     &m.generics, &m.fn_style, &*m.decl)\n                             }\n \n                             &ast::Provided(ref m) => {\n                                 ty_method_of_trait_method(\n-                                    ccx, trait_id, &trait_ty_generics,\n+                                    ccx, trait_id, &trait_def.generics,\n                                     &m.id, &m.ident, &m.explicit_self,\n                                     &m.generics, &m.fn_style, &*m.decl)\n                             }\n                         });\n \n                         if ty_method.explicit_self == ast::SelfStatic {\n-                            make_static_method_ty(ccx, trait_id, &*ty_method,\n-                                                  &trait_ty_generics);\n+                            make_static_method_ty(ccx, &*ty_method);\n                         }\n \n                         tcx.methods.borrow_mut().insert(ty_method.def_id,\n@@ -249,129 +248,12 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         _ => { /* Ignore things that aren't traits */ }\n     }\n \n-    fn make_static_method_ty(ccx: &CrateCtxt,\n-                             trait_id: ast::NodeId,\n-                             m: &ty::Method,\n-                             trait_ty_generics: &ty::Generics) {\n-        // If declaration is\n-        //\n-        //     trait Trait<'a,'b,'c,a,b,c> {\n-        //        fn foo<'d,'e,'f,d,e,f>(...) -> Self;\n-        //     }\n-        //\n-        // and we will create a function like\n-        //\n-        //     fn foo<'a,'b,'c,   // First the lifetime params from trait\n-        //            'd,'e,'f,   // Then lifetime params from `foo()`\n-        //            a,b,c,      // Then type params from trait\n-        //            D:Trait<'a,'b,'c,a,b,c>, // Then this sucker\n-        //            E,F,G       // Then type params from `foo()`, offset by 1\n-        //           >(...) -> D' {}\n-        //\n-        // Note that `Self` is replaced with an explicit type\n-        // parameter D that is sandwiched in between the trait params\n-        // and the method params, and thus the indices of the method\n-        // type parameters are offset by 1 (that is, the method\n-        // parameters are mapped from d, e, f to E, F, and G).  The\n-        // choice of this ordering is somewhat arbitrary.\n-        //\n-        // Note also that the bound for `D` is `Trait<'a,'b,'c,a,b,c>`.\n-        // This implies that the lifetime parameters that were inherited\n-        // from the trait (i.e., `'a`, `'b`, and `'c`) all must be early\n-        // bound, since they appear in a trait bound.\n-        //\n-        // Also, this system is rather a hack that should be replaced\n-        // with a more uniform treatment of Self (which is partly\n-        // underway).\n-\n-        // build up a subst that shifts all of the parameters over\n-        // by one and substitute in a new type param for self\n-\n-        let tcx = ccx.tcx;\n-\n-        let dummy_defid = ast::DefId {krate: 0, node: 0};\n-\n-        // Represents [A',B',C']\n-        let num_trait_bounds = trait_ty_generics.type_param_defs().len();\n-        let non_shifted_trait_tps = Vec::from_fn(num_trait_bounds, |i| {\n-            ty::mk_param(tcx, i, trait_ty_generics.type_param_defs()[i].def_id)\n-        });\n-\n-        // Represents [D']\n-        let self_param = ty::mk_param(tcx, num_trait_bounds,\n-                                      dummy_defid);\n-\n-        // Represents [E',F',G']\n-        let num_method_bounds = m.generics.type_param_defs().len();\n-        let shifted_method_tps = Vec::from_fn(num_method_bounds, |i| {\n-            ty::mk_param(tcx, i + num_trait_bounds + 1,\n-                         m.generics.type_param_defs()[i].def_id)\n-        });\n-\n-        // Convert the regions 'a, 'b, 'c defined on the trait into\n-        // bound regions on the fn. Note that because these appear in the\n-        // bound for `Self` they must be early bound.\n-        let new_early_region_param_defs = trait_ty_generics.region_param_defs.clone();\n-        let rps_from_trait =\n-            trait_ty_generics.region_param_defs().iter().\n-            enumerate().\n-            map(|(index,d)| ty::ReEarlyBound(d.def_id.node, index, d.name)).\n-            collect();\n-\n-        // build up the substitution from\n-        //     'a,'b,'c => 'a,'b,'c\n-        //     A,B,C => A',B',C'\n-        //     Self => D'\n-        //     D,E,F => E',F',G'\n-        let substs = subst::Substs {\n-            regions: subst::NonerasedRegions(rps_from_trait),\n-            self_ty: Some(self_param),\n-            tps: non_shifted_trait_tps.append(shifted_method_tps.as_slice())\n-        };\n-\n-        // create the type of `foo`, applying the substitution above\n-        let ty = ty::mk_bare_fn(tcx, m.fty.clone()).subst(tcx, &substs);\n-\n-        // create the type parameter definitions for `foo`, applying\n-        // the substitution to any traits that appear in their bounds.\n-\n-        // add in the type parameters from the trait\n-        let mut new_type_param_defs = Vec::new();\n-        let substd_type_param_defs =\n-            trait_ty_generics.type_param_defs.subst(tcx, &substs);\n-        new_type_param_defs.push_all(substd_type_param_defs.as_slice());\n-\n-        // add in the \"self\" type parameter\n-        let self_trait_def = get_trait_def(ccx, local_def(trait_id));\n-        let self_trait_ref = self_trait_def.trait_ref.subst(tcx, &substs);\n-        new_type_param_defs.push(ty::TypeParameterDef {\n-            ident: special_idents::self_,\n-            def_id: dummy_defid,\n-            bounds: Rc::new(ty::ParamBounds {\n-                builtin_bounds: ty::empty_builtin_bounds(),\n-                trait_bounds: vec!(self_trait_ref)\n-            }),\n-            default: None\n-        });\n-\n-        // add in the type parameters from the method\n-        let substd_type_param_defs = m.generics.type_param_defs.subst(tcx, &substs);\n-        new_type_param_defs.push_all(substd_type_param_defs.as_slice());\n-\n-        debug!(\"static method {} type_param_defs={} ty={}, substs={}\",\n-               m.def_id.repr(tcx),\n-               new_type_param_defs.repr(tcx),\n-               ty.repr(tcx),\n-               substs.repr(tcx));\n-\n-        tcx.tcache.borrow_mut().insert(m.def_id,\n-                          ty_param_bounds_and_ty {\n-                              generics: ty::Generics {\n-                                  type_param_defs: Rc::new(new_type_param_defs),\n-                                  region_param_defs: new_early_region_param_defs\n-                              },\n-                              ty: ty\n-                          });\n+    fn make_static_method_ty(ccx: &CrateCtxt, m: &ty::Method) {\n+        ccx.tcx.tcache.borrow_mut().insert(\n+            m.def_id,\n+            ty_param_bounds_and_ty {\n+                generics: m.generics.clone(),\n+                ty: ty::mk_bare_fn(ccx.tcx, m.fty.clone()) });\n     }\n \n     fn ty_method_of_trait_method(this: &CrateCtxt,\n@@ -384,12 +266,13 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                  m_fn_style: &ast::FnStyle,\n                                  m_decl: &ast::FnDecl) -> ty::Method\n     {\n-        let trait_self_ty = ty::mk_self(this.tcx, local_def(trait_id));\n+        let trait_self_ty = ty::mk_self_type(this.tcx, local_def(trait_id));\n         let fty = astconv::ty_of_method(this, *m_id, *m_fn_style, trait_self_ty,\n                                         *m_explicit_self, m_decl);\n-        let num_trait_type_params = trait_generics.type_param_defs().len();\n-        let ty_generics = ty_generics_for_fn_or_method(this, m_generics,\n-                                                       num_trait_type_params);\n+        let ty_generics =\n+            ty_generics_for_fn_or_method(this,\n+                                         m_generics,\n+                                         (*trait_generics).clone());\n         ty::Method::new(\n             *m_ident,\n             ty_generics,\n@@ -404,54 +287,6 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n     }\n }\n \n-pub fn ensure_supertraits(ccx: &CrateCtxt,\n-                          id: ast::NodeId,\n-                          sp: codemap::Span,\n-                          ast_trait_refs: &[ast::TraitRef],\n-                          sized: ast::Sized)\n-                          -> ty::BuiltinBounds\n-{\n-    let tcx = ccx.tcx;\n-\n-    // Called only the first time trait_def_of_item is called.\n-    // Supertraits are ensured at the same time.\n-    assert!(!tcx.supertraits.borrow().contains_key(&local_def(id)));\n-\n-    let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n-    let mut ty_trait_refs: Vec<Rc<ty::TraitRef>> = Vec::new();\n-    let mut bounds = ty::empty_builtin_bounds();\n-    for ast_trait_ref in ast_trait_refs.iter() {\n-        let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, ast_trait_ref);\n-        // FIXME(#8559): Need to instantiate the trait_ref whether or not it's a\n-        // builtin trait, so that the trait's node id appears in the tcx trait_ref\n-        // map. This is only needed for metadata; see the similar fixme in encoder.rs.\n-        let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, self_ty);\n-        if !ty::try_add_builtin_trait(ccx.tcx, trait_def_id, &mut bounds) {\n-\n-            // FIXME(#5527) Could have same trait multiple times\n-            if ty_trait_refs.iter().any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n-                // This means a trait inherited from the same supertrait more\n-                // than once.\n-                tcx.sess.span_err(sp, \"duplicate supertrait in trait declaration\");\n-                break;\n-            } else {\n-                ty_trait_refs.push(trait_ref);\n-            }\n-        }\n-    }\n-    if sized == ast::StaticSize {\n-        match tcx.lang_items.require(SizedTraitLangItem) {\n-            Ok(def_id) => {\n-                ty::try_add_builtin_trait(tcx, def_id, &mut bounds);\n-            }\n-            Err(s) => tcx.sess.err(s.as_slice()),\n-        };\n-    }\n-\n-    tcx.supertraits.borrow_mut().insert(local_def(id), Rc::new(ty_trait_refs));\n-    bounds\n-}\n-\n pub fn convert_field(ccx: &CrateCtxt,\n                      struct_generics: &ty::Generics,\n                      v: &ast::StructField,\n@@ -490,7 +325,6 @@ fn convert_methods(ccx: &CrateCtxt,\n                    ms: &[Gc<ast::Method>],\n                    untransformed_rcvr_ty: ty::t,\n                    rcvr_ty_generics: &ty::Generics,\n-                   rcvr_ast_generics: &ast::Generics,\n                    rcvr_visibility: ast::Visibility)\n {\n     let tcx = ccx.tcx;\n@@ -500,14 +334,11 @@ fn convert_methods(ccx: &CrateCtxt,\n             tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n         }\n \n-        let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs().len();\n-        let m_ty_generics = ty_generics_for_fn_or_method(ccx, &m.generics,\n-                                                         num_rcvr_ty_params);\n         let mty = Rc::new(ty_of_method(ccx,\n                                        container,\n                                        &**m,\n                                        untransformed_rcvr_ty,\n-                                       rcvr_ast_generics,\n+                                       rcvr_ty_generics,\n                                        rcvr_visibility));\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n         debug!(\"method {} (id {}) has type {}\",\n@@ -516,17 +347,8 @@ fn convert_methods(ccx: &CrateCtxt,\n                 fty.repr(ccx.tcx));\n         tcx.tcache.borrow_mut().insert(\n             local_def(m.id),\n-\n-            // n.b.: the type of a method is parameterized by both\n-            // the parameters on the receiver and those on the method\n-            // itself\n             ty_param_bounds_and_ty {\n-                generics: ty::Generics {\n-                    type_param_defs: Rc::new(Vec::from_slice(rcvr_ty_generics.type_param_defs())\n-                                             .append(m_ty_generics.type_param_defs())),\n-                    region_param_defs: Rc::new(Vec::from_slice(rcvr_ty_generics.region_param_defs())\n-                                               .append(m_ty_generics.region_param_defs())),\n-                },\n+                generics: mty.generics.clone(),\n                 ty: fty\n             });\n \n@@ -539,8 +361,9 @@ fn convert_methods(ccx: &CrateCtxt,\n                     container: MethodContainer,\n                     m: &ast::Method,\n                     untransformed_rcvr_ty: ty::t,\n-                    rcvr_generics: &ast::Generics,\n-                    rcvr_visibility: ast::Visibility) -> ty::Method\n+                    rcvr_ty_generics: &ty::Generics,\n+                    rcvr_visibility: ast::Visibility)\n+                    -> ty::Method\n     {\n         let fty = astconv::ty_of_method(ccx, m.id, m.fn_style,\n                                         untransformed_rcvr_ty,\n@@ -552,19 +375,17 @@ fn convert_methods(ccx: &CrateCtxt,\n         // foo(); }`).\n         let method_vis = m.vis.inherit_from(rcvr_visibility);\n \n-        let num_rcvr_type_params = rcvr_generics.ty_params.len();\n         let m_ty_generics =\n-            ty_generics_for_fn_or_method(ccx, &m.generics, num_rcvr_type_params);\n-        ty::Method::new(\n-            m.ident,\n-            m_ty_generics,\n-            fty,\n-            m.explicit_self.node,\n-            method_vis,\n-            local_def(m.id),\n-            container,\n-            None\n-        )\n+            ty_generics_for_fn_or_method(ccx, &m.generics,\n+                                         (*rcvr_ty_generics).clone());\n+        ty::Method::new(m.ident,\n+                        m_ty_generics,\n+                        fty,\n+                        m.explicit_self.node,\n+                        method_vis,\n+                        local_def(m.id),\n+                        container,\n+                        None)\n     }\n }\n \n@@ -634,32 +455,30 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                             ms.as_slice(),\n                             selfty,\n                             &ty_generics,\n-                            generics,\n                             parent_visibility);\n \n             for trait_ref in opt_trait_ref.iter() {\n                 instantiate_trait_ref(ccx, trait_ref, selfty);\n             }\n         },\n-        ast::ItemTrait(ref generics, _, _, ref trait_methods) => {\n+        ast::ItemTrait(_, _, _, ref trait_methods) => {\n             let trait_def = trait_def_of_item(ccx, it);\n \n             // Run convert_methods on the provided methods.\n             let (_, provided_methods) =\n                 split_trait_methods(trait_methods.as_slice());\n-            let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n+            let untransformed_rcvr_ty = ty::mk_self_type(tcx, local_def(it.id));\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n                             provided_methods.as_slice(),\n                             untransformed_rcvr_ty,\n                             &trait_def.generics,\n-                            generics,\n                             it.vis);\n \n             // We need to do this *after* converting methods, since\n             // convert_methods produces a tcache entry that is wrong for\n             // static trait methods. This is somewhat unfortunate.\n-            ensure_trait_methods(ccx, it.id);\n+            ensure_trait_methods(ccx, it.id, &*trait_def);\n         },\n         ast::ItemStruct(struct_def, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n@@ -770,7 +589,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     };\n     tcx.superstructs.borrow_mut().insert(local_def(id), super_struct);\n \n-    let substs = mk_item_substs(ccx, &tpt.generics, None);\n+    let substs = mk_item_substs(ccx, &tpt.generics);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n \n     // If this struct is enum-like or tuple-like, create the type of its\n@@ -873,32 +692,124 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n         _ => {}\n     }\n \n-    match it.node {\n+    let (generics, sized, supertraits) = match it.node {\n         ast::ItemTrait(ref generics, sized, ref supertraits, _) => {\n-            let self_ty = ty::mk_self(tcx, def_id);\n-            let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(ccx, &ty_generics, Some(self_ty));\n-            let bounds = ensure_supertraits(ccx,\n-                                            it.id,\n-                                            it.span,\n-                                            supertraits.as_slice(),\n-                                            sized);\n-            let trait_def = Rc::new(ty::TraitDef {\n-                generics: ty_generics,\n-                bounds: bounds,\n-                trait_ref: Rc::new(ty::TraitRef {\n-                    def_id: def_id,\n-                    substs: substs\n-                })\n-            });\n-            tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n-            trait_def\n+            (generics, sized, supertraits)\n         }\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n                 format!(\"trait_def_of_item invoked on {:?}\", s).as_slice());\n         }\n+    };\n+\n+    let substs = mk_trait_substs(ccx, it.id, generics);\n+\n+    let ty_generics = ty_generics_for_trait(ccx,\n+                                            it.id,\n+                                            &substs,\n+                                            generics);\n+\n+    let builtin_bounds =\n+        ensure_supertraits(ccx, it.id, it.span, supertraits, sized);\n+\n+    let substs = mk_item_substs(ccx, &ty_generics);\n+    let trait_def = Rc::new(ty::TraitDef {\n+        generics: ty_generics,\n+        bounds: builtin_bounds,\n+        trait_ref: Rc::new(ty::TraitRef {\n+            def_id: def_id,\n+            substs: substs\n+        })\n+    });\n+    tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n+\n+    return trait_def;\n+\n+    fn mk_trait_substs(ccx: &CrateCtxt,\n+                       trait_id: ast::NodeId,\n+                       generics: &ast::Generics)\n+                        -> subst::Substs\n+    {\n+        // Creates a no-op substitution for the trait's type parameters.\n+        let regions =\n+            generics.lifetimes\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, def)| ty::ReEarlyBound(def.id,\n+                                                     subst::TypeSpace,\n+                                                     i, def.name))\n+                    .collect();\n+\n+        let types =\n+            generics.ty_params\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, def)| ty::mk_param(ccx.tcx, subst::TypeSpace,\n+                                                 i, local_def(def.id)))\n+                    .collect();\n+\n+        let self_ty =\n+            ty::mk_param(ccx.tcx, subst::SelfSpace, 0, local_def(trait_id));\n+\n+        subst::Substs::new_trait(types, regions, self_ty)\n+    }\n+\n+    fn ensure_supertraits(ccx: &CrateCtxt,\n+                          id: ast::NodeId,\n+                          sp: codemap::Span,\n+                          ast_trait_refs: &Vec<ast::TraitRef>,\n+                          sized: ast::Sized)\n+                          -> ty::BuiltinBounds\n+    {\n+        let tcx = ccx.tcx;\n+\n+        // Called only the first time trait_def_of_item is called.\n+        // Supertraits are ensured at the same time.\n+        assert!(!tcx.supertraits.borrow().contains_key(&local_def(id)));\n+\n+        let self_ty = ty::mk_self_type(ccx.tcx, local_def(id));\n+        let mut ty_trait_refs: Vec<Rc<ty::TraitRef>> = Vec::new();\n+        let mut bounds = ty::empty_builtin_bounds();\n+        for ast_trait_ref in ast_trait_refs.iter() {\n+            let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, ast_trait_ref);\n+\n+            // FIXME(#8559): Need to instantiate the trait_ref whether\n+            // or not it's a builtin trait, so that the trait's node\n+            // id appears in the tcx trait_ref map. This is only\n+            // needed for metadata; see the similar fixme in\n+            // encoder.rs.\n+\n+            let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, self_ty);\n+            if !ty::try_add_builtin_trait(ccx.tcx, trait_def_id, &mut bounds) {\n+\n+                // FIXME(#5527) Could have same trait multiple times\n+                if ty_trait_refs.iter().any(\n+                    |other_trait| other_trait.def_id == trait_ref.def_id)\n+                {\n+                    // This means a trait inherited from the same\n+                    // supertrait more than once.\n+                    tcx.sess.span_err(sp, \"duplicate supertrait in \\\n+                                           trait declaration\");\n+                    break;\n+                } else {\n+                    ty_trait_refs.push(trait_ref);\n+                }\n+            }\n+        }\n+\n+        if sized == ast::StaticSize {\n+            match tcx.lang_items.require(SizedTraitLangItem) {\n+                Ok(def_id) => {\n+                    ty::try_add_builtin_trait(tcx, def_id, &mut bounds);\n+                }\n+                Err(s) => tcx.sess.err(s.as_slice()),\n+            };\n+        }\n+\n+        tcx.supertraits.borrow_mut().insert(local_def(id),\n+                                            Rc::new(ty_trait_refs));\n+        bounds\n     }\n }\n \n@@ -919,7 +830,8 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             return tpt;\n         }\n         ast::ItemFn(decl, fn_style, abi, ref generics, _) => {\n-            let ty_generics = ty_generics_for_fn_or_method(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_fn_or_method(ccx, generics,\n+                                                           ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(ccx,\n                                               it.id,\n                                               fn_style,\n@@ -957,7 +869,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n             let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(ccx, &ty_generics, None);\n+            let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_enum(tcx, local_def(it.id), substs);\n             let tpt = ty_param_bounds_and_ty {\n                 generics: ty_generics,\n@@ -972,7 +884,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n         }\n         ast::ItemStruct(_, ref generics) => {\n             let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(ccx, &ty_generics, None);\n+            let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_struct(tcx, local_def(it.id), substs);\n             let tpt = ty_param_bounds_and_ty {\n                 generics: ty_generics,\n@@ -1001,10 +913,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n         }\n         ast::ForeignItemStatic(t, _) => {\n             ty::ty_param_bounds_and_ty {\n-                generics: ty::Generics {\n-                    type_param_defs: Rc::new(Vec::new()),\n-                    region_param_defs: Rc::new(Vec::new()),\n-                },\n+                generics: ty::Generics::empty(),\n                 ty: ast_ty_to_ty(ccx, &ExplicitRscope, &*t)\n             }\n         }\n@@ -1013,75 +922,139 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n \n fn ty_generics_for_type(ccx: &CrateCtxt,\n                         generics: &ast::Generics)\n-                        -> ty::Generics {\n-    ty_generics(ccx, &generics.lifetimes, &generics.ty_params, 0)\n+                        -> ty::Generics\n+{\n+    ty_generics(ccx, subst::TypeSpace, &generics.lifetimes,\n+                &generics.ty_params, ty::Generics::empty())\n+}\n+\n+fn ty_generics_for_trait(ccx: &CrateCtxt,\n+                         trait_id: ast::NodeId,\n+                         substs: &subst::Substs,\n+                         generics: &ast::Generics)\n+                         -> ty::Generics\n+{\n+    let mut generics = ty_generics(ccx, subst::TypeSpace, &generics.lifetimes,\n+                                   &generics.ty_params, ty::Generics::empty());\n+\n+    // Something of a hack: use the node id for the trait, also as\n+    // the node id for the Self type parameter.\n+    let param_id = trait_id;\n+\n+    let self_trait_ref =\n+        Rc::new(ty::TraitRef { def_id: local_def(trait_id),\n+                               substs: (*substs).clone() });\n+\n+    let def = ty::TypeParameterDef {\n+        space: subst::SelfSpace,\n+        index: 0,\n+        ident: special_idents::type_self,\n+        def_id: local_def(param_id),\n+        bounds: Rc::new(ty::ParamBounds {\n+            builtin_bounds: ty::empty_builtin_bounds(),\n+            trait_bounds: vec!(self_trait_ref),\n+        }),\n+        default: None\n+    };\n+\n+    ccx.tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n+\n+    generics.types.push(subst::SelfSpace, def);\n+\n+    generics\n }\n \n fn ty_generics_for_fn_or_method(ccx: &CrateCtxt,\n                                 generics: &ast::Generics,\n-                                base_index: uint)\n-                                -> ty::Generics {\n+                                base_generics: ty::Generics)\n+                                -> ty::Generics\n+{\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n-    ty_generics(ccx, &early_lifetimes, &generics.ty_params, base_index)\n+    ty_generics(ccx, subst::FnSpace, &early_lifetimes,\n+                &generics.ty_params, base_generics)\n }\n \n fn ty_generics(ccx: &CrateCtxt,\n+               space: subst::ParamSpace,\n                lifetimes: &Vec<ast::Lifetime>,\n-               ty_params: &OwnedSlice<ast::TyParam>,\n-               base_index: uint) -> ty::Generics {\n-    return ty::Generics {\n-        region_param_defs: Rc::new(lifetimes.iter().map(|l| {\n-                ty::RegionParameterDef { name: l.name,\n-                                         def_id: local_def(l.id) }\n-            }).collect()),\n-        type_param_defs: Rc::new(ty_params.iter().enumerate().map(|(offset, param)| {\n-            let existing_def_opt = {\n-                let ty_param_defs = ccx.tcx.ty_param_defs.borrow();\n-                ty_param_defs.find(&param.id).map(|def| def.clone())\n-            };\n-            existing_def_opt.unwrap_or_else(|| {\n-                let param_ty = ty::param_ty {idx: base_index + offset,\n-                                             def_id: local_def(param.id)};\n-                let bounds = Rc::new(compute_bounds(ccx,\n-                                                    param_ty,\n-                                                    &param.bounds,\n-                                                    param.sized,\n-                                                    param.ident,\n-                                                    param.span));\n-                let default = param.default.map(|path| {\n-                    let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*path);\n-                    let cur_idx = param_ty.idx;\n-\n-                    ty::walk_ty(ty, |t| {\n-                        match ty::get(t).sty {\n-                            ty::ty_param(p) => if p.idx > cur_idx {\n-                                ccx.tcx.sess.span_err(path.span,\n-                                                        \"type parameters with a default cannot use \\\n-                                                        forward declared identifiers\")\n-                            },\n-                            _ => {}\n-                        }\n-                    });\n+               types: &OwnedSlice<ast::TyParam>,\n+               base_generics: ty::Generics)\n+               -> ty::Generics\n+{\n+    let mut result = base_generics;\n+\n+    for (i, l) in lifetimes.iter().enumerate() {\n+        result.regions.push(space,\n+                            ty::RegionParameterDef { name: l.name,\n+                                                     space: space,\n+                                                     index: i,\n+                                                     def_id: local_def(l.id) });\n+    }\n \n-                    ty\n-                });\n+    for (i, param) in types.iter().enumerate() {\n+        let def = get_or_create_type_parameter_def(ccx, space, param, i);\n+        debug!(\"def for param: {}\", def.repr(ccx.tcx));\n+        result.types.push(space, def);\n+    }\n \n-                let def = ty::TypeParameterDef {\n-                    ident: param.ident,\n-                    def_id: local_def(param.id),\n-                    bounds: bounds,\n-                    default: default\n-                };\n-                debug!(\"def for param: {}\", def.repr(ccx.tcx));\n-                ccx.tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n-                def\n-            })\n-        }).collect()),\n-    };\n+    return result;\n+\n+    fn get_or_create_type_parameter_def(ccx: &CrateCtxt,\n+                                        space: subst::ParamSpace,\n+                                        param: &ast::TyParam,\n+                                        index: uint)\n+                                        -> ty::TypeParameterDef\n+    {\n+        match ccx.tcx.ty_param_defs.borrow().find(&param.id) {\n+            Some(d) => { return (*d).clone(); }\n+            None => { }\n+        }\n+\n+        let param_ty = ty::ParamTy {space: space,\n+                                    idx: index,\n+                                    def_id: local_def(param.id)};\n+        let bounds = Rc::new(compute_bounds(ccx,\n+                                            param_ty,\n+                                            &param.bounds,\n+                                            param.sized,\n+                                            param.ident,\n+                                            param.span));\n+        let default = param.default.map(|path| {\n+            let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*path);\n+            let cur_idx = param_ty.idx;\n+\n+            ty::walk_ty(ty, |t| {\n+                match ty::get(t).sty {\n+                    ty::ty_param(p) => if p.idx > cur_idx {\n+                        ccx.tcx.sess.span_err(\n+                            path.span,\n+                            \"type parameters with a default cannot use \\\n+                             forward declared identifiers\")\n+                    },\n+                    _ => {}\n+                }\n+            });\n+\n+            ty\n+        });\n+\n+        let def = ty::TypeParameterDef {\n+            space: space,\n+            index: index,\n+            ident: param.ident,\n+            def_id: local_def(param.id),\n+            bounds: bounds,\n+            default: default\n+        };\n+\n+        ccx.tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n+\n+        def\n+    }\n \n     fn compute_bounds(\n         ccx: &CrateCtxt,\n-        param_ty: ty::param_ty,\n+        param_ty: ty::ParamTy,\n         ast_bounds: &OwnedSlice<ast::TyParamBound>,\n         sized: ast::Sized,\n         ident: ast::Ident,\n@@ -1101,7 +1074,8 @@ fn ty_generics(ccx: &CrateCtxt,\n         for ast_bound in ast_bounds.iter() {\n             match *ast_bound {\n                 TraitTyParamBound(ref b) => {\n-                    let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n+                    let ty = ty::mk_param(ccx.tcx, param_ty.space,\n+                                          param_ty.idx, param_ty.def_id);\n                     let trait_ref = instantiate_trait_ref(ccx, b, ty);\n                     if !ty::try_add_builtin_trait(\n                             ccx.tcx, trait_ref.def_id,\n@@ -1117,15 +1091,15 @@ fn ty_generics(ccx: &CrateCtxt,\n \n                 UnboxedFnTyParamBound(ref unboxed_function) => {\n                     let rscope = ExplicitRscope;\n-                    let mut trait_ref =\n-                        astconv::trait_ref_for_unboxed_function(\n-                            ccx,\n-                            &rscope,\n-                            unboxed_function);\n                     let self_ty = ty::mk_param(ccx.tcx,\n+                                               param_ty.space,\n                                                param_ty.idx,\n                                                param_ty.def_id);\n-                    trait_ref.substs.self_ty = Some(self_ty);\n+                    let trait_ref =\n+                        astconv::trait_ref_for_unboxed_function(ccx,\n+                                                                &rscope,\n+                                                                unboxed_function,\n+                                                                Some(self_ty));\n                     param_bounds.trait_bounds.push(Rc::new(trait_ref));\n                 }\n \n@@ -1196,7 +1170,8 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     }\n \n     let ty_generics_for_fn_or_method =\n-        ty_generics_for_fn_or_method(ccx, ast_generics, 0);\n+        ty_generics_for_fn_or_method(ccx, ast_generics,\n+                                     ty::Generics::empty());\n     let rb = BindingRscope::new(def_id.node);\n     let input_tys = decl.inputs\n                         .iter()\n@@ -1225,19 +1200,17 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n }\n \n pub fn mk_item_substs(ccx: &CrateCtxt,\n-                      ty_generics: &ty::Generics,\n-                      self_ty: Option<ty::t>)\n+                      ty_generics: &ty::Generics)\n                       -> subst::Substs\n {\n-    let params: Vec<ty::t> =\n-        ty_generics.type_param_defs().iter().enumerate().map(\n-            |(i, t)| ty::mk_param(ccx.tcx, i, t.def_id)).collect();\n+    let types =\n+        ty_generics.types.map(\n+            |def| ty::mk_param_from_def(ccx.tcx, def));\n \n-    let regions: Vec<ty::Region> =\n-        ty_generics.region_param_defs().iter().enumerate().map(\n-            |(i, l)| ty::ReEarlyBound(l.def_id.node, i, l.name)).collect();\n+    let regions =\n+        ty_generics.regions.map(\n+            |def| ty::ReEarlyBound(def.def_id.node, def.space,\n+                                   def.index, def.name));\n \n-    subst::Substs {regions: subst::NonerasedRegions(regions),\n-                   self_ty: self_ty,\n-                   tps: params}\n+    subst::Substs::new(types, regions)\n }"}, {"sha": "ac6851518083dcfd7a6fb34be94fd053676e519f", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 93, "deletions": 91, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -53,7 +53,7 @@ use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n use middle::ty;\n-use middle::typeck::infer::{then, ToUres};\n+use middle::typeck::infer::{ToUres};\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n@@ -84,113 +84,115 @@ pub trait Combine {\n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n \n-    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<Vec<ty::t> > {\n-\n-        // Note: type parameters are always treated as *invariant*\n-        // (otherwise the type system would be unsound).  In the\n-        // future we could allow type parameters to declare a\n-        // variance.\n-\n-        if as_.len() == bs.len() {\n-            result::fold_(as_.iter().zip(bs.iter())\n-                          .map(|(a, b)| eq_tys(self, *a, *b)))\n-                .then(|| Ok(Vec::from_slice(as_)))\n-        } else {\n-            Err(ty::terr_ty_param_size(expected_found(self,\n-                                                      as_.len(),\n-                                                      bs.len())))\n+    fn tps(&self,\n+           space: subst::ParamSpace,\n+           as_: &[ty::t],\n+           bs: &[ty::t])\n+           -> cres<Vec<ty::t>>\n+    {\n+        // FIXME(#5781) -- In general, we treat variance a bit wrong\n+        // here. For historical reasons, we treat Self as\n+        // contravariant and other tps as invariant. Both are wrong:\n+        // Self may or may not be contravariant, and other tps do not\n+        // need to be invariant.\n+\n+        if as_.len() != bs.len() {\n+            return Err(ty::terr_ty_param_size(expected_found(self,\n+                                                             as_.len(),\n+                                                             bs.len())));\n         }\n-    }\n-\n-    fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n-               -> cres<Option<ty::t>> {\n \n-        match (a, b) {\n-            (None, None) => {\n-                Ok(None)\n-            }\n-            (Some(a), Some(b)) => {\n-                // FIXME(#5781) this should be eq_tys\n-                // eq_tys(self, a, b).then(|| Ok(Some(a)) )\n-                self.contratys(a, b).and_then(|t| Ok(Some(t)))\n+        match space {\n+            subst::SelfSpace => {\n+                result::fold(as_\n+                             .iter()\n+                             .zip(bs.iter())\n+                             .map(|(a, b)| self.contratys(*a, *b)),\n+                             Vec::new(),\n+                             |mut v, a| { v.push(a); v })\n             }\n-            (None, Some(_)) |\n-                (Some(_), None) => {\n-                // I think it should never happen that we unify two\n-                // substs and one of them has a self_ty and one\n-                // doesn't...? I could be wrong about this.\n-                self.infcx().tcx.sess.bug(\"substitution a had a self_ty \\\n-                                           and substitution b didn't, or \\\n-                                           vice versa\");\n+\n+            subst::TypeSpace | subst::FnSpace => {\n+                try!(result::fold_(as_\n+                                  .iter()\n+                                  .zip(bs.iter())\n+                                  .map(|(a, b)| eq_tys(self, *a, *b))));\n+                Ok(Vec::from_slice(as_))\n             }\n         }\n     }\n \n     fn substs(&self,\n               item_def_id: ast::DefId,\n-              as_: &subst::Substs,\n-              bs: &subst::Substs)\n+              a_subst: &subst::Substs,\n+              b_subst: &subst::Substs)\n               -> cres<subst::Substs>\n     {\n+        let variances = ty::item_variances(self.infcx().tcx, item_def_id);\n+        let mut substs = subst::Substs::empty();\n+\n+        for &space in subst::ParamSpace::all().iter() {\n+            let a_tps = a_subst.types.get_vec(space);\n+            let b_tps = b_subst.types.get_vec(space);\n+            let tps = if_ok!(self.tps(space,\n+                                      a_tps.as_slice(),\n+                                      b_tps.as_slice()));\n+\n+            let a_regions = a_subst.regions().get_vec(space);\n+            let b_regions = b_subst.regions().get_vec(space);\n+            let r_variances = variances.regions.get_vec(space);\n+            let regions = if_ok!(relate_region_params(self,\n+                                                      item_def_id,\n+                                                      r_variances,\n+                                                      a_regions,\n+                                                      b_regions));\n+\n+            *substs.types.get_mut_vec(space) = tps;\n+            *substs.mut_regions().get_mut_vec(space) = regions;\n+        }\n+\n+        return Ok(substs);\n+\n         fn relate_region_params<C:Combine>(this: &C,\n                                            item_def_id: ast::DefId,\n-                                           a: &subst::RegionSubsts,\n-                                           b: &subst::RegionSubsts)\n-                                           -> cres<subst::RegionSubsts> {\n+                                           variances: &Vec<ty::Variance>,\n+                                           a_rs: &Vec<ty::Region>,\n+                                           b_rs: &Vec<ty::Region>)\n+                                           -> cres<Vec<ty::Region>>\n+        {\n             let tcx = this.infcx().tcx;\n-            match (a, b) {\n-                (&subst::ErasedRegions, _) | (_, &subst::ErasedRegions) => {\n-                    Ok(subst::ErasedRegions)\n-                }\n-\n-                (&subst::NonerasedRegions(ref a_rs),\n-                 &subst::NonerasedRegions(ref b_rs)) => {\n-                    let variances = ty::item_variances(tcx, item_def_id);\n-                    let region_params = &variances.region_params;\n-                    let num_region_params = region_params.len();\n-\n-                    debug!(\"relate_region_params(\\\n-                            item_def_id={}, \\\n-                            a_rs={}, \\\n-                            b_rs={},\n-                            region_params={})\",\n-                            item_def_id.repr(tcx),\n-                            a_rs.repr(tcx),\n-                            b_rs.repr(tcx),\n-                            region_params.repr(tcx));\n-\n-                    assert_eq!(num_region_params, a_rs.len());\n-                    assert_eq!(num_region_params, b_rs.len());\n-                    let mut rs = vec!();\n-                    for i in range(0, num_region_params) {\n-                        let a_r = *a_rs.get(i);\n-                        let b_r = *b_rs.get(i);\n-                        let variance = *region_params.get(i);\n-                        let r = match variance {\n-                            ty::Invariant => {\n-                                eq_regions(this, a_r, b_r)\n-                                    .and_then(|()| Ok(a_r))\n-                            }\n-                            ty::Covariant => this.regions(a_r, b_r),\n-                            ty::Contravariant => this.contraregions(a_r, b_r),\n-                            ty::Bivariant => Ok(a_r),\n-                        };\n-                        rs.push(if_ok!(r));\n+            let num_region_params = variances.len();\n+\n+            debug!(\"relate_region_params(\\\n+                   item_def_id={}, \\\n+                   a_rs={}, \\\n+                   b_rs={},\n+                   variances={})\",\n+                   item_def_id.repr(tcx),\n+                   a_rs.repr(tcx),\n+                   b_rs.repr(tcx),\n+                   variances.repr(tcx));\n+\n+            assert_eq!(num_region_params, a_rs.len());\n+            assert_eq!(num_region_params, b_rs.len());\n+            let mut rs = vec!();\n+            for i in range(0, num_region_params) {\n+                let a_r = *a_rs.get(i);\n+                let b_r = *b_rs.get(i);\n+                let variance = *variances.get(i);\n+                let r = match variance {\n+                    ty::Invariant => {\n+                        eq_regions(this, a_r, b_r)\n+                            .and_then(|()| Ok(a_r))\n                     }\n-                    Ok(subst::NonerasedRegions(rs))\n-                }\n+                    ty::Covariant => this.regions(a_r, b_r),\n+                    ty::Contravariant => this.contraregions(a_r, b_r),\n+                    ty::Bivariant => Ok(a_r),\n+                };\n+                rs.push(if_ok!(r));\n             }\n+            Ok(rs)\n         }\n-\n-        let tps = if_ok!(self.tps(as_.tps.as_slice(), bs.tps.as_slice()));\n-        let self_ty = if_ok!(self.self_tys(as_.self_ty, bs.self_ty));\n-        let regions = if_ok!(relate_region_params(self,\n-                                                  item_def_id,\n-                                                  &as_.regions,\n-                                                  &bs.regions));\n-        Ok(subst::Substs { regions: regions,\n-                           self_ty: self_ty,\n-                           tps: tps.clone() })\n     }\n \n     fn bare_fn_tys(&self, a: &ty::BareFnTy,"}, {"sha": "bcd66ed4d66f293119767b7d1a5c3df6f608f4d9", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -61,6 +61,7 @@ time of error detection.\n \n use std::collections::HashSet;\n use middle::def;\n+use middle::subst;\n use middle::ty;\n use middle::ty::{Region, ReFree};\n use middle::typeck::infer;\n@@ -1055,9 +1056,10 @@ impl<'a> Rebuilder<'a> {\n                                 ty: _\n                             } = ty::lookup_item_type(self.tcx, did);\n \n-                            let expected = generics.region_param_defs().len();\n-                            let lifetimes = &path.segments.last()\n-                                                 .unwrap().lifetimes;\n+                            let expected =\n+                                generics.regions.len(subst::TypeSpace);\n+                            let lifetimes =\n+                                &path.segments.last().unwrap().lifetimes;\n                             let mut insert = Vec::new();\n                             if lifetimes.len() == 0 {\n                                 let anon = self.cur_anon.get();"}, {"sha": "f43ee1e8aabaac2c2929ef278d052b6fd27a17c8", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -21,7 +21,8 @@ pub use middle::typeck::infer::resolve::{resolve_ivar, resolve_all};\n pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n pub use middle::typeck::infer::resolve::{resolve_rvar};\n \n-use std::collections::HashMap;\n+use middle::subst;\n+use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty;\n use middle::ty_fold;\n@@ -37,6 +38,7 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n use std::cell::{Cell, RefCell};\n+use std::collections::HashMap;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap;\n@@ -588,6 +590,7 @@ impl<'a> InferCtxt<'a> {\n             let vals = &mut ty_var_bindings.vals;\n             vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n         }\n+        debug!(\"created type variable {}\", TyVid(id));\n         return TyVid(id);\n     }\n \n@@ -623,13 +626,35 @@ impl<'a> InferCtxt<'a> {\n \n     pub fn region_vars_for_defs(&self,\n                                 span: Span,\n-                                defs: &[ty::RegionParameterDef])\n+                                defs: &Vec<ty::RegionParameterDef>)\n                                 -> Vec<ty::Region> {\n         defs.iter()\n             .map(|d| self.next_region_var(EarlyBoundRegion(span, d.name)))\n             .collect()\n     }\n \n+    pub fn fresh_substs_for_type(&self,\n+                                 span: Span,\n+                                 generics: &ty::Generics)\n+                                 -> subst::Substs\n+    {\n+        /*!\n+         * Given a set of generics defined on a type or impl, returns\n+         * a substitution mapping each type/region parameter to a\n+         * fresh inference variable.\n+         */\n+        assert!(generics.types.len(subst::SelfSpace) == 0);\n+        assert!(generics.types.len(subst::FnSpace) == 0);\n+        assert!(generics.regions.len(subst::SelfSpace) == 0);\n+        assert!(generics.regions.len(subst::FnSpace) == 0);\n+\n+        let type_parameter_count = generics.types.len(subst::TypeSpace);\n+        let region_param_defs = generics.regions.get_vec(subst::TypeSpace);\n+        let regions = self.region_vars_for_defs(span, region_param_defs);\n+        let type_parameters = self.next_ty_vars(type_parameter_count);\n+        subst::Substs::new_type(type_parameters, regions)\n+    }\n+\n     pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n         self.region_vars.new_bound(binder_id)\n     }"}, {"sha": "b5c103b84812a074c2030f437836dd9825e25f7d", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -66,14 +66,14 @@ use driver::config;\n use middle::def;\n use middle::resolve;\n use middle::subst;\n+use middle::subst::VecPerParamSpace;\n use middle::ty;\n use util::common::time;\n use util::ppaux::Repr;\n use util::ppaux;\n use util::nodemap::{DefIdMap, FnvHashMap};\n \n use std::cell::RefCell;\n-use std::rc::Rc;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n@@ -87,9 +87,9 @@ pub mod coherence;\n pub mod variance;\n \n #[deriving(Clone, Encodable, Decodable, PartialEq, PartialOrd)]\n-pub enum param_index {\n-    param_numbered(uint),\n-    param_self\n+pub struct param_index {\n+    pub space: subst::ParamSpace,\n+    pub index: uint\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -176,8 +176,9 @@ impl MethodCall {\n pub type MethodMap = RefCell<FnvHashMap<MethodCall, MethodCallee>>;\n \n pub type vtable_param_res = Vec<vtable_origin>;\n+\n // Resolutions for bounds of all parameters, left to right, for a given path.\n-pub type vtable_res = Vec<vtable_param_res>;\n+pub type vtable_res = VecPerParamSpace<vtable_param_res>;\n \n #[deriving(Clone)]\n pub enum vtable_origin {\n@@ -197,6 +198,14 @@ pub enum vtable_origin {\n       and the second is the bound number (identifying baz)\n      */\n     vtable_param(param_index, uint),\n+\n+    /*\n+      Asked to determine the vtable for ty_err. This is the value used\n+      for the vtables of `Self` in a virtual call like `foo.bar()`\n+      where `foo` is of object type. The same value is also used when\n+      type errors occur.\n+     */\n+    vtable_error,\n }\n \n impl Repr for vtable_origin {\n@@ -213,40 +222,18 @@ impl Repr for vtable_origin {\n             vtable_param(x, y) => {\n                 format!(\"vtable_param({:?}, {:?})\", x, y)\n             }\n+\n+            vtable_error => {\n+                format!(\"vtable_error\")\n+            }\n         }\n     }\n }\n \n pub type vtable_map = RefCell<FnvHashMap<MethodCall, vtable_res>>;\n \n \n-// Information about the vtable resolutions for a trait impl.\n-// Mostly the information is important for implementing default\n-// methods.\n-#[deriving(Clone)]\n-pub struct impl_res {\n-    // resolutions for any bounded params on the trait definition\n-    pub trait_vtables: vtable_res,\n-    // resolutions for the trait /itself/ (and for supertraits)\n-    pub self_vtables: vtable_param_res\n-}\n-\n-impl Repr for impl_res {\n-    #[cfg(stage0)]\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"impl_res \\\\{trait_vtables={}, self_vtables={}\\\\}\",\n-                self.trait_vtables.repr(tcx),\n-                self.self_vtables.repr(tcx))\n-    }\n-    #[cfg(not(stage0))]\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"impl_res {{trait_vtables={}, self_vtables={}}}\",\n-                self.trait_vtables.repr(tcx),\n-                self.self_vtables.repr(tcx))\n-    }\n-}\n-\n-pub type impl_vtable_map = RefCell<DefIdMap<impl_res>>;\n+pub type impl_vtable_map = RefCell<DefIdMap<vtable_res>>;\n \n pub struct CrateCtxt<'a> {\n     // A mapping from method call sites to traits that have that method.\n@@ -268,8 +255,7 @@ pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n                node_id,\n                item_substs.repr(tcx));\n \n-        assert!(item_substs.substs.tps.iter().\n-                all(|t| !ty::type_needs_infer(*t)));\n+        assert!(item_substs.substs.types.all(|t| !ty::type_needs_infer(*t)));\n \n         tcx.item_substs.borrow_mut().insert(node_id, item_substs);\n     }\n@@ -290,8 +276,8 @@ pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n \n pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {type_param_defs: Rc::new(Vec::new()),\n-                                region_param_defs: Rc::new(Vec::new())},\n+        generics: ty::Generics {types: VecPerParamSpace::empty(),\n+                                regions: VecPerParamSpace::empty()},\n         ty: t\n     }\n }"}, {"sha": "3731990e61faa0de4cd167474ad1025b53eac3b5", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 90, "deletions": 57, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -195,14 +195,15 @@ represents the \"variance transform\" as defined in the paper:\n use std::collections::HashMap;\n use arena;\n use arena::Arena;\n+use rl = middle::resolve_lifetime;\n use middle::subst;\n+use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace};\n use middle::ty;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n use util::ppaux::Repr;\n@@ -266,11 +267,17 @@ struct TermsContext<'a> {\n     inferred_infos: Vec<InferredInfo<'a>> ,\n }\n \n-enum ParamKind { TypeParam, RegionParam, SelfParam }\n+#[deriving(Show)]\n+enum ParamKind {\n+    TypeParam,\n+    RegionParam\n+}\n \n struct InferredInfo<'a> {\n     item_id: ast::NodeId,\n     kind: ParamKind,\n+    space: ParamSpace,\n+    index: uint,\n     param_id: ast::NodeId,\n     term: VarianceTermPtr<'a>,\n }\n@@ -288,9 +295,8 @@ fn determine_parameters_to_be_inferred<'a>(tcx: &'a ty::ctxt,\n         // cache and share the variance struct used for items with\n         // no type/region parameters\n         empty_variances: Rc::new(ty::ItemVariances {\n-            self_param: None,\n-            type_params: OwnedSlice::empty(),\n-            region_params: OwnedSlice::empty()\n+            types: VecPerParamSpace::empty(),\n+            regions: VecPerParamSpace::empty()\n         })\n     };\n \n@@ -303,12 +309,15 @@ impl<'a> TermsContext<'a> {\n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n+                    space: ParamSpace,\n                     index: uint,\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(|| InferredTerm(inf_index));\n         self.inferred_infos.push(InferredInfo { item_id: item_id,\n                                                 kind: kind,\n+                                                space: space,\n+                                                index: index,\n                                                 param_id: param_id,\n                                                 term: term });\n         let newly_added = self.inferred_map.insert(param_id, inf_index);\n@@ -338,7 +347,7 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n         // item are assigned continuous indices.\n         match item.node {\n             ast::ItemTrait(..) => {\n-                self.add_inferred(item.id, SelfParam, 0, item.id);\n+                self.add_inferred(item.id, TypeParam, SelfSpace, 0, item.id);\n             }\n             _ => { }\n         }\n@@ -348,10 +357,10 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n             ast::ItemStruct(_, ref generics) |\n             ast::ItemTrait(ref generics, _, _, _) => {\n                 for (i, p) in generics.lifetimes.iter().enumerate() {\n-                    self.add_inferred(item.id, RegionParam, i, p.id);\n+                    self.add_inferred(item.id, RegionParam, TypeSpace, i, p.id);\n                 }\n                 for (i, p) in generics.ty_params.iter().enumerate() {\n-                    self.add_inferred(item.id, TypeParam, i, p.id);\n+                    self.add_inferred(item.id, TypeParam, TypeSpace, i, p.id);\n                 }\n \n                 // If this item has no type or lifetime parameters,\n@@ -399,9 +408,9 @@ struct ConstraintContext<'a> {\n     // are indexed by the `ParamKind` (type, lifetime, self). Note\n     // that there are no marker types for self, so the entries for\n     // self are always None.\n-    invariant_lang_items: [Option<ast::DefId>, ..3],\n-    covariant_lang_items: [Option<ast::DefId>, ..3],\n-    contravariant_lang_items: [Option<ast::DefId>, ..3],\n+    invariant_lang_items: [Option<ast::DefId>, ..2],\n+    covariant_lang_items: [Option<ast::DefId>, ..2],\n+    contravariant_lang_items: [Option<ast::DefId>, ..2],\n \n     // These are pointers to common `ConstantTerm` instances\n     covariant: VarianceTermPtr<'a>,\n@@ -422,9 +431,9 @@ struct Constraint<'a> {\n fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n                                   krate: &ast::Crate)\n                                   -> ConstraintContext<'a> {\n-    let mut invariant_lang_items = [None, ..3];\n-    let mut covariant_lang_items = [None, ..3];\n-    let mut contravariant_lang_items = [None, ..3];\n+    let mut invariant_lang_items = [None, ..2];\n+    let mut covariant_lang_items = [None, ..2];\n+    let mut contravariant_lang_items = [None, ..2];\n \n     covariant_lang_items[TypeParam as uint] =\n         terms_cx.tcx.lang_items.covariant_type();\n@@ -547,7 +556,7 @@ impl<'a> ConstraintContext<'a> {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.map, param_id));\n         match tcx.named_region_map.find(&param_id) {\n-            Some(&ast::DefEarlyBoundRegion(_, lifetime_decl_id))\n+            Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n                 => lifetime_decl_id,\n             Some(_) => fail!(\"should not encounter non early-bound cases\"),\n \n@@ -611,6 +620,7 @@ impl<'a> ConstraintContext<'a> {\n                          param_def_id: ast::DefId,\n                          item_def_id: ast::DefId,\n                          kind: ParamKind,\n+                         space: ParamSpace,\n                          index: uint)\n                          -> VarianceTermPtr<'a> {\n         /*!\n@@ -637,9 +647,8 @@ impl<'a> ConstraintContext<'a> {\n             // variance already inferred, just look it up.\n             let variances = ty::item_variances(self.tcx(), item_def_id);\n             let variance = match kind {\n-                SelfParam => variances.self_param.unwrap(),\n-                TypeParam => *variances.type_params.get(index),\n-                RegionParam => *variances.region_params.get(index),\n+                TypeParam => *variances.types.get(space, index),\n+                RegionParam => *variances.regions.get(space, index),\n             };\n             self.constant_term(variance)\n         }\n@@ -736,17 +745,50 @@ impl<'a> ConstraintContext<'a> {\n             ty::ty_enum(def_id, ref substs) |\n             ty::ty_struct(def_id, ref substs) => {\n                 let item_type = ty::lookup_item_type(self.tcx(), def_id);\n-                self.add_constraints_from_substs(def_id, &item_type.generics,\n-                                                 substs, variance);\n+                let generics = &item_type.generics;\n+\n+                // All type parameters on enums and structs should be\n+                // in the TypeSpace.\n+                assert!(generics.types.get_vec(subst::SelfSpace).is_empty());\n+                assert!(generics.types.get_vec(subst::FnSpace).is_empty());\n+                assert!(generics.regions.get_vec(subst::SelfSpace).is_empty());\n+                assert!(generics.regions.get_vec(subst::FnSpace).is_empty());\n+\n+                self.add_constraints_from_substs(\n+                    def_id,\n+                    generics.types.get_vec(subst::TypeSpace),\n+                    generics.regions.get_vec(subst::TypeSpace),\n+                    substs,\n+                    variance);\n             }\n \n             ty::ty_trait(box ty::TyTrait { def_id, ref substs, .. }) => {\n                 let trait_def = ty::lookup_trait_def(self.tcx(), def_id);\n-                self.add_constraints_from_substs(def_id, &trait_def.generics,\n-                                                 substs, variance);\n+                let generics = &trait_def.generics;\n+\n+                // Traits DO have a Self type parameter, but it is\n+                // erased from object types.\n+                assert!(!generics.types.get_vec(subst::SelfSpace).is_empty() &&\n+                        substs.types.get_vec(subst::SelfSpace).is_empty());\n+\n+                // Traits never declare region parameters in the self\n+                // space.\n+                assert!(generics.regions.get_vec(subst::SelfSpace).is_empty());\n+\n+                // Traits never declare type/region parameters in the\n+                // fn space.\n+                assert!(generics.types.get_vec(subst::FnSpace).is_empty());\n+                assert!(generics.regions.get_vec(subst::FnSpace).is_empty());\n+\n+                self.add_constraints_from_substs(\n+                    def_id,\n+                    generics.types.get_vec(subst::TypeSpace),\n+                    generics.regions.get_vec(subst::TypeSpace),\n+                    substs,\n+                    variance);\n             }\n \n-            ty::ty_param(ty::param_ty { def_id: ref def_id, .. }) => {\n+            ty::ty_param(ty::ParamTy { def_id: ref def_id, .. }) => {\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n                 match self.terms_cx.inferred_map.find(&def_id.node) {\n                     Some(&index) => {\n@@ -760,12 +802,6 @@ impl<'a> ConstraintContext<'a> {\n                 }\n             }\n \n-            ty::ty_self(ref def_id) => {\n-                assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n-                let index = self.inferred_index(def_id.node);\n-                self.add_constraint(index, variance);\n-            }\n-\n             ty::ty_bare_fn(ty::BareFnTy { ref sig, .. }) |\n             ty::ty_closure(box ty::ClosureTy {\n                     ref sig,\n@@ -796,28 +832,28 @@ impl<'a> ConstraintContext<'a> {\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n                                    def_id: ast::DefId,\n-                                   generics: &ty::Generics,\n+                                   type_param_defs: &Vec<ty::TypeParameterDef>,\n+                                   region_param_defs: &Vec<ty::RegionParameterDef>,\n                                    substs: &subst::Substs,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n \n-        for (i, p) in generics.type_param_defs().iter().enumerate() {\n+        for p in type_param_defs.iter() {\n             let variance_decl =\n-                self.declared_variance(p.def_id, def_id, TypeParam, i);\n+                self.declared_variance(p.def_id, def_id, TypeParam,\n+                                       p.space, p.index);\n             let variance_i = self.xform(variance, variance_decl);\n-            self.add_constraints_from_ty(*substs.tps.get(i), variance_i);\n+            let substs_ty = *substs.types.get(p.space, p.index);\n+            self.add_constraints_from_ty(substs_ty, variance_i);\n         }\n \n-        match substs.regions {\n-            subst::ErasedRegions => {}\n-            subst::NonerasedRegions(ref rps) => {\n-                for (i, p) in generics.region_param_defs().iter().enumerate() {\n-                    let variance_decl =\n-                        self.declared_variance(p.def_id, def_id, RegionParam, i);\n-                    let variance_i = self.xform(variance, variance_decl);\n-                    self.add_constraints_from_region(*rps.get(i), variance_i);\n-                }\n-            }\n+        for p in region_param_defs.iter() {\n+            let variance_decl =\n+                self.declared_variance(p.def_id, def_id,\n+                                       RegionParam, p.space, p.index);\n+            let variance_i = self.xform(variance, variance_decl);\n+            let substs_r = *substs.regions().get(p.space, p.index);\n+            self.add_constraints_from_region(substs_r, variance_i);\n         }\n     }\n \n@@ -839,7 +875,7 @@ impl<'a> ConstraintContext<'a> {\n                                    region: ty::Region,\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n-            ty::ReEarlyBound(param_id, _, _) => {\n+            ty::ReEarlyBound(param_id, _, _, _) => {\n                 if self.is_to_be_inferred(param_id) {\n                     let index = self.inferred_index(param_id);\n                     self.add_constraint(index, variance);\n@@ -931,7 +967,7 @@ impl<'a> SolveContext<'a> {\n                 let new_value = glb(variance, old_value);\n                 if old_value != new_value {\n                     debug!(\"Updating inferred {} (node {}) \\\n-                            from {:?} to {:?} due to {}\",\n+                            from {} to {} due to {}\",\n                             inferred,\n                             self.terms_cx\n                                 .inferred_infos\n@@ -965,32 +1001,29 @@ impl<'a> SolveContext<'a> {\n         let num_inferred = self.terms_cx.num_inferred();\n         while index < num_inferred {\n             let item_id = inferred_infos.get(index).item_id;\n-            let mut self_param = None;\n-            let mut type_params = vec!();\n-            let mut region_params = vec!();\n+            let mut types = VecPerParamSpace::empty();\n+            let mut regions = VecPerParamSpace::empty();\n \n             while index < num_inferred &&\n                   inferred_infos.get(index).item_id == item_id {\n                 let info = inferred_infos.get(index);\n+                let variance = *solutions.get(index);\n+                debug!(\"Index {} Info {} / {} / {} Variance {}\",\n+                       index, info.index, info.kind, info.space, variance);\n                 match info.kind {\n-                    SelfParam => {\n-                        assert!(self_param.is_none());\n-                        self_param = Some(*solutions.get(index));\n-                    }\n                     TypeParam => {\n-                        type_params.push(*solutions.get(index));\n+                        types.push(info.space, variance);\n                     }\n                     RegionParam => {\n-                        region_params.push(*solutions.get(index));\n+                        regions.push(info.space, variance);\n                     }\n                 }\n                 index += 1;\n             }\n \n             let item_variances = ty::ItemVariances {\n-                self_param: self_param,\n-                type_params: OwnedSlice::from_vec(type_params),\n-                region_params: OwnedSlice::from_vec(region_params)\n+                types: types,\n+                regions: regions\n             };\n             debug!(\"item_id={} item_variances={}\",\n                     item_id,"}, {"sha": "31994d08d23478011763ab411f5d5786873486bd", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 87, "deletions": 81, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -9,17 +9,18 @@\n // except according to those terms.\n \n \n+use middle::def;\n use middle::subst;\n-use middle::subst::Subst;\n+use middle::subst::{VecPerParamSpace,Subst};\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{BrFresh, ctxt};\n-use middle::ty::{mt, t, param_ty};\n+use middle::ty::{mt, t, ParamTy};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region,\n                  ReEmpty};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_self, ty_tup};\n+use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n use middle::typeck;\n@@ -188,7 +189,7 @@ pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> St\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n         ty::ReScope(_) => prefix.to_string(),\n-        ty::ReEarlyBound(_, _, name) => {\n+        ty::ReEarlyBound(_, _, _, name) => {\n             token::get_name(name).get().to_string()\n         }\n         ty::ReLateBound(_, br) => bound_region_to_str(cx, prefix, space, br),\n@@ -375,7 +376,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => \"[type error]\".to_string(),\n-      ty_param(param_ty {idx: id, def_id: did}) => {\n+      ty_param(ParamTy {idx: id, def_id: did, ..}) => {\n           let ident = match cx.ty_param_defs.borrow().find(&did.node) {\n               Some(def) => token::get_ident(def.ident).get().to_string(),\n               // This can only happen when a type mismatch error happens and\n@@ -391,29 +392,25 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n               format!(\"{}:{:?}\", ident, did)\n           }\n       }\n-      ty_self(..) => \"Self\".to_string(),\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n-        let base = ty::item_path_str(cx, did);\n-        parameterized(cx,\n-                      base.as_slice(),\n-                      &substs.regions,\n-                      substs.tps.as_slice(),\n-                      did,\n-                      false)\n+          let base = ty::item_path_str(cx, did);\n+          let generics = ty::lookup_item_type(cx, did).generics;\n+          parameterized(cx, base.as_slice(), substs, &generics)\n       }\n       ty_trait(box ty::TyTrait {\n           def_id: did, ref substs, store, ref bounds\n       }) => {\n-        let base = ty::item_path_str(cx, did);\n-        let ty = parameterized(cx, base.as_slice(), &substs.regions,\n-                               substs.tps.as_slice(), did, true);\n-        let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n-        let bound_str = bounds.repr(cx);\n-        format!(\"{}{}{}{}\",\n-                trait_store_to_str(cx, store),\n-                ty,\n-                bound_sep,\n-                bound_str)\n+          let base = ty::item_path_str(cx, did);\n+          let trait_def = ty::lookup_trait_def(cx, did);\n+          let ty = parameterized(cx, base.as_slice(),\n+                                 substs, &trait_def.generics);\n+          let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n+          let bound_str = bounds.repr(cx);\n+          format!(\"{}{}{}{}\",\n+                  trait_store_to_str(cx, store),\n+                  ty,\n+                  bound_sep,\n+                  bound_str)\n       }\n       ty_str => \"str\".to_string(),\n       ty_vec(ref mt, sz) => {\n@@ -429,39 +426,38 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n \n pub fn parameterized(cx: &ctxt,\n                      base: &str,\n-                     regions: &subst::RegionSubsts,\n-                     tps: &[ty::t],\n-                     did: ast::DefId,\n-                     is_trait: bool)\n-                     -> String {\n+                     substs: &subst::Substs,\n+                     generics: &ty::Generics)\n+                     -> String\n+{\n     let mut strs = Vec::new();\n-    match *regions {\n+\n+    match substs.regions {\n         subst::ErasedRegions => { }\n         subst::NonerasedRegions(ref regions) => {\n             for &r in regions.iter() {\n-                strs.push(region_to_str(cx, \"\", false, r))\n+                let s = region_to_str(cx, \"\", false, r);\n+                if !s.is_empty() {\n+                    strs.push(s)\n+                } else {\n+                    // This happens when the value of the region\n+                    // parameter is not easily serialized. This may be\n+                    // because the user omitted it in the first place,\n+                    // or because it refers to some block in the code,\n+                    // etc. I'm not sure how best to serialize this.\n+                    strs.push(format!(\"'_\"));\n+                }\n             }\n         }\n     }\n \n-    let generics = if is_trait {\n-        ty::lookup_trait_def(cx, did).generics.clone()\n-    } else {\n-        ty::lookup_item_type(cx, did).generics\n-    };\n-    let ty_params = generics.type_param_defs();\n+    let tps = substs.types.get_vec(subst::TypeSpace);\n+    let ty_params = generics.types.get_vec(subst::TypeSpace);\n     let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n-    let num_defaults = if has_defaults {\n-        // We should have a borrowed version of substs instead of cloning.\n-        let mut substs = subst::Substs {\n-            tps: Vec::from_slice(tps),\n-            regions: regions.clone(),\n-            self_ty: None\n-        };\n+    let num_defaults = if has_defaults && !cx.sess.verbose() {\n         ty_params.iter().zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n-            substs.tps.pop();\n             match def.default {\n-                Some(default) => default.subst(cx, &substs) == actual,\n+                Some(default) => default.subst(cx, substs) == actual,\n                 None => false\n             }\n         }).count()\n@@ -473,6 +469,12 @@ pub fn parameterized(cx: &ctxt,\n         strs.push(ty_to_str(cx, *t))\n     }\n \n+    if cx.sess.verbose() {\n+        for t in substs.types.get_vec(subst::SelfSpace).iter() {\n+            strs.push(format!(\"for {}\", t.repr(cx)));\n+        }\n+    }\n+\n     if strs.len() > 0u {\n         format!(\"{}<{}>\", base, strs.connect(\",\"))\n     } else {\n@@ -554,6 +556,12 @@ impl<T:Repr> Repr for Vec<T> {\n     }\n }\n \n+impl Repr for def::Def {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+}\n+\n impl Repr for ty::TypeParameterDef {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"TypeParameterDef({:?}, {})\", self.def_id,\n@@ -577,10 +585,18 @@ impl Repr for ty::t {\n \n impl Repr for subst::Substs {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"substs(regions={}, self_ty={}, tps={})\",\n-                self.regions.repr(tcx),\n-                self.self_ty.repr(tcx),\n-                self.tps.repr(tcx))\n+        format!(\"Substs[types={}, regions={}]\",\n+                       self.types.repr(tcx),\n+                       self.regions.repr(tcx))\n+    }\n+}\n+\n+impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"[{};{};{}]\",\n+                       self.get_vec(subst::TypeSpace).repr(tcx),\n+                       self.get_vec(subst::SelfSpace).repr(tcx),\n+                       self.get_vec(subst::FnSpace).repr(tcx))\n     }\n }\n \n@@ -630,6 +646,12 @@ impl Repr for ast::Expr {\n     }\n }\n \n+impl Repr for ast::Path {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"path({})\", pprust::path_to_str(self))\n+    }\n+}\n+\n impl Repr for ast::Item {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"item({})\", tcx.map.node_to_str(self.id))\n@@ -665,11 +687,12 @@ impl Repr for ty::BoundRegion {\n impl Repr for ty::Region {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n-            ty::ReEarlyBound(id, index, name) => {\n-                format!(\"ReEarlyBound({}, {}, {})\",\n-                        id,\n-                        index,\n-                        token::get_name(name))\n+            ty::ReEarlyBound(id, space, index, name) => {\n+                format!(\"ReEarlyBound({}, {}, {}, {})\",\n+                               id,\n+                               space,\n+                               index,\n+                               token::get_name(name))\n             }\n \n             ty::ReLateBound(binder_id, ref bound_region) => {\n@@ -697,9 +720,7 @@ impl Repr for ty::Region {\n             }\n \n             ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n-                format!(\"re_skolemized({}, {})\",\n-                               id,\n-                               bound_region.repr(tcx))\n+                format!(\"re_skolemized({}, {})\", id, bound_region.repr(tcx))\n             }\n \n             ty::ReEmpty => {\n@@ -753,18 +774,18 @@ impl Repr for ty::ty_param_bounds_and_ty {\n \n impl Repr for ty::Generics {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"Generics(type_param_defs: {}, region_param_defs: {})\",\n-                self.type_param_defs().repr(tcx),\n-                self.region_param_defs().repr(tcx))\n+        format!(\"Generics(types: {}, regions: {})\",\n+                self.types.repr(tcx),\n+                self.regions.repr(tcx))\n     }\n }\n \n impl Repr for ty::ItemVariances {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"IterVariances(self_param={}, type_params={}, region_params={})\",\n-                self.self_param.repr(tcx),\n-                self.type_params.repr(tcx),\n-                self.region_params.repr(tcx))\n+        format!(\"ItemVariances(types={}, \\\n+                regions={})\",\n+                self.types.repr(tcx),\n+                self.regions.repr(tcx))\n     }\n }\n \n@@ -952,23 +973,8 @@ impl UserString for ty::BuiltinBounds {\n impl UserString for ty::TraitRef {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         let base = ty::item_path_str(tcx, self.def_id);\n-        if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n-            let mut all_tps = self.substs.tps.clone();\n-            for &t in self.substs.self_ty.iter() { all_tps.push(t); }\n-            parameterized(tcx,\n-                          base.as_slice(),\n-                          &self.substs.regions,\n-                          all_tps.as_slice(),\n-                          self.def_id,\n-                          true)\n-        } else {\n-            parameterized(tcx,\n-                          base.as_slice(),\n-                          &self.substs.regions,\n-                          self.substs.tps.as_slice(),\n-                          self.def_id,\n-                          true)\n-        }\n+        let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n+        parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics)\n     }\n }\n "}, {"sha": "dd6cc978ae71c93cf800c9b796991c5407b5d3ac", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 53, "deletions": 21, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -27,6 +27,7 @@ use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::def;\n use rustc::middle::subst;\n+use rustc::middle::subst::VecPerParamSpace;\n use rustc::middle::ty;\n \n use std::rc::Rc;\n@@ -53,6 +54,12 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for Vec<T> {\n     }\n }\n \n+impl<T: Clean<U>, U> Clean<VecPerParamSpace<U>> for VecPerParamSpace<T> {\n+    fn clean(&self) -> VecPerParamSpace<U> {\n+        self.map(|x| x.clean())\n+    }\n+}\n+\n impl<T: Clean<U>, U> Clean<U> for Gc<T> {\n     fn clean(&self) -> U {\n         (**self).clean()\n@@ -488,17 +495,17 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n }\n \n fn external_path(name: &str, substs: &subst::Substs) -> Path {\n+    let lifetimes = substs.regions().get_vec(subst::TypeSpace)\n+                    .iter()\n+                    .filter_map(|v| v.clean())\n+                    .collect();\n+    let types = substs.types.get_vec(subst::TypeSpace).clean();\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n-            lifetimes: match substs.regions {\n-                subst::ErasedRegions => Vec::new(),\n-                subst::NonerasedRegions(ref v) => {\n-                    v.iter().filter_map(|v| v.clean()).collect()\n-                }\n-            },\n-            types: substs.tps.clean(),\n+            lifetimes: lifetimes,\n+            types: types,\n         }],\n     }\n }\n@@ -578,12 +585,8 @@ impl Clean<Vec<TyParamBound>> for ty::ParamBounds {\n impl Clean<Option<Vec<TyParamBound>>> for subst::Substs {\n     fn clean(&self) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n-        match self.regions {\n-            subst::NonerasedRegions(..) => v.push(RegionBound),\n-            subst::ErasedRegions => {}\n-        }\n-        v.extend(self.tps.iter().map(|t| TraitBound(t.clean())));\n-\n+        v.extend(self.regions().iter().map(|_| RegionBound));\n+        v.extend(self.types.iter().map(|t| TraitBound(t.clean())));\n         if v.len() > 0 {Some(v)} else {None}\n     }\n }\n@@ -617,7 +620,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n             ty::ReStatic => Some(Lifetime(\"static\".to_string())),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n                 Some(Lifetime(token::get_name(name).get().to_string())),\n-            ty::ReEarlyBound(_, _, name) => Some(Lifetime(name.clean())),\n+            ty::ReEarlyBound(_, _, _, name) => Some(Lifetime(name.clean())),\n \n             ty::ReLateBound(..) |\n             ty::ReFree(..) |\n@@ -638,17 +641,41 @@ pub struct Generics {\n impl Clean<Generics> for ast::Generics {\n     fn clean(&self) -> Generics {\n         Generics {\n-            lifetimes: self.lifetimes.clean().move_iter().collect(),\n-            type_params: self.ty_params.clean().move_iter().collect(),\n+            lifetimes: self.lifetimes.clean(),\n+            type_params: self.ty_params.clean(),\n         }\n     }\n }\n \n impl Clean<Generics> for ty::Generics {\n     fn clean(&self) -> Generics {\n+        // In the type space, generics can come in one of multiple\n+        // namespaces.  This means that e.g. for fn items the type\n+        // parameters will live in FnSpace, but for types the\n+        // parameters will live in TypeSpace (trait definitions also\n+        // define a parameter in SelfSpace). *Method* definitions are\n+        // the one exception: they combine the TypeSpace parameters\n+        // from the enclosing impl/trait with their own FnSpace\n+        // parameters.\n+        //\n+        // In general, when we clean, we are trying to produce the\n+        // \"user-facing\" generics. Hence we select the most specific\n+        // namespace that is occupied, ignoring SelfSpace because it\n+        // is implicit.\n+\n+        let space = {\n+            if !self.types.get_vec(subst::FnSpace).is_empty() ||\n+                !self.regions.get_vec(subst::FnSpace).is_empty()\n+            {\n+                subst::FnSpace\n+            } else {\n+                subst::TypeSpace\n+            }\n+        };\n+\n         Generics {\n-            lifetimes: self.region_param_defs.clean(),\n-            type_params: self.type_param_defs.clean(),\n+            type_params: self.types.get_vec(space).clean(),\n+            lifetimes: self.regions.get_vec(space).clean(),\n         }\n     }\n }\n@@ -1259,8 +1286,13 @@ impl Clean<Type> for ty::t {\n             }\n             ty::ty_tup(ref t) => Tuple(t.iter().map(|t| t.clean()).collect()),\n \n-            ty::ty_param(ref p) => Generic(p.def_id),\n-            ty::ty_self(did) => Self(did),\n+            ty::ty_param(ref p) => {\n+                if p.space == subst::SelfSpace {\n+                    Self(p.def_id)\n+                } else {\n+                    Generic(p.def_id)\n+                }\n+            }\n \n             ty::ty_infer(..) => fail!(\"ty_infer\"),\n             ty::ty_err => fail!(\"ty_err\"),\n@@ -1968,7 +2000,7 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n             ast::TyFloat(ast::TyF64) => return Primitive(F64),\n             ast::TyFloat(ast::TyF128) => return Primitive(F128),\n         },\n-        def::DefTyParam(i, _) => return Generic(i),\n+        def::DefTyParam(_, i, _) => return Generic(i),\n         def::DefTyParamBinder(i) => return TyParamBinder(i),\n         _ => {}\n     };"}, {"sha": "941078b158b87718cc0e9a94e9b16d4d42884b2c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -208,14 +208,6 @@ impl Generics {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n-pub enum DefRegion {\n-    DefStaticRegion,\n-    DefEarlyBoundRegion(/* index */ uint, /* lifetime decl */ NodeId),\n-    DefLateBoundRegion(/* binder_id */ NodeId, /* depth */ uint, /* lifetime decl */ NodeId),\n-    DefFreeRegion(/* block scope */ NodeId, /* lifetime decl */ NodeId),\n-}\n-\n // The set of MetaItems that define the compilation environment of the crate,\n // used to drive conditional compilation\n pub type CrateConfig = Vec<Gc<MetaItem>>;"}, {"sha": "7ce6f7188b84f5484d25331b86cb586260e29d26", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -45,11 +45,16 @@ impl Trait<int> for S2 {\n \n fn foo<'a>() {\n     let _ = S::new::<int,f64>(1, 1.0);\n-    //~^ ERROR the impl referenced by this path needs 1 type parameter, but 0 type parameters were supplied\n-    let _ = S::<'a,int>::new::<f64>(1, 1.0); //~ ERROR expected 0 lifetime parameters\n+    //~^ ERROR too many type parameters provided\n+\n+    let _ = S::<'a,int>::new::<f64>(1, 1.0);\n+    //~^ ERROR too many lifetime parameters provided\n+\n     let _: S2 = Trait::new::<int,f64>(1, 1.0);\n-    //~^ ERROR the trait referenced by this path needs 1 type parameter, but 0 type parameters were supplied\n-    let _: S2 = Trait::<'a,int>::new::<f64>(1, 1.0); //~ ERROR expected 0 lifetime parameters\n+    //~^ ERROR too many type parameters provided\n+\n+    let _: S2 = Trait::<'a,int>::new::<f64>(1, 1.0);\n+    //~^ ERROR too many lifetime parameters provided\n }\n \n fn main() {}"}, {"sha": "7e7eee3cfaca86d58ab0ae49c52afd7fb4ae7016", "filename": "src/test/compile-fail/generic-impl-less-params-with-defaults.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -18,7 +18,5 @@ impl<A, B, C = (A, B)> Foo<A, B, C> {\n \n fn main() {\n     Foo::<int>::new();\n-    //~^ ERROR the impl referenced by this path needs at least 2 type parameters,\n-    //         but 1 was supplied\n-    //~^^^ ERROR not enough type parameters provided: expected at least 2, found 1\n+    //~^ ERROR too few type parameters provided\n }"}, {"sha": "ceaed9438be53c09bc2ac15145b8045b7b641086", "filename": "src/test/compile-fail/generic-impl-more-params-with-defaults.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -20,7 +20,5 @@ impl<T, A = Heap> Vec<T, A> {\n \n fn main() {\n     Vec::<int, Heap, bool>::new();\n-    //~^ ERROR the impl referenced by this path needs at most 2 type parameters,\n-    //         but 3 were supplied\n-    //~^^^ ERROR too many type parameters provided: expected at most 2, found 3\n+    //~^ ERROR too many type parameters provided\n }"}, {"sha": "e5400bf60c361c227b70986c24c9e09b9a2ea5c0", "filename": "src/test/compile-fail/issue-11844.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fissue-11844.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fissue-11844.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11844.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let a = Some(box 1);\n     match a {\n         Ok(a) => //~ ERROR: mismatched types\n-            println!(\"{}\",a), //~ ERROR: failed to find an implementation of trait\n+            println!(\"{}\",a),\n         None => fail!()\n     }\n }"}, {"sha": "14cc0a82df5b24105f8e2db6f8ea12e66362f88f", "filename": "src/test/compile-fail/issue-13466.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -15,7 +15,6 @@ pub fn main() {\n     // the actual arm `Result<T, E>` has two. typeck should not be\n     // tricked into looking up a non-existing second type parameter.\n     let _x: uint = match Some(1u) {\n-    //~^ ERROR mismatched types: expected `uint` but found `<generic #0>`\n         Ok(u) => u, //~ ERROR  mismatched types: expected `core::option::Option<uint>`\n         Err(e) => fail!(e)  //~ ERROR mismatched types: expected `core::option::Option<uint>`\n     };"}, {"sha": "4b1c67918745ac29cf4a0ecfc6bc82571b21dc23", "filename": "src/test/compile-fail/issue-7092.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fissue-7092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fissue-7092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7092.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -15,7 +15,6 @@ fn foo(x: Whatever) {\n     match x {\n         Some(field) => field.access(),\n         //~^ ERROR: mismatched types: expected `Whatever` but found\n-        //~^^ ERROR: does not implement any method in scope named `access`\n     }\n }\n "}, {"sha": "da4f9846187ca2784a77d9a10c4c332e8d066e76", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -14,7 +14,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR region_params=[-, -, -]\n+struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[]]\n     x: &'a int,\n     y: &'b [int],\n     c: &'c str\n@@ -23,7 +23,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR region_params=[-, -, -]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR region_params=[+, +, +]\n+struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n     x: extern \"Rust\" fn(&'a int),\n     y: extern \"Rust\" fn(&'b [int]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -32,15 +32,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR region_params=[+, +, +]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b> { //~ ERROR region_params=[-, o]\n+struct Test4<'a, 'b> { //~ ERROR regions=[[-, o];[];[]]\n     x: &'a mut &'b int,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b> { //~ ERROR region_params=[+, o]\n+struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[]]\n     x: extern \"Rust\" fn(&'a mut &'b int),\n }\n \n@@ -50,21 +50,21 @@ struct Test5<'a, 'b> { //~ ERROR region_params=[+, o]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b> { //~ ERROR region_params=[-, o]\n+struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[]]\n     x: &'a mut extern \"Rust\" fn(&'b int),\n }\n \n // No uses at all is bivariant:\n \n #[rustc_variance]\n-struct Test7<'a> { //~ ERROR region_params=[*]\n+struct Test7<'a> { //~ ERROR regions=[[*];[];[]]\n     x: int\n }\n \n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c> { //~ ERROR region_params=[+, -, o]\n+enum Test8<'a, 'b, 'c> { //~ ERROR regions=[[+, -, o];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),"}, {"sha": "913335fa51b1a720596ea194dd905aa84fffd407", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9153d8ad6c8259b3b23187f36dc3d3257a28d91c/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=9153d8ad6c8259b3b23187f36dc3d3257a28d91c", "patch": "@@ -13,29 +13,29 @@\n // Try enums too.\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c, 'd> { //~ ERROR region_params=[+, -, o, *]\n+enum Base<'a, 'b, 'c, 'd> { //~ ERROR regions=[[+, -, o, *];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x, 'y, 'z> { //~ ERROR region_params=[*, o, -, +]\n+struct Derived1<'w, 'x, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[]]\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b, 'c> { //~ ERROR region_params=[o, o, *]\n+struct Derived2<'a, 'b, 'c> { //~ ERROR regions=[[o, o, *];[];[]]\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a, 'b, 'c> { //~ ERROR region_params=[o, -, *]\n+struct Derived3<'a, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[]]\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c> { //~ ERROR region_params=[+, -, o]\n+struct Derived4<'a, 'b, 'c> { //~ ERROR regions=[[+, -, o];[];[]]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}]}