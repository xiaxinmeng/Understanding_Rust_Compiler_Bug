{"sha": "31e21613eefcf30e6b7a10954bbbfc873d30ad88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZTIxNjEzZWVmY2YzMGU2YjdhMTA5NTRiYmJmYzg3M2QzMGFkODg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T16:34:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T19:50:28Z"}, "message": "rollup merge of #19885: alexcrichton/char-escape\n\nThis changes the `escape_unicode` method on a `char` to use the new style of\nunicode escapes in the language.\n\nCloses #19811\nCloses #19879", "tree": {"sha": "278a0c4470b74bbe96d5827ac08a629a3fde3bdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/278a0c4470b74bbe96d5827ac08a629a3fde3bdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31e21613eefcf30e6b7a10954bbbfc873d30ad88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31e21613eefcf30e6b7a10954bbbfc873d30ad88", "html_url": "https://github.com/rust-lang/rust/commit/31e21613eefcf30e6b7a10954bbbfc873d30ad88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31e21613eefcf30e6b7a10954bbbfc873d30ad88/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3315a3bf4273601f10ac9ec3759370e599703223", "url": "https://api.github.com/repos/rust-lang/rust/commits/3315a3bf4273601f10ac9ec3759370e599703223", "html_url": "https://github.com/rust-lang/rust/commit/3315a3bf4273601f10ac9ec3759370e599703223"}, {"sha": "df5404cfa837907405427e3aa4adf1d969e208c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/df5404cfa837907405427e3aa4adf1d969e208c9", "html_url": "https://github.com/rust-lang/rust/commit/df5404cfa837907405427e3aa4adf1d969e208c9"}], "stats": {"total": 222, "additions": 111, "deletions": 111}, "files": [{"sha": "19ca1c9fd2bcea1ecb5f1085de743384d1ee2e93", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/31e21613eefcf30e6b7a10954bbbfc873d30ad88/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e21613eefcf30e6b7a10954bbbfc873d30ad88/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=31e21613eefcf30e6b7a10954bbbfc873d30ad88", "patch": "@@ -1597,17 +1597,24 @@ mod tests {\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert_eq!(\"abc\".escape_unicode(), String::from_str(\"\\\\x61\\\\x62\\\\x63\"));\n-        assert_eq!(\"a c\".escape_unicode(), String::from_str(\"\\\\x61\\\\x20\\\\x63\"));\n-        assert_eq!(\"\\r\\n\\t\".escape_unicode(), String::from_str(\"\\\\x0d\\\\x0a\\\\x09\"));\n-        assert_eq!(\"'\\\"\\\\\".escape_unicode(), String::from_str(\"\\\\x27\\\\x22\\\\x5c\"));\n+        assert_eq!(\"abc\".escape_unicode(),\n+                   String::from_str(\"\\\\u{61}\\\\u{62}\\\\u{63}\"));\n+        assert_eq!(\"a c\".escape_unicode(),\n+                   String::from_str(\"\\\\u{61}\\\\u{20}\\\\u{63}\"));\n+        assert_eq!(\"\\r\\n\\t\".escape_unicode(),\n+                   String::from_str(\"\\\\u{d}\\\\u{a}\\\\u{9}\"));\n+        assert_eq!(\"'\\\"\\\\\".escape_unicode(),\n+                   String::from_str(\"\\\\u{27}\\\\u{22}\\\\u{5c}\"));\n         assert_eq!(\"\\x00\\x01\\u{fe}\\u{ff}\".escape_unicode(),\n-                   String::from_str(\"\\\\x00\\\\x01\\\\u00fe\\\\u00ff\"));\n-        assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode(), String::from_str(\"\\\\u0100\\\\uffff\"));\n+                   String::from_str(\"\\\\u{0}\\\\u{1}\\\\u{fe}\\\\u{ff}\"));\n+        assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode(),\n+                   String::from_str(\"\\\\u{100}\\\\u{ffff}\"));\n         assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_unicode(),\n-                   String::from_str(\"\\\\U00010000\\\\U0010ffff\"));\n-        assert_eq!(\"ab\\u{fb00}\".escape_unicode(), String::from_str(\"\\\\x61\\\\x62\\\\ufb00\"));\n-        assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode(), String::from_str(\"\\\\U0001d4ea\\\\x0d\"));\n+                   String::from_str(\"\\\\u{10000}\\\\u{10ffff}\"));\n+        assert_eq!(\"ab\\u{fb00}\".escape_unicode(),\n+                   String::from_str(\"\\\\u{61}\\\\u{62}\\\\u{fb00}\"));\n+        assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode(),\n+                   String::from_str(\"\\\\u{1d4ea}\\\\u{d}\"));\n     }\n \n     #[test]\n@@ -1616,11 +1623,14 @@ mod tests {\n         assert_eq!(\"a c\".escape_default(), String::from_str(\"a c\"));\n         assert_eq!(\"\\r\\n\\t\".escape_default(), String::from_str(\"\\\\r\\\\n\\\\t\"));\n         assert_eq!(\"'\\\"\\\\\".escape_default(), String::from_str(\"\\\\'\\\\\\\"\\\\\\\\\"));\n-        assert_eq!(\"\\u{100}\\u{ffff}\".escape_default(), String::from_str(\"\\\\u0100\\\\uffff\"));\n+        assert_eq!(\"\\u{100}\\u{ffff}\".escape_default(),\n+                   String::from_str(\"\\\\u{100}\\\\u{ffff}\"));\n         assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default(),\n-                   String::from_str(\"\\\\U00010000\\\\U0010ffff\"));\n-        assert_eq!(\"ab\\u{fb00}\".escape_default(), String::from_str(\"ab\\\\ufb00\"));\n-        assert_eq!(\"\\u{1d4ea}\\r\".escape_default(), String::from_str(\"\\\\U0001d4ea\\\\r\"));\n+                   String::from_str(\"\\\\u{10000}\\\\u{10ffff}\"));\n+        assert_eq!(\"ab\\u{fb00}\".escape_default(),\n+                   String::from_str(\"ab\\\\u{fb00}\"));\n+        assert_eq!(\"\\u{1d4ea}\\r\".escape_default(),\n+                   String::from_str(\"\\\\u{1d4ea}\\\\r\"));\n     }\n \n     #[test]"}, {"sha": "9c12b3f68d3de71603f732bdb14a3448d88c554c", "filename": "src/libcore/char.rs", "status": "modified", "additions": 68, "deletions": 75, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/31e21613eefcf30e6b7a10954bbbfc873d30ad88/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e21613eefcf30e6b7a10954bbbfc873d30ad88/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=31e21613eefcf30e6b7a10954bbbfc873d30ad88", "patch": "@@ -15,11 +15,11 @@\n #![allow(non_snake_case)]\n #![doc(primitive = \"char\")]\n \n+use iter::Iterator;\n use mem::transmute;\n use ops::FnMut;\n-use option::Option;\n use option::Option::{None, Some};\n-use iter::{range_step, Iterator, RangeStep};\n+use option::Option;\n use slice::SliceExt;\n \n // UTF-8 ranges and tags for encoding characters\n@@ -156,34 +156,15 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     }\n }\n \n-///\n-/// Returns the hexadecimal Unicode escape of a `char`\n-///\n-/// The rules are as follows:\n-///\n-/// - chars in [0,0xff] get 2-digit escapes: `\\\\xNN`\n-/// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\u{NNNN}`\n-/// - chars above 0x10000 get 8-digit escapes: `\\\\u{{NNN}NNNNN}`\n-///\n+/// Deprecated, call the escape_unicode method instead.\n #[deprecated = \"use the Char::escape_unicode method\"]\n pub fn escape_unicode<F>(c: char, mut f: F) where F: FnMut(char) {\n     for char in c.escape_unicode() {\n         f(char);\n     }\n }\n \n-///\n-/// Returns a 'default' ASCII and C++11-like literal escape of a `char`\n-///\n-/// The default is chosen with a bias toward producing literals that are\n-/// legal in a variety of languages, including C++11 and similar C-family\n-/// languages. The exact rules are:\n-///\n-/// - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n-/// - Single-quote, double-quote and backslash chars are backslash-escaped.\n-/// - Any other chars in the range [0x20,0x7e] are not escaped.\n-/// - Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-///\n+/// Deprecated, call the escape_default method instead.\n #[deprecated = \"use the Char::escape_default method\"]\n pub fn escape_default<F>(c: char, mut f: F) where F: FnMut(char) {\n     for c in c.escape_default() {\n@@ -267,13 +248,11 @@ pub trait Char {\n     /// Returns an iterator that yields the hexadecimal Unicode escape\n     /// of a character, as `char`s.\n     ///\n-    /// The rules are as follows:\n-    ///\n-    /// * Characters in [0,0xff] get 2-digit escapes: `\\\\xNN`\n-    /// * Characters in [0x100,0xffff] get 4-digit escapes: `\\\\u{NNNN}`.\n-    /// * Characters above 0x10000 get 8-digit escapes: `\\\\u{{NNN}NNNNN}`.\n+    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n+    /// where `NNNN` is the shortest hexadecimal representation of the code\n+    /// point.\n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_unicode(self) -> UnicodeEscapedChars;\n+    fn escape_unicode(self) -> EscapeUnicode;\n \n     /// Returns an iterator that yields the 'default' ASCII and\n     /// C++11-like literal escape of a character, as `char`s.\n@@ -288,7 +267,7 @@ pub trait Char {\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_default(self) -> DefaultEscapedChars;\n+    fn escape_default(self) -> EscapeDefault;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n@@ -358,23 +337,23 @@ impl Char for char {\n     fn from_u32(i: u32) -> Option<char> { from_u32(i) }\n \n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_unicode(self) -> UnicodeEscapedChars {\n-        UnicodeEscapedChars { c: self, state: UnicodeEscapedCharsState::Backslash }\n+    fn escape_unicode(self) -> EscapeUnicode {\n+        EscapeUnicode { c: self, state: EscapeUnicodeState::Backslash }\n     }\n \n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_default(self) -> DefaultEscapedChars {\n+    fn escape_default(self) -> EscapeDefault {\n         let init_state = match self {\n-            '\\t' => DefaultEscapedCharsState::Backslash('t'),\n-            '\\r' => DefaultEscapedCharsState::Backslash('r'),\n-            '\\n' => DefaultEscapedCharsState::Backslash('n'),\n-            '\\\\' => DefaultEscapedCharsState::Backslash('\\\\'),\n-            '\\'' => DefaultEscapedCharsState::Backslash('\\''),\n-            '\"'  => DefaultEscapedCharsState::Backslash('\"'),\n-            '\\x20' ... '\\x7e' => DefaultEscapedCharsState::Char(self),\n-            _ => DefaultEscapedCharsState::Unicode(self.escape_unicode())\n+            '\\t' => EscapeDefaultState::Backslash('t'),\n+            '\\r' => EscapeDefaultState::Backslash('r'),\n+            '\\n' => EscapeDefaultState::Backslash('n'),\n+            '\\\\' => EscapeDefaultState::Backslash('\\\\'),\n+            '\\'' => EscapeDefaultState::Backslash('\\''),\n+            '\"'  => EscapeDefaultState::Backslash('\"'),\n+            '\\x20' ... '\\x7e' => EscapeDefaultState::Char(self),\n+            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n         };\n-        DefaultEscapedChars { state: init_state }\n+        EscapeDefault { state: init_state }\n     }\n \n     #[inline]\n@@ -451,72 +430,86 @@ impl Char for char {\n \n /// An iterator over the characters that represent a `char`, as escaped by\n /// Rust's unicode escaping rules.\n-pub struct UnicodeEscapedChars {\n+pub struct EscapeUnicode {\n     c: char,\n-    state: UnicodeEscapedCharsState\n+    state: EscapeUnicodeState\n }\n \n-enum UnicodeEscapedCharsState {\n+enum EscapeUnicodeState {\n     Backslash,\n     Type,\n-    Value(RangeStep<i32>),\n+    LeftBrace,\n+    Value(uint),\n+    RightBrace,\n+    Done,\n }\n \n-impl Iterator<char> for UnicodeEscapedChars {\n+impl Iterator<char> for EscapeUnicode {\n     fn next(&mut self) -> Option<char> {\n         match self.state {\n-            UnicodeEscapedCharsState::Backslash => {\n-                self.state = UnicodeEscapedCharsState::Type;\n+            EscapeUnicodeState::Backslash => {\n+                self.state = EscapeUnicodeState::Type;\n                 Some('\\\\')\n             }\n-            UnicodeEscapedCharsState::Type => {\n-                let (typechar, pad) = if self.c <= '\\x7f' { ('x', 2) }\n-                                      else if self.c <= '\\u{ffff}' { ('u', 4) }\n-                                      else { ('U', 8) };\n-                self.state = UnicodeEscapedCharsState::Value(range_step(4 * (pad - 1), -1, -4i32));\n-                Some(typechar)\n+            EscapeUnicodeState::Type => {\n+                self.state = EscapeUnicodeState::LeftBrace;\n+                Some('u')\n             }\n-            UnicodeEscapedCharsState::Value(ref mut range_step) => match range_step.next() {\n-                Some(offset) => {\n-                    let offset = offset as uint;\n-                    let v = match ((self.c as i32) >> offset) & 0xf {\n-                        i @ 0 ... 9 => '0' as i32 + i,\n-                        i => 'a' as i32 + (i - 10)\n-                    };\n-                    Some(unsafe { transmute(v) })\n+            EscapeUnicodeState::LeftBrace => {\n+                let mut n = 0u;\n+                while (self.c as u32) >> (4 * (n + 1)) != 0 {\n+                    n += 1;\n                 }\n-                None => None\n+                self.state = EscapeUnicodeState::Value(n);\n+                Some('{')\n+            }\n+            EscapeUnicodeState::Value(offset) => {\n+                let v = match ((self.c as i32) >> (offset * 4)) & 0xf {\n+                    i @ 0 ... 9 => '0' as i32 + i,\n+                    i => 'a' as i32 + (i - 10)\n+                };\n+                if offset == 0 {\n+                    self.state = EscapeUnicodeState::RightBrace;\n+                } else {\n+                    self.state = EscapeUnicodeState::Value(offset - 1);\n+                }\n+                Some(unsafe { transmute(v) })\n+            }\n+            EscapeUnicodeState::RightBrace => {\n+                self.state = EscapeUnicodeState::Done;\n+                Some('}')\n             }\n+            EscapeUnicodeState::Done => None,\n         }\n     }\n }\n \n /// An iterator over the characters that represent a `char`, escaped\n /// for maximum portability.\n-pub struct DefaultEscapedChars {\n-    state: DefaultEscapedCharsState\n+pub struct EscapeDefault {\n+    state: EscapeDefaultState\n }\n \n-enum DefaultEscapedCharsState {\n+enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),\n     Done,\n-    Unicode(UnicodeEscapedChars),\n+    Unicode(EscapeUnicode),\n }\n \n-impl Iterator<char> for DefaultEscapedChars {\n+impl Iterator<char> for EscapeDefault {\n     fn next(&mut self) -> Option<char> {\n         match self.state {\n-            DefaultEscapedCharsState::Backslash(c) => {\n-                self.state = DefaultEscapedCharsState::Char(c);\n+            EscapeDefaultState::Backslash(c) => {\n+                self.state = EscapeDefaultState::Char(c);\n                 Some('\\\\')\n             }\n-            DefaultEscapedCharsState::Char(c) => {\n-                self.state = DefaultEscapedCharsState::Done;\n+            EscapeDefaultState::Char(c) => {\n+                self.state = EscapeDefaultState::Done;\n                 Some(c)\n             }\n-            DefaultEscapedCharsState::Done => None,\n-            DefaultEscapedCharsState::Unicode(ref mut iter) => iter.next()\n+            EscapeDefaultState::Done => None,\n+            EscapeDefaultState::Unicode(ref mut iter) => iter.next()\n         }\n     }\n }"}, {"sha": "bed38f8c29666babdd7549f4b60fb17e7b10614f", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/31e21613eefcf30e6b7a10954bbbfc873d30ad88/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e21613eefcf30e6b7a10954bbbfc873d30ad88/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=31e21613eefcf30e6b7a10954bbbfc873d30ad88", "patch": "@@ -135,38 +135,35 @@ fn test_escape_default() {\n     let s = string('~');\n     assert_eq!(s, \"~\");\n     let s = string('\\x00');\n-    assert_eq!(s, \"\\\\x00\");\n+    assert_eq!(s, \"\\\\u{0}\");\n     let s = string('\\x1f');\n-    assert_eq!(s, \"\\\\x1f\");\n+    assert_eq!(s, \"\\\\u{1f}\");\n     let s = string('\\x7f');\n-    assert_eq!(s, \"\\\\x7f\");\n-    let s = string('\\u00ff');\n-    assert_eq!(s, \"\\\\u00ff\");\n-    let s = string('\\u011b');\n-    assert_eq!(s, \"\\\\u011b\");\n-    let s = string('\\U0001d4b6');\n-    assert_eq!(s, \"\\\\U0001d4b6\");\n+    assert_eq!(s, \"\\\\u{7f}\");\n+    let s = string('\\u{ff}');\n+    assert_eq!(s, \"\\\\u{ff}\");\n+    let s = string('\\u{11b}');\n+    assert_eq!(s, \"\\\\u{11b}\");\n+    let s = string('\\u{1d4b6}');\n+    assert_eq!(s, \"\\\\u{1d4b6}\");\n }\n \n #[test]\n fn test_escape_unicode() {\n-    fn string(c: char) -> String {\n-        let mut result = String::new();\n-        escape_unicode(c, |c| { result.push(c); });\n-        return result;\n-    }\n+    fn string(c: char) -> String { c.escape_unicode().collect() }\n+\n     let s = string('\\x00');\n-    assert_eq!(s, \"\\\\x00\");\n+    assert_eq!(s, \"\\\\u{0}\");\n     let s = string('\\n');\n-    assert_eq!(s, \"\\\\x0a\");\n+    assert_eq!(s, \"\\\\u{a}\");\n     let s = string(' ');\n-    assert_eq!(s, \"\\\\x20\");\n+    assert_eq!(s, \"\\\\u{20}\");\n     let s = string('a');\n-    assert_eq!(s, \"\\\\x61\");\n-    let s = string('\\u011b');\n-    assert_eq!(s, \"\\\\u011b\");\n-    let s = string('\\U0001d4b6');\n-    assert_eq!(s, \"\\\\U0001d4b6\");\n+    assert_eq!(s, \"\\\\u{61}\");\n+    let s = string('\\u{11b}');\n+    assert_eq!(s, \"\\\\u{11b}\");\n+    let s = string('\\u{1d4b6}');\n+    assert_eq!(s, \"\\\\u{1d4b6}\");\n }\n \n #[test]"}, {"sha": "fc7664c480fdbf7969a1ab89e63f6f3b2f435d9c", "filename": "src/test/compile-fail-fulldeps/macro-crate-cannot-read-embedded-ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31e21613eefcf30e6b7a10954bbbfc873d30ad88/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e21613eefcf30e6b7a10954bbbfc873d30ad88/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs?ref=31e21613eefcf30e6b7a10954bbbfc873d30ad88", "patch": "@@ -11,7 +11,7 @@\n // aux-build:macro_crate_test.rs\n // ignore-stage1\n // ignore-android\n-// error-pattern: unknown start of token: \\x00\n+// error-pattern: unknown start of token: \\u{0}\n \n // Issue #15750 and #15962 : this test is checking that the standard\n // parser rejects embedded idents.  pnkfelix did not want to attempt"}]}