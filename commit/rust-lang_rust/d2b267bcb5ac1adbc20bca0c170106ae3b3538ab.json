{"sha": "d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyYjI2N2JjYjVhYzFhZGJjMjBiY2EwYzE3MDEwNmFlM2IzNTM4YWI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-27T19:20:44Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-27T21:29:10Z"}, "message": "add a TotalEq trait", "tree": {"sha": "1e121e3e6efee7d72ef425bf3211126136667982", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e121e3e6efee7d72ef425bf3211126136667982"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "html_url": "https://github.com/rust-lang/rust/commit/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91cb6687a8869fa14aef8d978fb13e330c711cd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/91cb6687a8869fa14aef8d978fb13e330c711cd3", "html_url": "https://github.com/rust-lang/rust/commit/91cb6687a8869fa14aef8d978fb13e330c711cd3"}], "stats": {"total": 139, "additions": 115, "deletions": 24}, "files": [{"sha": "95f6f9bc1b51091868aece549776938c18fcb604", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -21,27 +21,54 @@ and `Eq` to overload the `==` and `!=` operators.\n */\n \n /**\n-* Trait for values that can be compared for equality\n-* and inequality.\n+* Trait for values that can be compared for equality and inequality.\n *\n-* Eventually this may be simplified to only require\n-* an `eq` method, with the other generated from\n-* a default implementation. However it should\n-* remain possible to implement `ne` separately, for\n-* compatibility with floating-point NaN semantics\n-* (cf. IEEE 754-2008 section 5.11).\n+* This trait allows partial equality, where types can be unordered instead of strictly equal or\n+* unequal. For example, with the built-in floating-point types `a == b` and `a != b` will both\n+* evaluate to false if either `a` or `b` is NaN (cf. IEEE 754-2008 section 5.11).\n+*\n+* Eventually, this will be implemented by default for types that implement `TotalEq`.\n */\n #[lang=\"eq\"]\n pub trait Eq {\n     fn eq(&self, other: &Self) -> bool;\n     fn ne(&self, other: &Self) -> bool;\n }\n \n+/// Trait for equality comparisons where `a == b` and `a != b` are strict inverses.\n+pub trait TotalEq {\n+    fn equals(&self, other: &Self) -> bool;\n+}\n+\n+macro_rules! totaleq_impl(\n+    ($t:ty) => {\n+        impl TotalEq for $t {\n+            #[inline(always)]\n+            fn equals(&self, other: &$t) -> bool { *self == *other }\n+        }\n+    }\n+)\n+\n+totaleq_impl!(bool)\n+\n+totaleq_impl!(u8)\n+totaleq_impl!(u16)\n+totaleq_impl!(u32)\n+totaleq_impl!(u64)\n+\n+totaleq_impl!(i8)\n+totaleq_impl!(i16)\n+totaleq_impl!(i32)\n+totaleq_impl!(i64)\n+\n+totaleq_impl!(int)\n+totaleq_impl!(uint)\n+\n #[deriving(Eq)]\n pub enum Ordering { Less, Equal, Greater }\n \n /// Trait for types that form a total order\n-pub trait TotalOrd {\n+pub trait TotalOrd: TotalEq {\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n@@ -140,11 +167,17 @@ pub fn max<T:Ord>(v1: T, v2: T) -> T {\n #[cfg(test)]\n mod test {\n     #[test]\n-    fn test_int() {\n+    fn test_int_totalord() {\n         assert_eq!(5.cmp(&10), Less);\n         assert_eq!(10.cmp(&5), Greater);\n         assert_eq!(5.cmp(&5), Equal);\n         assert_eq!((-5).cmp(&12), Less);\n         assert_eq!(12.cmp(-5), Greater);\n     }\n+\n+    #[test]\n+    fn test_int_totaleq() {\n+        fail_unless!(5.equals(&5));\n+        fail_unless!(!2.equals(&17));\n+    }\n }"}, {"sha": "6b8c390fc25752506cc319f3d43cb1cb56184796", "filename": "src/libcore/nil.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/src%2Flibcore%2Fnil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/src%2Flibcore%2Fnil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnil.rs?ref=d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,7 +15,7 @@ Functions for the unit type.\n */\n \n #[cfg(notest)]\n-use cmp::{Eq, Ord, TotalOrd, Ordering, Equal};\n+use prelude::*;\n \n #[cfg(notest)]\n impl Eq for () {\n@@ -42,3 +42,9 @@ impl TotalOrd for () {\n     #[inline(always)]\n     fn cmp(&self, _other: &()) -> Ordering { Equal }\n }\n+\n+#[cfg(notest)]\n+impl TotalEq for () {\n+    #[inline(always)]\n+    fn equals(&self, _other: &()) -> bool { true }\n+}"}, {"sha": "0194e8f009c6a5222d3068240480a5294d54ba2a", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "patch": "@@ -24,7 +24,7 @@ pub use result::{Result, Ok, Err};\n /* Reexported types and traits */\n \n pub use clone::Clone;\n-pub use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n+pub use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};"}, {"sha": "a6f9ae84f44299fa7e139d6344e2673f2a86a8cb", "filename": "src/libcore/str.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "patch": "@@ -21,7 +21,7 @@ use at_vec;\n use cast;\n use char;\n use clone::Clone;\n-use cmp::{Equiv, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{Equiv, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use libc;\n use option::{None, Option, Some};\n use ptr;\n@@ -930,6 +930,30 @@ impl Eq for @str {\n     fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(notest)]\n+impl<'self> TotalEq for &'self str {\n+    #[inline(always)]\n+    fn equals(&self, other: & &'self str) -> bool {\n+        eq_slice((*self), (*other))\n+    }\n+}\n+\n+#[cfg(notest)]\n+impl TotalEq for ~str {\n+    #[inline(always)]\n+    fn equals(&self, other: &~str) -> bool {\n+        eq_slice((*self), (*other))\n+    }\n+}\n+\n+#[cfg(notest)]\n+impl TotalEq for @str {\n+    #[inline(always)]\n+    fn equals(&self, other: &@str) -> bool {\n+        eq_slice((*self), (*other))\n+    }\n+}\n+\n #[cfg(notest)]\n impl Ord for ~str {\n     #[inline(always)]"}, {"sha": "174960560dfd6baad347b829e882ea8128f5cc96", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b267bcb5ac1adbc20bca0c170106ae3b3538ab/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=d2b267bcb5ac1adbc20bca0c170106ae3b3538ab", "patch": "@@ -14,7 +14,7 @@\n \n use container::{Container, Mutable};\n use cast;\n-use cmp::{Eq, Equiv, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{Eq, Equiv, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use iter::BaseIter;\n use iter;\n@@ -1547,7 +1547,7 @@ pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n \n // Equality\n \n-fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n+fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     if a_len != b_len { return false; }\n \n@@ -1556,33 +1556,61 @@ fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n         if a[i] != b[i] { return false; }\n         i += 1;\n     }\n+    true\n+}\n+\n+fn equals<T: TotalEq>(a: &[T], b: &[T]) -> bool {\n+    let (a_len, b_len) = (a.len(), b.len());\n+    if a_len != b_len { return false; }\n \n+    let mut i = 0;\n+    while i < a_len {\n+        if !a[i].equals(&b[i]) { return false; }\n+        i += 1;\n+    }\n     true\n }\n \n #[cfg(notest)]\n impl<'self,T:Eq> Eq for &'self [T] {\n     #[inline(always)]\n-    fn eq(&self, other: & &'self [T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: & &'self [T]) -> bool { eq(*self, *other) }\n     #[inline(always)]\n-    fn ne(&self, other: & &'self [T]) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n }\n \n-\n #[cfg(notest)]\n impl<T:Eq> Eq for ~[T] {\n     #[inline(always)]\n-    fn eq(&self, other: &~[T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: &~[T]) -> bool { eq(*self, *other) }\n     #[inline(always)]\n-    fn ne(&self, other: &~[T]) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> Eq for @[T] {\n     #[inline(always)]\n-    fn eq(&self, other: &@[T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: &@[T]) -> bool { eq(*self, *other) }\n+    #[inline(always)]\n+    fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n+}\n+\n+#[cfg(notest)]\n+impl<'self,T:TotalEq> TotalEq for &'self [T] {\n+    #[inline(always)]\n+    fn equals(&self, other: & &'self [T]) -> bool { equals(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl<T:TotalEq> TotalEq for ~[T] {\n+    #[inline(always)]\n+    fn equals(&self, other: &~[T]) -> bool { equals(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl<T:TotalEq> TotalEq for @[T] {\n     #[inline(always)]\n-    fn ne(&self, other: &@[T]) -> bool { !(*self).eq(other) }\n+    fn equals(&self, other: &@[T]) -> bool { equals(*self, *other) }\n }\n \n #[cfg(notest)]"}]}