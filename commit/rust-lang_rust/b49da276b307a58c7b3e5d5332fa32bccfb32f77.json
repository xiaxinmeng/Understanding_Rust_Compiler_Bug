{"sha": "b49da276b307a58c7b3e5d5332fa32bccfb32f77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OWRhMjc2YjMwN2E1OGM3YjNlNWQ1MzMyZmEzMmJjY2ZiMzJmNzc=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-09-06T07:24:33Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-10-25T20:48:44Z"}, "message": "Store a resolved def on hir::PathSegment", "tree": {"sha": "28a56c3881a4117f4c625c4675b4f1eed22efea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28a56c3881a4117f4c625c4675b4f1eed22efea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b49da276b307a58c7b3e5d5332fa32bccfb32f77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b49da276b307a58c7b3e5d5332fa32bccfb32f77", "html_url": "https://github.com/rust-lang/rust/commit/b49da276b307a58c7b3e5d5332fa32bccfb32f77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b49da276b307a58c7b3e5d5332fa32bccfb32f77/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc67d8fac48d48bcdeaab1c8e0a2770e0f246247", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc67d8fac48d48bcdeaab1c8e0a2770e0f246247", "html_url": "https://github.com/rust-lang/rust/commit/fc67d8fac48d48bcdeaab1c8e0a2770e0f246247"}], "stats": {"total": 293, "additions": 182, "deletions": 111}, "files": [{"sha": "23004d8035c64357a3d41ae6dc975a5042a9c62b", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b49da276b307a58c7b3e5d5332fa32bccfb32f77", "patch": "@@ -143,8 +143,13 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    /// Resolve a hir path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool);\n+    /// Resolve a path generated by the lowerer when expanding `for`, `if let`, etc.\n+    fn resolve_hir_path(\n+        &mut self,\n+        path: &ast::Path,\n+        args: Option<P<hir::GenericArgs>>,\n+        is_value: bool,\n+    ) -> hir::Path;\n \n     /// Obtain the resolution for a node id\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n@@ -163,7 +168,7 @@ pub trait Resolver {\n         span: Span,\n         crate_root: Option<&str>,\n         components: &[&str],\n-        params: Option<P<hir::GenericArgs>>,\n+        args: Option<P<hir::GenericArgs>>,\n         is_value: bool,\n     ) -> hir::Path;\n }\n@@ -1380,6 +1385,7 @@ impl<'a> LoweringContext<'a> {\n             // does not actually exist in the AST.\n             lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n \n+            let def = Def::Existential(DefId::local(exist_ty_def_index));\n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n             hir::TyKind::Def(hir::ItemId { id: exist_ty_id.node_id }, lifetimes)\n         })\n@@ -1852,8 +1858,10 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n+        let def = self.expect_full_def(segment.id);\n         hir::PathSegment::new(\n             segment.ident,\n+            Some(def),\n             generic_args,\n             infer_types,\n         )"}, {"sha": "e3c8f1eadf198a8af9895cdc8fadcbf88310d848", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b49da276b307a58c7b3e5d5332fa32bccfb32f77", "patch": "@@ -347,6 +347,7 @@ impl fmt::Display for Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n+    pub def: Option<Def>,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n@@ -367,14 +368,16 @@ impl PathSegment {\n     pub fn from_ident(ident: Ident) -> PathSegment {\n         PathSegment {\n             ident,\n+            def: None,\n             infer_types: true,\n             args: None,\n         }\n     }\n \n-    pub fn new(ident: Ident, args: GenericArgs, infer_types: bool) -> Self {\n+    pub fn new(ident: Ident, def: Option<Def>, args: GenericArgs, infer_types: bool) -> Self {\n         PathSegment {\n             ident,\n+            def,\n             infer_types,\n             args: if args.is_empty() {\n                 None"}, {"sha": "f30cb365eb7f4884f3f850e131a95c7212ade28e", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=b49da276b307a58c7b3e5d5332fa32bccfb32f77", "patch": "@@ -174,6 +174,7 @@ impl_stable_hash_for!(struct hir::Path {\n \n impl_stable_hash_for!(struct hir::PathSegment {\n     ident -> (ident.name),\n+    def,\n     infer_types,\n     args\n });"}, {"sha": "3164f3a83f04fc2789258be7e5926d552fd21fc3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b49da276b307a58c7b3e5d5332fa32bccfb32f77", "patch": "@@ -141,7 +141,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let prefix_iter = || parent_prefix.iter().cloned()\n             .chain(use_tree.prefix.segments.iter().map(|seg| seg.ident));\n         let prefix_start = prefix_iter().next();\n-        let starts_with_non_keyword = prefix_start.map_or(false, |ident| {\n+        let starts_with_non_keyword = prefix_start.map_or(false, |(ident, _)| {\n             !ident.is_path_segment_keyword()\n         });\n \n@@ -202,13 +202,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let source = prefix_start.unwrap();\n \n             // Helper closure to emit a canary with the given base path.\n-            let emit = |this: &mut Self, base: Option<Ident>| {\n+            let emit = |this: &mut Self, base: Option<(Ident, Option<NodeId>)>| {\n                 let subclass = SingleImport {\n                     target: Ident {\n                         name: keywords::Underscore.name().gensymed(),\n-                        span: source.span,\n+                        span: source.0.span,\n                     },\n-                    source,\n+                    source: source.0,\n                     result: PerNS {\n                         type_ns: Cell::new(Err(Undetermined)),\n                         value_ns: Cell::new(Err(Undetermined)),\n@@ -219,7 +219,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 this.add_import_directive(\n                     base.into_iter().collect(),\n                     subclass.clone(),\n-                    source.span,\n+                    source.0.span,\n                     id,\n                     root_use_tree.span,\n                     root_id,\n@@ -230,15 +230,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n \n             // A single simple `self::x` canary.\n-            emit(self, Some(Ident {\n+            emit(self, Some((Ident {\n                 name: keywords::SelfValue.name(),\n-                span: source.span,\n-            }));\n+                span: source.0.span,\n+            }, source.1)));\n \n             // One special unprefixed canary per block scope around\n             // the import, to detect items unreachable by `self::x`.\n             let orig_current_module = self.current_module;\n-            let mut span = source.span.modern();\n+            let mut span = source.0.span.modern();\n             loop {\n                 match self.current_module.kind {\n                     ModuleKind::Block(..) => emit(self, None),\n@@ -265,10 +265,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 if nested {\n                     // Correctly handle `self`\n-                    if source.name == keywords::SelfValue.name() {\n+                    if source.0.name == keywords::SelfValue.name() {\n                         type_ns_only = true;\n \n-                        let empty_prefix = module_path.last().map_or(true, |ident| {\n+                        let empty_prefix = module_path.last().map_or(true, |(ident, _)| {\n                             ident.name == keywords::CrateRoot.name()\n                         });\n                         if empty_prefix {\n@@ -284,20 +284,20 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // Replace `use foo::self;` with `use foo;`\n                         source = module_path.pop().unwrap();\n                         if rename.is_none() {\n-                            ident = source;\n+                            ident = source.0;\n                         }\n                     }\n                 } else {\n                     // Disallow `self`\n-                    if source.name == keywords::SelfValue.name() {\n+                    if source.0.name == keywords::SelfValue.name() {\n                         resolve_error(self,\n                                       use_tree.span,\n                                       ResolutionError::SelfImportsOnlyAllowedWithin);\n                     }\n \n                     // Disallow `use $crate;`\n-                    if source.name == keywords::DollarCrate.name() && module_path.is_empty() {\n-                        let crate_root = self.resolve_crate_root(source);\n+                    if source.0.name == keywords::DollarCrate.name() && module_path.is_empty() {\n+                        let crate_root = self.resolve_crate_root(source.0);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(_, name) => name,\n                             ModuleKind::Block(..) => unreachable!(),\n@@ -307,11 +307,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // while the current crate doesn't have a valid `crate_name`.\n                         if crate_name != keywords::Invalid.name() {\n                             // `crate_name` should not be interpreted as relative.\n-                            module_path.push(Ident {\n+                            module_path.push((Ident {\n                                 name: keywords::CrateRoot.name(),\n-                                span: source.span,\n-                            });\n-                            source.name = crate_name;\n+                                span: source.0.span,\n+                            }, Some(self.session.next_node_id())));\n+                            source.0.name = crate_name;\n                         }\n                         if rename.is_none() {\n                             ident.name = crate_name;\n@@ -332,7 +332,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 let subclass = SingleImport {\n                     target: ident,\n-                    source,\n+                    source: source.0,\n                     result: PerNS {\n                         type_ns: Cell::new(Err(Undetermined)),\n                         value_ns: Cell::new(Err(Undetermined)),\n@@ -393,6 +393,17 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n \n                 for &(ref tree, id) in items {\n+                    let prefix = ast::Path {\n+                        segments: module_path.iter()\n+                            .map(|ident| {\n+                                let mut seg = ast::PathSegment::from_ident(ident.0);\n+                                seg.id = self.session.next_node_id();\n+                                seg\n+                            })\n+                            .collect(),\n+                        span: path.span,\n+                    };\n+\n                     self.build_reduced_graph_for_use_tree(\n                         root_use_tree,\n                         root_id,"}, {"sha": "96ebd82df3a325baf50bbc2eec0782bae9b85a14", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 104, "deletions": 67, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b49da276b307a58c7b3e5d5332fa32bccfb32f77", "patch": "@@ -1534,8 +1534,13 @@ impl<'a, 'b: 'a, 'cl: 'b> ty::DefIdTree for &'a Resolver<'b, 'cl> {\n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl<'a, 'cl> hir::lowering::Resolver for Resolver<'a, 'cl> {\n-    fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool) {\n-        self.resolve_hir_path_cb(path, is_value,\n+    fn resolve_hir_path(\n+        &mut self,\n+        path: &ast::Path,\n+        args: Option<P<hir::GenericArgs>>,\n+        is_value: bool,\n+    ) -> hir::Path {\n+        self.resolve_hir_path_cb(path, args, is_value,\n                                  |resolver, span, error| resolve_error(resolver, span, error))\n     }\n \n@@ -1547,30 +1552,20 @@ impl<'a, 'cl> hir::lowering::Resolver for Resolver<'a, 'cl> {\n         args: Option<P<hir::GenericArgs>>,\n         is_value: bool\n     ) -> hir::Path {\n-        let mut segments = iter::once(keywords::CrateRoot.ident())\n+        let segments = iter::once(keywords::CrateRoot.ident())\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n                     .map(Ident::from_str)\n-            ).map(hir::PathSegment::from_ident).collect::<Vec<_>>();\n+            ).map(|i| self.new_ast_path_segment(i)).collect::<Vec<_>>();\n \n-        if let Some(args) = args {\n-            let ident = segments.last().unwrap().ident;\n-            *segments.last_mut().unwrap() = hir::PathSegment {\n-                ident,\n-                args: Some(args),\n-                infer_types: true,\n-            };\n-        }\n \n-        let mut path = hir::Path {\n+        let path = ast::Path {\n             span,\n-            def: Def::Err,\n-            segments: segments.into(),\n+            segments,\n         };\n \n-        self.resolve_hir_path(&mut path, is_value);\n-        path\n+        self.resolve_hir_path(&path, args, is_value)\n     }\n \n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> {\n@@ -1596,23 +1591,27 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         use std::iter;\n         let mut errored = false;\n \n-        let mut path = if path_str.starts_with(\"::\") {\n-            hir::Path {\n+        let path = if path_str.starts_with(\"::\") {\n+            ast::Path {\n                 span,\n-                def: Def::Err,\n-                segments: iter::once(keywords::CrateRoot.ident()).chain({\n-                    path_str.split(\"::\").skip(1).map(Ident::from_str)\n-                }).map(hir::PathSegment::from_ident).collect(),\n+                segments: iter::once(keywords::CrateRoot.ident())\n+                    .chain({\n+                        path_str.split(\"::\").skip(1).map(Ident::from_str)\n+                    })\n+                    .map(|i| self.new_ast_path_segment(i))\n+                    .collect(),\n             }\n         } else {\n-            hir::Path {\n+            ast::Path {\n                 span,\n-                def: Def::Err,\n-                segments: path_str.split(\"::\").map(Ident::from_str)\n-                                  .map(hir::PathSegment::from_ident).collect(),\n+                segments: path_str\n+                    .split(\"::\")\n+                    .map(Ident::from_str)\n+                    .map(|i| self.new_ast_path_segment(i))\n+                    .collect(),\n             }\n         };\n-        self.resolve_hir_path_cb(&mut path, is_value, |_, _, _| errored = true);\n+        let path = self.resolve_hir_path_cb(&path, None, is_value, |_, _, _| errored = true);\n         if errored || path.def == Def::Err {\n             Err(())\n         } else {\n@@ -1621,16 +1620,23 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n     }\n \n     /// resolve_hir_path, but takes a callback in case there was an error\n-    fn resolve_hir_path_cb<F>(&mut self, path: &mut hir::Path, is_value: bool, error_callback: F)\n+    fn resolve_hir_path_cb<F>(\n+        &mut self,\n+        path: &ast::Path,\n+        args: Option<P<hir::GenericArgs>>,\n+        is_value: bool,\n+        error_callback: F,\n+    ) -> hir::Path\n         where F: for<'c, 'b> FnOnce(&'c mut Resolver, Span, ResolutionError<'b>)\n     {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n-        let hir::Path { ref segments, span, ref mut def } = *path;\n-        let path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n+        let span = path.span;\n+        let segments = &path.segments;\n+        let path: Vec<_> = segments.iter().map(|seg| (seg.ident, Some(seg.id))).collect();\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n-        match self.resolve_path(None, &path, Some(namespace), true, span, CrateLint::No) {\n+        let def = match self.resolve_path(None, &path, Some(namespace), true, span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                *def = module.def().unwrap(),\n+                module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n             PathResult::NonModule(..) =>\n@@ -1648,9 +1654,28 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed(span, msg, _) => {\n                 error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n+                Def::Err\n             }\n+        };\n+\n+        let mut segments: Vec<_> = segments.iter().map(|seg| {\n+            let mut hir_seg = hir::PathSegment::from_ident(seg.ident);\n+            hir_seg.def = Some(self.def_map.get(&seg.id).map_or(Def::Err, |p| p.base_def()));\n+            hir_seg\n+        }).collect();\n+        segments.last_mut().unwrap().args = args;\n+        hir::Path {\n+            span,\n+            def,\n+            segments: segments.into(),\n         }\n     }\n+\n+    fn new_ast_path_segment(&self, ident: Ident) -> ast::PathSegment {\n+        let mut seg = ast::PathSegment::from_ident(ident);\n+        seg.id = self.session.next_node_id();\n+        seg\n+    }\n }\n \n impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n@@ -2458,7 +2483,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             let path: Vec<_> = trait_ref.path.segments.iter()\n-                .map(|seg| seg.ident)\n+                .map(|seg| (seg.ident, Some(seg.id)))\n                 .collect();\n             let def = self.smart_resolve_path_fragment(\n                 trait_ref.ref_id,\n@@ -2956,20 +2981,20 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         crate_lint: CrateLint\n     ) -> PathResolution {\n         let segments = &path.segments.iter()\n-            .map(|seg| seg.ident)\n+            .map(|seg| (seg.ident, Some(seg.id)))\n             .collect::<Vec<_>>();\n         self.smart_resolve_path_fragment(id, qself, segments, path.span, source, crate_lint)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n-                                   path: &[Ident],\n+                                   path: &[(Ident, Option<NodeId>)],\n                                    span: Span,\n                                    source: PathSource,\n                                    crate_lint: CrateLint)\n                                    -> PathResolution {\n-        let ident_span = path.last().map_or(span, |ident| ident.span);\n+        let ident_span = path.last().map_or(span, |ident| ident.0.span);\n         let ns = source.namespace();\n         let is_expected = &|def| source.is_expected(def);\n         let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n@@ -2979,17 +3004,17 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             // Make the base error.\n             let expected = source.descr_expected();\n             let path_str = names_to_string(path);\n-            let item_str = path.last().unwrap();\n+            let item_str = path.last().unwrap().0;\n             let code = source.error_code(def.is_some());\n             let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n                  format!(\"not a {}\", expected),\n                  span)\n             } else {\n-                let item_span = path.last().unwrap().span;\n+                let item_span = path.last().unwrap().0.span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (String::new(), \"this scope\".to_string())\n-                } else if path.len() == 2 && path[0].name == keywords::CrateRoot.name() {\n+                } else if path.len() == 2 && path[0].0.name == keywords::CrateRoot.name() {\n                     (String::new(), \"the crate root\".to_string())\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n@@ -2999,7 +3024,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             module.def(),\n                         _ => None,\n                     }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n-                    (mod_prefix, format!(\"`{}`\", names_to_string(mod_path)))\n+                    (mod_prefix, format!(\"`{}`\", names_and_ids_to_string(mod_path)))\n                 };\n                 (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n                  format!(\"not found in {}\", mod_str),\n@@ -3045,7 +3070,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n-            let ident = *path.last().unwrap();\n+            let ident = path.last().unwrap().0;\n             let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n             if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates =\n@@ -3072,7 +3097,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n                 if let Some(candidate) = this.lookup_assoc_candidate(ident, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].span, span);\n+                    let self_is_available = this.self_value_is_available(path[0].0.span, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_suggestion_with_applicability(\n@@ -3307,7 +3332,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n-                    let item_name = *path.last().unwrap();\n+                    let item_name = path.last().unwrap().0;\n                     let traits = self.get_traits_containing_item(item_name, ns);\n                     self.trait_map.insert(id, traits);\n                 }\n@@ -3377,7 +3402,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_qpath_anywhere(&mut self,\n                               id: NodeId,\n                               qself: Option<&QSelf>,\n-                              path: &[Ident],\n+                              path: &[(Ident, Option<NodeId>)],\n                               primary_ns: Namespace,\n                               span: Span,\n                               defer_to_typeck: bool,\n@@ -3399,10 +3424,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n         }\n         if primary_ns != MacroNS &&\n-           (self.macro_names.contains(&path[0].modern()) ||\n-            self.builtin_macros.get(&path[0].name).cloned()\n+           (self.macro_names.contains(&path[0].0.modern()) ||\n+            self.builtin_macros.get(&path[0].0.name).cloned()\n                                .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang) ||\n-            self.macro_use_prelude.get(&path[0].name).cloned()\n+            self.macro_use_prelude.get(&path[0].0.name).cloned()\n                                   .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n@@ -3416,7 +3441,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_qpath(&mut self,\n                      id: NodeId,\n                      qself: Option<&QSelf>,\n-                     path: &[Ident],\n+                     path: &[(Ident, Option<NodeId>)],\n                      ns: Namespace,\n                      span: Span,\n                      global_by_default: bool,\n@@ -3506,8 +3531,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types\n-                           .contains_key(&path[0].name) => {\n-                let prim = self.primitive_type_table.primitive_types[&path[0].name];\n+                           .contains_key(&path[0].0.name) => {\n+                let prim = self.primitive_type_table.primitive_types[&path[0].0.name];\n                 PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n@@ -3522,8 +3547,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].name != keywords::CrateRoot.name() &&\n-           path[0].name != keywords::DollarCrate.name() {\n+           path[0].0.name != keywords::CrateRoot.name() &&\n+           path[0].0.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(\n                     None,\n@@ -3551,7 +3576,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_path(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n-        path: &[Ident],\n+        path: &[(Ident, Option<NodeId>)],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n         record_used: bool,\n         path_span: Span,\n@@ -3587,7 +3612,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             crate_lint,\n         );\n \n-        for (i, &ident) in path.iter().enumerate() {\n+        for (i, &(ident, id)) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?}\", i, ident);\n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n@@ -3648,7 +3673,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 } else {\n                     format!(\"`{}`\", name)\n                 };\n-                let msg = if i == 1 && path[0].name == keywords::CrateRoot.name() {\n+                let msg = if i == 1 && path[0].0.name == keywords::CrateRoot.name() {\n                     format!(\"global paths cannot start with {}\", name_str)\n                 } else {\n                     format!(\"{} in paths can only be used in start position\", name_str)\n@@ -3688,6 +3713,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(def);\n                     if let Some(next_module) = binding.module() {\n                         module = Some(ModuleOrUniformRoot::Module(next_module));\n+                        if !is_last && record_used {\n+                            if let Some(id) = id {\n+                                assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n+                                self.record_def(id, PathResolution::new(def));\n+                            }\n+                        }\n                     } else if def == Def::ToolMod && i + 1 != path.len() {\n                         let def = Def::NonMacroAttr(NonMacroAttrKind::Tool);\n                         return PathResult::NonModule(PathResolution::new(def));\n@@ -3737,7 +3768,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     } else if i == 0 {\n                         format!(\"Use of undeclared type or module `{}`\", ident)\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1])\n+                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1].0)\n                     };\n                     return PathResult::Failed(ident.span, msg, is_last);\n                 }\n@@ -3755,7 +3786,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn lint_if_path_starts_with_module(\n         &self,\n         crate_lint: CrateLint,\n-        path: &[Ident],\n+        path: &[(Ident, Option<NodeId>)],\n         path_span: Span,\n         second_binding: Option<&NameBinding>,\n     ) {\n@@ -3772,7 +3803,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         let first_name = match path.get(0) {\n-            Some(ident) => ident.name,\n+            Some(ident) => ident.0.name,\n             None => return,\n         };\n \n@@ -3784,7 +3815,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         match path.get(1) {\n             // If this import looks like `crate::...` it's already good\n-            Some(ident) if ident.name == keywords::Crate.name() => return,\n+            Some((ident, _)) if ident.name == keywords::Crate.name() => return,\n             // Otherwise go below to see if it's an extern crate\n             Some(_) => {}\n             // If the path has length one (and it's `CrateRoot` most likely)\n@@ -3977,7 +4008,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn lookup_typo_candidate<FilterFn>(&mut self,\n-                                       path: &[Ident],\n+                                       path: &[(Ident, Option<NodeId>)],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn,\n                                        span: Span)\n@@ -4041,7 +4072,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n         }\n \n-        let name = path[path.len() - 1].name;\n+        let name = path[path.len() - 1].0.name;\n         // Make sure error reporting is deterministic.\n         names.sort_by_cached_key(|name| name.as_str());\n         match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n@@ -4558,7 +4589,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // Visibilities are resolved as global by default, add starting root segment.\n                 let segments = path.make_root().iter().chain(path.segments.iter())\n-                    .map(|seg| seg.ident)\n+                    .map(|seg| (seg.ident, Some(seg.id)))\n                     .collect::<Vec<_>>();\n                 let def = self.smart_resolve_path_fragment(\n                     id,\n@@ -4851,12 +4882,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n }\n \n-fn is_self_type(path: &[Ident], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].name == keywords::SelfType.name()\n+fn is_self_type(path: &[(Ident, Option<NodeId>)], namespace: Namespace) -> bool {\n+    namespace == TypeNS && path.len() == 1 && path[0].0.name == keywords::SelfType.name()\n }\n \n-fn is_self_value(path: &[Ident], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].name == keywords::SelfValue.name()\n+fn is_self_value(path: &[(Ident, Option<NodeId>)], namespace: Namespace) -> bool {\n+    namespace == ValueNS && path.len() == 1 && path[0].0.name == keywords::SelfValue.name()\n }\n \n fn names_to_string(idents: &[Ident]) -> String {\n@@ -4872,6 +4903,12 @@ fn names_to_string(idents: &[Ident]) -> String {\n     result\n }\n \n+fn names_and_ids_to_string(segments: &[(Ident, Option<NodeId>)]) -> String {\n+    names_to_string(&segments.iter()\n+                        .map(|seg| seg.0)\n+                        .collect::<Vec<_>>())\n+}\n+\n fn path_names_to_string(path: &Path) -> String {\n     names_to_string(&path.segments.iter()\n                         .map(|seg| seg.ident)"}, {"sha": "f462542f1d3e0034bee24475a192d9648d3f845f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b49da276b307a58c7b3e5d5332fa32bccfb32f77", "patch": "@@ -462,13 +462,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         force: bool,\n     ) -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n-        let mut path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n+        let mut path: Vec<_> = segments.iter().map(|seg| (seg.ident, Some(seg.id))).collect();\n \n         // Possibly apply the macro helper hack\n         if kind == MacroKind::Bang && path.len() == 1 &&\n-           path[0].span.ctxt().outer().expn_info().map_or(false, |info| info.local_inner_macros) {\n-            let root = Ident::new(keywords::DollarCrate.name(), path[0].span);\n-            path.insert(0, root);\n+           path[0].0.span.ctxt().outer().expn_info().map_or(false, |info| info.local_inner_macros) {\n+            let root = Ident::new(keywords::DollarCrate.name(), path[0].0.span);\n+            path.insert(0, (root, None));\n         }\n \n         if path.len() > 1 {\n@@ -496,12 +496,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n \n             parent_scope.module.macro_resolutions.borrow_mut()\n-                .push((path.into_boxed_slice(), span));\n+                .push((path\n+                    .iter()\n+                    .map(|(ident, _)| *ident)\n+                    .collect::<Vec<Ident>>()\n+                    .into_boxed_slice(), span));\n \n             def\n         } else {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                path[0], MacroNS, Some(kind), parent_scope, false, force, span\n+                path[0].0, MacroNS, Some(kind), parent_scope, false, force, span\n             );\n             match binding {\n                 Ok(..) => {}\n@@ -510,7 +514,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n \n             parent_scope.module.legacy_macro_resolutions.borrow_mut()\n-                .push((path[0], kind, parent_scope.clone(), binding.ok()));\n+                .push((path[0].0, kind, parent_scope.clone(), binding.ok()));\n \n             binding.map(|binding| binding.def_ignoring_ambiguity())\n         }\n@@ -846,6 +850,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n+            let path = path\n+                .iter()\n+                .map(|ident| (*ident, None))\n+                .collect::<Vec<(Ident, Option<ast::NodeId>)>>();\n             match self.resolve_path(None, &path, Some(MacroNS), true, span, CrateLint::No) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n@@ -938,7 +946,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n             };\n             let ident = Ident::new(Symbol::intern(name), span);\n-            self.lookup_typo_candidate(&[ident], MacroNS, is_macro, span)\n+            self.lookup_typo_candidate(&[(ident, None)], MacroNS, is_macro, span)\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "4d3a67d4a892eabb8e95dc6179c939cc3705415e", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b49da276b307a58c7b3e5d5332fa32bccfb32f77", "patch": "@@ -14,7 +14,7 @@ use {AmbiguityError, CrateLint, Module, ModuleOrUniformRoot, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use Resolver;\n-use {names_to_string, module_to_string};\n+use {names_to_string, names_and_ids_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n use rustc_data_structures::ptr_key::PtrKey;\n@@ -89,7 +89,7 @@ pub struct ImportDirective<'a> {\n     pub root_span: Span,\n \n     pub parent: Module<'a>,\n-    pub module_path: Vec<Ident>,\n+    pub module_path: Vec<(Ident, Option<NodeId>)>,\n     /// The resolution of `module_path`.\n     pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n     pub subclass: ImportDirectiveSubclass<'a>,\n@@ -393,7 +393,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n \n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n-                                module_path: Vec<Ident>,\n+                                module_path: Vec<(Ident, Option<NodeId>)>,\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n@@ -679,7 +679,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n                 let has_explicit_self =\n                     !import.module_path.is_empty() &&\n-                    import.module_path[0].name == keywords::SelfValue.name();\n+                    import.module_path[0].0.name == keywords::SelfValue.name();\n \n                 self.per_ns(|_, ns| {\n                     if let Some(result) = result[ns].get().ok() {\n@@ -728,9 +728,11 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                     self.throw_unresolved_import_error(empty_vec, None);\n                 }\n                 if !seen_spans.contains(&span) {\n-                    let path = import_path_to_string(&import.module_path[..],\n-                                                     &import.subclass,\n-                                                     span);\n+                    let path = import_path_to_string(\n+                        &import.module_path.iter().map(|(ident, _)| *ident).collect::<Vec<_>>(),\n+                        &import.subclass,\n+                        span,\n+                    );\n                     error_vec.push((span, path, err));\n                     seen_spans.insert(span);\n                     prev_root_id = import.root_id;\n@@ -851,7 +853,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               names_to_string(&directive.module_path[..]),\n+               names_and_ids_to_string(&directive.module_path[..]),\n                module_to_string(self.current_module).unwrap_or_else(|| \"???\".to_string()));\n \n         self.current_module = directive.parent;\n@@ -982,7 +984,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n                     let mut full_path = module_path.clone();\n-                    full_path.push(keywords::Invalid.ident());\n+                    full_path.push((keywords::Invalid.ident(), None));\n                     self.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n                         &full_path,\n@@ -1146,7 +1148,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n             // 2 segments, so the `resolve_path` above won't trigger it.\n             let mut full_path = module_path.clone();\n-            full_path.push(ident);\n+            full_path.push((ident, None));\n             self.per_ns(|this, ns| {\n                 if let Ok(binding) = result[ns].get() {\n                     this.lint_if_path_starts_with_module(\n@@ -1288,7 +1290,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                         let resolutions = imported_module.parent.expect(\"parent should exist\")\n                             .resolutions.borrow();\n                         let enum_path_segment_index = directive.module_path.len() - 1;\n-                        let enum_ident = directive.module_path[enum_path_segment_index];\n+                        let enum_ident = directive.module_path[enum_path_segment_index].0;\n \n                         let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n                             .expect(\"resolution should exist\");\n@@ -1311,6 +1313,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                                                        \"consider making the enum public\",\n                                                        suggestion);\n                         err.emit();\n+                    }\n                 }\n             }\n         }"}, {"sha": "d33077b336b46d2f998f3eb3f953cce5a4cd7bbc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49da276b307a58c7b3e5d5332fa32bccfb32f77/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b49da276b307a58c7b3e5d5332fa32bccfb32f77", "patch": "@@ -147,7 +147,7 @@ impl PathSegment {\n     pub fn crate_root(span: Span) -> Self {\n         PathSegment {\n             ident: Ident::new(keywords::CrateRoot.name(), span),\n-            id: CRATE_NODE_ID,\n+            id: DUMMY_NODE_ID,\n             args: None,\n         }\n     }"}]}