{"sha": "55412a201aa687e16cb76681d8dc7d595253800d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NDEyYTIwMWFhNjg3ZTE2Y2I3NjY4MWQ4ZGM3ZDU5NTI1MzgwMGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-23T09:44:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-03T19:28:17Z"}, "message": "track `CurrentItem`, not just `Generics`", "tree": {"sha": "dc8203c0fffbc65cee836489d60d912e6a2d4a58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc8203c0fffbc65cee836489d60d912e6a2d4a58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55412a201aa687e16cb76681d8dc7d595253800d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55412a201aa687e16cb76681d8dc7d595253800d", "html_url": "https://github.com/rust-lang/rust/commit/55412a201aa687e16cb76681d8dc7d595253800d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55412a201aa687e16cb76681d8dc7d595253800d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b175aef0c40d0b60316fabc6b4023c60c5bc832e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b175aef0c40d0b60316fabc6b4023c60c5bc832e", "html_url": "https://github.com/rust-lang/rust/commit/b175aef0c40d0b60316fabc6b4023c60c5bc832e"}], "stats": {"total": 91, "additions": 54, "deletions": 37}, "files": [{"sha": "a617551eeb19138c3f6783f65fc02d7d01e3b9a9", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 54, "deletions": 37, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/55412a201aa687e16cb76681d8dc7d595253800d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55412a201aa687e16cb76681d8dc7d595253800d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=55412a201aa687e16cb76681d8dc7d595253800d", "patch": "@@ -48,6 +48,21 @@ pub struct Constraint<'a> {\n     pub variance: &'a VarianceTerm<'a>,\n }\n \n+/// To build constriants, we visit one item (type, trait) at a time\n+/// and look at its contents. So e.g. if we have\n+///\n+///     struct Foo<T> {\n+///         b: Bar<T>\n+///     }\n+///\n+/// then while we are visiting `Bar<T>`, the `CurrentItem` would have\n+/// the def-id and generics of `Foo`.\n+#[allow(dead_code)] // TODO -- `def_id` field not used yet\n+pub struct CurrentItem<'a> {\n+    def_id: DefId,\n+    generics: &'a ty::Generics,\n+}\n+\n pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n                                             -> ConstraintContext<'a, 'tcx> {\n     let tcx = terms_cx.tcx;\n@@ -73,7 +88,7 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let tcx = self.terms_cx.tcx;\n-        let did = tcx.hir.local_def_id(item.id);\n+        let def_id = tcx.hir.local_def_id(item.id);\n \n         debug!(\"visit_item item={}\", tcx.hir.node_to_string(item.id));\n \n@@ -82,6 +97,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n                 let generics = tcx.generics_of(did);\n+                let current_item = &CurrentItem { def_id, generics };\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n@@ -90,18 +106,19 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n                 // self.add_constraints_from_generics(generics);\n \n                 for field in tcx.adt_def(did).all_fields() {\n-                    self.add_constraints_from_ty(generics,\n-                                                 tcx.type_of(field.did),\n+                    self.add_constraints_from_ty(current_item,\n+                                                 tcx.item_type(field.did),\n                                                  self.covariant);\n                 }\n             }\n             hir::ItemTrait(..) => {\n                 let generics = tcx.generics_of(did);\n+                let current_item = &CurrentItem { def_id, generics };\n                 let trait_ref = ty::TraitRef {\n-                    def_id: did,\n-                    substs: Substs::identity_for_item(tcx, did)\n+                    def_id: def_id,\n+                    substs: Substs::identity_for_item(tcx, def_id)\n                 };\n-                self.add_constraints_from_trait_ref(generics,\n+                self.add_constraints_from_trait_ref(current_item,\n                                                     trait_ref,\n                                                     self.invariant);\n             }\n@@ -279,7 +296,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     }\n \n     fn add_constraints_from_trait_ref(&mut self,\n-                                      generics: &ty::Generics,\n+                                      current: &CurrentItem,\n                                       trait_ref: ty::TraitRef<'tcx>,\n                                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n@@ -293,7 +310,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         // README.md for a discussion on dep-graph management.\n         self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n \n-        self.add_constraints_from_substs(generics,\n+        self.add_constraints_from_substs(current,\n                                          trait_ref.def_id,\n                                          &trait_generics.types,\n                                          &trait_generics.regions,\n@@ -305,7 +322,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// in a context with the generics defined in `generics` and\n     /// ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n-                               generics: &ty::Generics,\n+                               current: &CurrentItem,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={:?}, variance={:?})\",\n@@ -325,22 +342,22 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyRef(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, region, contra);\n-                self.add_constraints_from_mt(generics, mt, variance);\n+                self.add_constraints_from_region(current, region, contra);\n+                self.add_constraints_from_mt(current, mt, variance);\n             }\n \n             ty::TyArray(typ, _) |\n             ty::TySlice(typ) => {\n-                self.add_constraints_from_ty(generics, typ, variance);\n+                self.add_constraints_from_ty(current, typ, variance);\n             }\n \n             ty::TyRawPtr(ref mt) => {\n-                self.add_constraints_from_mt(generics, mt, variance);\n+                self.add_constraints_from_mt(current, mt, variance);\n             }\n \n             ty::TyTuple(subtys, _) => {\n                 for &subty in subtys {\n-                    self.add_constraints_from_ty(generics, subty, variance);\n+                    self.add_constraints_from_ty(current, subty, variance);\n                 }\n             }\n \n@@ -352,7 +369,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // README.md for a discussion on dep-graph management.\n                 self.tcx().dep_graph.read(VarianceDepNode(def.did));\n \n-                self.add_constraints_from_substs(generics,\n+                self.add_constraints_from_substs(current,\n                                                  def.did,\n                                                  &adt_generics.types,\n                                                  &adt_generics.regions,\n@@ -369,7 +386,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // README.md for a discussion on dep-graph management.\n                 self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n \n-                self.add_constraints_from_substs(generics,\n+                self.add_constraints_from_substs(current,\n                                                  trait_ref.def_id,\n                                                  &trait_generics.types,\n                                                  &trait_generics.regions,\n@@ -380,25 +397,25 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::TyDynamic(ref data, r) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, r, contra);\n+                self.add_constraints_from_region(current, r, contra);\n \n                 if let Some(p) = data.principal() {\n                     let poly_trait_ref = p.with_self_ty(self.tcx(), self.tcx().types.err);\n-                    self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n+                    self.add_constraints_from_trait_ref(current, poly_trait_ref.0, variance);\n                 }\n \n                 for projection in data.projection_bounds() {\n-                    self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n+                    self.add_constraints_from_ty(current, projection.0.ty, self.invariant);\n                 }\n             }\n \n             ty::TyParam(ref data) => {\n-                assert_eq!(generics.parent, None);\n+                assert_eq!(current.generics.parent, None);\n                 let mut i = data.idx as usize;\n-                if !generics.has_self || i > 0 {\n-                    i -= generics.regions.len();\n+                if !current.generics.has_self || i > 0 {\n+                    i -= current.generics.regions.len();\n                 }\n-                let def_id = generics.types[i].def_id;\n+                let def_id = current.generics.types[i].def_id;\n                 let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n@@ -414,7 +431,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyFnDef(.., sig) |\n             ty::TyFnPtr(sig) => {\n-                self.add_constraints_from_sig(generics, sig, variance);\n+                self.add_constraints_from_sig(current, sig, variance);\n             }\n \n             ty::TyError => {\n@@ -433,7 +450,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a nominal type (enum, struct,\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n-                                   generics: &ty::Generics,\n+                                   current: &CurrentItem,\n                                    def_id: DefId,\n                                    type_param_defs: &[ty::TypeParameterDef],\n                                    region_param_defs: &[ty::RegionParameterDef],\n@@ -451,41 +468,41 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl,\n                    variance_i);\n-            self.add_constraints_from_ty(generics, substs_ty, variance_i);\n+            self.add_constraints_from_ty(current, substs_ty, variance_i);\n         }\n \n         for p in region_param_defs {\n             let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_r = substs.region_for_def(p);\n-            self.add_constraints_from_region(generics, substs_r, variance_i);\n+            self.add_constraints_from_region(current, substs_r, variance_i);\n         }\n     }\n \n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n-                                generics: &ty::Generics,\n+                                current: &CurrentItem,\n                                 sig: ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n         for &input in sig.0.inputs() {\n-            self.add_constraints_from_ty(generics, input, contra);\n+            self.add_constraints_from_ty(current, input, contra);\n         }\n-        self.add_constraints_from_ty(generics, sig.0.output(), variance);\n+        self.add_constraints_from_ty(current, sig.0.output(), variance);\n     }\n \n     /// Adds constraints appropriate for a region appearing in a\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n-                                   generics: &ty::Generics,\n+                                   current: &CurrentItem,\n                                    region: ty::Region<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                assert_eq!(generics.parent, None);\n-                let i = data.index as usize - generics.has_self as usize;\n-                let def_id = generics.regions[i].def_id;\n+                assert_eq!(current.generics.parent, None);\n+                let i = data.index as usize - current.generics.has_self as usize;\n+                let def_id = current.generics.regions[i].def_id;\n                 let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n                     let index = self.inferred_index(node_id);\n@@ -518,17 +535,17 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a mutability-type pair\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n-                               generics: &ty::Generics,\n+                               current: &CurrentItem,\n                                mt: &ty::TypeAndMut<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n             hir::MutMutable => {\n                 let invar = self.invariant(variance);\n-                self.add_constraints_from_ty(generics, mt.ty, invar);\n+                self.add_constraints_from_ty(current, mt.ty, invar);\n             }\n \n             hir::MutImmutable => {\n-                self.add_constraints_from_ty(generics, mt.ty, variance);\n+                self.add_constraints_from_ty(current, mt.ty, variance);\n             }\n         }\n     }"}]}