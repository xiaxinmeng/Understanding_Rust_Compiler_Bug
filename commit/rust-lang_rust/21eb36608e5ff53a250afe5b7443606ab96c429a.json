{"sha": "21eb36608e5ff53a250afe5b7443606ab96c429a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZWIzNjYwOGU1ZmY1M2EyNTBhZmU1Yjc0NDM2MDZhYjk2YzQyOWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-21T12:18:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-31T23:44:43Z"}, "message": "create but do not use a projection cache", "tree": {"sha": "6430afeb59e37fd794c8b4b1d82ae25aa1f6d1fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6430afeb59e37fd794c8b4b1d82ae25aa1f6d1fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21eb36608e5ff53a250afe5b7443606ab96c429a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21eb36608e5ff53a250afe5b7443606ab96c429a", "html_url": "https://github.com/rust-lang/rust/commit/21eb36608e5ff53a250afe5b7443606ab96c429a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21eb36608e5ff53a250afe5b7443606ab96c429a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d042ce2ed3da66b8c1e1983ab82f5973a926af74", "url": "https://api.github.com/repos/rust-lang/rust/commits/d042ce2ed3da66b8c1e1983ab82f5973a926af74", "html_url": "https://github.com/rust-lang/rust/commit/d042ce2ed3da66b8c1e1983ab82f5973a926af74"}], "stats": {"total": 124, "additions": 118, "deletions": 6}, "files": [{"sha": "8e3d63508bfc5b0577b2c80ea6aaecbeb96e6ce0", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/21eb36608e5ff53a250afe5b7443606ab96c429a/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21eb36608e5ff53a250afe5b7443606ab96c429a/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=21eb36608e5ff53a250afe5b7443606ab96c429a", "patch": "@@ -106,6 +106,12 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     pub tables: InferTables<'a, 'gcx, 'tcx>,\n \n+    // Cache for projections. This cache is snapshotted along with the\n+    // infcx.\n+    //\n+    // Public so that `traits::project` can use it.\n+    pub projection_cache: RefCell<traits::ProjectionCache<'tcx>>,\n+\n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n@@ -479,6 +485,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             parameter_environment: param_env,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n+            projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             reported_trait_errors: RefCell::new(FnvHashSet()),\n             normalize: false,\n             projection_mode: ProjectionMode::AnyFinal,\n@@ -512,6 +519,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         global_tcx.enter_local(arenas, |tcx| f(InferCtxt {\n             tcx: tcx,\n             tables: tables,\n+            projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n@@ -547,6 +555,7 @@ impl<'tcx, T> InferOk<'tcx, T> {\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot {\n+    projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot,\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n     float_snapshot: unify::Snapshot<ty::FloatVid>,\n@@ -827,6 +836,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.obligations_in_snapshot.set(false);\n \n         CombinedSnapshot {\n+            projection_cache_snapshot: self.projection_cache.borrow_mut().snapshot(),\n             type_snapshot: self.type_variables.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n@@ -837,7 +847,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot) {\n         debug!(\"rollback_to(cause={})\", cause);\n-        let CombinedSnapshot { type_snapshot,\n+        let CombinedSnapshot { projection_cache_snapshot,\n+                               type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n@@ -846,6 +857,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         assert!(!self.obligations_in_snapshot.get());\n         self.obligations_in_snapshot.set(obligations_in_snapshot);\n \n+        self.projection_cache\n+            .borrow_mut()\n+            .rollback_to(projection_cache_snapshot);\n         self.type_variables\n             .borrow_mut()\n             .rollback_to(type_snapshot);\n@@ -861,14 +875,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn commit_from(&self, snapshot: CombinedSnapshot) {\n         debug!(\"commit_from()\");\n-        let CombinedSnapshot { type_snapshot,\n+        let CombinedSnapshot { projection_cache_snapshot,\n+                               type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n                                obligations_in_snapshot } = snapshot;\n \n         self.obligations_in_snapshot.set(obligations_in_snapshot);\n \n+        self.projection_cache\n+            .borrow_mut()\n+            .commit(projection_cache_snapshot);\n         self.type_variables\n             .borrow_mut()\n             .commit(type_snapshot);\n@@ -926,7 +944,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         F: FnOnce() -> Result<T, E>\n     {\n         debug!(\"commit_regions_if_ok()\");\n-        let CombinedSnapshot { type_snapshot,\n+        let CombinedSnapshot { projection_cache_snapshot,\n+                               type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n@@ -941,6 +960,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // Roll back any non-region bindings - they should be resolved\n         // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n+        self.projection_cache\n+            .borrow_mut()\n+            .rollback_to(projection_cache_snapshot);\n         self.type_variables\n             .borrow_mut()\n             .rollback_to(type_snapshot);"}, {"sha": "5b363d90578b1e7c2d996c904bc5bd5b468f1af7", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21eb36608e5ff53a250afe5b7443606ab96c429a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21eb36608e5ff53a250afe5b7443606ab96c429a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=21eb36608e5ff53a250afe5b7443606ab96c429a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Trait Resolution. See the Book for more.\n+//! Trait Resolution. See README.md for an overview of how this works.\n \n pub use self::SelectionError::*;\n pub use self::FulfillmentErrorCode::*;\n@@ -30,8 +30,9 @@ pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n-pub use self::project::{MismatchedProjectionTypes, ProjectionMode};\n+pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n+pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, ProjectionMode};\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};"}, {"sha": "7eb44d0e79e8ee34668692d04eb0f9d2c658048c", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/21eb36608e5ff53a250afe5b7443606ab96c429a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21eb36608e5ff53a250afe5b7443606ab96c429a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=21eb36608e5ff53a250afe5b7443606ab96c429a", "patch": "@@ -340,7 +340,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                                               data.clone(),\n                                               self.cause.clone(),\n                                               self.depth);\n-                debug!(\"AssociatedTypeNormalizer: depth={} normalized {:?} to {:?} with {} add'l obligations\",\n+                debug!(\"AssociatedTypeNormalizer: depth={} normalized {:?} to {:?} \\\n+                        with {} add'l obligations\",\n                        self.depth, ty, normalized_ty, obligations.len());\n                 self.obligations.extend(obligations);\n                 normalized_ty\n@@ -1237,3 +1238,91 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n             .next()\n     }\n }\n+\n+// # Cache\n+\n+pub struct ProjectionCache<'tcx> {\n+    map: SnapshotMap<ty::ProjectionTy<'tcx>, ProjectionCacheEntry<'tcx>>,\n+}\n+\n+#[derive(Clone, Debug)]\n+enum ProjectionCacheEntry<'tcx> {\n+    InProgress,\n+    Ambiguous,\n+    Error,\n+    NormalizedTy(Ty<'tcx>),\n+}\n+\n+// NB: intentionally not Clone\n+pub struct ProjectionCacheSnapshot {\n+    snapshot: Snapshot\n+}\n+\n+impl<'tcx> ProjectionCache<'tcx> {\n+    pub fn new() -> Self {\n+        ProjectionCache {\n+            map: SnapshotMap::new()\n+        }\n+    }\n+\n+    pub fn snapshot(&mut self) -> ProjectionCacheSnapshot {\n+        ProjectionCacheSnapshot { snapshot: self.map.snapshot() }\n+    }\n+\n+    pub fn rollback_to(&mut self, snapshot: ProjectionCacheSnapshot) {\n+        self.map.rollback_to(snapshot.snapshot);\n+    }\n+\n+    pub fn commit(&mut self, snapshot: ProjectionCacheSnapshot) {\n+        self.map.commit(snapshot.snapshot);\n+    }\n+\n+    /// Try to start normalize `key`; returns an error if\n+    /// normalization already occured (this error corresponds to a\n+    /// cache hit, so it's actually a good thing).\n+    fn try_start(&mut self, key: ty::ProjectionTy<'tcx>)\n+                 -> Result<(), ProjectionCacheEntry<'tcx>> {\n+        match self.map.get(&key) {\n+            Some(entry) => return Err(entry.clone()),\n+            None => { }\n+        }\n+\n+        self.map.insert(key, ProjectionCacheEntry::InProgress);\n+        Ok(())\n+    }\n+\n+    /// Indicates that `key` was normalized to `value`. If `cacheable` is false,\n+    /// then this result is sadly not cacheable.\n+    fn complete(&mut self,\n+                key: ty::ProjectionTy<'tcx>,\n+                value: &NormalizedTy<'tcx>,\n+                cacheable: bool) {\n+        let fresh_key = if cacheable {\n+            debug!(\"ProjectionCacheEntry::complete: adding cache entry: key={:?}, value={:?}\",\n+                   key, value);\n+            self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.value))\n+        } else {\n+            debug!(\"ProjectionCacheEntry::complete: cannot cache: key={:?}, value={:?}\",\n+                   key, value);\n+            !self.map.remove(key)\n+        };\n+\n+        assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n+    }\n+\n+    /// Indicates that trying to normalize `key` resulted in\n+    /// ambiguity. No point in trying it again then until we gain more\n+    /// type information (in which case, the \"fully resolved\" key will\n+    /// be different).\n+    fn ambiguous(&mut self, key: ty::ProjectionTy<'tcx>) {\n+        let fresh = self.map.insert(key, ProjectionCacheEntry::Ambiguous);\n+        assert!(!fresh, \"never started projecting `{:?}`\", key);\n+    }\n+\n+    /// Indicates that trying to normalize `key` resulted in\n+    /// error.\n+    fn error(&mut self, key: ty::ProjectionTy<'tcx>) {\n+        let fresh = self.map.insert(key, ProjectionCacheEntry::Error);\n+        assert!(!fresh, \"never started projecting `{:?}`\", key);\n+    }\n+}"}]}