{"sha": "be130b57d477069799158506d7e80145fdf71c73", "node_id": "C_kwDOAAsO6NoAKGJlMTMwYjU3ZDQ3NzA2OTc5OTE1ODUwNmQ3ZTgwMTQ1ZmRmNzFjNzM", "commit": {"author": {"name": "Kyle Matsuda", "email": "kyle.yoshio.matsuda@gmail.com", "date": "2023-01-10T21:22:52Z"}, "committer": {"name": "Kyle Matsuda", "email": "kyle.yoshio.matsuda@gmail.com", "date": "2023-01-14T07:23:32Z"}, "message": "change usages of impl_trait_ref to bound_impl_trait_ref", "tree": {"sha": "341ffe12198905a74b3f0e7ec5d44d1caa06fc88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/341ffe12198905a74b3f0e7ec5d44d1caa06fc88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be130b57d477069799158506d7e80145fdf71c73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be130b57d477069799158506d7e80145fdf71c73", "html_url": "https://github.com/rust-lang/rust/commit/be130b57d477069799158506d7e80145fdf71c73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be130b57d477069799158506d7e80145fdf71c73/comments", "author": {"login": "kylematsuda", "id": 17287790, "node_id": "MDQ6VXNlcjE3Mjg3Nzkw", "avatar_url": "https://avatars.githubusercontent.com/u/17287790?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kylematsuda", "html_url": "https://github.com/kylematsuda", "followers_url": "https://api.github.com/users/kylematsuda/followers", "following_url": "https://api.github.com/users/kylematsuda/following{/other_user}", "gists_url": "https://api.github.com/users/kylematsuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/kylematsuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kylematsuda/subscriptions", "organizations_url": "https://api.github.com/users/kylematsuda/orgs", "repos_url": "https://api.github.com/users/kylematsuda/repos", "events_url": "https://api.github.com/users/kylematsuda/events{/privacy}", "received_events_url": "https://api.github.com/users/kylematsuda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kylematsuda", "id": 17287790, "node_id": "MDQ6VXNlcjE3Mjg3Nzkw", "avatar_url": "https://avatars.githubusercontent.com/u/17287790?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kylematsuda", "html_url": "https://github.com/kylematsuda", "followers_url": "https://api.github.com/users/kylematsuda/followers", "following_url": "https://api.github.com/users/kylematsuda/following{/other_user}", "gists_url": "https://api.github.com/users/kylematsuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/kylematsuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kylematsuda/subscriptions", "organizations_url": "https://api.github.com/users/kylematsuda/orgs", "repos_url": "https://api.github.com/users/kylematsuda/repos", "events_url": "https://api.github.com/users/kylematsuda/events{/privacy}", "received_events_url": "https://api.github.com/users/kylematsuda/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef58baf8b8fecc5ca8b5e34921d33650186d4205", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef58baf8b8fecc5ca8b5e34921d33650186d4205", "html_url": "https://github.com/rust-lang/rust/commit/ef58baf8b8fecc5ca8b5e34921d33650186d4205"}], "stats": {"total": 234, "additions": 134, "deletions": 100}, "files": [{"sha": "28d83eea5ef4d8c6d18fff750283bfacd36f86da", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -2059,14 +2059,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             (_, Res::SelfTyAlias { alias_to: impl_def_id, is_trait_impl: true, .. }) => {\n                 // `Self` in an impl of a trait -- we have a concrete self type and a\n                 // trait reference.\n-                let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) else {\n+                let Some(trait_ref) = tcx.bound_impl_trait_ref(impl_def_id) else {\n                     // A cycle error occurred, most likely.\n                     let guar = tcx.sess.delay_span_bug(span, \"expected cycle error\");\n                     return Err(guar);\n                 };\n \n                 self.one_bound_for_assoc_type(\n-                    || traits::supertraits(tcx, ty::Binder::dummy(trait_ref)),\n+                    || traits::supertraits(tcx, ty::Binder::dummy(trait_ref.skip_binder())),\n                     || \"Self\".to_string(),\n                     assoc_ident,\n                     span,"}, {"sha": "0042429c6c435e0b82745451f08684620adf590b", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -535,12 +535,12 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n                 return;\n             };\n             debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.owner_id);\n-            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.owner_id) {\n+            if let Some(impl_trait_ref) = tcx.bound_impl_trait_ref(it.owner_id.to_def_id()) {\n                 check_impl_items_against_trait(\n                     tcx,\n                     it.span,\n                     it.owner_id.def_id,\n-                    impl_trait_ref,\n+                    impl_trait_ref.skip_binder(),\n                     &impl_.items,\n                 );\n                 check_on_unimplemented(tcx, it);"}, {"sha": "a420232ecbfd2fed12538fc9f619cd39e1f7383a", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -616,7 +616,8 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n ) -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed> {\n     let impl_m = tcx.opt_associated_item(def_id).unwrap();\n     let trait_m = tcx.opt_associated_item(impl_m.trait_item_def_id.unwrap()).unwrap();\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap();\n+    let impl_trait_ref =\n+        tcx.bound_impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap().subst_identity();\n     let param_env = tcx.param_env(def_id);\n \n     // First, check a few of the same things as `compare_impl_method`,\n@@ -1684,7 +1685,8 @@ pub(super) fn compare_impl_const_raw(\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_const_item = tcx.associated_item(impl_const_item_def);\n     let trait_const_item = tcx.associated_item(trait_const_item_def);\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_const_item.container_id(tcx)).unwrap();\n+    let impl_trait_ref =\n+        tcx.bound_impl_trait_ref(impl_const_item.container_id(tcx)).unwrap().subst_identity();\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let impl_c_span = tcx.def_span(impl_const_item_def.to_def_id());"}, {"sha": "6f85dfa4d91e62da34020d998774903d8972895f", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -181,8 +181,8 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         // for `T`\n         hir::ItemKind::Impl(ref impl_) => {\n             let is_auto = tcx\n-                .impl_trait_ref(def_id)\n-                .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n+                .bound_impl_trait_ref(def_id.into())\n+                .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.skip_binder().def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (impl_.defaultness, is_auto) {\n                 let sp = impl_.of_trait.as_ref().map_or(item.span, |t| t.path.span);\n                 let mut err =\n@@ -1253,7 +1253,8 @@ fn check_impl<'tcx>(\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n-                let trait_ref = tcx.impl_trait_ref(item.owner_id).unwrap();\n+                let trait_ref =\n+                    tcx.bound_impl_trait_ref(item.owner_id.to_def_id()).unwrap().subst_identity();\n                 let trait_ref = wfcx.normalize(\n                     ast_trait_ref.path.span,\n                     Some(WellFormedLoc::Ty(item.hir_id().expect_owner().def_id)),"}, {"sha": "28a25780f96f0779a87915636aac56e0fc0bf4ae", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -192,7 +192,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n     let source = tcx.type_of(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n     let target = {\n-        let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+        let trait_ref = tcx.bound_impl_trait_ref(impl_did.into()).unwrap().subst_identity();\n         assert_eq!(trait_ref.def_id, dispatch_from_dyn_trait);\n \n         trait_ref.substs.type_at(1)\n@@ -354,7 +354,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     });\n \n     let source = tcx.type_of(impl_did);\n-    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+    let trait_ref = tcx.bound_impl_trait_ref(impl_did.into()).unwrap().subst_identity();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\", source, target);"}, {"sha": "6bfb5a599149b80d35bc313199f16df11e409e51", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -128,7 +128,7 @@ fn coherent_trait(tcx: TyCtxt<'_>, def_id: DefId) {\n \n     let impls = tcx.hir().trait_impls(def_id);\n     for &impl_def_id in impls {\n-        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        let trait_ref = tcx.bound_impl_trait_ref(impl_def_id.into()).unwrap().subst_identity();\n \n         check_impl(tcx, impl_def_id, trait_ref);\n         check_object_overlap(tcx, impl_def_id, trait_ref);"}, {"sha": "9417901d1fdcffed5396c479017f97ac634ccb57", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -21,7 +21,7 @@ pub(crate) fn orphan_check_impl(\n     tcx: TyCtxt<'_>,\n     impl_def_id: LocalDefId,\n ) -> Result<(), ErrorGuaranteed> {\n-    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+    let trait_ref = tcx.bound_impl_trait_ref(impl_def_id.into()).unwrap().skip_binder();\n     trait_ref.error_reported()?;\n \n     let ret = do_orphan_check_impl(tcx, trait_ref, impl_def_id);"}, {"sha": "8db68067c69cb9753c33b00ffe5218c56bb433b7", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -13,7 +13,9 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let item = tcx.hir().expect_item(def_id);\n     let hir::ItemKind::Impl(ref impl_) = item.kind else { bug!() };\n \n-    if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n+    if let Some(trait_ref) =\n+        tcx.bound_impl_trait_ref(item.owner_id.to_def_id()).map(|t| t.subst_identity())\n+    {\n         let trait_def = tcx.trait_def(trait_ref.def_id);\n         let unsafe_attr =\n             impl_.generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\");"}, {"sha": "a44d9a6bddde2c638d0ca804da79c9119d31a914", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -87,7 +87,9 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         Node::Item(item) => match item.kind {\n             ItemKind::Impl(ref impl_) => {\n                 if impl_.defaultness.is_default() {\n-                    is_default_impl_trait = tcx.impl_trait_ref(def_id).map(ty::Binder::dummy);\n+                    is_default_impl_trait = tcx\n+                        .bound_impl_trait_ref(def_id)\n+                        .map(|t| ty::Binder::dummy(t.subst_identity()));\n                 }\n                 &impl_.generics\n             }\n@@ -251,7 +253,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     // for details.\n     if let Node::Item(&Item { kind: ItemKind::Impl { .. }, .. }) = node {\n         let self_ty = tcx.type_of(def_id);\n-        let trait_ref = tcx.impl_trait_ref(def_id);\n+        let trait_ref = tcx.bound_impl_trait_ref(def_id).map(ty::EarlyBinder::subst_identity);\n         cgp::setup_constraining_predicates(\n             tcx,\n             &mut predicates,"}, {"sha": "f845fa2ca5f09a45d51fc43ac75d44e93f2fd469", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -286,7 +286,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 }\n             }\n             ImplItemKind::Type(ty) => {\n-                if tcx.impl_trait_ref(tcx.hir().get_parent_item(hir_id)).is_none() {\n+                if tcx.bound_impl_trait_ref(tcx.hir().get_parent_item(hir_id).to_def_id()).is_none() {\n                     check_feature_inherent_assoc_ty(tcx, item.span);\n                 }\n "}, {"sha": "208f146ebbf610bbe94b7d7dd518dd9b4ed0dbab", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -85,7 +85,8 @@ fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n     }\n     let impl_generics = tcx.generics_of(impl_def_id);\n     let impl_predicates = tcx.predicates_of(impl_def_id);\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+    let impl_trait_ref =\n+        tcx.bound_impl_trait_ref(impl_def_id.into()).map(ty::EarlyBinder::subst_identity);\n \n     let mut input_parameters = cgp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n     cgp::identify_constrained_generic_params("}, {"sha": "ab40fa57acf383850a9b86f091f16796ba89ab49", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -89,8 +89,8 @@ pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n }\n \n fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId) -> Option<Node> {\n-    let trait_ref = tcx.impl_trait_ref(impl1_def_id)?;\n-    let trait_def = tcx.trait_def(trait_ref.def_id);\n+    let trait_ref = tcx.bound_impl_trait_ref(impl1_def_id.into())?;\n+    let trait_def = tcx.trait_def(trait_ref.skip_binder().def_id);\n \n     let impl2_node = trait_def.ancestors(tcx, impl1_def_id.to_def_id()).ok()?.nth(1)?;\n \n@@ -207,7 +207,7 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     let impl_generic_predicates = tcx.predicates_of(impl_def_id);\n     let mut unconstrained_parameters = FxHashSet::default();\n     let mut constrained_params = FxHashSet::default();\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+    let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).map(ty::EarlyBinder::subst_identity);\n \n     // Unfortunately the functions in `constrained_generic_parameters` don't do\n     // what we want here. We want only a list of constrained parameters while\n@@ -370,7 +370,7 @@ fn check_predicates<'tcx>(\n     });\n \n     // Include the well-formed predicates of the type parameters of the impl.\n-    for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().substs {\n+    for arg in tcx.bound_impl_trait_ref(impl1_def_id.into()).unwrap().subst_identity().substs {\n         let infcx = &tcx.infer_ctxt().build();\n         let obligations = wf::obligations(\n             infcx,"}, {"sha": "1a5a2ec7823b260227207bc0fc9cbede0edbf40c", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -240,7 +240,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             probe::InherentImplPick => {\n                 let impl_def_id = pick.item.container_id(self.tcx);\n                 assert!(\n-                    self.tcx.impl_trait_ref(impl_def_id).is_none(),\n+                    self.tcx.bound_impl_trait_ref(impl_def_id).is_none(),\n                     \"impl {:?} is not an inherent impl\",\n                     impl_def_id\n                 );"}, {"sha": "109ceb8956b41d0553301fd5b83ebf31a7d75916", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -1036,8 +1036,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // Provide the best span we can. Use the item, if local to crate, else\n                     // the impl, if local to crate (item may be defaulted), else nothing.\n                     let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n-                        let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n-                        self.associated_value(impl_trait_ref.def_id, item_name)\n+                        let impl_trait_ref = self.tcx.bound_impl_trait_ref(impl_did)?;\n+                        self.associated_value(impl_trait_ref.skip_binder().def_id, item_name)\n                     }) else {\n                         continue;\n                     };\n@@ -1052,10 +1052,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     let impl_ty = self.tcx.at(span).type_of(impl_did);\n \n-                    let insertion = match self.tcx.impl_trait_ref(impl_did) {\n+                    let insertion = match self.tcx.bound_impl_trait_ref(impl_did) {\n                         None => String::new(),\n                         Some(trait_ref) => {\n-                            format!(\" of the trait `{}`\", self.tcx.def_path_str(trait_ref.def_id))\n+                            format!(\n+                                \" of the trait `{}`\",\n+                                self.tcx.def_path_str(trait_ref.skip_binder().def_id)\n+                            )\n                         }\n                     };\n \n@@ -1085,8 +1088,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err.note(&note_str);\n                     }\n                     if let Some(sugg_span) = sugg_span\n-                        && let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n-                        let path = self.tcx.def_path_str(trait_ref.def_id);\n+                        && let Some(trait_ref) = self.tcx.bound_impl_trait_ref(impl_did) {\n+                        let path = self.tcx.def_path_str(trait_ref.skip_binder().def_id);\n \n                         let ty = match item.kind {\n                             ty::AssocKind::Const | ty::AssocKind::Type => rcvr_ty,\n@@ -2581,7 +2584,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.tcx.impl_polarity(*imp_did) == ty::ImplPolarity::Negative\n                         })\n                         .any(|imp_did| {\n-                            let imp = self.tcx.impl_trait_ref(imp_did).unwrap();\n+                            let imp =\n+                                self.tcx.bound_impl_trait_ref(imp_did).unwrap().subst_identity();\n                             let imp_simp =\n                                 simplify_type(self.tcx, imp.self_ty(), TreatParams::AsPlaceholder);\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)"}, {"sha": "2670eb0d1455df853caafd26dfc3038125b3f546", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -317,9 +317,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             self.tcx.associated_item(impl_item_def_id).impl_container(self.tcx) else { return; };\n         let Some(trait_ref) = self\n             .tcx\n-            .impl_trait_ref(impl_def_id)\n+            .bound_impl_trait_ref(impl_def_id)\n             else { return; };\n         let trait_substs = trait_ref\n+            .subst_identity()\n             // Replace the explicit self type with `Self` for better suggestion rendering\n             .with_self_ty(self.tcx, self.tcx.mk_ty_param(0, kw::SelfUpper))\n             .substs;"}, {"sha": "18a040ab8b187fd2571570e1010784004a5964c9", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -26,7 +26,7 @@ pub fn method_context(cx: &LateContext<'_>, id: hir::HirId) -> MethodLateContext\n     let item = cx.tcx.associated_item(def_id);\n     match item.container {\n         ty::TraitContainer => MethodLateContext::TraitAutoImpl,\n-        ty::ImplContainer => match cx.tcx.impl_trait_ref(item.container_id(cx.tcx)) {\n+        ty::ImplContainer => match cx.tcx.bound_impl_trait_ref(item.container_id(cx.tcx)) {\n             Some(_) => MethodLateContext::TraitImpl,\n             None => MethodLateContext::PlainImpl,\n         },"}, {"sha": "212b8aa1574df22b1347c8432301d1a2153ba3b1", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> LateLintPass<'tcx> for PassByValue {\n         match &ty.kind {\n             TyKind::Ref(_, hir::MutTy { ty: inner_ty, mutbl: hir::Mutability::Not }) => {\n                 if let Some(impl_did) = cx.tcx.impl_of_method(ty.hir_id.owner.to_def_id()) {\n-                    if cx.tcx.impl_trait_ref(impl_did).is_some() {\n+                    if cx.tcx.bound_impl_trait_ref(impl_did).is_some() {\n                         return;\n                     }\n                 }"}, {"sha": "3504a3bde4507bef228d0381219f3dd1e0ed09e4", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -1555,7 +1555,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.tables.impl_defaultness.set(def_id.index, *defaultness);\n                 self.tables.constness.set(def_id.index, *constness);\n \n-                let trait_ref = self.tcx.impl_trait_ref(def_id);\n+                let trait_ref =\n+                    self.tcx.bound_impl_trait_ref(def_id).map(ty::EarlyBinder::skip_binder);\n                 if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n@@ -1632,7 +1633,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n         }\n         if let hir::ItemKind::Impl { .. } = item.kind {\n-            if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n+            if let Some(trait_ref) =\n+                self.tcx.bound_impl_trait_ref(def_id).map(ty::EarlyBinder::subst_identity)\n+            {\n                 record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n             }\n         }\n@@ -1898,7 +1901,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         for id in tcx.hir().items() {\n             if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n-                if let Some(trait_ref) = tcx.impl_trait_ref(id.owner_id) {\n+                if let Some(trait_ref) = tcx\n+                    .bound_impl_trait_ref(id.owner_id.to_def_id())\n+                    .map(ty::EarlyBinder::subst_identity)\n+                {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),"}, {"sha": "e43e584b0b0d4e862090a66bf3caa1c6cc881501", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -101,7 +101,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn impl_subject(self, def_id: DefId) -> ImplSubject<'tcx> {\n-        self.impl_trait_ref(def_id)\n+        self.bound_impl_trait_ref(def_id)\n+            .map(|t| t.subst_identity())\n             .map(ImplSubject::Trait)\n             .unwrap_or_else(|| ImplSubject::Inherent(self.type_of(def_id)))\n     }"}, {"sha": "6270c2ebb28fb2871492ee35e4dce3afc2968437", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -1027,7 +1027,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Checks if the bound region is in Impl Item.\n     pub fn is_bound_region_in_impl_item(self, suitable_region_binding_scope: LocalDefId) -> bool {\n         let container_id = self.parent(suitable_region_binding_scope.to_def_id());\n-        if self.impl_trait_ref(container_id).is_some() {\n+        if self.bound_impl_trait_ref(container_id).is_some() {\n             // For now, we do not try to target impls of traits. This is\n             // because this message is going to suggest that the user\n             // change the fn signature, but they may not be free to do so,"}, {"sha": "ac762b9dfb27b56b7dea12728972478c0f4ddad8", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -2187,8 +2187,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> Option<ImplOverlapKind> {\n         // If either trait impl references an error, they're allowed to overlap,\n         // as one of them essentially doesn't exist.\n-        if self.impl_trait_ref(def_id1).map_or(false, |tr| tr.references_error())\n-            || self.impl_trait_ref(def_id2).map_or(false, |tr| tr.references_error())\n+        if self\n+            .bound_impl_trait_ref(def_id1)\n+            .map_or(false, |tr| tr.skip_binder().references_error())\n+            || self\n+                .bound_impl_trait_ref(def_id2)\n+                .map_or(false, |tr| tr.skip_binder().references_error())\n         {\n             return Some(ImplOverlapKind::Permitted { marker: false });\n         }\n@@ -2217,8 +2221,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let is_marker_overlap = {\n             let is_marker_impl = |def_id: DefId| -> bool {\n-                let trait_ref = self.impl_trait_ref(def_id);\n-                trait_ref.map_or(false, |tr| self.trait_def(tr.def_id).is_marker)\n+                let trait_ref = self.bound_impl_trait_ref(def_id);\n+                trait_ref.map_or(false, |tr| self.trait_def(tr.skip_binder().def_id).is_marker)\n             };\n             is_marker_impl(def_id1) && is_marker_impl(def_id2)\n         };\n@@ -2364,7 +2368,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Given the `DefId` of an impl, returns the `DefId` of the trait it implements.\n     /// If it implements no trait, returns `None`.\n     pub fn trait_id_of_impl(self, def_id: DefId) -> Option<DefId> {\n-        self.impl_trait_ref(def_id).map(|tr| tr.def_id)\n+        self.bound_impl_trait_ref(def_id).map(|tr| tr.skip_binder().def_id)\n     }\n \n     /// If the given `DefId` describes an item belonging to a trait,"}, {"sha": "070947410f38be76af6607a1197325adea8f9580", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -1351,7 +1351,10 @@ fn create_mono_items_for_default_impls<'tcx>(\n                 tcx.def_path_str(item.owner_id.to_def_id())\n             );\n \n-            if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n+            if let Some(trait_ref) = tcx\n+                .bound_impl_trait_ref(item.owner_id.to_def_id())\n+                .map(ty::EarlyBinder::subst_identity)\n+            {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n                 let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);"}, {"sha": "88ad7b28f544e3b1a83e4e98423ff955bdd18465", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -266,7 +266,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n             if let Some(trait_of) = self.tcx.trait_id_of_impl(impl_of)\n                 && self.tcx.has_attr(trait_of, sym::rustc_trivial_field_reads)\n             {\n-                let trait_ref = self.tcx.impl_trait_ref(impl_of).unwrap();\n+                let trait_ref = self.tcx.bound_impl_trait_ref(impl_of).unwrap().subst_identity();\n                 if let ty::Adt(adt_def, _) = trait_ref.self_ty().kind()\n                     && let Some(adt_def_id) = adt_def.did().as_local()\n                 {\n@@ -310,7 +310,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n             }\n             Node::ImplItem(impl_item) => {\n                 let item = self.tcx.local_parent(impl_item.owner_id.def_id);\n-                if self.tcx.impl_trait_ref(item).is_none() {\n+                if self.tcx.bound_impl_trait_ref(item.into()).is_none() {\n                     //// If it's a type whose items are live, then it's live, too.\n                     //// This is done to handle the case where, for example, the static\n                     //// method of a private type is used, but the type itself is never\n@@ -534,7 +534,7 @@ fn check_item<'tcx>(\n             }\n         }\n         DefKind::Impl => {\n-            let of_trait = tcx.impl_trait_ref(id.owner_id);\n+            let of_trait = tcx.bound_impl_trait_ref(id.owner_id.to_def_id());\n \n             if of_trait.is_some() {\n                 worklist.push(id.owner_id.def_id);"}, {"sha": "3ecc9faf76620b13f0c960675de97e49d5c7903a", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -593,7 +593,7 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let impl_def_id = self.tcx.hir().get_parent_item(ii.hir_id());\n-        if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n+        if self.tcx.bound_impl_trait_ref(impl_def_id.to_def_id()).is_none() {\n             self.check_missing_stability(ii.owner_id.def_id, ii.span);\n             self.check_missing_const_stability(ii.owner_id.def_id, ii.span);\n         }"}, {"sha": "69bfa8e2709aff3ecdb4378f2795448d131b6c0c", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -337,8 +337,8 @@ trait VisibilityLike: Sized {\n     ) -> Self {\n         let mut find = FindMin { tcx, effective_visibilities, min: Self::MAX };\n         find.visit(tcx.type_of(def_id));\n-        if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n-            find.visit_trait(trait_ref);\n+        if let Some(trait_ref) = tcx.bound_impl_trait_ref(def_id.into()) {\n+            find.visit_trait(trait_ref.subst_identity());\n         }\n         find.min\n     }\n@@ -857,8 +857,8 @@ impl ReachEverythingInTheInterfaceVisitor<'_, '_> {\n     }\n \n     fn trait_ref(&mut self) -> &mut Self {\n-        if let Some(trait_ref) = self.ev.tcx.impl_trait_ref(self.item_def_id) {\n-            self.visit_trait(trait_ref);\n+        if let Some(trait_ref) = self.ev.tcx.bound_impl_trait_ref(self.item_def_id.into()) {\n+            self.visit_trait(trait_ref.subst_identity());\n         }\n         self\n     }"}, {"sha": "623ef7964bf0dad1114e2c1d862608cbdb70441b", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -77,8 +77,8 @@ pub fn overlapping_impls(\n     // a quick check via fast_reject to tell if the impl headers could possibly\n     // unify.\n     let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n-    let impl1_ref = tcx.impl_trait_ref(impl1_def_id);\n-    let impl2_ref = tcx.impl_trait_ref(impl2_def_id);\n+    let impl1_ref = tcx.bound_impl_trait_ref(impl1_def_id).map(ty::EarlyBinder::subst_identity);\n+    let impl2_ref = tcx.bound_impl_trait_ref(impl2_def_id).map(ty::EarlyBinder::subst_identity);\n     let may_overlap = match (impl1_ref, impl2_ref) {\n         (Some(a), Some(b)) => iter::zip(a.substs, b.substs)\n             .all(|(arg1, arg2)| drcx.generic_args_may_unify(arg1, arg2)),\n@@ -461,7 +461,7 @@ pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanChe\n \n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n-    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+    let trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap().skip_binder();\n     debug!(\"orphan_check: trait_ref={:?}\", trait_ref);\n \n     // If the *trait* is local to the crate, ok."}, {"sha": "8b9c6821dafec50b9818c13a0820dd8ccf2b58b3", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -1940,7 +1940,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     return None;\n                 }\n \n-                let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                let imp = self.tcx.bound_impl_trait_ref(def_id).unwrap().subst_identity();\n \n                 self.fuzzy_match_tys(trait_pred.skip_binder().self_ty(), imp.self_ty(), false)\n                     .map(|similarity| ImplCandidate { trait_ref: imp, similarity })\n@@ -2039,7 +2039,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     self.tcx.impl_polarity(def_id) != ty::ImplPolarity::Negative\n                         || self.tcx.is_builtin_derive(def_id)\n                 })\n-                .filter_map(|def_id| self.tcx.impl_trait_ref(def_id))\n+                .filter_map(|def_id| self.tcx.bound_impl_trait_ref(def_id))\n+                .map(ty::EarlyBinder::subst_identity)\n                 .filter(|trait_ref| {\n                     let self_ty = trait_ref.self_ty();\n                     // Avoid mentioning type parameters."}, {"sha": "4c34dc64c26cc8b1304c1ddbd393b43f407d85eb", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -521,8 +521,10 @@ fn is_impossible_method(tcx: TyCtxt<'_>, (impl_def_id, trait_item_def_id): (DefI\n \n     let generics = tcx.generics_of(trait_item_def_id);\n     let predicates = tcx.predicates_of(trait_item_def_id);\n-    let impl_trait_ref =\n-        tcx.impl_trait_ref(impl_def_id).expect(\"expected impl to correspond to trait\");\n+    let impl_trait_ref = tcx\n+        .bound_impl_trait_ref(impl_def_id)\n+        .expect(\"expected impl to correspond to trait\")\n+        .subst_identity();\n     let param_env = tcx.param_env(impl_def_id);\n \n     let mut visitor = ReferencesOnlyParentGenerics { tcx, generics, trait_item_def_id };"}, {"sha": "a352a65fb068faa94692d4826fe2a15613ef53b3", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -148,7 +148,7 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n \n     // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n     let penv = tcx.param_env(impl1_def_id);\n-    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n+    let impl1_trait_ref = tcx.bound_impl_trait_ref(impl1_def_id).unwrap().subst_identity();\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n     let infcx = tcx.infer_ctxt().build();\n@@ -431,7 +431,7 @@ fn report_conflicting_impls<'tcx>(\n pub(crate) fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String> {\n     use std::fmt::Write;\n \n-    let trait_ref = tcx.impl_trait_ref(impl_def_id)?;\n+    let trait_ref = tcx.bound_impl_trait_ref(impl_def_id)?.skip_binder();\n     let mut w = \"impl\".to_owned();\n \n     let substs = InternalSubsts::identity_for_item(tcx, impl_def_id);"}, {"sha": "a2e39c53d15c86ec96435c199b53d1a94304ef09", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -48,7 +48,7 @@ trait ChildrenExt<'tcx> {\n impl<'tcx> ChildrenExt<'tcx> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n-        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        let trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap().subst_identity();\n         if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n         {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n@@ -63,7 +63,7 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     /// an impl with a parent. The impl must be present in the list of\n     /// children already.\n     fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n-        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        let trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap().subst_identity();\n         let vec: &mut Vec<DefId>;\n         if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n         {\n@@ -181,15 +181,15 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n             if le && !ge {\n                 debug!(\n                     \"descending as child of TraitRef {:?}\",\n-                    tcx.impl_trait_ref(possible_sibling).unwrap()\n+                    tcx.bound_impl_trait_ref(possible_sibling).unwrap().subst_identity()\n                 );\n \n                 // The impl specializes `possible_sibling`.\n                 return Ok(Inserted::ShouldRecurseOn(possible_sibling));\n             } else if ge && !le {\n                 debug!(\n                     \"placing as parent of TraitRef {:?}\",\n-                    tcx.impl_trait_ref(possible_sibling).unwrap()\n+                    tcx.bound_impl_trait_ref(possible_sibling).unwrap().subst_identity()\n                 );\n \n                 replace_children.push(possible_sibling);\n@@ -275,7 +275,7 @@ impl<'tcx> GraphExt<'tcx> for Graph {\n     ) -> Result<Option<FutureCompatOverlapError<'tcx>>, OverlapError<'tcx>> {\n         assert!(impl_def_id.is_local());\n \n-        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        let trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap().subst_identity();\n         let trait_def_id = trait_ref.def_id;\n \n         debug!(\n@@ -388,7 +388,7 @@ pub(crate) fn assoc_def(\n     impl_def_id: DefId,\n     assoc_def_id: DefId,\n ) -> Result<LeafDef, ErrorGuaranteed> {\n-    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n+    let trait_def_id = tcx.bound_impl_trait_ref(impl_def_id).unwrap().skip_binder().def_id;\n     let trait_def = tcx.trait_def(trait_def_id);\n \n     // This function may be called while we are still building the"}, {"sha": "dea33f896cf17523068cad2b1cfe2fa1222ac715", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -380,7 +380,8 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let trait_def_id = auto_trait_id.0;\n         let all_impls = self.interner.tcx.all_impls(trait_def_id);\n         for impl_def_id in all_impls {\n-            let trait_ref = self.interner.tcx.impl_trait_ref(impl_def_id).unwrap();\n+            let trait_ref =\n+                self.interner.tcx.bound_impl_trait_ref(impl_def_id).unwrap().subst_identity();\n             let self_ty = trait_ref.self_ty();\n             let provides = match (self_ty.kind(), chalk_ty) {\n                 (&ty::Adt(impl_adt_def, ..), Adt(id, ..)) => impl_adt_def.did() == id.0.did(),"}, {"sha": "d890a04599b1caf93ce87096561a11ea5ddcdfb6", "filename": "compiler/rustc_ty_utils/src/implied_bounds.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -21,14 +21,16 @@ fn assumed_wf_types(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Ty<'_>> {\n             assumed_wf_types.extend(liberated_sig.inputs_and_output);\n             tcx.intern_type_list(&assumed_wf_types)\n         }\n-        DefKind::Impl => match tcx.impl_trait_ref(def_id) {\n-            Some(trait_ref) => {\n-                let types: Vec<_> = trait_ref.substs.types().collect();\n-                tcx.intern_type_list(&types)\n+        DefKind::Impl => {\n+            match tcx.bound_impl_trait_ref(def_id).map(ty::EarlyBinder::subst_identity) {\n+                Some(trait_ref) => {\n+                    let types: Vec<_> = trait_ref.substs.types().collect();\n+                    tcx.intern_type_list(&types)\n+                }\n+                // Only the impl self type\n+                None => tcx.intern_type_list(&[tcx.type_of(def_id)]),\n             }\n-            // Only the impl self type\n-            None => tcx.intern_type_list(&[tcx.type_of(def_id)]),\n-        },\n+        }\n         DefKind::AssocConst | DefKind::AssocTy => tcx.assumed_wf_types(tcx.parent(def_id)),\n         DefKind::Mod\n         | DefKind::Struct"}, {"sha": "78c3a208e889fa0624cc1c042cb72ee7d1770c7d", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -289,7 +289,7 @@ fn well_formed_types_in_env(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Predica\n         // In a trait impl, we assume that the header trait ref and all its\n         // constituents are well-formed.\n         NodeKind::TraitImpl => {\n-            let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+            let trait_ref = tcx.bound_impl_trait_ref(def_id).expect(\"not an impl\").subst_identity();\n \n             // FIXME(chalk): this has problems because of late-bound regions\n             //inputs.extend(trait_ref.substs.iter().flat_map(|arg| arg.walk()));\n@@ -359,8 +359,9 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n     debug!(\"issue33140_self_ty({:?})\", def_id);\n \n     let trait_ref = tcx\n-        .impl_trait_ref(def_id)\n-        .unwrap_or_else(|| bug!(\"issue33140_self_ty called on inherent impl {:?}\", def_id));\n+        .bound_impl_trait_ref(def_id)\n+        .unwrap_or_else(|| bug!(\"issue33140_self_ty called on inherent impl {:?}\", def_id))\n+        .skip_binder();\n \n     debug!(\"issue33140_self_ty({:?}), trait-ref={:?}\", def_id, trait_ref);\n "}, {"sha": "23330daa54bf0a6f78d4ceb5fe368072d5dd1bab", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -376,7 +376,7 @@ pub(crate) fn build_impl(\n     let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_impl\");\n \n     let tcx = cx.tcx;\n-    let associated_trait = tcx.impl_trait_ref(did);\n+    let associated_trait = tcx.bound_impl_trait_ref(did).map(ty::EarlyBinder::skip_binder);\n \n     // Only inline impl if the implemented trait is\n     // reachable in rustdoc generated documentation"}, {"sha": "cda90955ba1169012f66d73555438c7e61616eb2", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -734,7 +734,7 @@ impl Item {\n                     ty::ImplContainer => {\n                         // Trait impl items always inherit the impl's visibility --\n                         // we don't want to show `pub`.\n-                        tcx.impl_trait_ref(tcx.parent(assoc_item.def_id)).is_some()\n+                        tcx.bound_impl_trait_ref(tcx.parent(assoc_item.def_id)).is_some()\n                     }\n                 };\n                 if is_trait_item {"}, {"sha": "fa9174287e2725d5135bf1294305d8958d3ca2e1", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -784,9 +784,9 @@ fn trait_impls_for<'a>(\n \n         // Look at each trait implementation to see if it's an impl for `did`\n         tcx.find_map_relevant_impl(trait_, ty, |impl_| {\n-            let trait_ref = tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n+            let trait_ref = tcx.bound_impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n-            let impl_type = trait_ref.self_ty();\n+            let impl_type = trait_ref.subst_identity().self_ty();\n             trace!(\n                 \"comparing type {} with kind {:?} against type {:?}\",\n                 impl_type,"}, {"sha": "6b2b18fff76e0564f79c340842c6dac7b995ddbf", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -247,11 +247,11 @@ fn check_hash_peq<'tcx>(\n                     return;\n                 }\n \n-                let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n+                let trait_ref = cx.tcx.bound_impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n \n                 // Only care about `impl PartialEq<Foo> for Foo`\n                 // For `impl PartialEq<B> for A, input_types is [A, B]\n-                if trait_ref.substs.type_at(1) == ty {\n+                if trait_ref.subst_identity().substs.type_at(1) == ty {\n                     span_lint_and_then(\n                         cx,\n                         DERIVED_HASH_WITH_MANUAL_EQ,\n@@ -295,11 +295,11 @@ fn check_ord_partial_ord<'tcx>(\n                     return;\n                 }\n \n-                let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n+                let trait_ref = cx.tcx.bound_impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n \n                 // Only care about `impl PartialOrd<Foo> for Foo`\n                 // For `impl PartialOrd<B> for A, input_types is [A, B]\n-                if trait_ref.substs.type_at(1) == ty {\n+                if trait_ref.subst_identity().substs.type_at(1) == ty {\n                     let mess = if partial_ord_is_automatically_derived {\n                         \"you are implementing `Ord` explicitly but have derived `PartialOrd`\"\n                     } else {"}, {"sha": "a8085122ccf95cdbe990f7f862b566ba14668b17", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -55,8 +55,8 @@ impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n         // check for `impl From<???> for ..`\n         if_chain! {\n             if let hir::ItemKind::Impl(impl_) = &item.kind;\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id);\n-            if cx.tcx.is_diagnostic_item(sym::From, impl_trait_ref.def_id);\n+            if let Some(impl_trait_ref) = cx.tcx.bound_impl_trait_ref(item.owner_id.to_def_id());\n+            if cx.tcx.is_diagnostic_item(sym::From, impl_trait_ref.skip_binder().def_id);\n             then {\n                 lint_impl_body(cx, item.span, impl_.items);\n             }"}, {"sha": "97d414bfa95e434bc4fa77408a1ee829e2c15294", "filename": "src/tools/clippy/clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for FromOverInto {\n             && let Some(into_trait_seg) = hir_trait_ref.path.segments.last()\n             // `impl Into<target_ty> for self_ty`\n             && let Some(GenericArgs { args: [GenericArg::Type(target_ty)], .. }) = into_trait_seg.args\n-            && let Some(middle_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id)\n+            && let Some(middle_trait_ref) = cx.tcx.bound_impl_trait_ref(item.owner_id.to_def_id()).map(ty::EarlyBinder::subst_identity)\n             && cx.tcx.is_diagnostic_item(sym::Into, middle_trait_ref.def_id)\n             && !matches!(middle_trait_ref.substs.type_at(1).kind(), ty::Alias(ty::Opaque, _))\n         {"}, {"sha": "37e33529a9a60ca1d9bf8192511630ec355059a9", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -101,7 +101,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             if name.ident.as_str() == \"MIN\";\n                             if let Some(const_id) = cx.typeck_results().type_dependent_def_id(cond_num_val.hir_id);\n                             if let Some(impl_id) = cx.tcx.impl_of_method(const_id);\n-                            if let None = cx.tcx.impl_trait_ref(impl_id); // An inherent impl\n+                            if let None = cx.tcx.bound_impl_trait_ref(impl_id); // An inherent impl\n                             if cx.tcx.type_of(impl_id).is_integral();\n                             then {\n                                 print_lint_and_sugg(cx, var_name, expr)\n@@ -114,7 +114,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             if name.ident.as_str() == \"min_value\";\n                             if let Some(func_id) = cx.typeck_results().type_dependent_def_id(func.hir_id);\n                             if let Some(impl_id) = cx.tcx.impl_of_method(func_id);\n-                            if let None = cx.tcx.impl_trait_ref(impl_id); // An inherent impl\n+                            if let None = cx.tcx.bound_impl_trait_ref(impl_id); // An inherent impl\n                             if cx.tcx.type_of(impl_id).is_integral();\n                             then {\n                                 print_lint_and_sugg(cx, var_name, expr)"}, {"sha": "16a25a98800de191643fcbf674c4da0273db7056", "filename": "src/tools/clippy/clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -53,7 +53,7 @@ pub fn is_clone_like(cx: &LateContext<'_>, method_name: &str, method_def_id: hir\n         \"to_vec\" => cx\n             .tcx\n             .impl_of_method(method_def_id)\n-            .filter(|&impl_did| cx.tcx.type_of(impl_did).is_slice() && cx.tcx.impl_trait_ref(impl_did).is_none())\n+            .filter(|&impl_did| cx.tcx.type_of(impl_did).is_slice() && cx.tcx.bound_impl_trait_ref(impl_did).is_none())\n             .is_some(),\n         _ => false,\n     }"}, {"sha": "dba0663467b7d28e83fa2a66e87ce0df9f4edbc8", "filename": "src/tools/clippy/clippy_lints/src/methods/suspicious_splitn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -12,7 +12,7 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n         if count <= 1;\n         if let Some(call_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(call_id);\n-        if cx.tcx.impl_trait_ref(impl_id).is_none();\n+        if cx.tcx.bound_impl_trait_ref(impl_id).is_none();\n         let self_ty = cx.tcx.type_of(impl_id);\n         if self_ty.is_slice() || self_ty.is_str();\n         then {"}, {"sha": "d0c99b352452faa413e18c131d8e4f325add219b", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -175,7 +175,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n         // If the method is an impl for a trait, don't doc.\n         if let Some(cid) = cx.tcx.associated_item(impl_item.owner_id).impl_container(cx.tcx) {\n-            if cx.tcx.impl_trait_ref(cid).is_some() {\n+            if cx.tcx.bound_impl_trait_ref(cid).is_some() {\n                 return;\n             }\n         } else {"}, {"sha": "0594fb175458d41d3a88874eca41075e868dff3f", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -155,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         let container_id = assoc_item.container_id(cx.tcx);\n         let trait_def_id = match assoc_item.container {\n             TraitContainer => Some(container_id),\n-            ImplContainer => cx.tcx.impl_trait_ref(container_id).map(|t| t.def_id),\n+            ImplContainer => cx.tcx.bound_impl_trait_ref(container_id).map(|t| t.skip_binder().def_id),\n         };\n \n         if let Some(trait_def_id) = trait_def_id {"}, {"sha": "9c112ade948ff9a40dcca33005cd53d5222108b0", "filename": "src/tools/clippy/clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -89,8 +89,8 @@ impl<'tcx> LateLintPass<'tcx> for NonSendFieldInSendTy {\n             if let Some(trait_id) = trait_ref.trait_def_id();\n             if send_trait == trait_id;\n             if hir_impl.polarity == ImplPolarity::Positive;\n-            if let Some(ty_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id);\n-            if let self_ty = ty_trait_ref.self_ty();\n+            if let Some(ty_trait_ref) = cx.tcx.bound_impl_trait_ref(item.owner_id.to_def_id());\n+            if let self_ty = ty_trait_ref.subst_identity().self_ty();\n             if let ty::Adt(adt_def, impl_trait_substs) = self_ty.kind();\n             then {\n                 let mut non_send_fields = Vec::new();"}, {"sha": "82b1716a216e6c4b3f34268a109cd69b48f6c923", "filename": "src/tools/clippy/clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -244,7 +244,7 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n             })) => {\n                 #[allow(trivial_casts)]\n                 if let Some(Node::Item(item)) = get_parent_node(cx.tcx, owner_id.into())\n-                    && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.owner_id)\n+                    && let Some(trait_ref) = cx.tcx.bound_impl_trait_ref(item.owner_id.to_def_id()).map(|t| t.subst_identity())\n                     && let Some(trait_item_id) = cx.tcx.associated_item(owner_id).trait_item_def_id\n                 {\n                     ("}, {"sha": "9f31a13aa984bed491ac0cb08312a81b50789aad", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be130b57d477069799158506d7e80145fdf71c73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=be130b57d477069799158506d7e80145fdf71c73", "patch": "@@ -133,11 +133,11 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 ref mut types_to_skip,\n                 ..\n             }) = self.stack.last_mut();\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_id);\n+            if let Some(impl_trait_ref) = cx.tcx.bound_impl_trait_ref(impl_id.to_def_id());\n             then {\n                 // `self_ty` is the semantic self type of `impl <trait> for <type>`. This cannot be\n                 // `Self`.\n-                let self_ty = impl_trait_ref.self_ty();\n+                let self_ty = impl_trait_ref.subst_identity().self_ty();\n \n                 // `trait_method_sig` is the signature of the function, how it is declared in the\n                 // trait, not in the impl of the trait."}]}