{"sha": "aa66b91767ce92c45192ca11718575529d631d21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNjZiOTE3NjdjZTkyYzQ1MTkyY2ExMTcxODU3NTUyOWQ2MzFkMjE=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2013-12-23T14:08:23Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2014-01-21T23:48:46Z"}, "message": "[std::vec] Rename .last_opt() to .last(), drop the old .last() behavior", "tree": {"sha": "b2d27a96f00a2802fdb8db2da3fda830fbfeac30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2d27a96f00a2802fdb8db2da3fda830fbfeac30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa66b91767ce92c45192ca11718575529d631d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa66b91767ce92c45192ca11718575529d631d21", "html_url": "https://github.com/rust-lang/rust/commit/aa66b91767ce92c45192ca11718575529d631d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa66b91767ce92c45192ca11718575529d631d21/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "add8f9680e2214c0e44978f1c24a62bd342d9a18", "url": "https://api.github.com/repos/rust-lang/rust/commits/add8f9680e2214c0e44978f1c24a62bd342d9a18", "html_url": "https://github.com/rust-lang/rust/commit/add8f9680e2214c0e44978f1c24a62bd342d9a18"}], "stats": {"total": 201, "additions": 89, "deletions": 112}, "files": [{"sha": "8729cf1b68553ece9aee7b3bc46b0eb8443a1d22", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -385,7 +385,7 @@ impl Integer for BigUint {\n         }\n \n         let mut shift = 0;\n-        let mut n = *other.data.last();\n+        let mut n = *other.data.last().unwrap();\n         while n < (1 << BigDigit::bits - 2) {\n             n <<= 1;\n             shift += 1;\n@@ -434,7 +434,7 @@ impl Integer for BigUint {\n             }\n \n             let an = a.data.slice(a.data.len() - n, a.data.len());\n-            let bn = *b.data.last();\n+            let bn = *b.data.last().unwrap();\n             let mut d = ~[];\n             let mut carry = 0;\n             for elt in an.rev_iter() {\n@@ -798,7 +798,7 @@ impl BigUint {\n     /// Determines the fewest bits necessary to express the `BigUint`.\n     pub fn bits(&self) -> uint {\n         if self.is_zero() { return 0; }\n-        let zeros = self.data.last().leading_zeros();\n+        let zeros = self.data.last().unwrap().leading_zeros();\n         return self.data.len()*BigDigit::bits - (zeros as uint);\n     }\n }"}, {"sha": "9b6d12580ecc44020953698d17a0874b04f38f95", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -234,7 +234,7 @@ mod tests {\n         sorted.sort();\n         let mut heap = PriorityQueue::from_vec(data);\n         while !heap.is_empty() {\n-            assert_eq!(heap.top(), sorted.last());\n+            assert_eq!(heap.top(), sorted.last().unwrap());\n             assert_eq!(heap.pop(), sorted.pop());\n         }\n     }"}, {"sha": "a0a9800926ebc829e018cac3a37cdad70de32c1d", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -179,17 +179,17 @@ impl Visitor<()> for Context {\n     fn visit_mac(&mut self, macro: &ast::Mac, _: ()) {\n         let ast::MacInvocTT(ref path, _, _) = macro.node;\n \n-        if path.segments.last().identifier == self.sess.ident_of(\"macro_rules\") {\n+        if path.segments.last().unwrap().identifier == self.sess.ident_of(\"macro_rules\") {\n             self.gate_feature(\"macro_rules\", path.span, \"macro definitions are \\\n                 not stable enough for use and are subject to change\");\n         }\n \n-        else if path.segments.last().identifier == self.sess.ident_of(\"asm\") {\n+        else if path.segments.last().unwrap().identifier == self.sess.ident_of(\"asm\") {\n             self.gate_feature(\"asm\", path.span, \"inline assembly is not \\\n                 stable enough for use and is subject to change\");\n         }\n \n-        else if path.segments.last().identifier == self.sess.ident_of(\"log_syntax\") {\n+        else if path.segments.last().unwrap().identifier == self.sess.ident_of(\"log_syntax\") {\n             self.gate_feature(\"log_syntax\", path.span, \"`log_syntax!` is not \\\n                 stable enough for use and is subject to change\");\n         }"}, {"sha": "14fd3799caf1b52620680fa5db37bdcc15299960", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -445,7 +445,7 @@ impl<'a> GatherLoanCtxt<'a> {\n             return;\n         }\n \n-        let root_ub = { *self.repeating_ids.last() }; // FIXME(#5074)\n+        let root_ub = { *self.repeating_ids.last().unwrap() }; // FIXME(#5074)\n \n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed."}, {"sha": "dc0b700da522a7d7b9a772e7b18622bb0e862427", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -495,7 +495,7 @@ impl CFGBuilder {\n                   label: Option<ast::Name>) -> LoopScope {\n         match label {\n             None => {\n-                return *self.loop_scopes.last();\n+                return *self.loop_scopes.last().unwrap();\n             }\n \n             Some(_) => {"}, {"sha": "e780864ffd507749df76b096ae48fa894ba0f9da", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -1077,7 +1077,7 @@ fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n     match (&p.node, def_map.get().find(&p.id)) {\n         (&ast::PatIdent(_, ref path, _), Some(&ast::DefStatic(_, false))) => {\n             // last identifier alone is right choice for this lint.\n-            let ident = path.segments.last().identifier;\n+            let ident = path.segments.last().unwrap().identifier;\n             let s = cx.tcx.sess.str_of(ident);\n             if s.chars().any(|c| c.is_lowercase()) {\n                 cx.span_lint(NonUppercasePatternStatics, path.span,"}, {"sha": "03d7c56aeb6f4bdc251811464e384ffe1f825faf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -790,7 +790,7 @@ impl Liveness {\n \n     pub fn last_loop_scope(&self) -> NodeId {\n         let loop_scope = self.loop_scope.borrow();\n-        *loop_scope.get().last()\n+        *loop_scope.get().last().unwrap()\n     }\n \n     pub fn ln_str(&self, ln: LiveNode) -> ~str {\n@@ -1593,7 +1593,7 @@ impl Liveness {\n             } else {\n                 let ends_with_stmt = match body.expr {\n                     None if body.stmts.len() > 0 =>\n-                        match body.stmts.last().node {\n+                        match body.stmts.last().unwrap().node {\n                             StmtSemi(e, _) => {\n                                 let t_stmt = ty::expr_ty(self.tcx, e);\n                                 ty::get(t_stmt).sty == ty::get(t_ret).sty\n@@ -1603,7 +1603,7 @@ impl Liveness {\n                     _ => false\n                 };\n                 if ends_with_stmt {\n-                    let last_stmt = body.stmts.last();\n+                    let last_stmt = body.stmts.last().unwrap();\n                     let span_semicolon = Span {\n                         lo: last_stmt.span.hi,\n                         hi: last_stmt.span.hi,"}, {"sha": "3d5267cd9285cce528250e63c097eb6e288cb9c9", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -595,7 +595,7 @@ impl<'a> PrivacyVisitor<'a> {\n             match *self.last_private_map.get(&path_id) {\n                 resolve::AllPublic => {},\n                 resolve::DependsOn(def) => {\n-                    let name = token::ident_to_str(&path.segments.last()\n+                    let name = token::ident_to_str(&path.segments.last().unwrap()\n                                                         .identifier);\n                     self.ensure_public(span, def, Some(origdid),\n                                        format!(\"{} `{}`\", tyname, name));"}, {"sha": "082c755b8321e37646db0aad730375388e500c7c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -1476,7 +1476,7 @@ impl Resolver {\n                     match view_path.node {\n                         ViewPathSimple(binding, ref full_path, id) => {\n                             let source_ident =\n-                                full_path.segments.last().identifier;\n+                                full_path.segments.last().unwrap().identifier;\n                             let subclass = @SingleImport(binding,\n                                                          source_ident);\n                             self.build_import_directive(module_,\n@@ -4303,7 +4303,7 @@ impl Resolver {\n \n                 // First, check to see whether the name is a primitive type.\n                 if path.segments.len() == 1 {\n-                    let id = path.segments.last().identifier;\n+                    let id = path.segments.last().unwrap().identifier;\n \n                     match self.primitive_type_table\n                             .primitive_types\n@@ -4342,7 +4342,7 @@ impl Resolver {\n                                 debug!(\"(resolving type) resolved `{}` to \\\n                                         type {:?}\",\n                                        self.session.str_of(path.segments\n-                                                               .last()\n+                                                               .last().unwrap()\n                                                                .identifier),\n                                        def);\n                                 result_def = Some(def);\n@@ -4561,7 +4561,7 @@ impl Resolver {\n                                 path.span,\n                                 format!(\"`{}` is not an enum variant or constant\",\n                                      self.session.str_of(\n-                                         path.segments.last().identifier)))\n+                                         path.segments.last().unwrap().identifier)))\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n@@ -4592,7 +4592,7 @@ impl Resolver {\n                                 format!(\"`{}` is not an enum variant, struct or const\",\n                                      self.session\n                                          .str_of(path.segments\n-                                                     .last()\n+                                                     .last().unwrap()\n                                                      .identifier)));\n                         }\n                         None => {\n@@ -4601,7 +4601,7 @@ impl Resolver {\n                                                     struct or const `{}`\",\n                                                     self.session\n                                                         .str_of(path.segments\n-                                                                    .last()\n+                                                                    .last().unwrap()\n                                                                     .identifier)));\n                         }\n                     }\n@@ -4722,7 +4722,7 @@ impl Resolver {\n \n         let unqualified_def =\n                 self.resolve_identifier(path.segments\n-                                            .last()\n+                                            .last().unwrap()\n                                             .identifier,\n                                         namespace,\n                                         check_ribs,\n@@ -4883,7 +4883,7 @@ impl Resolver {\n             }\n         }\n \n-        let ident = path.segments.last().identifier;\n+        let ident = path.segments.last().unwrap().identifier;\n         let def = match self.resolve_definition_of_name_in_module(containing_module,\n                                                         ident,\n                                                         namespace) {\n@@ -4952,7 +4952,7 @@ impl Resolver {\n             }\n         }\n \n-        let name = path.segments.last().identifier;\n+        let name = path.segments.last().unwrap().identifier;\n         match self.resolve_definition_of_name_in_module(containing_module,\n                                                         name,\n                                                         namespace) {"}, {"sha": "5bd8eb6386fcff4d055f44f7cf84c096270fa5ae", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -575,7 +575,7 @@ fn enter_default<'r,'b>(\n     // non guarded matches, and thus by exhaustiveness, we know that\n     // we don't need any default cases. If the check *isn't* nonexhaustive\n     // (because chk is Some), then we need the defaults anyways.\n-    let is_exhaustive = match matches.last_opt() {\n+    let is_exhaustive = match matches.last() {\n         Some(m) if m.data.arm.guard.is_some() && chk.is_infallible() => true,\n         _ => false\n     };\n@@ -913,7 +913,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> ~[Opt] {\n     // to not always merge conditions.\n     fn add_veclen_to_set(set: &mut ~[Opt], i: uint,\n                          len: uint, vlo: VecLenOpt) {\n-        match set.last_opt() {\n+        match set.last() {\n             // If the last condition in the list matches the one we want\n             // to add, then extend its range. Otherwise, make a new\n             // vec_len with a range just covering the new entry."}, {"sha": "c654bbbd709d9637bfba6d3533930aaf090a5846", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -2014,7 +2014,7 @@ fn exported_name(ccx: &CrateContext, path: ast_map::Path,\n \n         // Don't mangle\n         _ if attr::contains_name(attrs, \"no_mangle\")\n-            => path_elem_to_str(*path.last(), token::get_ident_interner()),\n+            => path_elem_to_str(*path.last().unwrap(), token::get_ident_interner()),\n \n         // Usual name mangling\n         _ => mangle_exported_name(ccx, path, ty)"}, {"sha": "d4b9af17845468256cfba055158e3ea8283b2a4d", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -475,7 +475,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n \n     fn top_scope<R>(&self, f: |&CleanupScope<'a>| -> R) -> R {\n         let scopes = self.scopes.borrow();\n-        f(scopes.get().last())\n+        f(scopes.get().last().unwrap())\n     }\n \n     fn trans_cleanups_to_exit_scope(&self,\n@@ -568,7 +568,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n             // and this scope is that loop, then stop popping and set\n             // `prev_llbb` to the appropriate exit block from the loop.\n             popped_scopes.push(self.pop_scope());\n-            let scope = popped_scopes.last();\n+            let scope = popped_scopes.last().unwrap();\n             match label {\n                 UnwindExit | ReturnExit => { }\n                 LoopExit(id, exit) => {"}, {"sha": "4c5ed91e5f74750f1b94f37494778cae715548eb", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -2036,7 +2036,7 @@ fn trait_metadata(cx: &CrateContext,\n     // assigned the correct name, size, namespace, and source location. But it does not describe\n     // the trait's methods.\n     let path = ty::item_path(cx.tcx, def_id);\n-    let ident = path.last().ident();\n+    let ident = path.last().unwrap().ident();\n     let name = ppaux::trait_store_to_str(cx.tcx, trait_store) +\n                ppaux::mutability_to_str(mutability) +\n                token::ident_to_str(&ident);\n@@ -2361,7 +2361,7 @@ fn populate_scope_map(cx: &CrateContext,\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess.codemap.lookup_char_pos(scope_span.lo);\n         let file_metadata = file_metadata(cx, loc.file.name);\n-        let parent_scope = scope_stack.last().scope_metadata;\n+        let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n             llvm::LLVMDIBuilderCreateLexicalBlock(\n@@ -2377,11 +2377,11 @@ fn populate_scope_map(cx: &CrateContext,\n         inner_walk(cx, scope_stack, scope_map);\n \n         // pop artificial scopes\n-        while scope_stack.last().ident.is_some() {\n+        while scope_stack.last().unwrap().ident.is_some() {\n             scope_stack.pop();\n         }\n \n-        if scope_stack.last().scope_metadata != scope_metadata {\n+        if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n             cx.sess.span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n         }\n \n@@ -2392,11 +2392,12 @@ fn populate_scope_map(cx: &CrateContext,\n                   block: &ast::Block,\n                   scope_stack: &mut ~[ScopeStackEntry],\n                   scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n-        scope_map.insert(block.id, scope_stack.last().scope_metadata);\n+        scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n \n         // The interesting things here are statements and the concluding expression.\n         for statement in block.stmts.iter() {\n-            scope_map.insert(ast_util::stmt_id(*statement), scope_stack.last().scope_metadata);\n+            scope_map.insert(ast_util::stmt_id(*statement),\n+                             scope_stack.last().unwrap().scope_metadata);\n \n             match statement.node {\n                 ast::StmtDecl(decl, _) => walk_decl(cx, decl, scope_stack, scope_map),\n@@ -2417,7 +2418,7 @@ fn populate_scope_map(cx: &CrateContext,\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n             codemap::Spanned { node: ast::DeclLocal(local), .. } => {\n-                scope_map.insert(local.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n \n                 walk_pattern(cx, local.pat, scope_stack, scope_map);\n \n@@ -2477,7 +2478,7 @@ fn populate_scope_map(cx: &CrateContext,\n                         // Create a new lexical scope and push it onto the stack\n                         let loc = cx.sess.codemap.lookup_char_pos(pat.span.lo);\n                         let file_metadata = file_metadata(cx, loc.file.name);\n-                        let parent_scope = scope_stack.last().scope_metadata;\n+                        let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n                             llvm::LLVMDIBuilderCreateLexicalBlock(\n@@ -2495,27 +2496,27 @@ fn populate_scope_map(cx: &CrateContext,\n \n                     } else {\n                         // Push a new entry anyway so the name can be found\n-                        let prev_metadata = scope_stack.last().scope_metadata;\n+                        let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n                         scope_stack.push(ScopeStackEntry {\n                             scope_metadata: prev_metadata,\n                             ident: Some(ident)\n                         });\n                     }\n                 }\n \n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for &sub_pat in sub_pat_opt.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n             ast::PatWild | ast::PatWildMulti => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n             }\n \n             ast::PatEnum(_, ref sub_pats_opt) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for ref sub_pats in sub_pats_opt.iter() {\n                     for &p in sub_pats.iter() {\n@@ -2525,39 +2526,39 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::PatStruct(_, ref field_pats, _) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for &ast::FieldPat { pat: sub_pat, .. } in field_pats.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n             ast::PatTup(ref sub_pats) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for &sub_pat in sub_pats.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n             ast::PatUniq(sub_pat) | ast::PatRegion(sub_pat) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n                 walk_pattern(cx, sub_pat, scope_stack, scope_map);\n             }\n \n             ast::PatLit(exp) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n                 walk_expr(cx, exp, scope_stack, scope_map);\n             }\n \n             ast::PatRange(exp1, exp2) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n                 walk_expr(cx, exp1, scope_stack, scope_map);\n                 walk_expr(cx, exp2, scope_stack, scope_map);\n             }\n \n             ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n-                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for &sub_pat in front_sub_pats.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n@@ -2579,7 +2580,7 @@ fn populate_scope_map(cx: &CrateContext,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n-        scope_map.insert(exp.id, scope_stack.last().scope_metadata);\n+        scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n \n         match exp.node {\n             ast::ExprLogLevel |\n@@ -2606,14 +2607,14 @@ fn populate_scope_map(cx: &CrateContext,\n             },\n \n             ast::ExprUnary(node_id, _, sub_exp) => {\n-                scope_map.insert(node_id, scope_stack.last().scope_metadata);\n+                scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n                 walk_expr(cx, sub_exp, scope_stack, scope_map);\n             }\n \n             ast::ExprAssignOp(node_id, _, lhs, rhs) |\n             ast::ExprIndex(node_id, lhs, rhs)        |\n             ast::ExprBinary(node_id, _, lhs, rhs)    => {\n-                scope_map.insert(node_id, scope_stack.last().scope_metadata);\n+                scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n                 walk_expr(cx, lhs, scope_stack, scope_map);\n                 walk_expr(cx, rhs, scope_stack, scope_map);\n             }\n@@ -2720,7 +2721,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprMethodCall(node_id, receiver_exp, _, _, ref args, _) => {\n-                scope_map.insert(node_id, scope_stack.last().scope_metadata);\n+                scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n                 walk_expr(cx, receiver_exp, scope_stack, scope_map);\n \n                 for arg_exp in args.iter() {"}, {"sha": "2e25ac941a66dda43031b72dc07eb7c6864b7a67", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -170,9 +170,9 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n     let expected_num_region_params = decl_generics.region_param_defs.len();\n-    let supplied_num_region_params = path.segments.last().lifetimes.len();\n+    let supplied_num_region_params = path.segments.last().unwrap().lifetimes.len();\n     let regions = if expected_num_region_params == supplied_num_region_params {\n-        path.segments.last().lifetimes.map(\n+        path.segments.last().unwrap().lifetimes.map(\n             |l| ast_region_to_region(this.tcx(), l))\n     } else {\n         let anon_regions =\n@@ -373,7 +373,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         }\n \n         if (flags & NO_REGIONS) != 0u {\n-            if !path.segments.last().lifetimes.is_empty() {\n+            if !path.segments.last().unwrap().lifetimes.is_empty() {\n                 tcx.sess.span_err(\n                     path.span,\n                     \"region parameters are not allowed on this type\");"}, {"sha": "86d347fdac0d2d0f43d9917c38d29f42aae500e9", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -3827,9 +3827,9 @@ pub fn instantiate_path(fcx: @FnCtxt,\n     // determine the region parameters, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n     let num_expected_regions = tpt.generics.region_param_defs.len();\n-    let num_supplied_regions = pth.segments.last().lifetimes.len();\n+    let num_supplied_regions = pth.segments.last().unwrap().lifetimes.len();\n     let regions = if num_expected_regions == num_supplied_regions {\n-        pth.segments.last().lifetimes.map(\n+        pth.segments.last().unwrap().lifetimes.map(\n             |l| ast_region_to_region(fcx.tcx(), l))\n     } else {\n         if num_supplied_regions != 0 {"}, {"sha": "9b1caaa152ce3b341542ebcc1fe13379392eb445", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -164,7 +164,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         info: |&render::Cache| -> Option<(~[~str], &'static str)>) {\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n-    let last = path.segments.last();\n+    let last = path.segments.last().unwrap();\n     if last.lifetimes.len() > 0 || last.types.len() > 0 {\n         let mut counter = 0;\n         generics.push_str(\"&lt;\");\n@@ -230,13 +230,13 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                     }\n                     match shortty {\n                         \"mod\" => {\n-                            url.push_str(*fqp.last());\n+                            url.push_str(*fqp.last().unwrap());\n                             url.push_str(\"/index.html\");\n                         }\n                         _ => {\n                             url.push_str(shortty);\n                             url.push_str(\".\");\n-                            url.push_str(*fqp.last());\n+                            url.push_str(*fqp.last().unwrap());\n                             url.push_str(\".html\");\n                         }\n                     }\n@@ -457,7 +457,7 @@ impl fmt::Default for clean::ViewPath {\n     fn fmt(v: &clean::ViewPath, f: &mut fmt::Formatter) {\n         match *v {\n             clean::SimpleImport(ref name, ref src) => {\n-                if *name == src.path.segments.last().name {\n+                if *name == src.path.segments.last().unwrap().name {\n                     write!(f.buf, \"use {};\", *src);\n                 } else {\n                     write!(f.buf, \"use {} = {};\", *name, *src);"}, {"sha": "fee97232fa000ee664dfae9f31fbde1bc89c8f3e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -275,7 +275,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         for (i, (&id, &(ref fqp, short))) in cache.paths.iter().enumerate() {\n             if i > 0 { write!(w, \",\"); }\n             write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n-                   id, short, *fqp.last());\n+                   id, short, *fqp.last().unwrap());\n         }\n         write!(w, \"\\\\};\");\n         w.flush();\n@@ -522,15 +522,15 @@ impl DocFolder for Cache {\n                     clean::TyMethodItem(..) |\n                     clean::StructFieldItem(..) |\n                     clean::VariantItem(..) => {\n-                        Some((Some(*self.parent_stack.last()),\n+                        Some((Some(*self.parent_stack.last().unwrap()),\n                               self.stack.slice_to(self.stack.len() - 1)))\n \n                     }\n                     clean::MethodItem(..) => {\n                         if self.parent_stack.len() == 0 {\n                             None\n                         } else {\n-                            let last = self.parent_stack.last();\n+                            let last = self.parent_stack.last().unwrap();\n                             let amt = match self.paths.find(last) {\n                                 Some(&(_, \"trait\")) => self.stack.len() - 1,\n                                 Some(..) | None => self.stack.len(),"}, {"sha": "b3d0e9cb10ab8daf9a2c2c19b6eef8b441b73ae6", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -952,10 +952,8 @@ pub trait ImmutableVector<'a, T> {\n     fn init(&self) -> &'a [T];\n     /// Returns all but the last `n' elements of a vector\n     fn initn(&self, n: uint) -> &'a [T];\n-    /// Returns the last element of a vector, failing if the vector is empty.\n-    fn last(&self) -> &'a T;\n     /// Returns the last element of a vector, or `None` if it is empty.\n-    fn last_opt(&self) -> Option<&'a T>;\n+    fn last(&self) -> Option<&'a T>;\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n@@ -1142,13 +1140,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn last(&self) -> &'a T {\n-        if self.len() == 0 { fail!(\"last: empty vector\") }\n-        &self[self.len() - 1]\n-    }\n-\n-    #[inline]\n-    fn last_opt(&self) -> Option<&'a T> {\n+    fn last(&self) -> Option<&'a T> {\n             if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n     }\n \n@@ -3116,27 +3108,12 @@ mod tests {\n \n     #[test]\n     fn test_last() {\n-        let mut a = ~[11];\n-        assert_eq!(a.last(), &11);\n-        a = ~[11, 12];\n-        assert_eq!(a.last(), &12);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_last_empty() {\n-        let a: ~[int] = ~[];\n-        a.last();\n-    }\n-\n-    #[test]\n-    fn test_last_opt() {\n         let mut a = ~[];\n-        assert_eq!(a.last_opt(), None);\n+        assert_eq!(a.last(), None);\n         a = ~[11];\n-        assert_eq!(a.last_opt().unwrap(), &11);\n+        assert_eq!(a.last().unwrap(), &11);\n         a = ~[11, 12];\n-        assert_eq!(a.last_opt().unwrap(), &12);\n+        assert_eq!(a.last().unwrap(), &12);\n     }\n \n     #[test]"}, {"sha": "72ab81d8657584140c237907838bed2d75a86307", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -106,7 +106,7 @@ fn pretty_ty(ty: &Ty, itr: @IdentInterner, out: &mut ~str) {\n         // need custom handling.\n         TyNil => { out.push_str(\"$NIL$\"); return }\n         TyPath(ref path, _, _) => {\n-            out.push_str(itr.get(path.segments.last().identifier.name));\n+            out.push_str(itr.get(path.segments.last().unwrap().identifier.name));\n             return\n         }\n         TyTup(ref tys) => {\n@@ -139,7 +139,7 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> PathElem {\n     match *trait_ref {\n         None => pretty = ~\"\",\n         Some(ref trait_ref) => {\n-            pretty = itr.get(trait_ref.path.segments.last().identifier.name).to_owned();\n+            pretty = itr.get(trait_ref.path.segments.last().unwrap().identifier.name).to_owned();\n             pretty.push_char('$');\n         }\n     };"}, {"sha": "6472551b049fc547b0e02f8972937cc72a76aa7c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -31,7 +31,7 @@ pub fn path_name_i(idents: &[Ident]) -> ~str {\n // totally scary function: ignores all but the last element, should have\n // a different name\n pub fn path_to_ident(path: &Path) -> Ident {\n-    path.segments.last().identifier\n+    path.segments.last().unwrap().identifier\n }\n \n pub fn local_def(id: NodeId) -> DefId {\n@@ -913,7 +913,7 @@ pub fn xorPush(marks: &mut ~[Mrk], mark: Mrk) {\n // get the last element of a mutable array.\n // FIXME #4903: , must be a separate procedure for now.\n pub fn getLast(arr: &~[Mrk]) -> Mrk {\n-    *arr.last()\n+    *arr.last().unwrap()\n }\n \n // are two paths equal when compared unhygienically?"}, {"sha": "ebf02f7691e40dc6db437b96ed1cd5ed12663d54", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -269,12 +269,9 @@ impl CodeMap {\n \n     pub fn new_filemap(&self, filename: FileName, src: @str) -> @FileMap {\n         let mut files = self.files.borrow_mut();\n-        let start_pos = if files.get().len() == 0 {\n-            0\n-        } else {\n-            let last_start = files.get().last().start_pos.to_uint();\n-            let last_len = files.get().last().src.len();\n-            last_start + last_len\n+        let start_pos = match files.get().last() {\n+            None => 0,\n+            Some(last) => last.start_pos.to_uint() + last.src.len(),\n         };\n \n         let filemap = @FileMap {"}, {"sha": "cddfa7d2aa050fb28f3ad046f82f93e7001defca", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -920,7 +920,7 @@ enum StructType {\n // general helper methods.\n impl<'a> TraitDef<'a> {\n     fn set_expn_info(&self, mut to_set: Span) -> Span {\n-        let trait_name = match self.path.path.last_opt() {\n+        let trait_name = match self.path.path.last() {\n             None => self.cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n             Some(name) => *name\n         };"}, {"sha": "4c78244bf08435c308c2c2fb17a8c4f9bcafca55", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -190,7 +190,8 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n         if !r.stack.get().dotdotdoted || {\n                 let repeat_idx = r.repeat_idx.borrow();\n                 let repeat_len = r.repeat_len.borrow();\n-                *repeat_idx.get().last() == *repeat_len.get().last() - 1\n+                *repeat_idx.get().last().unwrap() ==\n+                *repeat_len.get().last().unwrap() - 1\n             } {\n \n             match r.stack.get().up {"}, {"sha": "d6f363eb6a074a06a8a9bc54bdb8151b88d27c00", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -55,10 +55,10 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    pub fn last<'a>(&'a self) -> &'a T {\n+    pub fn last<'a>(&'a self) -> Option<&'a T> {\n         match *self {\n             Vec(ref v) => v.last(),\n-            Empty => fail!(\"last on empty opt_vec\")\n+            Empty => None\n         }\n     }\n "}, {"sha": "30408fa1c2b53790b9e05214431537ebf7e018ea", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -1753,19 +1753,19 @@ impl Parser {\n                 return self.mk_expr(lo, hi, ExprLit(lit));\n             }\n             let mut es = ~[self.parse_expr()];\n-            self.commit_expr(*es.last(), &[], &[token::COMMA, token::RPAREN]);\n+            self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n             while self.token == token::COMMA {\n                 self.bump();\n                 if self.token != token::RPAREN {\n                     es.push(self.parse_expr());\n-                    self.commit_expr(*es.last(), &[], &[token::COMMA, token::RPAREN]);\n+                    self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n                 }\n                 else {\n                     trailing_comma = true;\n                 }\n             }\n             hi = self.span.hi;\n-            self.commit_expr_expecting(*es.last(), token::RPAREN);\n+            self.commit_expr_expecting(*es.last().unwrap(), token::RPAREN);\n \n             return if es.len() == 1 && !trailing_comma {\n                 self.mk_expr(lo, self.span.hi, ExprParen(es[0]))\n@@ -1924,7 +1924,8 @@ impl Parser {\n \n                     fields.push(self.parse_field());\n                     while self.token != token::RBRACE {\n-                        self.commit_expr(fields.last().expr, &[token::COMMA], &[token::RBRACE]);\n+                        self.commit_expr(fields.last().unwrap().expr,\n+                                         &[token::COMMA], &[token::RBRACE]);\n \n                         if self.eat(&token::DOTDOT) {\n                             base = Some(self.parse_expr());\n@@ -1939,7 +1940,7 @@ impl Parser {\n                     }\n \n                     hi = pth.span.hi;\n-                    self.commit_expr_expecting(fields.last().expr, token::RBRACE);\n+                    self.commit_expr_expecting(fields.last().unwrap().expr, token::RBRACE);\n                     ex = ExprStruct(pth, fields, base);\n                     return self.mk_expr(lo, hi, ex);\n                 }\n@@ -2092,7 +2093,7 @@ impl Parser {\n                   // This is a conservative error: only report the last unclosed delimiter. The\n                   // previous unclosed delimiters could actually be closed! The parser just hasn't\n                   // gotten to them yet.\n-                  match p.open_braces.last_opt() {\n+                  match p.open_braces.last() {\n                       None => {}\n                       Some(&sp) => p.span_note(sp, \"unclosed delimiter\"),\n                   };"}, {"sha": "3ea48969069ce300d05b9345099c34bfdd962f4f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -1947,7 +1947,7 @@ pub fn print_view_path(s: &mut State, vp: &ast::ViewPath) {\n     match vp.node {\n       ast::ViewPathSimple(ident, ref path, _) => {\n         // FIXME(#6993) can't compare identifiers directly here\n-        if path.segments.last().identifier.name != ident.name {\n+        if path.segments.last().unwrap().identifier.name != ident.name {\n             print_ident(s, ident);\n             space(&mut s.s);\n             word_space(s, \"=\");"}, {"sha": "db46c3db439a7ef0508138d9a171df205b534d09", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa66b91767ce92c45192ca11718575529d631d21/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa66b91767ce92c45192ca11718575529d631d21/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=aa66b91767ce92c45192ca11718575529d631d21", "patch": "@@ -91,7 +91,7 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n                 unique: ~Cons((), @*st.unique),\n                 tuple: (@Cons((), st.tuple.first()),\n                         ~Cons((), @*st.tuple.second())),\n-                vec: st.vec + &[@Cons((), *st.vec.last())],\n+                vec: st.vec + &[@Cons((), *st.vec.last().unwrap())],\n                 res: r(@Cons((), st.res._l))\n             }\n           }"}]}