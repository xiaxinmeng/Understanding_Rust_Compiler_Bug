{"sha": "dbab381da1a46a18e46a04a61156aec40c59a4f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYWIzODFkYTFhNDZhMThlNDZhMDRhNjExNTZhZWM0MGM1OWE0ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-19T06:38:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-19T06:38:10Z"}, "message": "Auto merge of #55040 - scalexm:param-env, r=nikomatsakis\n\nReplace `ParamEnv` with a new type in chalk context.\n\nI left a few FIXMEs.\n\nr? @nikomatsakis", "tree": {"sha": "4fab9e0acd8a079380631377e31166166c570ce8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fab9e0acd8a079380631377e31166166c570ce8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbab381da1a46a18e46a04a61156aec40c59a4f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbab381da1a46a18e46a04a61156aec40c59a4f6", "html_url": "https://github.com/rust-lang/rust/commit/dbab381da1a46a18e46a04a61156aec40c59a4f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbab381da1a46a18e46a04a61156aec40c59a4f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb5e1b93e300cf9772a24c6de27d9f21cdae3123", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb5e1b93e300cf9772a24c6de27d9f21cdae3123", "html_url": "https://github.com/rust-lang/rust/commit/cb5e1b93e300cf9772a24c6de27d9f21cdae3123"}, {"sha": "55ce7a266958aaed4774927ed1765576f561aa2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/55ce7a266958aaed4774927ed1765576f561aa2d", "html_url": "https://github.com/rust-lang/rust/commit/55ce7a266958aaed4774927ed1765576f561aa2d"}], "stats": {"total": 669, "additions": 553, "deletions": 116}, "files": [{"sha": "de03892b994ef6a962ad4808f82d8bc9dde1b957", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -70,6 +70,7 @@ use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n+use traits;\n use traits::query::{\n     CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal,\n     CanonicalPredicateGoal, CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal,\n@@ -550,6 +551,7 @@ define_dep_nodes!( <'tcx>\n     [anon] TraitSelect,\n \n     [] ParamEnv(DefId),\n+    [] Environment(DefId),\n     [] DescribeDef(DefId),\n \n     // FIXME(mw): DefSpans are not really inputs since they are derived from\n@@ -669,7 +671,7 @@ define_dep_nodes!( <'tcx>\n     [input] Features,\n \n     [] ProgramClausesFor(DefId),\n-    [] ProgramClausesForEnv(ParamEnv<'tcx>),\n+    [] ProgramClausesForEnv(traits::Environment<'tcx>),\n     [] WasmImportModuleMap(CrateNum),\n     [] ForeignModules(CrateNum),\n "}, {"sha": "43448ad0d15ad21a4e470127dc9d143fd4cd2e06", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -1395,10 +1395,16 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n \n impl_stable_hash_for!(\n     impl<'tcx> for struct traits::ProgramClause<'tcx> {\n-        goal, hypotheses\n+        goal, hypotheses, category\n     }\n );\n \n+impl_stable_hash_for!(enum traits::ProgramClauseCategory {\n+    ImpliedBound,\n+    WellFormed,\n+    Other,\n+});\n+\n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -1422,3 +1428,8 @@ impl_stable_hash_for!(struct ty::subst::UserSubsts<'tcx> { substs, user_self_ty\n \n impl_stable_hash_for!(struct ty::subst::UserSelfTy<'tcx> { impl_def_id, self_ty });\n \n+impl_stable_hash_for!(\n+    impl<'tcx> for struct traits::Environment<'tcx> {\n+        clauses,\n+    }\n+);"}, {"sha": "d129cd486cf0517576ded39ffea8bdd10f7725fe", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -278,6 +278,8 @@ pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n /// * `DomainGoal`\n /// * `Goal`\n /// * `Clause`\n+/// * `Environment`\n+/// * `InEnvironment`\n /// are used for representing the trait system in the form of\n /// logic programming clauses. They are part of the interface\n /// for the chalk SLG solver.\n@@ -335,6 +337,14 @@ impl<'tcx> DomainGoal<'tcx> {\n     pub fn into_goal(self) -> GoalKind<'tcx> {\n         GoalKind::DomainGoal(self)\n     }\n+\n+    pub fn into_program_clause(self) -> ProgramClause<'tcx> {\n+        ProgramClause {\n+            goal: self,\n+            hypotheses: ty::List::empty(),\n+            category: ProgramClauseCategory::Other,\n+        }\n+    }\n }\n \n impl<'tcx> GoalKind<'tcx> {\n@@ -360,6 +370,15 @@ pub enum Clause<'tcx> {\n     ForAll(ty::Binder<ProgramClause<'tcx>>),\n }\n \n+impl Clause<'tcx> {\n+    pub fn category(self) -> ProgramClauseCategory {\n+        match self {\n+            Clause::Implies(clause) => clause.category,\n+            Clause::ForAll(clause) => clause.skip_binder().category,\n+        }\n+    }\n+}\n+\n /// Multiple clauses.\n pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n \n@@ -376,6 +395,38 @@ pub struct ProgramClause<'tcx> {\n \n     /// ...if we can prove these hypotheses (there may be no hypotheses at all):\n     pub hypotheses: Goals<'tcx>,\n+\n+    /// Useful for filtering clauses.\n+    pub category: ProgramClauseCategory,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum ProgramClauseCategory {\n+    ImpliedBound,\n+    WellFormed,\n+    Other,\n+}\n+\n+/// A set of clauses that we assume to be true.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Environment<'tcx> {\n+    pub clauses: Clauses<'tcx>,\n+}\n+\n+impl Environment<'tcx> {\n+    pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n+        InEnvironment {\n+            environment: self,\n+            goal,\n+        }\n+    }\n+}\n+\n+/// Something (usually a goal), along with an environment.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct InEnvironment<'tcx, G> {\n+    pub environment: Environment<'tcx>,\n+    pub goal: G,\n }\n \n pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;"}, {"sha": "c50c9703eb5574e0280e5560e8aa1d6e92fb6a29", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -496,7 +496,7 @@ impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n \n impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let traits::ProgramClause { goal, hypotheses } = self;\n+        let traits::ProgramClause { goal, hypotheses, .. } = self;\n         write!(fmt, \"{}\", goal)?;\n         if !hypotheses.is_empty() {\n             write!(fmt, \" :- \")?;\n@@ -647,18 +647,59 @@ impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::ProgramClause<'tcx> {\n         goal,\n-        hypotheses\n+        hypotheses,\n+        category,\n     }\n }\n \n+CloneTypeFoldableAndLiftImpls! {\n+    traits::ProgramClauseCategory,\n+}\n+\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::Clause<'tcx> {\n         (traits::Clause::Implies)(clause),\n         (traits::Clause::ForAll)(clause),\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Clause<'tcx>> {\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::Environment<'tcx> { clauses }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, G> TypeFoldable<'tcx> for traits::InEnvironment<'tcx, G> {\n+        environment,\n+        goal\n+    } where G: TypeFoldable<'tcx>\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n+    type Lifted = traits::Environment<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.clauses).map(|clauses| {\n+            traits::Environment {\n+                clauses,\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n+    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.environment).and_then(|environment| {\n+            tcx.lift(&self.goal).map(|goal| {\n+                traits::InEnvironment {\n+                    environment,\n+                    goal,\n+                }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n             .map(|t| t.fold_with(folder))"}, {"sha": "d0c3109da52f1570a099009987bf95eed45a5a52", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -12,6 +12,7 @@ use dep_graph::SerializedDepNodeIndex;\n use dep_graph::DepNode;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use mir::interpret::GlobalId;\n+use traits;\n use traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpEqGoal,\n     CanonicalTypeOpNormalizeGoal, CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n@@ -826,8 +827,14 @@ impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for_env<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: ty::ParamEnv<'tcx>) -> Cow<'static, str> {\n-        \"generating chalk-style clauses for param env\".into()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: traits::Environment<'tcx>) -> Cow<'static, str> {\n+        \"generating chalk-style clauses for environment\".into()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::environment<'tcx> {\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n+        \"return a chalk-style environment\".into()\n     }\n }\n "}, {"sha": "f2d7a6792b5631ab3c8a64221503dc0613f467ea", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -12,6 +12,7 @@\n \n use infer::canonical::Canonical;\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n+use traits;\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n@@ -181,6 +182,15 @@ impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n     }\n }\n \n+impl<'tcx> Key for traits::Environment<'tcx> {\n+    fn query_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt<'_, '_, '_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl Key for InternedString {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE"}, {"sha": "e4fc45f3798415d658196f327da715fc6639a87c", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -664,8 +664,11 @@ define_queries! { <'tcx>\n         [] fn program_clauses_for: ProgramClausesFor(DefId) -> Clauses<'tcx>,\n \n         [] fn program_clauses_for_env: ProgramClausesForEnv(\n-            ty::ParamEnv<'tcx>\n+            traits::Environment<'tcx>\n         ) -> Clauses<'tcx>,\n+\n+        // Get the chalk-style environment of the given item.\n+        [] fn environment: Environment(DefId) -> traits::Environment<'tcx>,\n     },\n \n     Linking {"}, {"sha": "f83f8bcf1a12d73e16b41684cc9cef8011be5742", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -1156,6 +1156,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::CheckMatch => { force!(check_match, def_id!()); }\n \n         DepKind::ParamEnv => { force!(param_env, def_id!()); }\n+        DepKind::Environment => { force!(environment, def_id!()); }\n         DepKind::DescribeDef => { force!(describe_def, def_id!()); }\n         DepKind::DefSpan => { force!(def_span, def_id!()); }\n         DepKind::LookupStability => { force!(lookup_stability, def_id!()); }"}, {"sha": "371fa46f3701039f8dbd2273c132245f80fa0ba8", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 48, "deletions": 39, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -22,8 +22,10 @@ use rustc::traits::{\n     ExClauseLift,\n     Goal,\n     GoalKind,\n-    ProgramClause,\n-    QuantifierKind\n+    Clause,\n+    QuantifierKind,\n+    Environment,\n+    InEnvironment,\n };\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::Kind;\n@@ -68,10 +70,10 @@ BraceStructTypeFoldableImpl! {\n impl context::Context for ChalkArenas<'tcx> {\n     type CanonicalExClause = Canonical<'tcx, ExClause<Self>>;\n \n-    type CanonicalGoalInEnvironment = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Goal<'tcx>>>;\n+    type CanonicalGoalInEnvironment = Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>;\n \n     // u-canonicalization not yet implemented\n-    type UCanonicalGoalInEnvironment = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Goal<'tcx>>>;\n+    type UCanonicalGoalInEnvironment = Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>;\n \n     type CanonicalConstrainedSubst = Canonical<'tcx, ConstrainedSubst<'tcx>>;\n \n@@ -82,13 +84,13 @@ impl context::Context for ChalkArenas<'tcx> {\n \n     type InferenceNormalizedSubst = CanonicalVarValues<'tcx>;\n \n-    type GoalInEnvironment = ty::ParamEnvAnd<'tcx, Goal<'tcx>>;\n+    type GoalInEnvironment = InEnvironment<'tcx, Goal<'tcx>>;\n \n     type RegionConstraint = QueryRegionConstraint<'tcx>;\n \n     type Substitution = CanonicalVarValues<'tcx>;\n \n-    type Environment = ty::ParamEnv<'tcx>;\n+    type Environment = Environment<'tcx>;\n \n     type Goal = Goal<'tcx>;\n \n@@ -98,24 +100,24 @@ impl context::Context for ChalkArenas<'tcx> {\n \n     type Parameter = Kind<'tcx>;\n \n-    type ProgramClause = ProgramClause<'tcx>;\n+    type ProgramClause = Clause<'tcx>;\n \n-    type ProgramClauses = Vec<ProgramClause<'tcx>>;\n+    type ProgramClauses = Vec<Clause<'tcx>>;\n \n     type UnificationResult = InferOk<'tcx, ()>;\n \n     fn goal_in_environment(\n-        env: &ty::ParamEnv<'tcx>,\n+        env: &Environment<'tcx>,\n         goal: Goal<'tcx>,\n-    ) -> ty::ParamEnvAnd<'tcx, Goal<'tcx>> {\n-        env.and(goal)\n+    ) -> InEnvironment<'tcx, Goal<'tcx>> {\n+        env.with(goal)\n     }\n }\n \n impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     fn make_solution(\n         &self,\n-        _root_goal: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _root_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n         _simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n     ) -> Option<Canonical<'gcx, QueryResponse<'gcx, ()>>> {\n         unimplemented!()\n@@ -124,7 +126,10 @@ impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n \n impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     /// True if this is a coinductive goal -- e.g., proving an auto trait.\n-    fn is_coinductive(&self, _goal: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>) -> bool {\n+    fn is_coinductive(\n+        &self,\n+        _goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>\n+    ) -> bool {\n         unimplemented!()\n     }\n \n@@ -142,7 +147,7 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     /// - the environment and goal found by substitution `S` into `arg`\n     fn instantiate_ucanonical_goal<R>(\n         &self,\n-        _arg: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _arg: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n         _op: impl context::WithInstantiatedUCanonicalGoal<ChalkArenas<'gcx>, Output = R>,\n     ) -> R {\n         unimplemented!()\n@@ -175,19 +180,19 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     }\n \n     fn canonical(\n-        u_canon: &'a Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n-    ) -> &'a Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+        u_canon: &'a Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n+    ) -> &'a Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>> {\n         u_canon\n     }\n \n     fn is_trivial_substitution(\n-        _u_canon: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _u_canon: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n         _canonical_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n     ) -> bool {\n         unimplemented!()\n     }\n \n-    fn num_universes(_: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>) -> usize {\n+    fn num_universes(_: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>) -> usize {\n         0 // FIXME\n     }\n \n@@ -196,8 +201,8 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     /// but for the universes of universally quantified names.\n     fn map_goal_from_canonical(\n         _map: &UniverseMap,\n-        value: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n-    ) -> Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+        value: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n+    ) -> Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>> {\n         *value // FIXME universe maps not implemented yet\n     }\n \n@@ -267,10 +272,14 @@ impl context::InferenceTable<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n     fn add_clauses(\n         &mut self,\n-        _env: &ty::ParamEnv<'tcx>,\n-        _clauses: Vec<ProgramClause<'tcx>>,\n-    ) -> ty::ParamEnv<'tcx> {\n-        panic!(\"FIXME no method to add clauses to ParamEnv yet\")\n+        env: &Environment<'tcx>,\n+        clauses: Vec<Clause<'tcx>>,\n+    ) -> Environment<'tcx> {\n+        Environment {\n+            clauses: self.infcx.tcx.mk_clauses(\n+                env.clauses.iter().cloned().chain(clauses.into_iter())\n+            )\n+        }\n     }\n }\n \n@@ -279,19 +288,19 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n {\n     fn resolvent_clause(\n         &mut self,\n-        _environment: &ty::ParamEnv<'tcx>,\n+        _environment: &Environment<'tcx>,\n         _goal: &DomainGoal<'tcx>,\n         _subst: &CanonicalVarValues<'tcx>,\n-        _clause: &ProgramClause<'tcx>,\n+        _clause: &Clause<'tcx>,\n     ) -> chalk_engine::fallible::Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n         panic!()\n     }\n \n     fn apply_answer_subst(\n         &mut self,\n         _ex_clause: ChalkExClause<'tcx>,\n-        _selected_goal: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n-        _answer_table_goal: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _selected_goal: &InEnvironment<'tcx, Goal<'tcx>>,\n+        _answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n         _canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n     ) -> chalk_engine::fallible::Fallible<ChalkExClause<'tcx>> {\n         panic!()\n@@ -303,8 +312,8 @@ impl context::TruncateOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n {\n     fn truncate_goal(\n         &mut self,\n-        subgoal: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n-    ) -> Option<ty::ParamEnvAnd<'tcx, Goal<'tcx>>> {\n+        subgoal: &InEnvironment<'tcx, Goal<'tcx>>,\n+    ) -> Option<InEnvironment<'tcx, Goal<'tcx>>> {\n         Some(*subgoal) // FIXME we should truncate at some point!\n     }\n \n@@ -321,9 +330,9 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n {\n     fn program_clauses(\n         &self,\n-        _environment: &ty::ParamEnv<'tcx>,\n+        _environment: &Environment<'tcx>,\n         goal: &DomainGoal<'tcx>,\n-    ) -> Vec<ProgramClause<'tcx>> {\n+    ) -> Vec<Clause<'tcx>> {\n         use rustc::traits::WhereClause::*;\n \n         match goal {\n@@ -389,8 +398,8 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n     fn canonicalize_goal(\n         &mut self,\n-        value: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n-    ) -> Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+        value: &InEnvironment<'tcx, Goal<'tcx>>,\n+    ) -> Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>> {\n         let mut _orig_values = OriginalQueryValues::default();\n         self.infcx.canonicalize_query(value, &mut _orig_values)\n     }\n@@ -412,24 +421,24 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n     fn u_canonicalize_goal(\n         &mut self,\n-        value: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        value: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n     ) -> (\n-        Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n         UniverseMap,\n     ) {\n         (value.clone(), UniverseMap)\n     }\n \n     fn invert_goal(\n         &mut self,\n-        _value: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n-    ) -> Option<ty::ParamEnvAnd<'tcx, Goal<'tcx>>> {\n+        _value: &InEnvironment<'tcx, Goal<'tcx>>,\n+    ) -> Option<InEnvironment<'tcx, Goal<'tcx>>> {\n         panic!(\"goal inversion not yet implemented\")\n     }\n \n     fn unify_parameters(\n         &mut self,\n-        _environment: &ty::ParamEnv<'tcx>,\n+        _environment: &Environment<'tcx>,\n         _a: &Kind<'tcx>,\n         _b: &Kind<'tcx>,\n     ) -> ChalkEngineFallible<InferOk<'tcx, ()>> {"}, {"sha": "3d1e7cf17a65964895156da7accbf923acd542ed", "filename": "src/librustc_traits/lowering/environment.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -0,0 +1,256 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::traits::{\n+    Clause,\n+    Clauses,\n+    DomainGoal,\n+    FromEnv,\n+    ProgramClause,\n+    ProgramClauseCategory,\n+    Environment,\n+};\n+use rustc::ty::{self, TyCtxt, Ty};\n+use rustc::hir::def_id::DefId;\n+use rustc_data_structures::fx::FxHashSet;\n+\n+struct ClauseVisitor<'set, 'a, 'tcx: 'a + 'set> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    round: &'set mut FxHashSet<Clause<'tcx>>,\n+}\n+\n+impl ClauseVisitor<'set, 'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, round: &'set mut FxHashSet<Clause<'tcx>>) -> Self {\n+        ClauseVisitor {\n+            tcx,\n+            round,\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) {\n+        match ty.sty {\n+            ty::Projection(data) => {\n+                self.round.extend(\n+                    self.tcx.program_clauses_for(data.item_def_id)\n+                        .iter()\n+                        .filter(|c| c.category() == ProgramClauseCategory::ImpliedBound)\n+                        .cloned()\n+                );\n+            }\n+\n+            // forall<'a, T> { `Outlives(T, 'a) :- FromEnv(&'a T)` }\n+            ty::Ref(_region, _sub_ty, ..) => {\n+                // FIXME: we'd need bound tys in order to properly write the above rule\n+            }\n+\n+            ty::Dynamic(..) => {\n+                // FIXME: trait object rules are not yet implemented\n+            }\n+\n+            ty::Adt(def, ..) => {\n+                self.round.extend(\n+                    self.tcx.program_clauses_for(def.did)\n+                        .iter()\n+                        .filter(|c| c.category() == ProgramClauseCategory::ImpliedBound)\n+                        .cloned()\n+                );\n+            }\n+\n+            ty::Foreign(def_id) |\n+            ty::FnDef(def_id, ..) |\n+            ty::Closure(def_id, ..) |\n+            ty::Generator(def_id, ..) |\n+            ty::Opaque(def_id, ..) => {\n+                self.round.extend(\n+                    self.tcx.program_clauses_for(def_id)\n+                        .iter()\n+                        .filter(|c| c.category() == ProgramClauseCategory::ImpliedBound)\n+                        .cloned()\n+                );\n+            }\n+\n+            ty::Bool |\n+            ty::Char |\n+            ty::Int(..) |\n+            ty::Uint(..) |\n+            ty::Float(..) |\n+            ty::Str |\n+            ty::Array(..) |\n+            ty::Slice(..) |\n+            ty::RawPtr(..) |\n+            ty::FnPtr(..) |\n+            ty::Never |\n+            ty::Tuple(..) |\n+            ty::GeneratorWitness(..) |\n+            ty::UnnormalizedProjection(..) |\n+            ty::Param(..) |\n+            ty::Infer(..) |\n+            ty::Error => (),\n+        }\n+    }\n+\n+    fn visit_from_env(&mut self, from_env: FromEnv<'tcx>) {\n+        match from_env {\n+            FromEnv::Trait(predicate) => {\n+                self.round.extend(\n+                    self.tcx.program_clauses_for(predicate.def_id())\n+                        .iter()\n+                        .filter(|c| c.category() == ProgramClauseCategory::ImpliedBound)\n+                        .cloned()\n+                );\n+            }\n+\n+            FromEnv::Ty(ty) => self.visit_ty(ty),\n+        }\n+    }\n+\n+    fn visit_domain_goal(&mut self, domain_goal: DomainGoal<'tcx>) {\n+        // The only domain goals we can find in an environment are:\n+        // * `DomainGoal::Holds(..)`\n+        // * `DomainGoal::FromEnv(..)`\n+        // The former do not lead to any implied bounds. So we only need\n+        // to visit the latter.\n+        if let DomainGoal::FromEnv(from_env) = domain_goal {\n+            self.visit_from_env(from_env);\n+        }\n+    }\n+\n+    fn visit_program_clause(&mut self, clause: ProgramClause<'tcx>) {\n+        self.visit_domain_goal(clause.goal);\n+        // No need to visit `clause.hypotheses`: they are always of the form\n+        // `FromEnv(...)` and were visited at a previous round.\n+    }\n+\n+    fn visit_clause(&mut self, clause: Clause<'tcx>) {\n+        match clause {\n+            Clause::Implies(clause) => self.visit_program_clause(clause),\n+            Clause::ForAll(clause) => self.visit_program_clause(*clause.skip_binder()),\n+        }\n+    }\n+}\n+\n+crate fn program_clauses_for_env<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    environment: Environment<'tcx>,\n+) -> Clauses<'tcx> {\n+    debug!(\"program_clauses_for_env(environment={:?})\", environment);\n+\n+    let mut last_round = FxHashSet();\n+    {\n+        let mut visitor = ClauseVisitor::new(tcx, &mut last_round);\n+        for &clause in environment.clauses {\n+            visitor.visit_clause(clause);\n+        }\n+    }\n+\n+    let mut closure = last_round.clone();\n+    let mut next_round = FxHashSet();\n+    while !last_round.is_empty() {\n+        let mut visitor = ClauseVisitor::new(tcx, &mut next_round);\n+        for clause in last_round.drain() {\n+            visitor.visit_clause(clause);\n+        }\n+        last_round.extend(\n+            next_round.drain().filter(|&clause| closure.insert(clause))\n+        );\n+    }\n+\n+    debug!(\"program_clauses_for_env: closure = {:#?}\", closure);\n+\n+    return tcx.mk_clauses(\n+        closure.into_iter()\n+    );\n+}\n+\n+crate fn environment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Environment<'tcx> {\n+    use super::{Lower, IntoFromEnvGoal};\n+    use rustc::hir::{Node, TraitItemKind, ImplItemKind, ItemKind, ForeignItemKind};\n+\n+    // The environment of an impl Trait type is its defining function's environment.\n+    if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n+        return environment(tcx, parent);\n+    }\n+\n+    // Compute the bounds on `Self` and the type parameters.\n+    let ty::InstantiatedPredicates { predicates } =\n+        tcx.predicates_of(def_id).instantiate_identity(tcx);\n+\n+    let clauses = predicates.into_iter()\n+        .map(|predicate| predicate.lower())\n+        .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_from_env_goal()))\n+        .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_program_clause()))\n+\n+        // `ForAll` because each `domain_goal` is a `PolyDomainGoal` and\n+        // could bound lifetimes.\n+        .map(Clause::ForAll);\n+\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let node = tcx.hir.get(node_id);\n+\n+    let mut is_fn = false;\n+    let mut is_impl = false;\n+    match node {\n+        Node::TraitItem(item) => match item.node {\n+            TraitItemKind::Method(..) => is_fn = true,\n+            _ => (),\n+        }\n+\n+        Node::ImplItem(item) => match item.node {\n+            ImplItemKind::Method(..) => is_fn = true,\n+            _ => (),\n+        }\n+\n+        Node::Item(item) => match item.node {\n+            ItemKind::Impl(..) => is_impl = true,\n+            ItemKind::Fn(..) => is_fn = true,\n+            _ => (),\n+        }\n+\n+        Node::ForeignItem(item) => match item.node {\n+            ForeignItemKind::Fn(..) => is_fn = true,\n+            _ => (),\n+        }\n+\n+        // FIXME: closures?\n+        _ => (),\n+    }\n+\n+    let mut input_tys = FxHashSet::default();\n+\n+    // In an impl, we assume that the receiver type and all its constituents\n+    // are well-formed.\n+    if is_impl {\n+        let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+        input_tys.extend(trait_ref.self_ty().walk());\n+    }\n+\n+    // In an fn, we assume that the arguments and all their constituents are\n+    // well-formed.\n+    if is_fn {\n+        let fn_sig = tcx.fn_sig(def_id);\n+        input_tys.extend(\n+            // FIXME: `skip_binder` seems ok for now? In a real setting,\n+            // the late bound regions would next be instantiated with things\n+            // in the inference table.\n+            fn_sig.skip_binder().inputs().iter().flat_map(|ty| ty.walk())\n+        );\n+    }\n+\n+    let clauses = clauses.chain(\n+        input_tys.into_iter()\n+            .map(|ty| DomainGoal::FromEnv(FromEnv::Ty(ty)))\n+            .map(|domain_goal| domain_goal.into_program_clause())\n+            .map(Clause::Implies)\n+    );\n+\n+    Environment {\n+        clauses: tcx.mk_clauses(clauses),\n+    }\n+}"}, {"sha": "fb598a335482bcc56b8ec8bbc9aa0ea896128692", "filename": "src/librustc_traits/lowering/mod.rs", "status": "renamed", "additions": 18, "deletions": 66, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+mod environment;\n+\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::map::definitions::DefPathData;\n@@ -20,21 +22,21 @@ use rustc::traits::{\n     GoalKind,\n     PolyDomainGoal,\n     ProgramClause,\n+    ProgramClauseCategory,\n     WellFormed,\n     WhereClause,\n };\n use rustc::ty::query::Providers;\n use rustc::ty::{self, List, TyCtxt};\n-use rustc_data_structures::fx::FxHashSet;\n-use std::mem;\n use syntax::ast;\n \n use std::iter;\n \n crate fn provide(p: &mut Providers) {\n     *p = Providers {\n         program_clauses_for,\n-        program_clauses_for_env,\n+        program_clauses_for_env: environment::program_clauses_for_env,\n+        environment: environment::environment,\n         ..*p\n     };\n }\n@@ -173,66 +175,6 @@ crate fn program_clauses_for<'a, 'tcx>(\n     }\n }\n \n-crate fn program_clauses_for_env<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> Clauses<'tcx> {\n-    debug!(\"program_clauses_for_env(param_env={:?})\", param_env);\n-\n-    let mut last_round = FxHashSet();\n-    last_round.extend(\n-        param_env\n-            .caller_bounds\n-            .iter()\n-            .flat_map(|&p| predicate_def_id(p)),\n-    );\n-\n-    let mut closure = last_round.clone();\n-    let mut next_round = FxHashSet();\n-    while !last_round.is_empty() {\n-        next_round.extend(\n-            last_round\n-                .drain()\n-                .flat_map(|def_id| {\n-                    tcx.predicates_of(def_id)\n-                        .instantiate_identity(tcx)\n-                        .predicates\n-                })\n-                .flat_map(|p| predicate_def_id(p))\n-                .filter(|&def_id| closure.insert(def_id)),\n-        );\n-        mem::swap(&mut next_round, &mut last_round);\n-    }\n-\n-    debug!(\"program_clauses_for_env: closure = {:#?}\", closure);\n-\n-    return tcx.mk_clauses(\n-        closure\n-            .into_iter()\n-            .flat_map(|def_id| tcx.program_clauses_for(def_id).iter().cloned()),\n-    );\n-\n-    /// Given that `predicate` is in the environment, returns the\n-    /// def-id of something (e.g., a trait, associated item, etc)\n-    /// whose predicates can also be assumed to be true. We will\n-    /// compute the transitive closure of such things.\n-    fn predicate_def_id<'tcx>(predicate: ty::Predicate<'tcx>) -> Option<DefId> {\n-        match predicate {\n-            ty::Predicate::Trait(predicate) => Some(predicate.def_id()),\n-\n-            ty::Predicate::Projection(projection) => Some(projection.item_def_id()),\n-\n-            ty::Predicate::WellFormed(..)\n-            | ty::Predicate::RegionOutlives(..)\n-            | ty::Predicate::TypeOutlives(..)\n-            | ty::Predicate::ObjectSafe(..)\n-            | ty::Predicate::ClosureKind(..)\n-            | ty::Predicate::Subtype(..)\n-            | ty::Predicate::ConstEvaluatable(..) => None,\n-        }\n-    }\n-}\n-\n fn program_clauses_for_trait<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n@@ -263,6 +205,7 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     let implemented_from_env = ProgramClause {\n         goal: impl_trait,\n         hypotheses,\n+        category: ProgramClauseCategory::ImpliedBound,\n     };\n \n     let clauses = iter::once(Clause::ForAll(ty::Binder::dummy(implemented_from_env)));\n@@ -290,6 +233,7 @@ fn program_clauses_for_trait<'a, 'tcx>(\n         .map(|wc| wc.map_bound(|goal| ProgramClause {\n             goal: goal.into_from_env_goal(),\n             hypotheses,\n+            category: ProgramClauseCategory::ImpliedBound,\n         }))\n         .map(Clause::ForAll);\n \n@@ -316,6 +260,7 @@ fn program_clauses_for_trait<'a, 'tcx>(\n         hypotheses: tcx.mk_goals(\n             wf_conditions.map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n         ),\n+        category: ProgramClauseCategory::WellFormed,\n     };\n     let wf_clause = iter::once(Clause::ForAll(ty::Binder::dummy(wf_clause)));\n \n@@ -358,6 +303,7 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n             where_clauses\n                 .map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n         ),\n+        category: ProgramClauseCategory::Other,\n     };\n     tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::dummy(clause))))\n }\n@@ -394,6 +340,7 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n                 .cloned()\n                 .map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n         ),\n+        category: ProgramClauseCategory::WellFormed,\n     };\n \n     let well_formed_clause = iter::once(Clause::ForAll(ty::Binder::dummy(well_formed)));\n@@ -419,6 +366,7 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n         .map(|wc| wc.map_bound(|goal| ProgramClause {\n             goal: goal.into_from_env_goal(),\n             hypotheses,\n+            category: ProgramClauseCategory::ImpliedBound,\n         }))\n \n         .map(Clause::ForAll);\n@@ -466,7 +414,8 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n \n     let projection_eq_clause = ProgramClause {\n         goal: DomainGoal::Holds(projection_eq),\n-        hypotheses: &ty::List::empty(),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::Other,\n     };\n \n     // Rule WellFormed-AssocTy\n@@ -484,6 +433,7 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(placeholder_ty)),\n         hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n+        category: ProgramClauseCategory::Other,\n     };\n \n     // Rule Implied-Trait-From-AssocTy\n@@ -500,6 +450,7 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     let from_env_clause = ProgramClause {\n         goal: DomainGoal::FromEnv(FromEnv::Trait(trait_predicate)),\n         hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n+        category: ProgramClauseCategory::ImpliedBound,\n     };\n \n     let clauses = iter::once(projection_eq_clause)\n@@ -565,6 +516,7 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n                 .into_iter()\n                 .map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n         ),\n+        category: ProgramClauseCategory::Other,\n     };\n     tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::dummy(clause))))\n }\n@@ -595,8 +547,8 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n             }\n \n             if attr.check_name(\"rustc_dump_env_program_clauses\") {\n-                let param_env = self.tcx.param_env(def_id);\n-                clauses = Some(self.tcx.program_clauses_for_env(param_env));\n+                let environment = self.tcx.environment(def_id);\n+                clauses = Some(self.tcx.program_clauses_for_env(environment));\n             }\n \n             if let Some(clauses) = clauses {", "previous_filename": "src/librustc_traits/lowering.rs"}, {"sha": "3aa04cfeb67d40c4e02e9c24b3a9f32770536674", "filename": "src/test/ui/chalkify/lower_env1.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -18,9 +18,6 @@ LL | #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n    = note: Implemented(Self: Bar) :- FromEnv(Self: Bar).\n    = note: Implemented(Self: Foo) :- FromEnv(Self: Foo).\n    = note: Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized).\n-   = note: WellFormed(Self: Bar) :- Implemented(Self: Bar), WellFormed(Self: Foo).\n-   = note: WellFormed(Self: Foo) :- Implemented(Self: Foo).\n-   = note: WellFormed(Self: std::marker::Sized) :- Implemented(Self: std::marker::Sized).\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0b50dbfdf95c6714b8c9c9c87940b86c25543c31", "filename": "src/test/ui/chalkify/lower_env2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait Foo { }\n+\n+#[rustc_dump_program_clauses] //~ ERROR program clause dump\n+struct S<'a, T> where T: Foo {\n+    data: &'a T,\n+}\n+\n+#[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n+fn bar<'a, T: Foo>(x: S<T>) {\n+}\n+\n+fn main() {\n+}"}, {"sha": "3b88ac1f22bea6d24d18c4ab02d7bd26441450dc", "filename": "src/test/ui/chalkify/lower_env2.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -0,0 +1,25 @@\n+error: program clause dump\n+  --> $DIR/lower_env2.rs:16:1\n+   |\n+LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: FromEnv(T: Foo) :- FromEnv(S<'a, T>).\n+   = note: FromEnv(T: std::marker::Sized) :- FromEnv(S<'a, T>).\n+   = note: TypeOutlives(T : 'a) :- FromEnv(S<'a, T>).\n+   = note: WellFormed(S<'a, T>) :- Implemented(T: std::marker::Sized), Implemented(T: Foo), TypeOutlives(T : 'a).\n+\n+error: program clause dump\n+  --> $DIR/lower_env2.rs:21:1\n+   |\n+LL | #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: FromEnv(T: Foo) :- FromEnv(S<'a, T>).\n+   = note: FromEnv(T: std::marker::Sized) :- FromEnv(S<'a, T>).\n+   = note: Implemented(Self: Foo) :- FromEnv(Self: Foo).\n+   = note: Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized).\n+   = note: TypeOutlives(T : 'a) :- FromEnv(S<'a, T>).\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "1f8bc49e30996ffa500223af0d52d18115957e9f", "filename": "src/test/ui/chalkify/lower_env3.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait Foo {\n+    #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n+    fn foo(&self);\n+}\n+\n+impl<T> Foo for T where T: Clone {\n+    #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n+    fn foo(&self) {\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "ac0f8e34cd437db975fefe0d7e43dd627da38f52", "filename": "src/test/ui/chalkify/lower_env3.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbab381da1a46a18e46a04a61156aec40c59a4f6/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr?ref=dbab381da1a46a18e46a04a61156aec40c59a4f6", "patch": "@@ -0,0 +1,20 @@\n+error: program clause dump\n+  --> $DIR/lower_env3.rs:15:5\n+   |\n+LL |     #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: Implemented(Self: Foo) :- FromEnv(Self: Foo).\n+\n+error: program clause dump\n+  --> $DIR/lower_env3.rs:20:5\n+   |\n+LL |     #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: FromEnv(Self: std::marker::Sized) :- FromEnv(Self: std::clone::Clone).\n+   = note: Implemented(Self: std::clone::Clone) :- FromEnv(Self: std::clone::Clone).\n+   = note: Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized).\n+\n+error: aborting due to 2 previous errors\n+"}]}