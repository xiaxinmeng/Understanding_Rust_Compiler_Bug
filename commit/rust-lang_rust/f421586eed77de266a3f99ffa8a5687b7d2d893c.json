{"sha": "f421586eed77de266a3f99ffa8a5687b7d2d893c", "node_id": "C_kwDOAAsO6NoAKGY0MjE1ODZlZWQ3N2RlMjY2YTNmOTlmZmE4YTU2ODdiN2QyZDg5M2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-24T10:33:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-24T10:33:42Z"}, "message": "Auto merge of #109216 - martingms:unicode-case-lut-shrink, r=Mark-Simulacrum\n\nShrink unicode case-mapping LUTs by 24k\n\nI was looking into the binary bloat of a small program using `str::to_lowercase` and `str::to_uppercase`, and noticed that the lookup tables used for case mapping had a lot of zero-bytes in them. The reason for this is that since some characters map to up to three other characters when lower or uppercased, the LUTs store a `[char; 3]` for each character. However, the vast majority of cases only map to a single new character, in other words most of the entries are e.g. `(lowerc, [upperc, '\\0', '\\0'])`.\nThis PR introduces a new encoding scheme for these tables.\n\nThe changes reduces the size of my test binary by about 24K.\n\nI've also done some `#[bench]`marks on unicode-heavy test data, and found that the performance of both `str::to_lowercase` and `str::to_uppercase` improves by up to 20%. These measurements are obviously very dependent on the character distribution of the data.\n\nSomeone else will have to decide whether this more complex scheme is worth it or not, I was just goofing around a bit and here's what came out of it :man_shrugging: No hard feelings if this isn't wanted!", "tree": {"sha": "75671286cb63e9b0b93b6cc55510d2a50c32af5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75671286cb63e9b0b93b6cc55510d2a50c32af5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f421586eed77de266a3f99ffa8a5687b7d2d893c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f421586eed77de266a3f99ffa8a5687b7d2d893c", "html_url": "https://github.com/rust-lang/rust/commit/f421586eed77de266a3f99ffa8a5687b7d2d893c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f421586eed77de266a3f99ffa8a5687b7d2d893c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c763eceae349c1d827d9cfbf5df21ca40b21c861", "url": "https://api.github.com/repos/rust-lang/rust/commits/c763eceae349c1d827d9cfbf5df21ca40b21c861", "html_url": "https://github.com/rust-lang/rust/commit/c763eceae349c1d827d9cfbf5df21ca40b21c861"}, {"sha": "54f55efb9a147e8a7b5073d24c0cc67f0aad5a13", "url": "https://api.github.com/repos/rust-lang/rust/commits/54f55efb9a147e8a7b5073d24c0cc67f0aad5a13", "html_url": "https://github.com/rust-lang/rust/commit/54f55efb9a147e8a7b5073d24c0cc67f0aad5a13"}], "stats": {"total": 2681, "additions": 852, "deletions": 1829}, "files": [{"sha": "b25e9df286808362df77a0f1b3cfb011b3e55fa3", "filename": "library/core/src/unicode/unicode_data.rs", "status": "modified", "additions": 783, "deletions": 1794, "changes": 2577, "blob_url": "https://github.com/rust-lang/rust/blob/f421586eed77de266a3f99ffa8a5687b7d2d893c/library%2Fcore%2Fsrc%2Funicode%2Funicode_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f421586eed77de266a3f99ffa8a5687b7d2d893c/library%2Fcore%2Fsrc%2Funicode%2Funicode_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Funicode%2Funicode_data.rs?ref=f421586eed77de266a3f99ffa8a5687b7d2d893c"}, {"sha": "7a978db62b40d872f31dd66b376c77208c2fe6d5", "filename": "src/tools/unicode-table-generator/src/case_mapping.rs", "status": "modified", "additions": 69, "deletions": 35, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f421586eed77de266a3f99ffa8a5687b7d2d893c/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fcase_mapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f421586eed77de266a3f99ffa8a5687b7d2d893c/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fcase_mapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fcase_mapping.rs?ref=f421586eed77de266a3f99ffa8a5687b7d2d893c", "patch": "@@ -1,36 +1,62 @@\n use crate::{fmt_list, UnicodeData};\n-use std::fmt;\n+use std::{\n+    char,\n+    collections::BTreeMap,\n+    fmt::{self, Write},\n+};\n+\n+const INDEX_MASK: u32 = 1 << 22;\n \n pub(crate) fn generate_case_mapping(data: &UnicodeData) -> String {\n     let mut file = String::new();\n \n+    write!(file, \"const INDEX_MASK: u32 = 0x{:x};\", INDEX_MASK).unwrap();\n+    file.push_str(\"\\n\\n\");\n     file.push_str(HEADER.trim_start());\n-\n-    let decl_type = \"&[(char, [char; 3])]\";\n-\n-    file.push_str(&format!(\n-        \"static LOWERCASE_TABLE: {} = &[{}];\",\n-        decl_type,\n-        fmt_list(data.to_lower.iter().map(to_mapping))\n-    ));\n+    file.push('\\n');\n+    file.push_str(&generate_tables(\"LOWER\", &data.to_lower));\n     file.push_str(\"\\n\\n\");\n-    file.push_str(&format!(\n-        \"static UPPERCASE_TABLE: {} = &[{}];\",\n-        decl_type,\n-        fmt_list(data.to_upper.iter().map(to_mapping))\n-    ));\n+    file.push_str(&generate_tables(\"UPPER\", &data.to_upper));\n     file\n }\n \n-fn to_mapping((key, (a, b, c)): (&u32, &(u32, u32, u32))) -> (CharEscape, [CharEscape; 3]) {\n-    (\n-        CharEscape(std::char::from_u32(*key).unwrap()),\n-        [\n-            CharEscape(std::char::from_u32(*a).unwrap()),\n-            CharEscape(std::char::from_u32(*b).unwrap()),\n-            CharEscape(std::char::from_u32(*c).unwrap()),\n-        ],\n-    )\n+fn generate_tables(case: &str, data: &BTreeMap<u32, (u32, u32, u32)>) -> String {\n+    let mut mappings = Vec::with_capacity(data.len());\n+    let mut multis = Vec::new();\n+\n+    for (&key, &(a, b, c)) in data.iter() {\n+        let key = char::from_u32(key).unwrap();\n+\n+        if key.is_ascii() {\n+            continue;\n+        }\n+\n+        let value = if b == 0 && c == 0 {\n+            a\n+        } else {\n+            multis.push([\n+                CharEscape(char::from_u32(a).unwrap()),\n+                CharEscape(char::from_u32(b).unwrap()),\n+                CharEscape(char::from_u32(c).unwrap()),\n+            ]);\n+\n+            INDEX_MASK | (u32::try_from(multis.len()).unwrap() - 1)\n+        };\n+\n+        mappings.push((CharEscape(key), value));\n+    }\n+\n+    let mut tables = String::new();\n+\n+    write!(tables, \"static {}CASE_TABLE: &[(char, u32)] = &[{}];\", case, fmt_list(mappings))\n+        .unwrap();\n+\n+    tables.push_str(\"\\n\\n\");\n+\n+    write!(tables, \"static {}CASE_TABLE_MULTI: &[[char; 3]] = &[{}];\", case, fmt_list(multis))\n+        .unwrap();\n+\n+    tables\n }\n \n struct CharEscape(char);\n@@ -46,25 +72,33 @@ pub fn to_lower(c: char) -> [char; 3] {\n     if c.is_ascii() {\n         [(c as u8).to_ascii_lowercase() as char, '\\0', '\\0']\n     } else {\n-        match bsearch_case_table(c, LOWERCASE_TABLE) {\n-            None => [c, '\\0', '\\0'],\n-            Some(index) => LOWERCASE_TABLE[index].1,\n-        }\n+        LOWERCASE_TABLE\n+            .binary_search_by(|&(key, _)| key.cmp(&c))\n+            .map(|i| {\n+                let u = LOWERCASE_TABLE[i].1;\n+                char::from_u32(u).map(|c| [c, '\\0', '\\0']).unwrap_or_else(|| {\n+                    // SAFETY: Index comes from statically generated table\n+                    unsafe { *LOWERCASE_TABLE_MULTI.get_unchecked((u & (INDEX_MASK - 1)) as usize) }\n+                })\n+            })\n+            .unwrap_or([c, '\\0', '\\0'])\n     }\n }\n \n pub fn to_upper(c: char) -> [char; 3] {\n     if c.is_ascii() {\n         [(c as u8).to_ascii_uppercase() as char, '\\0', '\\0']\n     } else {\n-        match bsearch_case_table(c, UPPERCASE_TABLE) {\n-            None => [c, '\\0', '\\0'],\n-            Some(index) => UPPERCASE_TABLE[index].1,\n-        }\n+        UPPERCASE_TABLE\n+            .binary_search_by(|&(key, _)| key.cmp(&c))\n+            .map(|i| {\n+                let u = UPPERCASE_TABLE[i].1;\n+                char::from_u32(u).map(|c| [c, '\\0', '\\0']).unwrap_or_else(|| {\n+                    // SAFETY: Index comes from statically generated table\n+                    unsafe { *UPPERCASE_TABLE_MULTI.get_unchecked((u & (INDEX_MASK - 1)) as usize) }\n+                })\n+            })\n+            .unwrap_or([c, '\\0', '\\0'])\n     }\n }\n-\n-fn bsearch_case_table(c: char, table: &[(char, [char; 3])]) -> Option<usize> {\n-    table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n-}\n \";"}]}