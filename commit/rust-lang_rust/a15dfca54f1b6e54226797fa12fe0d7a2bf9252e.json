{"sha": "a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNWRmY2E1NGYxYjZlNTQyMjY3OTdmYTEyZmUwZDdhMmJmOTI1MmU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-22T02:50:05Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-14T01:34:31Z"}, "message": "Instead of renaming, treat differently marked identifiers as unequal", "tree": {"sha": "b37486410919e630750e8e433b6e509c6ec33d63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b37486410919e630750e8e433b6e509c6ec33d63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "html_url": "https://github.com/rust-lang/rust/commit/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca924047de90b1370a7f1a81df7cfb611fe59b44", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca924047de90b1370a7f1a81df7cfb611fe59b44", "html_url": "https://github.com/rust-lang/rust/commit/ca924047de90b1370a7f1a81df7cfb611fe59b44"}], "stats": {"total": 597, "additions": 37, "deletions": 560}, "files": [{"sha": "f62eeb41a98560602df75d31d955cdb8ac750d70", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "patch": "@@ -53,7 +53,6 @@ use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n-use syntax::ext::mtwt;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::parse::token::{self, keywords};\n@@ -462,7 +461,7 @@ struct BindingInfo {\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = HashMap<Name, BindingInfo>;\n+type BindingMap = HashMap<ast::Ident, BindingInfo>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n@@ -668,7 +667,7 @@ enum ModulePrefixResult<'a> {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: HashMap<Name, Def>,\n+    bindings: HashMap<ast::Ident, Def>,\n     kind: RibKind<'a>,\n }\n \n@@ -1385,15 +1384,17 @@ impl<'a> Resolver<'a> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_ident_in_lexical_scope(&mut self,\n-                                      ident: ast::Ident,\n+                                      mut ident: ast::Ident,\n                                       ns: Namespace,\n                                       record_used: bool)\n                                       -> Option<LexicalScopeBinding<'a>> {\n-        let name = match ns { ValueNS => mtwt::resolve(ident), TypeNS => ident.name };\n+        if ns == TypeNS {\n+            ident = ast::Ident::with_empty_ctxt(ident.name);\n+        }\n \n         // Walk backwards up the ribs in scope.\n         for i in (0 .. self.get_ribs(ns).len()).rev() {\n-            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&name).cloned() {\n+            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::LocalDef(LocalDef {\n                     ribs: Some((ns, i)),\n@@ -1556,7 +1557,7 @@ impl<'a> Resolver<'a> {\n \n     /// Searches the current set of local scopes for labels.\n     /// Stops after meeting a closure.\n-    fn search_label(&self, name: Name) -> Option<Def> {\n+    fn search_label(&self, ident: ast::Ident) -> Option<Def> {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {\n@@ -1567,7 +1568,7 @@ impl<'a> Resolver<'a> {\n                     return None;\n                 }\n             }\n-            let result = rib.bindings.get(&name).cloned();\n+            let result = rib.bindings.get(&ident).cloned();\n             if result.is_some() {\n                 return result;\n             }\n@@ -1716,7 +1717,7 @@ impl<'a> Resolver<'a> {\n                     // plain insert (no renaming)\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(space, index as u32, def_id, name);\n-                    function_type_rib.bindings.insert(name, def);\n+                    function_type_rib.bindings.insert(ast::Ident::with_empty_ctxt(name), def);\n                 }\n                 self.type_ribs.push(function_type_rib);\n             }\n@@ -1887,7 +1888,7 @@ impl<'a> Resolver<'a> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // plain insert (no renaming, types are not currently hygienic....)\n-        self_type_rib.bindings.insert(keywords::SelfType.name(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n         self.type_ribs.push(self_type_rib);\n         f(self);\n         self.type_ribs.pop();\n@@ -1998,7 +1999,7 @@ impl<'a> Resolver<'a> {\n                     _ => false,\n                 } {\n                     let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n-                    binding_map.insert(mtwt::resolve(ident.node), binding_info);\n+                    binding_map.insert(ident.node, binding_info);\n                 }\n             }\n             true\n@@ -2020,15 +2021,14 @@ impl<'a> Resolver<'a> {\n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                     None => {\n-                        resolve_error(self,\n-                                      p.span,\n-                                      ResolutionError::VariableNotBoundInPattern(key, 1, i + 1));\n+                        let error = ResolutionError::VariableNotBoundInPattern(key.name, 1, i + 1);\n+                        resolve_error(self, p.span, error);\n                     }\n                     Some(binding_i) => {\n                         if binding_0.binding_mode != binding_i.binding_mode {\n                             resolve_error(self,\n                                           binding_i.span,\n-                                          ResolutionError::VariableBoundWithDifferentMode(key,\n+                                          ResolutionError::VariableBoundWithDifferentMode(key.name,\n                                                                                           i + 1));\n                         }\n                     }\n@@ -2039,7 +2039,7 @@ impl<'a> Resolver<'a> {\n                 if !map_0.contains_key(&key) {\n                     resolve_error(self,\n                                   binding.span,\n-                                  ResolutionError::VariableNotBoundInPattern(key, i + 1, 1));\n+                                  ResolutionError::VariableNotBoundInPattern(key.name, i + 1, 1));\n                 }\n             }\n         }\n@@ -2173,16 +2173,15 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings: &mut HashMap<Name, NodeId>)\n+                     bindings: &mut HashMap<ast::Ident, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n         // must not add it if it's in the bindings map\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n-        let renamed = mtwt::resolve(ident.node);\n         let mut def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n-        match bindings.get(&renamed).cloned() {\n+        match bindings.get(&ident.node).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n                 resolve_error(\n@@ -2204,7 +2203,7 @@ impl<'a> Resolver<'a> {\n             Some(..) if pat_src == PatternSource::Match => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                def = self.value_ribs.last_mut().unwrap().bindings[&renamed];\n+                def = self.value_ribs.last_mut().unwrap().bindings[&ident.node];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n@@ -2213,8 +2212,8 @@ impl<'a> Resolver<'a> {\n             None => {\n                 // A completely fresh binding, add to the lists if it's valid.\n                 if ident.node.name != keywords::Invalid.name() {\n-                    bindings.insert(renamed, outer_pat_id);\n-                    self.value_ribs.last_mut().unwrap().bindings.insert(renamed, def);\n+                    bindings.insert(ident.node, outer_pat_id);\n+                    self.value_ribs.last_mut().unwrap().bindings.insert(ident.node, def);\n                 }\n             }\n         }\n@@ -2275,7 +2274,7 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings: &mut HashMap<Name, NodeId>) {\n+                       bindings: &mut HashMap<ast::Ident, NodeId>) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n@@ -2748,7 +2747,7 @@ impl<'a> Resolver<'a> {\n         let names = self.value_ribs\n                     .iter()\n                     .rev()\n-                    .flat_map(|rib| rib.bindings.keys());\n+                    .flat_map(|rib| rib.bindings.keys().map(|ident| &ident.name));\n \n         if let Some(found) = find_best_match_for_name(names, name, None) {\n             if name != found {\n@@ -2759,7 +2758,7 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_labeled_block(&mut self, label: Option<ast::Ident>, id: NodeId, block: &Block) {\n         if let Some(label) = label {\n-            let (label, def) = (mtwt::resolve(label), Def::Label(id));\n+            let def = Def::Label(id);\n             self.with_label_rib(|this| {\n                 this.label_ribs.last_mut().unwrap().bindings.insert(label, def);\n                 this.visit_block(block);\n@@ -2966,15 +2965,15 @@ impl<'a> Resolver<'a> {\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n-                        rib.bindings.insert(mtwt::resolve(label.node), def);\n+                        rib.bindings.insert(label.node, def);\n                     }\n \n                     visit::walk_expr(this, expr);\n                 })\n             }\n \n             ExprKind::Break(Some(label)) | ExprKind::Continue(Some(label)) => {\n-                match self.search_label(mtwt::resolve(label.node)) {\n+                match self.search_label(label.node) {\n                     None => {\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,"}, {"sha": "a9b46ff39c6e3b11d034ff738a7834440327561c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "patch": "@@ -26,7 +26,6 @@ use tokenstream::{TokenTree};\n \n use std::fmt;\n use std::rc::Rc;\n-use std::hash::{Hash, Hasher};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n@@ -46,7 +45,7 @@ pub struct SyntaxContext(pub u32);\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n-#[derive(Clone, Copy, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Ident {\n     pub name: Name,\n     pub ctxt: SyntaxContext\n@@ -93,40 +92,6 @@ impl Ident {\n     }\n }\n \n-impl PartialEq for Ident {\n-    fn eq(&self, other: &Ident) -> bool {\n-        if self.ctxt != other.ctxt {\n-            // There's no one true way to compare Idents. They can be compared\n-            // non-hygienically `id1.name == id2.name`, hygienically\n-            // `mtwt::resolve(id1) == mtwt::resolve(id2)`, or even member-wise\n-            // `(id1.name, id1.ctxt) == (id2.name, id2.ctxt)` depending on the situation.\n-            // Ideally, PartialEq should not be implemented for Ident at all, but that\n-            // would be too impractical, because many larger structures (Token, in particular)\n-            // including Idents as their parts derive PartialEq and use it for non-hygienic\n-            // comparisons. That's why PartialEq is implemented and defaults to non-hygienic\n-            // comparison. Hash is implemented too and is consistent with PartialEq, i.e. only\n-            // the name of Ident is hashed. Still try to avoid comparing idents in your code\n-            // (especially as keys in hash maps), use one of the three methods listed above\n-            // explicitly.\n-            //\n-            // If you see this panic, then some idents from different contexts were compared\n-            // non-hygienically. It's likely a bug. Use one of the three comparison methods\n-            // listed above explicitly.\n-\n-            panic!(\"idents with different contexts are compared with operator `==`: \\\n-                {:?}, {:?}.\", self, other);\n-        }\n-\n-        self.name == other.name\n-    }\n-}\n-\n-impl Hash for Ident {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.name.hash(state)\n-    }\n-}\n-\n impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}#{}\", self.name, self.ctxt.0)"}, {"sha": "7ebcd12cdb9512853b9122c49079f8690a381e65", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "patch": "@@ -26,7 +26,6 @@ use parse::token::{InternedString, intern, str_to_ident};\n use ptr::P;\n use util::small_vector::SmallVector;\n use util::lev_distance::find_best_match_for_name;\n-use ext::mtwt;\n use fold::Folder;\n \n use std::collections::{HashMap, HashSet};\n@@ -483,15 +482,12 @@ pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n pub struct BlockInfo {\n     /// Should macros escape from this scope?\n     pub macros_escape: bool,\n-    /// What are the pending renames?\n-    pub pending_renames: mtwt::RenameList,\n }\n \n impl BlockInfo {\n     pub fn new() -> BlockInfo {\n         BlockInfo {\n             macros_escape: false,\n-            pending_renames: Vec::new(),\n         }\n     }\n }"}, {"sha": "5b5a5d0e5312006b328cddbbaa2c72361146c6c1", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 423, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, PatKind};\n-use ast::{Local, Ident, Mac_, Name, SpannedIdent};\n+use ast::{Block, Crate, Ident, Mac_, Name, PatKind};\n use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast;\n use attr::HasAttrs;\n@@ -23,8 +22,7 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use util::move_map::MoveMap;\n-use parse::token::{fresh_mark, fresh_name, intern, keywords};\n+use parse::token::{fresh_mark, intern, keywords};\n use ptr::P;\n use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n@@ -96,89 +94,15 @@ impl MacroGenerable for Option<P<ast::Expr>> {\n     }\n }\n \n-pub fn expand_expr(mut expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n+pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n     match expr.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n             return expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, fld);\n         }\n-\n-        ast::ExprKind::While(cond, body, opt_ident) => {\n-            let cond = fld.fold_expr(cond);\n-            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            expr.node = ast::ExprKind::While(cond, body, opt_ident);\n-        }\n-\n-        ast::ExprKind::WhileLet(pat, cond, body, opt_ident) => {\n-            let pat = fld.fold_pat(pat);\n-            let cond = fld.fold_expr(cond);\n-\n-            // Hygienic renaming of the body.\n-            let ((body, opt_ident), mut rewritten_pats) =\n-                rename_in_scope(vec![pat],\n-                                fld,\n-                                (body, opt_ident),\n-                                |rename_fld, fld, (body, opt_ident)| {\n-                expand_loop_block(rename_fld.fold_block(body), opt_ident, fld)\n-            });\n-            assert!(rewritten_pats.len() == 1);\n-\n-            expr.node = ast::ExprKind::WhileLet(rewritten_pats.remove(0), cond, body, opt_ident);\n-        }\n-\n-        ast::ExprKind::Loop(loop_block, opt_ident) => {\n-            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            expr.node = ast::ExprKind::Loop(loop_block, opt_ident);\n-        }\n-\n-        ast::ExprKind::ForLoop(pat, head, body, opt_ident) => {\n-            let pat = fld.fold_pat(pat);\n-\n-            // Hygienic renaming of the for loop body (for loop binds its pattern).\n-            let ((body, opt_ident), mut rewritten_pats) =\n-                rename_in_scope(vec![pat],\n-                                fld,\n-                                (body, opt_ident),\n-                                |rename_fld, fld, (body, opt_ident)| {\n-                expand_loop_block(rename_fld.fold_block(body), opt_ident, fld)\n-            });\n-            assert!(rewritten_pats.len() == 1);\n-\n-            let head = fld.fold_expr(head);\n-            expr.node = ast::ExprKind::ForLoop(rewritten_pats.remove(0), head, body, opt_ident);\n-        }\n-\n-        ast::ExprKind::IfLet(pat, sub_expr, body, else_opt) => {\n-            let pat = fld.fold_pat(pat);\n-\n-            // Hygienic renaming of the body.\n-            let (body, mut rewritten_pats) =\n-                rename_in_scope(vec![pat],\n-                                fld,\n-                                body,\n-                                |rename_fld, fld, body| {\n-                fld.fold_block(rename_fld.fold_block(body))\n-            });\n-            assert!(rewritten_pats.len() == 1);\n-\n-            let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n-            let sub_expr = fld.fold_expr(sub_expr);\n-            expr.node = ast::ExprKind::IfLet(rewritten_pats.remove(0), sub_expr, body, else_opt);\n-        }\n-\n-        ast::ExprKind::Closure(capture_clause, fn_decl, block, fn_decl_span) => {\n-            let (rewritten_fn_decl, rewritten_block)\n-                = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n-            expr.node = ast::ExprKind::Closure(capture_clause,\n-                                               rewritten_fn_decl,\n-                                               rewritten_block,\n-                                               fn_decl_span);\n-        }\n-\n-        _ => expr = noop_fold_expr(expr, fld),\n-    };\n-    P(expr)\n+        _ => P(noop_fold_expr(expr, fld)),\n+    }\n }\n \n /// Expand a macro invocation. Returns the result of expansion.\n@@ -327,41 +251,6 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n     fully_expanded\n }\n \n-/// Rename loop label and expand its loop body\n-///\n-/// The renaming procedure for loop is different in the sense that the loop\n-/// body is in a block enclosed by loop head so the renaming of loop label\n-/// must be propagated to the enclosed context.\n-fn expand_loop_block(loop_block: P<Block>,\n-                     opt_ident: Option<SpannedIdent>,\n-                     fld: &mut MacroExpander) -> (P<Block>, Option<SpannedIdent>) {\n-    match opt_ident {\n-        Some(label) => {\n-            let new_label = fresh_name(label.node);\n-            let rename = (label.node, new_label);\n-\n-            // The rename *must not* be added to the pending list of current\n-            // syntax context otherwise an unrelated `break` or `continue` in\n-            // the same context will pick that up in the deferred renaming pass\n-            // and be renamed incorrectly.\n-            let mut rename_list = vec!(rename);\n-            let mut rename_fld = IdentRenamer{renames: &mut rename_list};\n-            let renamed_ident = rename_fld.fold_ident(label.node);\n-\n-            // The rename *must* be added to the enclosed syntax context for\n-            // `break` or `continue` to pick up because by definition they are\n-            // in a block enclosed by loop head.\n-            fld.cx.syntax_env.push_frame();\n-            fld.cx.syntax_env.info().pending_renames.push(rename);\n-            let expanded_block = expand_block_elts(loop_block, fld);\n-            fld.cx.syntax_env.pop_frame();\n-\n-            (expanded_block, Some(Spanned { node: renamed_ident, span: label.span }))\n-        }\n-        None => (fld.fold_block(loop_block), opt_ident)\n-    }\n-}\n-\n // eval $e with a new exts frame.\n // must be a macro so that $e isn't evaluated too early.\n macro_rules! with_exts_frame {\n@@ -381,20 +270,6 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n         .into_iter().map(|i| i.expect_item()).collect()\n }\n \n-/// Expand item_kind\n-fn expand_item_kind(item: ast::ItemKind, fld: &mut MacroExpander) -> ast::ItemKind {\n-    match item {\n-        ast::ItemKind::Fn(decl, unsafety, constness, abi, generics, body) => {\n-            let (rewritten_fn_decl, rewritten_body)\n-                = expand_and_rename_fn_decl_and_block(decl, body, fld);\n-            let expanded_generics = fold::noop_fold_generics(generics,fld);\n-            ast::ItemKind::Fn(rewritten_fn_decl, unsafety, constness, abi,\n-                        expanded_generics, rewritten_body)\n-        }\n-        _ => noop_fold_item_kind(item, fld)\n-    }\n-}\n-\n // does this attribute list contain \"macro_use\" ?\n fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool {\n     for attr in attrs {\n@@ -425,16 +300,9 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n \n /// Expand a stmt\n fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n-    // perform all pending renames\n-    let stmt = {\n-        let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n-        let mut rename_fld = IdentRenamer{renames:pending_renames};\n-        rename_fld.fold_stmt(stmt).expect_one(\"rename_fold didn't return one value\")\n-    };\n-\n     let (mac, style, attrs) = match stmt.node {\n         StmtKind::Mac(mac) => mac.unwrap(),\n-        _ => return expand_non_macro_stmt(stmt, fld)\n+        _ => return noop_fold_stmt(stmt, fld)\n     };\n \n     let mut fully_expanded: SmallVector<ast::Stmt> =\n@@ -458,167 +326,6 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     fully_expanded\n }\n \n-// expand a non-macro stmt. this is essentially the fallthrough for\n-// expand_stmt, above.\n-fn expand_non_macro_stmt(stmt: Stmt, fld: &mut MacroExpander)\n-                         -> SmallVector<Stmt> {\n-    // is it a let?\n-    match stmt.node {\n-        StmtKind::Local(local) => {\n-            // take it apart:\n-            let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n-                // expand the ty since TyKind::FixedLengthVec contains an Expr\n-                // and thus may have a macro use\n-                let expanded_ty = ty.map(|t| fld.fold_ty(t));\n-                // expand the pat (it might contain macro uses):\n-                let expanded_pat = fld.fold_pat(pat);\n-                // find the PatIdents in the pattern:\n-                // oh dear heaven... this is going to include the enum\n-                // names, as well... but that should be okay, as long as\n-                // the new names are gensyms for the old ones.\n-                // generate fresh names, push them to a new pending list\n-                let idents = pattern_bindings(&expanded_pat);\n-                let mut new_pending_renames =\n-                    idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n-                // rewrite the pattern using the new names (the old\n-                // ones have already been applied):\n-                let rewritten_pat = {\n-                    // nested binding to allow borrow to expire:\n-                    let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n-                    rename_fld.fold_pat(expanded_pat)\n-                };\n-                // add them to the existing pending renames:\n-                fld.cx.syntax_env.info().pending_renames\n-                      .extend(new_pending_renames);\n-                Local {\n-                    id: id,\n-                    ty: expanded_ty,\n-                    pat: rewritten_pat,\n-                    // also, don't forget to expand the init:\n-                    init: init.map(|e| fld.fold_expr(e)),\n-                    span: span,\n-                    attrs: fold::fold_thin_attrs(attrs, fld),\n-                }\n-            });\n-            SmallVector::one(Stmt {\n-                id: stmt.id,\n-                node: StmtKind::Local(rewritten_local),\n-                span: stmt.span,\n-            })\n-        }\n-        _ => noop_fold_stmt(stmt, fld),\n-    }\n-}\n-\n-// expand the arm of a 'match', renaming for macro hygiene\n-fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n-    // expand pats... they might contain macro uses:\n-    let expanded_pats = arm.pats.move_map(|pat| fld.fold_pat(pat));\n-    if expanded_pats.is_empty() {\n-        panic!(\"encountered match arm with 0 patterns\");\n-    }\n-\n-    // apply renaming and then expansion to the guard and the body:\n-    let ((rewritten_guard, rewritten_body), rewritten_pats) =\n-        rename_in_scope(expanded_pats,\n-                        fld,\n-                        (arm.guard, arm.body),\n-                        |rename_fld, fld, (ag, ab)|{\n-        let rewritten_guard = ag.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n-        let rewritten_body = fld.fold_expr(rename_fld.fold_expr(ab));\n-        (rewritten_guard, rewritten_body)\n-    });\n-\n-    ast::Arm {\n-        attrs: fold::fold_attrs(arm.attrs, fld),\n-        pats: rewritten_pats,\n-        guard: rewritten_guard,\n-        body: rewritten_body,\n-    }\n-}\n-\n-fn rename_in_scope<X, F>(pats: Vec<P<ast::Pat>>,\n-                         fld: &mut MacroExpander,\n-                         x: X,\n-                         f: F)\n-                         -> (X, Vec<P<ast::Pat>>)\n-    where F: Fn(&mut IdentRenamer, &mut MacroExpander, X) -> X\n-{\n-    // all of the pats must have the same set of bindings, so use the\n-    // first one to extract them and generate new names:\n-    let idents = pattern_bindings(&pats[0]);\n-    let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n-    // apply the renaming, but only to the PatIdents:\n-    let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n-    let rewritten_pats = pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n-\n-    let mut rename_fld = IdentRenamer{ renames:&new_renames };\n-    (f(&mut rename_fld, fld, x), rewritten_pats)\n-}\n-\n-/// A visitor that extracts the PatKind::Ident (binding) paths\n-/// from a given thingy and puts them in a mutable\n-/// array\n-#[derive(Clone)]\n-struct PatIdentFinder {\n-    ident_accumulator: Vec<ast::Ident>\n-}\n-\n-impl Visitor for PatIdentFinder {\n-    fn visit_pat(&mut self, pattern: &ast::Pat) {\n-        match *pattern {\n-            ast::Pat { id: _, node: PatKind::Ident(_, ref path1, ref inner), span: _ } => {\n-                self.ident_accumulator.push(path1.node);\n-                // visit optional subpattern of PatKind::Ident:\n-                if let Some(ref subpat) = *inner {\n-                    self.visit_pat(subpat)\n-                }\n-            }\n-            // use the default traversal for non-PatIdents\n-            _ => visit::walk_pat(self, pattern)\n-        }\n-    }\n-}\n-\n-/// find the PatKind::Ident paths in a pattern\n-fn pattern_bindings(pat: &ast::Pat) -> Vec<ast::Ident> {\n-    let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n-    name_finder.visit_pat(pat);\n-    name_finder.ident_accumulator\n-}\n-\n-/// find the PatKind::Ident paths in a\n-fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n-    let mut pat_idents = PatIdentFinder{ident_accumulator:Vec::new()};\n-    for arg in &fn_decl.inputs {\n-        pat_idents.visit_pat(&arg.pat);\n-    }\n-    pat_idents.ident_accumulator\n-}\n-\n-// expand a block. pushes a new exts_frame, then calls expand_block_elts\n-pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    // see note below about treatment of exts table\n-    with_exts_frame!(fld.cx.syntax_env,false,\n-                     expand_block_elts(blk, fld))\n-}\n-\n-// expand the elements of a block.\n-pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    b.map(|Block {id, stmts, rules, span}| {\n-        let new_stmts = stmts.into_iter().flat_map(|x| {\n-            // perform pending renames and expand macros in the statement\n-            fld.fold_stmt(x).into_iter()\n-        }).collect();\n-        Block {\n-            id: fld.new_id(id),\n-            stmts: new_stmts,\n-            rules: rules,\n-            span: span\n-        }\n-    })\n-}\n-\n fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n     match p.node {\n         PatKind::Mac(_) => {}\n@@ -632,58 +339,6 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n     })\n }\n \n-/// A tree-folder that applies every rename in its (mutable) list\n-/// to every identifier, including both bindings and varrefs\n-/// (and lots of things that will turn out to be neither)\n-pub struct IdentRenamer<'a> {\n-    renames: &'a mtwt::RenameList,\n-}\n-\n-impl<'a> Folder for IdentRenamer<'a> {\n-    fn fold_ident(&mut self, id: Ident) -> Ident {\n-        mtwt::apply_renames(self.renames, id)\n-    }\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n-}\n-\n-/// A tree-folder that applies every rename in its list to\n-/// the idents that are in PatKind::Ident patterns. This is more narrowly\n-/// focused than IdentRenamer, and is needed for FnDecl,\n-/// where we want to rename the args but not the fn name or the generics etc.\n-pub struct PatIdentRenamer<'a> {\n-    renames: &'a mtwt::RenameList,\n-}\n-\n-impl<'a> Folder for PatIdentRenamer<'a> {\n-    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        match pat.node {\n-            PatKind::Ident(..) => {},\n-            _ => return noop_fold_pat(pat, self)\n-        }\n-\n-        pat.map(|ast::Pat {id, node, span}| match node {\n-            PatKind::Ident(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n-                let new_ident = mtwt::apply_renames(self.renames, ident);\n-                let new_node =\n-                    PatKind::Ident(binding_mode,\n-                                  Spanned{span: sp, node: new_ident},\n-                                  sub.map(|p| self.fold_pat(p)));\n-                ast::Pat {\n-                    id: id,\n-                    node: new_node,\n-                    span: span,\n-                }\n-            },\n-            _ => unreachable!()\n-        })\n-    }\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n-}\n-\n fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n     match a {\n         Annotatable::Item(it) => match it.node {\n@@ -781,21 +436,6 @@ fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVe\n fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n                  -> SmallVector<ast::ImplItem> {\n     match ii.node {\n-        ast::ImplItemKind::Method(..) => SmallVector::one(ast::ImplItem {\n-            id: ii.id,\n-            ident: ii.ident,\n-            attrs: ii.attrs,\n-            vis: ii.vis,\n-            defaultness: ii.defaultness,\n-            node: match ii.node {\n-                ast::ImplItemKind::Method(sig, body) => {\n-                    let (sig, body) = expand_and_rename_method(sig, body, fld);\n-                    ast::ImplItemKind::Method(sig, body)\n-                }\n-                _ => unreachable!()\n-            },\n-            span: ii.span,\n-        }),\n         ast::ImplItemKind::Macro(mac) => {\n             expand_mac_invoc(mac, None, ii.attrs, ii.span, fld)\n         }\n@@ -806,61 +446,13 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n fn expand_trait_item(ti: ast::TraitItem, fld: &mut MacroExpander)\n                      -> SmallVector<ast::TraitItem> {\n     match ti.node {\n-        ast::TraitItemKind::Method(_, Some(_)) => {\n-            SmallVector::one(ast::TraitItem {\n-                id: ti.id,\n-                ident: ti.ident,\n-                attrs: ti.attrs,\n-                node: match ti.node  {\n-                    ast::TraitItemKind::Method(sig, Some(body)) => {\n-                        let (sig, body) = expand_and_rename_method(sig, body, fld);\n-                        ast::TraitItemKind::Method(sig, Some(body))\n-                    }\n-                    _ => unreachable!()\n-                },\n-                span: ti.span,\n-            })\n-        }\n         ast::TraitItemKind::Macro(mac) => {\n             expand_mac_invoc(mac, None, ti.attrs, ti.span, fld)\n         }\n         _ => fold::noop_fold_trait_item(ti, fld)\n     }\n }\n \n-/// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n-/// PatIdents in its arguments to perform renaming in the FnDecl and\n-/// the block, returning both the new FnDecl and the new Block.\n-fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Block>,\n-                                       fld: &mut MacroExpander)\n-                                       -> (P<ast::FnDecl>, P<ast::Block>) {\n-    let expanded_decl = fld.fold_fn_decl(fn_decl);\n-    let idents = fn_decl_arg_bindings(&expanded_decl);\n-    let renames =\n-        idents.iter().map(|id| (*id,fresh_name(*id))).collect();\n-    // first, a renamer for the PatIdents, for the fn_decl:\n-    let mut rename_pat_fld = PatIdentRenamer{renames: &renames};\n-    let rewritten_fn_decl = rename_pat_fld.fold_fn_decl(expanded_decl);\n-    // now, a renamer for *all* idents, for the body:\n-    let mut rename_fld = IdentRenamer{renames: &renames};\n-    let rewritten_body = fld.fold_block(rename_fld.fold_block(block));\n-    (rewritten_fn_decl,rewritten_body)\n-}\n-\n-fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n-                            fld: &mut MacroExpander)\n-                            -> (ast::MethodSig, P<ast::Block>) {\n-    let (rewritten_fn_decl, rewritten_body)\n-        = expand_and_rename_fn_decl_and_block(sig.decl, body, fld);\n-    (ast::MethodSig {\n-        generics: fld.fold_generics(sig.generics),\n-        abi: sig.abi,\n-        unsafety: sig.unsafety,\n-        constness: sig.constness,\n-        decl: rewritten_fn_decl\n-    }, rewritten_body)\n-}\n-\n pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n     let t = match t.node.clone() {\n         ast::TyKind::Mac(mac) => {\n@@ -983,25 +575,17 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         result\n     }\n \n-    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n-        expand_item_kind(item, self)\n-    }\n-\n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n         expand_stmt(stmt, self)\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n         let was_in_block = ::std::mem::replace(&mut self.cx.in_block, true);\n-        let result = expand_block(block, self);\n+        let result = with_exts_frame!(self.cx.syntax_env, false, noop_fold_block(block, self));\n         self.cx.in_block = was_in_block;\n         result\n     }\n \n-    fn fold_arm(&mut self, arm: ast::Arm) -> ast::Arm {\n-        expand_arm(arm, self)\n-    }\n-\n     fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n         expand_annotatable(Annotatable::TraitItem(P(i)), self)\n             .into_iter().map(|i| i.expect_trait_item()).collect()"}, {"sha": "a4c698a92261ca73c51dec59794c548edca44bb6", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 3, "deletions": 58, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "patch": "@@ -17,35 +17,27 @@\n \n pub use self::SyntaxContext_::*;\n \n-use ast::{Ident, Mrk, Name, SyntaxContext};\n+use ast::{Mrk, SyntaxContext};\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n \n /// The SCTable contains a table of SyntaxContext_'s. It\n /// represents a flattened tree structure, to avoid having\n /// managed pointers everywhere (that caused an ICE).\n-/// the `marks` and `renames` fields are side-tables\n-/// that ensure that adding the same mark to the same context\n-/// gives you back the same context as before. This should cut\n-/// down on memory use *a lot*; applying a mark to a tree containing\n-/// 50 identifiers would otherwise generate 50 new contexts.\n+/// The `marks` ensures that adding the same mark to the\n+/// same context gives you back the same context as before.\n pub struct SCTable {\n     table: RefCell<Vec<SyntaxContext_>>,\n     marks: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-    renames: RefCell<HashMap<Name,SyntaxContext>>,\n }\n \n #[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, Clone)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n-    Rename (Name),\n }\n \n-/// A list of ident->name renamings\n-pub type RenameList = Vec<(Ident, Name)>;\n-\n /// Extend a syntax context with a given mark\n pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n     with_sctable(|table| apply_mark_internal(m, ctxt, table))\n@@ -63,32 +55,6 @@ fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxCo\n     }\n }\n \n-/// Extend a syntax context with a given rename\n-pub fn apply_rename(from: Ident, to: Name, ident: Ident) -> Ident {\n-    with_sctable(|table| apply_rename_internal(from, to, ident, table))\n-}\n-\n-/// Extend a syntax context with a given rename and sctable (explicit memoization)\n-fn apply_rename_internal(from: Ident, to: Name, ident: Ident, table: &SCTable) -> Ident {\n-    if (ident.name, ident.ctxt) != (from.name, from.ctxt) {\n-        return ident;\n-    }\n-    let ctxt = *table.renames.borrow_mut().entry(to).or_insert_with(|| {\n-        SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Rename(to)))\n-    });\n-    Ident { ctxt: ctxt, ..ident }\n-}\n-\n-/// Apply a list of renamings to a context\n-// if these rename lists get long, it would make sense\n-// to consider memoizing this fold. This may come up\n-// when we add hygiene to item names.\n-pub fn apply_renames(renames: &RenameList, ident: Ident) -> Ident {\n-    renames.iter().fold(ident, |ident, &(from, to)| {\n-        apply_rename(from, to, ident)\n-    })\n-}\n-\n /// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn with_sctable<T, F>(op: F) -> T where\n     F: FnOnce(&SCTable) -> T,\n@@ -102,7 +68,6 @@ fn new_sctable_internal() -> SCTable {\n     SCTable {\n         table: RefCell::new(vec![EmptyCtxt]),\n         marks: RefCell::new(HashMap::new()),\n-        renames: RefCell::new(HashMap::new()),\n     }\n }\n \n@@ -119,7 +84,6 @@ pub fn clear_tables() {\n     with_sctable(|table| {\n         *table.table.borrow_mut() = Vec::new();\n         *table.marks.borrow_mut() = HashMap::new();\n-        *table.renames.borrow_mut() = HashMap::new();\n     });\n }\n \n@@ -128,7 +92,6 @@ pub fn reset_tables() {\n     with_sctable(|table| {\n         *table.table.borrow_mut() = vec![EmptyCtxt];\n         *table.marks.borrow_mut() = HashMap::new();\n-        *table.renames.borrow_mut() = HashMap::new();\n     });\n }\n \n@@ -138,24 +101,6 @@ fn idx_push<T>(vec: &mut Vec<T>, val: T) -> u32 {\n     (vec.len() - 1) as u32\n }\n \n-/// Resolve a syntax object to a name, per MTWT.\n-pub fn resolve(id: Ident) -> Name {\n-    with_sctable(|sctable| {\n-        resolve_internal(id, sctable)\n-    })\n-}\n-\n-/// Resolve a syntax object to a name, per MTWT.\n-/// adding memoization to resolve 500+ seconds in resolve for librustc (!)\n-fn resolve_internal(id: Ident, table: &SCTable) -> Name {\n-    match table.table.borrow()[id.ctxt.0 as usize] {\n-        EmptyCtxt => id.name,\n-        // ignore marks here:\n-        Mark(_, subctxt) => resolve_internal(Ident::new(id.name, subctxt), table),\n-        Rename(name) => name,\n-    }\n-}\n-\n /// Return the outer mark for a context with a mark at the outside.\n /// FAILS when outside is not a mark.\n pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {"}, {"sha": "3b25d38141932637642b802487128ded5512eab8", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "patch": "@@ -15,7 +15,6 @@ pub use self::Lit::*;\n pub use self::Token::*;\n \n use ast::{self, BinOpKind};\n-use ext::mtwt;\n use ptr::P;\n use util::interner::{RcStr, StrInterner};\n use util::interner;\n@@ -313,17 +312,6 @@ impl Token {\n             _ => false,\n         }\n     }\n-\n-    /// Hygienic identifier equality comparison.\n-    ///\n-    /// See `styntax::ext::mtwt`.\n-    pub fn mtwt_eq(&self, other : &Token) -> bool {\n-        match (self, other) {\n-            (&Ident(id1), &Ident(id2)) | (&Lifetime(id1), &Lifetime(id2)) =>\n-                mtwt::resolve(id1) == mtwt::resolve(id2),\n-            _ => *self == *other\n-        }\n-    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash)]"}]}