{"sha": "efca421c4365c1ab65927e388e18b8d91234d2ab", "node_id": "C_kwDOAAsO6NoAKGVmY2E0MjFjNDM2NWMxYWI2NTkyN2UzODhlMThiOGQ5MTIzNGQyYWI", "commit": {"author": {"name": "Eric Sampson", "email": "esampson@eaze.com", "date": "2021-10-06T21:43:37Z"}, "committer": {"name": "Eric Sampson", "email": "esampson@eaze.com", "date": "2021-10-06T21:43:37Z"}, "message": "Refactor to eliminate a vector allocation.", "tree": {"sha": "dd45042151b13504c3e07680fcb83c783589abb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd45042151b13504c3e07680fcb83c783589abb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efca421c4365c1ab65927e388e18b8d91234d2ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efca421c4365c1ab65927e388e18b8d91234d2ab", "html_url": "https://github.com/rust-lang/rust/commit/efca421c4365c1ab65927e388e18b8d91234d2ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efca421c4365c1ab65927e388e18b8d91234d2ab/comments", "author": {"login": "ericsampson", "id": 1183853, "node_id": "MDQ6VXNlcjExODM4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1183853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ericsampson", "html_url": "https://github.com/ericsampson", "followers_url": "https://api.github.com/users/ericsampson/followers", "following_url": "https://api.github.com/users/ericsampson/following{/other_user}", "gists_url": "https://api.github.com/users/ericsampson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ericsampson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ericsampson/subscriptions", "organizations_url": "https://api.github.com/users/ericsampson/orgs", "repos_url": "https://api.github.com/users/ericsampson/repos", "events_url": "https://api.github.com/users/ericsampson/events{/privacy}", "received_events_url": "https://api.github.com/users/ericsampson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ericsampson", "id": 1183853, "node_id": "MDQ6VXNlcjExODM4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1183853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ericsampson", "html_url": "https://github.com/ericsampson", "followers_url": "https://api.github.com/users/ericsampson/followers", "following_url": "https://api.github.com/users/ericsampson/following{/other_user}", "gists_url": "https://api.github.com/users/ericsampson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ericsampson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ericsampson/subscriptions", "organizations_url": "https://api.github.com/users/ericsampson/orgs", "repos_url": "https://api.github.com/users/ericsampson/repos", "events_url": "https://api.github.com/users/ericsampson/events{/privacy}", "received_events_url": "https://api.github.com/users/ericsampson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d77be67f7999d2032ad89dd2ad1c040a9f50388", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d77be67f7999d2032ad89dd2ad1c040a9f50388", "html_url": "https://github.com/rust-lang/rust/commit/0d77be67f7999d2032ad89dd2ad1c040a9f50388"}], "stats": {"total": 70, "additions": 30, "deletions": 40}, "files": [{"sha": "47db002ef9024287406f247217f6cd30fe0a3c96", "filename": "crates/ide/src/annotations.rs", "status": "modified", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/efca421c4365c1ab65927e388e18b8d91234d2ab/crates%2Fide%2Fsrc%2Fannotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efca421c4365c1ab65927e388e18b8d91234d2ab/crates%2Fide%2Fsrc%2Fannotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations.rs?ref=efca421c4365c1ab65927e388e18b8d91234d2ab", "patch": "@@ -64,49 +64,53 @@ pub(crate) fn annotations(\n \n     visit_file_defs(&Semantics::new(db), file_id, &mut |def| match def {\n         Either::Left(def) => {\n-            let (range, ranges_enum_variants) = match def {\n-                hir::ModuleDef::Const(konst) => {\n-                    if config.annotate_references {\n-                        (konst.source(db).and_then(|node| name_range(&node, file_id)), vec![])\n-                    } else {\n-                        (None, vec![])\n-                    }\n+            let range = match def {\n+                hir::ModuleDef::Const(konst) if config.annotate_references => {\n+                    konst.source(db).and_then(|node| name_range(&node, file_id))\n                 }\n-                hir::ModuleDef::Trait(trait_) => {\n-                    if config.annotate_references || config.annotate_impls {\n-                        (trait_.source(db).and_then(|node| name_range(&node, file_id)), vec![])\n-                    } else {\n-                        (None, vec![])\n-                    }\n+                hir::ModuleDef::Trait(trait_)\n+                    if config.annotate_references || config.annotate_impls =>\n+                {\n+                    trait_.source(db).and_then(|node| name_range(&node, file_id))\n                 }\n                 hir::ModuleDef::Adt(adt) => match adt {\n-                    hir::Adt::Enum(enum_) => (\n-                        if config.annotate_references || config.annotate_impls {\n-                            enum_.source(db).and_then(|node| name_range(&node, file_id))\n-                        } else {\n-                            None\n-                        },\n+                    hir::Adt::Enum(enum_) => {\n                         if config.annotate_enum_variant_references {\n                             enum_\n                                 .variants(db)\n                                 .into_iter()\n                                 .map(|variant| {\n                                     variant.source(db).and_then(|node| name_range(&node, file_id))\n                                 })\n-                                .collect()\n+                                .filter_map(std::convert::identity)\n+                                .for_each(|range| {\n+                                    annotations.push(Annotation {\n+                                        range,\n+                                        kind: AnnotationKind::HasReferences {\n+                                            position: FilePosition {\n+                                                file_id,\n+                                                offset: range.start(),\n+                                            },\n+                                            data: None,\n+                                        },\n+                                    })\n+                                })\n+                        }\n+                        if config.annotate_references || config.annotate_impls {\n+                            enum_.source(db).and_then(|node| name_range(&node, file_id))\n                         } else {\n-                            vec![]\n-                        },\n-                    ),\n+                            None\n+                        }\n+                    }\n                     _ => {\n                         if config.annotate_references || config.annotate_impls {\n-                            (adt.source(db).and_then(|node| name_range(&node, file_id)), vec![])\n+                            adt.source(db).and_then(|node| name_range(&node, file_id))\n                         } else {\n-                            (None, vec![])\n+                            None\n                         }\n                     }\n                 },\n-                _ => (None, vec![]),\n+                _ => None,\n             };\n \n             let (range, offset) = match range {\n@@ -133,20 +137,6 @@ pub(crate) fn annotations(\n                 });\n             }\n \n-            if config.annotate_enum_variant_references {\n-                for range_enum_variant in\n-                    ranges_enum_variants.into_iter().filter_map(std::convert::identity)\n-                {\n-                    annotations.push(Annotation {\n-                        range: range_enum_variant,\n-                        kind: AnnotationKind::HasReferences {\n-                            position: FilePosition { file_id, offset: range_enum_variant.start() },\n-                            data: None,\n-                        },\n-                    });\n-                }\n-            }\n-\n             fn name_range<T: HasName>(node: &InFile<T>, file_id: FileId) -> Option<TextRange> {\n                 if node.file_id == file_id.into() {\n                     node.value.name().map(|it| it.syntax().text_range())"}]}