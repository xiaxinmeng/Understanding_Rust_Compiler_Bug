{"sha": "ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNGZhYzAxYjVlMjA3ZGYwZjBjN2UwZWE5NjRiZDMwODg4MjZkMjc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-11T21:50:04Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-13T23:52:50Z"}, "message": "Rename Send trait to Owned", "tree": {"sha": "abae4bd8b385afdfbba28988560992683102970b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abae4bd8b385afdfbba28988560992683102970b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "html_url": "https://github.com/rust-lang/rust/commit/ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a277081ee481174cd28f7e85aaf1c4de912cbf4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a277081ee481174cd28f7e85aaf1c4de912cbf4f", "html_url": "https://github.com/rust-lang/rust/commit/a277081ee481174cd28f7e85aaf1c4de912cbf4f"}], "stats": {"total": 569, "additions": 290, "deletions": 279}, "files": [{"sha": "0f3c7fc4edc8949ed9748c0bf7874eb5383ee556", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -57,7 +57,7 @@ use libc::size_t;\n  * transmitted. If a port value is copied, both copies refer to the same\n  * port.  Ports may be associated with multiple `chan`s.\n  */\n-pub enum Port<T: Send> {\n+pub enum Port<T: Owned> {\n     Port_(@PortPtr<T>)\n }\n \n@@ -73,16 +73,16 @@ pub enum Port<T: Send> {\n  * data will be silently dropped.  Channels may be duplicated and\n  * themselves transmitted over other channels.\n  */\n-pub enum Chan<T: Send> {\n+pub enum Chan<T: Owned> {\n     Chan_(port_id)\n }\n \n /// Constructs a port\n-pub fn Port<T: Send>() -> Port<T> {\n+pub fn Port<T: Owned>() -> Port<T> {\n     Port_(@PortPtr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n }\n \n-impl<T: Send> Port<T> {\n+impl<T: Owned> Port<T> {\n \n     fn chan() -> Chan<T> { Chan(&self) }\n     fn send(v: T) { self.chan().send(move v) }\n@@ -91,7 +91,7 @@ impl<T: Send> Port<T> {\n \n }\n \n-impl<T: Send> Chan<T> {\n+impl<T: Owned> Chan<T> {\n \n     fn chan() -> Chan<T> { self }\n     fn send(v: T) { send(self, move v) }\n@@ -101,12 +101,12 @@ impl<T: Send> Chan<T> {\n }\n \n /// Open a new receiving channel for the duration of a function\n-pub fn listen<T: Send, U>(f: fn(Chan<T>) -> U) -> U {\n+pub fn listen<T: Owned, U>(f: fn(Chan<T>) -> U) -> U {\n     let po = Port();\n     f(po.chan())\n }\n \n-struct PortPtr<T:Send> {\n+struct PortPtr<T:Owned> {\n     po: *rust_port,\n   drop unsafe {\n       do task::unkillable {\n@@ -130,7 +130,7 @@ struct PortPtr<T:Send> {\n   }\n }\n \n-fn PortPtr<T: Send>(po: *rust_port) -> PortPtr<T> {\n+fn PortPtr<T: Owned>(po: *rust_port) -> PortPtr<T> {\n     PortPtr {\n         po: po\n     }\n@@ -144,7 +144,7 @@ fn PortPtr<T: Send>(po: *rust_port) -> PortPtr<T> {\n  * Fails if the port is detached or dead. Fails if the port\n  * is owned by a different task.\n  */\n-fn as_raw_port<T: Send, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n+fn as_raw_port<T: Owned, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n \n     struct PortRef {\n         p: *rust_port,\n@@ -176,15 +176,15 @@ fn as_raw_port<T: Send, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n  * Constructs a channel. The channel is bound to the port used to\n  * construct it.\n  */\n-pub fn Chan<T: Send>(p: &Port<T>) -> Chan<T> {\n+pub fn Chan<T: Owned>(p: &Port<T>) -> Chan<T> {\n     Chan_(rustrt::get_port_id((**p).po))\n }\n \n /**\n  * Sends data over a channel. The sent data is moved into the channel,\n  * whereupon the caller loses access to it.\n  */\n-pub fn send<T: Send>(ch: Chan<T>, data: T) {\n+pub fn send<T: Owned>(ch: Chan<T>, data: T) {\n     let Chan_(p) = ch;\n     let data_ptr = ptr::addr_of(&data) as *();\n     let res = rustrt::rust_port_id_send(p, data_ptr);\n@@ -199,22 +199,22 @@ pub fn send<T: Send>(ch: Chan<T>, data: T) {\n  * Receive from a port.  If no data is available on the port then the\n  * task will block until data becomes available.\n  */\n-pub fn recv<T: Send>(p: Port<T>) -> T { recv_((**p).po) }\n+pub fn recv<T: Owned>(p: Port<T>) -> T { recv_((**p).po) }\n \n /// Returns true if there are messages available\n-pub fn peek<T: Send>(p: Port<T>) -> bool { peek_((**p).po) }\n+pub fn peek<T: Owned>(p: Port<T>) -> bool { peek_((**p).po) }\n \n #[doc(hidden)]\n-pub fn recv_chan<T: Send>(ch: comm::Chan<T>) -> T {\n+pub fn recv_chan<T: Owned>(ch: comm::Chan<T>) -> T {\n     as_raw_port(ch, |x|recv_(x))\n }\n \n-fn peek_chan<T: Send>(ch: comm::Chan<T>) -> bool {\n+fn peek_chan<T: Owned>(ch: comm::Chan<T>) -> bool {\n     as_raw_port(ch, |x|peek_(x))\n }\n \n /// Receive on a raw port pointer\n-fn recv_<T: Send>(p: *rust_port) -> T {\n+fn recv_<T: Owned>(p: *rust_port) -> T {\n     let yield = 0;\n     let yieldp = ptr::addr_of(&yield);\n     let mut res;\n@@ -240,7 +240,7 @@ fn peek_(p: *rust_port) -> bool {\n }\n \n /// Receive on one of two ports\n-pub fn select2<A: Send, B: Send>(p_a: Port<A>, p_b: Port<B>)\n+pub fn select2<A: Owned, B: Owned>(p_a: Port<A>, p_b: Port<B>)\n     -> Either<A, B> {\n     let ports = ~[(**p_a).po, (**p_b).po];\n     let yield = 0, yieldp = ptr::addr_of(&yield);"}, {"sha": "a30567639a9776222505c728801b067944d0b78a", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -167,7 +167,7 @@ pub mod util;\n \n /* Reexported core operators */\n \n-pub use kinds::{Const, Copy, Send, Durable};\n+pub use kinds::{Const, Copy, Owned, Durable};\n pub use ops::{Drop};\n pub use ops::{Add, Sub, Mul, Div, Modulo, Neg};\n pub use ops::{BitAnd, BitOr, BitXor};"}, {"sha": "c4d500bbafadbc29f94d319542490c2bb12966db", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -24,7 +24,7 @@ The 4 kinds are\n   scalar types and managed pointers, and exludes owned pointers. It\n   also excludes types that implement `Drop`.\n \n-* Send - owned types and types containing owned types.  These types\n+* Owned - owned types and types containing owned types.  These types\n   may be transferred across task boundaries.\n \n * Const - types that are deeply immutable. Const types are used for\n@@ -44,8 +44,17 @@ pub trait Copy {\n     // Empty.\n }\n \n+#[cfg(stage0)]\n #[lang=\"send\"]\n-pub trait Send {\n+pub trait Owned {\n+    // Empty.\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+#[lang=\"owned\"]\n+pub trait Owned {\n     // Empty.\n }\n "}, {"sha": "914530c0653097995af98f0128129f0755c47fc1", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -131,7 +131,7 @@ pub fn BufferHeader() -> BufferHeader{\n \n // This is for protocols to associate extra data to thread around.\n #[doc(hidden)]\n-type Buffer<T: Send> = {\n+type Buffer<T: Owned> = {\n     header: BufferHeader,\n     data: T,\n };\n@@ -180,13 +180,13 @@ impl PacketHeader {\n         reinterpret_cast(&self.buffer)\n     }\n \n-    fn set_buffer<T: Send>(b: ~Buffer<T>) unsafe {\n+    fn set_buffer<T: Owned>(b: ~Buffer<T>) unsafe {\n         self.buffer = reinterpret_cast(&b);\n     }\n }\n \n #[doc(hidden)]\n-pub type Packet<T: Send> = {\n+pub type Packet<T: Owned> = {\n     header: PacketHeader,\n     mut payload: Option<T>,\n };\n@@ -197,22 +197,22 @@ pub trait HasBuffer {\n     fn set_buffer_(b: *libc::c_void);\n }\n \n-impl<T: Send> Packet<T>: HasBuffer {\n+impl<T: Owned> Packet<T>: HasBuffer {\n     fn set_buffer_(b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n }\n \n #[doc(hidden)]\n-pub fn mk_packet<T: Send>() -> Packet<T> {\n+pub fn mk_packet<T: Owned>() -> Packet<T> {\n     {\n         header: PacketHeader(),\n         mut payload: None\n     }\n }\n \n #[doc(hidden)]\n-fn unibuffer<T: Send>() -> ~Buffer<Packet<T>> {\n+fn unibuffer<T: Owned>() -> ~Buffer<Packet<T>> {\n     let b = ~{\n         header: BufferHeader(),\n         data: {\n@@ -228,7 +228,7 @@ fn unibuffer<T: Send>() -> ~Buffer<Packet<T>> {\n }\n \n #[doc(hidden)]\n-pub fn packet<T: Send>() -> *Packet<T> {\n+pub fn packet<T: Owned>() -> *Packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(&(b.data));\n     // We'll take over memory management from here.\n@@ -237,7 +237,7 @@ pub fn packet<T: Send>() -> *Packet<T> {\n }\n \n #[doc(hidden)]\n-pub fn entangle_buffer<T: Send, Tstart: Send>(\n+pub fn entangle_buffer<T: Owned, Tstart: Owned>(\n     buffer: ~Buffer<T>,\n     init: fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n@@ -329,12 +329,12 @@ fn swap_state_rel(dst: &mut State, src: State) -> State {\n }\n \n #[doc(hidden)]\n-pub unsafe fn get_buffer<T: Send>(p: *PacketHeader) -> ~Buffer<T> {\n+pub unsafe fn get_buffer<T: Owned>(p: *PacketHeader) -> ~Buffer<T> {\n     transmute((*p).buf_header())\n }\n \n // This could probably be done with SharedMutableState to avoid move_it!().\n-struct BufferResource<T: Send> {\n+struct BufferResource<T: Owned> {\n     buffer: ~Buffer<T>,\n \n     drop unsafe {\n@@ -354,7 +354,7 @@ struct BufferResource<T: Send> {\n     }\n }\n \n-fn BufferResource<T: Send>(b: ~Buffer<T>) -> BufferResource<T> {\n+fn BufferResource<T: Owned>(b: ~Buffer<T>) -> BufferResource<T> {\n     //let p = ptr::addr_of(*b);\n     //error!(\"take %?\", p);\n     atomic_add_acq(&mut b.header.ref_count, 1);\n@@ -366,7 +366,7 @@ fn BufferResource<T: Send>(b: ~Buffer<T>) -> BufferResource<T> {\n }\n \n #[doc(hidden)]\n-pub fn send<T: Send, Tbuffer: Send>(p: SendPacketBuffered<T, Tbuffer>,\n+pub fn send<T: Owned, Tbuffer: Owned>(p: SendPacketBuffered<T, Tbuffer>,\n                                     payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n@@ -410,7 +410,8 @@ pub fn send<T: Send, Tbuffer: Send>(p: SendPacketBuffered<T, Tbuffer>,\n Fails if the sender closes the connection.\n \n */\n-pub fn recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>) -> T {\n+pub fn recv<T: Owned, Tbuffer: Owned>(\n+    p: RecvPacketBuffered<T, Tbuffer>) -> T {\n     option::unwrap_expect(try_recv(move p), \"connection closed\")\n }\n \n@@ -420,7 +421,7 @@ Returns `None` if the sender has closed the connection without sending\n a message, or `Some(T)` if a message was received.\n \n */\n-pub fn try_recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>)\n+pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     -> Option<T>\n {\n     let p_ = p.unwrap();\n@@ -519,22 +520,22 @@ pub fn try_recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>)\n }\n \n /// Returns true if messages are available.\n-pub pure fn peek<T: Send, Tb: Send>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n+pub pure fn peek<T: Owned, Tb: Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     match unsafe {(*p.header()).state} {\n       Empty | Terminated => false,\n       Blocked => fail ~\"peeking on blocked packet\",\n       Full => true\n     }\n }\n \n-impl<T: Send, Tb: Send> RecvPacketBuffered<T, Tb>: Peekable<T> {\n+impl<T: Owned, Tb: Owned> RecvPacketBuffered<T, Tb>: Peekable<T> {\n     pure fn peek() -> bool {\n         peek(&self)\n     }\n }\n \n #[doc(hidden)]\n-fn sender_terminate<T: Send>(p: *Packet<T>) {\n+fn sender_terminate<T: Owned>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n@@ -563,7 +564,7 @@ fn sender_terminate<T: Send>(p: *Packet<T>) {\n }\n \n #[doc(hidden)]\n-fn receiver_terminate<T: Send>(p: *Packet<T>) {\n+fn receiver_terminate<T: Owned>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n@@ -671,7 +672,7 @@ Sometimes messages will be available on both endpoints at once. In\n this case, `select2` may return either `left` or `right`.\n \n */\n-pub fn select2<A: Send, Ab: Send, B: Send, Bb: Send>(\n+pub fn select2<A: Owned, Ab: Owned, B: Owned, Bb: Owned>(\n     a: RecvPacketBuffered<A, Ab>,\n     b: RecvPacketBuffered<B, Bb>)\n     -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n@@ -714,7 +715,7 @@ pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n  list of the remaining endpoints.\n \n */\n-pub fn select<T: Send, Tb: Send>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n+pub fn select<T: Owned, Tb: Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n     -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n@@ -728,14 +729,14 @@ pub fn select<T: Send, Tb: Send>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n message.\n \n */\n-pub type SendPacket<T: Send> = SendPacketBuffered<T, Packet<T>>;\n+pub type SendPacket<T: Owned> = SendPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-pub fn SendPacket<T: Send>(p: *Packet<T>) -> SendPacket<T> {\n+pub fn SendPacket<T: Owned>(p: *Packet<T>) -> SendPacket<T> {\n     SendPacketBuffered(p)\n }\n \n-pub struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n+pub struct SendPacketBuffered<T: Owned, Tbuffer: Owned> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n     drop {\n@@ -754,7 +755,7 @@ pub struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n     }\n }\n \n-pub fn SendPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n+pub fn SendPacketBuffered<T: Owned, Tbuffer: Owned>(p: *Packet<T>)\n     -> SendPacketBuffered<T, Tbuffer> {\n         //debug!(\"take send %?\", p);\n     SendPacketBuffered {\n@@ -766,7 +767,7 @@ pub fn SendPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n     }\n }\n \n-impl<T: Send, Tbuffer: Send> SendPacketBuffered<T, Tbuffer> {\n+impl<T: Owned, Tbuffer: Owned> SendPacketBuffered<T, Tbuffer> {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n@@ -795,14 +796,14 @@ impl<T: Send, Tbuffer: Send> SendPacketBuffered<T, Tbuffer> {\n \n /// Represents the receive end of a pipe. It can receive exactly one\n /// message.\n-pub type RecvPacket<T: Send> = RecvPacketBuffered<T, Packet<T>>;\n+pub type RecvPacket<T: Owned> = RecvPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-pub fn RecvPacket<T: Send>(p: *Packet<T>) -> RecvPacket<T> {\n+pub fn RecvPacket<T: Owned>(p: *Packet<T>) -> RecvPacket<T> {\n     RecvPacketBuffered(p)\n }\n \n-pub struct RecvPacketBuffered<T: Send, Tbuffer: Send> {\n+pub struct RecvPacketBuffered<T: Owned, Tbuffer: Owned> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n     drop {\n@@ -821,7 +822,7 @@ pub struct RecvPacketBuffered<T: Send, Tbuffer: Send> {\n     }\n }\n \n-impl<T: Send, Tbuffer: Send> RecvPacketBuffered<T, Tbuffer> {\n+impl<T: Owned, Tbuffer: Owned> RecvPacketBuffered<T, Tbuffer> {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n@@ -836,7 +837,7 @@ impl<T: Send, Tbuffer: Send> RecvPacketBuffered<T, Tbuffer> {\n     }\n }\n \n-impl<T: Send, Tbuffer: Send> RecvPacketBuffered<T, Tbuffer> : Selectable {\n+impl<T: Owned, Tbuffer: Owned> RecvPacketBuffered<T, Tbuffer> : Selectable {\n     pure fn header() -> *PacketHeader {\n         match self.p {\n           Some(packet) => unsafe {\n@@ -850,7 +851,7 @@ impl<T: Send, Tbuffer: Send> RecvPacketBuffered<T, Tbuffer> : Selectable {\n     }\n }\n \n-pub fn RecvPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n+pub fn RecvPacketBuffered<T: Owned, Tbuffer: Owned>(p: *Packet<T>)\n     -> RecvPacketBuffered<T, Tbuffer> {\n     //debug!(\"take recv %?\", p);\n     RecvPacketBuffered {\n@@ -863,7 +864,7 @@ pub fn RecvPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n }\n \n #[doc(hidden)]\n-pub fn entangle<T: Send>() -> (SendPacket<T>, RecvPacket<T>) {\n+pub fn entangle<T: Owned>() -> (SendPacket<T>, RecvPacket<T>) {\n     let p = packet();\n     (SendPacket(p), RecvPacket(p))\n }\n@@ -875,7 +876,7 @@ endpoint. The send endpoint is returned to the caller and the receive\n endpoint is passed to the new task.\n \n */\n-pub fn spawn_service<T: Send, Tb: Send>(\n+pub fn spawn_service<T: Owned, Tb: Owned>(\n     init: extern fn() -> (SendPacketBuffered<T, Tb>,\n                           RecvPacketBuffered<T, Tb>),\n     service: fn~(v: RecvPacketBuffered<T, Tb>))\n@@ -899,7 +900,7 @@ pub fn spawn_service<T: Send, Tb: Send>(\n receive state.\n \n */\n-pub fn spawn_service_recv<T: Send, Tb: Send>(\n+pub fn spawn_service_recv<T: Owned, Tb: Owned>(\n     init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                           SendPacketBuffered<T, Tb>),\n     service: fn~(v: SendPacketBuffered<T, Tb>))\n@@ -922,7 +923,7 @@ pub fn spawn_service_recv<T: Send, Tb: Send>(\n // Streams - Make pipes a little easier in general.\n \n proto! streamp (\n-    Open:send<T: Send> {\n+    Open:send<T: Owned> {\n         data(T) -> Open<T>\n     }\n )\n@@ -958,18 +959,18 @@ pub trait Peekable<T> {\n }\n \n #[doc(hidden)]\n-type Chan_<T:Send> = { mut endp: Option<streamp::client::Open<T>> };\n+type Chan_<T:Owned> = { mut endp: Option<streamp::client::Open<T>> };\n \n /// An endpoint that can send many messages.\n-pub enum Chan<T:Send> {\n+pub enum Chan<T:Owned> {\n     Chan_(Chan_<T>)\n }\n \n #[doc(hidden)]\n-type Port_<T:Send> = { mut endp: Option<streamp::server::Open<T>> };\n+type Port_<T:Owned> = { mut endp: Option<streamp::server::Open<T>> };\n \n /// An endpoint that can receive many messages.\n-pub enum Port<T:Send> {\n+pub enum Port<T:Owned> {\n     Port_(Port_<T>)\n }\n \n@@ -978,13 +979,13 @@ pub enum Port<T:Send> {\n These allow sending or receiving an unlimited number of messages.\n \n */\n-pub fn stream<T:Send>() -> (Port<T>, Chan<T>) {\n+pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n     let (c, s) = streamp::init();\n \n     (Port_({ mut endp: Some(move s) }), Chan_({ mut endp: Some(move c) }))\n }\n \n-impl<T: Send> Chan<T>: GenericChan<T> {\n+impl<T: Owned> Chan<T>: GenericChan<T> {\n     fn send(x: T) {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -993,7 +994,7 @@ impl<T: Send> Chan<T>: GenericChan<T> {\n     }\n }\n \n-impl<T: Send> Chan<T>: GenericSmartChan<T> {\n+impl<T: Owned> Chan<T>: GenericSmartChan<T> {\n \n     fn try_send(x: T) -> bool {\n         let mut endp = None;\n@@ -1008,7 +1009,7 @@ impl<T: Send> Chan<T>: GenericSmartChan<T> {\n     }\n }\n \n-impl<T: Send> Port<T>: GenericPort<T> {\n+impl<T: Owned> Port<T>: GenericPort<T> {\n     fn recv() -> T {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -1030,7 +1031,7 @@ impl<T: Send> Port<T>: GenericPort<T> {\n     }\n }\n \n-impl<T: Send> Port<T>: Peekable<T> {\n+impl<T: Owned> Port<T>: Peekable<T> {\n     pure fn peek() -> bool unsafe {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -1043,7 +1044,7 @@ impl<T: Send> Port<T>: Peekable<T> {\n     }\n }\n \n-impl<T: Send> Port<T>: Selectable {\n+impl<T: Owned> Port<T>: Selectable {\n     pure fn header() -> *PacketHeader unsafe {\n         match self.endp {\n           Some(ref endp) => endp.header(),\n@@ -1053,17 +1054,17 @@ impl<T: Send> Port<T>: Selectable {\n }\n \n /// Treat many ports as one.\n-pub struct PortSet<T: Send> {\n+pub struct PortSet<T: Owned> {\n     mut ports: ~[pipes::Port<T>],\n }\n \n-pub fn PortSet<T: Send>() -> PortSet<T>{\n+pub fn PortSet<T: Owned>() -> PortSet<T>{\n     PortSet {\n         ports: ~[]\n     }\n }\n \n-impl<T: Send> PortSet<T> {\n+impl<T: Owned> PortSet<T> {\n \n     fn add(port: pipes::Port<T>) {\n         self.ports.push(move port)\n@@ -1076,7 +1077,7 @@ impl<T: Send> PortSet<T> {\n     }\n }\n \n-impl<T: Send> PortSet<T> : GenericPort<T> {\n+impl<T: Owned> PortSet<T> : GenericPort<T> {\n \n     fn try_recv() -> Option<T> {\n         let mut result = None;\n@@ -1106,7 +1107,7 @@ impl<T: Send> PortSet<T> : GenericPort<T> {\n \n }\n \n-impl<T: Send> PortSet<T> : Peekable<T> {\n+impl<T: Owned> PortSet<T> : Peekable<T> {\n     pure fn peek() -> bool {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n@@ -1118,9 +1119,9 @@ impl<T: Send> PortSet<T> : Peekable<T> {\n }\n \n /// A channel that can be shared between many senders.\n-pub type SharedChan<T: Send> = private::Exclusive<Chan<T>>;\n+pub type SharedChan<T: Owned> = private::Exclusive<Chan<T>>;\n \n-impl<T: Send> SharedChan<T>: GenericChan<T> {\n+impl<T: Owned> SharedChan<T>: GenericChan<T> {\n     fn send(x: T) {\n         let mut xx = Some(move x);\n         do self.with_imm |chan| {\n@@ -1131,7 +1132,7 @@ impl<T: Send> SharedChan<T>: GenericChan<T> {\n     }\n }\n \n-impl<T: Send> SharedChan<T>: GenericSmartChan<T> {\n+impl<T: Owned> SharedChan<T>: GenericSmartChan<T> {\n     fn try_send(x: T) -> bool {\n         let mut xx = Some(move x);\n         do self.with_imm |chan| {\n@@ -1143,19 +1144,19 @@ impl<T: Send> SharedChan<T>: GenericSmartChan<T> {\n }\n \n /// Converts a `chan` into a `shared_chan`.\n-pub fn SharedChan<T:Send>(c: Chan<T>) -> SharedChan<T> {\n+pub fn SharedChan<T:Owned>(c: Chan<T>) -> SharedChan<T> {\n     private::exclusive(move c)\n }\n \n /// Receive a message from one of two endpoints.\n-pub trait Select2<T: Send, U: Send> {\n+pub trait Select2<T: Owned, U: Owned> {\n     /// Receive a message or return `None` if a connection closes.\n     fn try_select() -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n     fn select() -> Either<T, U>;\n }\n \n-impl<T: Send, U: Send,\n+impl<T: Owned, U: Owned,\n      Left: Selectable GenericPort<T>,\n      Right: Selectable GenericPort<U>>\n     (Left, Right): Select2<T, U> {\n@@ -1180,32 +1181,32 @@ impl<T: Send, U: Send,\n }\n \n proto! oneshot (\n-    Oneshot:send<T:Send> {\n+    Oneshot:send<T:Owned> {\n         send(T) -> !\n     }\n )\n \n /// The send end of a oneshot pipe.\n-pub type ChanOne<T: Send> = oneshot::client::Oneshot<T>;\n+pub type ChanOne<T: Owned> = oneshot::client::Oneshot<T>;\n /// The receive end of a oneshot pipe.\n-pub type PortOne<T: Send> = oneshot::server::Oneshot<T>;\n+pub type PortOne<T: Owned> = oneshot::server::Oneshot<T>;\n \n /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-pub fn oneshot<T: Send>() -> (ChanOne<T>, PortOne<T>) {\n+pub fn oneshot<T: Owned>() -> (ChanOne<T>, PortOne<T>) {\n     oneshot::init()\n }\n \n /**\n  * Receive a message from a oneshot pipe, failing if the connection was\n  * closed.\n  */\n-pub fn recv_one<T: Send>(port: PortOne<T>) -> T {\n+pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n     let oneshot::send(message) = recv(move port);\n     move message\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n-pub fn try_recv_one<T: Send> (port: PortOne<T>) -> Option<T> {\n+pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n     let message = try_recv(move port);\n \n     if message.is_none() { None }\n@@ -1216,15 +1217,15 @@ pub fn try_recv_one<T: Send> (port: PortOne<T>) -> Option<T> {\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n-pub fn send_one<T: Send>(chan: ChanOne<T>, data: T) {\n+pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n     oneshot::client::send(move chan, move data);\n }\n \n /**\n  * Send a message on a oneshot pipe, or return false if the connection was\n  * closed.\n  */\n-pub fn try_send_one<T: Send>(chan: ChanOne<T>, data: T)\n+pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n         -> bool {\n     oneshot::client::try_send(move chan, move data).is_some()\n }"}, {"sha": "1f3d6ba75bea1ce90addfd048fecaea1ba8fb467", "filename": "src/libcore/private.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -52,7 +52,7 @@ fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n  * or, if no channel exists creates and installs a new channel and sets up a\n  * new task to receive from it.\n  */\n-pub unsafe fn chan_from_global_ptr<T: Send>(\n+pub unsafe fn chan_from_global_ptr<T: Owned>(\n     global: GlobalPtr,\n     task_fn: fn() -> task::TaskBuilder,\n     f: fn~(comm::Port<T>)\n@@ -350,7 +350,7 @@ fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n     }\n }\n \n-pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n+pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n         mut ptr:      Option<~ArcData<T>>,\n@@ -421,9 +421,9 @@ pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n  * Data races between tasks can result in crashes and, with sufficient\n  * cleverness, arbitrary type coercion.\n  */\n-pub type SharedMutableState<T: Send> = ArcDestruct<T>;\n+pub type SharedMutableState<T: Owned> = ArcDestruct<T>;\n \n-pub unsafe fn shared_mutable_state<T: Send>(data: T) ->\n+pub unsafe fn shared_mutable_state<T: Owned>(data: T) ->\n         SharedMutableState<T> {\n     let data = ~ArcData { count: 1, unwrapper: 0, data: Some(move data) };\n     unsafe {\n@@ -433,7 +433,7 @@ pub unsafe fn shared_mutable_state<T: Send>(data: T) ->\n }\n \n #[inline(always)]\n-pub unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n+pub unsafe fn get_shared_mutable_state<T: Owned>(rc: &a/SharedMutableState<T>)\n         -> &a/mut T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n@@ -445,7 +445,7 @@ pub unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n     }\n }\n #[inline(always)]\n-pub unsafe fn get_shared_immutable_state<T: Send>(\n+pub unsafe fn get_shared_immutable_state<T: Owned>(\n         rc: &a/SharedMutableState<T>) -> &a/T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n@@ -457,7 +457,7 @@ pub unsafe fn get_shared_immutable_state<T: Send>(\n     }\n }\n \n-pub unsafe fn clone_shared_mutable_state<T: Send>(rc: &SharedMutableState<T>)\n+pub unsafe fn clone_shared_mutable_state<T: Owned>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n@@ -506,27 +506,27 @@ impl LittleLock {\n     }\n }\n \n-struct ExData<T: Send> { lock: LittleLock, mut failed: bool, mut data: T, }\n+struct ExData<T: Owned> { lock: LittleLock, mut failed: bool, mut data: T, }\n /**\n  * An arc over mutable data that is protected by a lock. For library use only.\n  */\n-pub struct Exclusive<T: Send> { x: SharedMutableState<ExData<T>> }\n+pub struct Exclusive<T: Owned> { x: SharedMutableState<ExData<T>> }\n \n-pub fn exclusive<T:Send >(user_data: T) -> Exclusive<T> {\n+pub fn exclusive<T:Owned >(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n         lock: LittleLock(), mut failed: false, mut data: move user_data\n     };\n     Exclusive { x: unsafe { shared_mutable_state(move data) } }\n }\n \n-impl<T: Send> Exclusive<T>: Clone {\n+impl<T: Owned> Exclusive<T>: Clone {\n     // Duplicate an exclusive ARC, as std::arc::clone.\n     fn clone(&self) -> Exclusive<T> {\n         Exclusive { x: unsafe { clone_shared_mutable_state(&self.x) } }\n     }\n }\n \n-impl<T: Send> Exclusive<T> {\n+impl<T: Owned> Exclusive<T> {\n     // Exactly like std::arc::mutex_arc,access(), but with the little_lock\n     // instead of a proper mutex. Same reason for being unsafe.\n     //\n@@ -556,7 +556,7 @@ impl<T: Send> Exclusive<T> {\n }\n \n // FIXME(#3724) make this a by-move method on the exclusive\n-pub fn unwrap_exclusive<T: Send>(arc: Exclusive<T>) -> T {\n+pub fn unwrap_exclusive<T: Owned>(arc: Exclusive<T>) -> T {\n     let Exclusive { x: x } = move arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let ExData { data: data, _ } = move inner;"}, {"sha": "1ba2c1dc2c112c955b4d0ff4c3b29500b8a1da74", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -425,7 +425,7 @@ impl TaskBuilder {\n         spawn::spawn_raw(move opts, (x.gen_body)(move f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A: Send>(arg: A, f: fn~(v: A)) {\n+    fn spawn_with<A: Owned>(arg: A, f: fn~(v: A)) {\n         let arg = ~mut Some(move arg);\n         do self.spawn |move arg, move f| {\n             f(option::swap_unwrap(arg))\n@@ -443,7 +443,7 @@ impl TaskBuilder {\n      * otherwise be required to establish communication from the parent\n      * to the child.\n      */\n-    fn spawn_listener<A: Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+    fn spawn_listener<A: Owned>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n         let setup_po = comm::Port();\n         let setup_ch = comm::Chan(&setup_po);\n         do self.spawn |move f| {\n@@ -458,7 +458,7 @@ impl TaskBuilder {\n     /**\n      * Runs a new task, setting up communication in both directions\n      */\n-    fn spawn_conversation<A: Send, B: Send>\n+    fn spawn_conversation<A: Owned, B: Owned>\n         (f: fn~(comm::Port<A>, comm::Chan<B>))\n         -> (comm::Port<B>, comm::Chan<A>) {\n         let from_child = comm::Port();\n@@ -482,7 +482,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T: Send>(f: fn~() -> T) -> Result<T,()> {\n+    fn try<T: Owned>(f: fn~() -> T) -> Result<T,()> {\n         let po = comm::Port();\n         let ch = comm::Chan(&po);\n         let mut result = None;\n@@ -552,7 +552,7 @@ pub fn spawn_supervised(f: fn~()) {\n     task().supervised().spawn(move f)\n }\n \n-pub fn spawn_with<A:Send>(arg: A, f: fn~(v: A)) {\n+pub fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n     /*!\n      * Runs a task, while transfering ownership of one argument to the\n      * child.\n@@ -566,7 +566,7 @@ pub fn spawn_with<A:Send>(arg: A, f: fn~(v: A)) {\n     task().spawn_with(move arg, move f)\n }\n \n-pub fn spawn_listener<A:Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+pub fn spawn_listener<A:Owned>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n     /*!\n      * Runs a new task while providing a channel from the parent to the child\n      *\n@@ -576,7 +576,7 @@ pub fn spawn_listener<A:Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n     task().spawn_listener(move f)\n }\n \n-pub fn spawn_conversation<A: Send, B: Send>\n+pub fn spawn_conversation<A: Owned, B: Owned>\n     (f: fn~(comm::Port<A>, comm::Chan<B>))\n     -> (comm::Port<B>, comm::Chan<A>) {\n     /*!\n@@ -605,7 +605,7 @@ pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n     task().sched_mode(mode).spawn(move f)\n }\n \n-pub fn try<T:Send>(f: fn~() -> T) -> Result<T,()> {\n+pub fn try<T:Owned>(f: fn~() -> T) -> Result<T,()> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err."}, {"sha": "c7ee052147f9aa8610955cfe13e2a3f9c8fc62c4", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -484,7 +484,7 @@ fn parse_bounds(st: @pstate, conv: conv_did) -> @~[ty::param_bound] {\n     let mut bounds = ~[];\n     loop {\n         bounds.push(match next(st) {\n-          'S' => ty::bound_send,\n+          'S' => ty::bound_owned,\n           'C' => ty::bound_copy,\n           'K' => ty::bound_const,\n           'O' => ty::bound_durable,"}, {"sha": "6ceb592f6c9ddc5141211064f814e21ee336aeaf", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -392,7 +392,7 @@ fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::FnTy) {\n fn enc_bounds(w: io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n     for vec::each(*bs) |bound| {\n         match *bound {\n-          ty::bound_send => w.write_char('S'),\n+          ty::bound_owned => w.write_char('S'),\n           ty::bound_copy => w.write_char('C'),\n           ty::bound_const => w.write_char('K'),\n           ty::bound_durable => w.write_char('O'),"}, {"sha": "e35377c5cdd9377b3a96818a2588197e7d2207bf", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -63,7 +63,7 @@ fn kind_to_str(k: Kind) -> ~str {\n     }\n \n     if ty::kind_can_be_sent(k) {\n-        kinds.push(~\"send\");\n+        kinds.push(~\"owned\");\n     } else if ty::kind_is_durable(k) {\n         kinds.push(~\"durable\");\n     }"}, {"sha": "1f65ee8ae83243fdab2ad2fd712fa562693822d2", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -13,7 +13,7 @@\n // Language items are items that represent concepts intrinsic to the language\n // itself. Examples are:\n //\n-// * Traits that specify \"kinds\"; e.g. \"const\", \"copy\", \"send\".\n+// * Traits that specify \"kinds\"; e.g. \"const\", \"copy\", \"owned\".\n //\n // * Traits that represent operators; e.g. \"add\", \"sub\", \"index\".\n //\n@@ -35,7 +35,7 @@ use str_eq = str::eq;\n struct LanguageItems {\n     mut const_trait: Option<def_id>,\n     mut copy_trait: Option<def_id>,\n-    mut send_trait: Option<def_id>,\n+    mut owned_trait: Option<def_id>,\n     mut durable_trait: Option<def_id>,\n \n     mut drop_trait: Option<def_id>,\n@@ -68,7 +68,7 @@ mod language_items {\n         LanguageItems {\n             const_trait: None,\n             copy_trait: None,\n-            send_trait: None,\n+            owned_trait: None,\n             durable_trait: None,\n \n             drop_trait: None,\n@@ -105,7 +105,7 @@ fn LanguageItemCollector(crate: @crate, session: Session,\n \n     item_refs.insert(~\"const\", &mut items.const_trait);\n     item_refs.insert(~\"copy\", &mut items.copy_trait);\n-    item_refs.insert(~\"send\", &mut items.send_trait);\n+    item_refs.insert(~\"owned\", &mut items.owned_trait);\n     item_refs.insert(~\"durable\", &mut items.durable_trait);\n \n     item_refs.insert(~\"drop\", &mut items.drop_trait);"}, {"sha": "1770c6dac52a73ba8cb93853962c0d8b96497093", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -178,7 +178,7 @@ export occurs_check;\n export param_ty;\n export param_bound, param_bounds, bound_copy, bound_durable;\n export param_bounds_to_str, param_bound_to_str;\n-export bound_send, bound_trait;\n+export bound_owned, bound_trait;\n export param_bounds_to_kind;\n export default_arg_mode_for_ty;\n export item_path;\n@@ -703,7 +703,7 @@ enum type_err {\n enum param_bound {\n     bound_copy,\n     bound_durable,\n-    bound_send,\n+    bound_owned,\n     bound_const,\n     bound_trait(t),\n }\n@@ -770,7 +770,7 @@ impl param_bound : to_bytes::IterBytes {\n         match *self {\n           bound_copy => 0u8.iter_bytes(lsb0, f),\n           bound_durable => 1u8.iter_bytes(lsb0, f),\n-          bound_send => 2u8.iter_bytes(lsb0, f),\n+          bound_owned => 2u8.iter_bytes(lsb0, f),\n           bound_const => 3u8.iter_bytes(lsb0, f),\n           bound_trait(ref t) =>\n           to_bytes::iter_bytes_2(&4u8, t, lsb0, f)\n@@ -876,8 +876,8 @@ fn param_bounds_to_kind(bounds: param_bounds) -> Kind {\n           bound_durable => {\n             kind = raise_kind(kind, kind_durable());\n           }\n-          bound_send => {\n-            kind = raise_kind(kind, kind_send_only() | kind_durable());\n+          bound_owned => {\n+            kind = raise_kind(kind, kind_owned_only() | kind_durable());\n           }\n           bound_const => {\n             kind = raise_kind(kind, kind_const());\n@@ -1550,7 +1550,7 @@ fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n     match *pb {\n         bound_copy => ~\"copy\",\n         bound_durable => ~\"durable\",\n-        bound_send => ~\"send\",\n+        bound_owned => ~\"owned\",\n         bound_const => ~\"const\",\n         bound_trait(t) => ty_to_str(cx, t)\n     }\n@@ -1908,8 +1908,8 @@ enum Kind { kind_(u32) }\n /// can be copied (implicitly or explicitly)\n const KIND_MASK_COPY         : u32 = 0b000000000000000000000000001_u32;\n \n-/// can be sent: no shared box, borrowed ptr (must imply DURABLE)\n-const KIND_MASK_SEND         : u32 = 0b000000000000000000000000010_u32;\n+/// no shared box, borrowed ptr (must imply DURABLE)\n+const KIND_MASK_OWNED         : u32 = 0b000000000000000000000000010_u32;\n \n /// is durable (no borrowed ptrs)\n const KIND_MASK_DURABLE      : u32 = 0b000000000000000000000000100_u32;\n@@ -1941,22 +1941,22 @@ fn kind_safe_for_default_mode() -> Kind {\n }\n \n fn kind_implicitly_sendable() -> Kind {\n-    kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY | KIND_MASK_SEND)\n+    kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY | KIND_MASK_OWNED)\n }\n \n fn kind_safe_for_default_mode_send() -> Kind {\n     // similar to implicit copy, but always includes vectors and strings\n     kind_(KIND_MASK_DEFAULT_MODE | KIND_MASK_IMPLICIT |\n-          KIND_MASK_COPY | KIND_MASK_SEND)\n+          KIND_MASK_COPY | KIND_MASK_OWNED)\n }\n \n \n-fn kind_send_copy() -> Kind {\n-    kind_(KIND_MASK_COPY | KIND_MASK_SEND)\n+fn kind_owned_copy() -> Kind {\n+    kind_(KIND_MASK_COPY | KIND_MASK_OWNED)\n }\n \n-fn kind_send_only() -> Kind {\n-    kind_(KIND_MASK_SEND)\n+fn kind_owned_only() -> Kind {\n+    kind_(KIND_MASK_OWNED)\n }\n \n fn kind_const() -> Kind {\n@@ -1979,12 +1979,12 @@ fn remove_implicit(k: Kind) -> Kind {\n     k - kind_(KIND_MASK_IMPLICIT | KIND_MASK_DEFAULT_MODE)\n }\n \n-fn remove_send(k: Kind) -> Kind {\n-    k - kind_(KIND_MASK_SEND)\n+fn remove_owned(k: Kind) -> Kind {\n+    k - kind_(KIND_MASK_OWNED)\n }\n \n-fn remove_durable_send(k: Kind) -> Kind {\n-    k - kind_(KIND_MASK_DURABLE) - kind_(KIND_MASK_SEND)\n+fn remove_durable_owned(k: Kind) -> Kind {\n+    k - kind_(KIND_MASK_DURABLE) - kind_(KIND_MASK_OWNED)\n }\n \n fn remove_copyable(k: Kind) -> Kind {\n@@ -2031,7 +2031,7 @@ pure fn kind_can_be_copied(k: Kind) -> bool {\n }\n \n pure fn kind_can_be_sent(k: Kind) -> bool {\n-    *k & KIND_MASK_SEND == KIND_MASK_SEND\n+    *k & KIND_MASK_OWNED == KIND_MASK_OWNED\n }\n \n pure fn kind_is_durable(k: Kind) -> bool {\n@@ -2050,7 +2050,7 @@ fn meta_kind(p: FnMeta) -> Kind {\n             kind_safe_for_default_mode() | kind_durable()\n         }\n         ast::ProtoUniq => {\n-            kind_send_copy() | kind_durable()\n+            kind_owned_copy() | kind_durable()\n         }\n     }\n }\n@@ -2071,17 +2071,17 @@ fn raise_kind(a: Kind, b: Kind) -> Kind {\n fn test_kinds() {\n     // The kind \"lattice\" is defined by the subset operation on the\n     // set of permitted operations.\n-    assert kind_lteq(kind_send_copy(), kind_send_copy());\n-    assert kind_lteq(kind_copyable(), kind_send_copy());\n+    assert kind_lteq(kind_owned_copy(), kind_owned_copy());\n+    assert kind_lteq(kind_copyable(), kind_owned_copy());\n     assert kind_lteq(kind_copyable(), kind_copyable());\n-    assert kind_lteq(kind_noncopyable(), kind_send_copy());\n+    assert kind_lteq(kind_noncopyable(), kind_owned_copy());\n     assert kind_lteq(kind_noncopyable(), kind_copyable());\n     assert kind_lteq(kind_noncopyable(), kind_noncopyable());\n     assert kind_lteq(kind_copyable(), kind_implicitly_copyable());\n     assert kind_lteq(kind_copyable(), kind_implicitly_sendable());\n-    assert kind_lteq(kind_send_copy(), kind_implicitly_sendable());\n-    assert !kind_lteq(kind_send_copy(), kind_implicitly_copyable());\n-    assert !kind_lteq(kind_copyable(), kind_send_only());\n+    assert kind_lteq(kind_owned_copy(), kind_implicitly_sendable());\n+    assert !kind_lteq(kind_owned_copy(), kind_implicitly_copyable());\n+    assert !kind_lteq(kind_copyable(), kind_owned_only());\n }\n \n // Return the most permissive kind that a composite object containing a field\n@@ -2121,7 +2121,7 @@ fn type_kind(cx: ctxt, ty: t) -> Kind {\n         if cx.vecs_implicitly_copyable {\n             kind_implicitly_sendable() | kind_const() | kind_durable()\n         } else {\n-            kind_send_copy() | kind_const() | kind_durable()\n+            kind_owned_copy() | kind_const() | kind_durable()\n         }\n       }\n \n@@ -2131,7 +2131,7 @@ fn type_kind(cx: ctxt, ty: t) -> Kind {\n       // Those with refcounts raise noncopyable to copyable,\n       // lower sendable to copyable. Therefore just set result to copyable.\n       ty_box(tm) => {\n-        remove_send(mutable_type_kind(cx, tm) | kind_safe_for_default_mode())\n+        remove_owned(mutable_type_kind(cx, tm) | kind_safe_for_default_mode())\n       }\n \n       // Trait instances are (for now) like shared boxes, basically\n@@ -2161,13 +2161,13 @@ fn type_kind(cx: ctxt, ty: t) -> Kind {\n       // contained type, but aren't implicitly copyable.  Fixed vectors have\n       // the kind of the element they contain, taking mutability into account.\n       ty_evec(tm, vstore_box) => {\n-        remove_send(kind_safe_for_default_mode() | mutable_type_kind(cx, tm))\n+        remove_owned(kind_safe_for_default_mode() | mutable_type_kind(cx, tm))\n       }\n       ty_evec(tm, vstore_slice(re_static)) => {\n         kind_safe_for_default_mode() | mutable_type_kind(cx, tm)\n       }\n       ty_evec(tm, vstore_slice(_)) => {\n-        remove_durable_send(kind_safe_for_default_mode() |\n+        remove_durable_owned(kind_safe_for_default_mode() |\n                            mutable_type_kind(cx, tm))\n       }\n       ty_evec(tm, vstore_fixed(_)) => {\n@@ -2179,7 +2179,7 @@ fn type_kind(cx: ctxt, ty: t) -> Kind {\n         kind_safe_for_default_mode() | kind_const() | kind_durable()\n       }\n       ty_estr(vstore_slice(re_static)) => {\n-        kind_safe_for_default_mode() | kind_send_copy() | kind_const()\n+        kind_safe_for_default_mode() | kind_owned_copy() | kind_const()\n       }\n       ty_estr(vstore_slice(_)) => {\n         kind_safe_for_default_mode() | kind_const()\n@@ -2226,7 +2226,7 @@ fn type_kind(cx: ctxt, ty: t) -> Kind {\n         let mut lowest = kind_top();\n         let variants = enum_variants(cx, did);\n         if vec::len(*variants) == 0u {\n-            lowest = kind_send_only() | kind_durable();\n+            lowest = kind_owned_only() | kind_durable();\n         } else {\n             for vec::each(*variants) |variant| {\n                 for variant.args.each |aty| {\n@@ -4236,7 +4236,7 @@ fn iter_bound_traits_and_supertraits(tcx: ctxt,\n         let bound_trait_ty = match *bound {\n             ty::bound_trait(bound_t) => bound_t,\n \n-            ty::bound_copy | ty::bound_send |\n+            ty::bound_copy | ty::bound_owned |\n             ty::bound_const | ty::bound_durable => {\n                 loop; // skip non-trait bounds\n             }\n@@ -4653,9 +4653,9 @@ impl param_bound : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            bound_send => {\n+            bound_owned => {\n                 match (*other) {\n-                    bound_send => true,\n+                    bound_owned => true,\n                     _ => false\n                 }\n             }"}, {"sha": "c61ad39e3330297c2243dc1b02c3a8efc6da6a52", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -342,7 +342,7 @@ impl LookupContext {\n             let bound_trait_ty = match *bound {\n                 ty::bound_trait(bound_t) => bound_t,\n \n-                ty::bound_copy | ty::bound_send |\n+                ty::bound_copy | ty::bound_owned |\n                 ty::bound_const | ty::bound_durable => {\n                     loop; // skip non-trait bounds\n                 }"}, {"sha": "b4ba9c3d6544727eeecfbf7c462e31ee2efe1e6b", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -872,8 +872,8 @@ fn compute_bounds(ccx: @crate_ctxt,\n         match ty::get(ity).sty {\n             ty::ty_trait(did, _, _) => {\n                 let d = Some(did);\n-                if d == li.send_trait {\n-                    ~[ty::bound_send]\n+                if d == li.owned_trait {\n+                    ~[ty::bound_owned]\n                 }\n                 else if d == li.copy_trait {\n                     ~[ty::bound_copy]"}, {"sha": "9e2f5a063ac0dfde8607325aae9fba8c48a3e3e2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -11,7 +11,7 @@\n use std::map::HashMap;\n use middle::ty;\n use middle::ty::{arg, canon_mode};\n-use middle::ty::{bound_copy, bound_const, bound_durable, bound_send,\n+use middle::ty::{bound_copy, bound_const, bound_durable, bound_owned,\n         bound_trait};\n use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n use middle::ty::{ctxt, field, method};"}, {"sha": "0c3154bf8f8194e0777158873265b8f210c2ef4a", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -95,7 +95,7 @@ fn act(po: comm::Port<Msg>, source: ~str, parse: Parser) {\n     }\n }\n \n-pub fn exec<T:Send>(\n+pub fn exec<T:Owned>(\n     srv: Srv,\n     +f: fn~(ctxt: Ctxt) -> T\n ) -> T {"}, {"sha": "0180d18668daf86d8ffa587e1192072486cd2aaf", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -98,7 +98,7 @@ fn fold_item(\n     }\n }\n \n-fn parse_item_attrs<T:Send>(\n+fn parse_item_attrs<T:Owned>(\n     srv: astsrv::Srv,\n     id: doc::AstId,\n     +parse_attrs: fn~(+a: ~[ast::attribute]) -> T) -> T {"}, {"sha": "ba626f80ddb8f5b19470226177576be47f76f57f", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -92,7 +92,7 @@ fn mk_fold<T:Clone>(\n     }\n }\n \n-pub fn default_any_fold<T:Send Clone>(+ctxt: T) -> Fold<T> {\n+pub fn default_any_fold<T:Owned Clone>(+ctxt: T) -> Fold<T> {\n     mk_fold(\n         move ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -128,7 +128,7 @@ pub fn default_seq_fold<T:Clone>(+ctxt: T) -> Fold<T> {\n     )\n }\n \n-pub fn default_par_fold<T:Send Clone>(+ctxt: T) -> Fold<T> {\n+pub fn default_par_fold<T:Owned Clone>(+ctxt: T) -> Fold<T> {\n     mk_fold(\n         move ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -178,7 +178,7 @@ pub fn default_seq_fold_item<T>(\n     doc\n }\n \n-pub fn default_any_fold_mod<T:Send Clone>(\n+pub fn default_any_fold_mod<T:Owned Clone>(\n     fold: &Fold<T>,\n     +doc: doc::ModDoc\n ) -> doc::ModDoc {\n@@ -205,7 +205,7 @@ pub fn default_seq_fold_mod<T>(\n     })\n }\n \n-pub fn default_par_fold_mod<T:Send Clone>(\n+pub fn default_par_fold_mod<T:Owned Clone>(\n     fold: &Fold<T>,\n     +doc: doc::ModDoc\n ) -> doc::ModDoc {\n@@ -219,7 +219,7 @@ pub fn default_par_fold_mod<T:Send Clone>(\n     })\n }\n \n-pub fn default_any_fold_nmod<T:Send Clone>(\n+pub fn default_any_fold_nmod<T:Owned Clone>(\n     fold: &Fold<T>,\n     +doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n@@ -246,7 +246,7 @@ pub fn default_seq_fold_nmod<T>(\n     }\n }\n \n-pub fn default_par_fold_nmod<T:Send Clone>(\n+pub fn default_par_fold_nmod<T:Owned Clone>(\n     fold: &Fold<T>,\n     +doc: doc::NmodDoc\n ) -> doc::NmodDoc {"}, {"sha": "e2bbda46d7cf389e281ef7dbdbae5ff72bd6098e", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -73,18 +73,18 @@ impl &Condvar {\n  ****************************************************************************/\n \n /// An atomically reference counted wrapper for shared immutable state.\n-struct ARC<T: Const Send> { x: SharedMutableState<T> }\n+struct ARC<T: Const Owned> { x: SharedMutableState<T> }\n \n /// Create an atomically reference counted wrapper.\n-pub fn ARC<T: Const Send>(data: T) -> ARC<T> {\n+pub fn ARC<T: Const Owned>(data: T) -> ARC<T> {\n     ARC { x: unsafe { shared_mutable_state(move data) } }\n }\n \n /**\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-pub fn get<T: Const Send>(rc: &a/ARC<T>) -> &a/T {\n+pub fn get<T: Const Owned>(rc: &a/ARC<T>) -> &a/T {\n     unsafe { get_shared_immutable_state(&rc.x) }\n }\n \n@@ -95,7 +95,7 @@ pub fn get<T: Const Send>(rc: &a/ARC<T>) -> &a/T {\n  * object. However, one of the `arc` objects can be sent to another task,\n  * allowing them to share the underlying data.\n  */\n-pub fn clone<T: Const Send>(rc: &ARC<T>) -> ARC<T> {\n+pub fn clone<T: Const Owned>(rc: &ARC<T>) -> ARC<T> {\n     ARC { x: unsafe { clone_shared_mutable_state(&rc.x) } }\n }\n \n@@ -108,12 +108,12 @@ pub fn clone<T: Const Send>(rc: &ARC<T>) -> ARC<T> {\n  * unwrap from a task that holds another reference to the same ARC; it is\n  * guaranteed to deadlock.\n  */\n-fn unwrap<T: Const Send>(rc: ARC<T>) -> T {\n+fn unwrap<T: Const Owned>(rc: ARC<T>) -> T {\n     let ARC { x: x } = move rc;\n     unsafe { unwrap_shared_mutable_state(move x) }\n }\n \n-impl<T: Const Send> ARC<T>: Clone {\n+impl<T: Const Owned> ARC<T>: Clone {\n     fn clone(&self) -> ARC<T> {\n         clone(self)\n     }\n@@ -124,27 +124,27 @@ impl<T: Const Send> ARC<T>: Clone {\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct MutexARCInner<T: Send> { lock: Mutex, failed: bool, data: T }\n+struct MutexARCInner<T: Owned> { lock: Mutex, failed: bool, data: T }\n /// An ARC with mutable data protected by a blocking mutex.\n-struct MutexARC<T: Send> { x: SharedMutableState<MutexARCInner<T>> }\n+struct MutexARC<T: Owned> { x: SharedMutableState<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n-pub fn MutexARC<T: Send>(user_data: T) -> MutexARC<T> {\n+pub fn MutexARC<T: Owned>(user_data: T) -> MutexARC<T> {\n     mutex_arc_with_condvars(move user_data, 1)\n }\n /**\n  * Create a mutex-protected ARC with the supplied data and a specified number\n  * of condvars (as sync::mutex_with_condvars).\n  */\n-pub fn mutex_arc_with_condvars<T: Send>(user_data: T,\n+pub fn mutex_arc_with_condvars<T: Owned>(user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n                           failed: false, data: move user_data };\n     MutexARC { x: unsafe { shared_mutable_state(move data) } }\n }\n \n-impl<T: Send> MutexARC<T>: Clone {\n+impl<T: Owned> MutexARC<T>: Clone {\n     /// Duplicate a mutex-protected ARC, as arc::clone.\n     fn clone(&self) -> MutexARC<T> {\n         // NB: Cloning the underlying mutex is not necessary. Its reference\n@@ -153,7 +153,7 @@ impl<T: Send> MutexARC<T>: Clone {\n     }\n }\n \n-impl<T: Send> &MutexARC<T> {\n+impl<T: Owned> &MutexARC<T> {\n \n     /**\n      * Access the underlying mutable data with mutual exclusion from other\n@@ -210,7 +210,7 @@ impl<T: Send> &MutexARC<T> {\n  * Will additionally fail if another task has failed while accessing the arc.\n  */\n // FIXME(#3724) make this a by-move method on the arc\n-pub fn unwrap_mutex_arc<T: Send>(arc: MutexARC<T>) -> T {\n+pub fn unwrap_mutex_arc<T: Owned>(arc: MutexARC<T>) -> T {\n     let MutexARC { x: x } = move arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let MutexARCInner { failed: failed, data: data, _ } = move inner;\n@@ -256,35 +256,35 @@ fn PoisonOnFail(failed: &r/mut bool) -> PoisonOnFail/&r {\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct RWARCInner<T: Const Send> { lock: RWlock, failed: bool, data: T }\n+struct RWARCInner<T: Const Owned> { lock: RWlock, failed: bool, data: T }\n /**\n  * A dual-mode ARC protected by a reader-writer lock. The data can be accessed\n  * mutably or immutably, and immutably-accessing tasks may run concurrently.\n  *\n  * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n  */\n-struct RWARC<T: Const Send> {\n+struct RWARC<T: Const Owned> {\n     x: SharedMutableState<RWARCInner<T>>,\n     mut cant_nest: ()\n }\n \n /// Create a reader/writer ARC with the supplied data.\n-pub fn RWARC<T: Const Send>(user_data: T) -> RWARC<T> {\n+pub fn RWARC<T: Const Owned>(user_data: T) -> RWARC<T> {\n     rw_arc_with_condvars(move user_data, 1)\n }\n /**\n  * Create a reader/writer ARC with the supplied data and a specified number\n  * of condvars (as sync::rwlock_with_condvars).\n  */\n-pub fn rw_arc_with_condvars<T: Const Send>(user_data: T,\n+pub fn rw_arc_with_condvars<T: Const Owned>(user_data: T,\n                                        num_condvars: uint) -> RWARC<T> {\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n                      failed: false, data: move user_data };\n     RWARC { x: unsafe { shared_mutable_state(move data) }, cant_nest: () }\n }\n \n-impl<T: Const Send> RWARC<T> {\n+impl<T: Const Owned> RWARC<T> {\n     /// Duplicate a rwlock-protected ARC, as arc::clone.\n     fn clone(&self) -> RWARC<T> {\n         RWARC { x: unsafe { clone_shared_mutable_state(&self.x) },\n@@ -293,7 +293,7 @@ impl<T: Const Send> RWARC<T> {\n \n }\n \n-impl<T: Const Send> &RWARC<T> {\n+impl<T: Const Owned> &RWARC<T> {\n     /**\n      * Access the underlying data mutably. Locks the rwlock in write mode;\n      * other readers and writers will block.\n@@ -394,7 +394,7 @@ impl<T: Const Send> &RWARC<T> {\n  * in write mode.\n  */\n // FIXME(#3724) make this a by-move method on the arc\n-pub fn unwrap_rw_arc<T: Const Send>(arc: RWARC<T>) -> T {\n+pub fn unwrap_rw_arc<T: Const Owned>(arc: RWARC<T>) -> T {\n     let RWARC { x: x, _ } = move arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let RWARCInner { failed: failed, data: data, _ } = move inner;\n@@ -408,19 +408,19 @@ pub fn unwrap_rw_arc<T: Const Send>(arc: RWARC<T>) -> T {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T: Const Send>(state: &r/mut RWARCInner<T>) -> &r/RWlock {\n+fn borrow_rwlock<T: Const Owned>(state: &r/mut RWARCInner<T>) -> &r/RWlock {\n     unsafe { cast::transmute_immut(&mut state.lock) }\n }\n \n // FIXME (#3154) ice with struct/&<T> prevents these from being structs.\n \n /// The \"write permission\" token used for RWARC.write_downgrade().\n-pub enum RWWriteMode<T: Const Send> =\n+pub enum RWWriteMode<T: Const Owned> =\n     (&mut T, sync::RWlockWriteMode, PoisonOnFail);\n /// The \"read permission\" token used for RWARC.write_downgrade().\n-pub enum RWReadMode<T:Const Send> = (&T, sync::RWlockReadMode);\n+pub enum RWReadMode<T:Const Owned> = (&T, sync::RWlockReadMode);\n \n-impl<T: Const Send> &RWWriteMode<T> {\n+impl<T: Const Owned> &RWWriteMode<T> {\n     /// Access the pre-downgrade RWARC in write mode.\n     fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n         match *self {\n@@ -446,7 +446,7 @@ impl<T: Const Send> &RWWriteMode<T> {\n     }\n }\n \n-impl<T: Const Send> &RWReadMode<T> {\n+impl<T: Const Owned> &RWReadMode<T> {\n     /// Access the post-downgrade rwlock in read mode.\n     fn read<U>(blk: fn(x: &T) -> U) -> U {\n         match *self {"}, {"sha": "1055f3ea7df7287e3f9c95ee00d59d326ba0d050", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -21,24 +21,24 @@ use pipes::{GenericChan, GenericSmartChan, GenericPort,\n             Chan, Port, Selectable, Peekable};\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n-pub struct DuplexStream<T: Send, U: Send> {\n+pub struct DuplexStream<T: Owned, U: Owned> {\n     priv chan: Chan<T>,\n     priv port: Port<U>,\n }\n \n-impl<T: Send, U: Send> DuplexStream<T, U> : GenericChan<T> {\n+impl<T: Owned, U: Owned> DuplexStream<T, U> : GenericChan<T> {\n     fn send(x: T) {\n         self.chan.send(move x)\n     }\n }\n \n-impl<T: Send, U: Send> DuplexStream<T, U> : GenericSmartChan<T> {\n+impl<T: Owned, U: Owned> DuplexStream<T, U> : GenericSmartChan<T> {\n     fn try_send(x: T) -> bool {\n         self.chan.try_send(move x)\n     }\n }\n \n-impl<T: Send, U: Send> DuplexStream<T, U> : GenericPort<U> {\n+impl<T: Owned, U: Owned> DuplexStream<T, U> : GenericPort<U> {\n     fn recv() -> U {\n         self.port.recv()\n     }\n@@ -48,20 +48,20 @@ impl<T: Send, U: Send> DuplexStream<T, U> : GenericPort<U> {\n     }\n }\n \n-impl<T: Send, U: Send> DuplexStream<T, U> : Peekable<U> {\n+impl<T: Owned, U: Owned> DuplexStream<T, U> : Peekable<U> {\n     pure fn peek() -> bool {\n         self.port.peek()\n     }\n }\n \n-impl<T: Send, U: Send> DuplexStream<T, U> : Selectable {\n+impl<T: Owned, U: Owned> DuplexStream<T, U> : Selectable {\n     pure fn header() -> *pipes::PacketHeader {\n         self.port.header()\n     }\n }\n \n /// Creates a bidirectional stream.\n-pub fn DuplexStream<T: Send, U: Send>()\n+pub fn DuplexStream<T: Owned, U: Owned>()\n     -> (DuplexStream<T, U>, DuplexStream<U, T>)\n {\n     let (p1, c2) = pipes::stream();"}, {"sha": "2a72c2f696a54c4c42561d76196822b6e35b5a02", "filename": "src/libstd/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -89,7 +89,7 @@ pub fn from_value<A>(val: A) -> Future<A> {\n     Future {state: Forced(move val)}\n }\n \n-pub fn from_port<A:Send>(port: PortOne<A>) ->\n+pub fn from_port<A:Owned>(port: PortOne<A>) ->\n         Future<A> {\n     /*!\n      * Create a future from a port\n@@ -121,7 +121,7 @@ pub fn from_fn<A>(f: ~fn() -> A) -> Future<A> {\n     Future {state: Pending(move f)}\n }\n \n-pub fn spawn<A:Send>(blk: fn~() -> A) -> Future<A> {\n+pub fn spawn<A:Owned>(blk: fn~() -> A) -> Future<A> {\n     /*!\n      * Create a future from a unique closure.\n      *"}, {"sha": "55f88d4427cefd4486f28de2e6056bb77e1b3556", "filename": "src/libstd/par.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -29,7 +29,7 @@ const min_granularity : uint = 1024u;\n  * This is used to build most of the other parallel vector functions,\n  * like map or alli.\n  */\n-fn map_slices<A: Copy Send, B: Copy Send>(\n+fn map_slices<A: Copy Owned, B: Copy Owned>(\n     xs: &[A],\n     f: fn() -> fn~(uint, v: &[A]) -> B)\n     -> ~[B] {\n@@ -84,7 +84,8 @@ fn map_slices<A: Copy Send, B: Copy Send>(\n }\n \n /// A parallel version of map.\n-pub fn map<A: Copy Send, B: Copy Send>(xs: &[A], f: fn~((&A)) -> B) -> ~[B] {\n+pub fn map<A: Copy Owned, B: Copy Owned>(\n+    xs: &[A], f: fn~((&A)) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         fn~(_base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::map(slice, |x| f(x))\n@@ -93,7 +94,7 @@ pub fn map<A: Copy Send, B: Copy Send>(xs: &[A], f: fn~((&A)) -> B) -> ~[B] {\n }\n \n /// A parallel version of mapi.\n-pub fn mapi<A: Copy Send, B: Copy Send>(xs: &[A],\n+pub fn mapi<A: Copy Owned, B: Copy Owned>(xs: &[A],\n                                     f: fn~(uint, (&A)) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n@@ -114,7 +115,7 @@ pub fn mapi<A: Copy Send, B: Copy Send>(xs: &[A],\n  * In this case, f is a function that creates functions to run over the\n  * inner elements. This is to skirt the need for copy constructors.\n  */\n-pub fn mapi_factory<A: Copy Send, B: Copy Send>(\n+pub fn mapi_factory<A: Copy Owned, B: Copy Owned>(\n     xs: &[A], f: fn() -> fn~(uint, A) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n         let f = f();\n@@ -131,7 +132,7 @@ pub fn mapi_factory<A: Copy Send, B: Copy Send>(\n }\n \n /// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A: Copy Send>(xs: &[A], f: fn~(uint, (&A)) -> bool) -> bool {\n+pub fn alli<A: Copy Owned>(xs: &[A], f: fn~(uint, (&A)) -> bool) -> bool {\n     do vec::all(map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n             vec::alli(slice, |i, x| {\n@@ -142,7 +143,7 @@ pub fn alli<A: Copy Send>(xs: &[A], f: fn~(uint, (&A)) -> bool) -> bool {\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-pub fn any<A: Copy Send>(xs: &[A], f: fn~(&(A)) -> bool) -> bool {\n+pub fn any<A: Copy Owned>(xs: &[A], f: fn~(&(A)) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n             vec::any(slice, |x| f(x))"}, {"sha": "e1b029c5396f4bb4dd495b8811f2aa1d00941846", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -76,10 +76,10 @@ struct SemInner<Q> {\n     blocked:   Q\n }\n #[doc(hidden)]\n-enum Sem<Q: Send> = Exclusive<SemInner<Q>>;\n+enum Sem<Q: Owned> = Exclusive<SemInner<Q>>;\n \n #[doc(hidden)]\n-fn new_sem<Q: Send>(count: int, q: Q) -> Sem<Q> {\n+fn new_sem<Q: Owned>(count: int, q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n         mut count: count, waiters: new_waitqueue(), blocked: move q }))\n }\n@@ -94,7 +94,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n }\n \n #[doc(hidden)]\n-impl<Q: Send> &Sem<Q> {\n+impl<Q: Owned> &Sem<Q> {\n     fn acquire() {\n         let mut waiter_nobe = None;\n         unsafe {\n@@ -160,9 +160,9 @@ impl &Sem<~[mut Waitqueue]> {\n #[doc(hidden)]\n type SemRelease = SemReleaseGeneric<()>;\n type SemAndSignalRelease = SemReleaseGeneric<~[mut Waitqueue]>;\n-struct SemReleaseGeneric<Q: Send> { sem: &Sem<Q> }\n+struct SemReleaseGeneric<Q: Owned> { sem: &Sem<Q> }\n \n-impl<Q: Send> SemReleaseGeneric<Q> : Drop {\n+impl<Q: Owned> SemReleaseGeneric<Q> : Drop {\n     fn finalize(&self) {\n         self.sem.release();\n     }"}, {"sha": "a9638ad05c37fdb4b9c4b6d7aa8cec19e71ae9a2", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -32,7 +32,7 @@ use comm = core::comm;\n  * * ch - a channel of type T to send a `val` on\n  * * val - a value of type T to send over the provided `ch`\n  */\n-pub fn delayed_send<T: Send>(iotask: IoTask,\n+pub fn delayed_send<T: Owned>(iotask: IoTask,\n                                   msecs: uint, ch: comm::Chan<T>, val: T) {\n         unsafe {\n             let timer_done_po = core::comm::Port::<()>();\n@@ -108,7 +108,7 @@ pub fn sleep(iotask: IoTask, msecs: uint) {\n  * on the provided port in the allotted timeout period, then the result will\n  * be a `some(T)`. If not, then `none` will be returned.\n  */\n-pub fn recv_timeout<T: Copy Send>(iotask: IoTask,\n+pub fn recv_timeout<T: Copy Owned>(iotask: IoTask,\n                               msecs: uint,\n                               wait_po: comm::Port<T>) -> Option<T> {\n     let timeout_po = comm::Port::<()>();"}, {"sha": "8b3944431709de7dd8c31d9cc6f46a44e2cff3ba", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -166,7 +166,7 @@ struct Exec {\n     discovered_outputs: WorkMap\n }\n \n-struct Work<T:Send> {\n+struct Work<T:Owned> {\n     prep: @mut Prep,\n     res: Option<Either<T,PortOne<(Exec,T)>>>\n }\n@@ -197,7 +197,7 @@ impl Context {\n         Context {db: db, logger: lg, cfg: cfg, freshness: LinearMap()}\n     }\n \n-    fn prep<T:Send\n+    fn prep<T:Owned\n               Serializable<json::Serializer>\n               Deserializable<json::Deserializer>>(\n                   @self,\n@@ -245,7 +245,7 @@ impl Prep {\n         return true;\n     }\n \n-    fn exec<T:Send\n+    fn exec<T:Owned\n               Serializable<json::Serializer>\n               Deserializable<json::Deserializer>>(\n                   @mut self, blk: ~fn(&Exec) -> T) -> Work<T> {\n@@ -291,7 +291,7 @@ impl Prep {\n     }\n }\n \n-impl<T:Send\n+impl<T:Owned\n        Serializable<json::Serializer>\n        Deserializable<json::Deserializer>>\n     Work<T> {\n@@ -301,7 +301,7 @@ impl<T:Send\n }\n \n // FIXME (#3724): movable self. This should be in impl Work.\n-fn unwrap<T:Send\n+fn unwrap<T:Owned\n             Serializable<json::Serializer>\n             Deserializable<json::Deserializer>>(w: Work<T>) -> T {\n "}, {"sha": "67dc05bc31d154054f5694ba2d88886142539a18", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -14,7 +14,7 @@ export foo;\n \n use core::comm::*;\n \n-fn foo<T: Send Copy>(x: T) -> Port<T> {\n+fn foo<T: Owned Copy>(x: T) -> Port<T> {\n     let p = Port();\n     let c = Chan(&p);\n     do task::spawn() |copy c, copy x| {"}, {"sha": "d8ce8076e41ed47109b2d51285573038acdcf423", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -28,20 +28,20 @@ export recv;\n  * transmitted. If a port value is copied, both copies refer to the same\n  * port.  Ports may be associated with multiple `chan`s.\n  */\n-enum port<T: Send> {\n+enum port<T: Owned> {\n     port_t(@port_ptr<T>)\n }\n \n /// Constructs a port\n-fn port<T: Send>() -> port<T> {\n+fn port<T: Owned>() -> port<T> {\n     port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n }\n \n-struct port_ptr<T:Send> {\n+struct port_ptr<T:Owned> {\n    po: *rust_port,\n }\n \n-impl<T:Send> port_ptr<T> : Drop {\n+impl<T:Owned> port_ptr<T> : Drop {\n     fn finalize(&self) {\n         unsafe {\n             debug!(\"in the port_ptr destructor\");\n@@ -63,7 +63,7 @@ impl<T:Send> port_ptr<T> : Drop {\n     }\n }\n \n-fn port_ptr<T: Send>(po: *rust_port) -> port_ptr<T> {\n+fn port_ptr<T: Owned>(po: *rust_port) -> port_ptr<T> {\n     debug!(\"in the port_ptr constructor\");\n     port_ptr {\n         po: po\n@@ -74,11 +74,11 @@ fn port_ptr<T: Send>(po: *rust_port) -> port_ptr<T> {\n  * Receive from a port.  If no data is available on the port then the\n  * task will block until data becomes available.\n  */\n-fn recv<T: Send>(p: port<T>) -> T { recv_((**p).po) }\n+fn recv<T: Owned>(p: port<T>) -> T { recv_((**p).po) }\n \n \n /// Receive on a raw port pointer\n-fn recv_<T: Send>(p: *rust_port) -> T {\n+fn recv_<T: Owned>(p: *rust_port) -> T {\n     let yield = 0;\n     let yieldp = ptr::addr_of(&yield);\n     let mut res;"}, {"sha": "11d7545e175548cd99456972ceb198867bec88e4", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -68,7 +68,7 @@ macro_rules! follow (\n     )\n )\n \n-fn switch<T: Send, Tb: Send, U>(+endp: pipes::RecvPacketBuffered<T, Tb>,\n+fn switch<T: Owned, Tb: Owned, U>(+endp: pipes::RecvPacketBuffered<T, Tb>,\n                       f: fn(+v: Option<T>) -> U) -> U {\n     f(pipes::try_recv(move endp))\n }"}, {"sha": "8cee0b5f7f35956676bb7c3357c0bcd853f9344e", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -124,35 +124,35 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter<K: Send, V: Send> = fn(&K, V);\n+    type putter<K: Owned, V: Owned> = fn(&K, V);\n \n-    type mapper<K1: Send, K2: Send, V: Send> = fn~(K1, putter<K2, V>);\n+    type mapper<K1: Owned, K2: Owned, V: Owned> = fn~(K1, putter<K2, V>);\n \n-    type getter<V: Send> = fn() -> Option<V>;\n+    type getter<V: Owned> = fn() -> Option<V>;\n \n-    type reducer<K: Copy Send, V: Copy Send> = fn~(&K, getter<V>);\n+    type reducer<K: Copy Owned, V: Copy Owned> = fn~(&K, getter<V>);\n \n-    enum ctrl_proto<K: Copy Send, V: Copy Send> {\n+    enum ctrl_proto<K: Copy Owned, V: Copy Owned> {\n         find_reducer(K, Chan<Chan<reduce_proto<V>>>),\n         mapper_done\n     }\n \n \n     proto! ctrl_proto (\n-        open: send<K: Copy Send, V: Copy Send> {\n+        open: send<K: Copy Owned, V: Copy Owned> {\n             find_reducer(K) -> reducer_response<K, V>,\n             mapper_done -> !\n         }\n \n-        reducer_response: recv<K: Copy Send, V: Copy Send> {\n+        reducer_response: recv<K: Copy Owned, V: Copy Owned> {\n             reducer(Chan<reduce_proto<V>>) -> open<K, V>\n         }\n     )\n \n-    enum reduce_proto<V: Copy Send> { emit_val(V), done, addref, release }\n+    enum reduce_proto<V: Copy Owned> { emit_val(V), done, addref, release }\n \n-    fn start_mappers<K1: Copy Send, K2: Hash IterBytes Eq Const Copy Send,\n-                     V: Copy Send>(\n+    fn start_mappers<K1: Copy Owned, K2: Hash IterBytes Eq Const Copy Owned,\n+                     V: Copy Owned>(\n         map: &mapper<K1, K2, V>,\n         ctrls: &mut ~[ctrl_proto::server::open<K2, V>],\n         inputs: &~[K1])\n@@ -170,7 +170,7 @@ mod map_reduce {\n         move tasks\n     }\n \n-    fn map_task<K1: Copy Send, K2: Hash IterBytes Eq Const Copy Send, V: Copy Send>(\n+    fn map_task<K1: Copy Owned, K2: Hash IterBytes Eq Const Copy Owned, V: Copy Owned>(\n         map: mapper<K1, K2, V>,\n         ctrl: &box<ctrl_proto::client::open<K2, V>>,\n         input: K1)\n@@ -202,15 +202,15 @@ mod map_reduce {\n             send(c.get(), emit_val(val));\n         }\n \n-        fn finish<K: Copy Send, V: Copy Send>(_k: K, v: Chan<reduce_proto<V>>)\n+        fn finish<K: Copy Owned, V: Copy Owned>(_k: K, v: Chan<reduce_proto<V>>)\n         {\n             send(v, release);\n         }\n         for intermediates.each_value |v| { send(v, release) }\n         ctrl_proto::client::mapper_done(ctrl.unwrap());\n     }\n \n-    fn reduce_task<K: Copy Send, V: Copy Send>(\n+    fn reduce_task<K: Copy Owned, V: Copy Owned>(\n         reduce: ~reducer<K, V>, \n         key: K,\n         out: Chan<Chan<reduce_proto<V>>>)\n@@ -222,7 +222,7 @@ mod map_reduce {\n         let mut ref_count = 0;\n         let mut is_done = false;\n \n-        fn get<V: Copy Send>(p: Port<reduce_proto<V>>,\n+        fn get<V: Copy Owned>(p: Port<reduce_proto<V>>,\n                              ref_count: &mut int, is_done: &mut bool)\n            -> Option<V> {\n             while !*is_done || *ref_count > 0 {\n@@ -245,7 +245,7 @@ mod map_reduce {\n         (*reduce)(&key, || get(p, &mut ref_count, &mut is_done) );\n     }\n \n-    fn map_reduce<K1: Copy Send, K2: Hash IterBytes Eq Const Copy Send, V: Copy Send>(\n+    fn map_reduce<K1: Copy Owned, K2: Hash IterBytes Eq Const Copy Owned, V: Copy Owned>(\n         map: mapper<K1, K2, V>,\n         reduce: reducer<K2, V>,\n         inputs: ~[K1])"}, {"sha": "c0b27789977efdd62d655be30e9ac802a1cc572e", "filename": "src/test/compile-fail/issue-2766-a.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -10,10 +10,10 @@\n \n mod stream {\n     #[legacy_exports];\n-    enum Stream<T: Send> { send(T, server::Stream<T>), }\n+    enum Stream<T: Owned> { send(T, server::Stream<T>), }\n     mod server {\n         #[legacy_exports];\n-        impl<T: Send> Stream<T> {\n+        impl<T: Owned> Stream<T> {\n             fn recv() -> extern fn(+v: Stream<T>) -> stream::Stream<T> {\n               // resolve really should report just one error here.\n               // Change the test case when it changes.\n@@ -26,7 +26,7 @@ mod stream {\n                 recv\n             }\n         }\n-        type Stream<T: Send> = pipes::RecvPacket<stream::Stream<T>>;\n+        type Stream<T: Owned> = pipes::RecvPacket<stream::Stream<T>>;\n     }\n }\n "}, {"sha": "074bdf42280f4dff89b66cfd44fc30c870646b41", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn send<T: Send>(ch: _chan<T>, -data: T) {\n+fn send<T: Owned>(ch: _chan<T>, -data: T) {\n     log(debug, ch);\n     log(debug, data);\n     fail;"}, {"sha": "e20971a63bdb75258784fd3c4c8e631b1fdf0c52", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<T: Send>(_i: T) {\n+fn f<T: Owned>(_i: T) {\n }\n \n fn main() {\n     let i = ~@100;\n-    f(move i); //~ ERROR missing `send`\n+    f(move i); //~ ERROR missing `owned`\n }"}, {"sha": "ef9e0aae95e6be5470561f82238e34190b4d6db6", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -25,7 +25,7 @@ fn foo(i:int, j: @~str) -> foo {\n \n fn main() {\n   let cat = ~\"kitty\";\n-  let po = comm::Port();         //~ ERROR missing `send`\n-  let ch = comm::Chan(&po);       //~ ERROR missing `send`\n-  comm::send(ch, foo(42, @(move cat))); //~ ERROR missing `send`\n+  let po = comm::Port();         //~ ERROR missing `owned`\n+  let ch = comm::Chan(&po);       //~ ERROR missing `owned`\n+  comm::send(ch, foo(42, @(move cat))); //~ ERROR missing `owned`\n }"}, {"sha": "739bf097d4fdaee39ed8f0a73fbd0d0d54f7c293", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -14,8 +14,8 @@ fn test00_start(ch: chan_t<int>, message: int) { send(ch, message); }\n type task_id = int;\n type port_id = int;\n \n-enum chan_t<T: Send> = {task: task_id, port: port_id};\n+enum chan_t<T: Owned> = {task: task_id, port: port_id};\n \n-fn send<T: Send>(ch: chan_t<T>, data: T) { fail; }\n+fn send<T: Owned>(ch: chan_t<T>, data: T) { fail; }\n \n fn main() { fail ~\"quux\"; }"}, {"sha": "b1d8c99faa51925b5c056c80033e8fcc8a82dd3e", "filename": "src/test/run-fail/issue-2444.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2444.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -13,7 +13,7 @@\n extern mod std;\n use std::arc;\n \n-enum e<T: Const Send> { e(arc::ARC<T>) }\n+enum e<T: Const Owned> { e(arc::ARC<T>) }\n \n fn foo() -> e<int> {fail;}\n "}, {"sha": "8b4c1e3ea30a5a3e27c9a18cd49296ea0cf0a0f6", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -15,7 +15,7 @@ use comm::Port;\n use comm::send;\n use comm::recv;\n \n-fn echo<T: Send>(c: Chan<T>, oc: Chan<Chan<T>>) {\n+fn echo<T: Owned>(c: Chan<T>, oc: Chan<Chan<T>>) {\n     // Tests that the type argument in port gets\n     // visited\n     let p = Port::<T>();"}, {"sha": "ded15ca94f119ce60b4142f3ceea785e950856cd", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -23,7 +23,7 @@ fn make_cycle<A:Copy>(a: A) {\n     g.rec = Some(g);\n }\n \n-fn f<A:Send Copy, B:Send Copy>(a: A, b: B) -> fn@() -> (A, B) {\n+fn f<A:Owned Copy, B:Owned Copy>(a: A, b: B) -> fn@() -> (A, B) {\n     fn@() -> (A, B) { (a, b) }\n }\n "}, {"sha": "507bd347fef219137fb3ff195b2f49de5f0e341d", "filename": "src/test/run-pass/bounded-fn-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fbounded-fn-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fbounded-fn-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbounded-fn-type.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -11,7 +11,7 @@\n fn ignore<T>(_x: T) {}\n \n fn main() {\n-    let f: fn@:Send() = ||();\n+    let f: fn@:Owned() = ||();\n     ignore(f);\n }\n "}, {"sha": "a00afd8c6d969f2330aed7fd68aa58bcb86c5aeb", "filename": "src/test/run-pass/fixed-point-bind-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -11,11 +11,11 @@\n // xfail-fast\n #[legacy_modes];\n \n-fn fix_help<A: Durable, B: Send>(f: extern fn(fn@(A) -> B, A) -> B, x: A) -> B {\n+fn fix_help<A: Durable, B: Owned>(f: extern fn(fn@(A) -> B, A) -> B, x: A) -> B {\n     return f({|a|fix_help(f, a)}, x);\n }\n \n-fn fix<A: Durable, B: Send>(f: extern fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n+fn fix<A: Durable, B: Owned>(f: extern fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n     return {|a|fix_help(f, a)};\n }\n "}, {"sha": "53e66f950d3e97343104c881ae23b53517346631", "filename": "src/test/run-pass/fn-bare-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -10,7 +10,7 @@\n \n // This is what the signature to spawn should look like with bare functions\n \n-fn spawn<T: Send>(val: T, f: extern fn(T)) {\n+fn spawn<T: Owned>(val: T, f: extern fn(T)) {\n     f(move val);\n }\n "}, {"sha": "6537be69a1da154c0c0606f5a8b0095982d01c59", "filename": "src/test/run-pass/generic-alias-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-fn id<T: Copy Send>(t: T) -> T { return t; }\n+fn id<T: Copy Owned>(t: T) -> T { return t; }\n \n fn main() {\n     let expected = ~100;"}, {"sha": "7e7a41e20041487f10ecf801de777fa88ce87aaa", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -29,13 +29,13 @@ mod pipes {\n         pure fn ne(&self, other: &state) -> bool { !(*self).eq(other) }\n     }\n \n-    type packet<T: Send> = {\n+    type packet<T: Owned> = {\n         mut state: state,\n         mut blocked_task: Option<task::Task>,\n         mut payload: Option<T>\n     };\n \n-    fn packet<T: Send>() -> *packet<T> unsafe {\n+    fn packet<T: Owned>() -> *packet<T> unsafe {\n         let p: *packet<T> = cast::transmute(~{\n             mut state: empty,\n             mut blocked_task: None::<task::Task>,\n@@ -70,7 +70,7 @@ mod pipes {\n         }\n     }\n \n-    fn send<T: Send>(-p: send_packet<T>, -payload: T) {\n+    fn send<T: Owned>(-p: send_packet<T>, -payload: T) {\n         let p = p.unwrap();\n         let p = unsafe { uniquify(p) };\n         assert (*p).payload.is_none();\n@@ -96,7 +96,7 @@ mod pipes {\n         }\n     }\n \n-    fn recv<T: Send>(-p: recv_packet<T>) -> Option<T> {\n+    fn recv<T: Owned>(-p: recv_packet<T>) -> Option<T> {\n         let p = p.unwrap();\n         let p = unsafe { uniquify(p) };\n         loop {\n@@ -117,7 +117,7 @@ mod pipes {\n         }\n     }\n \n-    fn sender_terminate<T: Send>(p: *packet<T>) {\n+    fn sender_terminate<T: Owned>(p: *packet<T>) {\n         let p = unsafe { uniquify(p) };\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty | blocked => {\n@@ -134,7 +134,7 @@ mod pipes {\n         }\n     }\n \n-    fn receiver_terminate<T: Send>(p: *packet<T>) {\n+    fn receiver_terminate<T: Owned>(p: *packet<T>) {\n         let p = unsafe { uniquify(p) };\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty => {\n@@ -151,11 +151,11 @@ mod pipes {\n         }\n     }\n \n-    struct send_packet<T: Send> {\n+    struct send_packet<T: Owned> {\n         mut p: Option<*packet<T>>,\n     }\n \n-    impl<T: Send> send_packet<T> : Drop {\n+    impl<T: Owned> send_packet<T> : Drop {\n         fn finalize(&self) {\n             if self.p != None {\n                 let mut p = None;\n@@ -165,25 +165,25 @@ mod pipes {\n         }\n     }\n \n-    impl<T: Send> send_packet<T> {\n+    impl<T: Owned> send_packet<T> {\n         fn unwrap() -> *packet<T> {\n             let mut p = None;\n             p <-> self.p;\n             option::unwrap(move p)\n         }\n     }\n \n-    fn send_packet<T: Send>(p: *packet<T>) -> send_packet<T> {\n+    fn send_packet<T: Owned>(p: *packet<T>) -> send_packet<T> {\n         send_packet {\n             p: Some(p)\n         }\n     }\n \n-    struct recv_packet<T: Send> {\n+    struct recv_packet<T: Owned> {\n         mut p: Option<*packet<T>>,\n     }\n \n-    impl<T: Send> recv_packet<T> : Drop {\n+    impl<T: Owned> recv_packet<T> : Drop {\n         fn finalize(&self) {\n             if self.p != None {\n                 let mut p = None;\n@@ -193,21 +193,21 @@ mod pipes {\n         }\n     }\n \n-    impl<T: Send> recv_packet<T> {\n+    impl<T: Owned> recv_packet<T> {\n         fn unwrap() -> *packet<T> {\n             let mut p = None;\n             p <-> self.p;\n             option::unwrap(move p)\n         }\n     }\n \n-    fn recv_packet<T: Send>(p: *packet<T>) -> recv_packet<T> {\n+    fn recv_packet<T: Owned>(p: *packet<T>) -> recv_packet<T> {\n         recv_packet {\n             p: Some(p)\n         }\n     }\n \n-    fn entangle<T: Send>() -> (send_packet<T>, recv_packet<T>) {\n+    fn entangle<T: Owned>() -> (send_packet<T>, recv_packet<T>) {\n         let p = packet();\n         (send_packet(p), recv_packet(p))\n     }"}, {"sha": "dad0427adccfeff58ff9a0f4a1d9b3d250ebeacd", "filename": "src/test/run-pass/issue-2834.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fissue-2834.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fissue-2834.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2834.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -12,7 +12,7 @@\n //\n \n proto! streamp (\n-    open:send<T: Send> {\n+    open:send<T: Owned> {\n         data(T) -> open<T>\n     }\n )"}, {"sha": "1ad51582067347618e5b0c65090e6f18a519ed34", "filename": "src/test/run-pass/issue-2930.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2930.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n proto! stream (\n-    Stream:send<T:Send> {\n+    Stream:send<T:Owned> {\n         send(T) -> Stream<T>\n     }\n )"}, {"sha": "487db85ad66bd6331bceaf8fe99bcf6caaf6937d", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -47,7 +47,7 @@ macro_rules! move_it (\n     { $x:expr } => { unsafe { let y = move *ptr::addr_of(&($x)); move y } }\n )\n \n-fn switch<T: Send, U>(+endp: pipes::RecvPacket<T>,\n+fn switch<T: Owned, U>(+endp: pipes::RecvPacket<T>,\n                       f: fn(+v: Option<T>) -> U) -> U {\n     f(pipes::try_recv(move endp))\n }"}, {"sha": "e71d0c4931dc7cb9974b8e87b08d1d97b1a9872a", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -26,7 +26,7 @@ proto! oneshot (\n )\n \n proto! stream (\n-    Stream:send<T:Send> {\n+    Stream:send<T:Owned> {\n         send(T) -> Stream<T>\n     }\n )"}, {"sha": "a8878075b269cc487104779a6b7d9ef988d80222", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n // tests that ctrl's type gets inferred properly\n-type command<K: Send, V: Send> = {key: K, val: V};\n+type command<K: Owned, V: Owned> = {key: K, val: V};\n \n-fn cache_server<K: Send, V: Send>(c: core::comm::Chan<core::comm::Chan<command<K, V>>>) {\n+fn cache_server<K: Owned, V: Owned>(c: core::comm::Chan<core::comm::Chan<command<K, V>>>) {\n     let ctrl = core::comm::Port();\n     core::comm::send(c, core::comm::Chan(&ctrl));\n }"}, {"sha": "aa0485f79945daf644f0c692ac61b5c57be36ece", "filename": "src/test/run-pass/type-param-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -13,7 +13,7 @@\n \n fn p_foo<T>(pinned: T) { }\n fn s_foo<T: Copy>(shared: T) { }\n-fn u_foo<T: Send>(unique: T) { }\n+fn u_foo<T: Owned>(unique: T) { }\n \n struct r {\n   i: int,"}, {"sha": "b78c78ad9e9820ea5d5c56a30e5c62964ffe45b0", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -18,7 +18,7 @@ type pointy = {\n     d : fn~() -> uint,\n };\n \n-fn make_uniq_closure<A:Send Copy>(a: A) -> fn~() -> uint {\n+fn make_uniq_closure<A:Owned Copy>(a: A) -> fn~() -> uint {\n     fn~() -> uint { ptr::addr_of(&a) as uint }\n }\n "}, {"sha": "f3637ef7d6eed31752d2c335692d07b6017fb667", "filename": "src/test/run-pass/unique-kinds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4fac01b5e207df0f0c7e0ea964bd3088826d27/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-kinds.rs?ref=ed4fac01b5e207df0f0c7e0ea964bd3088826d27", "patch": "@@ -12,11 +12,11 @@ use cmp::Eq;\n \n fn sendable() {\n \n-    fn f<T: Send Eq>(i: T, j: T) {\n+    fn f<T: Owned Eq>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<T: Send Eq>(i: T, j: T) {\n+    fn g<T: Owned Eq>(i: T, j: T) {\n         assert i != j;\n     }\n "}]}