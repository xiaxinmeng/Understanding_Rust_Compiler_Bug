{"sha": "767bff89ededdff875b042bb37397b972e3a82f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2N2JmZjg5ZWRlZGRmZjg3NWIwNDJiYjM3Mzk3Yjk3MmUzYTgyZjE=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-05-01T00:46:17Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-05-02T18:41:02Z"}, "message": "Complete standard derives", "tree": {"sha": "bc2d1cfa1211d471bfcb9abfb6ea0b0d0b57b300", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc2d1cfa1211d471bfcb9abfb6ea0b0d0b57b300"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/767bff89ededdff875b042bb37397b972e3a82f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/767bff89ededdff875b042bb37397b972e3a82f1", "html_url": "https://github.com/rust-lang/rust/commit/767bff89ededdff875b042bb37397b972e3a82f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/767bff89ededdff875b042bb37397b972e3a82f1/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4b32d15340e1dae74d3eaa701ef92ae0f9e295e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4b32d15340e1dae74d3eaa701ef92ae0f9e295e", "html_url": "https://github.com/rust-lang/rust/commit/c4b32d15340e1dae74d3eaa701ef92ae0f9e295e"}], "stats": {"total": 261, "additions": 245, "deletions": 16}, "files": [{"sha": "8934b45fe5d13e909bcbbb45b5e09257fc33f4bc", "filename": "crates/ra_ide/src/completion/complete_attribute.rs", "status": "modified", "additions": 242, "deletions": 13, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/767bff89ededdff875b042bb37397b972e3a82f1/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767bff89ededdff875b042bb37397b972e3a82f1/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs?ref=767bff89ededdff875b042bb37397b972e3a82f1", "patch": "@@ -5,23 +5,26 @@\n \n use super::completion_context::CompletionContext;\n use super::completion_item::{CompletionItem, CompletionItemKind, CompletionKind, Completions};\n+use ast::AttrInput;\n use ra_syntax::{\n-    ast::{Attr, AttrKind},\n-    AstNode,\n+    ast::{self, AttrKind},\n+    AstNode, SyntaxKind,\n };\n+use rustc_hash::FxHashSet;\n \n-pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_attribute {\n-        return;\n-    }\n+pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+    let attribute = ctx.attribute_under_caret.as_ref()?;\n \n-    let is_inner = ctx\n-        .original_token\n-        .ancestors()\n-        .find_map(Attr::cast)\n-        .map(|attr| attr.kind() == AttrKind::Inner)\n-        .unwrap_or(false);\n+    match (attribute.path(), attribute.input()) {\n+        (Some(path), Some(AttrInput::TokenTree(token_tree))) if path.to_string() == \"derive\" => {\n+            complete_derive(acc, ctx, token_tree)\n+        }\n+        _ => complete_attribute_start(acc, ctx, attribute),\n+    }\n+    Some(())\n+}\n \n+fn complete_attribute_start(acc: &mut Completions, ctx: &CompletionContext, attribute: &ast::Attr) {\n     for attr_completion in ATTRIBUTES {\n         let mut item = CompletionItem::new(\n             CompletionKind::Attribute,\n@@ -37,7 +40,7 @@ pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n             _ => {}\n         }\n \n-        if is_inner || !attr_completion.should_be_inner {\n+        if attribute.kind() == AttrKind::Inner || !attr_completion.should_be_inner {\n             acc.add(item);\n         }\n     }\n@@ -126,6 +129,68 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     },\n ];\n \n+fn complete_derive(acc: &mut Completions, ctx: &CompletionContext, derive_input: ast::TokenTree) {\n+    // TODO kb autodetect derive macros\n+    // https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Find.20all.20possible.20derive.20macro.20values.3F/near/195955580\n+\n+    if let Ok(existing_derives) = parse_derive_input(derive_input) {\n+        for derive_completion in DERIVE_COMPLETIONS\n+            .into_iter()\n+            .filter(|completion| !existing_derives.contains(completion.label))\n+        {\n+            let mut label = derive_completion.label.to_owned();\n+            for dependency in derive_completion\n+                .dependencies\n+                .into_iter()\n+                .filter(|&&dependency| !existing_derives.contains(dependency))\n+            {\n+                label.push_str(\", \");\n+                label.push_str(dependency);\n+            }\n+            let item = CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), label)\n+                .kind(CompletionItemKind::Attribute);\n+            acc.add(item);\n+        }\n+    }\n+}\n+\n+fn parse_derive_input(derive_input: ast::TokenTree) -> Result<FxHashSet<String>, ()> {\n+    match (derive_input.left_delimiter_token(), derive_input.right_delimiter_token()) {\n+        (Some(left_paren), Some(right_paren))\n+            if left_paren.kind() == SyntaxKind::L_PAREN\n+                && right_paren.kind() == SyntaxKind::R_PAREN =>\n+        {\n+            Ok(derive_input\n+                .syntax()\n+                .children_with_tokens()\n+                .filter_map(|child| child.into_token())\n+                .skip_while(|child| child != &left_paren)\n+                .take_while(|child| child != &right_paren)\n+                .filter(|child| child.kind() == SyntaxKind::IDENT)\n+                .map(|child| child.to_string())\n+                .collect())\n+        }\n+        _ => Err(()),\n+    }\n+}\n+\n+struct DeriveCompletion {\n+    label: &'static str,\n+    dependencies: &'static [&'static str],\n+}\n+\n+const DERIVE_COMPLETIONS: &[DeriveCompletion] = &[\n+    DeriveCompletion { label: \"Clone\", dependencies: &[] },\n+    DeriveCompletion { label: \"Copy\", dependencies: &[\"Clone\"] },\n+    DeriveCompletion { label: \"Debug\", dependencies: &[] },\n+    DeriveCompletion { label: \"Default\", dependencies: &[] },\n+    DeriveCompletion { label: \"Hash\", dependencies: &[] },\n+    DeriveCompletion { label: \"PartialEq\", dependencies: &[] },\n+    DeriveCompletion { label: \"Eq\", dependencies: &[\"PartialEq\"] },\n+    DeriveCompletion { label: \"PartialOrd\", dependencies: &[\"PartialEq\"] },\n+    DeriveCompletion { label: \"Ord\", dependencies: &[\"PartialOrd\", \"Eq\", \"PartialEq\"] },\n+];\n+\n #[cfg(test)]\n mod tests {\n     use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n@@ -135,6 +200,170 @@ mod tests {\n         do_completion(code, CompletionKind::Attribute)\n     }\n \n+    #[test]\n+    fn empty_derive_completion() {\n+        assert_debug_snapshot!(\n+            do_attr_completion(\n+                    r\"\n+                    #[derive(<|>)]\n+                    struct Test {}\n+                    \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Clone\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Copy, Clone\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Copy, Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Debug\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Debug\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Default\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Default\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Eq, PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Eq, PartialEq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Hash\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Hash\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Ord, PartialOrd, Eq, PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"Ord, PartialOrd, Eq, PartialEq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"PartialEq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"PartialOrd, PartialEq\",\n+                source_range: 30..30,\n+                delete: 30..30,\n+                insert: \"PartialOrd, PartialEq\",\n+                kind: Attribute,\n+            },\n+        ]\n+            \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn no_completion_for_incorrect_derive() {\n+        assert_debug_snapshot!(\n+            do_attr_completion(\n+                r\"\n+                    #[derive{<|>)]\n+                    struct Test {}\n+                    \",\n+            ),\n+            @\"[]\"\n+        );\n+    }\n+\n+    #[test]\n+    fn derive_with_input_completion() {\n+        assert_debug_snapshot!(\n+            do_attr_completion(\n+                    r\"\n+                    #[derive(Whatever, PartialEq, <|>)]\n+                    struct Test {}\n+                    \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Clone\",\n+                source_range: 51..51,\n+                delete: 51..51,\n+                insert: \"Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Copy, Clone\",\n+                source_range: 51..51,\n+                delete: 51..51,\n+                insert: \"Copy, Clone\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Debug\",\n+                source_range: 51..51,\n+                delete: 51..51,\n+                insert: \"Debug\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Default\",\n+                source_range: 51..51,\n+                delete: 51..51,\n+                insert: \"Default\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Eq\",\n+                source_range: 51..51,\n+                delete: 51..51,\n+                insert: \"Eq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Hash\",\n+                source_range: 51..51,\n+                delete: 51..51,\n+                insert: \"Hash\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"Ord, PartialOrd, Eq\",\n+                source_range: 51..51,\n+                delete: 51..51,\n+                insert: \"Ord, PartialOrd, Eq\",\n+                kind: Attribute,\n+            },\n+            CompletionItem {\n+                label: \"PartialOrd\",\n+                source_range: 51..51,\n+                delete: 51..51,\n+                insert: \"PartialOrd\",\n+                kind: Attribute,\n+            },\n+        ]\n+            \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_attribute_completion() {\n         assert_debug_snapshot!("}, {"sha": "dd87bd119e1973317e53ff2d57046767a544c2a1", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/767bff89ededdff875b042bb37397b972e3a82f1/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767bff89ededdff875b042bb37397b972e3a82f1/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=767bff89ededdff875b042bb37397b972e3a82f1", "patch": "@@ -58,7 +58,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_macro_call: bool,\n     pub(super) is_path_type: bool,\n     pub(super) has_type_args: bool,\n-    pub(super) is_attribute: bool,\n+    pub(super) attribute_under_caret: Option<ast::Attr>,\n }\n \n impl<'a> CompletionContext<'a> {\n@@ -116,7 +116,7 @@ impl<'a> CompletionContext<'a> {\n             is_path_type: false,\n             has_type_args: false,\n             dot_receiver_is_ambiguous_float_literal: false,\n-            is_attribute: false,\n+            attribute_under_caret: None,\n         };\n \n         let mut original_file = original_file.syntax().clone();\n@@ -200,6 +200,7 @@ impl<'a> CompletionContext<'a> {\n                 Some(ty)\n             })\n             .flatten();\n+        self.attribute_under_caret = find_node_at_offset(&file_with_fake_ident, offset);\n \n         // First, let's try to complete a reference to some declaration.\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&file_with_fake_ident, offset) {\n@@ -318,7 +319,6 @@ impl<'a> CompletionContext<'a> {\n                 .and_then(|it| it.syntax().parent().and_then(ast::CallExpr::cast))\n                 .is_some();\n             self.is_macro_call = path.syntax().parent().and_then(ast::MacroCall::cast).is_some();\n-            self.is_attribute = path.syntax().parent().and_then(ast::Attr::cast).is_some();\n \n             self.is_path_type = path.syntax().parent().and_then(ast::PathType::cast).is_some();\n             self.has_type_args = segment.type_arg_list().is_some();"}]}