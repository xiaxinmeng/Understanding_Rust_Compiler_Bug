{"sha": "76ec67063e3b310aca4d4164577d167862d1bf73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZWM2NzA2M2UzYjMxMGFjYTRkNDE2NDU3N2QxNjc4NjJkMWJmNzM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-04T23:08:33Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-04T23:10:22Z"}, "message": "rustc: Don't use recursive types for tags; remove tag_info; introduce GEP_tag()", "tree": {"sha": "bf81a9700015f8433f9b3de42b909f0bb370fe48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf81a9700015f8433f9b3de42b909f0bb370fe48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76ec67063e3b310aca4d4164577d167862d1bf73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76ec67063e3b310aca4d4164577d167862d1bf73", "html_url": "https://github.com/rust-lang/rust/commit/76ec67063e3b310aca4d4164577d167862d1bf73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76ec67063e3b310aca4d4164577d167862d1bf73/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "596face2745ccc11a959a530807ea3e36e9d1354", "url": "https://api.github.com/repos/rust-lang/rust/commits/596face2745ccc11a959a530807ea3e36e9d1354", "html_url": "https://github.com/rust-lang/rust/commit/596face2745ccc11a959a530807ea3e36e9d1354"}], "stats": {"total": 262, "additions": 154, "deletions": 108}, "files": [{"sha": "66539ab2a1ffa3c8cb0b8b1da39b71fd697b265b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 154, "deletions": 108, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/76ec67063e3b310aca4d4164577d167862d1bf73/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ec67063e3b310aca4d4164577d167862d1bf73/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=76ec67063e3b310aca4d4164577d167862d1bf73", "patch": "@@ -60,8 +60,6 @@ type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef bzero_glue,\n                     ValueRef vec_append_glue);\n \n-type tag_info = rec(type_handle th);\n-\n state type crate_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n                             target_data td,\n@@ -74,7 +72,8 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, @ast.item] items,\n                             hashmap[ast.def_id,\n                                     @ast.native_item] native_items,\n-                            hashmap[@ty.t, @tag_info] tags,\n+                            // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n+                            hashmap[@ty.t, uint] tag_sizes,\n                             hashmap[ast.def_id, ValueRef] discrims,\n                             hashmap[ast.def_id, ValueRef] fn_pairs,\n                             hashmap[ast.def_id, ValueRef] consts,\n@@ -395,16 +394,30 @@ fn T_opaque_closure_ptr(type_names tn) -> TypeRef {\n     ret t;\n }\n \n-fn T_opaque_tag_ptr(type_names tn) -> TypeRef {\n-    auto s = \"*tag\";\n+fn T_tag(type_names tn, uint size) -> TypeRef {\n+    auto s = \"tag_\" + _uint.to_str(size, 10u);\n+    if (tn.name_has_type(s)) {\n+        ret tn.get_type(s);\n+    }\n+    auto t = T_struct(vec(T_int(), T_array(T_i8(), size)));\n+    tn.associate(s, t);\n+    ret t;\n+}\n+\n+fn T_opaque_tag(type_names tn) -> TypeRef {\n+    auto s = \"tag\";\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n     }\n-    auto t = T_ptr(T_struct(vec(T_int(), T_i8())));\n+    auto t = T_struct(vec(T_int(), T_i8()));\n     tn.associate(s, t);\n     ret t;\n }\n \n+fn T_opaque_tag_ptr(type_names tn) -> TypeRef {\n+    ret T_ptr(T_opaque_tag(tn));\n+}\n+\n fn T_captured_tydescs(type_names tn, uint n) -> TypeRef {\n     ret T_struct(_vec.init_elt[TypeRef](T_ptr(T_tydesc(tn)), n));\n }\n@@ -436,7 +449,7 @@ fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n         fail;\n     }\n \n-    ret type_of_inner(cx, t);\n+    ret type_of_inner(cx, t, false);\n }\n \n fn type_of_explicit_args(@crate_ctxt cx,\n@@ -447,12 +460,14 @@ fn type_of_explicit_args(@crate_ctxt cx,\n             check (arg.mode == ast.alias);\n             atys += T_typaram_ptr(cx.tn);\n         } else {\n-            let TypeRef t = type_of_inner(cx, arg.ty);\n+            let TypeRef t;\n             alt (arg.mode) {\n                 case (ast.alias) {\n-                    t = T_ptr(t);\n+                    t = T_ptr(type_of_inner(cx, arg.ty, true));\n+                }\n+                case (_) {\n+                    t = type_of_inner(cx, arg.ty, false);\n                 }\n-                case (_) { /* fall through */  }\n             }\n             atys += t;\n         }\n@@ -478,7 +493,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n     if (ty.type_has_dynamic_size(output)) {\n         atys += T_typaram_ptr(cx.tn);\n     } else {\n-        atys += T_ptr(type_of_inner(cx, output));\n+        atys += T_ptr(type_of_inner(cx, output, false));\n     }\n \n     // Arg 1: Task pointer.\n@@ -545,10 +560,10 @@ fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n         }\n     }\n     atys += type_of_explicit_args(cx, inputs);\n-    ret T_fn(atys, type_of_inner(cx, output));\n+    ret T_fn(atys, type_of_inner(cx, output, false));\n }\n \n-fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n+fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n     let TypeRef llty = 0 as TypeRef;\n \n     alt (t.struct) {\n@@ -573,26 +588,31 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n         }\n         case (ty.ty_char) { llty = T_char(); }\n         case (ty.ty_str) { llty = T_ptr(T_str()); }\n-        case (ty.ty_tag(?tag_id, _)) {\n-            llty = llvm.LLVMResolveTypeHandle(cx.tags.get(t).th.llth);\n+        case (ty.ty_tag(_, _)) {\n+            if (boxed) {\n+                llty = T_opaque_tag(cx.tn);\n+            } else {\n+                auto size = static_size_of_tag(cx, t);\n+                llty = T_tag(cx.tn, size);\n+            }\n         }\n         case (ty.ty_box(?t)) {\n-            llty = T_ptr(T_box(type_of_inner(cx, t)));\n+            llty = T_ptr(T_box(type_of_inner(cx, t, true)));\n         }\n         case (ty.ty_vec(?t)) {\n-            llty = T_ptr(T_vec(type_of_inner(cx, t)));\n+            llty = T_ptr(T_vec(type_of_inner(cx, t, true)));\n         }\n         case (ty.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n             for (@ty.t elt in elts) {\n-                tys += type_of_inner(cx, elt);\n+                tys += type_of_inner(cx, elt, boxed);\n             }\n             llty = T_struct(tys);\n         }\n         case (ty.ty_rec(?fields)) {\n             let vec[TypeRef] tys = vec();\n             for (ty.field f in fields) {\n-                tys += type_of_inner(cx, f.ty);\n+                tys += type_of_inner(cx, f.ty, boxed);\n             }\n             llty = T_struct(tys);\n         }\n@@ -650,9 +670,11 @@ fn type_of_arg(@crate_ctxt cx, &ty.arg arg) -> TypeRef {\n         }\n     }\n \n-    auto typ = type_of_inner(cx, arg.ty);\n+    auto typ;\n     if (arg.mode == ast.alias) {\n-        typ = T_ptr(typ);\n+        typ = T_ptr(type_of_inner(cx, arg.ty, true));\n+    } else {\n+        typ = type_of_inner(cx, arg.ty, false);\n     }\n     ret typ;\n }\n@@ -856,6 +878,11 @@ fn align_to(@block_ctxt cx, ValueRef off, ValueRef align) -> ValueRef {\n     ret cx.build.And(bumped, cx.build.Not(mask));\n }\n \n+// Returns the real size of the given type for the current target.\n+fn llsize_of_real(@crate_ctxt cx, TypeRef t) -> uint {\n+    ret llvm.LLVMStoreSizeOfType(cx.td.lltd, t);\n+}\n+\n fn llsize_of(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntCast(lib.llvm.llvm.LLVMSizeOf(t), T_int(), False);\n }\n@@ -878,6 +905,49 @@ fn align_of(@block_ctxt cx, @ty.t t) -> result {\n     ret dynamic_align_of(cx, t);\n }\n \n+// Computes the size of the data part of a non-dynamically-sized tag.\n+fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n+    if (ty.type_has_dynamic_size(t)) {\n+        log \"dynamically sized type passed to static_size_of_tag()\";\n+        fail;\n+    }\n+\n+    if (cx.tag_sizes.contains_key(t)) {\n+        ret cx.tag_sizes.get(t);\n+    }\n+\n+    auto tid = tup(0, 0);           // FIXME (#250): typestate botch\n+    let vec[@ty.t] subtys = vec();  // FIXME (#250): typestate botch\n+    alt (t.struct) {\n+        case (ty.ty_tag(?tid_, ?subtys_)) {\n+            tid = tid_;\n+            subtys = subtys_;\n+        }\n+        case (_) {\n+            log \"non-tag passed to static_size_of_tag()\";\n+            fail;\n+        }\n+    }\n+\n+    // Compute max(variant sizes).\n+    auto max_size = 0u;\n+    auto variants = tag_variants(cx, tid);\n+    for (ast.variant variant in variants) {\n+        let vec[@ty.t] tys = variant_types(cx, variant);\n+        auto tup_ty = ty.plain_ty(ty.ty_tup(tys));\n+\n+        // Here we possibly do a recursive call.\n+        auto this_size = llsize_of_real(cx, type_of(cx, tup_ty));\n+\n+        if (max_size < this_size) {\n+            max_size = this_size;\n+        }\n+    }\n+\n+    cx.tag_sizes.insert(t, max_size);\n+    ret max_size;\n+}\n+\n fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n     fn align_elements(@block_ctxt cx, vec[@ty.t] elts) -> result {\n         //\n@@ -974,10 +1044,10 @@ fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n }\n \n // Replacement for the LLVM 'GEP' instruction when field-indexing into a\n-// tuple-like structure (tup, rec, tag) with a static index. This one is\n-// driven off ty.struct and knows what to do when it runs into a ty_param\n-// stuck in the middle of the thing it's GEP'ing into. Much like size_of and\n-// align_of, above.\n+// tuple-like structure (tup, rec) with a static index. This one is driven off\n+// ty.struct and knows what to do when it runs into a ty_param stuck in the\n+// middle of the thing it's GEP'ing into. Much like size_of and align_of,\n+// above.\n \n fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n                 ValueRef base, vec[int] ixs) -> result {\n@@ -1076,6 +1146,53 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n     ret res(bcx, bcx.build.PointerCast(bumped, typ));\n }\n \n+// Replacement for the LLVM 'GEP' instruction when field indexing into a tag.\n+// This function uses GEP_tup_like() above and automatically performs casts as\n+// appropriate. @llblobptr is the data part of a tag value; its actual type is\n+// meaningless, as it will be cast away.\n+fn GEP_tag(@block_ctxt cx, ValueRef llblobptr, &ast.variant variant, int ix)\n+        -> result {\n+    // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n+    // Separately, store the type of the element we're interested in.\n+    auto arg_tys = arg_tys_of_fn(variant.ann);\n+    auto elem_ty = ty.plain_ty(ty.ty_nil);  // typestate infelicity\n+    auto i = 0;\n+    let vec[@ty.t] true_arg_tys = vec();\n+    for (ty.arg a in arg_tys) {\n+        true_arg_tys += vec(a.ty);\n+        if (i == ix) {\n+            elem_ty = a.ty;\n+        }\n+\n+        i += 1;\n+    }\n+    auto tup_ty = ty.plain_ty(ty.ty_tup(true_arg_tys));\n+\n+    // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n+    // the blob pointer isn't dynamically sized).\n+    let ValueRef llunionptr;\n+    if (!ty.type_has_dynamic_size(tup_ty)) {\n+        auto llty = type_of(cx.fcx.ccx, tup_ty);\n+        llunionptr = cx.build.TruncOrBitCast(llblobptr, T_ptr(llty));\n+    } else {\n+        llunionptr = llblobptr;\n+    }\n+\n+    // Do the GEP_tup_like().\n+    auto rslt = GEP_tup_like(cx, tup_ty, llunionptr, vec(0, ix));\n+\n+    // Cast the result to the appropriate type, if necessary.\n+    auto val;\n+    if (!ty.type_has_dynamic_size(elem_ty)) {\n+        auto llelemty = type_of(rslt.bcx.fcx.ccx, elem_ty);\n+        val = rslt.bcx.build.PointerCast(rslt.val, T_ptr(llelemty));\n+    } else {\n+        val = rslt.val;\n+    }\n+\n+    ret res(rslt.bcx, val);\n+}\n+\n \n fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n         -> result {\n@@ -1527,6 +1644,7 @@ fn variant_types(@crate_ctxt cx, &ast.variant v) -> vec[@ty.t] {\n                 tys += vec(arg.ty);\n             }\n         }\n+        case (ty.ty_tag(_, _)) { /* nothing */ }\n         case (_) { fail; }\n     }\n     ret tys;\n@@ -1647,8 +1765,6 @@ fn iter_structural_ty_full(@block_ctxt cx,\n             }\n         }\n         case (ty.ty_tag(?tid, ?tps)) {\n-            auto info = cx.fcx.ccx.tags.get(mk_plain_tag(tid));\n-\n             auto variants = tag_variants(cx.fcx.ccx, tid);\n             auto n_variants = _vec.len[ast.variant](variants);\n \n@@ -4653,14 +4769,6 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     auto arg_tys = arg_tys_of_fn(variant.ann);\n     copy_args_to_allocas(bcx, none[TypeRef], fn_args, arg_tys);\n \n-    // Now synthesize a tuple type for the arguments, so that GEP_tup_like()\n-    // will know what the data part of the variant looks like.\n-    let vec[@ty.t] true_arg_tys = vec();\n-    for (ty.arg a in arg_tys) {\n-        true_arg_tys += vec(a.ty);\n-    }\n-    auto tup_ty = ty.plain_ty(ty.ty_tup(true_arg_tys));\n-\n     // Cast the tag to a type we can GEP into.\n     auto lltagptr = bcx.build.PointerCast(fcx.llretptr,\n                                           T_opaque_tag_ptr(fcx.ccx.tn));\n@@ -4672,23 +4780,19 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     auto llblobptr = bcx.build.GEP(lltagptr,\n                                    vec(C_int(0), C_int(1)));\n \n-    // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n-    // the blob pointer isn't dynamically sized).\n-    let ValueRef llunionptr;\n-    if (!ty.type_has_dynamic_size(tup_ty)) {\n-        auto llty = type_of(cx, tup_ty);\n-        llunionptr = bcx.build.TruncOrBitCast(llblobptr, T_ptr(llty));\n-    } else {\n-        llunionptr = llblobptr;\n-    }\n-\n     i = 0u;\n     for (ast.variant_arg va in variant.args) {\n-        auto llargval = bcx.build.Load(fcx.llargs.get(va.id));\n-        auto rslt = GEP_tup_like(bcx, tup_ty, llunionptr, vec(0, i as int));\n+        auto rslt = GEP_tag(bcx, llblobptr, variant, i as int);\n         bcx = rslt.bcx;\n         auto lldestptr = rslt.val;\n \n+        // If this argument to this function is a tag, it'll have come in to\n+        // this function as an opaque blob due to the way that type_of()\n+        // works. So we have to cast to the destination's view of the type.\n+        auto llargptr = bcx.build.PointerCast(fcx.llargs.get(va.id),\n+            val_ty(lldestptr));\n+        auto llargval = bcx.build.Load(llargptr);\n+\n         bcx.build.Store(llargval, lldestptr);\n         i += 1u;\n     }\n@@ -4747,6 +4851,7 @@ fn trans_item(@crate_ctxt cx, &ast.item item) {\n         case (ast.item_tag(?name, ?variants, ?tps, ?tag_id)) {\n             auto sub_cx = @rec(path=cx.path + sep() + name with *cx);\n             auto i = 0;\n+            log \"translating variants for \" + name;\n             for (ast.variant variant in variants) {\n                 trans_tag_variant(sub_cx, tag_id, variant, i, tps);\n                 i += 1;\n@@ -4885,12 +4990,6 @@ fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n         }\n \n         case (ast.item_tag(_, ?variants, ?tps, ?tag_id)) {\n-            auto vi = new_def_hash[uint]();\n-            auto navi = new_def_hash[uint]();\n-\n-            auto info = @rec(th=mk_type_handle());\n-\n-            cx.tags.insert(mk_plain_tag(tag_id), info);\n             cx.items.insert(tag_id, i);\n         }\n \n@@ -4942,58 +5041,6 @@ fn collect_tag_ctors(@crate_ctxt cx, @ast.crate crate) {\n }\n \n \n-// The tag type resolution pass, which determines all the LLVM types that\n-// correspond to each tag type in the crate.\n-\n-fn resolve_tag_types_for_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n-    alt (i.node) {\n-        case (ast.item_tag(_, ?variants, _, ?tag_id)) {\n-            // FIXME: This is all wrong. Now sizes and alignments are computed\n-            // dynamically instead of up front.\n-\n-            auto max_align = 0u;\n-            auto max_size = 0u;\n-\n-            auto info = cx.tags.get(mk_plain_tag(tag_id));\n-\n-            for (ast.variant variant in variants) {\n-                if (_vec.len[ast.variant_arg](variant.args) > 0u) {\n-                    auto llvariantty = type_of_variant(cx, variant);\n-                    auto align =\n-                        llvm.LLVMPreferredAlignmentOfType(cx.td.lltd,\n-                                                          llvariantty);\n-                    auto size =\n-                        llvm.LLVMStoreSizeOfType(cx.td.lltd,\n-                                                 llvariantty) as uint;\n-                    if (max_align < align) { max_align = align; }\n-                    if (max_size < size) { max_size = size; }\n-                }\n-            }\n-\n-            // FIXME: alignment is wrong here, manually insert padding I\n-            // guess :(\n-            auto tag_ty = T_struct(vec(T_int(), T_array(T_i8(), max_size)));\n-            auto th = info.th.llth;\n-            llvm.LLVMRefineType(llvm.LLVMResolveTypeHandle(th), tag_ty);\n-        }\n-        case (_) {\n-            // fall through\n-        }\n-    }\n-\n-    ret cx;\n-}\n-\n-fn resolve_tag_types(@crate_ctxt cx, @ast.crate crate) {\n-    let fold.ast_fold[@crate_ctxt] fld =\n-        fold.new_identity_fold[@crate_ctxt]();\n-\n-    fld = @rec( update_env_for_item = bind resolve_tag_types_for_item(_,_)\n-                with *fld );\n-\n-    fold.fold_crate[@crate_ctxt](cx, fld, crate);\n-}\n-\n // The constant translation pass.\n \n fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n@@ -5461,7 +5508,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     auto glues = make_glues(llmod, tn);\n     auto hasher = ty.hash_ty;\n     auto eqer = ty.eq_ty;\n-    auto tags = map.mk_hashmap[@ty.t,@tag_info](hasher, eqer);\n+    auto tag_sizes = map.mk_hashmap[@ty.t,uint](hasher, eqer);\n     auto tydescs = map.mk_hashmap[@ty.t,ValueRef](hasher, eqer);\n     let vec[ast.ty_param] obj_typarams = vec();\n     let vec[ast.obj_field] obj_fields = vec();\n@@ -5477,7 +5524,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n                    item_ids = new_def_hash[ValueRef](),\n                    items = new_def_hash[@ast.item](),\n                    native_items = new_def_hash[@ast.native_item](),\n-                   tags = tags,\n+                   tag_sizes = tag_sizes,\n                    discrims = new_def_hash[ValueRef](),\n                    fn_pairs = new_def_hash[ValueRef](),\n                    consts = new_def_hash[ValueRef](),\n@@ -5492,7 +5539,6 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     create_typedefs(cx);\n \n     collect_items(cx, crate);\n-    resolve_tag_types(cx, crate);\n     collect_tag_ctors(cx, crate);\n     trans_constants(cx, crate);\n "}]}