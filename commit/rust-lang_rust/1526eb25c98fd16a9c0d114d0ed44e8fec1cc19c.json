{"sha": "1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MjZlYjI1Yzk4ZmQxNmE5YzBkMTE0ZDBlZDQ0ZThmZWMxY2MxOWM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-10T19:44:34Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-13T19:10:09Z"}, "message": "Import the prelude", "tree": {"sha": "1acf0f556de14a2fac88929db9af96025a47f79f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1acf0f556de14a2fac88929db9af96025a47f79f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "html_url": "https://github.com/rust-lang/rust/commit/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65266c644a31e6b321e5afb3c5a2ee75be76cb0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/65266c644a31e6b321e5afb3c5a2ee75be76cb0c", "html_url": "https://github.com/rust-lang/rust/commit/65266c644a31e6b321e5afb3c5a2ee75be76cb0c"}], "stats": {"total": 111, "additions": 99, "deletions": 12}, "files": [{"sha": "16852a6a14074c87f43f84191cf3ead25ccd5c3b", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "patch": "@@ -6,4 +6,5 @@ test_utils::marks!(\n     type_var_resolves_to_int_var\n     glob_enum\n     glob_across_crates\n+    std_prelude\n );"}, {"sha": "2ba6038c67d058a10b2bd3beef89e29f223a466f", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "patch": "@@ -34,6 +34,10 @@ use crate::{\n /// module, the set of visible items.\n #[derive(Default, Debug, PartialEq, Eq)]\n pub struct ItemMap {\n+    /// The prelude module for this crate. This either comes from an import\n+    /// marked with the `prelude_import` attribute, or (in the normal case) from\n+    /// a dependency (`std` or `core`).\n+    prelude: Option<Module>,\n     pub(crate) extern_prelude: FxHashMap<Name, ModuleDef>,\n     per_module: ArenaMap<ModuleId, ModuleScope>,\n }\n@@ -211,6 +215,13 @@ where\n             if let Some(module) = dep.krate.root_module(self.db) {\n                 self.result.extern_prelude.insert(dep.name.clone(), module.into());\n             }\n+            // look for the prelude\n+            if self.result.prelude.is_none() {\n+                let item_map = self.db.item_map(dep.krate);\n+                if item_map.prelude.is_some() {\n+                    self.result.prelude = item_map.prelude;\n+                }\n+            }\n         }\n     }\n \n@@ -279,7 +290,10 @@ where\n             log::debug!(\"glob import: {:?}\", import);\n             match def.take_types() {\n                 Some(ModuleDef::Module(m)) => {\n-                    if m.krate != self.krate {\n+                    if import.is_prelude {\n+                        tested_by!(std_prelude);\n+                        self.result.prelude = Some(m);\n+                    } else if m.krate != self.krate {\n                         tested_by!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n                         let item_map = self.db.item_map(m.krate);\n@@ -434,12 +448,40 @@ impl ItemMap {\n         self.resolve_path_fp(db, original_module, path).0\n     }\n \n-    pub(crate) fn resolve_name_in_module(&self, module: Module, name: &Name) -> PerNs<ModuleDef> {\n+    fn resolve_in_prelude(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        original_module: Module,\n+        name: &Name,\n+    ) -> PerNs<ModuleDef> {\n+        if let Some(prelude) = self.prelude {\n+            let resolution = if prelude.krate == original_module.krate {\n+                self[prelude.module_id].items.get(name).cloned()\n+            } else {\n+                db.item_map(prelude.krate)[prelude.module_id].items.get(name).cloned()\n+            };\n+            resolution.map(|r| r.def).unwrap_or_else(PerNs::none)\n+        } else {\n+            PerNs::none()\n+        }\n+    }\n+\n+    pub(crate) fn resolve_name_in_module(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        module: Module,\n+        name: &Name,\n+    ) -> PerNs<ModuleDef> {\n+        // Resolve in:\n+        //  - current module / scope\n+        //  - extern prelude\n+        //  - std prelude\n         let from_scope = self[module.module_id].items.get(name).map_or(PerNs::none(), |it| it.def);\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_prelude = self.resolve_in_prelude(db, module, name);\n \n-        from_scope.or(from_extern_prelude)\n+        from_scope.or(from_extern_prelude).or(from_prelude)\n     }\n \n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n@@ -459,7 +501,7 @@ impl ItemMap {\n                     Some((_, segment)) => segment,\n                     None => return (PerNs::none(), ReachedFixedPoint::Yes),\n                 };\n-                self.resolve_name_in_module(original_module, &segment.name)\n+                self.resolve_name_in_module(db, original_module, &segment.name)\n             }\n             PathKind::Super => {\n                 if let Some(p) = original_module.parent(db) {"}, {"sha": "922dbe9c18eb9e417cd005c9240009c23da52f67", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "patch": "@@ -2,7 +2,7 @@ use std::sync::Arc;\n \n use ra_syntax::{\n     AstNode, SourceFile, TreeArc, AstPtr,\n-    ast::{self, ModuleItemOwner, NameOwner},\n+    ast::{self, ModuleItemOwner, NameOwner, AttrsOwner},\n };\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use rustc_hash::FxHashMap;\n@@ -23,6 +23,7 @@ pub(super) struct ImportData {\n     pub(super) path: Path,\n     pub(super) alias: Option<Name>,\n     pub(super) is_glob: bool,\n+    pub(super) is_prelude: bool,\n     pub(super) is_extern_crate: bool,\n }\n \n@@ -191,6 +192,7 @@ impl LoweredModule {\n                         path,\n                         alias,\n                         is_glob: false,\n+                        is_prelude: false,\n                         is_extern_crate: true,\n                     });\n                 }\n@@ -214,11 +216,14 @@ impl LoweredModule {\n     }\n \n     fn add_use_item(&mut self, source_map: &mut ImportSourceMap, item: &ast::UseItem) {\n+        let is_prelude =\n+            item.attrs().any(|attr| attr.as_atom().map(|s| s == \"prelude_import\").unwrap_or(false));\n         Path::expand_use_item(item, |path, segment, alias| {\n             let import = self.imports.alloc(ImportData {\n                 path,\n                 alias,\n                 is_glob: segment.is_none(),\n+                is_prelude,\n                 is_extern_crate: false,\n             });\n             if let Some(segment) = segment {"}, {"sha": "68ebe963a7b127e07b2b3c4dad0c5e58419631a3", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "patch": "@@ -296,6 +296,43 @@ fn module_resolution_works_for_non_standard_filenames() {\n     );\n }\n \n+#[test]\n+fn std_prelude() {\n+    covers!(std_prelude);\n+    let mut db = MockDatabase::with_files(\n+        \"\n+        //- /main.rs\n+        use Foo::*;\n+\n+        //- /lib.rs\n+        mod prelude;\n+        #[prelude_import]\n+        use prelude::*;\n+\n+        //- /prelude.rs\n+        pub enum Foo { Bar, Baz };\n+    \",\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"test_crate\"]),\n+        \"test_crate\": (\"/lib.rs\", []),\n+    });\n+    let main_id = db.file_id_of(\"/main.rs\");\n+\n+    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate);\n+\n+    check_module_item_map(\n+        &item_map,\n+        module.module_id,\n+        \"\n+            Bar: t v\n+            Baz: t v\n+        \",\n+    );\n+}\n+\n #[test]\n fn name_res_works_for_broken_modules() {\n     covers!(name_res_works_for_broken_modules);"}, {"sha": "fde4d6580d4e3ac0d6d85f0d52f22f42cd2334e0", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "patch": "@@ -56,10 +56,10 @@ pub enum Resolution {\n }\n \n impl Resolver {\n-    pub fn resolve_name(&self, name: &Name) -> PerNs<Resolution> {\n+    pub fn resolve_name(&self, db: &impl HirDatabase, name: &Name) -> PerNs<Resolution> {\n         let mut resolution = PerNs::none();\n         for scope in self.scopes.iter().rev() {\n-            resolution = resolution.or(scope.resolve_name(name));\n+            resolution = resolution.or(scope.resolve_name(db, name));\n             if resolution.is_both() {\n                 return resolution;\n             }\n@@ -69,9 +69,9 @@ impl Resolver {\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<Resolution> {\n         if let Some(name) = path.as_ident() {\n-            self.resolve_name(name)\n+            self.resolve_name(db, name)\n         } else if path.is_self() {\n-            self.resolve_name(&Name::self_param())\n+            self.resolve_name(db, &Name::self_param())\n         } else {\n             let (item_map, module) = match self.module() {\n                 Some(m) => m,\n@@ -143,13 +143,13 @@ impl Resolver {\n }\n \n impl Scope {\n-    fn resolve_name(&self, name: &Name) -> PerNs<Resolution> {\n+    fn resolve_name(&self, db: &impl HirDatabase, name: &Name) -> PerNs<Resolution> {\n         match self {\n             Scope::ModuleScope(m) => {\n                 if let Some(KnownName::SelfParam) = name.as_known_name() {\n                     PerNs::types(Resolution::Def(m.module.into()))\n                 } else {\n-                    m.item_map.resolve_name_in_module(m.module, name).map(Resolution::Def)\n+                    m.item_map.resolve_name_in_module(db, m.module, name).map(Resolution::Def)\n                 }\n             }\n             Scope::GenericParams(gp) => match gp.find_by_name(name) {"}, {"sha": "7c5e8ce5ed0df3cc4d237ba72c2785ca93cbff00", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "patch": "@@ -4210,6 +4210,7 @@ impl ToOwned for UseItem {\n }\n \n \n+impl ast::AttrsOwner for UseItem {}\n impl UseItem {\n     pub fn use_tree(&self) -> Option<&UseTree> {\n         super::child_opt(self)"}, {"sha": "304bc59096e08e11741c2f2ae37de16ddf11385f", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=1526eb25c98fd16a9c0d114d0ed44e8fec1cc19c", "patch": "@@ -596,7 +596,8 @@ Grammar(\n             options: [ \"Pat\", \"TypeRef\" ],\n         ),\n         \"UseItem\": (\n-            options: [ \"UseTree\" ]\n+            traits: [\"AttrsOwner\"],\n+            options: [ \"UseTree\" ],\n         ),\n         \"UseTree\": (\n             options: [ \"Path\", \"UseTreeList\", \"Alias\" ]"}]}