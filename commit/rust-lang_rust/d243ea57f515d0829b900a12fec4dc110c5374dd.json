{"sha": "d243ea57f515d0829b900a12fec4dc110c5374dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNDNlYTU3ZjUxNWQwODI5YjkwMGExMmZlYzRkYzExMGM1Mzc0ZGQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-29T09:18:40Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-29T09:41:45Z"}, "message": "Move last remaining expression types out of trans_expr\n\nIssue #667", "tree": {"sha": "665cbcbfe7577c6c67e961b94a8000ea55b9cb92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/665cbcbfe7577c6c67e961b94a8000ea55b9cb92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d243ea57f515d0829b900a12fec4dc110c5374dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d243ea57f515d0829b900a12fec4dc110c5374dd", "html_url": "https://github.com/rust-lang/rust/commit/d243ea57f515d0829b900a12fec4dc110c5374dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d243ea57f515d0829b900a12fec4dc110c5374dd/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f089f533e854fc3824828bc3dcb2ceb0309b57ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/f089f533e854fc3824828bc3dcb2ceb0309b57ac", "html_url": "https://github.com/rust-lang/rust/commit/f089f533e854fc3824828bc3dcb2ceb0309b57ac"}], "stats": {"total": 137, "additions": 58, "deletions": 79}, "files": [{"sha": "9831acc4f1d9cdae4e5c4ec1702fbfd6026cbaaf", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 32, "deletions": 43, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d243ea57f515d0829b900a12fec4dc110c5374dd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d243ea57f515d0829b900a12fec4dc110c5374dd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d243ea57f515d0829b900a12fec4dc110c5374dd", "patch": "@@ -2243,10 +2243,7 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n         trans_closure(sub_cx, sp, f, llfn, none, [], id, {|_fcx|});\n       }\n     };\n-    let addr = alt dest {\n-      save_in(a) { a }\n-      overwrite(a, ty) { bcx = drop_ty(bcx, a, ty); a }\n-    };\n+    let {bcx, val: addr} = get_dest_addr(bcx, dest);\n     fill_fn_pair(bcx, addr, llfn, env);\n     ret bcx;\n }\n@@ -2537,6 +2534,13 @@ fn store_in_dest(bcx: @block_ctxt, val: ValueRef, dest: dest) -> @block_ctxt {\n     ret bcx;\n }\n \n+fn get_dest_addr(bcx: @block_ctxt, dest: dest) -> result {\n+    alt dest {\n+      save_in(a) { rslt(bcx, a) }\n+      overwrite(a, t) { rslt(drop_ty(bcx, a, t), a) }\n+    }\n+}\n+\n // Wrapper through which legacy non-DPS code can use DPS functions\n fn dps_to_result(bcx: @block_ctxt,\n                  work: block(@block_ctxt, dest) -> @block_ctxt,\n@@ -3675,12 +3679,8 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n         bcx = lv.bcx;\n         // FIXME[DPS] factor this out\n-        let addr = alt dest {\n-          save_in(a) { a }\n-          overwrite(a, ty) { bcx = drop_ty(bcx, a, ty); a }\n-        };\n-        bcx = memmove_ty(bcx, addr, lv.val, pair_ty);\n-        ret bcx;\n+        let {bcx, val: addr} = get_dest_addr(bcx, dest);\n+        ret memmove_ty(bcx, addr, lv.val, pair_ty);\n     }\n     let closure = alt f_res.env {\n       null_env. { none }\n@@ -3717,10 +3717,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n                          closure.ptrty, ty_param_count, target_res);\n \n     // Fill the function pair\n-    let addr = alt dest {\n-      save_in(a) { a }\n-      overwrite(a, ty) { bcx = drop_ty(bcx, a, ty); a }\n-    };\n+    let {bcx, val: addr} = get_dest_addr(bcx, dest);\n     fill_fn_pair(bcx, addr, llthunk.val, closure.ptr);\n     ret bcx;\n }\n@@ -4186,25 +4183,18 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n     ret bcx;\n }\n \n+// FIXME[DPS] remove this entirely, rename trans_expr_dps to trans_expr\n fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n-    // Fixme Fill in cx.sp\n-    alt e.node {\n-      ast::expr_anon_obj(anon_obj) {\n-        ret trans_anon_obj(cx, e.span, anon_obj, e.id);\n-      }\n-      ast::expr_call(_, _) | ast::expr_field(_, _) | ast::expr_index(_, _) |\n-      ast::expr_path(_) | ast::expr_unary(ast::deref., _) {\n+    if expr_is_lval(bcx_tcx(cx), e) {\n         let t = ty::expr_ty(bcx_tcx(cx), e);\n         let sub = trans_lval(cx, e);\n         let v = sub.val;\n         if sub.is_mem { v = load_if_immediate(sub.bcx, v, t); }\n         ret rslt(sub.bcx, v);\n-      }\n-      // Fall through to DPS-style\n-      _ {\n+    } else {\n+        // Fall through to DPS-style\n         ret dps_to_result(cx, {|bcx, dest| trans_expr_dps(bcx, e, dest)},\n                           ty::expr_ty(bcx_tcx(cx), e));\n-      }\n     }\n }\n \n@@ -4234,6 +4224,9 @@ fn trans_expr_by_ref(bcx: @block_ctxt, e: @ast::expr) -> result {\n // - exprs returning non-immediates get save_in (or by_ref when lval)\n fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n     -> @block_ctxt {\n+    let tcx = bcx_tcx(bcx);\n+    if expr_is_lval(tcx, e) { ret lval_to_dps(bcx, e, dest); }\n+\n     alt e.node {\n       ast::expr_if(cond, thn, els) | ast::expr_if_check(cond, thn, els) {\n         ret trans_if(bcx, cond, thn, els, dest);\n@@ -4261,22 +4254,23 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       ast::expr_vec(args, _) { ret tvec::trans_vec(bcx, args, e.id, dest); }\n       ast::expr_binary(op, x, y) { ret trans_binary(bcx, op, x, y, dest); }\n       ast::expr_unary(op, x) {\n-        if op == ast::deref {\n-            ret trans_expr_backwards_compat(bcx, e, dest);\n-        }\n+        assert op != ast::deref; // lvals are handled above\n         ret trans_unary(bcx, op, x, e.id, dest);\n       }\n       ast::expr_fn(f) { ret trans_expr_fn(bcx, f, e.span, e.id, dest); }\n       ast::expr_bind(f, args) { ret trans_bind(bcx, f, args, e.id, dest); }\n       ast::expr_copy(a) {\n-        if !expr_is_lval(bcx_tcx(bcx), a) {\n-            ret trans_expr_dps(bcx, a, dest);\n-        } else {\n-            // FIXME[DPS] give this a name that makes more sense\n-            ret trans_expr_backwards_compat(bcx, e, dest);\n-        }\n+        if !expr_is_lval(tcx, a) { ret trans_expr_dps(bcx, a, dest); }\n+        else { ret lval_to_dps(bcx, a, dest); }\n       }\n       ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n+      ast::expr_anon_obj(anon_obj) {\n+        ret trans_anon_obj(bcx, e.span, anon_obj, e.id, dest);\n+      }\n+      // FIXME[DPS] untangle non-lval calls and fields from trans_lval\n+      ast::expr_call(_, _) | ast::expr_field(_, _) {\n+        ret lval_to_dps(bcx, e, dest);\n+      }\n \n       // These return nothing\n       ast::expr_break. {\n@@ -4366,11 +4360,11 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n         let {bcx, val: addr, is_mem} = trans_lval(bcx, dst);\n         assert is_mem;\n         // FIXME: calculate copy init-ness in typestate.\n-        if expr_is_lval(bcx_tcx(bcx), src) {\n+        if expr_is_lval(tcx, src) {\n             ret trans_expr_save_in(bcx, src, addr, DROP_EXISTING);\n         } else {\n             let srclv = trans_lval(bcx, src);\n-            let t = ty::expr_ty(bcx_tcx(bcx), src);\n+            let t = ty::expr_ty(tcx, src);\n             ret move_val(srclv.bcx, DROP_EXISTING, addr, srclv, t);\n         }\n       }\n@@ -4379,7 +4373,7 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n         let lhs_res = trans_lval(bcx, dst);\n         assert (lhs_res.is_mem);\n         let rhs_res = trans_lval(lhs_res.bcx, src);\n-        let t = ty::expr_ty(bcx_tcx(bcx), src);\n+        let t = ty::expr_ty(tcx, src);\n         let {bcx: bcx, val: tmp_alloc} = alloc_ty(rhs_res.bcx, t);\n         // Swap through a temporary.\n         bcx = move_val(bcx, INIT, tmp_alloc, lhs_res, t);\n@@ -4390,15 +4384,10 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n         assert dest == ignore;\n         ret trans_assign_op(bcx, op, dst, src);\n       }\n-\n-      ast::expr_mac(_) { ret bcx_ccx(bcx).sess.bug(\"unexpanded macro\"); }\n-      // Convert back from result to DPS\n-      _ { ret trans_expr_backwards_compat(bcx, e, dest); }\n     }\n }\n \n-fn trans_expr_backwards_compat(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n-    -> @block_ctxt {\n+fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let lv = trans_lval(bcx, e);\n     let {bcx, val, is_mem} = lv;\n     let ty = ty::expr_ty(bcx_tcx(bcx), e);"}, {"sha": "0e4b529282937762fada100008f3360af593046e", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d243ea57f515d0829b900a12fec4dc110c5374dd/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d243ea57f515d0829b900a12fec4dc110c5374dd/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=d243ea57f515d0829b900a12fec4dc110c5374dd", "patch": "@@ -213,7 +213,13 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n // instead \"inlining\" the construction of the object and returning the object\n // itself.\n fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n-                  id: ast::node_id) -> result {\n+                  id: ast::node_id, dest: trans::dest) -> @block_ctxt {\n+    if dest == trans::ignore {\n+        alt anon_obj.inner_obj {\n+          some(e) { ret trans::trans_expr_dps(bcx, e, trans::ignore); }\n+          none. { ret bcx; }\n+        }\n+    }\n \n     let ccx = bcx_ccx(bcx);\n \n@@ -283,43 +289,26 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n       }\n     }\n \n-    // Allocate the object that we're going to return.\n-    let pair = alloca(bcx, ccx.rust_object_type);\n-\n-    // Take care of cleanups.\n-    let t = node_id_type(ccx, id);\n-    add_clean_temp(bcx, pair, t);\n-\n-    // Grab onto the first and second elements of the pair.\n-    let pair_vtbl = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    let pair_box = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n-\n     vtbl = PointerCast(bcx, vtbl, T_ptr(T_empty_struct()));\n-    Store(bcx, vtbl, pair_vtbl);\n \n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n     // typarams, fields, and a pointer to our inner_obj.\n     let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n \n-    if vec::len(additional_fields) == 0u &&\n-           anon_obj.inner_obj == none {\n-\n-        // If the object we're translating has no fields and no inner_obj,\n-        // there's not much to do.\n-        Store(bcx, C_null(llbox_ty), pair_box);\n-\n-    } else {\n-\n+    let box = C_null(llbox_ty);\n+    if vec::len(additional_fields) > 0u || anon_obj.inner_obj != none {\n         // Synthesize a type for the object body and hand it off to\n         // trans_malloc_boxed, which allocates a box, including space for a\n         // refcount.\n         let body_ty: ty::t =\n             create_object_body_type(ccx.tcx, additional_field_tys, [],\n                                     some(inner_obj_ty));\n-        let box = trans_malloc_boxed(bcx, body_ty);\n-        bcx = box.bcx;\n-        let body = box.body;\n+        let box_r = trans_malloc_boxed(bcx, body_ty);\n+        box = box_r.box;\n+        bcx = box_r.bcx;\n+        add_clean_free(bcx, box, false);\n+        let body = box_r.body;\n \n         // Put together a tydesc for the body, so that the object can later be\n         // freed by calling through its tydesc.\n@@ -386,14 +375,15 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n                          inner_obj_ty);\n           }\n         }\n-\n-        // Store box ptr in outer pair.\n-        let p = PointerCast(bcx, box.box, llbox_ty);\n-        Store(bcx, p, pair_box);\n+        revoke_clean(bcx, box);\n+        box = PointerCast(bcx, box, llbox_ty);\n     }\n-\n-    // return the object we built.\n-    ret rslt(bcx, pair);\n+    let {bcx, val: pair} = trans::get_dest_addr(bcx, dest);\n+    let pair_vtbl = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    Store(bcx, vtbl, pair_vtbl);\n+    let pair_box = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n+    Store(bcx, box, pair_box);\n+    ret bcx;\n }\n \n // Used only inside create_vtbl and create_backwarding_vtbl to distinguish"}, {"sha": "ec9821d6d26a084a72c2bbce5cf3d7f893b480e4", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d243ea57f515d0829b900a12fec4dc110c5374dd/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d243ea57f515d0829b900a12fec4dc110c5374dd/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=d243ea57f515d0829b900a12fec4dc110c5374dd", "patch": "@@ -1299,14 +1299,14 @@ fn vars_in_type(cx: ctxt, ty: t) -> [int] {\n }\n \n fn type_autoderef(cx: ctxt, t: ty::t) -> ty::t {\n-    let t1: ty::t = t;\n+    let t1 = t;\n     while true {\n         alt struct(cx, t1) {\n-          ty::ty_box(mt) { t1 = mt.ty; }\n-          ty::ty_res(_, inner, tps) {\n+          ty_box(mt) | ty_uniq(mt) { t1 = mt.ty; }\n+          ty_res(_, inner, tps) {\n             t1 = substitute_type_params(cx, tps, inner);\n           }\n-          ty::ty_tag(did, tps) {\n+          ty_tag(did, tps) {\n             let variants = tag_variants(cx, did);\n             if vec::len(variants) != 1u || vec::len(variants[0].args) != 1u {\n                 break;"}]}