{"sha": "7b4642f44178403770cc35166fb676b7fa051bec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiNDY0MmY0NDE3ODQwMzc3MGNjMzUxNjZmYjY3NmI3ZmEwNTFiZWM=", "commit": {"author": {"name": "Gabriel Smith", "email": "gsmith@d3engineering.com", "date": "2019-11-18T19:24:13Z"}, "committer": {"name": "Gabriel Smith", "email": "gsmith@d3engineering.com", "date": "2019-11-18T22:01:48Z"}, "message": "resolve: late: Check if type arg is really a const arg\n\nA path type argument could be a generic const argument due to\nlimitations as to what we can determine at parsing. We double check just\nto be sure by trying to resolve in the type namespace first, and if that\nfails we try again in the value namespace. If resolution in the value\nnamespace succeeds, we have a generic const argument on our hands.", "tree": {"sha": "416b2f5c0681faeaec854b99da49f3fd1eb88ea7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/416b2f5c0681faeaec854b99da49f3fd1eb88ea7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b4642f44178403770cc35166fb676b7fa051bec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b4642f44178403770cc35166fb676b7fa051bec", "html_url": "https://github.com/rust-lang/rust/commit/7b4642f44178403770cc35166fb676b7fa051bec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b4642f44178403770cc35166fb676b7fa051bec/comments", "author": null, "committer": null, "parents": [{"sha": "128ca7415f970b13150e90b4705188d7f076d389", "url": "https://api.github.com/repos/rust-lang/rust/commits/128ca7415f970b13150e90b4705188d7f076d389", "html_url": "https://github.com/rust-lang/rust/commit/128ca7415f970b13150e90b4705188d7f076d389"}], "stats": {"total": 46, "additions": 46, "deletions": 0}, "files": [{"sha": "f48df7faea25aa74f952437c729233772ca1ad34", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7b4642f44178403770cc35166fb676b7fa051bec/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4642f44178403770cc35166fb676b7fa051bec/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=7b4642f44178403770cc35166fb676b7fa051bec", "patch": "@@ -546,6 +546,52 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             self.visit_where_predicate(p);\n         }\n     }\n+\n+    fn visit_generic_arg(&mut self, arg: &'tcx GenericArg) {\n+        debug!(\"visit_generic_arg({:?})\", arg);\n+        match arg {\n+            GenericArg::Type(ref ty) => {\n+                // We parse const arguments as path types as we cannot distiguish them durring\n+                // parsing. We try to resolve that ambiguity by attempting resolution the type\n+                // namespace first, and if that fails we try again in the value namespace. If\n+                // resolution in the value namespace succeeds, we have an generic const argument on\n+                // our hands.\n+                if let TyKind::Path(ref qself, ref path) = ty.kind {\n+                    // We cannot disambiguate multi-segment paths right now as that requires type\n+                    // checking.\n+                    if path.segments.len() == 1 && path.segments[0].args.is_none() {\n+                        let mut check_ns = |ns| self.resolve_ident_in_lexical_scope(\n+                            path.segments[0].ident, ns, None, path.span\n+                        ).is_some();\n+\n+                        if !check_ns(TypeNS) && check_ns(ValueNS) {\n+                            // This must be equivalent to `visit_anon_const`, but we cannot call it\n+                            // directly due to visitor lifetimes so we have to copy-paste some code.\n+                            self.with_constant_rib(|this| {\n+                                this.smart_resolve_path(\n+                                    ty.id,\n+                                    qself.as_ref(),\n+                                    path,\n+                                    PathSource::Expr(None)\n+                                );\n+\n+                                if let Some(ref qself) = *qself {\n+                                    this.visit_ty(&qself.ty);\n+                                }\n+                                this.visit_path(path, ty.id);\n+                            });\n+\n+                            return;\n+                        }\n+                    }\n+                }\n+\n+                self.visit_ty(ty);\n+            }\n+            GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n+            GenericArg::Const(ct) => self.visit_anon_const(ct),\n+        }\n+    }\n }\n \n impl<'a, 'b> LateResolutionVisitor<'a, '_> {"}]}