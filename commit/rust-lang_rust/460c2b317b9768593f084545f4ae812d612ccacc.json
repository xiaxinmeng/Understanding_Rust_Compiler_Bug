{"sha": "460c2b317b9768593f084545f4ae812d612ccacc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2MGMyYjMxN2I5NzY4NTkzZjA4NDU0NWY0YWU4MTJkNjEyY2NhY2M=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-11-10T08:46:21Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-11-10T08:57:11Z"}, "message": "Fix `use_self` false positive\n\nThis fixes the first error reported in issue #3410.", "tree": {"sha": "354d7b7e80f4f2169bf07f12dc9240ab53c26105", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/354d7b7e80f4f2169bf07f12dc9240ab53c26105"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/460c2b317b9768593f084545f4ae812d612ccacc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/460c2b317b9768593f084545f4ae812d612ccacc", "html_url": "https://github.com/rust-lang/rust/commit/460c2b317b9768593f084545f4ae812d612ccacc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/460c2b317b9768593f084545f4ae812d612ccacc/comments", "author": null, "committer": null, "parents": [{"sha": "3bb88775de5a6f8f5c5743dd11af6c820122ccc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bb88775de5a6f8f5c5743dd11af6c820122ccc7", "html_url": "https://github.com/rust-lang/rust/commit/3bb88775de5a6f8f5c5743dd11af6c820122ccc7"}], "stats": {"total": 53, "additions": 38, "deletions": 15}, "files": [{"sha": "db393616ff20d6bf34e60367dd310a000d4f036f", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/460c2b317b9768593f084545f4ae812d612ccacc/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/460c2b317b9768593f084545f4ae812d612ccacc/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=460c2b317b9768593f084545f4ae812d612ccacc", "patch": "@@ -73,7 +73,7 @@ fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path) {\n }\n \n struct TraitImplTyVisitor<'a, 'tcx: 'a> {\n-    item_path: &'a Path,\n+    item_type: ty::Ty<'tcx>,\n     cx: &'a LateContext<'a, 'tcx>,\n     trait_type_walker: ty::walk::TypeWalker<'tcx>,\n     impl_type_walker: ty::walk::TypeWalker<'tcx>,\n@@ -85,21 +85,28 @@ impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n         let impl_ty = self.impl_type_walker.next();\n \n         if let TyKind::Path(QPath::Resolved(_, path)) = &t.node {\n-            if self.item_path.def == path.def {\n-                let is_self_ty = if let def::Def::SelfTy(..) = path.def {\n-                    true\n-                } else {\n-                    false\n-                };\n \n-                if !is_self_ty && impl_ty != trait_ty {\n-                    // The implementation and trait types don't match which means that\n-                    // the concrete type was specified by the implementation but\n-                    // it didn't use `Self`\n-                    span_use_self_lint(self.cx, path);\n+            // The implementation and trait types don't match which means that\n+            // the concrete type was specified by the implementation\n+            if impl_ty != trait_ty {\n+\n+                if let Some(impl_ty) = impl_ty {\n+                    if self.item_type == impl_ty {\n+                        let is_self_ty = if let def::Def::SelfTy(..) = path.def {\n+                            true\n+                        } else {\n+                            false\n+                        };\n+\n+                        if !is_self_ty {\n+                            span_use_self_lint(self.cx, path);\n+                        }\n+                    }\n                 }\n+\n             }\n         }\n+\n         walk_ty(self, t)\n     }\n \n@@ -110,7 +117,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n \n fn check_trait_method_impl_decl<'a, 'tcx: 'a>(\n     cx: &'a LateContext<'a, 'tcx>,\n-    item_path: &'a Path,\n+    item_type: ty::Ty<'tcx>,\n     impl_item: &ImplItem,\n     impl_decl: &'tcx FnDecl,\n     impl_trait_ref: &ty::TraitRef<'_>,\n@@ -151,7 +158,7 @@ fn check_trait_method_impl_decl<'a, 'tcx: 'a>(\n     ) {\n         let mut visitor = TraitImplTyVisitor {\n             cx,\n-            item_path,\n+            item_type,\n             trait_type_walker: trait_ty.walk(),\n             impl_type_walker: impl_ty.walk(),\n         };\n@@ -192,7 +199,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n                             let impl_item = cx.tcx.hir.impl_item(impl_item_ref.id);\n                             if let ImplItemKind::Method(MethodSig{ decl: impl_decl, .. }, impl_body_id)\n                                     = &impl_item.node {\n-                                check_trait_method_impl_decl(cx, item_path, impl_item, impl_decl, &impl_trait_ref);\n+                                let item_type = cx.tcx.type_of(impl_def_id);\n+                                check_trait_method_impl_decl(cx, item_type, impl_item, impl_decl, &impl_trait_ref);\n+\n                                 let body = cx.tcx.hir.body(*impl_body_id);\n                                 visitor.visit_body(body);\n                             } else {"}, {"sha": "4c1ec2ad2b943c1f1b0d222fb6e66be47b7cb534", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/460c2b317b9768593f084545f4ae812d612ccacc/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/460c2b317b9768593f084545f4ae812d612ccacc/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=460c2b317b9768593f084545f4ae812d612ccacc", "patch": "@@ -219,3 +219,17 @@ mod existential {\n         }\n     }\n }\n+\n+mod issue3410 {\n+\n+    struct A;\n+    struct B;\n+\n+    trait Trait<T>: Sized {\n+        fn a(v: T);\n+    }\n+\n+    impl Trait<Vec<A>> for Vec<B> {\n+        fn a(_: Vec<A>) {}\n+    }\n+}"}]}