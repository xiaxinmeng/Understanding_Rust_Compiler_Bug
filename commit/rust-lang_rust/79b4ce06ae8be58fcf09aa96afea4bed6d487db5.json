{"sha": "79b4ce06ae8be58fcf09aa96afea4bed6d487db5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5YjRjZTA2YWU4YmU1OGZjZjA5YWE5NmFmZWE0YmVkNmQ0ODdkYjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-22T14:12:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-22T14:46:40Z"}, "message": "collections: Stabilize String\n\n# Rationale\n\nWhen dealing with strings, many functions deal with either a `char` (unicode\ncodepoint) or a byte (utf-8 encoding related). There is often an inconsistent\nway in which methods are referred to as to whether they contain \"byte\", \"char\",\nor nothing in their name.  There are also issues open to rename *all* methods to\nreflect that they operate on utf8 encodings or bytes (e.g. utf8_len() or\nbyte_len()).\n\nThe current state of String seems to largely be what is desired, so this PR\nproposes the following rationale for methods dealing with bytes or characters:\n\n> When constructing a string, the input encoding *must* be mentioned (e.g.\n> from_utf8). This makes it clear what exactly the input type is expected to be\n> in terms of encoding.\n>\n> When a method operates on anything related to an *index* within the string\n> such as length, capacity, position, etc, the method *implicitly* operates on\n> bytes. It is an understood fact that String is a utf-8 encoded string, and\n> burdening all methods with \"bytes\" would be redundant.\n>\n> When a method operates on the *contents* of a string, such as push() or pop(),\n> then \"char\" is the default type. A String can loosely be thought of as being a\n> collection of unicode codepoints, but not all collection-related operations\n> make sense because some can be woefully inefficient.\n\n# Method stabilization\n\nThe following methods have been marked #[stable]\n\n* The String type itself\n* String::new\n* String::with_capacity\n* String::from_utf16_lossy\n* String::into_bytes\n* String::as_bytes\n* String::len\n* String::clear\n* String::as_slice\n\nThe following methods have been marked #[unstable]\n\n* String::from_utf8 - The error type in the returned `Result` may change to\n                      provide a nicer message when it's `unwrap()`'d\n* String::from_utf8_lossy - The returned `MaybeOwned` type still needs\n                            stabilization\n* String::from_utf16 - The return type may change to become a `Result` which\n                       includes more contextual information like where the error\n                       occurred.\n* String::from_chars - This is equivalent to iter().collect(), but currently not\n                       as ergonomic.\n* String::from_char - This method is the equivalent of Vec::from_elem, and has\n                      been marked #[unstable] becuase it can be seen as a\n                      duplicate of iterator-based functionality as well as\n                      possibly being renamed.\n* String::push_str - This *can* be emulated with .extend(foo.chars()), but is\n                     less efficient because of decoding/encoding. Due to the\n                     desire to minimize API surface this may be able to be\n                     removed in the future for something possibly generic with\n                     no loss in performance.\n* String::grow - This is a duplicate of iterator-based functionality, which may\n                 become more ergonomic in the future.\n* String::capacity - This function was just added.\n* String::push - This function was just added.\n* String::pop - This function was just added.\n* String::truncate - The failure conventions around String methods and byte\n                     indices isn't totally clear at this time, so the failure\n                     semantics and return value of this method are subject to\n                     change.\n* String::as_mut_vec - the naming of this method may change.\n* string::raw::* - these functions are all waiting on [an RFC][2]\n\n[2]: https://github.com/rust-lang/rfcs/pull/240\n\nThe following method have been marked #[experimental]\n\n* String::from_str - This function only exists as it's more efficient than\n                     to_string(), but having a less ergonomic function for\n                     performance reasons isn't the greatest reason to keep it\n                     around. Like Vec::push_all, this has been marked\n                     experimental for now.\n\nThe following methods have been #[deprecated]\n\n* String::append - This method has been deprecated to remain consistent with the\n                   deprecation of Vec::append. While convenient, it is one of\n                   the only functional-style apis on String, and requires more\n                   though as to whether it belongs as a first-class method or\n                   now (and how it relates to other collections).\n* String::from_byte - This is fairly rare functionality and can be emulated with\n                      str::from_utf8 plus an assert plus a call to to_string().\n                      Additionally, String::from_char could possibly be used.\n* String::byte_capacity - Renamed to String::capacity due to the rationale\n                          above.\n* String::push_char - Renamed to String::push due to the rationale above.\n* String::pop_char - Renamed to String::pop due to the rationale above.\n* String::push_bytes - There are a number of `unsafe` functions on the `String`\n                       type which allow bypassing utf-8 checks. These have all\n                       been deprecated in favor of calling `.as_mut_vec()` and\n                       then operating directly on the vector returned. These\n                       methods were deprecated because naming them with relation\n                       to other methods was difficult to rationalize and it's\n                       arguably more composable to call .as_mut_vec().\n* String::as_mut_bytes - See push_bytes\n* String::push_byte - See push_bytes\n* String::pop_byte - See push_bytes\n* String::shift_byte - See push_bytes\n\n# Reservation methods\n\nThis commit does not yet touch the methods for reserving bytes. The methods on\nVec have also not yet been modified. These methods are discussed in the upcoming\n[Collections reform RFC][1]\n\n[1]: https://github.com/aturon/rfcs/blob/collections-conventions/active/0000-collections-conventions.md#implicit-growth", "tree": {"sha": "1e81a4b009e85779d9108979ae3229a51754c912", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e81a4b009e85779d9108979ae3229a51754c912"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79b4ce06ae8be58fcf09aa96afea4bed6d487db5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79b4ce06ae8be58fcf09aa96afea4bed6d487db5", "html_url": "https://github.com/rust-lang/rust/commit/79b4ce06ae8be58fcf09aa96afea4bed6d487db5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79b4ce06ae8be58fcf09aa96afea4bed6d487db5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3907a13f697feb007ab4824ee26f998d56a1311f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3907a13f697feb007ab4824ee26f998d56a1311f", "html_url": "https://github.com/rust-lang/rust/commit/3907a13f697feb007ab4824ee26f998d56a1311f"}], "stats": {"total": 86, "additions": 77, "deletions": 9}, "files": [{"sha": "7f29645407c578d7b5ab7ac0763e4d557dd8a42b", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 77, "deletions": 9, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/79b4ce06ae8be58fcf09aa96afea4bed6d487db5/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79b4ce06ae8be58fcf09aa96afea4bed6d487db5/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=79b4ce06ae8be58fcf09aa96afea4bed6d487db5", "patch": "@@ -31,6 +31,7 @@ use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n+#[stable]\n pub struct String {\n     vec: Vec<u8>,\n }\n@@ -44,6 +45,7 @@ impl String {\n     /// let mut s = String::new();\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn new() -> String {\n         String {\n             vec: Vec::new(),\n@@ -60,6 +62,7 @@ impl String {\n     /// let mut s = String::with_capacity(10);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn with_capacity(capacity: uint) -> String {\n         String {\n             vec: Vec::with_capacity(capacity),\n@@ -75,6 +78,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n+    #[experimental = \"needs investigation to see if to_string() can match perf\"]\n     pub fn from_str(string: &str) -> String {\n         String { vec: string.as_bytes().to_vec() }\n     }\n@@ -111,6 +115,7 @@ impl String {\n     /// assert_eq!(s, Err(vec![240, 144, 128]));\n     /// ```\n     #[inline]\n+    #[unstable = \"error type may change\"]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, Vec<u8>> {\n         if str::is_utf8(vec.as_slice()) {\n             Ok(String { vec: vec })\n@@ -129,6 +134,7 @@ impl String {\n     /// let output = String::from_utf8_lossy(input);\n     /// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n     /// ```\n+    #[unstable = \"return type may change\"]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n         if str::is_utf8(v) {\n             return MaybeOwnedSlice(unsafe { mem::transmute(v) })\n@@ -260,6 +266,7 @@ impl String {\n     /// v[4] = 0xD800;\n     /// assert_eq!(String::from_utf16(v), None);\n     /// ```\n+    #[unstable = \"error value in return may change\"]\n     pub fn from_utf16(v: &[u16]) -> Option<String> {\n         let mut s = String::with_capacity(v.len() / 2);\n         for c in str::utf16_items(v) {\n@@ -284,6 +291,7 @@ impl String {\n     /// assert_eq!(String::from_utf16_lossy(v),\n     ///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_string());\n     /// ```\n+    #[stable]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n         str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n@@ -298,6 +306,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n+    #[unstable = \"may be removed in favor of .collect()\"]\n     pub fn from_chars(chs: &[char]) -> String {\n         chs.iter().map(|c| *c).collect()\n     }\n@@ -312,6 +321,7 @@ impl String {\n     /// assert_eq!(bytes, vec![104, 101, 108, 108, 111]);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.vec\n     }\n@@ -329,6 +339,7 @@ impl String {\n     /// assert_eq!(big.as_slice(), \"hello world!\");\n     /// ```\n     #[inline]\n+    #[deprecated = \"use .push_str() instead\"]\n     pub fn append(mut self, second: &str) -> String {\n         self.push_str(second);\n         self\n@@ -343,6 +354,8 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"aaaaa\");\n     /// ```\n     #[inline]\n+    #[unstable = \"may be replaced with iterators, questionable usability, and \\\n+                  the name may change\"]\n     pub fn from_char(length: uint, ch: char) -> String {\n         if length == 0 {\n             return String::new()\n@@ -370,6 +383,7 @@ impl String {\n     /// let s = String::from_byte(104);\n     /// assert_eq!(s.as_slice(), \"h\");\n     /// ```\n+    #[deprecated = \"use str::from_utf8 with a slice of one byte instead\"]\n     pub fn from_byte(b: u8) -> String {\n         assert!(b < 128u8);\n         String::from_char(1, b as char)\n@@ -385,6 +399,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"foobar\");\n     /// ```\n     #[inline]\n+    #[unstable = \"extra variants of `push`, could possibly be based on iterators\"]\n     pub fn push_str(&mut self, string: &str) {\n         self.vec.push_all(string.as_bytes())\n     }\n@@ -399,6 +414,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"fooZZZZZ\");\n     /// ```\n     #[inline]\n+    #[unstable = \"duplicate of iterator-based functionality\"]\n     pub fn grow(&mut self, count: uint, ch: char) {\n         for _ in range(0, count) {\n             self.push_char(ch)\n@@ -414,10 +430,25 @@ impl String {\n     /// assert!(s.byte_capacity() >= 10);\n     /// ```\n     #[inline]\n+    #[deprecated = \"renamed to .capacity()\"]\n     pub fn byte_capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n \n+    /// Returns the number of bytes that this string buffer can hold without reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = String::with_capacity(10);\n+    /// assert!(s.byte_capacity() >= 10);\n+    /// ```\n+    #[inline]\n+    #[unstable = \"just implemented, needs to prove itself\"]\n+    pub fn capacity(&self) -> uint {\n+        self.vec.capacity()\n+    }\n+\n     /// Reserves capacity for at least `extra` additional bytes in this string buffer.\n     ///\n     /// # Example\n@@ -477,19 +508,27 @@ impl String {\n         self.vec.shrink_to_fit()\n     }\n \n+    /// Deprecated, use .push() instead.\n+    #[inline]\n+    #[deprecated = \"renamed to .push()\"]\n+    pub fn push_char(&mut self, ch: char) {\n+        self.push(ch)\n+    }\n+\n     /// Adds the given character to the end of the string.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"abc\");\n-    /// s.push_char('1');\n-    /// s.push_char('2');\n-    /// s.push_char('3');\n+    /// s.push('1');\n+    /// s.push('2');\n+    /// s.push('3');\n     /// assert_eq!(s.as_slice(), \"abc123\");\n     /// ```\n     #[inline]\n-    pub fn push_char(&mut self, ch: char) {\n+    #[stable = \"function just renamed from push_char\"]\n+    pub fn push(&mut self, ch: char) {\n         let cur_len = self.len();\n         // This may use up to 4 bytes.\n         self.vec.reserve_additional(4);\n@@ -520,6 +559,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n+    #[deprecated = \"call .as_mut_vec() and push onto that\"]\n     pub unsafe fn push_bytes(&mut self, bytes: &[u8]) {\n         self.vec.push_all(bytes)\n     }\n@@ -534,6 +574,7 @@ impl String {\n     /// assert_eq!(s.as_bytes(), b);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.vec.as_slice()\n     }\n@@ -557,6 +598,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"h3ll0\")\n     /// ```\n     #[inline]\n+    #[deprecated = \"call .as_mut_vec().as_slice() instead\"]\n     pub unsafe fn as_mut_bytes<'a>(&'a mut self) -> &'a mut [u8] {\n         self.vec.as_mut_slice()\n     }\n@@ -575,6 +617,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"he\");\n     /// ```\n     #[inline]\n+    #[unstable = \"the failure conventions for strings are under development\"]\n     pub fn truncate(&mut self, len: uint) {\n         assert!(self.as_slice().is_char_boundary(len));\n         self.vec.truncate(len)\n@@ -595,6 +638,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n+    #[deprecated = \"call .as_mut_vec().push() instead\"]\n     pub unsafe fn push_byte(&mut self, byte: u8) {\n         self.vec.push(byte)\n     }\n@@ -617,6 +661,7 @@ impl String {\n     /// }\n     /// ```\n     #[inline]\n+    #[deprecated = \"call .as_mut_vec().pop() instead\"]\n     pub unsafe fn pop_byte(&mut self) -> Option<u8> {\n         let len = self.len();\n         if len == 0 {\n@@ -628,20 +673,26 @@ impl String {\n         Some(byte)\n     }\n \n+    /// Deprecated. Renamed to `pop`.\n+    #[inline]\n+    #[deprecated = \"renamed to .pop()\"]\n+    pub fn pop_char(&mut self) -> Option<char> { self.pop() }\n+\n     /// Removes the last character from the string buffer and returns it.\n     /// Returns `None` if this string buffer is empty.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n-    /// assert_eq!(s.pop_char(), Some('o'));\n-    /// assert_eq!(s.pop_char(), Some('o'));\n-    /// assert_eq!(s.pop_char(), Some('f'));\n-    /// assert_eq!(s.pop_char(), None);\n+    /// assert_eq!(s.pop(), Some('o'));\n+    /// assert_eq!(s.pop(), Some('o'));\n+    /// assert_eq!(s.pop(), Some('f'));\n+    /// assert_eq!(s.pop(), None);\n     /// ```\n     #[inline]\n-    pub fn pop_char(&mut self) -> Option<char> {\n+    #[unstable = \"this function was just renamed from pop_char\"]\n+    pub fn pop(&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n             return None\n@@ -671,6 +722,7 @@ impl String {\n     ///     assert_eq!(s.shift_byte(), None);\n     /// }\n     /// ```\n+    #[deprecated = \"call .as_mut_rev().remove(0)\"]\n     pub unsafe fn shift_byte(&mut self) -> Option<u8> {\n         self.vec.remove(0)\n     }\n@@ -722,25 +774,31 @@ impl String {\n     /// }\n     /// assert_eq!(s.as_slice(), \"olleh\");\n     /// ```\n+    #[unstable = \"the name of this method may be changed\"]\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n     }\n }\n \n+#[experimental = \"collection traits will probably be removed\"]\n impl Collection for String {\n     #[inline]\n+    #[stable]\n     fn len(&self) -> uint {\n         self.vec.len()\n     }\n }\n \n+#[experimental = \"collection traits will probably be removed\"]\n impl Mutable for String {\n     #[inline]\n+    #[stable]\n     fn clear(&mut self) {\n         self.vec.clear()\n     }\n }\n \n+#[experimental = \"waiting on FromIterator stabilization\"]\n impl FromIterator<char> for String {\n     fn from_iter<I:Iterator<char>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -749,6 +807,7 @@ impl FromIterator<char> for String {\n     }\n }\n \n+#[experimental = \"waiting on Extendable stabilization\"]\n impl Extendable<char> for String {\n     fn extend<I:Iterator<char>>(&mut self, mut iterator: I) {\n         for ch in iterator {\n@@ -757,48 +816,56 @@ impl Extendable<char> for String {\n     }\n }\n \n+#[experimental = \"waiting on Str stabilization\"]\n impl Str for String {\n     #[inline]\n+    #[stable]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         unsafe {\n             mem::transmute(self.vec.as_slice())\n         }\n     }\n }\n \n+#[experimental = \"waiting on StrAllocating stabilization\"]\n impl StrAllocating for String {\n     #[inline]\n     fn into_string(self) -> String {\n         self\n     }\n }\n \n+#[stable]\n impl Default for String {\n     fn default() -> String {\n         String::new()\n     }\n }\n \n+#[experimental = \"waiting on Show stabilization\"]\n impl fmt::Show for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_slice().fmt(f)\n     }\n }\n \n+#[experimental = \"waiting on Hash stabilization\"]\n impl<H: hash::Writer> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         self.as_slice().hash(hasher)\n     }\n }\n \n+#[experimental = \"waiting on Equiv stabilization\"]\n impl<'a, S: Str> Equiv<S> for String {\n     #[inline]\n     fn equiv(&self, other: &S) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n+#[experimental = \"waiting on Add stabilization\"]\n impl<S: Str> Add<S, String> for String {\n     fn add(&self, other: &S) -> String {\n         let mut s = String::from_str(self.as_slice());\n@@ -808,6 +875,7 @@ impl<S: Str> Add<S, String> for String {\n }\n \n /// Unsafe operations\n+#[unstable = \"waiting on raw module conventions\"]\n pub mod raw {\n     use core::mem;\n     use core::ptr::RawPtr;"}]}