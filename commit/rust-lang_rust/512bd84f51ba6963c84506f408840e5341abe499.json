{"sha": "512bd84f51ba6963c84506f408840e5341abe499", "node_id": "C_kwDOAAsO6NoAKDUxMmJkODRmNTFiYTY5NjNjODQ1MDZmNDA4ODQwZTUzNDFhYmU0OTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-07T23:40:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-07T23:40:06Z"}, "message": "Auto merge of #94075 - mikebenfield:wip-enum, r=oli-obk\n\nUse niche-filling optimization even when multiple variants have data.\n\nFixes #46213", "tree": {"sha": "f1c82de1bcea080bf93b98d6a40c2ddd5f503d63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1c82de1bcea080bf93b98d6a40c2ddd5f503d63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/512bd84f51ba6963c84506f408840e5341abe499", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/512bd84f51ba6963c84506f408840e5341abe499", "html_url": "https://github.com/rust-lang/rust/commit/512bd84f51ba6963c84506f408840e5341abe499", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/512bd84f51ba6963c84506f408840e5341abe499/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2804e6ec2c29a5c7368600ea173b890e2655c3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2804e6ec2c29a5c7368600ea173b890e2655c3d", "html_url": "https://github.com/rust-lang/rust/commit/c2804e6ec2c29a5c7368600ea173b890e2655c3d"}, {"sha": "d7a750b50436fbd228b176f6438566625e235990", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a750b50436fbd228b176f6438566625e235990", "html_url": "https://github.com/rust-lang/rust/commit/d7a750b50436fbd228b176f6438566625e235990"}], "stats": {"total": 573, "additions": 377, "deletions": 196}, "files": [{"sha": "e38572f609b3178828dd61af42f8c184a57783bc", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -3075,7 +3075,8 @@ mod size_asserts {\n     static_assert_size!(Block, 48);\n     static_assert_size!(Expr, 104);\n     static_assert_size!(ExprKind, 72);\n-    static_assert_size!(Fn, 192);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(Fn, 184);\n     static_assert_size!(ForeignItem, 96);\n     static_assert_size!(ForeignItemKind, 24);\n     static_assert_size!(GenericArg, 24);"}, {"sha": "97b395bcd05186b199e59026ddec9fda4472dc77", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -42,10 +42,10 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n         Variants::Multiple {\n             tag: _,\n             tag_field,\n-            tag_encoding: TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+            tag_encoding: TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n             variants: _,\n         } => {\n-            if variant_index != dataful_variant {\n+            if variant_index != untagged_variant {\n                 let niche = place.place_field(fx, mir::Field::new(tag_field));\n                 let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                 let niche_value = ty::ScalarInt::try_from_uint(\n@@ -113,7 +113,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             let res = CValue::by_val(val, dest_layout);\n             dest.write_cvalue(fx, res);\n         }\n-        TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+        TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n             // Rebase from niche values to discriminants, and check\n             // whether the result is in range for the niche variants.\n \n@@ -169,8 +169,9 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 fx.bcx.ins().iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n             };\n \n-            let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n-            let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n+            let untagged_variant =\n+                fx.bcx.ins().iconst(cast_to, i64::from(untagged_variant.as_u32()));\n+            let discr = fx.bcx.ins().select(is_niche, niche_discr, untagged_variant);\n             let res = CValue::by_val(discr, dest_layout);\n             dest.write_cvalue(fx, res);\n         }"}, {"sha": "129e336c7e431c58dd68b2280188bce1ee199cfa", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -99,7 +99,7 @@ const SINGLE_VARIANT_VIRTUAL_DISR: u64 = 0;\n /// compiler versions.\n ///\n /// Niche-tag enums have one special variant, usually called the\n-/// \"dataful variant\". This variant has a field that\n+/// \"untagged variant\". This variant has a field that\n /// doubles as the tag of the enum. The variant is active when the value of\n /// that field is within a pre-defined range. Therefore the variant struct\n /// has a `DISCR_BEGIN` and `DISCR_END` field instead of `DISCR_EXACT` in\n@@ -249,7 +249,7 @@ pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n                     None,\n                 ),\n                 Variants::Multiple {\n-                    tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+                    tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n                     ref variants,\n                     tag_field,\n                     ..\n@@ -260,7 +260,7 @@ pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n                     enum_type_di_node,\n                     variants.indices(),\n                     tag_field,\n-                    Some(dataful_variant),\n+                    Some(untagged_variant),\n                 ),\n             }\n         },\n@@ -391,7 +391,7 @@ fn build_union_fields_for_enum<'ll, 'tcx>(\n     enum_type_di_node: &'ll DIType,\n     variant_indices: impl Iterator<Item = VariantIdx> + Clone,\n     tag_field: usize,\n-    dataful_variant_index: Option<VariantIdx>,\n+    untagged_variant_index: Option<VariantIdx>,\n ) -> SmallVec<&'ll DIType> {\n     let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n \n@@ -436,7 +436,7 @@ fn build_union_fields_for_enum<'ll, 'tcx>(\n         variant_names_type_di_node,\n         tag_base_type,\n         tag_field,\n-        dataful_variant_index,\n+        untagged_variant_index,\n     )\n }\n \n@@ -472,7 +472,7 @@ fn build_variant_struct_wrapper_type_di_node<'ll, 'tcx>(\n     enum_or_generator_type_and_layout: TyAndLayout<'tcx>,\n     enum_or_generator_type_di_node: &'ll DIType,\n     variant_index: VariantIdx,\n-    dataful_variant_index: Option<VariantIdx>,\n+    untagged_variant_index: Option<VariantIdx>,\n     variant_struct_type_di_node: &'ll DIType,\n     variant_names_type_di_node: &'ll DIType,\n     tag_base_type_di_node: &'ll DIType,\n@@ -517,7 +517,7 @@ fn build_variant_struct_wrapper_type_di_node<'ll, 'tcx>(\n                     }\n                 }\n                 DiscrResult::Range(min, max) => {\n-                    assert_eq!(Some(variant_index), dataful_variant_index);\n+                    assert_eq!(Some(variant_index), untagged_variant_index);\n                     if is_128_bits {\n                         DiscrKind::Range128(min, max)\n                     } else {\n@@ -757,7 +757,7 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n     discr_type_di_node: &'ll DIType,\n     tag_base_type: Ty<'tcx>,\n     tag_field: usize,\n-    dataful_variant_index: Option<VariantIdx>,\n+    untagged_variant_index: Option<VariantIdx>,\n ) -> SmallVec<&'ll DIType> {\n     let tag_base_type_di_node = type_di_node(cx, tag_base_type);\n     let mut unions_fields = SmallVec::with_capacity(variant_field_infos.len() + 1);\n@@ -776,7 +776,7 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n             enum_type_and_layout,\n             enum_type_di_node,\n             variant_member_info.variant_index,\n-            dataful_variant_index,\n+            untagged_variant_index,\n             variant_member_info.variant_struct_type_di_node,\n             discr_type_di_node,\n             tag_base_type_di_node,"}, {"sha": "14044d0f99b987609ff17331b3ee50d4f2b83605", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -417,7 +417,7 @@ impl DiscrResult {\n /// Returns the discriminant value corresponding to the variant index.\n ///\n /// Will return `None` if there is less than two variants (because then the enum won't have)\n-/// a tag, and if this is the dataful variant of a niche-layout enum (because then there is no\n+/// a tag, and if this is the untagged variant of a niche-layout enum (because then there is no\n /// single discriminant value).\n fn compute_discriminant_value<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n@@ -430,11 +430,11 @@ fn compute_discriminant_value<'ll, 'tcx>(\n             enum_type_and_layout.ty.discriminant_for_variant(cx.tcx, variant_index).unwrap().val,\n         ),\n         &Variants::Multiple {\n-            tag_encoding: TagEncoding::Niche { ref niche_variants, niche_start, dataful_variant },\n+            tag_encoding: TagEncoding::Niche { ref niche_variants, niche_start, untagged_variant },\n             tag,\n             ..\n         } => {\n-            if variant_index == dataful_variant {\n+            if variant_index == untagged_variant {\n                 let valid_range = enum_type_and_layout\n                     .for_variant(cx, variant_index)\n                     .largest_niche"}, {"sha": "becbccc434d9ac33ee30091225aa0b87278986b7", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -378,7 +378,7 @@ fn build_discr_member_di_node<'ll, 'tcx>(\n ///\n /// The DW_AT_discr_value is optional, and is omitted if\n ///   - This is the only variant of a univariant enum (i.e. their is no discriminant)\n-///   - This is the \"dataful\" variant of a niche-layout enum\n+///   - This is the \"untagged\" variant of a niche-layout enum\n ///     (where only the other variants are identified by a single value)\n ///\n /// There is only ever a single member, the type of which is a struct that describes the"}, {"sha": "13d8f6eddd1de12579a15761d52d7f56acf5c50c", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -244,7 +244,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 };\n                 bx.intcast(tag.immediate(), cast_to, signed)\n             }\n-            TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+            TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n                 // Rebase from niche values to discriminants, and check\n                 // whether the result is in range for the niche variants.\n                 let niche_llty = bx.cx().immediate_backend_type(tag.layout);\n@@ -302,7 +302,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 bx.select(\n                     is_niche,\n                     niche_discr,\n-                    bx.cx().const_uint(cast_to, dataful_variant.as_u32() as u64),\n+                    bx.cx().const_uint(cast_to, untagged_variant.as_u32() as u64),\n                 )\n             }\n         }\n@@ -337,11 +337,11 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             }\n             Variants::Multiple {\n                 tag_encoding:\n-                    TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+                    TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n                 tag_field,\n                 ..\n             } => {\n-                if variant_index != dataful_variant {\n+                if variant_index != untagged_variant {\n                     let niche = self.project_field(bx, tag_field);\n                     let niche_llty = bx.cx().immediate_backend_type(niche.layout);\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();"}, {"sha": "ba041810bd19e8d71a593f1d82d719c5b5476921", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -718,7 +718,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Return the cast value, and the index.\n                 (discr_val, index.0)\n             }\n-            TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+            TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n                 let tag_val = tag_val.to_scalar();\n                 // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n                 // discriminant (encoded in niche/tag) and variant index are the same.\n@@ -736,7 +736,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if !ptr_valid {\n                             throw_ub!(InvalidTag(dbg_val))\n                         }\n-                        dataful_variant\n+                        untagged_variant\n                     }\n                     Ok(tag_bits) => {\n                         let tag_bits = tag_bits.assert_bits(tag_layout.size);\n@@ -766,7 +766,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             assert!(usize::try_from(variant_index).unwrap() < variants_len);\n                             VariantIdx::from_u32(variant_index)\n                         } else {\n-                            dataful_variant\n+                            untagged_variant\n                         }\n                     }\n                 };\n@@ -780,13 +780,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(bootstrap)))]\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(Immediate, 56);\n-    static_assert_size!(ImmTy<'_>, 72);\n-    static_assert_size!(Operand, 64);\n-    static_assert_size!(OpTy<'_>, 88);\n+    static_assert_size!(Immediate, 48);\n+    static_assert_size!(ImmTy<'_>, 64);\n+    static_assert_size!(Operand, 56);\n+    static_assert_size!(OpTy<'_>, 80);\n }"}, {"sha": "b328892906df22217f8b2afcb39c160766f2bc74", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -817,15 +817,15 @@ where\n             }\n             abi::Variants::Multiple {\n                 tag_encoding:\n-                    TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+                    TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n                 tag: tag_layout,\n                 tag_field,\n                 ..\n             } => {\n                 // No need to validate that the discriminant here because the\n                 // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n \n-                if variant_index != dataful_variant {\n+                if variant_index != untagged_variant {\n                     let variants_start = niche_variants.start().as_u32();\n                     let variant_index_relative = variant_index\n                         .as_u32()\n@@ -890,6 +890,8 @@ mod size_asserts {\n     static_assert_size!(MemPlaceMeta, 24);\n     static_assert_size!(MemPlace, 40);\n     static_assert_size!(MPlaceTy<'_>, 64);\n-    static_assert_size!(Place, 48);\n-    static_assert_size!(PlaceTy<'_>, 72);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(Place, 40);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(PlaceTy<'_>, 64);\n }"}, {"sha": "e351b650a16c1a8c7c6829e01dbc326a0ed8d13e", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -117,6 +117,10 @@ pub trait ObligationProcessor {\n }\n \n /// The result type used by `process_obligation`.\n+// `repr(C)` to inhibit the niche filling optimization. Otherwise, the `match` appearing\n+// in `process_obligations` is significantly slower, which can substantially affect\n+// benchmarks like `rustc-perf`'s inflate and keccak.\n+#[repr(C)]\n #[derive(Debug)]\n pub enum ProcessResult<O, E> {\n     Unchanged,"}, {"sha": "513225e1606452e73cb63c6fe1296e4673007994", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -69,8 +69,8 @@ pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a, ErrorGuaranteed>>;\n // (See also the comment on `DiagnosticBuilder`'s `diagnostic` field.)\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(PResult<'_, ()>, 16);\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(PResult<'_, bool>, 24);\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(bootstrap)))]\n+rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, Encodable, Decodable)]\n pub enum SuggestionStyle {"}, {"sha": "a668c0e95ce4b1f328a625a3d6762749909093ba", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -3473,12 +3473,15 @@ mod size_asserts {\n     static_assert_size!(FnDecl<'_>, 40);\n     static_assert_size!(ForeignItem<'_>, 72);\n     static_assert_size!(ForeignItemKind<'_>, 40);\n-    static_assert_size!(GenericArg<'_>, 40);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(GenericArg<'_>, 32);\n     static_assert_size!(GenericBound<'_>, 48);\n     static_assert_size!(Generics<'_>, 56);\n     static_assert_size!(Impl<'_>, 80);\n-    static_assert_size!(ImplItem<'_>, 88);\n-    static_assert_size!(ImplItemKind<'_>, 40);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(ImplItem<'_>, 80);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(ImplItemKind<'_>, 32);\n     static_assert_size!(Item<'_>, 80);\n     static_assert_size!(ItemKind<'_>, 48);\n     static_assert_size!(Local<'_>, 64);\n@@ -3490,8 +3493,10 @@ mod size_asserts {\n     static_assert_size!(QPath<'_>, 24);\n     static_assert_size!(Stmt<'_>, 32);\n     static_assert_size!(StmtKind<'_>, 16);\n-    static_assert_size!(TraitItem<'_>, 96);\n-    static_assert_size!(TraitItemKind<'_>, 56);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(TraitItem<'static>, 88);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(TraitItemKind<'_>, 48);\n     static_assert_size!(Ty<'_>, 72);\n     static_assert_size!(TyKind<'_>, 56);\n }"}, {"sha": "e149535bec7b56e13e66304a05f9c901d2163a19", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -1231,7 +1231,8 @@ pub enum BinOp {\n mod size_asserts {\n     use super::*;\n     // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(AggregateKind<'_>, 48);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(AggregateKind<'_>, 40);\n     static_assert_size!(Operand<'_>, 24);\n     static_assert_size!(Place<'_>, 16);\n     static_assert_size!(PlaceElem<'_>, 24);"}, {"sha": "c50f8b0eebe1a03686430d45872cdb63999b20b6", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -825,8 +825,12 @@ mod size_asserts {\n     static_assert_size!(Block, 56);\n     static_assert_size!(Expr<'_>, 64);\n     static_assert_size!(ExprKind<'_>, 40);\n-    static_assert_size!(Pat<'_>, 72);\n-    static_assert_size!(PatKind<'_>, 56);\n-    static_assert_size!(Stmt<'_>, 56);\n-    static_assert_size!(StmtKind<'_>, 48);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(Pat<'_>, 64);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(PatKind<'_>, 48);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(Stmt<'_>, 48);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(StmtKind<'_>, 40);\n }"}, {"sha": "abb7ddd88b14db57bdfa0828ba3732cbba1147e7", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 200, "deletions": 118, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -22,7 +22,7 @@ use rustc_target::abi::call::{\n use rustc_target::abi::*;\n use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy, Target};\n \n-use std::cmp;\n+use std::cmp::{self, Ordering};\n use std::fmt;\n use std::iter;\n use std::num::NonZeroUsize;\n@@ -1046,131 +1046,191 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 // that allow representation optimization.)\n                 assert!(def.is_enum());\n \n-                // The current code for niche-filling relies on variant indices\n-                // instead of actual discriminants, so dataful enums with\n-                // explicit discriminants (RFC #2363) would misbehave.\n-                let no_explicit_discriminants = def\n-                    .variants()\n-                    .iter_enumerated()\n-                    .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i.as_u32()));\n-\n-                let mut niche_filling_layout = None;\n-\n-                // Niche-filling enum optimization.\n-                if !def.repr().inhibit_enum_layout_opt() && no_explicit_discriminants {\n-                    let mut dataful_variant = None;\n-                    let mut niche_variants = VariantIdx::MAX..=VariantIdx::new(0);\n+                // Until we've decided whether to use the tagged or\n+                // niche filling LayoutS, we don't want to intern the\n+                // variant layouts, so we can't store them in the\n+                // overall LayoutS. Store the overall LayoutS\n+                // and the variant LayoutSs here until then.\n+                struct TmpLayout<'tcx> {\n+                    layout: LayoutS<'tcx>,\n+                    variants: IndexVec<VariantIdx, LayoutS<'tcx>>,\n+                }\n \n-                    // Find one non-ZST variant.\n-                    'variants: for (v, fields) in variants.iter_enumerated() {\n-                        if absent(fields) {\n-                            continue 'variants;\n+                let calculate_niche_filling_layout =\n+                    || -> Result<Option<TmpLayout<'tcx>>, LayoutError<'tcx>> {\n+                        // The current code for niche-filling relies on variant indices\n+                        // instead of actual discriminants, so enums with\n+                        // explicit discriminants (RFC #2363) would misbehave.\n+                        if def.repr().inhibit_enum_layout_opt()\n+                            || def\n+                                .variants()\n+                                .iter_enumerated()\n+                                .any(|(i, v)| v.discr != ty::VariantDiscr::Relative(i.as_u32()))\n+                        {\n+                            return Ok(None);\n                         }\n-                        for f in fields {\n-                            if !f.is_zst() {\n-                                if dataful_variant.is_none() {\n-                                    dataful_variant = Some(v);\n-                                    continue 'variants;\n-                                } else {\n-                                    dataful_variant = None;\n-                                    break 'variants;\n-                                }\n-                            }\n+\n+                        if variants.len() < 2 {\n+                            return Ok(None);\n                         }\n-                        niche_variants = *niche_variants.start().min(&v)..=v;\n-                    }\n \n-                    if niche_variants.start() > niche_variants.end() {\n-                        dataful_variant = None;\n-                    }\n+                        let mut align = dl.aggregate_align;\n+                        let mut variant_layouts = variants\n+                            .iter_enumerated()\n+                            .map(|(j, v)| {\n+                                let mut st = self.univariant_uninterned(\n+                                    ty,\n+                                    v,\n+                                    &def.repr(),\n+                                    StructKind::AlwaysSized,\n+                                )?;\n+                                st.variants = Variants::Single { index: j };\n+\n+                                align = align.max(st.align);\n+\n+                                Ok(st)\n+                            })\n+                            .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+\n+                        let largest_variant_index = match variant_layouts\n+                            .iter_enumerated()\n+                            .max_by_key(|(_i, layout)| layout.size.bytes())\n+                            .map(|(i, _layout)| i)\n+                        {\n+                            None => return Ok(None),\n+                            Some(i) => i,\n+                        };\n \n-                    if let Some(i) = dataful_variant {\n-                        let count = (niche_variants.end().as_u32()\n-                            - niche_variants.start().as_u32()\n-                            + 1) as u128;\n+                        let all_indices = VariantIdx::new(0)..=VariantIdx::new(variants.len() - 1);\n+                        let needs_disc = |index: VariantIdx| {\n+                            index != largest_variant_index && !absent(&variants[index])\n+                        };\n+                        let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap()\n+                            ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap();\n+\n+                        let count = niche_variants.size_hint().1.unwrap() as u128;\n \n                         // Find the field with the largest niche\n-                        let niche_candidate = variants[i]\n+                        let (field_index, niche, (niche_start, niche_scalar)) = match variants\n+                            [largest_variant_index]\n                             .iter()\n                             .enumerate()\n                             .filter_map(|(j, field)| Some((j, field.largest_niche?)))\n-                            .max_by_key(|(_, niche)| niche.available(dl));\n-\n-                        if let Some((field_index, niche, (niche_start, niche_scalar))) =\n-                            niche_candidate.and_then(|(field_index, niche)| {\n-                                Some((field_index, niche, niche.reserve(self, count)?))\n-                            })\n+                            .max_by_key(|(_, niche)| niche.available(dl))\n+                            .and_then(|(j, niche)| Some((j, niche, niche.reserve(self, count)?)))\n                         {\n-                            let mut align = dl.aggregate_align;\n-                            let st = variants\n-                                .iter_enumerated()\n-                                .map(|(j, v)| {\n-                                    let mut st = self.univariant_uninterned(\n-                                        ty,\n-                                        v,\n-                                        &def.repr(),\n-                                        StructKind::AlwaysSized,\n-                                    )?;\n-                                    st.variants = Variants::Single { index: j };\n+                            None => return Ok(None),\n+                            Some(x) => x,\n+                        };\n \n-                                    align = align.max(st.align);\n+                        let niche_offset = niche.offset\n+                            + variant_layouts[largest_variant_index].fields.offset(field_index);\n+                        let niche_size = niche.value.size(dl);\n+                        let size = variant_layouts[largest_variant_index].size.align_to(align.abi);\n \n-                                    Ok(tcx.intern_layout(st))\n-                                })\n-                                .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+                        let all_variants_fit =\n+                            variant_layouts.iter_enumerated_mut().all(|(i, layout)| {\n+                                if i == largest_variant_index {\n+                                    return true;\n+                                }\n \n-                            let offset = st[i].fields().offset(field_index) + niche.offset;\n+                                layout.largest_niche = None;\n \n-                            // Align the total size to the largest alignment.\n-                            let size = st[i].size().align_to(align.abi);\n+                                if layout.size <= niche_offset {\n+                                    // This variant will fit before the niche.\n+                                    return true;\n+                                }\n \n-                            let abi = if st.iter().all(|v| v.abi().is_uninhabited()) {\n-                                Abi::Uninhabited\n-                            } else if align == st[i].align() && size == st[i].size() {\n-                                // When the total alignment and size match, we can use the\n-                                // same ABI as the scalar variant with the reserved niche.\n-                                match st[i].abi() {\n-                                    Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n-                                    Abi::ScalarPair(first, second) => {\n-                                        // Only the niche is guaranteed to be initialised,\n-                                        // so use union layout for the other primitive.\n-                                        if offset.bytes() == 0 {\n-                                            Abi::ScalarPair(niche_scalar, second.to_union())\n-                                        } else {\n-                                            Abi::ScalarPair(first.to_union(), niche_scalar)\n+                                // Determine if it'll fit after the niche.\n+                                let this_align = layout.align.abi;\n+                                let this_offset = (niche_offset + niche_size).align_to(this_align);\n+\n+                                if this_offset + layout.size > size {\n+                                    return false;\n+                                }\n+\n+                                // It'll fit, but we need to make some adjustments.\n+                                match layout.fields {\n+                                    FieldsShape::Arbitrary { ref mut offsets, .. } => {\n+                                        for (j, offset) in offsets.iter_mut().enumerate() {\n+                                            if !variants[i][j].is_zst() {\n+                                                *offset += this_offset;\n+                                            }\n                                         }\n                                     }\n-                                    _ => Abi::Aggregate { sized: true },\n+                                    _ => {\n+                                        panic!(\"Layout of fields should be Arbitrary for variants\")\n+                                    }\n                                 }\n-                            } else {\n-                                Abi::Aggregate { sized: true }\n-                            };\n \n-                            let largest_niche = Niche::from_scalar(dl, offset, niche_scalar);\n-\n-                            niche_filling_layout = Some(LayoutS {\n-                                variants: Variants::Multiple {\n-                                    tag: niche_scalar,\n-                                    tag_encoding: TagEncoding::Niche {\n-                                        dataful_variant: i,\n-                                        niche_variants,\n-                                        niche_start,\n-                                    },\n-                                    tag_field: 0,\n-                                    variants: st,\n-                                },\n-                                fields: FieldsShape::Arbitrary {\n-                                    offsets: vec![offset],\n-                                    memory_index: vec![0],\n-                                },\n-                                abi,\n-                                largest_niche,\n-                                size,\n-                                align,\n+                                // It can't be a Scalar or ScalarPair because the offset isn't 0.\n+                                if !layout.abi.is_uninhabited() {\n+                                    layout.abi = Abi::Aggregate { sized: true };\n+                                }\n+                                layout.size += this_offset;\n+\n+                                true\n                             });\n+\n+                        if !all_variants_fit {\n+                            return Ok(None);\n                         }\n-                    }\n-                }\n+\n+                        let largest_niche = Niche::from_scalar(dl, niche_offset, niche_scalar);\n+\n+                        let others_zst = variant_layouts.iter_enumerated().all(|(i, layout)| {\n+                            i == largest_variant_index || layout.size == Size::ZERO\n+                        });\n+                        let same_size = size == variant_layouts[largest_variant_index].size;\n+                        let same_align = align == variant_layouts[largest_variant_index].align;\n+\n+                        let abi = if variant_layouts.iter().all(|v| v.abi.is_uninhabited()) {\n+                            Abi::Uninhabited\n+                        } else if same_size && same_align && others_zst {\n+                            match variant_layouts[largest_variant_index].abi {\n+                                // When the total alignment and size match, we can use the\n+                                // same ABI as the scalar variant with the reserved niche.\n+                                Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n+                                Abi::ScalarPair(first, second) => {\n+                                    // Only the niche is guaranteed to be initialised,\n+                                    // so use union layouts for the other primitive.\n+                                    if niche_offset == Size::ZERO {\n+                                        Abi::ScalarPair(niche_scalar, second.to_union())\n+                                    } else {\n+                                        Abi::ScalarPair(first.to_union(), niche_scalar)\n+                                    }\n+                                }\n+                                _ => Abi::Aggregate { sized: true },\n+                            }\n+                        } else {\n+                            Abi::Aggregate { sized: true }\n+                        };\n+\n+                        let layout = LayoutS {\n+                            variants: Variants::Multiple {\n+                                tag: niche_scalar,\n+                                tag_encoding: TagEncoding::Niche {\n+                                    untagged_variant: largest_variant_index,\n+                                    niche_variants,\n+                                    niche_start,\n+                                },\n+                                tag_field: 0,\n+                                variants: IndexVec::new(),\n+                            },\n+                            fields: FieldsShape::Arbitrary {\n+                                offsets: vec![niche_offset],\n+                                memory_index: vec![0],\n+                            },\n+                            abi,\n+                            largest_niche,\n+                            size,\n+                            align,\n+                        };\n+\n+                        Ok(Some(TmpLayout { layout, variants: variant_layouts }))\n+                    };\n+\n+                let niche_filling_layout = calculate_niche_filling_layout()?;\n \n                 let (mut min, mut max) = (i128::MAX, i128::MIN);\n                 let discr_type = def.repr().discr_type();\n@@ -1425,15 +1485,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag);\n \n-                let layout_variants =\n-                    layout_variants.into_iter().map(|v| tcx.intern_layout(v)).collect();\n-\n                 let tagged_layout = LayoutS {\n                     variants: Variants::Multiple {\n                         tag,\n                         tag_encoding: TagEncoding::Direct,\n                         tag_field: 0,\n-                        variants: layout_variants,\n+                        variants: IndexVec::new(),\n                     },\n                     fields: FieldsShape::Arbitrary {\n                         offsets: vec![Size::ZERO],\n@@ -1445,20 +1502,45 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     size,\n                 };\n \n-                let best_layout = match (tagged_layout, niche_filling_layout) {\n-                    (tagged_layout, Some(niche_filling_layout)) => {\n+                let tagged_layout = TmpLayout { layout: tagged_layout, variants: layout_variants };\n+\n+                let mut best_layout = match (tagged_layout, niche_filling_layout) {\n+                    (tl, Some(nl)) => {\n                         // Pick the smaller layout; otherwise,\n                         // pick the layout with the larger niche; otherwise,\n                         // pick tagged as it has simpler codegen.\n-                        cmp::min_by_key(tagged_layout, niche_filling_layout, |layout| {\n-                            let niche_size = layout.largest_niche.map_or(0, |n| n.available(dl));\n-                            (layout.size, cmp::Reverse(niche_size))\n-                        })\n+                        use Ordering::*;\n+                        let niche_size = |tmp_l: &TmpLayout<'_>| {\n+                            tmp_l.layout.largest_niche.map_or(0, |n| n.available(dl))\n+                        };\n+                        match (\n+                            tl.layout.size.cmp(&nl.layout.size),\n+                            niche_size(&tl).cmp(&niche_size(&nl)),\n+                        ) {\n+                            (Greater, _) => nl,\n+                            (Equal, Less) => nl,\n+                            _ => tl,\n+                        }\n                     }\n-                    (tagged_layout, None) => tagged_layout,\n+                    (tl, None) => tl,\n+                };\n+\n+                // Now we can intern the variant layouts and store them in the enum layout.\n+                best_layout.layout.variants = match best_layout.layout.variants {\n+                    Variants::Multiple { tag, tag_encoding, tag_field, .. } => Variants::Multiple {\n+                        tag,\n+                        tag_encoding,\n+                        tag_field,\n+                        variants: best_layout\n+                            .variants\n+                            .into_iter()\n+                            .map(|layout| tcx.intern_layout(layout))\n+                            .collect(),\n+                    },\n+                    _ => bug!(),\n                 };\n \n-                tcx.intern_layout(best_layout)\n+                tcx.intern_layout(best_layout.layout)\n             }\n \n             // Types with no meaningful known layout.\n@@ -2559,11 +2641,11 @@ where\n                     // using more niches than just null (e.g., the first page of\n                     // the address space, or unaligned pointers).\n                     Variants::Multiple {\n-                        tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+                        tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n                         tag_field,\n                         ..\n                     } if this.fields.offset(tag_field) == offset => {\n-                        Some(this.for_variant(cx, dataful_variant))\n+                        Some(this.for_variant(cx, untagged_variant))\n                     }\n                     _ => Some(this),\n                 };"}, {"sha": "bcaf209f84b65dcf6e14ac18c0adbc16595e0e5f", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -1130,7 +1130,7 @@ pub enum TagEncoding {\n \n     /// Niche (values invalid for a type) encoding the discriminant:\n     /// Discriminant and variant index coincide.\n-    /// The variant `dataful_variant` contains a niche at an arbitrary\n+    /// The variant `untagged_variant` contains a niche at an arbitrary\n     /// offset (field `tag_field` of the enum), which for a variant with\n     /// discriminant `d` is set to\n     /// `(d - niche_variants.start).wrapping_add(niche_start)`.\n@@ -1139,7 +1139,7 @@ pub enum TagEncoding {\n     /// `None` has a null pointer for the second tuple field, and\n     /// `Some` is the identity function (with a non-null reference).\n     Niche {\n-        dataful_variant: VariantIdx,\n+        untagged_variant: VariantIdx,\n         niche_variants: RangeInclusive<VariantIdx>,\n         niche_start: u128,\n     },"}, {"sha": "2077cf71b2ef72924b414513a1a28d22e2aebc66", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -2532,7 +2532,8 @@ mod size_asserts {\n     // These are in alphabetical order, which is easy to maintain.\n     static_assert_size!(Crate, 72); // frequently moved by-value\n     static_assert_size!(DocFragment, 32);\n-    static_assert_size!(GenericArg, 64);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(GenericArg, 56);\n     static_assert_size!(GenericArgs, 32);\n     static_assert_size!(GenericParamDef, 56);\n     static_assert_size!(Item, 56);"}, {"sha": "7f1be6f27847c0d7f9632984f56dc384b9792852", "filename": "src/test/debuginfo/msvc-pretty-enums.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -53,8 +53,8 @@\n // cdb-command: dx niche128_none\n // cdb-check: niche128_none    : None [Type: enum2$<core::option::Option<core::num::nonzero::NonZeroI128> >]\n \n-// cdb-command: dx wrapping_niche128_dataful\n-// cdb-check: wrapping_niche128_dataful : X [Type: enum2$<msvc_pretty_enums::Wrapping128Niche>]\n+// cdb-command: dx wrapping_niche128_untagged\n+// cdb-check: wrapping_niche128_untagged : X [Type: enum2$<msvc_pretty_enums::Wrapping128Niche>]\n // cdb-check:    [+0x[...]] __0              [Type: msvc_pretty_enums::Wrapping128]\n \n // cdb-command: dx wrapping_niche128_none1\n@@ -213,7 +213,7 @@ fn main() {\n     let niche128_some = Some(NonZeroI128::new(123456).unwrap());\n     let niche128_none: Option<NonZeroI128> = None;\n \n-    let wrapping_niche128_dataful =\n+    let wrapping_niche128_untagged =\n         unsafe { Wrapping128Niche::X(Wrapping128(340282366920938463463374607431768211454)) };\n     let wrapping_niche128_none1 = Wrapping128Niche::Y;\n     let wrapping_niche128_none2 = Wrapping128Niche::Z;"}, {"sha": "bfabe2d12f7ffcc8a73d1c3c27aec08efc91be15", "filename": "src/test/ui/layout/issue-96158-scalarpair-payload-might-be-uninit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -411,7 +411,7 @@ error: layout_of(NicheFirst) = Layout {\n                    valid_range: 0..=4,\n                },\n                tag_encoding: Niche {\n-                   dataful_variant: 0,\n+                   untagged_variant: 0,\n                    niche_variants: 1..=2,\n                    niche_start: 3,\n                },\n@@ -555,7 +555,7 @@ error: layout_of(NicheSecond) = Layout {\n                    valid_range: 0..=4,\n                },\n                tag_encoding: Niche {\n-                   dataful_variant: 0,\n+                   untagged_variant: 0,\n                    niche_variants: 1..=2,\n                    niche_start: 3,\n                },"}, {"sha": "a3e82070e0f529cd8287ba75c8e7454a41063856", "filename": "src/test/ui/layout/zero-sized-array-enum-niche.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.stderr?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -353,7 +353,7 @@ error: layout_of(std::result::Result<[u32; 0], Packed<U16IsZero>>) = Layout {\n                    valid_range: 0..=1,\n                },\n                tag_encoding: Niche {\n-                   dataful_variant: 1,\n+                   untagged_variant: 1,\n                    niche_variants: 0..=0,\n                    niche_start: 1,\n                },"}, {"sha": "5102574d4be3ece384bfef2a5e2ec50172e9d5ff", "filename": "src/test/ui/stats/hir-stats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -1,6 +1,7 @@\n // check-pass\n // compile-flags: -Zhir-stats\n // only-x86_64\n+// ignore-stage1\n \n // The aim here is to include at least one of every different type of top-level\n // AST/HIR node reported by `-Zhir-stats`."}, {"sha": "c8ceb6ff22df24a731d4ee4f7d5e7df3361197c1", "filename": "src/test/ui/stats/hir-stats.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -21,39 +21,39 @@ ast-stats-1 - MacCall                   32 ( 0.4%)             1\n ast-stats-1 - Expr                      96 ( 1.1%)             3\n ast-stats-1 Param                    160 ( 1.9%)             4            40\n ast-stats-1 FnDecl                   200 ( 2.4%)             5            40\n-ast-stats-1 Variant                  240 ( 2.8%)             2           120\n+ast-stats-1 Variant                  240 ( 2.9%)             2           120\n ast-stats-1 Block                    288 ( 3.4%)             6            48\n ast-stats-1 GenericBound             352 ( 4.2%)             4            88\n ast-stats-1 - Trait                    352 ( 4.2%)             4\n ast-stats-1 AssocItem                416 ( 4.9%)             4           104\n ast-stats-1 - TyAlias                  208 ( 2.5%)             2\n ast-stats-1 - Fn                       208 ( 2.5%)             2\n-ast-stats-1 GenericParam             520 ( 6.1%)             5           104\n-ast-stats-1 PathSegment              720 ( 8.5%)            30            24\n-ast-stats-1 Expr                     832 ( 9.8%)             8           104\n+ast-stats-1 GenericParam             480 ( 5.7%)             5            96\n+ast-stats-1 PathSegment              720 ( 8.6%)            30            24\n+ast-stats-1 Expr                     832 ( 9.9%)             8           104\n ast-stats-1 - Path                     104 ( 1.2%)             1\n ast-stats-1 - Match                    104 ( 1.2%)             1\n ast-stats-1 - Struct                   104 ( 1.2%)             1\n ast-stats-1 - Lit                      208 ( 2.5%)             2\n ast-stats-1 - Block                    312 ( 3.7%)             3\n-ast-stats-1 Pat                      840 ( 9.9%)             7           120\n+ast-stats-1 Pat                      840 (10.0%)             7           120\n ast-stats-1 - Struct                   120 ( 1.4%)             1\n ast-stats-1 - Wild                     120 ( 1.4%)             1\n ast-stats-1 - Ident                    600 ( 7.1%)             5\n-ast-stats-1 Ty                     1_344 (15.9%)            14            96\n+ast-stats-1 Ty                     1_344 (16.0%)            14            96\n ast-stats-1 - Rptr                      96 ( 1.1%)             1\n ast-stats-1 - Ptr                       96 ( 1.1%)             1\n ast-stats-1 - ImplicitSelf             192 ( 2.3%)             2\n ast-stats-1 - Path                     960 (11.4%)            10\n-ast-stats-1 Item                   1_656 (19.6%)             9           184\n+ast-stats-1 Item                   1_656 (19.7%)             9           184\n ast-stats-1 - Trait                    184 ( 2.2%)             1\n ast-stats-1 - Enum                     184 ( 2.2%)             1\n ast-stats-1 - ForeignMod               184 ( 2.2%)             1\n ast-stats-1 - Impl                     184 ( 2.2%)             1\n ast-stats-1 - Fn                       368 ( 4.4%)             2\n-ast-stats-1 - Use                      552 ( 6.5%)             3\n+ast-stats-1 - Use                      552 ( 6.6%)             3\n ast-stats-1 ----------------------------------------------------------------\n-ast-stats-1 Total                  8_456\n+ast-stats-1 Total                  8_416\n ast-stats-1\n ast-stats-2 POST EXPANSION AST STATS\n ast-stats-2 Name                Accumulated Size         Count     Item Size\n@@ -86,25 +86,25 @@ ast-stats-2 - Trait                    352 ( 3.8%)             4\n ast-stats-2 AssocItem                416 ( 4.5%)             4           104\n ast-stats-2 - TyAlias                  208 ( 2.3%)             2\n ast-stats-2 - Fn                       208 ( 2.3%)             2\n-ast-stats-2 GenericParam             520 ( 5.7%)             5           104\n-ast-stats-2 PathSegment              792 ( 8.6%)            33            24\n-ast-stats-2 Pat                      840 ( 9.1%)             7           120\n+ast-stats-2 GenericParam             480 ( 5.2%)             5            96\n+ast-stats-2 PathSegment              792 ( 8.7%)            33            24\n+ast-stats-2 Pat                      840 ( 9.2%)             7           120\n ast-stats-2 - Struct                   120 ( 1.3%)             1\n ast-stats-2 - Wild                     120 ( 1.3%)             1\n-ast-stats-2 - Ident                    600 ( 6.5%)             5\n+ast-stats-2 - Ident                    600 ( 6.6%)             5\n ast-stats-2 Expr                     936 (10.2%)             9           104\n ast-stats-2 - Path                     104 ( 1.1%)             1\n ast-stats-2 - Match                    104 ( 1.1%)             1\n ast-stats-2 - Struct                   104 ( 1.1%)             1\n ast-stats-2 - InlineAsm                104 ( 1.1%)             1\n ast-stats-2 - Lit                      208 ( 2.3%)             2\n ast-stats-2 - Block                    312 ( 3.4%)             3\n-ast-stats-2 Ty                     1_344 (14.6%)            14            96\n+ast-stats-2 Ty                     1_344 (14.7%)            14            96\n ast-stats-2 - Rptr                      96 ( 1.0%)             1\n ast-stats-2 - Ptr                       96 ( 1.0%)             1\n ast-stats-2 - ImplicitSelf             192 ( 2.1%)             2\n ast-stats-2 - Path                     960 (10.5%)            10\n-ast-stats-2 Item                   2_024 (22.0%)            11           184\n+ast-stats-2 Item                   2_024 (22.1%)            11           184\n ast-stats-2 - Trait                    184 ( 2.0%)             1\n ast-stats-2 - Enum                     184 ( 2.0%)             1\n ast-stats-2 - ExternCrate              184 ( 2.0%)             1\n@@ -113,15 +113,15 @@ ast-stats-2 - Impl                     184 ( 2.0%)             1\n ast-stats-2 - Fn                       368 ( 4.0%)             2\n ast-stats-2 - Use                      736 ( 8.0%)             4\n ast-stats-2 ----------------------------------------------------------------\n-ast-stats-2 Total                  9_184\n+ast-stats-2 Total                  9_144\n ast-stats-2\n hir-stats HIR STATS\n hir-stats Name                Accumulated Size         Count     Item Size\n hir-stats ----------------------------------------------------------------\n hir-stats ForeignItemRef            24 ( 0.2%)             1            24\n hir-stats Mod                       32 ( 0.3%)             1            32\n hir-stats ExprField                 40 ( 0.4%)             1            40\n-hir-stats TraitItemRef              56 ( 0.5%)             2            28\n+hir-stats TraitItemRef              56 ( 0.6%)             2            28\n hir-stats Param                     64 ( 0.6%)             2            32\n hir-stats Local                     64 ( 0.6%)             1            64\n hir-stats InlineAsm                 72 ( 0.7%)             1            72\n@@ -135,11 +135,11 @@ hir-stats - Semi                      32 ( 0.3%)             1\n hir-stats - Expr                      32 ( 0.3%)             1\n hir-stats FnDecl                   120 ( 1.2%)             3            40\n hir-stats Attribute                128 ( 1.3%)             4            32\n+hir-stats GenericArg               128 ( 1.3%)             4            32\n+hir-stats - Type                      32 ( 0.3%)             1\n+hir-stats - Lifetime                  96 ( 0.9%)             3\n hir-stats GenericArgs              144 ( 1.4%)             3            48\n hir-stats Variant                  160 ( 1.6%)             2            80\n-hir-stats GenericArg               160 ( 1.6%)             4            40\n-hir-stats - Type                      40 ( 0.4%)             1\n-hir-stats - Lifetime                 120 ( 1.2%)             3\n hir-stats GenericBound             192 ( 1.9%)             4            48\n hir-stats - Trait                    192 ( 1.9%)             4\n hir-stats WherePredicate           216 ( 2.1%)             3            72\n@@ -151,7 +151,7 @@ hir-stats - Wild                      88 ( 0.9%)             1\n hir-stats - Struct                    88 ( 0.9%)             1\n hir-stats - Binding                  264 ( 2.6%)             3\n hir-stats Generics                 560 ( 5.5%)            10            56\n-hir-stats Expr                     768 ( 7.5%)            12            64\n+hir-stats Expr                     768 ( 7.6%)            12            64\n hir-stats - Path                      64 ( 0.6%)             1\n hir-stats - Struct                    64 ( 0.6%)             1\n hir-stats - Match                     64 ( 0.6%)             1\n@@ -173,5 +173,5 @@ hir-stats - Path                     936 ( 9.2%)            13\n hir-stats Path                   1_536 (15.1%)            32            48\n hir-stats PathSegment            2_240 (22.0%)            40            56\n hir-stats ----------------------------------------------------------------\n-hir-stats Total                 10_200\n+hir-stats Total                 10_168\n hir-stats"}, {"sha": "7a23f13630a43fabcfdbea1251b182fce6a890f7", "filename": "src/test/ui/structs-enums/type-sizes.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512bd84f51ba6963c84506f408840e5341abe499/src%2Ftest%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Ftype-sizes.rs?ref=512bd84f51ba6963c84506f408840e5341abe499", "patch": "@@ -120,6 +120,54 @@ pub enum AlwaysTaggedBecauseItHasNoNiche {\n     B\n }\n \n+pub enum NicheFilledMultipleFields {\n+    A(bool, u8),\n+    B(u8),\n+    C(u8),\n+    D(bool),\n+    E,\n+    F,\n+    G,\n+}\n+\n+struct BoolInTheMiddle(std::num::NonZeroU16, bool, u8);\n+\n+enum NicheWithData {\n+    A,\n+    B([u16; 5]),\n+    Largest { a1: u32, a2: BoolInTheMiddle, a3: u32 },\n+    C,\n+    D(u32, u32),\n+}\n+\n+// A type with almost 2^16 invalid values.\n+#[repr(u16)]\n+pub enum NicheU16 {\n+    _0,\n+}\n+\n+pub enum EnumManyVariant<X> {\n+    Dataful(u8, X),\n+\n+    // 0x100 niche variants.\n+    _00, _01, _02, _03, _04, _05, _06, _07, _08, _09, _0A, _0B, _0C, _0D, _0E, _0F,\n+    _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _1A, _1B, _1C, _1D, _1E, _1F,\n+    _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _2A, _2B, _2C, _2D, _2E, _2F,\n+    _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _3A, _3B, _3C, _3D, _3E, _3F,\n+    _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _4A, _4B, _4C, _4D, _4E, _4F,\n+    _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _5A, _5B, _5C, _5D, _5E, _5F,\n+    _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _6A, _6B, _6C, _6D, _6E, _6F,\n+    _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _7A, _7B, _7C, _7D, _7E, _7F,\n+    _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _8A, _8B, _8C, _8D, _8E, _8F,\n+    _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _9A, _9B, _9C, _9D, _9E, _9F,\n+    _A0, _A1, _A2, _A3, _A4, _A5, _A6, _A7, _A8, _A9, _AA, _AB, _AC, _AD, _AE, _AF,\n+    _B0, _B1, _B2, _B3, _B4, _B5, _B6, _B7, _B8, _B9, _BA, _BB, _BC, _BD, _BE, _BF,\n+    _C0, _C1, _C2, _C3, _C4, _C5, _C6, _C7, _C8, _C9, _CA, _CB, _CC, _CD, _CE, _CF,\n+    _D0, _D1, _D2, _D3, _D4, _D5, _D6, _D7, _D8, _D9, _DA, _DB, _DC, _DD, _DE, _DF,\n+    _E0, _E1, _E2, _E3, _E4, _E5, _E6, _E7, _E8, _E9, _EA, _EB, _EC, _ED, _EE, _EF,\n+    _F0, _F1, _F2, _F3, _F4, _F5, _F6, _F7, _F8, _F9, _FA, _FB, _FC, _FD, _FE, _FF,\n+}\n+\n pub fn main() {\n     assert_eq!(size_of::<u8>(), 1 as usize);\n     assert_eq!(size_of::<u32>(), 4 as usize);\n@@ -170,4 +218,35 @@ pub fn main() {\n     assert_eq!(size_of::<AlwaysTaggedBecauseItHasNoNiche>(), 8);\n     assert_eq!(size_of::<Option<AlwaysTaggedBecauseItHasNoNiche>>(), 8);\n     assert_eq!(size_of::<Option<Option<AlwaysTaggedBecauseItHasNoNiche>>>(), 8);\n+\n+    assert_eq!(size_of::<NicheFilledMultipleFields>(), 2);\n+    assert_eq!(size_of::<Option<NicheFilledMultipleFields>>(), 2);\n+    assert_eq!(size_of::<Option<Option<NicheFilledMultipleFields>>>(), 2);\n+\n+    struct S1{ a: u16, b: std::num::NonZeroU16, c: u16, d: u8, e: u32, f: u64, g:[u8;2] }\n+    assert_eq!(size_of::<S1>(), 24);\n+    assert_eq!(size_of::<Option<S1>>(), 24);\n+\n+    assert_eq!(size_of::<NicheWithData>(), 12);\n+    assert_eq!(size_of::<Option<NicheWithData>>(), 12);\n+    assert_eq!(size_of::<Option<Option<NicheWithData>>>(), 12);\n+    assert_eq!(\n+        size_of::<Option<Option2<&(), Option<NicheWithData>>>>(),\n+        size_of::<(&(), NicheWithData)>()\n+    );\n+\n+    pub enum FillPadding { A(std::num::NonZeroU8, u32), B }\n+    assert_eq!(size_of::<FillPadding>(), 8);\n+    assert_eq!(size_of::<Option<FillPadding>>(), 8);\n+    assert_eq!(size_of::<Option<Option<FillPadding>>>(), 8);\n+\n+    assert_eq!(size_of::<Result<(std::num::NonZeroU8, u8, u8), u16>>(), 4);\n+    assert_eq!(size_of::<Option<Result<(std::num::NonZeroU8, u8, u8), u16>>>(), 4);\n+    assert_eq!(size_of::<Result<(std::num::NonZeroU8, u8, u8, u8), u16>>(), 4);\n+\n+    assert_eq!(size_of::<EnumManyVariant<u16>>(), 6);\n+    assert_eq!(size_of::<EnumManyVariant<NicheU16>>(), 4);\n+    assert_eq!(size_of::<EnumManyVariant<Option<NicheU16>>>(), 4);\n+    assert_eq!(size_of::<EnumManyVariant<Option2<NicheU16,u8>>>(), 6);\n+    assert_eq!(size_of::<EnumManyVariant<Option<(NicheU16,u8)>>>(), 6);\n }"}]}