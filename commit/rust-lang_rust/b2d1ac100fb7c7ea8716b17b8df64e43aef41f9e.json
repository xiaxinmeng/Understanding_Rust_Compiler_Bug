{"sha": "b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZDFhYzEwMGZiN2M3ZWE4NzE2YjE3YjhkZjY0ZTQzYWVmNDFmOWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-03T06:09:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-09T00:03:58Z"}, "message": "libcore: Remove mutable fields from rand.", "tree": {"sha": "b5166d2d1c5bb467a1dab930355bac29c93960a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5166d2d1c5bb467a1dab930355bac29c93960a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e", "html_url": "https://github.com/rust-lang/rust/commit/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee78d811e488e2f279cfda454f8f909477dc3d6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee78d811e488e2f279cfda454f8f909477dc3d6b", "html_url": "https://github.com/rust-lang/rust/commit/ee78d811e488e2f279cfda454f8f909477dc3d6b"}], "stats": {"total": 197, "additions": 107, "deletions": 90}, "files": [{"sha": "8e0a185248e6109975333d2f20cbb4b4501a8881", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e", "patch": "@@ -56,7 +56,7 @@ fn resize_at(capacity: uint) -> uint {\n \n pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n     initial_capacity: uint) -> HashMap<K, V> {\n-    let r = rand::task_rng();\n+    let mut r = rand::task_rng();\n     linear_map_with_capacity_and_keys(r.gen(), r.gen(),\n                                       initial_capacity)\n }"}, {"sha": "cb212efa363e274dc79b86eb2f3056bb413b950c", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 96, "deletions": 80, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e", "patch": "@@ -55,12 +55,12 @@ pub mod distributions;\n \n /// A type that can be randomly generated using an Rng\n pub trait Rand {\n-    fn rand<R: Rng>(rng: &R) -> Self;\n+    fn rand<R: Rng>(rng: &mut R) -> Self;\n }\n \n impl Rand for int {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> int {\n+    fn rand<R: Rng>(rng: &mut R) -> int {\n         if int::bits == 32 {\n             rng.next() as int\n         } else {\n@@ -71,35 +71,35 @@ impl Rand for int {\n \n impl Rand for i8 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> i8 {\n+    fn rand<R: Rng>(rng: &mut R) -> i8 {\n         rng.next() as i8\n     }\n }\n \n impl Rand for i16 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> i16 {\n+    fn rand<R: Rng>(rng: &mut R) -> i16 {\n         rng.next() as i16\n     }\n }\n \n impl Rand for i32 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> i32 {\n+    fn rand<R: Rng>(rng: &mut R) -> i32 {\n         rng.next() as i32\n     }\n }\n \n impl Rand for i64 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> i64 {\n+    fn rand<R: Rng>(rng: &mut R) -> i64 {\n         (rng.next() as i64 << 32) | rng.next() as i64\n     }\n }\n \n impl Rand for uint {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> uint {\n+    fn rand<R: Rng>(rng: &mut R) -> uint {\n         if uint::bits == 32 {\n             rng.next() as uint\n         } else {\n@@ -110,50 +110,50 @@ impl Rand for uint {\n \n impl Rand for u8 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> u8 {\n+    fn rand<R: Rng>(rng: &mut R) -> u8 {\n         rng.next() as u8\n     }\n }\n \n impl Rand for u16 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> u16 {\n+    fn rand<R: Rng>(rng: &mut R) -> u16 {\n         rng.next() as u16\n     }\n }\n \n impl Rand for u32 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> u32 {\n+    fn rand<R: Rng>(rng: &mut R) -> u32 {\n         rng.next()\n     }\n }\n \n impl Rand for u64 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> u64 {\n+    fn rand<R: Rng>(rng: &mut R) -> u64 {\n         (rng.next() as u64 << 32) | rng.next() as u64\n     }\n }\n \n impl Rand for float {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> float {\n+    fn rand<R: Rng>(rng: &mut R) -> float {\n         rng.gen::<f64>() as float\n     }\n }\n \n impl Rand for f32 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> f32 {\n+    fn rand<R: Rng>(rng: &mut R) -> f32 {\n         rng.gen::<f64>() as f32\n     }\n }\n \n static scale : f64 = (u32::max_value as f64) + 1.0f64;\n impl Rand for f64 {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> f64 {\n+    fn rand<R: Rng>(rng: &mut R) -> f64 {\n         let u1 = rng.next() as f64;\n         let u2 = rng.next() as f64;\n         let u3 = rng.next() as f64;\n@@ -164,14 +164,14 @@ impl Rand for f64 {\n \n impl Rand for char {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> char {\n+    fn rand<R: Rng>(rng: &mut R) -> char {\n         rng.next() as char\n     }\n }\n \n impl Rand for bool {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> bool {\n+    fn rand<R: Rng>(rng: &mut R) -> bool {\n         rng.next() & 1u32 == 1u32\n     }\n }\n@@ -185,7 +185,7 @@ macro_rules! tuple_impl {\n             > Rand for ( $( $tyvar ),* , ) {\n \n             #[inline]\n-            fn rand<R: Rng>(_rng: &R) -> ( $( $tyvar ),* , ) {\n+            fn rand<R: Rng>(_rng: &mut R) -> ( $( $tyvar ),* , ) {\n                 (\n                     // use the $tyvar's to get the appropriate number of\n                     // repeats (they're not actually needed)\n@@ -201,7 +201,7 @@ macro_rules! tuple_impl {\n \n impl Rand for () {\n     #[inline]\n-    fn rand<R: Rng>(_: &R) -> () { () }\n+    fn rand<R: Rng>(_: &mut R) -> () { () }\n }\n tuple_impl!{A}\n tuple_impl!{A, B}\n@@ -216,7 +216,7 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n \n impl<T:Rand> Rand for Option<T> {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> Option<T> {\n+    fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n         if rng.gen() {\n             Some(rng.gen())\n         } else {\n@@ -227,12 +227,12 @@ impl<T:Rand> Rand for Option<T> {\n \n impl<T: Rand> Rand for ~T {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> ~T { ~rng.gen() }\n+    fn rand<R: Rng>(rng: &mut R) -> ~T { ~rng.gen() }\n }\n \n impl<T: Rand> Rand for @T {\n     #[inline]\n-    fn rand<R: Rng>(rng: &R) -> @T { @rng.gen() }\n+    fn rand<R: Rng>(rng: &mut R) -> @T { @rng.gen() }\n }\n \n #[abi = \"cdecl\"]\n@@ -248,7 +248,7 @@ pub mod rustrt {\n /// A random number generator\n pub trait Rng {\n     /// Return the next random integer\n-    pub fn next(&self) -> u32;\n+    pub fn next(&mut self) -> u32;\n }\n \n /// A value with a particular weight compared to other values\n@@ -259,21 +259,21 @@ pub struct Weighted<T> {\n \n pub trait RngUtil {\n     /// Return a random value of a Rand type\n-    fn gen<T:Rand>(&self) -> T;\n+    fn gen<T:Rand>(&mut self) -> T;\n     /**\n      * Return a int randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n-    fn gen_int_range(&self, start: int, end: int) -> int;\n+    fn gen_int_range(&mut self, start: int, end: int) -> int;\n     /**\n      * Return a uint randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n-    fn gen_uint_range(&self, start: uint, end: uint) -> uint;\n+    fn gen_uint_range(&mut self, start: uint, end: uint) -> uint;\n     /**\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n-    fn gen_char_from(&self, chars: &str) -> char;\n+    fn gen_char_from(&mut self, chars: &str) -> char;\n     /**\n      * Return a bool with a 1 in n chance of true\n      *\n@@ -289,7 +289,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn gen_weighted_bool(&self, n: uint) -> bool;\n+    fn gen_weighted_bool(&mut self, n: uint) -> bool;\n     /**\n      * Return a random string of the specified length composed of A-Z,a-z,0-9\n      *\n@@ -305,7 +305,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn gen_str(&self, len: uint) -> ~str;\n+    fn gen_str(&mut self, len: uint) -> ~str;\n     /**\n      * Return a random byte string of the specified length\n      *\n@@ -321,7 +321,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn gen_bytes(&self, len: uint) -> ~[u8];\n+    fn gen_bytes(&mut self, len: uint) -> ~[u8];\n     /**\n      * Choose an item randomly, failing if values is empty\n      *\n@@ -337,9 +337,9 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn choose<T:Copy>(&self, values: &[T]) -> T;\n+    fn choose<T:Copy>(&mut self, values: &[T]) -> T;\n     /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Copy>(&self, values: &[T]) -> Option<T>;\n+    fn choose_option<T:Copy>(&mut self, values: &[T]) -> Option<T>;\n     /**\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n@@ -359,7 +359,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn choose_weighted<T:Copy>(&self, v : &[Weighted<T>]) -> T;\n+    fn choose_weighted<T:Copy>(&mut self, v : &[Weighted<T>]) -> T;\n     /**\n      * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n@@ -379,7 +379,8 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn choose_weighted_option<T:Copy>(&self, v: &[Weighted<T>]) -> Option<T>;\n+    fn choose_weighted_option<T:Copy>(&mut self, v: &[Weighted<T>])\n+                                     -> Option<T>;\n     /**\n      * Return a vec containing copies of the items, in order, where\n      * the weight of the item determines how many copies there are\n@@ -399,7 +400,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn weighted_vec<T:Copy>(&self, v: &[Weighted<T>]) -> ~[T];\n+    fn weighted_vec<T:Copy>(&mut self, v: &[Weighted<T>]) -> ~[T];\n     /**\n      * Shuffle a vec\n      *\n@@ -415,7 +416,7 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn shuffle<T:Copy>(&self, values: &[T]) -> ~[T];\n+    fn shuffle<T:Copy>(&mut self, values: &[T]) -> ~[T];\n     /**\n      * Shuffle a mutable vec in place\n      *\n@@ -435,22 +436,22 @@ pub trait RngUtil {\n      * }\n      * ~~~\n      */\n-    fn shuffle_mut<T>(&self, values: &mut [T]);\n+    fn shuffle_mut<T>(&mut self, values: &mut [T]);\n }\n \n /// Extension methods for random number generators\n impl<R: Rng> RngUtil for R {\n     /// Return a random value for a Rand type\n     #[inline(always)]\n-    fn gen<T: Rand>(&self) -> T {\n+    fn gen<T: Rand>(&mut self) -> T {\n         Rand::rand(self)\n     }\n \n     /**\n      * Return an int randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n-    fn gen_int_range(&self, start: int, end: int) -> int {\n+    fn gen_int_range(&mut self, start: int, end: int) -> int {\n         assert!(start < end);\n         start + int::abs(self.gen::<int>() % (end - start))\n     }\n@@ -459,23 +460,23 @@ impl<R: Rng> RngUtil for R {\n      * Return a uint randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n-    fn gen_uint_range(&self, start: uint, end: uint) -> uint {\n+    fn gen_uint_range(&mut self, start: uint, end: uint) -> uint {\n         assert!(start < end);\n         start + (self.gen::<uint>() % (end - start))\n     }\n \n     /**\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n-    fn gen_char_from(&self, chars: &str) -> char {\n+    fn gen_char_from(&mut self, chars: &str) -> char {\n         assert!(!chars.is_empty());\n         let mut cs = ~[];\n         for str::each_char(chars) |c| { cs.push(c) }\n         self.choose(cs)\n     }\n \n     /// Return a bool with a 1-in-n chance of true\n-    fn gen_weighted_bool(&self, n: uint) -> bool {\n+    fn gen_weighted_bool(&mut self, n: uint) -> bool {\n         if n == 0u {\n             true\n         } else {\n@@ -486,7 +487,7 @@ impl<R: Rng> RngUtil for R {\n     /**\n      * Return a random string of the specified length composed of A-Z,a-z,0-9\n      */\n-    fn gen_str(&self, len: uint) -> ~str {\n+    fn gen_str(&mut self, len: uint) -> ~str {\n         let charset = ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                        abcdefghijklmnopqrstuvwxyz\\\n                        0123456789\";\n@@ -500,19 +501,19 @@ impl<R: Rng> RngUtil for R {\n     }\n \n     /// Return a random byte string of the specified length\n-    fn gen_bytes(&self, len: uint) -> ~[u8] {\n+    fn gen_bytes(&mut self, len: uint) -> ~[u8] {\n         do vec::from_fn(len) |_i| {\n             self.gen()\n         }\n     }\n \n     /// Choose an item randomly, failing if values is empty\n-    fn choose<T:Copy>(&self, values: &[T]) -> T {\n+    fn choose<T:Copy>(&mut self, values: &[T]) -> T {\n         self.choose_option(values).get()\n     }\n \n     /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Copy>(&self, values: &[T]) -> Option<T> {\n+    fn choose_option<T:Copy>(&mut self, values: &[T]) -> Option<T> {\n         if values.is_empty() {\n             None\n         } else {\n@@ -523,15 +524,16 @@ impl<R: Rng> RngUtil for R {\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n      */\n-    fn choose_weighted<T:Copy>(&self, v : &[Weighted<T>]) -> T {\n+    fn choose_weighted<T:Copy>(&mut self, v: &[Weighted<T>]) -> T {\n         self.choose_weighted_option(v).get()\n     }\n \n     /**\n      * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n      */\n-    fn choose_weighted_option<T:Copy>(&self, v: &[Weighted<T>]) -> Option<T> {\n+    fn choose_weighted_option<T:Copy>(&mut self, v: &[Weighted<T>])\n+                                     -> Option<T> {\n         let mut total = 0u;\n         for v.each |item| {\n             total += item.weight;\n@@ -554,7 +556,7 @@ impl<R: Rng> RngUtil for R {\n      * Return a vec containing copies of the items, in order, where\n      * the weight of the item determines how many copies there are\n      */\n-    fn weighted_vec<T:Copy>(&self, v: &[Weighted<T>]) -> ~[T] {\n+    fn weighted_vec<T:Copy>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n         for v.each |item| {\n             for uint::range(0u, item.weight) |_i| {\n@@ -565,14 +567,14 @@ impl<R: Rng> RngUtil for R {\n     }\n \n     /// Shuffle a vec\n-    fn shuffle<T:Copy>(&self, values: &[T]) -> ~[T] {\n+    fn shuffle<T:Copy>(&mut self, values: &[T]) -> ~[T] {\n         let mut m = vec::from_slice(values);\n         self.shuffle_mut(m);\n         m\n     }\n \n     /// Shuffle a mutable vec in place\n-    fn shuffle_mut<T>(&self, values: &mut [T]) {\n+    fn shuffle_mut<T>(&mut self, values: &mut [T]) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place.\n@@ -594,12 +596,12 @@ static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n /// A random number generator that uses the [ISAAC\n /// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n pub struct IsaacRng {\n-    priv mut cnt: u32,\n-    priv mut rsl: [u32, .. RAND_SIZE],\n-    priv mut mem: [u32, .. RAND_SIZE],\n-    priv mut a: u32,\n-    priv mut b: u32,\n-    priv mut c: u32\n+    priv cnt: u32,\n+    priv rsl: [u32, .. RAND_SIZE],\n+    priv mem: [u32, .. RAND_SIZE],\n+    priv a: u32,\n+    priv b: u32,\n+    priv c: u32\n }\n \n pub impl IsaacRng {\n@@ -647,7 +649,7 @@ pub impl IsaacRng {\n     /// Initialises `self`. If `use_rsl` is true, then use the current value\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n-    priv fn init(&self, use_rsl: bool) {\n+    priv fn init(&mut self, use_rsl: bool) {\n         macro_rules! init_mut_many (\n             ($( $var:ident ),* = $val:expr ) => {\n                 let mut $( $var = $val ),*;\n@@ -705,16 +707,16 @@ pub impl IsaacRng {\n \n     /// Refills the output buffer (`self.rsl`)\n     #[inline]\n-    priv fn isaac(&self) {\n+    priv fn isaac(&mut self) {\n         self.c += 1;\n         // abbreviations\n         let mut a = self.a, b = self.b + self.c;\n-        let mem = &mut self.mem;\n-        let rsl = &mut self.rsl;\n \n         static midpoint: uint =  RAND_SIZE as uint / 2;\n \n-        macro_rules! ind (($x:expr) => { mem[($x >> 2) & (RAND_SIZE - 1)] });\n+        macro_rules! ind (($x:expr) => {\n+            self.mem[($x >> 2) & (RAND_SIZE - 1)]\n+        });\n         macro_rules! rngstep(\n             ($j:expr, $shift:expr) => {{\n                 let base = base + $j;\n@@ -724,13 +726,13 @@ pub impl IsaacRng {\n                     a << $shift as uint\n                 };\n \n-                let x = mem[base  + mr_offset];\n-                a = (a ^ mix) + mem[base + m2_offset];\n+                let x = self.mem[base  + mr_offset];\n+                a = (a ^ mix) + self.mem[base + m2_offset];\n                 let y = ind!(x) + a + b;\n-                mem[base + mr_offset] = y;\n+                self.mem[base + mr_offset] = y;\n \n                 b = ind!(y >> RAND_SIZE_LEN) + x;\n-                rsl[base + mr_offset] = b;\n+                self.rsl[base + mr_offset] = b;\n             }}\n         );\n \n@@ -751,7 +753,7 @@ pub impl IsaacRng {\n \n impl Rng for IsaacRng {\n     #[inline(always)]\n-    fn next(&self) -> u32 {\n+    fn next(&mut self) -> u32 {\n         if self.cnt == 0 {\n             // make some more numbers\n             self.isaac();\n@@ -765,15 +767,15 @@ impl Rng for IsaacRng {\n /// generator](http://en.wikipedia.org/wiki/Xorshift). Not suitable for\n /// cryptographic purposes.\n pub struct XorShiftRng {\n-    priv mut x: u32,\n-    priv mut y: u32,\n-    priv mut z: u32,\n-    priv mut w: u32,\n+    priv x: u32,\n+    priv y: u32,\n+    priv z: u32,\n+    priv w: u32,\n }\n \n impl Rng for XorShiftRng {\n     #[inline]\n-    pub fn next(&self) -> u32 {\n+    pub fn next(&mut self) -> u32 {\n         let x = self.x;\n         let t = x ^ (x << 11);\n         self.x = self.y;\n@@ -789,7 +791,10 @@ pub impl XorShiftRng {\n     /// Create an xor shift random number generator with a default seed.\n     fn new() -> XorShiftRng {\n         // constants taken from http://en.wikipedia.org/wiki/Xorshift\n-        XorShiftRng::new_seeded(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n+        XorShiftRng::new_seeded(123456789u32,\n+                                362436069u32,\n+                                521288629u32,\n+                                88675123u32)\n     }\n \n     /**\n@@ -798,7 +803,12 @@ pub impl XorShiftRng {\n      * all other generators constructed with the same seed.\n      */\n     fn new_seeded(x: u32, y: u32, z: u32, w: u32) -> XorShiftRng {\n-        XorShiftRng { x: x, y: y, z: z, w: w }\n+        XorShiftRng {\n+            x: x,\n+            y: y,\n+            z: z,\n+            w: w,\n+        }\n     }\n }\n \n@@ -815,23 +825,23 @@ pub fn seed() -> ~[u8] {\n }\n \n // used to make space in TLS for a random number generator\n-fn tls_rng_state(_v: @IsaacRng) {}\n+fn tls_rng_state(_v: @@mut IsaacRng) {}\n \n /**\n  * Gives back a lazily initialized task-local random number generator,\n  * seeded by the system. Intended to be used in method chaining style, ie\n  * `task_rng().gen::<int>()`.\n  */\n #[inline]\n-pub fn task_rng() -> @IsaacRng {\n-    let r : Option<@IsaacRng>;\n+pub fn task_rng() -> @@mut IsaacRng {\n+    let r : Option<@@mut IsaacRng>;\n     unsafe {\n         r = task::local_data::local_data_get(tls_rng_state);\n     }\n     match r {\n         None => {\n             unsafe {\n-                let rng = @IsaacRng::new_seeded(seed());\n+                let rng = @@mut IsaacRng::new_seeded(seed());\n                 task::local_data::local_data_set(tls_rng_state, rng);\n                 rng\n             }\n@@ -841,9 +851,13 @@ pub fn task_rng() -> @IsaacRng {\n }\n \n // Allow direct chaining with `task_rng`\n-impl<R: Rng> Rng for @R {\n+impl<R: Rng> Rng for @@mut R {\n     #[inline(always)]\n-    fn next(&self) -> u32 { (**self).next() }\n+    fn next(&mut self) -> u32 {\n+        match *self {\n+            @@ref mut r => r.next()\n+        }\n+    }\n }\n \n /**\n@@ -852,7 +866,9 @@ impl<R: Rng> Rng for @R {\n  */\n #[inline]\n pub fn random<T: Rand>() -> T {\n-    (*task_rng()).gen()\n+    match *task_rng() {\n+        @ref mut r => r.gen()\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "72cff5111e76291e46be9ca60b7b03d682972302", "filename": "src/libcore/rand/distributions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibcore%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibcore%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand%2Fdistributions.rs?ref=b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e", "patch": "@@ -27,13 +27,13 @@ mod ziggurat_tables;\n \n // inlining should mean there is no performance penalty for this\n #[inline(always)]\n-fn ziggurat<R:Rng>(rng: &R,\n+fn ziggurat<R:Rng>(rng: &mut R,\n                    center_u: bool,\n                    X: ziggurat_tables::ZigTable,\n                    F: ziggurat_tables::ZigTable,\n                    F_DIFF: ziggurat_tables::ZigTable,\n                    pdf: &'static fn(f64) -> f64, // probability density function\n-                   zero_case: &'static fn(&R, f64) -> f64) -> f64 {\n+                   zero_case: &'static fn(&mut R, f64) -> f64) -> f64 {\n     loop {\n         let u = if center_u {2.0 * rng.gen() - 1.0} else {rng.gen()};\n         let i: uint = rng.gen::<uint>() & 0xff;\n@@ -76,13 +76,13 @@ fn ziggurat<R:Rng>(rng: &R,\n pub struct StandardNormal(f64);\n \n impl Rand for StandardNormal {\n-    fn rand<R:Rng>(rng: &R) -> StandardNormal {\n+    fn rand<R:Rng>(rng: &mut R) -> StandardNormal {\n         #[inline(always)]\n         fn pdf(x: f64) -> f64 {\n             f64::exp((-x*x/2.0) as f64) as f64\n         }\n         #[inline(always)]\n-        fn zero_case<R:Rng>(rng: &R, u: f64) -> f64 {\n+        fn zero_case<R:Rng>(rng: &mut R, u: f64) -> f64 {\n             // compute a random number in the tail by hand\n \n             // strange initial conditions, because the loop is not\n@@ -130,13 +130,13 @@ pub struct Exp1(f64);\n // This could be done via `-f64::ln(rng.gen::<f64>())` but that is slower.\n impl Rand for Exp1 {\n     #[inline]\n-    fn rand<R:Rng>(rng: &R) -> Exp1 {\n+    fn rand<R:Rng>(rng: &mut R) -> Exp1 {\n         #[inline(always)]\n         fn pdf(x: f64) -> f64 {\n             f64::exp(-x)\n         }\n         #[inline(always)]\n-        fn zero_case<R:Rng>(rng: &R, _u: f64) -> f64 {\n+        fn zero_case<R:Rng>(rng: &mut R, _u: f64) -> f64 {\n             ziggurat_tables::ZIG_EXP_R - f64::ln(rng.gen())\n         }\n "}, {"sha": "c9cd2f61e5c8a0a326ef0a14a6716b3bfba10df0", "filename": "src/libcore/unstable/at_exit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e", "patch": "@@ -62,7 +62,8 @@ fn exit_runner(exit_fns: *ExitFunctions) {\n     // give us ownership of the array of functions\n     let mut exit_fns_vec = unsafe { vec::from_buf(start, count as uint) };\n     // Let's not make any promises about execution order\n-    rand::rng().shuffle_mut(exit_fns_vec);\n+    let mut rng = rand::rng();\n+    rng.shuffle_mut(exit_fns_vec);\n \n     debug!(\"running %u exit functions\", exit_fns_vec.len());\n "}, {"sha": "e02a7a337334ed98cd1da4b6098da4c1f368c1c1", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e", "patch": "@@ -13,7 +13,7 @@\n use core::rand::RngUtil;\n \n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n-    let r = rand::rng();\n+    let mut r = rand::rng();\n     for 1000.times {\n         let p = tmpdir.push(r.gen_str(16) + suffix);\n         if os::make_dir(&p, 0x1c0) { // 700"}, {"sha": "7c0673a280bd8e3a0cf15e01fcb770419abc6df3", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=b2d1ac100fb7c7ea8716b17b8df64e43aef41f9e", "patch": "@@ -688,7 +688,7 @@ pub mod bench {\n         // not met, it may run as long as the Go algorithm.\n         pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n \n-            let rng = rand::rng();\n+            let mut rng = rand::rng();\n             let mut magnitude = 10;\n             let mut prev_madp = 0.0;\n "}]}