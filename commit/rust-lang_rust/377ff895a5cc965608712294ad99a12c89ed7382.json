{"sha": "377ff895a5cc965608712294ad99a12c89ed7382", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3N2ZmODk1YTVjYzk2NTYwODcxMjI5NGFkOTlhMTJjODllZDczODI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-06-23T12:02:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-23T12:02:08Z"}, "message": "Rollup merge of #42777 - kennytm:kill-ignore-doctest, r=estebank\n\nRemove most \"```ignore\" doc tests.\n\nUnconditional ` ```ignore ` doc tests lead to outdated examples (e.g. https://github.com/rust-lang/rust/issues/42729#issuecomment-309346572). This PR tries to change all existing ` ```ignore ` tests into one of the following:\n\n* Add import and declarations to ensure the code is run-pass\n* If the code is not Rust, change to ` ```text `/` ```sh `/` ```json `/` ```dot `\n* If the code is expected compile-fail, change to ` ```compile_fail `\n* If the code is expected run-fail, change to ` ```should_panic `\n* If the code can type-check but cannot link/run, change to ` ```no_run `\n* Otherwise, add an explanation after the ` ```ignore `\n\nThe `--explain` handling is changed to cope with hidden lines from the error index.\n\nTidy is changed to reject any unexplained ` ```ignore ` and ` ```rust,ignore `.", "tree": {"sha": "18b1ba146d5b56fc9a570397226474187a109062", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18b1ba146d5b56fc9a570397226474187a109062"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/377ff895a5cc965608712294ad99a12c89ed7382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/377ff895a5cc965608712294ad99a12c89ed7382", "html_url": "https://github.com/rust-lang/rust/commit/377ff895a5cc965608712294ad99a12c89ed7382", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/377ff895a5cc965608712294ad99a12c89ed7382/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd32b1ba0d2d51a7e8505c1d3e37d17d3ba12843", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd32b1ba0d2d51a7e8505c1d3e37d17d3ba12843", "html_url": "https://github.com/rust-lang/rust/commit/bd32b1ba0d2d51a7e8505c1d3e37d17d3ba12843"}, {"sha": "9addd3ba657e0d37c3fa5296262474db91d26d8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9addd3ba657e0d37c3fa5296262474db91d26d8f", "html_url": "https://github.com/rust-lang/rust/commit/9addd3ba657e0d37c3fa5296262474db91d26d8f"}], "stats": {"total": 797, "additions": 560, "deletions": 237}, "files": [{"sha": "4a43018e973b176b72c36e75125d4926b4b648d8", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -42,8 +42,10 @@\n //! Recursive structures must be boxed, because if the definition of `Cons`\n //! looked like this:\n //!\n-//! ```rust,ignore\n+//! ```compile_fail,E0072\n+//! # enum List<T> {\n //! Cons(T, List<T>),\n+//! # }\n //! ```\n //!\n //! It wouldn't work. This is because the size of a `List` depends on how many"}, {"sha": "1bd95fb82aa4d68874485f79c1613c099cf616c7", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -230,7 +230,7 @@\n //! There are a number of related macros in the `format!` family. The ones that\n //! are currently implemented are:\n //!\n-//! ```ignore\n+//! ```ignore (only-for-syntax-highlight)\n //! format!      // described above\n //! write!       // first argument is a &mut io::Write, the destination\n //! writeln!     // same as write but appends a newline"}, {"sha": "c56a93c046041082a0a000e4e3d0a5208b8b1888", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -244,7 +244,11 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Examples\n     ///\n-    /// ```ignore\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// # extern crate alloc;\n+    /// # use std::ptr;\n+    /// # use alloc::raw_vec::RawVec;\n     /// struct MyVec<T> {\n     ///     buf: RawVec<T>,\n     ///     len: usize,\n@@ -261,6 +265,10 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///         self.len += 1;\n     ///     }\n     /// }\n+    /// # fn main() {\n+    /// #   let mut vec = MyVec { buf: RawVec::new(), len: 0 };\n+    /// #   vec.push(1);\n+    /// # }\n     /// ```\n     #[inline(never)]\n     #[cold]\n@@ -440,13 +448,17 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Examples\n     ///\n-    /// ```ignore\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// # extern crate alloc;\n+    /// # use std::ptr;\n+    /// # use alloc::raw_vec::RawVec;\n     /// struct MyVec<T> {\n     ///     buf: RawVec<T>,\n     ///     len: usize,\n     /// }\n     ///\n-    /// impl<T> MyVec<T> {\n+    /// impl<T: Clone> MyVec<T> {\n     ///     pub fn push_all(&mut self, elems: &[T]) {\n     ///         self.buf.reserve(self.len, elems.len());\n     ///         // reserve would have aborted or panicked if the len exceeded\n@@ -459,6 +471,10 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///         }\n     ///     }\n     /// }\n+    /// # fn main() {\n+    /// #   let mut vector = MyVec { buf: RawVec::new(), len: 0 };\n+    /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n+    /// # }\n     /// ```\n     pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         unsafe {"}, {"sha": "79d1ccf637d3753a1cff9a3dd5e8813c713a50a0", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -124,7 +124,7 @@ use boxed::Box;\n /// similar, but without the UTF-8 constraint. The second implication is that\n /// you cannot index into a `String`:\n ///\n-/// ```ignore\n+/// ```compile_fail,E0277\n /// let s = \"hello\";\n ///\n /// println!(\"The first letter of s is {}\", s[0]); // ERROR!!!"}, {"sha": "5d1999a42629a2c54fe4bf5f56419ca5f3322cdc", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -156,7 +156,7 @@ use Bound::{Excluded, Included, Unbounded};\n /// However be careful: if you try to access an index which isn't in the `Vec`,\n /// your software will panic! You cannot do this:\n ///\n-/// ```ignore\n+/// ```should_panic\n /// let v = vec![0, 2, 4, 6];\n /// println!(\"{}\", v[6]); // it will panic!\n /// ```"}, {"sha": "d6a9be4437d435f88031f9be3b5a1d41d888f92b", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -211,7 +211,7 @@\n //! There's one more subtle bit here: the standard library contains an\n //! interesting implementation of [`IntoIterator`]:\n //!\n-//! ```ignore\n+//! ```ignore (only-for-syntax-highlight)\n //! impl<I: Iterator> IntoIterator for I\n //! ```\n //!"}, {"sha": "e8fd729b638bed4abfdd7bc2bdcd8a7e8faa274e", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -434,7 +434,7 @@ macro_rules! impls{\n /// example, here is a struct `Slice` that has two pointers of type `*const T`,\n /// presumably pointing into an array somewhere:\n ///\n-/// ```ignore\n+/// ```compile_fail,E0392\n /// struct Slice<'a, T> {\n ///     start: *const T,\n ///     end: *const T,"}, {"sha": "bba42752f50c646db08b7240f745252c11f867c4", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -328,11 +328,18 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n ///\n /// Here's an example of how a collection might make use of needs_drop:\n ///\n-/// ```ignore\n+/// ```\n /// #![feature(needs_drop)]\n /// use std::{mem, ptr};\n ///\n-/// pub struct MyCollection<T> { /* ... */ }\n+/// pub struct MyCollection<T> {\n+/// #   data: [T; 1],\n+///     /* ... */\n+/// }\n+/// # impl<T> MyCollection<T> {\n+/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n+/// #   fn free_buffer(&mut self) {}\n+/// # }\n ///\n /// impl<T> Drop for MyCollection<T> {\n ///     fn drop(&mut self) {\n@@ -575,7 +582,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// `replace` allows consumption of a struct field by replacing it with another value.\n /// Without `replace` you can run into issues like these:\n ///\n-/// ```ignore\n+/// ```compile_fail,E0507\n /// struct Buffer<T> { buf: Vec<T> }\n ///\n /// impl<T> Buffer<T> {\n@@ -645,7 +652,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n ///\n /// Borrows are based on lexical scope, so this produces an error:\n ///\n-/// ```ignore\n+/// ```compile_fail,E0502\n /// let mut v = vec![1, 2, 3];\n /// let x = &v[0];\n ///"}, {"sha": "19da887cbbfbee7a6f5d1d10d6ad98512a40fe5e", "filename": "src/libcore/ops/place.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fops%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fops%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fplace.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -38,7 +38,13 @@ pub trait Place<Data: ?Sized> {\n ///\n /// `PLACE <- EXPR` effectively desugars into:\n ///\n-/// ```rust,ignore\n+/// ```\n+/// # #![feature(placement_new_protocol, box_heap)]\n+/// # use std::ops::{Placer, Place, InPlace};\n+/// # #[allow(non_snake_case)]\n+/// # fn main() {\n+/// # let PLACE = std::boxed::HEAP;\n+/// # let EXPR = 1;\n /// let p = PLACE;\n /// let mut place = Placer::make_place(p);\n /// let raw_place = Place::pointer(&mut place);\n@@ -47,6 +53,7 @@ pub trait Place<Data: ?Sized> {\n ///     std::ptr::write(raw_place, value);\n ///     InPlace::finalize(place)\n /// }\n+/// # ; }\n /// ```\n ///\n /// The type of `PLACE <- EXPR` is derived from the type of `PLACE`;\n@@ -89,14 +96,21 @@ pub trait InPlace<Data: ?Sized>: Place<Data> {\n ///\n /// `box EXPR` effectively desugars into:\n ///\n-/// ```rust,ignore\n+/// ```\n+/// # #![feature(placement_new_protocol)]\n+/// # use std::ops::{BoxPlace, Place, Boxed};\n+/// # #[allow(non_snake_case)]\n+/// # fn main() {\n+/// # let EXPR = 1;\n /// let mut place = BoxPlace::make_place();\n /// let raw_place = Place::pointer(&mut place);\n /// let value = EXPR;\n+/// # let _: Box<_> =\n /// unsafe {\n ///     ::std::ptr::write(raw_place, value);\n ///     Boxed::finalize(place)\n /// }\n+/// # ; }\n /// ```\n ///\n /// The type of `box EXPR` is supplied from its surrounding"}, {"sha": "33258b7a875c599aa584d85db0a3d1965ab979c6", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -26,7 +26,7 @@ use fmt;\n /// It does not have an `IntoIterator` implementation, so you can't use it in a\n /// `for` loop directly. This won't compile:\n ///\n-/// ```ignore\n+/// ```compile_fail,E0277\n /// for i in .. {\n ///    // ...\n /// }\n@@ -184,7 +184,7 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n /// It does not have an `IntoIterator` implementation, so you can't use it in a\n /// `for` loop directly. This won't compile:\n ///\n-/// ```ignore\n+/// ```compile_fail,E0277\n /// for i in ..5 {\n ///     // ...\n /// }\n@@ -313,7 +313,8 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// It does not have an `IntoIterator` implementation, so you can't use it in a\n /// `for` loop directly. This won't compile:\n ///\n-/// ```ignore\n+/// ```compile_fail,E0277\n+/// #![feature(inclusive_range_syntax)]\n /// for i in ...5 {\n ///     // ...\n /// }"}, {"sha": "60b7669f3b2d91f118a0f29795861dff0f314e0e", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -15,8 +15,10 @@\n //! useful an upstream crate must define panicking for libcore to use. The current\n //! interface for panicking is:\n //!\n-//! ```ignore\n-//! fn panic_impl(fmt: fmt::Arguments, &(&'static str, u32)) -> !;\n+//! ```\n+//! # use std::fmt;\n+//! fn panic_impl(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> !\n+//! # { loop {} }\n //! ```\n //!\n //! This definition allows for panicking with any general message, but it does not"}, {"sha": "54ae9e0d628d59c78f365378c931ec1548a076a4", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -408,11 +408,11 @@ impl<T: ?Sized> *const T {\n     ///\n     /// Basic usage:\n     ///\n-    /// ```ignore\n-    /// let val: *const u8 = &10u8 as *const u8;\n+    /// ```\n+    /// let ptr: *const u8 = &10u8 as *const u8;\n     ///\n     /// unsafe {\n-    ///     if let Some(val_back) = val.as_ref() {\n+    ///     if let Some(val_back) = ptr.as_ref() {\n     ///         println!(\"We got back the value: {}!\", val_back);\n     ///     }\n     /// }\n@@ -570,11 +570,11 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Basic usage:\n     ///\n-    /// ```ignore\n-    /// let val: *mut u8 = &mut 10u8 as *mut u8;\n+    /// ```\n+    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n     ///\n     /// unsafe {\n-    ///     if let Some(val_back) = val.as_ref() {\n+    ///     if let Some(val_back) = ptr.as_ref() {\n     ///         println!(\"We got back the value: {}!\", val_back);\n     ///     }\n     /// }"}, {"sha": "7412a01e11e1e85a2d3946e72f5ffa86f4baeb10", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -111,7 +111,7 @@\n //!\n //! Output from first example (in `example1.dot`):\n //!\n-//! ```ignore\n+//! ```dot\n //! digraph example1 {\n //!     N0[label=\"N0\"];\n //!     N1[label=\"N1\"];"}, {"sha": "5e36bd8ec2772abb1db02605c3763adaceb50bfe", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 66, "deletions": 33, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -198,7 +198,12 @@ impl Trait for u8 {\n \n Now, if we have the following code:\n \n-```ignore\n+```compile_fail,E0038\n+# trait Trait { fn foo<T>(&self, on: T); }\n+# impl Trait for String { fn foo<T>(&self, on: T) {} }\n+# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n+# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n+# // etc.\n fn call_foo(thing: Box<Trait>) {\n     thing.foo(true); // this could be any one of the 8 types above\n     thing.foo(1);\n@@ -565,8 +570,9 @@ fn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!\n ```\n \"##,\n \n-// isn't thrown anymore\n E0139: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n There are various restrictions on transmuting between types in Rust; for example\n types being transmuted must have the same size. To apply all these restrictions,\n the compiler must know the exact types that may be transmuted. When type\n@@ -602,22 +608,24 @@ If it's possible, hand-monomorphize the code by writing the function for each\n possible type substitution. It's possible to use traits to do this cleanly,\n for example:\n \n-```ignore\n+```\n+use std::mem::transmute;\n+\n struct Foo<T>(Vec<T>);\n \n-trait MyTransmutableType {\n+trait MyTransmutableType: Sized {\n     fn transmute(Vec<Self>) -> Foo<Self>;\n }\n \n impl MyTransmutableType for u8 {\n-    fn transmute(x: Foo<u8>) -> Vec<u8> {\n-        transmute(x)\n+    fn transmute(x: Vec<u8>) -> Foo<u8> {\n+        unsafe { transmute(x) }\n     }\n }\n \n impl MyTransmutableType for String {\n-    fn transmute(x: Foo<String>) -> Vec<String> {\n-        transmute(x)\n+    fn transmute(x: Vec<String>) -> Foo<String> {\n+        unsafe { transmute(x) }\n     }\n }\n \n@@ -635,8 +643,14 @@ is a size mismatch in one of the impls.\n \n It is also possible to manually transmute:\n \n-```ignore\n-ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\n+```\n+# use std::ptr;\n+# let v = Some(\"value\");\n+# type SomeType = &'static [u8];\n+unsafe {\n+    ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\n+}\n+# ;\n ```\n \n Note that this does not move `v` (unlike `transmute`), and may need a\n@@ -662,7 +676,7 @@ them yourself.\n You can build a free-standing crate by adding `#![no_std]` to the crate\n attributes:\n \n-```ignore\n+```ignore (only-for-syntax-highlight)\n #![no_std]\n ```\n \n@@ -764,7 +778,7 @@ foo(3_i8);\n \n Here is that same example again, with some explanatory comments:\n \n-```ignore\n+```compile_fail,E0271\n trait Trait { type AssociatedType; }\n \n fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n@@ -784,7 +798,7 @@ fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n }\n \n impl Trait for i8 { type AssociatedType = &'static str; }\n-~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n //      |                             |\n // `i8` does have                     |\n // implementation                     |\n@@ -816,7 +830,7 @@ The above fails because of an analogous type mismatch,\n though may be harder to see. Again, here are some\n explanatory comments for the same example:\n \n-```ignore\n+```compile_fail\n {\n     let vs = vec![1, 2, 3, 4];\n \n@@ -1416,6 +1430,8 @@ trait SecondTrait : FirstTrait {\n \"##,\n \n E0398: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n In Rust 1.3, the default object lifetime bounds are expected to change, as\n described in [RFC 1156]. You are getting a warning because the compiler\n thinks it is possible that this change will cause a compilation error in your\n@@ -1433,14 +1449,16 @@ time, this means that you will want to change the signature of a function that\n you are calling. For example, if the error is reported on a call like `foo(x)`,\n and `foo` is defined as follows:\n \n-```ignore\n-fn foo(arg: &Box<SomeTrait>) { ... }\n+```\n+# trait SomeTrait {}\n+fn foo(arg: &Box<SomeTrait>) { /* ... */ }\n ```\n \n You might change it to:\n \n-```ignore\n-fn foo<'a>(arg: &Box<SomeTrait+'a>) { ... }\n+```\n+# trait SomeTrait {}\n+fn foo<'a>(arg: &'a Box<SomeTrait+'a>) { /* ... */ }\n ```\n \n This explicitly states that you expect the trait object `SomeTrait` to contain\n@@ -1809,24 +1827,29 @@ specified exit code, use `std::process::exit`.\n E0591: r##\"\n Per [RFC 401][rfc401], if you have a function declaration `foo`:\n \n-```rust,ignore\n+```\n // For the purposes of this explanation, all of these\n // different kinds of `fn` declarations are equivalent:\n-fn foo(x: i32) { ... }\n-extern \"C\" fn foo(x: i32);\n-impl i32 { fn foo(x: self) { ... } }\n+struct S;\n+fn foo(x: S) { /* ... */ }\n+# #[cfg(for_demonstration_only)]\n+extern \"C\" { fn foo(x: S); }\n+# #[cfg(for_demonstration_only)]\n+impl S { fn foo(self) { /* ... */ } }\n ```\n \n-the type of `foo` is **not** `fn(i32)`, as one might expect.\n+the type of `foo` is **not** `fn(S)`, as one might expect.\n Rather, it is a unique, zero-sized marker type written here as `typeof(foo)`.\n-However, `typeof(foo)` can be _coerced_ to a function pointer `fn(i32)`,\n+However, `typeof(foo)` can be _coerced_ to a function pointer `fn(S)`,\n so you rarely notice this:\n \n-```rust,ignore\n-let x: fn(i32) = foo; // OK, coerces\n+```\n+# struct S;\n+# fn foo(_: S) {}\n+let x: fn(S) = foo; // OK, coerces\n ```\n \n-The reason that this matter is that the type `fn(i32)` is not specific to\n+The reason that this matter is that the type `fn(S)` is not specific to\n any particular function: it's a function _pointer_. So calling `x()` results\n in a virtual call, whereas `foo()` is statically dispatched, because the type\n of `foo` tells us precisely what function is being called.\n@@ -1837,14 +1860,17 @@ when using **transmute** to convert a fn item into a fn pointer.\n \n This is sometimes done as part of an FFI:\n \n-```rust,ignore\n+```compile_fail,E0591\n extern \"C\" fn foo(userdata: Box<i32>) {\n-   ...\n+    /* ... */\n }\n \n+# fn callback(_: extern \"C\" fn(*mut i32)) {}\n+# use std::mem::transmute;\n+# unsafe {\n let f: extern \"C\" fn(*mut i32) = transmute(foo);\n callback(f);\n-\n+# }\n ```\n \n Here, transmute is being used to convert the types of the fn arguments.\n@@ -1856,8 +1882,15 @@ This pattern should be rewritten. There are a few possible ways to do this:\n - change the original fn declaration to match the expected signature,\n   and do the cast in the fn body (the prefered option)\n - cast the fn item fo a fn pointer before calling transmute, as shown here:\n-  - `let f: extern \"C\" fn(*mut i32) = transmute(foo as extern \"C\" fn(_))`\n-  - `let f: extern \"C\" fn(*mut i32) = transmute(foo as usize) /* works too */`\n+\n+    ```\n+    # extern \"C\" fn foo(_: Box<i32>) {}\n+    # use std::mem::transmute;\n+    # unsafe {\n+    let f: extern \"C\" fn(*mut i32) = transmute(foo as extern \"C\" fn(_));\n+    let f: extern \"C\" fn(*mut i32) = transmute(foo as usize); // works too\n+    # }\n+    ```\n \n The same applies to transmutes to `*mut fn()`, which were observedin practice.\n Note though that use of this type is generally incorrect.\n@@ -1905,7 +1938,7 @@ An unknown lint was used on the command line.\n \n Erroneous example:\n \n-```ignore\n+```sh\n rustc -D bogus omse_file.rs\n ```\n "}, {"sha": "b84cd212c4ab4451dff7c969dc9e5aac929125ac", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -755,15 +755,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     ///\n     /// For example:\n     ///\n-    /// ```ignore\n+    /// ```\n     /// let a: i32;\n     /// a = 10; // ok, even though a is uninitialized\n+    /// ```\n     ///\n+    /// ```\n     /// struct Point { x: u32, y: u32 }\n-    /// let p: Point;\n+    /// let mut p: Point;\n     /// p.x = 22; // ok, even though `p` is uninitialized\n+    /// ```\n     ///\n-    /// let p: Box<Point>;\n+    /// ```compile_fail,E0381\n+    /// # struct Point { x: u32, y: u32 }\n+    /// let mut p: Box<Point>;\n     /// (*p).x = 22; // not ok, p is uninitialized, can't deref\n     /// ```\n     fn check_if_assigned_path_is_moved(&self,"}, {"sha": "38dcc731236911bc1b432dea44e3bd89699912f6", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -153,10 +153,13 @@ structure that is currently uninitialized.\n \n For example, this can happen when a drop has taken place:\n \n-```ignore\n+```compile_fail,E0383\n struct Foo {\n     a: u32,\n }\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n \n let mut x = Foo { a: 1 };\n drop(x); // `x` is now uninitialized\n@@ -169,6 +172,9 @@ This error can be fixed by fully reinitializing the structure in question:\n struct Foo {\n     a: u32,\n }\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n \n let mut x = Foo { a: 1 };\n drop(x);\n@@ -944,10 +950,9 @@ fn main() {\n }\n ```\n \n-Moving out of a member of a mutably borrowed struct is fine if you put something\n-back. `mem::replace` can be used for that:\n+Moving a member out of a mutably borrowed struct will also cause E0507 error:\n \n-```ignore\n+```compile_fail,E0507\n struct TheDarkKnight;\n \n impl TheDarkKnight {\n@@ -959,18 +964,31 @@ struct Batcave {\n }\n \n fn main() {\n-    use std::mem;\n-\n     let mut cave = Batcave {\n         knight: TheDarkKnight\n     };\n     let borrowed = &mut cave;\n \n     borrowed.knight.nothing_is_true(); // E0507\n-    mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n }\n ```\n \n+It is fine only if you put something back. `mem::replace` can be used for that:\n+\n+```\n+# struct TheDarkKnight;\n+# impl TheDarkKnight { fn nothing_is_true(self) {} }\n+# struct Batcave { knight: TheDarkKnight }\n+use std::mem;\n+\n+let mut cave = Batcave {\n+    knight: TheDarkKnight\n+};\n+let borrowed = &mut cave;\n+\n+mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n+```\n+\n You can find more information about borrowing in the rust-book:\n http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n \"##,"}, {"sha": "56d08184a0f17b10f1c317d93198a98f28ed32a8", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -436,17 +436,19 @@ that happens.\n Qualified names are good practice, and most code works well with them. But if\n you prefer them unqualified, you can import the variants into scope:\n \n-```ignore\n+```\n use Method::*;\n enum Method { GET, POST }\n+# fn main() {}\n ```\n \n If you want others to be able to import variants from your module directly, use\n `pub use`:\n \n-```ignore\n+```\n pub use Method::*;\n-enum Method { GET, POST }\n+pub enum Method { GET, POST }\n+# fn main() {}\n ```\n \"##,\n "}, {"sha": "54e7c398fe6a67379990159b7064fd778f4af026", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -355,14 +355,21 @@ fn handle_explain(code: &str,\n     };\n     match descriptions.find_description(&normalised) {\n         Some(ref description) => {\n+            let mut is_in_code_block = false;\n             // Slice off the leading newline and print.\n-            print!(\"{}\", &(&description[1..]).split(\"\\n\").map(|x| {\n-                format!(\"{}\\n\", if x.starts_with(\"```\") {\n-                    \"```\"\n+            for line in description[1..].lines() {\n+                let indent_level = line.find(|c: char| !c.is_whitespace())\n+                    .unwrap_or_else(|| line.len());\n+                let dedented_line = &line[indent_level..];\n+                if dedented_line.starts_with(\"```\") {\n+                    is_in_code_block = !is_in_code_block;\n+                    println!(\"{}\", &line[..(indent_level+3)]);\n+                } else if is_in_code_block && dedented_line.starts_with(\"# \") {\n+                    continue;\n                 } else {\n-                    x\n-                })\n-            }).collect::<String>());\n+                    println!(\"{}\", line);\n+                }\n+            }\n         }\n         None => {\n             early_error(output, &format!(\"no extended information for {}\", code));"}, {"sha": "1fa1a896dd6b65b48eca7335b0fb3034563567cf", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -21,7 +21,7 @@ A link name was given with an empty name. Erroneous code example:\n The rust compiler cannot link to an external library if you don't give it its\n name. Example:\n \n-```ignore\n+```no_run\n #[link(name = \"some_lib\")] extern {} // ok!\n ```\n \"##,\n@@ -32,7 +32,7 @@ as frameworks are specific to that operating system.\n \n Erroneous code example:\n \n-```ignore\n+```ignore (should-compile_fail-but-cannot-doctest-conditionally-without-macos)\n #[link(name = \"FooCoreServices\", kind = \"framework\")] extern {}\n // OS used to compile is Linux for example\n ```\n@@ -75,7 +75,7 @@ A link was used without a name parameter. Erroneous code example:\n Please add the name parameter to allow the rust compiler to find the library\n you want. Example:\n \n-```ignore\n+```no_run\n #[link(kind = \"dylib\", name = \"some_lib\")] extern {} // ok!\n ```\n \"##,"}, {"sha": "ff74698deab3fb4eddce2c597939edccd49debd3", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -150,7 +150,7 @@\n //! the compiler. For example, if crate A wanted to use Bv1 and Bv2, then it\n //! would look something like:\n //!\n-//! ```ignore\n+//! ```compile_fail,E0463\n //! extern crate b1;\n //! extern crate b2;\n //!"}, {"sha": "54f285480ab5371506e6fb1d3a7b78fb35f6a5a3", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -471,7 +471,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// But there may also be candidates that the test just doesn't\n     /// apply to. The classical example involves wildcards:\n     ///\n-    /// ```rust,ignore\n+    /// ```\n+    /// # let (x, y, z) = (true, true, true);\n     /// match (x, y, z) {\n     ///     (true, _, true) => true,    // (0)\n     ///     (_, true, _) => true,       // (1)"}, {"sha": "2244ffde3c9d0933fbf0c33886fe0e08d342c67e", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -47,11 +47,12 @@ set of scheduled drops up front, and so whenever we exit from the\n scope we only drop the values scheduled thus far. For example, consider\n the scope S corresponding to this loop:\n \n-```rust,ignore\n+```\n+# let cond = true;\n loop {\n-    let x = ...;\n+    let x = ..;\n     if cond { break; }\n-    let y = ...;\n+    let y = ..;\n }\n ```\n "}, {"sha": "464dd72e5698664f1bc450d8e3fce7374f6a3cd8", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -154,7 +154,7 @@ E0449: r##\"\n A visibility qualifier was used when it was unnecessary. Erroneous code\n examples:\n \n-```compile_fail\n+```compile_fail,E0449\n struct Bar;\n \n trait Foo {\n@@ -171,7 +171,7 @@ pub impl Foo for Bar { // error: unnecessary visibility qualifier\n To fix this error, please remove the visibility qualifier when it is not\n required. Example:\n \n-```ignore\n+```\n struct Bar;\n \n trait Foo {\n@@ -184,8 +184,8 @@ impl Bar {}\n \n // Trait methods share the visibility of the trait, so `pub` is\n // unnecessary in either case\n-pub impl Foo for Bar {\n-    pub fn foo() {}\n+impl Foo for Bar {\n+    fn foo() {}\n }\n ```\n \"##,"}, {"sha": "1de31c5d79154ee16547b476b9feebdeef4bf597", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -20,21 +20,31 @@\n //! To define a plugin, build a dylib crate with a\n //! `#[plugin_registrar]` function:\n //!\n-//! ```rust,ignore\n+//! ```no_run\n //! #![crate_name = \"myplugin\"]\n //! #![crate_type = \"dylib\"]\n //! #![feature(plugin_registrar)]\n+//! #![feature(rustc_private)]\n //!\n-//! extern crate rustc;\n+//! extern crate rustc_plugin;\n+//! extern crate syntax;\n+//! extern crate syntax_pos;\n //!\n //! use rustc_plugin::Registry;\n+//! use syntax::ext::base::{ExtCtxt, MacResult};\n+//! use syntax_pos::Span;\n+//! use syntax::tokenstream::TokenTree;\n //!\n //! #[plugin_registrar]\n //! pub fn plugin_registrar(reg: &mut Registry) {\n //!     reg.register_macro(\"mymacro\", expand_mymacro);\n //! }\n //!\n-//! fn expand_mymacro(...) {  // details elided\n+//! fn expand_mymacro(cx: &mut ExtCtxt, span: Span, tt: &[TokenTree]) -> Box<MacResult> {\n+//!     unimplemented!()\n+//! }\n+//!\n+//! # fn main() {}\n //! ```\n //!\n //! WARNING: We currently don't check that the registrar function"}, {"sha": "f8559954db12bf7f40f12ccf25ddaf220ae7449b", "filename": "src/librustc_privacy/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_privacy%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_privacy%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Fdiagnostics.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -32,7 +32,7 @@ To solve this error, please ensure that the trait is also public. The trait\n can be made inaccessible if necessary by placing it into a private inner\n module, but it still has to be marked with `pub`. Example:\n \n-```ignore\n+```\n pub trait Foo { // we set the Foo trait public\n     fn dummy(&self) { }\n }\n@@ -75,9 +75,11 @@ mod Foo {\n \"##,\n \n E0447: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n The `pub` keyword was used inside a function. Erroneous code example:\n \n-```ignore\n+```\n fn foo() {\n     pub struct Bar; // error: visibility has no effect inside functions\n }\n@@ -100,15 +102,15 @@ pub enum Foo {\n Since the enum is already public, adding `pub` on one its elements is\n unnecessary. Example:\n \n-```compile_fail,\n+```compile_fail\n enum Foo {\n     pub Bar, // not ok!\n }\n ```\n \n This is the correct syntax:\n \n-```ignore\n+```\n pub enum Foo {\n     Bar, // ok!\n }"}, {"sha": "34f3ff276ccd97f9137d2ff9428f9d54f5141e08", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 57, "deletions": 41, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -50,7 +50,7 @@ variable declarations and expression statements.\n \n Here is an example that demonstrates the error:\n \n-```ignore\n+```\n fn f() {\n     // Variable declaration before import\n     let x = 0;\n@@ -86,7 +86,7 @@ items under a new local name.\n \n An example of this error:\n \n-```ignore\n+```\n use foo::baz;\n use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n \n@@ -188,15 +188,15 @@ already been imported.\n Erroneous code example:\n \n ```compile_fail,E0254\n-extern crate alloc;\n+extern crate core;\n \n mod foo {\n-    pub trait alloc {\n+    pub trait core {\n         fn do_something();\n     }\n }\n \n-use foo::alloc; // error: an extern crate named `alloc` has already\n+use foo::core;  // error: an extern crate named `core` has already\n                 //        been imported in this module\n \n fn main() {}\n@@ -205,16 +205,16 @@ fn main() {}\n To fix issue issue, you have to rename at least one of the two imports.\n Example:\n \n-```ignore\n-extern crate alloc as liballoc; // ok!\n+```\n+extern crate core as libcore; // ok!\n \n mod foo {\n-    pub trait alloc {\n+    pub trait core {\n         fn do_something();\n     }\n }\n \n-use foo::alloc;\n+use foo::core;\n \n fn main() {}\n ```\n@@ -295,8 +295,9 @@ that has been imported into the current module.\n Erroneous code example:\n \n ```compile_fail,E0259\n-extern crate std;\n-extern crate libc as std;\n+# #![feature(libc)]\n+extern crate core;\n+extern crate libc as core;\n \n fn main() {}\n ```\n@@ -306,9 +307,12 @@ external crate imported into the current module.\n \n Correct example:\n \n-```ignore\n-extern crate std;\n+```\n+# #![feature(libc)]\n+extern crate core;\n extern crate libc as other_name;\n+\n+fn main() {}\n ```\n \"##,\n \n@@ -317,26 +321,26 @@ The name for an item declaration conflicts with an external crate's name.\n \n Erroneous code example:\n \n-```ignore,E0260\n-extern crate abc;\n+```compile_fail,E0260\n+extern crate core;\n \n-struct abc;\n+struct core;\n ```\n \n There are two possible solutions:\n \n Solution #1: Rename the item.\n \n-```ignore\n-extern crate abc;\n+```\n+extern crate core;\n \n struct xyz;\n ```\n \n Solution #2: Import the crate with a different name.\n \n-```ignore\n-extern crate abc as xyz;\n+```\n+extern crate core as xyz;\n \n struct abc;\n ```\n@@ -509,7 +513,8 @@ This may require additional type hints in the function body.\n In case the item is a function inside an `impl`, defining a private helper\n function might be easier:\n \n-```ignore\n+```\n+# struct Foo<T>(T);\n impl<T> Foo<T> {\n     pub fn foo(&self, x: T) {\n         self.bar(x);\n@@ -584,7 +589,8 @@ impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n Please verify that the name of the trait wasn't misspelled and ensure that it\n was imported. Example:\n \n-```ignore\n+```\n+# #[cfg(for_demonstration_only)]\n // solution 1:\n use some_file::SomeTrait;\n \n@@ -721,7 +727,7 @@ Here, `y` is bound by-value in one case and by-reference in the other.\n To fix this error, just use the same mode in both cases.\n Generally using `ref` or `ref mut` where not already used will fix this:\n \n-```ignore\n+```\n let x = (0, 2);\n match x {\n     (0, ref y) | (ref y, 0) => { /* use y */}\n@@ -905,7 +911,8 @@ match (1, 2) {\n \n Or maybe did you mean to unify? Consider using a guard:\n \n-```ignore\n+```\n+# let (A, B, C) = (1, 2, 3);\n match (A, B, C) {\n     (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\n     (y, z, see) => { /* A and B unequal; do another thing */ }\n@@ -1045,9 +1052,12 @@ let x = unknown_variable; // ok!\n If the item is not defined in the current module, it must be imported using a\n `use` statement, like so:\n \n-```ignore\n+```\n+# mod foo { pub fn bar() {} }\n+# fn main() {\n use foo::bar;\n bar();\n+# }\n ```\n \n If the item you are importing is not defined in some super-module of the\n@@ -1130,8 +1140,11 @@ use something::{self, self}; // error: `self` import can only appear once in\n Please verify you didn't misspell the import name or remove the duplicated\n `self` import. Example:\n \n-```ignore\n-use something::self; // ok!\n+```\n+# mod something {}\n+# fn main() {\n+use something::{self}; // ok!\n+# }\n ```\n \"##,\n \n@@ -1164,21 +1177,23 @@ prefixes, respectively. Also verify that you didn't misspell the import\n name and that the import exists in the module from where you tried to\n import it. Example:\n \n-```ignore\n+```\n use self::something::Foo; // ok!\n \n mod something {\n     pub struct Foo;\n }\n+# fn main() {}\n ```\n \n Or, if you tried to use a module from an external crate, you may have missed\n the `extern crate` declaration (which is usually placed in the crate root):\n \n-```ignore\n-extern crate homura; // Required to use the `homura` crate\n+```\n+extern crate core; // Required to use the `core` crate\n \n-use homura::Madoka;\n+use core::any;\n+# fn main() {}\n ```\n \"##,\n \n@@ -1339,7 +1354,7 @@ extern crate core as another_crate;\n This is a syntax error at the level of attribute declarations. The proper\n syntax for macro imports is the following:\n \n-```ignore\n+```ignore (cannot-doctest-multicrate-project)\n // In some_crate:\n #[macro_export]\n macro_rules! get_tacos {\n@@ -1383,7 +1398,7 @@ Decide which macros you would like to export and list them properly.\n \n These are proper reexport declarations:\n \n-```ignore\n+```ignore (cannot-doctest-multicrate-project)\n #[macro_reexport(some_macro, another_macro)]\n extern crate macros_for_good;\n ```\n@@ -1396,9 +1411,9 @@ Example of erroneous code:\n \n ```compile_fail,E0468\n mod foo {\n-    #[macro_use(helpful_macro)] // error: must be at crate root to import\n+    #[macro_use(debug_assert)]  // error: must be at crate root to import\n     extern crate core;          //        macros from another crate\n-    helpful_macro!(...);\n+    fn run_macro() { debug_assert!(true); }\n }\n ```\n \n@@ -1408,13 +1423,14 @@ macros.\n Either move the macro import to crate root or do without the foreign macros.\n This will work:\n \n-```ignore\n-#[macro_use(helpful_macro)]\n-extern crate some_crate;\n+```\n+#[macro_use(debug_assert)]\n+extern crate core;\n \n mod foo {\n-    helpful_macro!(...)\n+    fn run_macro() { debug_assert!(true); }\n }\n+# fn main() {}\n ```\n \"##,\n \n@@ -1442,7 +1458,7 @@ in question exports them.\n \n A working version would be:\n \n-```ignore\n+```ignore (cannot-doctest-multicrate-project)\n // In some_crate crate:\n #[macro_export]\n macro_rules! eat {\n@@ -1484,7 +1500,7 @@ in question exports them.\n \n A working version:\n \n-```ignore\n+```ignore (cannot-doctest-multicrate-project)\n // In some_crate crate:\n #[macro_export]\n macro_rules! eat {"}, {"sha": "df71fd4b19b6aba4683f3d18f04a3201e5d74359", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -16,7 +16,7 @@ E0511: r##\"\n Invalid monomorphization of an intrinsic function was used. Erroneous code\n example:\n \n-```ignore\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n #![feature(platform_intrinsics)]\n \n extern \"platform-intrinsic\" {"}, {"sha": "5b8170d7ddee4604e596814e9526fdfd140e3898", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 89, "deletions": 32, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -226,8 +226,10 @@ size of trait implementors isn't fixed, this type has no compile-time size.\n Therefore, all accesses to trait types must be through pointers. If you\n encounter this error you should try to avoid dereferencing the pointer.\n \n-```ignore\n-let trait_obj: &SomeTrait = ...;\n+```compile_fail,E0033\n+# trait SomeTrait { fn method_one(&self){} fn method_two(&self){} }\n+# impl<T> SomeTrait for T {}\n+let trait_obj: &SomeTrait = &\"some_value\";\n \n // This tries to implicitly dereference to create an unsized local variable.\n let &invalid = trait_obj;\n@@ -407,7 +409,11 @@ fn main() {\n \n Please note on the last example that we could have called `method` like this:\n \n-```ignore\n+```\n+# struct Test;\n+# impl Test { fn method<T>(&self, v: &[T]) -> usize { v.len() } }\n+# let x = Test;\n+# let v = &[0];\n x.method(v);\n ```\n \"##,\n@@ -684,9 +690,8 @@ External C functions are allowed to be variadic. However, a variadic function\n takes a minimum number of arguments. For example, consider C's variadic `printf`\n function:\n \n-```ignore\n-extern crate libc;\n-use libc::{ c_char, c_int };\n+```\n+use std::os::raw::{c_char, c_int};\n \n extern \"C\" {\n     fn printf(_: *const c_char, ...) -> c_int;\n@@ -696,16 +701,35 @@ extern \"C\" {\n Using this declaration, it must be called with at least one argument, so\n simply calling `printf()` is invalid. But the following uses are allowed:\n \n-```ignore\n+```\n+# #![feature(static_nobundle)]\n+# use std::os::raw::{c_char, c_int};\n+# #[cfg_attr(all(windows, target_env = \"msvc\"),\n+#            link(name = \"legacy_stdio_definitions\", kind = \"static-nobundle\"))]\n+# extern \"C\" { fn printf(_: *const c_char, ...) -> c_int; }\n+# fn main() {\n unsafe {\n     use std::ffi::CString;\n \n-    printf(CString::new(\"test\\n\").unwrap().as_ptr());\n-    printf(CString::new(\"number = %d\\n\").unwrap().as_ptr(), 3);\n-    printf(CString::new(\"%d, %d\\n\").unwrap().as_ptr(), 10, 5);\n+    let fmt = CString::new(\"test\\n\").unwrap();\n+    printf(fmt.as_ptr());\n+\n+    let fmt = CString::new(\"number = %d\\n\").unwrap();\n+    printf(fmt.as_ptr(), 3);\n+\n+    let fmt = CString::new(\"%d, %d\\n\").unwrap();\n+    printf(fmt.as_ptr(), 10, 5);\n }\n+# }\n ```\n \"##,\n+// ^ Note: On MSVC 2015, the `printf` function is \"inlined\" in the C code, and\n+// the C runtime does not contain the `printf` definition. This leads to linker\n+// error from the doc test (issue #42830).\n+// This can be fixed by linking to the static library\n+// `legacy_stdio_definitions.lib` (see https://stackoverflow.com/a/36504365/).\n+// If this compatibility library is removed in the future, consider changing\n+// `printf` in this example to another well-known variadic function.\n \n E0061: r##\"\n The number of arguments passed to a function must match the number of arguments\n@@ -924,13 +948,15 @@ fn main() {\n \"##,\n \n E0073: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n You cannot define a struct (or enum) `Foo` that requires an instance of `Foo`\n in order to make a new `Foo` value. This is because there would be no way a\n first instance of `Foo` could be made to initialize another instance!\n \n Here's an example of a struct that has this problem:\n \n-```ignore\n+```\n struct Foo { x: Box<Foo> } // error\n ```\n \n@@ -944,14 +970,16 @@ Now it's possible to create at least one instance of `Foo`: `Foo { x: None }`.\n \"##,\n \n E0074: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n When using the `#[simd]` attribute on a tuple struct, the components of the\n tuple struct must all be of a concrete, nongeneric type so the compiler can\n reason about how to use SIMD with them. This error will occur if the types\n are generic.\n \n This will cause an error:\n \n-```ignore\n+```\n #![feature(repr_simd)]\n \n #[repr(simd)]\n@@ -1078,13 +1106,16 @@ encountered, so a conflict occurs.\n \"##,\n \n E0082: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n When you specify enum discriminants with `=`, the compiler expects `isize`\n values by default. Or you can add the `repr` attibute to the enum declaration\n for an explicit choice of the discriminant type. In either cases, the\n discriminant values must fall within a valid range for the expected type;\n otherwise this error is raised. For example:\n \n-```ignore\n+```compile_fail\n+# #![deny(overflowing_literals)]\n #[repr(u8)]\n enum Thing {\n     A = 1024,\n@@ -1095,7 +1126,8 @@ enum Thing {\n Here, 1024 lies outside the valid range for `u8`, so the discriminant for `A` is\n invalid. Here is another, more subtle example which depends on target word size:\n \n-```ignore\n+```compile_fail,E0080\n+# #[repr(i32)]\n enum DependsOnPointerSize {\n     A = 1 << 32,\n }\n@@ -1448,11 +1480,12 @@ impl Drop for u32 {}\n To avoid this kind of error, ensure that at least one local type is referenced\n by the `impl`:\n \n-```ignore\n+```\n pub struct Foo; // you define your type in your crate\n \n impl Drop for Foo { // and you can implement the trait on it!\n     // code of trait implementation here\n+#   fn drop(&mut self) { }\n }\n \n impl From<Foo> for i32 { // or you use a type from your crate as\n@@ -1644,7 +1677,8 @@ It is not possible to declare type parameters on a function that has the `start`\n attribute. Such a function must have the following type signature (for more\n information: http://doc.rust-lang.org/stable/book/first-edition/no-stdlib.html):\n \n-```ignore\n+```\n+# let _:\n fn(isize, *const *const u8) -> isize;\n ```\n \n@@ -1812,10 +1846,12 @@ information see the [opt-in builtin traits RFC][RFC 19].\n \"##,\n \n E0193: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n `where` clauses must use generic type parameters: it does not make sense to use\n them otherwise. An example causing this error:\n \n-```ignore\n+```\n trait Foo {\n     fn bar(&self);\n }\n@@ -2265,17 +2301,20 @@ If `ForeignTrait` is a trait defined in some external crate `foo`, then the\n following trait `impl` is an error:\n \n ```compile_fail,E0210\n-extern crate alloc;\n-use alloc::range::RangeArgument;\n+# #[cfg(for_demonstration_only)]\n+extern crate foo;\n+# #[cfg(for_demonstration_only)]\n+use foo::ForeignTrait;\n+# use std::panic::UnwindSafe as ForeignTrait;\n \n-impl<T> RangeArgument<T> for T { } // error\n-\n-fn main() {}\n+impl<T> ForeignTrait for T { } // error\n+# fn main() {}\n ```\n \n To work around this, it can be covered with a local type, `MyType`:\n \n-```ignore\n+```\n+# use std::panic::UnwindSafe as ForeignTrait;\n struct MyType<T>(T);\n impl<T> ForeignTrait for MyType<T> { } // Ok\n ```\n@@ -2286,7 +2325,7 @@ For another example of an error, suppose there's another trait defined in `foo`\n named `ForeignTrait2` that takes two type parameters. Then this `impl` results\n in the same rule violation:\n \n-```compile_fail\n+```ignore (cannot-doctest-multicrate-project)\n struct MyType2;\n impl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n ```\n@@ -2297,7 +2336,7 @@ is uncovered, and so runs afoul of the orphan rule.\n \n Consider one more example:\n \n-```ignore\n+```ignore (cannot-doctest-multicrate-project)\n impl<T> ForeignTrait2<MyType<T>, T> for MyType2 { } // Ok\n ```\n \n@@ -2308,7 +2347,7 @@ violate the orphan rule; it is permitted.\n To see why that last example was allowed, you need to understand the general\n rule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:\n \n-```ignore\n+```ignore (only-for-syntax-highlight)\n impl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n ```\n \n@@ -2590,13 +2629,17 @@ fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}\n To solve this error, please move the type bindings in the type parameter\n declaration:\n \n-```ignore\n+```\n+# struct Bar;\n+# trait Foo { type A; }\n fn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!\n ```\n \n Or in the `where` clause:\n \n-```ignore\n+```\n+# struct Bar;\n+# trait Foo { type A; }\n fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n ```\n \"##,\n@@ -2935,12 +2978,19 @@ impl<T, U> CoerceUnsized<MyType<U>> for MyType<T>\n [`CoerceUnsized`]: https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html\n \"##,\n \n+/*\n+// Associated consts can now be accessed through generic type parameters, and\n+// this error is no longer emitted.\n+//\n+// FIXME: consider whether to leave it in the error index, or remove it entirely\n+//        as associated consts is not stabilized yet.\n+\n E0329: r##\"\n An attempt was made to access an associated constant through either a generic\n type parameter or `Self`. This is not supported yet. An example causing this\n error is shown below:\n \n-```ignore\n+```\n #![feature(associated_consts)]\n \n trait Foo {\n@@ -2961,7 +3011,7 @@ fn get_bar_bad<F: Foo>(t: F) -> f64 {\n Currently, the value of `BAR` for a particular type can only be accessed\n through a concrete type, as shown below:\n \n-```ignore\n+```\n #![feature(associated_consts)]\n \n trait Foo {\n@@ -2975,6 +3025,7 @@ fn get_bar_good() -> f64 {\n }\n ```\n \"##,\n+*/\n \n E0366: r##\"\n An attempt was made to implement `Drop` on a concrete specialization of a\n@@ -4349,14 +4400,20 @@ f.method; // error: attempted to take value of method `method` on type `Foo`\n \n If you want to use a method, add `()` after it:\n \n-```ignore\n+```\n+# struct Foo { x: u32 }\n+# impl Foo { fn method(&self) {} }\n+# let f = Foo { x: 0 };\n f.method();\n ```\n \n However, if you wanted to access a field of a struct check that the field name\n is spelled correctly. Example:\n \n-```ignore\n+```\n+# struct Foo { x: u32 }\n+# impl Foo { fn method(&self) {} }\n+# let f = Foo { x: 0 };\n println!(\"{}\", f.x);\n ```\n \"##,"}, {"sha": "bea13397eca4bc298d2d4e438cc8ee4255407cd2", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -15,7 +15,7 @@\n //! functionality through a unit-struct, `Markdown`, which has an implementation\n //! of `fmt::Display`. Example usage:\n //!\n-//! ```rust,ignore\n+//! ```\n //! use rustdoc::html::markdown::Markdown;\n //!\n //! let s = \"My *markdown* _text_\";"}, {"sha": "dae0b5f01238b0525408faa45c4f14edfba22919", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -36,7 +36,7 @@\n //! Arrays are enclosed in square brackets ([ ... ]) and objects in curly brackets ({ ... }).\n //! A simple JSON document encoding a person, their age, address and phone numbers could look like\n //!\n-//! ```ignore\n+//! ```json\n //! {\n //!     \"FirstName\": \"John\",\n //!     \"LastName\": \"Doe\","}, {"sha": "9a4c5ec8f6b2e311ebac1415ec1550e6b1583477", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -444,7 +444,7 @@ pub mod builtin {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n     /// let secret_key = include_str!(\"secret-key.ascii\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -461,7 +461,7 @@ pub mod builtin {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n     /// let secret_key = include_bytes!(\"secret-key.bin\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -530,13 +530,13 @@ pub mod builtin {\n     ///\n     /// File 'my_str.in':\n     ///\n-    /// ```ignore\n+    /// ```ignore (only-for-syntax-highlight)\n     /// \"Hello World!\"\n     /// ```\n     ///\n     /// File 'main.rs':\n     ///\n-    /// ```ignore\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n     /// fn main() {\n     ///     let my_str = include!(\"my_str.in\");\n     ///     println!(\"{}\", my_str);"}, {"sha": "98642f86f4dc22fc900d1addf902a4256880d7f0", "filename": "src/libstd/memchr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmemchr.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -24,7 +24,7 @@\n ///\n /// This shows how to find the first position of a byte in a byte string.\n ///\n-/// ```rust,ignore\n+/// ```ignore (cannot-doctest-private-modules)\n /// use memchr::memchr;\n ///\n /// let haystack = b\"the quick brown fox\";\n@@ -44,7 +44,7 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n ///\n /// This shows how to find the last position of a byte in a byte string.\n ///\n-/// ```rust,ignore\n+/// ```ignore (cannot-doctest-private-modules)\n /// use memchr::memrchr;\n ///\n /// let haystack = b\"the quick brown fox\";"}, {"sha": "49cdba21a1d37241831bc6b326b87aa9177d7012", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -22,13 +22,14 @@\n //!\n //! On a technical level, Rust inserts\n //!\n-//! ```ignore\n+//! ```\n //! extern crate std;\n //! ```\n //!\n //! into the crate root of every crate, and\n //!\n-//! ```ignore\n+//! ```\n+//! # #[allow(unused_imports)]\n //! use std::prelude::v1::*;\n //! ```\n //!"}, {"sha": "869299e21448ad38d01621e7fc6209ff83d77ee6", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -320,7 +320,7 @@ mod prim_pointer { }\n ///\n /// An array itself is not iterable:\n ///\n-/// ```ignore\n+/// ```compile_fail,E0277\n /// let array: [i32; 3] = [0; 3];\n ///\n /// for x in array { }\n@@ -480,8 +480,10 @@ mod prim_str { }\n /// Tuples are *heterogeneous*. This means that each element of the tuple can\n /// have a different type. In that tuple above, it has the type:\n ///\n-/// ```rust,ignore\n+/// ```\n+/// # let _:\n /// (&'static str, i32, char)\n+/// # = (\"hello\", 5, 'c');\n /// ```\n ///\n /// Tuples are a *sequence*. This means that they can be accessed by position;"}, {"sha": "df6a648b7b1626a4cf4ef157003d856ded40b9a4", "filename": "src/libstd/process.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -349,15 +349,19 @@ impl Command {\n     ///\n     /// Only one argument can be passed per use. So instead of:\n     ///\n-    /// ```ignore\n+    /// ```no_run\n+    /// # std::process::Command::new(\"sh\")\n     /// .arg(\"-C /path/to/repo\")\n+    /// # ;\n     /// ```\n     ///\n     /// usage would be:\n     ///\n-    /// ```ignore\n+    /// ```no_run\n+    /// # std::process::Command::new(\"sh\")\n     /// .arg(\"-C\")\n     /// .arg(\"/path/to/repo\")\n+    /// # ;\n     /// ```\n     ///\n     /// To pass multiple arguments see [`args`]."}, {"sha": "4437cf43920c53eac1b179a56874f8d592a941da", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Unix-specific extensions to primitives in the `std::fs` module.\n+//! Redox-specific extensions to primitives in the `std::fs` module.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -18,23 +18,25 @@ use path::Path;\n use sys;\n use sys_common::{FromInner, AsInner, AsInnerMut};\n \n-/// Unix-specific extensions to `Permissions`\n+/// Redox-specific extensions to `Permissions`\n #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n pub trait PermissionsExt {\n-    /// Returns the underlying raw `mode_t` bits that are the standard Unix\n+    /// Returns the underlying raw `mode_t` bits that are the standard Redox\n     /// permissions for this file.\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```no_run\n     /// use std::fs::File;\n-    /// use std::os::unix::fs::PermissionsExt;\n+    /// use std::os::redox::fs::PermissionsExt;\n     ///\n+    /// # fn run() -> std::io::Result<()> {\n     /// let f = File::create(\"foo.txt\")?;\n     /// let metadata = f.metadata()?;\n     /// let permissions = metadata.permissions();\n     ///\n     /// println!(\"permissions: {}\", permissions.mode());\n+    /// # Ok(()) }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&self) -> u32;\n@@ -43,28 +45,30 @@ pub trait PermissionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```no_run\n     /// use std::fs::File;\n-    /// use std::os::unix::fs::PermissionsExt;\n+    /// use std::os::redox::fs::PermissionsExt;\n     ///\n+    /// # fn run() -> std::io::Result<()> {\n     /// let f = File::create(\"foo.txt\")?;\n     /// let metadata = f.metadata()?;\n     /// let mut permissions = metadata.permissions();\n     ///\n     /// permissions.set_mode(0o644); // Read/write for owner and read for others.\n     /// assert_eq!(permissions.mode(), 0o644);\n+    /// # Ok(()) }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn set_mode(&mut self, mode: u32);\n \n-    /// Creates a new instance of `Permissions` from the given set of Unix\n+    /// Creates a new instance of `Permissions` from the given set of Redox\n     /// permission bits.\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```\n     /// use std::fs::Permissions;\n-    /// use std::os::unix::fs::PermissionsExt;\n+    /// use std::os::redox::fs::PermissionsExt;\n     ///\n     /// // Read/write for owner and read for others.\n     /// let permissions = Permissions::from_mode(0o644);\n@@ -89,7 +93,7 @@ impl PermissionsExt for Permissions {\n     }\n }\n \n-/// Unix-specific extensions to `OpenOptions`\n+/// Redox-specific extensions to `OpenOptions`\n #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n pub trait OpenOptionsExt {\n     /// Sets the mode bits that a new file will be created with.\n@@ -102,14 +106,17 @@ pub trait OpenOptionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```no_run\n+    /// # #![feature(libc)]\n     /// extern crate libc;\n     /// use std::fs::OpenOptions;\n-    /// use std::os::unix::fs::OpenOptionsExt;\n+    /// use std::os::redox::fs::OpenOptionsExt;\n     ///\n+    /// # fn main() {\n     /// let mut options = OpenOptions::new();\n     /// options.mode(0o644); // Give read/write for owner and read for others.\n     /// let file = options.open(\"foo.txt\");\n+    /// # }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&mut self, mode: u32) -> &mut Self;\n@@ -124,17 +131,20 @@ pub trait OpenOptionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```no_run\n+    /// # #![feature(libc)]\n     /// extern crate libc;\n     /// use std::fs::OpenOptions;\n-    /// use std::os::unix::fs::OpenOptionsExt;\n+    /// use std::os::redox::fs::OpenOptionsExt;\n     ///\n+    /// # fn main() {\n     /// let mut options = OpenOptions::new();\n     /// options.write(true);\n-    /// if cfg!(unix) {\n+    /// if cfg!(target_os = \"redox\") {\n     ///     options.custom_flags(libc::O_NOFOLLOW);\n     /// }\n     /// let file = options.open(\"foo.txt\");\n+    /// # }\n     /// ```\n     #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn custom_flags(&mut self, flags: i32) -> &mut Self;\n@@ -226,7 +236,7 @@ impl MetadataExt for fs::Metadata {\n     }\n }\n \n-/// Add special unix types (block/char device, fifo and socket)\n+/// Add special Redox types (block/char device, fifo and socket)\n #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n pub trait FileTypeExt {\n     /// Returns whether this file type is a block device.\n@@ -267,7 +277,7 @@ impl FileTypeExt for fs::FileType {\n /// # Examples\n ///\n /// ```\n-/// use std::os::unix::fs;\n+/// use std::os::redox::fs;\n ///\n /// # fn foo() -> std::io::Result<()> {\n /// fs::symlink(\"a.txt\", \"b.txt\")?;\n@@ -281,16 +291,16 @@ pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n }\n \n #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-/// An extension trait for `fs::DirBuilder` for unix-specific options.\n+/// An extension trait for `fs::DirBuilder` for Redox-specific options.\n pub trait DirBuilderExt {\n     /// Sets the mode to create new directories with. This option defaults to\n     /// 0o777.\n     ///\n     /// # Examples\n     ///\n-    /// ```ignore\n+    /// ```no_run\n     /// use std::fs::DirBuilder;\n-    /// use std::os::unix::fs::DirBuilderExt;\n+    /// use std::os::redox::fs::DirBuilderExt;\n     ///\n     /// let mut builder = DirBuilder::new();\n     /// builder.mode(0o755);"}, {"sha": "26710bf61d510cd8391e39f98ee6c2b875d9954f", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -73,15 +73,17 @@ pub trait PermissionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```no_run\n     /// use std::fs::File;\n     /// use std::os::unix::fs::PermissionsExt;\n     ///\n+    /// # fn run() -> std::io::Result<()> {\n     /// let f = File::create(\"foo.txt\")?;\n     /// let metadata = f.metadata()?;\n     /// let permissions = metadata.permissions();\n     ///\n     /// println!(\"permissions: {}\", permissions.mode());\n+    /// # Ok(()) }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&self) -> u32;\n@@ -90,16 +92,18 @@ pub trait PermissionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```no_run\n     /// use std::fs::File;\n     /// use std::os::unix::fs::PermissionsExt;\n     ///\n+    /// # fn run() -> std::io::Result<()> {\n     /// let f = File::create(\"foo.txt\")?;\n     /// let metadata = f.metadata()?;\n     /// let mut permissions = metadata.permissions();\n     ///\n     /// permissions.set_mode(0o644); // Read/write for owner and read for others.\n     /// assert_eq!(permissions.mode(), 0o644);\n+    /// # Ok(()) }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn set_mode(&mut self, mode: u32);\n@@ -109,7 +113,7 @@ pub trait PermissionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```\n     /// use std::fs::Permissions;\n     /// use std::os::unix::fs::PermissionsExt;\n     ///\n@@ -149,14 +153,17 @@ pub trait OpenOptionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```no_run\n+    /// # #![feature(libc)]\n     /// extern crate libc;\n     /// use std::fs::OpenOptions;\n     /// use std::os::unix::fs::OpenOptionsExt;\n     ///\n+    /// # fn main() {\n     /// let mut options = OpenOptions::new();\n     /// options.mode(0o644); // Give read/write for owner and read for others.\n     /// let file = options.open(\"foo.txt\");\n+    /// # }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&mut self, mode: u32) -> &mut Self;\n@@ -171,17 +178,20 @@ pub trait OpenOptionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```no_run\n+    /// # #![feature(libc)]\n     /// extern crate libc;\n     /// use std::fs::OpenOptions;\n     /// use std::os::unix::fs::OpenOptionsExt;\n     ///\n+    /// # fn main() {\n     /// let mut options = OpenOptions::new();\n     /// options.write(true);\n     /// if cfg!(unix) {\n     ///     options.custom_flags(libc::O_NOFOLLOW);\n     /// }\n     /// let file = options.open(\"foo.txt\");\n+    /// # }\n     /// ```\n     #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn custom_flags(&mut self, flags: i32) -> &mut Self;\n@@ -353,7 +363,7 @@ pub trait DirBuilderExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```ignore\n+    /// ```no_run\n     /// use std::fs::DirBuilder;\n     /// use std::os::unix::fs::DirBuilderExt;\n     ///"}, {"sha": "67348a00494174656a9fef8fdaca18f587febc6b", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -169,8 +169,10 @@ pub trait OpenOptionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```ignore\n+    /// ```no_run\n+    /// # #[cfg(for_demonstration_only)]\n     /// extern crate winapi;\n+    /// # mod winapi { pub const FILE_FLAG_DELETE_ON_CLOSE: u32 = 0x04000000; }\n     ///\n     /// use std::fs::OpenOptions;\n     /// use std::os::windows::prelude::*;\n@@ -204,8 +206,10 @@ pub trait OpenOptionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```ignore\n+    /// ```no_run\n+    /// # #[cfg(for_demonstration_only)]\n     /// extern crate winapi;\n+    /// # mod winapi { pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2; }\n     ///\n     /// use std::fs::OpenOptions;\n     /// use std::os::windows::prelude::*;"}, {"sha": "9ba023b57e6a3c9ece53f042790b7f082ffdb6b9", "filename": "src/libstd/sys_common/thread_local.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -33,7 +33,7 @@\n //! Using a dynamically allocated TLS key. Note that this key can be shared\n //! among many threads via an `Arc`.\n //!\n-//! ```rust,ignore\n+//! ```ignore (cannot-doctest-private-modules)\n //! let key = Key::new(None);\n //! assert!(key.get().is_null());\n //! key.set(1 as *mut u8);\n@@ -45,7 +45,7 @@\n //! Sometimes a statically allocated key is either required or easier to work\n //! with, however.\n //!\n-//! ```rust,ignore\n+//! ```ignore (cannot-doctest-private-modules)\n //! static KEY: StaticKey = INIT;\n //!\n //! unsafe {\n@@ -74,7 +74,7 @@ use sys_common::mutex::Mutex;\n ///\n /// # Examples\n ///\n-/// ```ignore\n+/// ```ignore (cannot-doctest-private-modules)\n /// use tls::os::{StaticKey, INIT};\n ///\n /// static KEY: StaticKey = INIT;\n@@ -105,7 +105,7 @@ pub struct StaticKey {\n ///\n /// # Examples\n ///\n-/// ```rust,ignore\n+/// ```ignore (cannot-doctest-private-modules)\n /// use tls::os::Key;\n ///\n /// let key = Key::new(None);"}, {"sha": "8bd58ec7a52d5eacc7fdb48db631a74ccfcb2a10", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -775,10 +775,10 @@ pub struct Local {\n ///\n /// E.g. `0...10 => { println!(\"match!\") }` as in\n ///\n-/// ```rust,ignore\n-/// match n {\n+/// ```\n+/// match 123 {\n ///     0...10 => { println!(\"match!\") },\n-///     // ..\n+///     _ => { println!(\"no match!\") },\n /// }\n /// ```\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -977,7 +977,7 @@ pub enum ExprKind {\n /// separately. `position` represents the index of the associated\n /// item qualified with this Self type.\n ///\n-/// ```rust,ignore\n+/// ```ignore (only-for-syntax-highlight)\n /// <Vec<T> as a::b::Trait>::AssociatedItem\n ///  ^~~~~     ~~~~~~~~~~~~~~^\n ///  ty        position = 3"}, {"sha": "508feca9731f2828e5dcdecb4bdd6a87b9c7c0ba", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -51,12 +51,14 @@ fn main() {}\n \n The parenthesized `inline` attribute requires the parameter to be specified:\n \n-```ignore\n+```\n #[inline(always)]\n fn something() {}\n+```\n \n-// or:\n+or:\n \n+```\n #[inline(never)]\n fn something() {}\n ```"}, {"sha": "851a638e14842af4fd55ce36444e968124805adc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -4436,7 +4436,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses an optional `where` clause and places it in `generics`.\n     ///\n-    /// ```ignore\n+    /// ```ignore (only-for-syntax-highlight)\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n     pub fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {"}, {"sha": "82b5d7e284bc671fa0cf3a01edce42214de208e2", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -11,7 +11,7 @@\n //! This pretty-printer is a direct reimplementation of Philip Karlton's\n //! Mesa pretty-printer, as described in appendix A of\n //!\n-//! ````ignore\n+//! ````text\n //! STAN-CS-79-770: \"Pretty Printing\", by Derek C. Oppen.\n //! Stanford Department of Computer Science, 1979.\n //! ````"}, {"sha": "33f742282c1726a95e12818a69d3000a6b989272", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -14,14 +14,15 @@\n //!\n //! For example, a type like:\n //!\n-//! ```ignore\n+//! ```\n //! #[derive(Encodable, Decodable)]\n //! struct Node { id: usize }\n //! ```\n //!\n //! would generate two implementations like:\n //!\n-//! ```ignore\n+//! ```\n+//! # struct Node { id: usize }\n //! impl<S: Encoder<E>, E> Encodable<S, E> for Node {\n //!     fn encode(&self, s: &mut S) -> Result<(), E> {\n //!         s.emit_struct(\"Node\", 1, |this| {\n@@ -48,14 +49,17 @@\n //! Other interesting scenarios are when the item has type parameters or\n //! references other non-built-in types.  A type definition like:\n //!\n-//! ```ignore\n+//! ```\n+//! # #[derive(Encodable, Decodable)] struct Span;\n //! #[derive(Encodable, Decodable)]\n //! struct Spanned<T> { node: T, span: Span }\n //! ```\n //!\n //! would yield functions like:\n //!\n-//! ```ignore\n+//! ```\n+//! # #[derive(Encodable, Decodable)] struct Span;\n+//! # struct Spanned<T> { node: T, span: Span }\n //! impl<\n //!     S: Encoder<E>,\n //!     E,"}, {"sha": "3a15b82d19f691de1e974a87f152c57700d21fbc", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -456,7 +456,7 @@ impl<'a> TraitDef<'a> {\n \n     /// Given that we are deriving a trait `DerivedTrait` for a type like:\n     ///\n-    /// ```ignore\n+    /// ```ignore (only-for-syntax-highlight)\n     /// struct Struct<'a, ..., 'z, A, B: DeclaredTrait, C, ..., Z> where C: WhereTrait {\n     ///     a: A,\n     ///     b: B::Item,\n@@ -469,7 +469,7 @@ impl<'a> TraitDef<'a> {\n     ///\n     /// create an impl like:\n     ///\n-    /// ```ignore\n+    /// ```ignore (only-for-syntax-highlight)\n     /// impl<'a, ..., 'z, A, B: DeclaredTrait, C, ...  Z> where\n     ///     C:                       WhereTrait,\n     ///     A: DerivedTrait + B1 + ... + BN,\n@@ -933,8 +933,9 @@ impl<'a> MethodDef<'a> {\n         }\n     }\n \n-    /// ```ignore\n+    /// ```\n     /// #[derive(PartialEq)]\n+    /// # struct Dummy;\n     /// struct A { x: i32, y: i32 }\n     ///\n     /// // equivalent to:\n@@ -1040,8 +1041,9 @@ impl<'a> MethodDef<'a> {\n                                       &StaticStruct(struct_def, summary))\n     }\n \n-    /// ```ignore\n+    /// ```\n     /// #[derive(PartialEq)]\n+    /// # struct Dummy;\n     /// enum A {\n     ///     A1,\n     ///     A2(i32)\n@@ -1624,7 +1626,7 @@ pub fn cs_fold<F>(use_foldl: bool,\n /// Call the method that is being derived on all the fields, and then\n /// process the collected results. i.e.\n ///\n-/// ```ignore\n+/// ```ignore (only-for-syntax-highlight)\n /// f(cx, span, vec![self_1.method(__arg_1_1, __arg_2_1),\n ///                  self_2.method(__arg_1_2, __arg_2_2)])\n /// ```"}, {"sha": "a6768c07fe13b543e9085dd1e08f56fcc35a8886", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -117,7 +117,8 @@ struct Context<'a, 'b: 'a> {\n /// expressions.\n ///\n /// If parsing succeeds, the return value is:\n-/// ```ignore\n+///\n+/// ```text\n /// Some((fmtstr, parsed arguments, index map for named arguments))\n /// ```\n fn parse_args(ecx: &mut ExtCtxt,"}, {"sha": "17fb59935dd16d78b9d609e8af2d3123be64bf09", "filename": "src/test/ui/explain.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Ftest%2Fui%2Fexplain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Ftest%2Fui%2Fexplain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexplain.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --explain E0591"}, {"sha": "0bbbd95320a8ca879b8e44f089fb04b422491308", "filename": "src/test/ui/explain.stdout", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Ftest%2Fui%2Fexplain.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Ftest%2Fui%2Fexplain.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexplain.stdout?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -0,0 +1,63 @@\n+Per [RFC 401][rfc401], if you have a function declaration `foo`:\n+\n+```\n+// For the purposes of this explanation, all of these\n+// different kinds of `fn` declarations are equivalent:\n+struct S;\n+fn foo(x: S) { /* ... */ }\n+extern \"C\" { fn foo(x: S); }\n+impl S { fn foo(self) { /* ... */ } }\n+```\n+\n+the type of `foo` is **not** `fn(S)`, as one might expect.\n+Rather, it is a unique, zero-sized marker type written here as `typeof(foo)`.\n+However, `typeof(foo)` can be _coerced_ to a function pointer `fn(S)`,\n+so you rarely notice this:\n+\n+```\n+let x: fn(S) = foo; // OK, coerces\n+```\n+\n+The reason that this matter is that the type `fn(S)` is not specific to\n+any particular function: it's a function _pointer_. So calling `x()` results\n+in a virtual call, whereas `foo()` is statically dispatched, because the type\n+of `foo` tells us precisely what function is being called.\n+\n+As noted above, coercions mean that most code doesn't have to be\n+concerned with this distinction. However, you can tell the difference\n+when using **transmute** to convert a fn item into a fn pointer.\n+\n+This is sometimes done as part of an FFI:\n+\n+```\n+extern \"C\" fn foo(userdata: Box<i32>) {\n+    /* ... */\n+}\n+\n+let f: extern \"C\" fn(*mut i32) = transmute(foo);\n+callback(f);\n+```\n+\n+Here, transmute is being used to convert the types of the fn arguments.\n+This pattern is incorrect because, because the type of `foo` is a function\n+**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n+is a function pointer, which is not zero-sized.\n+This pattern should be rewritten. There are a few possible ways to do this:\n+\n+- change the original fn declaration to match the expected signature,\n+  and do the cast in the fn body (the prefered option)\n+- cast the fn item fo a fn pointer before calling transmute, as shown here:\n+\n+    ```\n+    let f: extern \"C\" fn(*mut i32) = transmute(foo as extern \"C\" fn(_));\n+    let f: extern \"C\" fn(*mut i32) = transmute(foo as usize); // works too\n+    ```\n+\n+The same applies to transmutes to `*mut fn()`, which were observedin practice.\n+Note though that use of this type is generally incorrect.\n+The intention is typically to describe a function pointer, but just `fn()`\n+alone suffices for that. `*mut fn()` is a pointer to a fn pointer.\n+(Since these values are typically just passed to C code, however, this rarely\n+makes a difference in practice.)\n+\n+[rfc401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md"}, {"sha": "b42beb37821cef09e09f52073161ad62b2cd0eda", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/377ff895a5cc965608712294ad99a12c89ed7382/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377ff895a5cc965608712294ad99a12c89ed7382/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=377ff895a5cc965608712294ad99a12c89ed7382", "patch": "@@ -18,6 +18,7 @@\n //! * No CR characters\n //! * No `TODO` or `XXX` directives\n //! * A valid license header is at the top\n+//! * No unexplained ` ```ignore ` or ` ```rust,ignore ` doc tests\n //!\n //! A number of these checks can be opted-out of with various directives like\n //! `// ignore-tidy-linelength`.\n@@ -38,6 +39,17 @@ http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n option. This file may not be copied, modified, or distributed\n except according to those terms.\";\n \n+const UNEXPLAINED_IGNORE_DOCTEST_INFO: &str = r#\"unexplained \"```ignore\" doctest; try one:\n+\n+* make the test actually pass, by adding necessary imports and declarations, or\n+* use \"```text\", if the code is not Rust code, or\n+* use \"```compile_fail,Ennnn\", if the code is expected to fail at compile time, or\n+* use \"```should_panic\", if the code is expected to fail at run time, or\n+* use \"```no_run\", if the code should type-check but not necessary linkable/runnable, or\n+* explain it like \"```ignore (cannot-test-this-because-xxxx)\", if the annotation cannot be avoided.\n+\n+\"#;\n+\n /// Parser states for line_is_url.\n #[derive(PartialEq)]\n #[allow(non_camel_case_types)]\n@@ -138,6 +150,9 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     err(\"XXX is deprecated; use FIXME\")\n                 }\n             }\n+            if line.ends_with(\"```ignore\") || line.ends_with(\"```rust,ignore\") {\n+                err(UNEXPLAINED_IGNORE_DOCTEST_INFO);\n+            }\n         }\n         if !licenseck(file, &contents) {\n             tidy_error!(bad, \"{}: incorrect license\", file.display());"}]}