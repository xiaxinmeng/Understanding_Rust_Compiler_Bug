{"sha": "ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNTYxMGZmOGM0MWViMDY2NGRhYjg2OGRjOTE4NmEyMWUyZjEzYjA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-16T17:46:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-16T17:46:31Z"}, "message": "Rollup merge of #72047 - Julian-Wollersberger:literal_error_reporting_cleanup, r=petrochenkov\n\nLiteral error reporting cleanup\n\nWhile doing some performance work, I noticed some code duplication in `librustc_parser/lexer/mod.rs`, so I cleaned it up.\n\nThis PR is probably best reviewed commit by commit.\n\nI'm not sure what the API stability practices for `librustc_lexer` are. Four public methods in `unescape.rs` can be removed, but two are used by clippy, so I left them in for now.\nI could open a PR for Rust-Analyzer when this one lands.\n\nBut how do I open a PR for clippy? (Git submodules are frustrating to work with)", "tree": {"sha": "377694a4c142aa33146dda238cb9e7c75044e856", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/377694a4c142aa33146dda238cb9e7c75044e856"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJewCb4CRBK7hj4Ov3rIwAAdHIIAAVUJk+5Q4vf2CZ0zZnJf3mX\n1jFOrGH5G5DzCqhU3SlOj8qV9u2X3a6QpX7B4VuyyGy8IL5pZSeq3Eol9Ufjarnx\nkHd20QEQRHVI35+L5L+9aYOQzj//J4zODO1OOjrj1/XVh3oWJ46Ra/hcdUgpOo3n\nyhWV8tQGjvpV7V99JMVsqy5Wl6s1ryd06osoZo00fy+G8rjyyGPVMsSr2fI6JjxA\nxaoEo47C+YXZVI1dCV4Gvs9aawic66M8bDuIVlmt3AcI/z4uQL8GHKx5vsgq9Ylx\nz7xTuZU4LmO+zpQmxsD8yShm+vZj4M9eeTCkqcRRj4cx8wrgB9GTl2kEYgEdsCM=\n=aV4g\n-----END PGP SIGNATURE-----\n", "payload": "tree 377694a4c142aa33146dda238cb9e7c75044e856\nparent aecab5e603ad0a904f2f357470b419b2ac6014d8\nparent 43ae7854543ea98516c3946e5f14ff3bb0f18bfd\nauthor Ralf Jung <post@ralfj.de> 1589651191 +0200\ncommitter GitHub <noreply@github.com> 1589651191 +0200\n\nRollup merge of #72047 - Julian-Wollersberger:literal_error_reporting_cleanup, r=petrochenkov\n\nLiteral error reporting cleanup\n\nWhile doing some performance work, I noticed some code duplication in `librustc_parser/lexer/mod.rs`, so I cleaned it up.\n\nThis PR is probably best reviewed commit by commit.\n\nI'm not sure what the API stability practices for `librustc_lexer` are. Four public methods in `unescape.rs` can be removed, but two are used by clippy, so I left them in for now.\nI could open a PR for Rust-Analyzer when this one lands.\n\nBut how do I open a PR for clippy? (Git submodules are frustrating to work with)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "html_url": "https://github.com/rust-lang/rust/commit/ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aecab5e603ad0a904f2f357470b419b2ac6014d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aecab5e603ad0a904f2f357470b419b2ac6014d8", "html_url": "https://github.com/rust-lang/rust/commit/aecab5e603ad0a904f2f357470b419b2ac6014d8"}, {"sha": "43ae7854543ea98516c3946e5f14ff3bb0f18bfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/43ae7854543ea98516c3946e5f14ff3bb0f18bfd", "html_url": "https://github.com/rust-lang/rust/commit/43ae7854543ea98516c3946e5f14ff3bb0f18bfd"}], "stats": {"total": 346, "additions": 132, "deletions": 214}, "files": [{"sha": "4428d09902b92d6b8a3360e130737b33eb66b32d", "filename": "src/librustc_ast/util/literal.rs", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fliteral.rs?ref=ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "patch": "@@ -6,8 +6,7 @@ use crate::tokenstream::TokenTree;\n \n use rustc_data_structures::sync::Lrc;\n use rustc_lexer::unescape::{unescape_byte, unescape_char};\n-use rustc_lexer::unescape::{unescape_byte_str, unescape_str};\n-use rustc_lexer::unescape::{unescape_raw_byte_str, unescape_raw_str};\n+use rustc_lexer::unescape::{unescape_byte_literal, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n@@ -59,45 +58,53 @@ impl LitKind {\n                 // new symbol because the string in the LitKind is different to the\n                 // string in the token.\n                 let s = symbol.as_str();\n-                let symbol = if s.contains(&['\\\\', '\\r'][..]) {\n-                    let mut buf = String::with_capacity(s.len());\n-                    let mut error = Ok(());\n-                    unescape_str(&s, &mut |_, unescaped_char| match unescaped_char {\n-                        Ok(c) => buf.push(c),\n-                        Err(_) => error = Err(LitError::LexerError),\n-                    });\n-                    error?;\n-                    Symbol::intern(&buf)\n-                } else {\n-                    symbol\n-                };\n+                let symbol =\n+                    if s.contains(&['\\\\', '\\r'][..]) {\n+                        let mut buf = String::with_capacity(s.len());\n+                        let mut error = Ok(());\n+                        unescape_literal(&s, Mode::Str, &mut |_, unescaped_char| {\n+                            match unescaped_char {\n+                                Ok(c) => buf.push(c),\n+                                Err(_) => error = Err(LitError::LexerError),\n+                            }\n+                        });\n+                        error?;\n+                        Symbol::intern(&buf)\n+                    } else {\n+                        symbol\n+                    };\n                 LitKind::Str(symbol, ast::StrStyle::Cooked)\n             }\n             token::StrRaw(n) => {\n                 // Ditto.\n                 let s = symbol.as_str();\n-                let symbol = if s.contains('\\r') {\n-                    let mut buf = String::with_capacity(s.len());\n-                    let mut error = Ok(());\n-                    unescape_raw_str(&s, &mut |_, unescaped_char| match unescaped_char {\n-                        Ok(c) => buf.push(c),\n-                        Err(_) => error = Err(LitError::LexerError),\n-                    });\n-                    error?;\n-                    buf.shrink_to_fit();\n-                    Symbol::intern(&buf)\n-                } else {\n-                    symbol\n-                };\n+                let symbol =\n+                    if s.contains('\\r') {\n+                        let mut buf = String::with_capacity(s.len());\n+                        let mut error = Ok(());\n+                        unescape_literal(&s, Mode::RawStr, &mut |_, unescaped_char| {\n+                            match unescaped_char {\n+                                Ok(c) => buf.push(c),\n+                                Err(_) => error = Err(LitError::LexerError),\n+                            }\n+                        });\n+                        error?;\n+                        buf.shrink_to_fit();\n+                        Symbol::intern(&buf)\n+                    } else {\n+                        symbol\n+                    };\n                 LitKind::Str(symbol, ast::StrStyle::Raw(n))\n             }\n             token::ByteStr => {\n                 let s = symbol.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n                 let mut error = Ok(());\n-                unescape_byte_str(&s, &mut |_, unescaped_byte| match unescaped_byte {\n-                    Ok(c) => buf.push(c),\n-                    Err(_) => error = Err(LitError::LexerError),\n+                unescape_byte_literal(&s, Mode::ByteStr, &mut |_, unescaped_byte| {\n+                    match unescaped_byte {\n+                        Ok(c) => buf.push(c),\n+                        Err(_) => error = Err(LitError::LexerError),\n+                    }\n                 });\n                 error?;\n                 buf.shrink_to_fit();\n@@ -108,9 +115,11 @@ impl LitKind {\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n                     let mut error = Ok(());\n-                    unescape_raw_byte_str(&s, &mut |_, unescaped_byte| match unescaped_byte {\n-                        Ok(c) => buf.push(c),\n-                        Err(_) => error = Err(LitError::LexerError),\n+                    unescape_byte_literal(&s, Mode::RawByteStr, &mut |_, unescaped_byte| {\n+                        match unescaped_byte {\n+                            Ok(c) => buf.push(c),\n+                            Err(_) => error = Err(LitError::LexerError),\n+                        }\n                     });\n                     error?;\n                     buf.shrink_to_fit();"}, {"sha": "e44feee96607a7d4d0eaf669945bf8fa1c29b5d0", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "patch": "@@ -1,5 +1,11 @@\n //! Low-level Rust lexer.\n //!\n+//! The idea with `librustc_lexer` is to make a reusable library,\n+//! by separating out pure lexing and rustc-specific concerns, like spans,\n+//! error reporting an interning.  So, rustc_lexer operates directly on `&str`,\n+//! produces simple tokens which are a pair of type-tag and a bit of original text,\n+//! and does not report errors, instead storing them as flags on the token.\n+//!\n //! Tokens produced by this lexer are not yet ready for parsing the Rust syntax,\n //! for that see `librustc_parse::lexer`, which converts this basic token stream\n //! into wide tokens used by actual parser.\n@@ -719,6 +725,9 @@ impl Cursor<'_> {\n \n             // Check that amount of closing '#' symbols\n             // is equal to the amount of opening ones.\n+            // Note that this will not consume extra trailing `#` characters:\n+            // `r###\"abcde\"####` is lexed as a `LexedRawString { n_hashes: 3 }`\n+            // followed by a `#` token.\n             let mut hashes_left = n_start_hashes;\n             let is_closing_hash = |c| {\n                 if c == '#' && hashes_left != 0 {\n@@ -739,8 +748,8 @@ impl Cursor<'_> {\n                     possible_terminator_offset: None,\n                 };\n             } else if n_end_hashes > max_hashes {\n-                // Keep track of possible terminators to give a hint about where there might be\n-                // a missing terminator\n+                // Keep track of possible terminators to give a hint about\n+                // where there might be a missing terminator\n                 possible_terminator_offset =\n                     Some(self.len_consumed() - start_pos - n_end_hashes + prefix_len);\n                 max_hashes = n_end_hashes;"}, {"sha": "2a9e1b7cbc3460a440b35fc9da3785ab80fac262", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 41, "deletions": 51, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "patch": "@@ -58,69 +58,57 @@ pub enum EscapeError {\n     NonAsciiCharInByteString,\n }\n \n-/// Takes a contents of a char literal (without quotes), and returns an\n-/// unescaped char or an error\n-pub fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n-}\n-\n-/// Takes a contents of a byte literal (without quotes), and returns an\n-/// unescaped byte or an error.\n-pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Byte)\n-        .map(byte_from_char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n-}\n-\n-/// Takes a contents of a string literal (without quotes) and produces a\n+/// Takes a contents of a literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n /// Values are returned through invoking of the provided callback.\n-pub fn unescape_str<F>(literal_text: &str, callback: &mut F)\n+pub fn unescape_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    unescape_str_or_byte_str(literal_text, Mode::Str, callback)\n+    match mode {\n+        Mode::Char | Mode::Byte => {\n+            let mut chars = literal_text.chars();\n+            let result = unescape_char_or_byte(&mut chars, mode);\n+            // The Chars iterator moved forward.\n+            callback(0..(literal_text.len() - chars.as_str().len()), result);\n+        }\n+        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(literal_text, mode, callback),\n+        // NOTE: Raw strings do not perform any explicit character escaping, here we\n+        // only translate CRLF to LF and produce errors on bare CR.\n+        Mode::RawStr | Mode::RawByteStr => {\n+            unescape_raw_str_or_byte_str(literal_text, mode, callback)\n+        }\n+    }\n }\n \n-/// Takes a contents of a byte string literal (without quotes) and produces a\n-/// sequence of bytes or errors.\n+/// Takes a contents of a byte, byte string or raw byte string (without quotes)\n+/// and produces a sequence of bytes or errors.\n /// Values are returned through invoking of the provided callback.\n-pub fn unescape_byte_str<F>(literal_text: &str, callback: &mut F)\n+pub fn unescape_byte_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<u8, EscapeError>),\n {\n-    unescape_str_or_byte_str(literal_text, Mode::ByteStr, &mut |range, char| {\n-        callback(range, char.map(byte_from_char))\n+    assert!(mode.is_bytes());\n+    unescape_literal(literal_text, mode, &mut |range, result| {\n+        callback(range, result.map(byte_from_char));\n     })\n }\n \n-/// Takes a contents of a raw string literal (without quotes) and produces a\n-/// sequence of characters or errors.\n-/// Values are returned through invoking of the provided callback.\n-/// NOTE: Raw strings do not perform any explicit character escaping, here we\n-/// only translate CRLF to LF and produce errors on bare CR.\n-pub fn unescape_raw_str<F>(literal_text: &str, callback: &mut F)\n-where\n-    F: FnMut(Range<usize>, Result<char, EscapeError>),\n-{\n-    unescape_raw_str_or_byte_str(literal_text, Mode::Str, callback)\n+/// Takes a contents of a char literal (without quotes), and returns an\n+/// unescaped char or an error\n+pub fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n+    let mut chars = literal_text.chars();\n+    unescape_char_or_byte(&mut chars, Mode::Char)\n+        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n }\n \n-/// Takes a contents of a raw byte string literal (without quotes) and produces a\n-/// sequence of bytes or errors.\n-/// Values are returned through invoking of the provided callback.\n-/// NOTE: Raw strings do not perform any explicit character escaping, here we\n-/// only translate CRLF to LF and produce errors on bare CR.\n-pub fn unescape_raw_byte_str<F>(literal_text: &str, callback: &mut F)\n-where\n-    F: FnMut(Range<usize>, Result<u8, EscapeError>),\n-{\n-    unescape_raw_str_or_byte_str(literal_text, Mode::ByteStr, &mut |range, char| {\n-        callback(range, char.map(byte_from_char))\n-    })\n+/// Takes a contents of a byte literal (without quotes), and returns an\n+/// unescaped byte or an error.\n+pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n+    let mut chars = literal_text.chars();\n+    unescape_char_or_byte(&mut chars, Mode::Byte)\n+        .map(byte_from_char)\n+        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n }\n \n /// What kind of literal do we parse.\n@@ -130,13 +118,15 @@ pub enum Mode {\n     Str,\n     Byte,\n     ByteStr,\n+    RawStr,\n+    RawByteStr,\n }\n \n impl Mode {\n     pub fn in_single_quotes(self) -> bool {\n         match self {\n             Mode::Char | Mode::Byte => true,\n-            Mode::Str | Mode::ByteStr => false,\n+            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => false,\n         }\n     }\n \n@@ -146,8 +136,8 @@ impl Mode {\n \n     pub fn is_bytes(self) -> bool {\n         match self {\n-            Mode::Byte | Mode::ByteStr => true,\n-            Mode::Char | Mode::Str => false,\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n+            Mode::Char | Mode::Str | Mode::RawStr => false,\n         }\n     }\n }\n@@ -345,7 +335,7 @@ where\n \n fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n-    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::Byte(Str)\");\n+    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::ByteStr\");\n     res as u8\n }\n "}, {"sha": "f2b751a78f27fbd11a2a16987e54b7ddabf7253c", "filename": "src/librustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "patch": "@@ -102,7 +102,7 @@ fn test_unescape_char_good() {\n fn test_unescape_str_good() {\n     fn check(literal_text: &str, expected: &str) {\n         let mut buf = Ok(String::with_capacity(literal_text.len()));\n-        unescape_str(literal_text, &mut |range, c| {\n+        unescape_literal(literal_text, Mode::Str, &mut |range, c| {\n             if let Ok(b) = &mut buf {\n                 match c {\n                     Ok(c) => b.push(c),\n@@ -222,7 +222,7 @@ fn test_unescape_byte_good() {\n fn test_unescape_byte_str_good() {\n     fn check(literal_text: &str, expected: &[u8]) {\n         let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n-        unescape_byte_str(literal_text, &mut |range, c| {\n+        unescape_byte_literal(literal_text, Mode::ByteStr, &mut |range, c| {\n             if let Ok(b) = &mut buf {\n                 match c {\n                     Ok(c) => b.push(c),\n@@ -246,7 +246,7 @@ fn test_unescape_byte_str_good() {\n fn test_unescape_raw_str() {\n     fn check(literal: &str, expected: &[(Range<usize>, Result<char, EscapeError>)]) {\n         let mut unescaped = Vec::with_capacity(literal.len());\n-        unescape_raw_str(literal, &mut |range, res| unescaped.push((range, res)));\n+        unescape_literal(literal, Mode::RawStr, &mut |range, res| unescaped.push((range, res)));\n         assert_eq!(unescaped, expected);\n     }\n \n@@ -258,7 +258,9 @@ fn test_unescape_raw_str() {\n fn test_unescape_raw_byte_str() {\n     fn check(literal: &str, expected: &[(Range<usize>, Result<u8, EscapeError>)]) {\n         let mut unescaped = Vec::with_capacity(literal.len());\n-        unescape_raw_byte_str(literal, &mut |range, res| unescaped.push((range, res)));\n+        unescape_byte_literal(literal, Mode::RawByteStr, &mut |range, res| {\n+            unescaped.push((range, res))\n+        });\n         assert_eq!(unescaped, expected);\n     }\n "}, {"sha": "2b7d5e5adb432924f25bea312e0292f573dbf4b3", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 30, "deletions": 122, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "patch": "@@ -15,6 +15,7 @@ mod tokentrees;\n mod unescape_error_reporting;\n mod unicode_chars;\n \n+use rustc_lexer::unescape::Mode;\n use unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n #[derive(Clone, Debug)]\n@@ -325,38 +326,27 @@ impl<'a> StringReader<'a> {\n         suffix_start: BytePos,\n         kind: rustc_lexer::LiteralKind,\n     ) -> (token::LitKind, Symbol) {\n-        match kind {\n+        // prefix means `\"` or `br\"` or `r###\"`, ...\n+        let (lit_kind, mode, prefix_len, postfix_len) = match kind {\n             rustc_lexer::LiteralKind::Char { terminated } => {\n                 if !terminated {\n                     self.fatal_span_(start, suffix_start, \"unterminated character literal\").raise()\n                 }\n-                let content_start = start + BytePos(1);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_char_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::Char, id)\n+                (token::Char, Mode::Char, 1, 1) // ' '\n             }\n             rustc_lexer::LiteralKind::Byte { terminated } => {\n                 if !terminated {\n                     self.fatal_span_(start + BytePos(1), suffix_start, \"unterminated byte constant\")\n                         .raise()\n                 }\n-                let content_start = start + BytePos(2);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_byte_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::Byte, id)\n+                (token::Byte, Mode::Byte, 2, 1) // b' '\n             }\n             rustc_lexer::LiteralKind::Str { terminated } => {\n                 if !terminated {\n                     self.fatal_span_(start, suffix_start, \"unterminated double quote string\")\n                         .raise()\n                 }\n-                let content_start = start + BytePos(1);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::Str, id)\n+                (token::Str, Mode::Str, 1, 1) // \" \"\n             }\n             rustc_lexer::LiteralKind::ByteStr { terminated } => {\n                 if !terminated {\n@@ -367,42 +357,28 @@ impl<'a> StringReader<'a> {\n                     )\n                     .raise()\n                 }\n-                let content_start = start + BytePos(2);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_byte_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::ByteStr, id)\n+                (token::ByteStr, Mode::ByteStr, 2, 1) // b\" \"\n             }\n             rustc_lexer::LiteralKind::RawStr(unvalidated_raw_str) => {\n                 let valid_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n                 let n_hashes = valid_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n-\n-                let content_start = start + BytePos(2 + n);\n-                let content_end = suffix_start - BytePos(1 + n);\n-                self.validate_raw_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::StrRaw(n_hashes), id)\n+                (token::StrRaw(n_hashes), Mode::RawStr, 2 + n, 1 + n) // r##\" \"##\n             }\n             rustc_lexer::LiteralKind::RawByteStr(unvalidated_raw_str) => {\n                 let validated_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n                 let n_hashes = validated_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n-\n-                let content_start = start + BytePos(3 + n);\n-                let content_end = suffix_start - BytePos(1 + n);\n-                self.validate_raw_byte_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::ByteStrRaw(n_hashes), id)\n+                (token::ByteStrRaw(n_hashes), Mode::RawByteStr, 3 + n, 1 + n) // br##\" \"##\n             }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n-                if empty_int {\n+                return if empty_int {\n                     self.err_span_(start, suffix_start, \"no valid digits found for number\");\n                     (token::Integer, sym::integer(0))\n                 } else {\n                     self.validate_int_literal(base, start, suffix_start);\n                     (token::Integer, self.symbol_from_to(start, suffix_start))\n-                }\n+                };\n             }\n             rustc_lexer::LiteralKind::Float { base, empty_exponent } => {\n                 if empty_exponent {\n@@ -430,9 +406,14 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 let id = self.symbol_from_to(start, suffix_start);\n-                (token::Float, id)\n+                return (token::Float, id);\n             }\n-        }\n+        };\n+        let content_start = start + BytePos(prefix_len);\n+        let content_end = suffix_start - BytePos(postfix_len);\n+        let id = self.symbol_from_to(content_start, content_end);\n+        self.validate_literal_escape(mode, content_start, content_end);\n+        return (lit_kind, id);\n     }\n \n     pub fn pos(&self) -> BytePos {\n@@ -558,96 +539,23 @@ impl<'a> StringReader<'a> {\n         .raise();\n     }\n \n-    fn validate_char_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        if let Err((off, err)) = unescape::unescape_char(lit) {\n-            emit_unescape_error(\n-                &self.sess.span_diagnostic,\n-                lit,\n-                self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                unescape::Mode::Char,\n-                0..off,\n-                err,\n-            )\n-        }\n-    }\n-\n-    fn validate_byte_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        if let Err((off, err)) = unescape::unescape_byte(lit) {\n-            emit_unescape_error(\n-                &self.sess.span_diagnostic,\n-                lit,\n-                self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                unescape::Mode::Byte,\n-                0..off,\n-                err,\n-            )\n-        }\n-    }\n-\n-    fn validate_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n+    fn validate_literal_escape(&self, mode: Mode, content_start: BytePos, content_end: BytePos) {\n+        let lit_content = self.str_from_to(content_start, content_end);\n+        unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n+            // Here we only check for errors. The actual unescaping is done later.\n+            if let Err(err) = result {\n+                let span_with_quotes =\n+                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1));\n                 emit_unescape_error(\n                     &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::Str,\n+                    lit_content,\n+                    span_with_quotes,\n+                    mode,\n                     range,\n                     err,\n-                )\n-            }\n-        })\n-    }\n-\n-    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_raw_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n-                emit_unescape_error(\n-                    &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::Str,\n-                    range,\n-                    err,\n-                )\n-            }\n-        })\n-    }\n-\n-    fn validate_raw_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n-                emit_unescape_error(\n-                    &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::ByteStr,\n-                    range,\n-                    err,\n-                )\n-            }\n-        })\n-    }\n-\n-    fn validate_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_byte_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n-                emit_unescape_error(\n-                    &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::ByteStr,\n-                    range,\n-                    err,\n-                )\n+                );\n             }\n-        })\n+        });\n     }\n \n     fn validate_int_literal(&self, base: Base, content_start: BytePos, content_end: BytePos) {"}, {"sha": "26bf463bd2922eefd941e9bedd4d106eb6f9a011", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5610ff8c41eb0664dab868dc9186a21e2f13b0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "patch": "@@ -483,8 +483,8 @@ fn check_newlines(fmtstr: &StrLit) -> bool {\n     };\n \n     match fmtstr.style {\n-        StrStyle::Cooked => unescape::unescape_str(contents, &mut cb),\n-        StrStyle::Raw(_) => unescape::unescape_raw_str(contents, &mut cb),\n+        StrStyle::Cooked => unescape::unescape_literal(contents, unescape::Mode::Str, &mut cb),\n+        StrStyle::Raw(_) => unescape::unescape_literal(contents, unescape::Mode::RawStr, &mut cb),\n     }\n \n     should_lint"}]}