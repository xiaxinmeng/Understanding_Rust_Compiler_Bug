{"sha": "b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YTNmZTI1YzZmYTM1ZDViMjQzZDZkZmFlZTU5MzA2YzRiY2ZkYTk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-05-28T22:31:32Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-05-28T22:31:32Z"}, "message": "librustc: drop AST before running LLVM, frees 400mb on a librustc build", "tree": {"sha": "08b4d5937efeb3244956005b6c46361963ca72c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08b4d5937efeb3244956005b6c46361963ca72c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9", "html_url": "https://github.com/rust-lang/rust/commit/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6264df5331fef467b8ca8d0800358e1ae94a0dbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6264df5331fef467b8ca8d0800358e1ae94a0dbf", "html_url": "https://github.com/rust-lang/rust/commit/6264df5331fef467b8ca8d0800358e1ae94a0dbf"}], "stats": {"total": 116, "additions": 60, "deletions": 56}, "files": [{"sha": "da94883d4073991f99873e4312ed029b0bebb97e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9", "patch": "@@ -172,73 +172,75 @@ pub enum compile_upto {\n \n // For continuing compilation after a parsed crate has been\n // modified\n+\n+\n #[fixed_stack_segment]\n pub fn compile_rest(sess: Session,\n                     cfg: ast::crate_cfg,\n                     upto: compile_upto,\n                     outputs: Option<@OutputFilenames>,\n                     curr: Option<@ast::crate>)\n-                 -> (@ast::crate, Option<ty::ctxt>) {\n+    -> (Option<@ast::crate>, Option<ty::ctxt>) {\n+\n     let time_passes = sess.time_passes();\n-    let mut crate = curr.get();\n \n-    *sess.building_library = session::building_library(\n-        sess.opts.crate_type, crate, sess.opts.test);\n+    let (llmod, link_meta) = {\n \n-    crate = time(time_passes, ~\"expansion\", ||\n-        syntax::ext::expand::expand_crate(sess.parse_sess, copy cfg,\n-                                          crate));\n+        let mut crate = curr.unwrap();\n \n-    crate = time(time_passes, ~\"configuration\", ||\n-        front::config::strip_unconfigured_items(crate));\n+        *sess.building_library = session::building_library(\n+            sess.opts.crate_type, crate, sess.opts.test);\n \n-    crate = time(time_passes, ~\"maybe building test harness\", ||\n-        front::test::modify_for_testing(sess, crate));\n+        crate = time(time_passes, ~\"expansion\", ||\n+                     syntax::ext::expand::expand_crate(sess.parse_sess, copy cfg,\n+                                                       crate));\n \n-    if upto == cu_expand { return (crate, None); }\n+        crate = time(time_passes, ~\"configuration\", ||\n+                     front::config::strip_unconfigured_items(crate));\n \n-    crate = time(time_passes, ~\"intrinsic injection\", ||\n-        front::intrinsic_inject::inject_intrinsic(sess, crate));\n+        crate = time(time_passes, ~\"maybe building test harness\", ||\n+                     front::test::modify_for_testing(sess, crate));\n \n-    crate = time(time_passes, ~\"extra injection\", ||\n-        front::std_inject::maybe_inject_libstd_ref(sess, crate));\n+        if upto == cu_expand { return (Some(crate), None); }\n \n-    let ast_map = time(time_passes, ~\"ast indexing\", ||\n-            syntax::ast_map::map_crate(sess.diagnostic(), crate));\n+        crate = time(time_passes, ~\"intrinsic injection\", ||\n+                     front::intrinsic_inject::inject_intrinsic(sess, crate));\n \n-    time(time_passes, ~\"external crate/lib resolution\", ||\n-        creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n-                             sess.filesearch,\n-                             session::sess_os_to_meta_os(sess.targ_cfg.os),\n-                             sess.opts.is_static,\n-                             sess.parse_sess.interner));\n+        crate = time(time_passes, ~\"extra injection\", ||\n+                     front::std_inject::maybe_inject_libstd_ref(sess, crate));\n \n-    let lang_items = time(time_passes, ~\"language item collection\", ||\n-         middle::lang_items::collect_language_items(crate, sess));\n+        let ast_map = time(time_passes, ~\"ast indexing\", ||\n+                           syntax::ast_map::map_crate(sess.diagnostic(), crate));\n \n-    let middle::resolve::CrateMap {\n-        def_map: def_map,\n-        exp_map2: exp_map2,\n-        trait_map: trait_map\n-    } =\n-        time(time_passes, ~\"resolution\", ||\n-             middle::resolve::resolve_crate(sess, lang_items, crate));\n+        time(time_passes, ~\"external crate/lib resolution\", ||\n+             creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n+                                  sess.filesearch,\n+                                  session::sess_os_to_meta_os(sess.targ_cfg.os),\n+                                  sess.opts.is_static,\n+                                  sess.parse_sess.interner));\n \n-    time(time_passes, ~\"looking for entry point\",\n-         || middle::entry::find_entry_point(sess, crate, ast_map));\n+        let lang_items = time(time_passes, ~\"language item collection\", ||\n+                              middle::lang_items::collect_language_items(crate, sess));\n \n-    let freevars = time(time_passes, ~\"freevar finding\", ||\n-        freevars::annotate_freevars(def_map, crate));\n+        let middle::resolve::CrateMap {\n+            def_map: def_map,\n+            exp_map2: exp_map2,\n+            trait_map: trait_map\n+        } =\n+            time(time_passes, ~\"resolution\", ||\n+                 middle::resolve::resolve_crate(sess, lang_items, crate));\n \n-    let region_map = time(time_passes, ~\"region resolution\", ||\n-        middle::region::resolve_crate(sess, def_map, crate));\n+        time(time_passes, ~\"looking for entry point\",\n+             || middle::entry::find_entry_point(sess, crate, ast_map));\n \n-    let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n-        middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n+        let freevars = time(time_passes, ~\"freevar finding\", ||\n+                            freevars::annotate_freevars(def_map, crate));\n \n-    let outputs = outputs.get();\n+        let region_map = time(time_passes, ~\"region resolution\", ||\n+                              middle::region::resolve_crate(sess, def_map, crate));\n \n-    let (llmod, link_meta) = {\n+        let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n+                          middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n \n         let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n                                 region_map, rp_set, lang_items);\n@@ -255,7 +257,7 @@ pub fn compile_rest(sess: Session,\n              middle::check_const::check_crate(sess, crate, ast_map, def_map,\n                                               method_map, ty_cx));\n \n-        if upto == cu_typeck { return (crate, Some(ty_cx)); }\n+        if upto == cu_typeck { return (Some(crate), Some(ty_cx)); }\n \n         time(time_passes, ~\"privacy checking\", ||\n              middle::privacy::check_crate(ty_cx, &method_map, crate));\n@@ -289,7 +291,7 @@ pub fn compile_rest(sess: Session,\n         time(time_passes, ~\"lint checking\", ||\n              lint::check_crate(ty_cx, crate));\n \n-        if upto == cu_no_trans { return (crate, Some(ty_cx)); }\n+        if upto == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n \n         let maps = astencode::Maps {\n             root_map: root_map,\n@@ -300,13 +302,14 @@ pub fn compile_rest(sess: Session,\n             capture_map: capture_map\n         };\n \n+        let outputs = outputs.get_ref();\n         time(time_passes, ~\"translation\", ||\n              trans::base::trans_crate(sess, crate, ty_cx,\n                                       &outputs.obj_filename,\n                                       exp_map2, maps))\n-\n     };\n \n+    let outputs = outputs.get_ref();\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n         io::println(str::connect(link::link_args(sess,\n             &outputs.obj_filename, &outputs.out_filename, link_meta), \" \"));\n@@ -335,24 +338,24 @@ pub fn compile_rest(sess: Session,\n         (sess.opts.is_static && *sess.building_library)   ||\n         sess.opts.jit;\n \n-    if stop_after_codegen { return (crate, None); }\n+    if stop_after_codegen { return (None, None); }\n \n     time(time_passes, ~\"linking\", ||\n          link::link_binary(sess,\n                            &outputs.obj_filename,\n                            &outputs.out_filename, link_meta));\n \n-    return (crate, None);\n+    return (None, None);\n }\n \n pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n                 input: &input, upto: compile_upto,\n                 outputs: Option<@OutputFilenames>)\n-    -> (@ast::crate, Option<ty::ctxt>) {\n+    -> (Option<@ast::crate>, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n     let crate = time(time_passes, ~\"parsing\",\n                          || parse_input(sess, copy cfg, input) );\n-    if upto == cu_parse { return (crate, None); }\n+    if upto == cu_parse { return (Some(crate), None); }\n \n     compile_rest(sess, cfg, upto, outputs, Some(crate))\n }\n@@ -437,7 +440,7 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n     let src = sess.codemap.get_filemap(source_name(input)).src;\n     do io::with_str_reader(*src) |rdr| {\n         pprust::print_crate(sess.codemap, sess.parse_sess.interner,\n-                            sess.span_diagnostic, crate,\n+                            sess.span_diagnostic, crate.unwrap(),\n                             source_name(input),\n                             rdr, io::stdout(), ann, is_expanded);\n     }"}, {"sha": "600306e2aa4ab8fb63a1caa5d00eb9af0a1ce03c", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9", "patch": "@@ -144,9 +144,10 @@ fn run(repl: Repl, input: ~str) -> Repl {\n \n     let outputs = driver::build_output_filenames(&wrapped, &None, &None, sess);\n     debug!(\"calling compile_upto\");\n-    let (crate, _) = driver::compile_upto(sess, cfg, &wrapped,\n-                                          driver::cu_everything,\n-                                          Some(outputs));\n+\n+    let crate = driver::parse_input(sess, copy cfg, &wrapped);\n+    driver::compile_rest(sess, cfg, driver::cu_everything,\n+                         Some(outputs), Some(crate));\n \n     let mut opt = None;\n "}, {"sha": "ae4bfc6bc4b5e9669a87ce8151d8e25b6aa61014", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9", "patch": "@@ -101,7 +101,7 @@ impl<'self> PkgScript<'self> {\n             input: input,\n             sess: sess,\n             cfg: cfg,\n-            crate: crate,\n+            crate: crate.unwrap(),\n             build_dir: work_dir\n         }\n     }"}, {"sha": "f8de7291cef6e7bc605cc2fc4f3c02f33e7ee57c", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=b4a3fe25c6fa35d5b243d6dfaee59306c4bcfda9", "patch": "@@ -426,7 +426,7 @@ pub fn compile_crate_from_input(input: &driver::input,\n             debug!(\"Calling compile_upto, outputs = %?\", outputs);\n             let (crate, _) = driver::compile_upto(sess, copy cfg, input,\n                                                   driver::cu_parse, Some(outputs));\n-            let mut crate = crate;\n+            let mut crate = crate.unwrap();\n \n             debug!(\"About to inject link_meta info...\");\n             // Inject the inferred link_meta info if it's not already there"}]}