{"sha": "0f88167f89fffe321590c5148f21b7d51d44388d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmODgxNjdmODlmZmZlMzIxNTkwYzUxNDhmMjFiN2Q1MWQ0NDM4OGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-18T11:28:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-18T11:28:12Z"}, "message": "Auto merge of #58847 - bjorn3:remove_metadata_only_cg, r=alexcrichton\n\nRemove metadata only codegen backend\n\nIt is unused and probably broken at the moment.", "tree": {"sha": "e73770f15b22930f5ee5bef204ae72bf13efa840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e73770f15b22930f5ee5bef204ae72bf13efa840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f88167f89fffe321590c5148f21b7d51d44388d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f88167f89fffe321590c5148f21b7d51d44388d", "html_url": "https://github.com/rust-lang/rust/commit/0f88167f89fffe321590c5148f21b7d51d44388d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f88167f89fffe321590c5148f21b7d51d44388d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd45b19bd2d8b4f9a3940a409ea43285019f3280", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd45b19bd2d8b4f9a3940a409ea43285019f3280", "html_url": "https://github.com/rust-lang/rust/commit/cd45b19bd2d8b4f9a3940a409ea43285019f3280"}, {"sha": "0e0488fa53ddc465139023c023957a70176f34e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e0488fa53ddc465139023c023957a70176f34e2", "html_url": "https://github.com/rust-lang/rust/commit/0e0488fa53ddc465139023c023957a70176f34e2"}], "stats": {"total": 838, "additions": 44, "deletions": 794}, "files": [{"sha": "4951ed51cf26579a3248dae25dfe4d36395d2c9b", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -2650,7 +2650,6 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n- \"rustc_incremental 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"rustc_target 0.0.0\","}, {"sha": "8c1049f42c535bae2b1aad811d1b5db7fe41a189", "filename": "config.toml.example", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -14,10 +14,6 @@\n # =============================================================================\n [llvm]\n \n-# Indicates whether rustc will support compilation with LLVM\n-# note: rustc does not compile without LLVM at the moment\n-#enabled = true\n-\n # Indicates whether the LLVM build is a Release or Debug build\n #optimize = true\n "}, {"sha": "414033a5e2fede00eb1803a01e30fdda4798b4b5", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -996,10 +996,7 @@ impl<'a> Builder<'a> {\n         // For other crates, however, we know that we've already got a standard\n         // library up and running, so we can use the normal compiler to compile\n         // build scripts in that situation.\n-        //\n-        // If LLVM support is disabled we need to use the snapshot compiler to compile\n-        // build scripts, as the new compiler doesn't support executables.\n-        if mode == Mode::Std || !self.config.llvm_enabled {\n+        if mode == Mode::Std {\n             cargo\n                 .env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());"}, {"sha": "6162c7e0a37c3f9bf63c175129f0dcf8b89e56f9", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -64,7 +64,6 @@ pub struct Config {\n     pub backtrace_on_ice: bool,\n \n     // llvm codegen options\n-    pub llvm_enabled: bool,\n     pub llvm_assertions: bool,\n     pub llvm_optimize: bool,\n     pub llvm_thin_lto: bool,\n@@ -244,7 +243,6 @@ struct Install {\n #[derive(Deserialize, Default)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Llvm {\n-    enabled: Option<bool>,\n     ccache: Option<StringOrBool>,\n     ninja: Option<bool>,\n     assertions: Option<bool>,\n@@ -360,7 +358,6 @@ impl Config {\n \n     pub fn default_opts() -> Config {\n         let mut config = Config::default();\n-        config.llvm_enabled = true;\n         config.llvm_optimize = true;\n         config.llvm_version_check = true;\n         config.backtrace = true;\n@@ -512,7 +509,6 @@ impl Config {\n                 Some(StringOrBool::Bool(false)) | None => {}\n             }\n             set(&mut config.ninja, llvm.ninja);\n-            set(&mut config.llvm_enabled, llvm.enabled);\n             llvm_assertions = llvm.assertions;\n             set(&mut config.llvm_optimize, llvm.optimize);\n             set(&mut config.llvm_thin_lto, llvm.thin_lto);\n@@ -671,6 +667,11 @@ impl Config {\n     pub fn very_verbose(&self) -> bool {\n         self.verbose > 1\n     }\n+\n+    pub fn llvm_enabled(&self) -> bool {\n+        self.rust_codegen_backends.contains(&INTERNER.intern_str(\"llvm\"))\n+        || self.rust_codegen_backends.contains(&INTERNER.intern_str(\"emscripten\"))\n+    }\n }\n \n fn set<T>(field: &mut T, val: Option<T>) {"}, {"sha": "8a9d99c1662ddef1b9b2a690ab6516c486621f2f", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -1194,7 +1194,7 @@ impl Step for Compiletest {\n             cmd.arg(\"--quiet\");\n         }\n \n-        if builder.config.llvm_enabled {\n+        if builder.config.llvm_enabled() {\n             let llvm_config = builder.ensure(native::Llvm {\n                 target: builder.config.build,\n                 emscripten: false,\n@@ -1227,12 +1227,6 @@ impl Step for Compiletest {\n                 }\n             }\n         }\n-        if suite == \"run-make-fulldeps\" && !builder.config.llvm_enabled {\n-            builder.info(\n-                \"Ignoring run-make test suite as they generally don't work without LLVM\"\n-            );\n-            return;\n-        }\n \n         if suite != \"run-make-fulldeps\" {\n             cmd.arg(\"--cc\")"}, {"sha": "865b1f8268c32a8a6b19b47ba670e22367b72a56", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -700,7 +700,7 @@ impl<'a> Builder<'a> {\n     }\n \n     fn llvm_bin_path(&self) -> Option<PathBuf> {\n-        if self.config.llvm_enabled {\n+        if self.config.llvm_enabled() {\n             let llvm_config = self.ensure(native::Llvm {\n                 target: self.config.build,\n                 emscripten: false,"}, {"sha": "c75208b9e06c13bb4a505954192133519c6ef131", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -21,4 +21,3 @@ rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n-rustc_incremental = { path = \"../librustc_incremental\" }"}, {"sha": "56eaffb1ca31dcad88a669c06b42548367b98fbe", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 2, "deletions": 144, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -10,27 +10,16 @@\n #![feature(box_syntax)]\n \n use std::any::Any;\n-use std::io::Write;\n-use std::fs;\n-use std::path::Path;\n-use std::sync::{mpsc, Arc};\n-\n-use rustc_data_structures::owning_ref::OwningRef;\n-use flate2::Compression;\n-use flate2::write::DeflateEncoder;\n+use std::sync::mpsc;\n \n use syntax::symbol::Symbol;\n-use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::Session;\n use rustc::util::common::ErrorReported;\n-use rustc::session::config::{CrateType, OutputFilenames, PrintRequest};\n+use rustc::session::config::{OutputFilenames, PrintRequest};\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::dep_graph::DepGraph;\n-use rustc_target::spec::Target;\n-use crate::link::out_filename;\n \n pub use rustc_data_structures::sync::MetadataRef;\n \n@@ -64,134 +53,3 @@ pub trait CodegenBackend {\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorReported>;\n }\n-\n-pub struct NoLlvmMetadataLoader;\n-\n-impl MetadataLoader for NoLlvmMetadataLoader {\n-    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        let buf = fs::read(filename).map_err(|e| format!(\"metadata file open err: {:?}\", e))?;\n-        let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf);\n-        Ok(rustc_erase_owner!(buf.map_owner_box()))\n-    }\n-\n-    fn get_dylib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        self.get_rlib_metadata(target, filename)\n-    }\n-}\n-\n-pub struct MetadataOnlyCodegenBackend(());\n-pub struct OngoingCodegen {\n-    metadata: EncodedMetadata,\n-    metadata_version: Vec<u8>,\n-    crate_name: Symbol,\n-}\n-\n-impl MetadataOnlyCodegenBackend {\n-    pub fn boxed() -> Box<dyn CodegenBackend> {\n-        box MetadataOnlyCodegenBackend(())\n-    }\n-}\n-\n-impl CodegenBackend for MetadataOnlyCodegenBackend {\n-    fn init(&self, sess: &Session) {\n-        for cty in sess.opts.crate_types.iter() {\n-            match *cty {\n-                CrateType::Rlib | CrateType::Dylib | CrateType::Executable => {},\n-                _ => {\n-                    sess.diagnostic().warn(\n-                        &format!(\"LLVM unsupported, so output type {} is not supported\", cty)\n-                    );\n-                },\n-            }\n-        }\n-    }\n-\n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n-        box NoLlvmMetadataLoader\n-    }\n-\n-    fn provide(&self, providers: &mut Providers<'_>) {\n-        crate::symbol_names::provide(providers);\n-\n-        providers.target_features_whitelist = |_tcx, _cnum| {\n-            Default::default() // Just a dummy\n-        };\n-        providers.is_reachable_non_generic = |_tcx, _defid| true;\n-        providers.exported_symbols = |_tcx, _crate| Arc::new(Vec::new());\n-    }\n-    fn provide_extern(&self, providers: &mut Providers<'_>) {\n-        providers.is_reachable_non_generic = |_tcx, _defid| true;\n-    }\n-\n-    fn codegen_crate<'a, 'tcx>(\n-        &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        _rx: mpsc::Receiver<Box<dyn Any + Send>>\n-    ) -> Box<dyn Any> {\n-        use rustc_mir::monomorphize::item::MonoItem;\n-\n-        crate::check_for_rustc_errors_attr(tcx);\n-        crate::symbol_names_test::report_symbol_names(tcx);\n-        rustc_incremental::assert_dep_graph(tcx);\n-        rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n-        // FIXME: Fix this\n-        // rustc::middle::dependency_format::calculate(tcx);\n-        let _ = tcx.link_args(LOCAL_CRATE);\n-        let _ = tcx.native_libraries(LOCAL_CRATE);\n-        let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n-        for (mono_item, _) in cgus.iter().flat_map(|cgu| cgu.items().iter()) {\n-            if let MonoItem::Fn(inst) = mono_item {\n-                let def_id = inst.def_id();\n-                if def_id.is_local() {\n-                    let _ = tcx.codegen_fn_attrs(def_id);\n-                }\n-            }\n-        }\n-        tcx.sess.abort_if_errors();\n-\n-        let metadata = tcx.encode_metadata();\n-\n-        box OngoingCodegen {\n-            metadata,\n-            metadata_version: tcx.metadata_encoding_version().to_vec(),\n-            crate_name: tcx.crate_name(LOCAL_CRATE),\n-        }\n-    }\n-\n-    fn join_codegen_and_link(\n-        &self,\n-        ongoing_codegen: Box<dyn Any>,\n-        sess: &Session,\n-        _dep_graph: &DepGraph,\n-        outputs: &OutputFilenames,\n-    ) -> Result<(), ErrorReported> {\n-        let ongoing_codegen = ongoing_codegen.downcast::<OngoingCodegen>()\n-            .expect(\"Expected MetadataOnlyCodegenBackend's OngoingCodegen, found Box<dyn Any>\");\n-        for &crate_type in sess.opts.crate_types.iter() {\n-            if crate_type != CrateType::Rlib &&\n-               crate_type != CrateType::Dylib {\n-                continue;\n-            }\n-            let output_name =\n-                out_filename(sess, crate_type, &outputs, &ongoing_codegen.crate_name.as_str());\n-            let mut compressed = ongoing_codegen.metadata_version.clone();\n-            let metadata = if crate_type == CrateType::Dylib {\n-                DeflateEncoder::new(&mut compressed, Compression::fast())\n-                    .write_all(&ongoing_codegen.metadata.raw_data)\n-                    .unwrap();\n-                &compressed\n-            } else {\n-                &ongoing_codegen.metadata.raw_data\n-            };\n-            fs::write(&output_name, metadata).unwrap();\n-        }\n-\n-        sess.abort_if_errors();\n-        if !sess.opts.crate_types.contains(&CrateType::Rlib)\n-            && !sess.opts.crate_types.contains(&CrateType::Dylib)\n-        {\n-            sess.fatal(\"Executables are not supported by the metadata-only backend.\");\n-        }\n-        Ok(())\n-    }\n-}"}, {"sha": "1a3914e6ef44cc8f04784eafbf21d8c52db2b640", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -19,7 +19,6 @@\n \n #[macro_use]\n extern crate rustc;\n-#[macro_use] extern crate rustc_data_structures;\n \n use rustc::ty::TyCtxt;\n use rustc::hir::def_id::LOCAL_CRATE;"}, {"sha": "25984616b878b24e8ad2e9bd90b0260a83c36300", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -91,9 +91,6 @@ use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n-#[cfg(test)]\n-mod test;\n-\n pub mod pretty;\n \n /// Exit status code used for successful compilation and help output."}, {"sha": "f98939eb40a8e45147178677ce410dd7e1ccfac2", "filename": "src/librustc_driver/test.rs", "status": "removed", "additions": 0, "deletions": 614, "changes": 614, "blob_url": "https://github.com/rust-lang/rust/blob/cd45b19bd2d8b4f9a3940a409ea43285019f3280/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd45b19bd2d8b4f9a3940a409ea43285019f3280/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=cd45b19bd2d8b4f9a3940a409ea43285019f3280", "patch": "@@ -1,614 +0,0 @@\n-//! Standalone tests for the inference module.\n-\n-use errors::emitter::Emitter;\n-use errors::{DiagnosticBuilder, Level};\n-use rustc::hir;\n-use rustc::infer::outlives::env::OutlivesEnvironment;\n-use rustc::infer::{self, InferOk, InferResult, SuppressRegionErrors};\n-use rustc::middle::region;\n-use rustc::session::{DiagnosticOutput, config};\n-use rustc::traits::ObligationCause;\n-use rustc::ty::subst::Subst;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc_data_structures::sync;\n-use rustc_target::spec::abi::Abi;\n-use rustc_interface::interface;\n-use syntax::ast;\n-use syntax::feature_gate::UnstableFeatures;\n-use syntax::source_map::FileName;\n-use syntax::symbol::Symbol;\n-\n-struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n-    region_scope_tree: &'a mut region::ScopeTree,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-struct RH<'a> {\n-    id: hir::ItemLocalId,\n-    sub: &'a [RH<'a>],\n-}\n-\n-const EMPTY_SOURCE_STR: &'static str = \"#![feature(no_core)] #![no_core]\";\n-\n-struct ExpectErrorEmitter {\n-    messages: Vec<String>,\n-}\n-\n-fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n-    match lvl {\n-        Level::Bug | Level::Fatal | Level::Error => {}\n-        _ => {\n-            return;\n-        }\n-    }\n-\n-    debug!(\"Error: {}\", msg);\n-    match e.messages.iter().position(|m| msg.contains(m)) {\n-        Some(i) => {\n-            e.messages.remove(i);\n-        }\n-        None => {\n-            debug!(\"Unexpected error: {} Expected: {:?}\", msg, e.messages);\n-            panic!(\"Unexpected error: {} Expected: {:?}\", msg, e.messages);\n-        }\n-    }\n-}\n-\n-impl Emitter for ExpectErrorEmitter {\n-    fn emit(&mut self, db: &DiagnosticBuilder) {\n-        remove_message(self, &db.message(), db.level);\n-        for child in &db.children {\n-            remove_message(self, &child.message(), child.level);\n-        }\n-    }\n-}\n-\n-fn errors(msgs: &[&str]) -> (Box<dyn Emitter + Send + sync::Send>, usize) {\n-    let mut v: Vec<_> = msgs.iter().map(|m| m.to_string()).collect();\n-    if !v.is_empty() {\n-        v.push(\"aborting due to previous error\".to_owned());\n-    }\n-    (\n-        box ExpectErrorEmitter { messages: v } as Box<dyn Emitter + Send + sync::Send>,\n-        msgs.len(),\n-    )\n-}\n-\n-fn test_env<F>(\n-    source_string: &str,\n-    (emitter, expected_err_count): (Box<dyn Emitter + Send + sync::Send>, usize),\n-    body: F,\n-)\n-where\n-    F: FnOnce(Env) + Send,\n-{\n-    let mut opts = config::Options::default();\n-    opts.debugging_opts.verbose = true;\n-    opts.unstable_features = UnstableFeatures::Allow;\n-\n-    // When we're compiling this library with `--test` it'll run as a binary but\n-    // not actually exercise much functionality.\n-    // As a result most of the logic loading the codegen backend is defunkt\n-    // (it assumes we're a dynamic library in a sysroot)\n-    // so let's just use the metadata only backend which doesn't need to load any libraries.\n-    opts.debugging_opts.codegen_backend = Some(\"metadata_only\".to_owned());\n-\n-    let input = config::Input::Str {\n-        name: FileName::anon_source_code(&source_string),\n-        input: source_string.to_string(),\n-    };\n-\n-    let config = interface::Config {\n-        opts,\n-        crate_cfg: Default::default(),\n-        input,\n-        input_path: None,\n-        output_file: None,\n-        output_dir: None,\n-        file_loader: None,\n-        diagnostic_output: DiagnosticOutput::Emitter(emitter),\n-        stderr: None,\n-        crate_name: Some(\"test\".to_owned()),\n-        lint_caps: Default::default(),\n-    };\n-\n-    interface::run_compiler(config, |compiler| {\n-        compiler.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n-            tcx.infer_ctxt().enter(|infcx| {\n-                let mut region_scope_tree = region::ScopeTree::default();\n-                let param_env = ty::ParamEnv::empty();\n-                body(Env {\n-                    infcx: &infcx,\n-                    region_scope_tree: &mut region_scope_tree,\n-                    param_env: param_env,\n-                });\n-                let outlives_env = OutlivesEnvironment::new(param_env);\n-                let def_id = tcx.hir().local_def_id(ast::CRATE_NODE_ID);\n-                infcx.resolve_regions_and_report_errors(\n-                    def_id,\n-                    &region_scope_tree,\n-                    &outlives_env,\n-                    SuppressRegionErrors::default(),\n-                );\n-                assert_eq!(tcx.sess.err_count(), expected_err_count);\n-            });\n-        })\n-    });\n-}\n-\n-fn d1() -> ty::DebruijnIndex {\n-    ty::INNERMOST\n-}\n-\n-fn d2() -> ty::DebruijnIndex {\n-    d1().shifted_in(1)\n-}\n-\n-impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    pub fn create_region_hierarchy(\n-        &mut self,\n-        rh: &RH,\n-        parent: (region::Scope, region::ScopeDepth),\n-    ) {\n-        let me = region::Scope {\n-            id: rh.id,\n-            data: region::ScopeData::Node,\n-        };\n-        self.region_scope_tree.record_scope_parent(me, Some(parent));\n-        for child_rh in rh.sub {\n-            self.create_region_hierarchy(child_rh, (me, parent.1 + 1));\n-        }\n-    }\n-\n-    pub fn create_simple_region_hierarchy(&mut self) {\n-        // Creates a region hierarchy where 1 is root, 10 and 11 are\n-        // children of 1, etc.\n-\n-        let dscope = region::Scope {\n-            id: hir::ItemLocalId::from_u32(1),\n-            data: region::ScopeData::Destruction,\n-        };\n-        self.region_scope_tree.record_scope_parent(dscope, None);\n-        self.create_region_hierarchy(\n-            &RH {\n-                id: hir::ItemLocalId::from_u32(1),\n-                sub: &[\n-                    RH {\n-                        id: hir::ItemLocalId::from_u32(10),\n-                        sub: &[],\n-                    },\n-                    RH {\n-                        id: hir::ItemLocalId::from_u32(11),\n-                        sub: &[],\n-                    },\n-                ],\n-            },\n-            (dscope, 1),\n-        );\n-    }\n-\n-    #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n-    pub fn lookup_item(&self, names: &[String]) -> hir::HirId {\n-        return match search_mod(self, &self.infcx.tcx.hir().krate().module, 0, names) {\n-            Some(id) => id,\n-            None => {\n-                panic!(\"no item found: `{}`\", names.join(\"::\"));\n-            }\n-        };\n-\n-        fn search_mod(\n-            this: &Env,\n-            m: &hir::Mod,\n-            idx: usize,\n-            names: &[String],\n-        ) -> Option<hir::HirId> {\n-            assert!(idx < names.len());\n-            for item in &m.item_ids {\n-                let item = this.infcx.tcx.hir().expect_item(item.id);\n-                if item.ident.to_string() == names[idx] {\n-                    return search(this, item, idx + 1, names);\n-                }\n-            }\n-            return None;\n-        }\n-\n-        fn search(this: &Env, it: &hir::Item, idx: usize, names: &[String]) -> Option<hir::HirId> {\n-            if idx == names.len() {\n-                return Some(it.hir_id);\n-            }\n-\n-            return match it.node {\n-                hir::ItemKind::Use(..)\n-                | hir::ItemKind::ExternCrate(..)\n-                | hir::ItemKind::Const(..)\n-                | hir::ItemKind::Static(..)\n-                | hir::ItemKind::Fn(..)\n-                | hir::ItemKind::ForeignMod(..)\n-                | hir::ItemKind::GlobalAsm(..)\n-                | hir::ItemKind::Existential(..)\n-                | hir::ItemKind::Ty(..) => None,\n-\n-                hir::ItemKind::Enum(..)\n-                | hir::ItemKind::Struct(..)\n-                | hir::ItemKind::Union(..)\n-                | hir::ItemKind::Trait(..)\n-                | hir::ItemKind::TraitAlias(..)\n-                | hir::ItemKind::Impl(..) => None,\n-\n-                hir::ItemKind::Mod(ref m) => search_mod(this, m, idx, names),\n-            };\n-        }\n-    }\n-\n-    pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match self.infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n-            .sub(a, b)\n-        {\n-            Ok(_) => true,\n-            Err(ref e) => panic!(\"Encountered error: {}\", e),\n-        }\n-    }\n-\n-    pub fn is_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        self.infcx.can_sub(self.param_env, a, b).is_ok()\n-    }\n-\n-    pub fn assert_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n-        if !self.is_subtype(a, b) {\n-            panic!(\"{} is not a subtype of {}, but it should be\", a, b);\n-        }\n-    }\n-\n-    pub fn assert_eq(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n-        self.assert_subtype(a, b);\n-        self.assert_subtype(b, a);\n-    }\n-\n-    pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx\n-            .tcx\n-            .mk_fn_ptr(ty::Binder::bind(self.infcx.tcx.mk_fn_sig(\n-                input_tys.iter().cloned(),\n-                output_ty,\n-                false,\n-                hir::Unsafety::Normal,\n-                Abi::Rust,\n-            )))\n-    }\n-\n-    pub fn t_nil(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_unit()\n-    }\n-\n-    pub fn t_pair(&self, ty1: Ty<'tcx>, ty2: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.tcx.intern_tup(&[ty1, ty2])\n-    }\n-\n-    pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n-        let name = format!(\"T{}\", index);\n-        self.infcx\n-            .tcx\n-            .mk_ty_param(index, Symbol::intern(&name).as_interned_str())\n-    }\n-\n-    pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {\n-        let name = Symbol::intern(name).as_interned_str();\n-        self.infcx\n-            .tcx\n-            .mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                def_id: self.infcx.tcx.hir().local_def_id(ast::CRATE_NODE_ID),\n-                index,\n-                name,\n-            }))\n-    }\n-\n-    pub fn re_late_bound_with_debruijn(\n-        &self,\n-        id: u32,\n-        debruijn: ty::DebruijnIndex,\n-    ) -> ty::Region<'tcx> {\n-        self.infcx\n-            .tcx\n-            .mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n-    }\n-\n-    pub fn t_rptr(&self, r: ty::Region<'tcx>) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n-    }\n-\n-    pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n-        let r = self.re_late_bound_with_debruijn(id, d1());\n-        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n-    }\n-\n-    pub fn t_rptr_late_bound_with_debruijn(\n-        &self,\n-        id: u32,\n-        debruijn: ty::DebruijnIndex,\n-    ) -> Ty<'tcx> {\n-        let r = self.re_late_bound_with_debruijn(id, debruijn);\n-        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n-    }\n-\n-    pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n-        let r = ty::ReScope(region::Scope {\n-            id: hir::ItemLocalId::from_u32(id),\n-            data: region::ScopeData::Node,\n-        });\n-        self.infcx\n-            .tcx\n-            .mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n-    }\n-\n-    pub fn re_free(&self, id: u32) -> ty::Region<'tcx> {\n-        self.infcx.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-            scope: self.infcx.tcx.hir().local_def_id(ast::CRATE_NODE_ID),\n-            bound_region: ty::BrAnon(id),\n-        }))\n-    }\n-\n-    pub fn t_rptr_free(&self, id: u32) -> Ty<'tcx> {\n-        let r = self.re_free(id);\n-        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n-    }\n-\n-    pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, ()> {\n-        self.infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n-            .sub(t1, t2)\n-    }\n-\n-    /// Checks that `t1 <: t2` is true (this may register additional\n-    /// region checks).\n-    pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub(t1, t2) {\n-            Ok(InferOk {\n-                obligations,\n-                value: (),\n-            }) => {\n-                // None of these tests should require nested obligations.\n-                assert!(obligations.is_empty());\n-            }\n-            Err(ref e) => {\n-                panic!(\"unexpected error computing sub({:?},{:?}): {}\", t1, t2, e);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn contravariant_region_ptr_ok() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr1 = env.t_rptr_scope(1);\n-        let t_rptr10 = env.t_rptr_scope(10);\n-        env.assert_eq(t_rptr1, t_rptr1);\n-        env.assert_eq(t_rptr10, t_rptr10);\n-        env.make_subtype(t_rptr1, t_rptr10);\n-    })\n-}\n-\n-#[test]\n-fn contravariant_region_ptr_err() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[\"mismatched types\"]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr1 = env.t_rptr_scope(1);\n-        let t_rptr10 = env.t_rptr_scope(10);\n-        env.assert_eq(t_rptr1, t_rptr1);\n-        env.assert_eq(t_rptr10, t_rptr10);\n-\n-        // This will cause an error when regions are resolved.\n-        env.make_subtype(t_rptr10, t_rptr1);\n-    })\n-}\n-\n-#[test]\n-fn sub_bound_free_true() {\n-    //! Test that:\n-    //!\n-    //!     for<'a> fn(&'a isize) <: fn(&'b isize)\n-    //!\n-    //! *does* hold.\n-\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_sub(\n-            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-            env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-        );\n-    })\n-}\n-\n-/// Test substituting a bound region into a function, which introduces another level of binding.\n-/// This requires adjusting the Debruijn index.\n-#[test]\n-fn subst_ty_renumber_bound() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        // Situation:\n-        // Theta = [A -> &'a foo]\n-\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-\n-        // t_source = fn(A)\n-        let t_source = {\n-            let t_param = env.t_param(0);\n-            env.t_fn(&[t_param], env.t_nil())\n-        };\n-\n-        let substs = env.infcx.tcx.intern_substs(&[t_rptr_bound1.into()]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n-\n-        // t_expected = fn(&'a isize)\n-        let t_expected = {\n-            let t_ptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n-            env.t_fn(&[t_ptr_bound2], env.t_nil())\n-        };\n-\n-        debug!(\n-            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-            t_source, substs, t_substituted, t_expected\n-        );\n-\n-        assert_eq!(t_substituted, t_expected);\n-    })\n-}\n-\n-/// Tests substituting a bound region into a function, which introduces another level of binding.\n-/// This requires adjusting the De Bruijn index.\n-#[test]\n-fn subst_ty_renumber_some_bounds() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        // Situation:\n-        // `Theta = [A -> &'a foo]`\n-\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-\n-        // `t_source = (A, fn(A))`\n-        let t_source = {\n-            let t_param = env.t_param(0);\n-            env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n-        };\n-\n-        let substs = env.infcx.tcx.intern_substs(&[t_rptr_bound1.into()]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n-\n-        // `t_expected = (&'a isize, fn(&'a isize))`\n-        //\n-        // However, note that the Debruijn index is different in the different cases.\n-        let t_expected = {\n-            let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n-            env.t_pair(t_rptr_bound1, env.t_fn(&[t_rptr_bound2], env.t_nil()))\n-        };\n-\n-        debug!(\n-            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-            t_source, substs, t_substituted, t_expected\n-        );\n-\n-        assert_eq!(t_substituted, t_expected);\n-    })\n-}\n-\n-/// Tests that we correctly compute whether a type has escaping regions or not.\n-#[test]\n-fn escaping() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        // Situation:\n-        // `Theta = [A -> &'a foo]`\n-        env.create_simple_region_hierarchy();\n-\n-        assert!(!env.t_nil().has_escaping_bound_vars());\n-\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        assert!(!t_rptr_free1.has_escaping_bound_vars());\n-\n-        let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, d1());\n-        assert!(t_rptr_bound1.has_escaping_bound_vars());\n-\n-        let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n-        assert!(t_rptr_bound2.has_escaping_bound_vars());\n-\n-        // `t_fn = fn(A)`\n-        let t_param = env.t_param(0);\n-        assert!(!t_param.has_escaping_bound_vars());\n-        let t_fn = env.t_fn(&[t_param], env.t_nil());\n-        assert!(!t_fn.has_escaping_bound_vars());\n-    })\n-}\n-\n-/// Tests applying a substitution where the value being substituted for an early-bound region is a\n-/// late-bound region.\n-#[test]\n-fn subst_region_renumber_region() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let re_bound1 = env.re_late_bound_with_debruijn(1, d1());\n-\n-        // `type t_source<'a> = fn(&'a isize)`\n-        let t_source = {\n-            let re_early = env.re_early_bound(0, \"'a\");\n-            env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n-        };\n-\n-        let substs = env.infcx.tcx.intern_substs(&[re_bound1.into()]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n-\n-        // `t_expected = fn(&'a isize)`\n-        //\n-        // but not that the Debruijn index is different in the different cases.\n-        let t_expected = {\n-            let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n-            env.t_fn(&[t_rptr_bound2], env.t_nil())\n-        };\n-\n-        debug!(\n-            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-            t_source, substs, t_substituted, t_expected\n-        );\n-\n-        assert_eq!(t_substituted, t_expected);\n-    })\n-}\n-\n-#[test]\n-fn walk_ty() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let tcx = env.infcx.tcx;\n-        let int_ty = tcx.types.isize;\n-        let usize_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty]);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty]);\n-        let walked: Vec<_> = tup2_ty.walk().collect();\n-        assert_eq!(\n-            walked,\n-            [\n-                tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty, usize_ty,\n-                int_ty, usize_ty, usize_ty\n-            ]\n-        );\n-    })\n-}\n-\n-#[test]\n-fn walk_ty_skip_subtree() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let tcx = env.infcx.tcx;\n-        let int_ty = tcx.types.isize;\n-        let usize_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty]);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty]);\n-\n-        // types we expect to see (in order), plus a boolean saying\n-        // whether to skip the subtree.\n-        let mut expected = vec![\n-            (tup2_ty, false),\n-            (tup1_ty, false),\n-            (int_ty, false),\n-            (usize_ty, false),\n-            (int_ty, false),\n-            (usize_ty, false),\n-            (tup1_ty, true), // skip the isize/usize/isize/usize\n-            (usize_ty, false),\n-        ];\n-        expected.reverse();\n-\n-        let mut walker = tup2_ty.walk();\n-        while let Some(t) = walker.next() {\n-            debug!(\"walked to {:?}\", t);\n-            let (expected_ty, skip) = expected.pop().unwrap();\n-            assert_eq!(t, expected_ty);\n-            if skip {\n-                walker.skip_current_subtree();\n-            }\n-        }\n-\n-        assert!(expected.is_empty());\n-    })\n-}"}, {"sha": "b1ef4e315d98da2370c745bd55a8103b65849098", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -266,9 +266,6 @@ pub fn get_codegen_backend(sess: &Session) -> Box<dyn CodegenBackend> {\n         let codegen_name = sess.opts.debugging_opts.codegen_backend.as_ref()\n             .unwrap_or(&sess.target.target.options.codegen_backend);\n         let backend = match &codegen_name[..] {\n-            \"metadata_only\" => {\n-                rustc_codegen_utils::codegen_backend::MetadataOnlyCodegenBackend::boxed\n-            }\n             filename if filename.contains(\".\") => {\n                 load_backend_from_dylib(filename.as_ref())\n             }"}, {"sha": "5330470da16b038d218c4806dc73ac18fb2bc662", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f88167f89fffe321590c5148f21b7d51d44388d/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=0f88167f89fffe321590c5148f21b7d51d44388d", "patch": "@@ -3,9 +3,13 @@\n extern crate syntax;\n extern crate rustc;\n extern crate rustc_codegen_utils;\n+#[macro_use]\n+extern crate rustc_data_structures;\n+extern crate rustc_target;\n \n use std::any::Any;\n-use std::sync::mpsc;\n+use std::sync::{Arc, mpsc};\n+use std::path::Path;\n use syntax::symbol::Symbol;\n use rustc::session::Session;\n use rustc::session::config::OutputFilenames;\n@@ -14,21 +18,44 @@ use rustc::ty::query::Providers;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::dep_graph::DepGraph;\n use rustc::util::common::ErrorReported;\n-use rustc_codegen_utils::codegen_backend::{CodegenBackend, MetadataOnlyCodegenBackend};\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_data_structures::sync::MetadataRef;\n+use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_target::spec::Target;\n \n-struct TheBackend(Box<CodegenBackend>);\n+pub struct NoLlvmMetadataLoader;\n+\n+impl MetadataLoader for NoLlvmMetadataLoader {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<MetadataRef, String> {\n+        let buf = std::fs::read(filename).map_err(|e| format!(\"metadata file open err: {:?}\", e))?;\n+        let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf);\n+        Ok(rustc_erase_owner!(buf.map_owner_box()))\n+    }\n+\n+    fn get_dylib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String> {\n+        self.get_rlib_metadata(target, filename)\n+    }\n+}\n+\n+struct TheBackend;\n \n impl CodegenBackend for TheBackend {\n     fn metadata_loader(&self) -> Box<MetadataLoader + Sync> {\n-        self.0.metadata_loader()\n+        Box::new(NoLlvmMetadataLoader)\n     }\n \n     fn provide(&self, providers: &mut Providers) {\n-        self.0.provide(providers);\n+        rustc_codegen_utils::symbol_names::provide(providers);\n+\n+        providers.target_features_whitelist = |_tcx, _cnum| {\n+            Default::default() // Just a dummy\n+        };\n+        providers.is_reachable_non_generic = |_tcx, _defid| true;\n+        providers.exported_symbols = |_tcx, _crate| Arc::new(Vec::new());\n     }\n \n     fn provide_extern(&self, providers: &mut Providers) {\n-        self.0.provide_extern(providers);\n+        providers.is_reachable_non_generic = |_tcx, _defid| true;\n     }\n \n     fn codegen_crate<'a, 'tcx>(\n@@ -69,5 +96,5 @@ impl CodegenBackend for TheBackend {\n /// This is the entrypoint for a hot plugged rustc_codegen_llvm\n #[no_mangle]\n pub fn __rustc_codegen_backend() -> Box<CodegenBackend> {\n-    Box::new(TheBackend(MetadataOnlyCodegenBackend::boxed()))\n+    Box::new(TheBackend)\n }"}]}