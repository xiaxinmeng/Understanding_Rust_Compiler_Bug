{"sha": "c16919d3a8e83e4c72668f6ad89d48f6ba8341f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNjkxOWQzYThlODNlNGM3MjY2OGY2YWQ4OWQ0OGY2YmE4MzQxZjY=", "commit": {"author": {"name": "Matthijs Hofstra", "email": "thiezz@gmail.com", "date": "2013-04-02T21:15:04Z"}, "committer": {"name": "Matthijs Hofstra", "email": "thiezz@gmail.com", "date": "2013-04-03T14:33:23Z"}, "message": "Removing mut fields from vec.rs, at_vec.rs, str.rs, unstable.rs, and cell.rs.", "tree": {"sha": "fa2e4a1a72422248c04ff1f9da4224baa6a140c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa2e4a1a72422248c04ff1f9da4224baa6a140c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6", "html_url": "https://github.com/rust-lang/rust/commit/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/comments", "author": {"login": "Thiez", "id": 204550, "node_id": "MDQ6VXNlcjIwNDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/204550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Thiez", "html_url": "https://github.com/Thiez", "followers_url": "https://api.github.com/users/Thiez/followers", "following_url": "https://api.github.com/users/Thiez/following{/other_user}", "gists_url": "https://api.github.com/users/Thiez/gists{/gist_id}", "starred_url": "https://api.github.com/users/Thiez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Thiez/subscriptions", "organizations_url": "https://api.github.com/users/Thiez/orgs", "repos_url": "https://api.github.com/users/Thiez/repos", "events_url": "https://api.github.com/users/Thiez/events{/privacy}", "received_events_url": "https://api.github.com/users/Thiez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Thiez", "id": 204550, "node_id": "MDQ6VXNlcjIwNDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/204550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Thiez", "html_url": "https://github.com/Thiez", "followers_url": "https://api.github.com/users/Thiez/followers", "following_url": "https://api.github.com/users/Thiez/following{/other_user}", "gists_url": "https://api.github.com/users/Thiez/gists{/gist_id}", "starred_url": "https://api.github.com/users/Thiez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Thiez/subscriptions", "organizations_url": "https://api.github.com/users/Thiez/orgs", "repos_url": "https://api.github.com/users/Thiez/repos", "events_url": "https://api.github.com/users/Thiez/events{/privacy}", "received_events_url": "https://api.github.com/users/Thiez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "260d74dfcc095d02add8fc97c31922824ddf92fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/260d74dfcc095d02add8fc97c31922824ddf92fd", "html_url": "https://github.com/rust-lang/rust/commit/260d74dfcc095d02add8fc97c31922824ddf92fd"}], "stats": {"total": 46, "additions": 22, "deletions": 24}, "files": [{"sha": "38a663dc24504cd4adf58600b3ccbd04346a36f1", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=c16919d3a8e83e4c72668f6ad89d48f6ba8341f6", "patch": "@@ -208,7 +208,7 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn set_len<T>(v: @[T], new_len: uint) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(&v));\n+        let repr: **mut VecRepr = ::cast::reinterpret_cast(&addr_of(&v));\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n@@ -226,7 +226,7 @@ pub mod raw {\n \n     #[inline(always)] // really pretty please\n     pub unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n+        let repr: **mut VecRepr = ::cast::reinterpret_cast(&v);\n         let fill = (**repr).unboxed.fill;\n         (**repr).unboxed.fill += sys::size_of::<T>();\n         let p = addr_of(&((**repr).unboxed.data));"}, {"sha": "c2983e033e537af276f978ad878de0472f54ee6b", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=c16919d3a8e83e4c72668f6ad89d48f6ba8341f6", "patch": "@@ -10,7 +10,7 @@\n \n //! A mutable, nullable memory location\n \n-use cast::transmute;\n+use cast::transmute_mut;\n use prelude::*;\n \n /*\n@@ -20,16 +20,12 @@ Similar to a mutable option type, but friendlier.\n */\n \n pub struct Cell<T> {\n-    mut value: Option<T>\n+    value: Option<T>\n }\n \n impl<T:cmp::Eq> cmp::Eq for Cell<T> {\n     fn eq(&self, other: &Cell<T>) -> bool {\n-        unsafe {\n-            let frozen_self: &Option<T> = transmute(&mut self.value);\n-            let frozen_other: &Option<T> = transmute(&mut other.value);\n-            frozen_self == frozen_other\n-        }\n+        (self.value) == (other.value)\n     }\n     fn ne(&self, other: &Cell<T>) -> bool { !self.eq(other) }\n }\n@@ -46,6 +42,7 @@ pub fn empty_cell<T>() -> Cell<T> {\n pub impl<T> Cell<T> {\n     /// Yields the value, failing if the cell is empty.\n     fn take(&self) -> T {\n+        let mut self = unsafe { transmute_mut(self) };\n         if self.is_empty() {\n             fail!(~\"attempt to take an empty cell\");\n         }\n@@ -57,6 +54,7 @@ pub impl<T> Cell<T> {\n \n     /// Returns the value, failing if the cell is full.\n     fn put_back(&self, value: T) {\n+        let mut self = unsafe { transmute_mut(self) };\n         if !self.is_empty() {\n             fail!(~\"attempt to put a value back into a full cell\");\n         }"}, {"sha": "18ea169d96e5cbcb64f968783b86f0e2c96c7bed", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=c16919d3a8e83e4c72668f6ad89d48f6ba8341f6", "patch": "@@ -2274,8 +2274,8 @@ pub mod raw {\n \n     /// Sets the length of the string and adds the null terminator\n     pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n-        let v: **vec::raw::VecRepr = cast::transmute(v);\n-        let repr: *vec::raw::VecRepr = *v;\n+        let v: **mut vec::raw::VecRepr = cast::transmute(v);\n+        let repr: *mut vec::raw::VecRepr = *v;\n         (*repr).unboxed.fill = new_len + 1u;\n         let null = ptr::mut_offset(cast::transmute(&((*repr).unboxed.data)),\n                                    new_len);"}, {"sha": "e2b57a8dd3edac1b3309d0fd1a74759332f0f1db", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=c16919d3a8e83e4c72668f6ad89d48f6ba8341f6", "patch": "@@ -106,13 +106,13 @@ fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n  ****************************************************************************/\n \n struct ArcData<T> {\n-    mut count:     libc::intptr_t,\n+    count:     libc::intptr_t,\n     // FIXME(#3224) should be able to make this non-option to save memory\n-    mut data:      Option<T>,\n+    data:      Option<T>,\n }\n \n struct ArcDestruct<T> {\n-    mut data: *libc::c_void,\n+    data: *libc::c_void,\n }\n \n #[unsafe_destructor]\n@@ -122,7 +122,7 @@ impl<T> Drop for ArcDestruct<T>{\n             do task::unkillable {\n                 let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n                 let new_count =\n-                    intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n+                    intrinsics::atomic_xsub(cast::transmute_mut(&data.count), 1) - 1;\n                 assert!(new_count >= 0);\n                 if new_count == 0 {\n                     // drop glue takes over.\n@@ -186,7 +186,7 @@ pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n+        let new_count = intrinsics::atomic_xadd(cast::transmute_mut(&ptr.count), 1) + 1;\n         assert!(new_count >= 2);\n         cast::forget(ptr);\n     }\n@@ -252,15 +252,15 @@ pub impl LittleLock {\n     }\n }\n \n-struct ExData<T> { lock: LittleLock, mut failed: bool, mut data: T, }\n+struct ExData<T> { lock: LittleLock, failed: bool, data: T, }\n /**\n  * An arc over mutable data that is protected by a lock. For library use only.\n  */\n pub struct Exclusive<T> { x: SharedMutableState<ExData<T>> }\n \n pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n-        lock: LittleLock(), mut failed: false, mut data: user_data\n+        lock: LittleLock(), failed: false, data: user_data\n     };\n     Exclusive { x: unsafe { shared_mutable_state(data) } }\n }"}, {"sha": "21e876ea0fb02e6da62a4b916822aa8edef93cf1", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16919d3a8e83e4c72668f6ad89d48f6ba8341f6/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=c16919d3a8e83e4c72668f6ad89d48f6ba8341f6", "patch": "@@ -633,7 +633,7 @@ pub fn push<T>(v: &mut ~[T], initval: T) {\n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n-    let repr: **raw::VecRepr = ::cast::transmute(v);\n+    let repr: **mut raw::VecRepr = ::cast::transmute(v);\n     let fill = (**repr).unboxed.fill;\n     (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n     let p = addr_of(&((**repr).unboxed.data));\n@@ -2148,8 +2148,8 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n \n /// The internal 'unboxed' representation of a vector\n pub struct UnboxedVecRepr {\n-    mut fill: uint,\n-    mut alloc: uint,\n+    fill: uint,\n+    alloc: uint,\n     data: u8\n }\n \n@@ -2171,8 +2171,8 @@ pub mod raw {\n     }\n \n     pub struct SliceRepr {\n-        mut data: *u8,\n-        mut len: uint\n+        data: *u8,\n+        len: uint\n     }\n \n     /**\n@@ -2184,7 +2184,7 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n-        let repr: **VecRepr = ::cast::transmute(v);\n+        let repr: **mut VecRepr = ::cast::transmute(v);\n         (**repr).unboxed.fill = new_len * sys::nonzero_size_of::<T>();\n     }\n "}]}