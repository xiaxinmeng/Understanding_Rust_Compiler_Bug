{"sha": "3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMzZmYThjM2ZlNGQxZDYxZGZkMWI3YTEyNTdlNmQ5OTE4MTcyYzQ=", "commit": {"author": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-05-15T06:15:56Z"}, "committer": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-05-15T06:15:56Z"}, "message": "Get closer to successful compilation", "tree": {"sha": "d8510c0143bbb687120c23cd64700cd8d3f99b6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8510c0143bbb687120c23cd64700cd8d3f99b6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4", "html_url": "https://github.com/rust-lang/rust/commit/3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4/comments", "author": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f03518bfad10481f5df900f7e15bab368f1fec04", "url": "https://api.github.com/repos/rust-lang/rust/commits/f03518bfad10481f5df900f7e15bab368f1fec04", "html_url": "https://github.com/rust-lang/rust/commit/f03518bfad10481f5df900f7e15bab368f1fec04"}], "stats": {"total": 398, "additions": 243, "deletions": 155}, "files": [{"sha": "dd3ad999fc646505ed758efcbb5f2e6190f62485", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 243, "deletions": 155, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=3b36fa8c3fe4d1d61dfd1b7a1257e6d9918172c4", "patch": "@@ -8,26 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::borrow_set::BorrowSet;\n+use borrow_check::borrow_set::{BorrowSet, BorrowData};\n use borrow_check::location::LocationTable;\n use borrow_check::{JustWrite, WriteAndRead};\n use borrow_check::{ShallowOrDeep, Deep, Shallow};\n use borrow_check::{ReadOrWrite, Activation, Read, Reservation, Write};\n use borrow_check::{Context, ContextKind};\n use borrow_check::{LocalMutationIsAllowed, MutateMode};\n+use borrow_check::ArtificialField;\n+use borrow_check::{ReadKind, WriteKind, Overlap};\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::facts::AllFacts;\n+use dataflow::move_paths::indexes::BorrowIndex;\n use rustc::hir;\n use rustc::infer::InferCtxt;\n-use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::Place::Projection;\n-use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n-use rustc::mir::{Local, PlaceProjection, ProjectionElem};\n+use rustc::mir::{BasicBlock, Location, Mir, Place, Rvalue, Projection};\n+use rustc::mir::{Local, ProjectionElem};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n-use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, CanonicalTy, ClosureSubsts};\n+use rustc::mir::{Field, Operand, BorrowKind};\n+use rustc::ty;\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::iter;\n \n pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -43,7 +46,7 @@ pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n     }\n \n     let mut ig = InvalidationGenerator {\n-        all_facts: all_facts.unwrap()\n+        all_facts: &mut all_facts.unwrap(),\n         borrow_set,\n         infcx,\n         regioncx,\n@@ -64,19 +67,19 @@ struct InvalidationGenerator<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n \n /// Visits the whole MIR and generates invalidates() facts\n /// Most of the code implementing this was stolen from borrow_check/mod.rs\n-impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n-    fn visit_statement(&mut self, block: BasicBlock, statement: &Statemnt<'tcx>, location: Location) {\n+impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'gcx, 'tcx> {\n+    fn visit_statement(&mut self, block: BasicBlock, statement: &Statement<'tcx>, location: Location) {\n         match statement.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n-                self.consumer_rvalue(\n+                self.consume_rvalue(\n                     ContextKind::AssignRhs.new(location),\n-                    (rhs, location),\n-                    locaiton\n+                    rhs,\n+                    location\n                 );\n \n                 self.mutate_place(\n                     ContextKind::AssignLhs.new(location),\n-                    (lhs, location),\n+                    lhs,\n                     Shallow(None),\n                     JustWrite\n                 );\n@@ -87,7 +90,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n             } => {\n                 self.mutate_place(\n                     ContextKind::SetDiscrim.new(location),\n-                    (place, location),\n+                    place,\n                     Shallow(Some(ArtificialField::Discriminant)),\n                     JustWrite,\n                 );\n@@ -104,21 +107,21 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n                         // be encoeded through MIR place derefs instead.\n                         self.access_place(\n                             context,\n-                            (output, location),\n+                            output,\n                             (Deep, Read(ReadKind::Copy)),\n                             LocalMutationIsAllowed::No,\n                         );\n                     } else {\n                         self.mutate_place(\n                             context,\n-                            (output, location),\n+                            output,\n                             if o.is_rw { Deep } else { Shallow(None) },\n                             if o.is_rw { WriteAndRead } else { JustWrite },\n                         );\n                     }\n                 }\n                 for input in inputs {\n-                    self.consume_operand(context, (input, location));\n+                    self.consume_operand(context, input);\n                 }\n             }\n             // EndRegion matters to older NLL/MIR AST borrowck, not to alias NLL\n@@ -133,14 +136,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     ContextKind::StorageDead.new(location),\n-                    (&Place::Local(local), location),\n+                    &Place::Local(local),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n         }\n \n-        self.super_statment(block, statement, location);\n+        self.super_statement(block, statement, location);\n     }\n \n     fn visit_terminator(\n@@ -156,7 +159,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n                 values: _,\n                 targets: _,\n             } => {\n-                self.consume_operand(ContextKind::SwitchInt.new(loc,c (discr, location)));\n+                self.consume_operand(ContextKind::SwitchInt.new(location), discr);\n             }\n             TerminatorKind::Drop {\n                 location: ref drop_place,\n@@ -167,7 +170,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n                 let gcx = tcx.global_tcx();\n                 let drop_place_ty = drop_place.ty(self.mir, tcx);\n                 let drop_place_ty = tcx.erase_regions(&drop_place_ty).to_ty(tcx);\n-                self.visit_terminator_drop(loc, term)\n+                self.visit_terminator_drop(location, terminator, drop_place, drop_place_ty);\n             }\n             TerminatorKind::DropAndReplace {\n                 location: ref drop_place,\n@@ -176,14 +179,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n                 unwind: _,\n             } => {\n                 self.mutate_place(\n-                    ContextKind::DropAndReplace.new(loc),\n-                    (drop_place, location),\n+                    ContextKind::DropAndReplace.new(location),\n+                    drop_place,\n                     Deep,\n                     JustWrite,\n                 );\n                 self.consume_operand(\n-                    ContextKind::DropAndReplace.new(loc),\n-                    (new_value, location),\n+                    ContextKind::DropAndReplace.new(location),\n+                    new_value,\n                 );\n             }\n             TerminatorKind::Call {\n@@ -192,17 +195,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n                 ref destination,\n                 cleanup: _,\n             } => {\n-                self.consume_operand(ContextKind::CallOperator.new(loc), (func, location));\n+                self.consume_operand(ContextKind::CallOperator.new(location), func);\n                 for arg in args {\n-                    self.consume_operand(\n-                        ContextKind::CallOperand.new(loc),\n-                        (arg, location),\n-                    );\n+                    self.consume_operand(ContextKind::CallOperand.new(location), arg);\n                 }\n                 if let Some((ref dest, _ /*bb*/)) = *destination {\n                     self.mutate_place(\n-                        ContextKind::CallDest.new(loc),\n-                        (dest, location),\n+                        ContextKind::CallDest.new(location),\n+                        dest,\n                         Deep,\n                         JustWrite,\n                     );\n@@ -215,22 +215,19 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n                 target: _,\n                 cleanup: _,\n             } => {\n-                self.consume_operand(ContextKind::Assert.new(loc), (cond, location));\n+                self.consume_operand(ContextKind::Assert.new(location), cond);\n                 use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n                 if let BoundsCheck { ref len, ref index } = *msg {\n-                    self.consume_operand(ContextKind::Assert.new(loc), (len, location));\n-                    self.consume_operand(\n-                        ContextKind::Assert.new(loc),\n-                        (index, location),\n-                    );\n+                    self.consume_operand(ContextKind::Assert.new(location), len);\n+                    self.consume_operand(ContextKind::Assert.new(location), index);\n                 }\n             }\n             TerminatorKind::Yield {\n                 ref value,\n                 resume: _,\n                 drop: _,\n             } => {\n-                self.consume_operand(ContextKind::Yield.new(loc), (value, location));\n+                self.consume_operand(ContextKind::Yield.new(location), value);\n \n                 // ** TODO(bob_twinkles) figure out what the equivalent of this is\n                 // if self.movable_generator {\n@@ -278,25 +275,24 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n     }\n }\n \n-impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n+impl<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> InvalidationGenerator<'cg, 'cx, 'gcx, 'tcx> {\n     /// Simulates dropping of a variable\n     fn visit_terminator_drop(\n         &mut self,\n         loc: Location,\n         term: &Terminator<'tcx>,\n         drop_place: &Place<'tcx>,\n         erased_drop_place_ty: ty::Ty<'gcx>,\n-        location: Location\n     ) {\n         let gcx = self.infcx.tcx.global_tcx();\n         let drop_field = |\n-        ig: &mut InvalidationGenerator<'cx, 'gcx, 'tcx>,\n+        ig: &mut InvalidationGenerator<'cg, 'cx, 'gcx, 'tcx>,\n         (index, field): (usize, ty::Ty<'gcx>),\n         | {\n-            let field_ty = gcx.normalize_erasing_regions(mir.param_env, field);\n+            let field_ty = gcx.normalize_erasing_regions(self.mir.param_env, field);\n             let place = drop_place.clone().field(Field::new(index), field_ty);\n \n-            ig.visit_terminator_drop(loc, term, &place, field_ty, location);\n+            ig.visit_terminator_drop(loc, term, &place, field_ty);\n         };\n \n         match erased_drop_place_ty.sty {\n@@ -319,13 +315,18 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n             }\n             // Closures and generators also have disjoint fields, but they are only\n             // directly accessed in the body of the closure/generator.\n-            ty::TyClosure(def, substs)\n-            | ty::TyGenerator(def, substs, ..)\n+            ty::TyGenerator(def, substs, ..)\n                 if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n             => {\n                 substs.upvar_tys(def, self.infcx.tcx).enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n+            ty::TyClosure(def, substs)\n+                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n+                => {\n+                    substs.upvar_tys(def, self.infcx.tcx).enumerate()\n+                        .for_each(|field| drop_field(self, field));\n+                }\n             _ => {\n                 // We have now refined the type of the value being\n                 // dropped (potentially) to just the type of a\n@@ -335,7 +336,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n                 if erased_drop_place_ty.needs_drop(gcx, self.param_env) {\n                     self.access_place(\n                         ContextKind::Drop.new(loc),\n-                        (drop_place, location),\n+                        drop_place,\n                         (Deep, Write(WriteKind::StorageDeadOrDrop)),\n                         LocalMutationIsAllowed::Yes,\n                     );\n@@ -348,13 +349,13 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n     fn mutate_place(\n         &mut self,\n         context: Context,\n-        place_location: &(Place<'tcx>, location),\n-        kind: (ShallowOrDeep, ReadOrWrite),\n+        place: &Place<'tcx>,\n+        kind: ShallowOrDeep,\n         mode: MutateMode,\n     ) {\n         self.access_place(\n             context,\n-            place_location,\n+            place,\n             (kind, Write(WriteKind::Mutate)),\n             LocalMutationIsAllowed::ExceptUpvars,\n         );\n@@ -364,22 +365,22 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n     fn consume_operand(\n         &mut self,\n         context: Context,\n-        (operand, location): (&Operand<'tcx>, location),\n+        operand: &Operand<'tcx>,\n     ) {\n         match *operand {\n             Operand::Copy(ref place) => {\n                 self.access_place(\n                     context,\n-                    (place, location),\n+                    place,\n                     (Deep, Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n                 );\n             }\n             Operand::Move(ref place) => {\n                 self.access_place(\n                     context,\n-                    (place, location),\n-                    (Deep, Write(WriteKind::move)),\n+                    place,\n+                    (Deep, Write(WriteKind::Move)),\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n@@ -391,8 +392,8 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n     fn consume_rvalue(\n         &mut self,\n         context: Context,\n-        (rvalue, location): (&Rvalue<'tcx>, Location),\n-        _location: Location,\n+        rvalue: &Rvalue<'tcx>,\n+        location: Location,\n     ) {\n         match *rvalue {\n             Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n@@ -410,7 +411,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n \n                 self.access_place(\n                     context,\n-                    (place, location),\n+                    place,\n                     access_kind,\n                     LocalMutationIsAllowed::No,\n                 );\n@@ -420,7 +421,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n             | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n-                self.consume_operand(context, (operand, location))\n+                self.consume_operand(context, operand)\n             }\n \n             Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n@@ -431,29 +432,24 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n                 };\n                 self.access_place(\n                     context,\n-                    (place, location),\n+                    place,\n                     (Shallow(Some(af)), Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n                 );\n-                self.check_if_path_or_subpath_is_moved(\n-                    context,\n-                    InitializationRequiringAction::Use,\n-                    (place, location),\n-                );\n             }\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2)\n             | Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n-                self.consume_operand(context, (operand1, location));\n-                self.consume_operand(context, (operand2, location));\n+                self.consume_operand(context, operand1);\n+                self.consume_operand(context, operand2);\n             }\n \n             Rvalue::NullaryOp(_op, _ty) => {\n             }\n \n             Rvalue::Aggregate(ref aggregate_kind, ref operands) => {\n                 for operand in operands {\n-                    self.consume_operand(context, (operand, location));\n+                    self.consume_operand(context, operand);\n                 }\n             }\n         }\n@@ -463,34 +459,33 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n     fn access_place(\n         &mut self,\n         context: Context,\n-        place_location: (&Place<'tcx>, Location),\n+        place: &Place<'tcx>,\n         kind: (ShallowOrDeep, ReadOrWrite),\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) {\n         let (sd, rw) = kind;\n         // note: not doing check_access_permissions checks because they don't generate invalidates\n-        self.check_acess_for_conflict(context, place_location, sd, rw);\n+        self.check_access_for_conflict(context, place, sd, rw);\n     }\n \n     fn check_access_for_conflict(\n         &mut self,\n         context: Context,\n-        (place, location): (&Place<'tcx>, Location),\n+        place: &Place<'tcx>,\n         sd: ShallowOrDeep,\n         rw: ReadOrWrite,\n     ) {\n         debug!(\n-            \"invalidation::check_access_for_conflict(context={:?}, place_location={:?}, sd={:?}, \\\n+            \"invalidation::check_access_for_conflict(context={:?}, place={:?}, sd={:?}, \\\n              rw={:?})\",\n             context,\n-            (place, location),\n+            place,\n             sd,\n             rw,\n         );\n         self.each_borrow_involving_path(\n             context,\n-            (sd, place_location.0),\n-            flow_state,\n+            (sd, place),\n             |this, borrow_index, borrow| match (rw, borrow.kind) {\n                 // Obviously an activation is compatible with its own\n                 // reservation (or even prior activating uses of same\n@@ -499,84 +494,43 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n                 // NOTE: *reservations* do conflict with themselves;\n                 // thus aren't injecting unsoundenss w/ this check.)\n                 (Activation(_, activating), _) if activating == borrow_index => {\n-                    debug!(\n-                        \"check_access_for_conflict place_location: {:?} sd: {:?} rw: {:?} \\\n-                         skipping {:?} b/c activation of same borrow_index\",\n-                        (place, location),\n-                        sd,\n-                        rw,\n-                        (borrow_index, borrow),\n-                    );\n-                    Control::Continue\n+                    // Activating a borrow doesn't generate any invalidations, since we\n+                    // have already taken the reservation\n                 }\n \n                 (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n-                    Control::Continue\n+                    // Reads/reservations don't invalidate shared borrows\n                 }\n \n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if this.is_active(borrow, context.loc) {\n-                        self.generate_invalidates(borrow_index);\n-                        Control::Break\n-                    } else {\n+                    if !this.is_active(borrow, context.loc) {\n+                        // If the borrow isn't active yet, reads don't invalidate it\n                         assert!(this.allow_two_phase_borrow(borrow.kind));\n-                        Control::Continue\n+                        return;\n+                    }\n+\n+                    // Unique and mutable borrows are invalidated by reads from any\n+                    // involved path\n+                    match kind {\n+                        ReadKind::Copy => {\n+                            this.generate_invalidates(borrow_index, context.loc);\n+                        }\n+                        ReadKind::Borrow(bk) => {\n+                            this.generate_invalidates(borrow_index, context.loc);\n+                        }\n                     }\n                 }\n \n-                // ****** XXX: rewrite the rest of this function to use generate_invalidates instead of reporting errors ******\n                 (Reservation(kind), BorrowKind::Unique)\n                 | (Reservation(kind), BorrowKind::Mut { .. })\n                 | (Activation(kind, _), _)\n                 | (Write(kind), _) => {\n-                    match rw {\n-                        Reservation(_) => {\n-                            debug!(\n-                                \"recording invalid reservation of \\\n-                                 place: {:?}\",\n-                                place_span.0\n-                            );\n-                            this.reservation_error_reported.insert(place_span.0.clone());\n-                        }\n-                        Activation(_, activating) => {\n-                            debug!(\n-                                \"observing check_place for activation of \\\n-                                 borrow_index: {:?}\",\n-                                activating\n-                            );\n-                        }\n-                        Read(..) | Write(..) => {}\n-                    }\n-\n-                    match kind {\n-                        WriteKind::MutableBorrow(bk) => {\n-                            error_reported = true;\n-                            this.report_conflicting_borrow(\n-                                context,\n-                                place_span,\n-                                bk,\n-                                &borrow,\n-                            )\n-                        }\n-                        WriteKind::StorageDeadOrDrop => {\n-                            error_reported = true;\n-                            this.report_borrowed_value_does_not_live_long_enough(\n-                                context,\n-                                borrow,\n-                                place_span.1,\n-                            );\n-                        }\n-                        WriteKind::Mutate => {\n-                            error_reported = true;\n-                            this.report_illegal_mutation_of_borrowed(context, place_span, borrow)\n-                        }\n-                        WriteKind::Move => {\n-                            error_reported = true;\n-                            this.report_move_out_while_borrowed(context, place_span, &borrow)\n-                        }\n-                    }\n-                    Control::Break\n+                    // unique or mutable borrows are invalidated by writes.\n+                    // Reservations count as writes since we need to check\n+                    // that activating the borrow will be OK\n+                    // TOOD(bob_twinkles) is this actually the right thing to do?\n+                    this.generate_invalidates(borrow_index, context.loc);\n                 }\n             },\n         );\n@@ -592,8 +546,9 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n     }\n \n     /// Generate a new invalidates(L, B) fact\n-    fn generate_invalidates(&mut self, b: BorrowIndex, l: LocationIndex) {\n-        self.all_facts.invalidates.append((l, b));\n+    fn generate_invalidates(&mut self, b: BorrowIndex, l: Location) {\n+        let lidx = self.location_table.mid_index(l);\n+        self.all_facts.invalidates.push((lidx, b));\n     }\n \n     /// This function iterates over all borrows that intersect with an\n@@ -610,7 +565,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n         access_place: (ShallowOrDeep, &Place<'tcx>),\n         mut op: F,\n     ) where\n-        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n+        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>),\n     {\n         let (access, place) = access_place;\n \n@@ -620,18 +575,15 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n         let borrow_set = self.borrow_set.clone();\n-        for i in borrow_set.borrows.iter() {\n+        for i in borrow_set.borrows.indices() {\n             let borrowed = &borrow_set[i];\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {\n                 debug!(\n                     \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n                     i, borrowed, place, access\n                 );\n-                let ctrl = op(self, i, borrowed);\n-                if ctrl == Control::Break {\n-                    return;\n-                }\n+                op(self, i, borrowed);\n             }\n         }\n     }\n@@ -751,7 +703,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n                         Place::Projection(box Projection { base, elem }) => (base, elem),\n                         _ => bug!(\"place has no base?\"),\n                     };\n-                    let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let base_ty = base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n \n                     match (elem, &base_ty.sty, access) {\n                         (_, _, Shallow(Some(ArtificialField::Discriminant)))\n@@ -778,13 +730,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n                         }\n                         (\n                             ProjectionElem::Deref,\n-                            ty::TyRef(\n-                                _,\n-                                ty::TypeAndMut {\n-                                    ty: _,\n-                                    mutbl: hir::MutImmutable,\n-                                },\n-                            ),\n+                            ty::TyRef( _, _, hir::MutImmutable),\n                             _,\n                         ) => {\n                             // the borrow goes through a dereference of a shared reference.\n@@ -843,4 +789,146 @@ impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n         }\n         unreachable!(\"iter::repeat returned None\")\n     }\n+\n+    // Given that the bases of `elem1` and `elem2` are always either equal\n+    // or disjoint (and have the same type!), return the overlap situation\n+    // between `elem1` and `elem2`.\n+    fn place_element_conflict(&self, elem1: &Place<'tcx>, elem2: &Place<'tcx>) -> Overlap {\n+        match (elem1, elem2) {\n+            (Place::Local(l1), Place::Local(l2)) => {\n+                if l1 == l2 {\n+                    // the same local - base case, equal\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n+                    Overlap::EqualOrDisjoint\n+                } else {\n+                    // different locals - base case, disjoint\n+                    debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n+                    Overlap::Disjoint\n+                }\n+            }\n+            (Place::Static(static1), Place::Static(static2)) => {\n+                if static1.def_id != static2.def_id {\n+                    debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                    Overlap::Disjoint\n+                } else if self.infcx.tcx.is_static(static1.def_id) == Some(hir::Mutability::MutMutable) {\n+                    // We ignore mutable statics - they can only be unsafe code.\n+                    debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                    Overlap::Disjoint\n+                } else {\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                    Overlap::EqualOrDisjoint\n+                }\n+            }\n+            (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n+                debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n+                Overlap::Disjoint\n+            }\n+            (Place::Projection(pi1), Place::Projection(pi2)) => {\n+                match (&pi1.elem, &pi2.elem) {\n+                    (ProjectionElem::Deref, ProjectionElem::Deref) => {\n+                        // derefs (e.g. `*x` vs. `*x`) - recur.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n+                        Overlap::EqualOrDisjoint\n+                    }\n+                    (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n+                        if f1 == f2 {\n+                            // same field (e.g. `a.y` vs. `a.y`) - recur.\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                            Overlap::EqualOrDisjoint\n+                        } else {\n+                            let ty = pi1.base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                            match ty.sty {\n+                                ty::TyAdt(def, _) if def.is_union() => {\n+                                    // Different fields of a union, we are basically stuck.\n+                                    debug!(\"place_element_conflict: STUCK-UNION\");\n+                                    Overlap::Arbitrary\n+                                }\n+                                _ => {\n+                                    // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n+                                    debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                                    Overlap::Disjoint\n+                                }\n+                            }\n+                        }\n+                    }\n+                    (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n+                        // different variants are treated as having disjoint fields,\n+                        // even if they occupy the same \"space\", because it's\n+                        // impossible for 2 variants of the same enum to exist\n+                        // (and therefore, to be borrowed) at the same time.\n+                        //\n+                        // Note that this is different from unions - we *do* allow\n+                        // this code to compile:\n+                        //\n+                        // ```\n+                        // fn foo(x: &mut Result<i32, i32>) {\n+                        //     let mut v = None;\n+                        //     if let Ok(ref mut a) = *x {\n+                        //         v = Some(a);\n+                        //     }\n+                        //     // here, you would *think* that the\n+                        //     // *entirety* of `x` would be borrowed,\n+                        //     // but in fact only the `Ok` variant is,\n+                        //     // so the `Err` variant is *entirely free*:\n+                        //     if let Err(ref mut a) = *x {\n+                        //         v = Some(a);\n+                        //     }\n+                        //     drop(v);\n+                        // }\n+                        // ```\n+                        if v1 == v2 {\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                            Overlap::EqualOrDisjoint\n+                        } else {\n+                            debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                            Overlap::Disjoint\n+                        }\n+                    }\n+                    (ProjectionElem::Index(..), ProjectionElem::Index(..))\n+                    | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n+                    | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n+                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n+                    | (\n+                        ProjectionElem::ConstantIndex { .. },\n+                        ProjectionElem::ConstantIndex { .. },\n+                    )\n+                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                        // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n+                        // (if the indexes differ) or equal (if they are the same), so this\n+                        // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n+                        //\n+                        // Note that by construction, MIR at borrowck can't subdivide\n+                        // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n+                        // are only present in slice patterns, and we \"merge together\" nested\n+                        // slice patterns. That means we don't have to think about these. It's\n+                        // probably a good idea to assert this somewhere, but I'm too lazy.\n+                        //\n+                        // FIXME(#8636) we might want to return Disjoint if\n+                        // both projections are constant and disjoint.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n+                        Overlap::EqualOrDisjoint\n+                    }\n+\n+                    (ProjectionElem::Deref, _)\n+                    | (ProjectionElem::Field(..), _)\n+                    | (ProjectionElem::Index(..), _)\n+                    | (ProjectionElem::ConstantIndex { .. }, _)\n+                    | (ProjectionElem::Subslice { .. }, _)\n+                    | (ProjectionElem::Downcast(..), _) => bug!(\n+                        \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+                        elem1,\n+                        elem2\n+                    ),\n+                }\n+            }\n+            (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n+                \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n+                elem1,\n+                elem2\n+            ),\n+        }\n+    }\n }"}]}