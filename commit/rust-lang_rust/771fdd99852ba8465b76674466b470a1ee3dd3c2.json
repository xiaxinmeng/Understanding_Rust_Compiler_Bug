{"sha": "771fdd99852ba8465b76674466b470a1ee3dd3c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MWZkZDk5ODUyYmE4NDY1Yjc2Njc0NDY2YjQ3MGExZWUzZGQzYzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-04-08T11:23:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-04-16T11:03:41Z"}, "message": "enforce that R1: R2 requires univ(R1) <= univ(R2)", "tree": {"sha": "3c79115072f66974cb8e613c0895ffea63e7799f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c79115072f66974cb8e613c0895ffea63e7799f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/771fdd99852ba8465b76674466b470a1ee3dd3c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/771fdd99852ba8465b76674466b470a1ee3dd3c2", "html_url": "https://github.com/rust-lang/rust/commit/771fdd99852ba8465b76674466b470a1ee3dd3c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/771fdd99852ba8465b76674466b470a1ee3dd3c2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "534a41a32952d36ec73656357777ebbea707aeb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/534a41a32952d36ec73656357777ebbea707aeb4", "html_url": "https://github.com/rust-lang/rust/commit/534a41a32952d36ec73656357777ebbea707aeb4"}], "stats": {"total": 162, "additions": 152, "deletions": 10}, "files": [{"sha": "9533d61b7e83ec56859af276d9935494c13474f9", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 79, "deletions": 5, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/771fdd99852ba8465b76674466b470a1ee3dd3c2/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771fdd99852ba8465b76674466b470a1ee3dd3c2/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=771fdd99852ba8465b76674466b470a1ee3dd3c2", "patch": "@@ -321,10 +321,75 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let num_sccs = constraints_scc.num_sccs();\n         let mut scc_universes = IndexVec::from_elem_n(ty::UniverseIndex::MAX, num_sccs);\n \n+        debug!(\"compute_scc_universes()\");\n+\n+        // For each region R in universe U, ensure that the universe for the SCC\n+        // that contains R is \"no bigger\" than U. This effectively sets the universe\n+        // for each SCC to be the minimum of the regions within.\n         for (region_vid, region_definition) in definitions.iter_enumerated() {\n             let scc = constraints_scc.scc(region_vid);\n             let scc_universe = &mut scc_universes[scc];\n-            *scc_universe = ::std::cmp::min(*scc_universe, region_definition.universe);\n+            let scc_min = std::cmp::min(region_definition.universe, *scc_universe);\n+            if scc_min != *scc_universe {\n+                *scc_universe = scc_min;\n+                debug!(\n+                    \"compute_scc_universes: lowered universe of {scc:?} to {scc_min:?} \\\n+                    because it contains {region_vid:?} in {region_universe:?}\",\n+                    scc = scc,\n+                    scc_min = scc_min,\n+                    region_vid = region_vid,\n+                    region_universe = region_definition.universe,\n+                );\n+            }\n+        }\n+\n+        // Walk each SCC `A` and `B` such that `A: B`\n+        // and ensure that universe(A) can see universe(B).\n+        //\n+        // This serves to enforce the 'empty/placeholder' hierarchy\n+        // (described in more detail on `RegionKind`):\n+        //\n+        // ```\n+        // static -----+\n+        //   |         |\n+        // empty(U0) placeholder(U1)\n+        //   |      /\n+        // empty(U1)\n+        // ```\n+        //\n+        // In particular, imagine we have variables R0 in U0 and R1\n+        // created in U1, and constraints like this;\n+        //\n+        // ```\n+        // R1: !1 // R1 outlives the placeholder in U1\n+        // R1: R0 // R1 outlives R0\n+        // ```\n+        //\n+        // Here, we wish for R1 to be `'static`, because it\n+        // cannot outlive `placeholder(U1)` and `empty(U0)` any other way.\n+        //\n+        // Thanks to this loop, what happens is that the `R1: R0`\n+        // constraint lowers the universe of `R1` to `U0`, which in turn\n+        // means that the `R1: !1` constraint will (later) cause\n+        // `R1` to become `'static`.\n+        for scc_a in constraints_scc.all_sccs() {\n+            for &scc_b in constraints_scc.successors(scc_a) {\n+                let scc_universe_a = scc_universes[scc_a];\n+                let scc_universe_b = scc_universes[scc_b];\n+                let scc_universe_min = std::cmp::min(scc_universe_a, scc_universe_b);\n+                if scc_universe_a != scc_universe_min {\n+                    scc_universes[scc_a] = scc_universe_min;\n+\n+                    debug!(\n+                        \"compute_scc_universes: lowered universe of {scc_a:?} to {scc_universe_min:?} \\\n+                        because {scc_a:?}: {scc_b:?} and {scc_b:?} is in universe {scc_universe_b:?}\",\n+                        scc_a = scc_a,\n+                        scc_b = scc_b,\n+                        scc_universe_min = scc_universe_min,\n+                        scc_universe_b = scc_universe_b\n+                    );\n+                }\n+            }\n         }\n \n         debug!(\"compute_scc_universes: scc_universe = {:#?}\", scc_universes);\n@@ -1773,6 +1838,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n     crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n+        debug!(\"find_sub_region_live_at: {:?} is in scc {:?}\", fr1, self.constraint_sccs.scc(fr1));\n+        debug!(\n+            \"find_sub_region_live_at: {:?} is in universe {:?}\",\n+            fr1,\n+            self.scc_universes[self.constraint_sccs.scc(fr1)]\n+        );\n         self.find_constraint_paths_between_regions(fr1, |r| {\n             // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n             debug!(\n@@ -1794,13 +1865,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         .or_else(|| {\n             // If we fail to find THAT, it may be that `fr1` is a\n             // placeholder that cannot \"fit\" into its SCC. In that\n-            // case, there should be some `r` where `fr1: r`, both\n-            // `fr1` and `r` are in the same SCC, and `fr1` is a\n+            // case, there should be some `r` where `fr1: r` and `fr1` is a\n             // placeholder that `r` cannot name. We can blame that\n             // edge.\n+            //\n+            // Remember that if `R1: R2`, then the universe of R1\n+            // must be able to name the universe of R2, because R2 will\n+            // be at least `'empty(Universe(R2))`, and `R1` must be at\n+            // larger than that.\n             self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n-                    && self.cannot_name_placeholder(r, fr1)\n+                self.cannot_name_placeholder(r, fr1)\n             })\n         })\n         .map(|(_path, r)| r)"}, {"sha": "d3964a7f515deee842f9d71fa08a2f93a2fe8dcf", "filename": "src/test/ui/nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/771fdd99852ba8465b76674466b470a1ee3dd3c2/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771fdd99852ba8465b76674466b470a1ee3dd3c2/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs?ref=771fdd99852ba8465b76674466b470a1ee3dd3c2", "patch": "@@ -0,0 +1,36 @@\n+// Test that the NLL solver cannot find a solution\n+// for `exists<R1> { forall<R1> { R2: R1 } }`.\n+//\n+// In this test, the impl should match `fn(T)` for some `T`,\n+// but we ask it to match `for<'a> fn(&'a ())`. Due to argument\n+// contravariance, this effectively requires a `T = &'b ()` where\n+// `forall<'a> { 'a: 'b }`. Therefore, we get an error.\n+//\n+// Note the use of `-Zno-leak-check` and `feature(nll)` here. These\n+// are presently required in order to skip the leak-check errors.\n+//\n+// c.f. Issue #57642.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+trait Y {\n+    type F;\n+    fn make_f() -> Self::F;\n+}\n+\n+impl<T> Y for fn(T) {\n+    type F = fn(T);\n+\n+    fn make_f() -> Self::F {\n+        |_| {}\n+    }\n+}\n+\n+fn main() {\n+    let _x = <fn(&())>::make_f();\n+    //~^ higher-ranked subtype error\n+    //~| higher-ranked subtype error\n+    //~| higher-ranked subtype error\n+}"}, {"sha": "70fb877d716899e276f49c13f99fe6f4c8b15bdc", "filename": "src/test/ui/nll/relate_tys/impl-fn-ignore-binder-via-bottom.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/771fdd99852ba8465b76674466b470a1ee3dd3c2/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/771fdd99852ba8465b76674466b470a1ee3dd3c2/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr?ref=771fdd99852ba8465b76674466b470a1ee3dd3c2", "patch": "@@ -0,0 +1,20 @@\n+error: higher-ranked subtype error\n+  --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n+   |\n+LL |     let _x = <fn(&())>::make_f();\n+   |              ^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n+   |\n+LL |     let _x = <fn(&())>::make_f();\n+   |              ^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n+   |\n+LL |     let _x = <fn(&())>::make_f();\n+   |              ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "298a6ef7ab3c5b85551b5621b91a7eed9cce79ca", "filename": "src/test/ui/nll/type-check-pointer-comparisons.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/771fdd99852ba8465b76674466b470a1ee3dd3c2/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771fdd99852ba8465b76674466b470a1ee3dd3c2/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs?ref=771fdd99852ba8465b76674466b470a1ee3dd3c2", "patch": "@@ -21,13 +21,13 @@ fn compare_fn_ptr<'a, 'b, 'c>(f: fn(&'c mut &'a i32), g: fn(&'c mut &'b i32)) {\n }\n \n fn compare_hr_fn_ptr<'a>(f: fn(&'a i32), g: fn(&i32)) {\n-    // Ideally this should compile with the operands swapped as well, but HIR\n-    // type checking prevents it (and stops compilation) for now.\n-    f == g; // OK\n+    f == g;\n+    //~^ ERROR higher-ranked subtype error\n }\n \n fn compare_const_fn_ptr<'a>(f: *const fn(&'a i32), g: *const fn(&i32)) {\n-    f == g; // OK\n+    f == g;\n+    //~^ ERROR higher-ranked subtype error\n }\n \n fn main() {}"}, {"sha": "0fc7480260fdb96eb7ee83663f1590debb079ff0", "filename": "src/test/ui/nll/type-check-pointer-comparisons.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/771fdd99852ba8465b76674466b470a1ee3dd3c2/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/771fdd99852ba8465b76674466b470a1ee3dd3c2/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr?ref=771fdd99852ba8465b76674466b470a1ee3dd3c2", "patch": "@@ -76,5 +76,17 @@ LL |     f == g;\n \n help: `'a` and `'b` must be the same: replace one with the other\n \n-error: aborting due to 6 previous errors\n+error: higher-ranked subtype error\n+  --> $DIR/type-check-pointer-comparisons.rs:24:5\n+   |\n+LL |     f == g;\n+   |     ^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/type-check-pointer-comparisons.rs:29:5\n+   |\n+LL |     f == g;\n+   |     ^^^^^^\n+\n+error: aborting due to 8 previous errors\n "}]}