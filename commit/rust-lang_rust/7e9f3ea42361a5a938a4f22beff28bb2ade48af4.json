{"sha": "7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlOWYzZWE0MjM2MWE1YTkzOGE0ZjIyYmVmZjI4YmIyYWRlNDhhZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-30T16:41:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-30T16:41:51Z"}, "message": "auto merge of #13863 : huonw/rust/re-tweaks, r=pcwalton\n\nMostly code style e.g. avoiding `~` and using `for` + iterators.", "tree": {"sha": "8af8bbb1fb51a4c12ffb0209bed70466475c1429", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8af8bbb1fb51a4c12ffb0209bed70466475c1429"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "html_url": "https://github.com/rust-lang/rust/commit/7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad37c0b97c1a5403268e2addbcae28c51d15a924", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad37c0b97c1a5403268e2addbcae28c51d15a924", "html_url": "https://github.com/rust-lang/rust/commit/ad37c0b97c1a5403268e2addbcae28c51d15a924"}, {"sha": "33f98ada02cccb58f700b1b26059ae63d75917c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/33f98ada02cccb58f700b1b26059ae63d75917c4", "html_url": "https://github.com/rust-lang/rust/commit/33f98ada02cccb58f700b1b26059ae63d75917c4"}], "stats": {"total": 218, "additions": 101, "deletions": 117}, "files": [{"sha": "e5166c6c17cb469955347a4ab04374b8bb462b8a", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "patch": "@@ -13,7 +13,6 @@\n #![allow(visible_private_types)]\n \n use std::cmp;\n-use std::iter;\n use parse;\n use parse::{\n     Flags, FLAG_EMPTY,\n@@ -89,7 +88,7 @@ pub struct Program {\n \n impl Program {\n     /// Compiles a Regex given its AST.\n-    pub fn new(ast: ~parse::Ast) -> (Program, ~[Option<~str>]) {\n+    pub fn new(ast: parse::Ast) -> (Program, Vec<Option<~str>>) {\n         let mut c = Compiler {\n             insts: Vec::with_capacity(100),\n             names: Vec::with_capacity(10),\n@@ -104,16 +103,16 @@ impl Program {\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n         let mut pre = StrBuf::with_capacity(5);\n-        for i in iter::range(1, c.insts.len()) {\n-            match *c.insts.get(i) {\n+        for inst in c.insts.slice_from(1).iter() {\n+            match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push_char(c),\n                 _ => break\n             }\n         }\n \n-        let names = c.names.as_slice().into_owned();\n+        let Compiler { insts, names } = c;\n         let prog = Program {\n-            insts: c.insts,\n+            insts: insts,\n             prefix: pre.into_owned(),\n         };\n         (prog, names)\n@@ -144,48 +143,48 @@ struct Compiler<'r> {\n // The only tricky thing here is patching jump/split instructions to point to\n // the right instruction.\n impl<'r> Compiler<'r> {\n-    fn compile(&mut self, ast: ~parse::Ast) {\n+    fn compile(&mut self, ast: parse::Ast) {\n         match ast {\n-            ~Nothing => {},\n-            ~Literal(c, flags) => self.push(OneChar(c, flags)),\n-            ~Dot(nl) => self.push(Any(nl)),\n-            ~Class(ranges, flags) =>\n+            Nothing => {},\n+            Literal(c, flags) => self.push(OneChar(c, flags)),\n+            Dot(nl) => self.push(Any(nl)),\n+            Class(ranges, flags) =>\n                 self.push(CharClass(ranges, flags)),\n-            ~Begin(flags) => self.push(EmptyBegin(flags)),\n-            ~End(flags) => self.push(EmptyEnd(flags)),\n-            ~WordBoundary(flags) => self.push(EmptyWordBoundary(flags)),\n-            ~Capture(cap, name, x) => {\n+            Begin(flags) => self.push(EmptyBegin(flags)),\n+            End(flags) => self.push(EmptyEnd(flags)),\n+            WordBoundary(flags) => self.push(EmptyWordBoundary(flags)),\n+            Capture(cap, name, x) => {\n                 let len = self.names.len();\n                 if cap >= len {\n                     self.names.grow(10 + cap - len, &None)\n                 }\n                 *self.names.get_mut(cap) = name;\n \n                 self.push(Save(2 * cap));\n-                self.compile(x);\n+                self.compile(*x);\n                 self.push(Save(2 * cap + 1));\n             }\n-            ~Cat(xs) => {\n+            Cat(xs) => {\n                 for x in xs.move_iter() {\n                     self.compile(x)\n                 }\n             }\n-            ~Alt(x, y) => {\n+            Alt(x, y) => {\n                 let split = self.empty_split(); // push: split 0, 0\n                 let j1 = self.insts.len();\n-                self.compile(x);                // push: insts for x\n+                self.compile(*x);                // push: insts for x\n                 let jmp = self.empty_jump();    // push: jmp 0\n                 let j2 = self.insts.len();\n-                self.compile(y);                // push: insts for y\n+                self.compile(*y);                // push: insts for y\n                 let j3 = self.insts.len();\n \n                 self.set_split(split, j1, j2);  // split 0, 0 -> split j1, j2\n                 self.set_jump(jmp, j3);         // jmp 0      -> jmp j3\n             }\n-            ~Rep(x, ZeroOne, g) => {\n+            Rep(x, ZeroOne, g) => {\n                 let split = self.empty_split();\n                 let j1 = self.insts.len();\n-                self.compile(x);\n+                self.compile(*x);\n                 let j2 = self.insts.len();\n \n                 if g.is_greedy() {\n@@ -194,11 +193,11 @@ impl<'r> Compiler<'r> {\n                     self.set_split(split, j2, j1);\n                 }\n             }\n-            ~Rep(x, ZeroMore, g) => {\n+            Rep(x, ZeroMore, g) => {\n                 let j1 = self.insts.len();\n                 let split = self.empty_split();\n                 let j2 = self.insts.len();\n-                self.compile(x);\n+                self.compile(*x);\n                 let jmp = self.empty_jump();\n                 let j3 = self.insts.len();\n \n@@ -209,9 +208,9 @@ impl<'r> Compiler<'r> {\n                     self.set_split(split, j3, j2);\n                 }\n             }\n-            ~Rep(x, OneMore, g) => {\n+            Rep(x, OneMore, g) => {\n                 let j1 = self.insts.len();\n-                self.compile(x);\n+                self.compile(*x);\n                 let split = self.empty_split();\n                 let j2 = self.insts.len();\n "}, {"sha": "b94271622d7e9014d95c1020037f26a2e8286a0f", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "patch": "@@ -362,7 +362,7 @@\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n \n #![feature(macro_rules, phase)]\n-#![deny(missing_doc)]\n+#![deny(missing_doc, deprecated_owned_vector)]\n \n extern crate collections;\n #[cfg(test)]"}, {"sha": "094da4ae269b50239053628315ca3cb77294f4e9", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "patch": "@@ -62,7 +62,7 @@ pub enum Ast {\n     Capture(uint, Option<~str>, ~Ast),\n     // Represent concatenation as a flat vector to avoid blowing the\n     // stack in the compiler.\n-    Cat(Vec<~Ast>),\n+    Cat(Vec<Ast>),\n     Alt(~Ast, ~Ast),\n     Rep(~Ast, Repeater, Greed),\n }\n@@ -103,7 +103,7 @@ impl Greed {\n /// state.\n #[deriving(Show)]\n enum BuildAst {\n-    Ast(~Ast),\n+    Ast(Ast),\n     Paren(Flags, uint, ~str), // '('\n     Bar, // '|'\n }\n@@ -152,7 +152,7 @@ impl BuildAst {\n         }\n     }\n \n-    fn unwrap(self) -> Result<~Ast, Error> {\n+    fn unwrap(self) -> Result<Ast, Error> {\n         match self {\n             Ast(x) => Ok(x),\n             _ => fail!(\"Tried to unwrap non-AST item: {}\", self),\n@@ -188,7 +188,7 @@ struct Parser<'a> {\n     names: Vec<~str>,\n }\n \n-pub fn parse(s: &str) -> Result<~Ast, Error> {\n+pub fn parse(s: &str) -> Result<Ast, Error> {\n     Parser {\n         chars: s.chars().collect(),\n         chari: 0,\n@@ -200,7 +200,7 @@ pub fn parse(s: &str) -> Result<~Ast, Error> {\n }\n \n impl<'a> Parser<'a> {\n-    fn parse(&mut self) -> Result<~Ast, Error> {\n+    fn parse(&mut self) -> Result<Ast, Error> {\n         loop {\n             let c = self.cur();\n             match c {\n@@ -243,7 +243,7 @@ impl<'a> Parser<'a> {\n                     // alternate and make it a capture.\n                     if cap.is_some() {\n                         let ast = try!(self.pop_ast());\n-                        self.push(~Capture(cap.unwrap(), cap_name, ast));\n+                        self.push(Capture(cap.unwrap(), cap_name, ~ast));\n                     }\n                 }\n                 '|' => {\n@@ -294,14 +294,14 @@ impl<'a> Parser<'a> {\n         self.chari < self.chars.len()\n     }\n \n-    fn pop_ast(&mut self) -> Result<~Ast, Error> {\n+    fn pop_ast(&mut self) -> Result<Ast, Error> {\n         match self.stack.pop().unwrap().unwrap() {\n             Err(e) => Err(e),\n             Ok(ast) => Ok(ast),\n         }\n     }\n \n-    fn push(&mut self, ast: ~Ast) {\n+    fn push(&mut self, ast: Ast) {\n         self.stack.push(Ast(ast))\n     }\n \n@@ -323,29 +323,29 @@ impl<'a> Parser<'a> {\n         }\n         let ast = try!(self.pop_ast());\n         match ast {\n-            ~Begin(_) | ~End(_) | ~WordBoundary(_) =>\n+            Begin(_) | End(_) | WordBoundary(_) =>\n                 return self.err(\n                     \"Repeat arguments cannot be empty width assertions.\"),\n             _ => {}\n         }\n         let greed = try!(self.get_next_greedy());\n-        self.push(~Rep(ast, rep, greed));\n+        self.push(Rep(~ast, rep, greed));\n         Ok(())\n     }\n \n     fn push_literal(&mut self, c: char) -> Result<(), Error> {\n         match c {\n             '.' => {\n-                self.push(~Dot(self.flags))\n+                self.push(Dot(self.flags))\n             }\n             '^' => {\n-                self.push(~Begin(self.flags))\n+                self.push(Begin(self.flags))\n             }\n             '$' => {\n-                self.push(~End(self.flags))\n+                self.push(End(self.flags))\n             }\n             _ => {\n-                self.push(~Literal(c, self.flags))\n+                self.push(Literal(c, self.flags))\n             }\n         }\n         Ok(())\n@@ -362,7 +362,7 @@ impl<'a> Parser<'a> {\n                 FLAG_EMPTY\n             };\n         let mut ranges: Vec<(char, char)> = vec!();\n-        let mut alts: Vec<~Ast> = vec!();\n+        let mut alts: Vec<Ast> = vec!();\n \n         if self.peek_is(1, ']') {\n             try!(self.expect(']'))\n@@ -378,8 +378,8 @@ impl<'a> Parser<'a> {\n             match c {\n                 '[' =>\n                     match self.try_parse_ascii() {\n-                        Some(~Class(asciis, flags)) => {\n-                            alts.push(~Class(asciis, flags ^ negated));\n+                        Some(Class(asciis, flags)) => {\n+                            alts.push(Class(asciis, flags ^ negated));\n                             continue\n                         }\n                         Some(ast) =>\n@@ -389,12 +389,12 @@ impl<'a> Parser<'a> {\n                     },\n                 '\\\\' => {\n                     match try!(self.parse_escape()) {\n-                        ~Class(asciis, flags) => {\n-                            alts.push(~Class(asciis, flags ^ negated));\n+                        Class(asciis, flags) => {\n+                            alts.push(Class(asciis, flags ^ negated));\n                             continue\n                         }\n-                        ~Literal(c2, _) => c = c2, // process below\n-                        ~Begin(_) | ~End(_) | ~WordBoundary(_) =>\n+                        Literal(c2, _) => c = c2, // process below\n+                        Begin(_) | End(_) | WordBoundary(_) =>\n                             return self.err(\n                                 \"\\\\A, \\\\z, \\\\b and \\\\B are not valid escape \\\n                                  sequences inside a character class.\"),\n@@ -407,15 +407,15 @@ impl<'a> Parser<'a> {\n                 ']' => {\n                     if ranges.len() > 0 {\n                         let flags = negated | (self.flags & FLAG_NOCASE);\n-                        let mut ast = ~Class(combine_ranges(ranges), flags);\n+                        let mut ast = Class(combine_ranges(ranges), flags);\n                         for alt in alts.move_iter() {\n-                            ast = ~Alt(alt, ast)\n+                            ast = Alt(~alt, ~ast)\n                         }\n                         self.push(ast);\n                     } else if alts.len() > 0 {\n                         let mut ast = alts.pop().unwrap();\n                         for alt in alts.move_iter() {\n-                            ast = ~Alt(alt, ast)\n+                            ast = Alt(~alt, ~ast)\n                         }\n                         self.push(ast);\n                     }\n@@ -444,7 +444,7 @@ impl<'a> Parser<'a> {\n     // and moves the parser to the final ']' character.\n     // If unsuccessful, no state is changed and None is returned.\n     // Assumes that '[' is the current character.\n-    fn try_parse_ascii(&mut self) -> Option<~Ast> {\n+    fn try_parse_ascii(&mut self) -> Option<Ast> {\n         if !self.peek_is(1, ':') {\n             return None\n         }\n@@ -473,7 +473,7 @@ impl<'a> Parser<'a> {\n             Some(ranges) => {\n                 self.chari = closer;\n                 let flags = negated | (self.flags & FLAG_NOCASE);\n-                Some(~Class(combine_ranges(ranges), flags))\n+                Some(Class(combine_ranges(ranges), flags))\n             }\n         }\n     }\n@@ -546,7 +546,7 @@ impl<'a> Parser<'a> {\n             for _ in iter::range(0, min) {\n                 self.push(ast.clone())\n             }\n-            self.push(~Rep(ast, ZeroMore, greed));\n+            self.push(Rep(~ast, ZeroMore, greed));\n         } else {\n             // Require N copies of what's on the stack and then repeat it\n             // up to M times optionally.\n@@ -556,47 +556,47 @@ impl<'a> Parser<'a> {\n             }\n             if max.is_some() {\n                 for _ in iter::range(min, max.unwrap()) {\n-                    self.push(~Rep(ast.clone(), ZeroOne, greed))\n+                    self.push(Rep(~ast.clone(), ZeroOne, greed))\n                 }\n             }\n             // It's possible that we popped something off the stack but\n             // never put anything back on it. To keep things simple, add\n             // a no-op expression.\n             if min == 0 && (max.is_none() || max == Some(0)) {\n-                self.push(~Nothing)\n+                self.push(Nothing)\n             }\n         }\n         Ok(())\n     }\n \n     // Parses all escape sequences.\n     // Assumes that '\\' is the current character.\n-    fn parse_escape(&mut self) -> Result<~Ast, Error> {\n+    fn parse_escape(&mut self) -> Result<Ast, Error> {\n         try!(self.noteof(\"an escape sequence following a '\\\\'\"))\n \n         let c = self.cur();\n         if is_punct(c) {\n-            return Ok(~Literal(c, FLAG_EMPTY))\n+            return Ok(Literal(c, FLAG_EMPTY))\n         }\n         match c {\n-            'a' => Ok(~Literal('\\x07', FLAG_EMPTY)),\n-            'f' => Ok(~Literal('\\x0C', FLAG_EMPTY)),\n-            't' => Ok(~Literal('\\t', FLAG_EMPTY)),\n-            'n' => Ok(~Literal('\\n', FLAG_EMPTY)),\n-            'r' => Ok(~Literal('\\r', FLAG_EMPTY)),\n-            'v' => Ok(~Literal('\\x0B', FLAG_EMPTY)),\n-            'A' => Ok(~Begin(FLAG_EMPTY)),\n-            'z' => Ok(~End(FLAG_EMPTY)),\n-            'b' => Ok(~WordBoundary(FLAG_EMPTY)),\n-            'B' => Ok(~WordBoundary(FLAG_NEGATED)),\n+            'a' => Ok(Literal('\\x07', FLAG_EMPTY)),\n+            'f' => Ok(Literal('\\x0C', FLAG_EMPTY)),\n+            't' => Ok(Literal('\\t', FLAG_EMPTY)),\n+            'n' => Ok(Literal('\\n', FLAG_EMPTY)),\n+            'r' => Ok(Literal('\\r', FLAG_EMPTY)),\n+            'v' => Ok(Literal('\\x0B', FLAG_EMPTY)),\n+            'A' => Ok(Begin(FLAG_EMPTY)),\n+            'z' => Ok(End(FLAG_EMPTY)),\n+            'b' => Ok(WordBoundary(FLAG_EMPTY)),\n+            'B' => Ok(WordBoundary(FLAG_NEGATED)),\n             '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7' => Ok(try!(self.parse_octal())),\n             'x' => Ok(try!(self.parse_hex())),\n             'p' | 'P' => Ok(try!(self.parse_unicode_name())),\n             'd' | 'D' | 's' | 'S' | 'w' | 'W' => {\n                 let ranges = perl_unicode_class(c);\n                 let mut flags = self.flags & FLAG_NOCASE;\n                 if c.is_uppercase() { flags |= FLAG_NEGATED }\n-                Ok(~Class(ranges, flags))\n+                Ok(Class(ranges, flags))\n             }\n             _ => self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c)),\n         }\n@@ -607,7 +607,7 @@ impl<'a> Parser<'a> {\n     // name is the unicode class name.\n     // Assumes that \\p or \\P has been read (and 'p' or 'P' is the current\n     // character).\n-    fn parse_unicode_name(&mut self) -> Result<~Ast, Error> {\n+    fn parse_unicode_name(&mut self) -> Result<Ast, Error> {\n         let negated = if self.cur() == 'P' { FLAG_NEGATED } else { FLAG_EMPTY };\n         let mut name: ~str;\n         if self.peek_is(1, '{') {\n@@ -635,14 +635,14 @@ impl<'a> Parser<'a> {\n             None => return self.err(format!(\n                 \"Could not find Unicode class '{}'\", name)),\n             Some(ranges) => {\n-                Ok(~Class(ranges, negated | (self.flags & FLAG_NOCASE)))\n+                Ok(Class(ranges, negated | (self.flags & FLAG_NOCASE)))\n             }\n         }\n     }\n \n     // Parses an octal number, up to 3 digits.\n     // Assumes that \\n has been read, where n is the first digit.\n-    fn parse_octal(&mut self) -> Result<~Ast, Error> {\n+    fn parse_octal(&mut self) -> Result<Ast, Error> {\n         let start = self.chari;\n         let mut end = start + 1;\n         let (d2, d3) = (self.peek(1), self.peek(2));\n@@ -656,15 +656,15 @@ impl<'a> Parser<'a> {\n         }\n         let s = self.slice(start, end);\n         match num::from_str_radix::<u32>(s, 8) {\n-            Some(n) => Ok(~Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n+            Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => self.err(format!(\n                 \"Could not parse '{}' as octal number.\", s)),\n         }\n     }\n \n     // Parse a hex number. Either exactly two digits or anything in {}.\n     // Assumes that \\x has been read.\n-    fn parse_hex(&mut self) -> Result<~Ast, Error> {\n+    fn parse_hex(&mut self) -> Result<Ast, Error> {\n         if !self.peek_is(1, '{') {\n             try!(self.expect('{'))\n             return self.parse_hex_two()\n@@ -684,17 +684,17 @@ impl<'a> Parser<'a> {\n     // Assumes that \\xn has been read, where n is the first digit and is the\n     // current character.\n     // After return, parser will point at the second digit.\n-    fn parse_hex_two(&mut self) -> Result<~Ast, Error> {\n+    fn parse_hex_two(&mut self) -> Result<Ast, Error> {\n         let (start, end) = (self.chari, self.chari + 2);\n         let bad = self.slice(start - 2, self.chars.len());\n         try!(self.noteof(format!(\"Invalid hex escape sequence '{}'\", bad)))\n         self.parse_hex_digits(self.slice(start, end))\n     }\n \n     // Parses `s` as a hexadecimal number.\n-    fn parse_hex_digits(&self, s: &str) -> Result<~Ast, Error> {\n+    fn parse_hex_digits(&self, s: &str) -> Result<Ast, Error> {\n         match num::from_str_radix::<u32>(s, 16) {\n-            Some(n) => Ok(~Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n+            Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => self.err(format!(\n                 \"Could not parse '{}' as hex number.\", s)),\n         }\n@@ -840,16 +840,16 @@ impl<'a> Parser<'a> {\n         // thrown away). But be careful with overflow---we can't count on the\n         // open paren to be there.\n         if from > 0 { from = from - 1}\n-        let ast = try!(self.build_from(from, Alt));\n+        let ast = try!(self.build_from(from, |l,r| Alt(~l, ~r)));\n         self.push(ast);\n         Ok(())\n     }\n \n     // build_from combines all AST elements starting at 'from' in the\n     // parser's stack using 'mk' to combine them. If any such element is not an\n     // AST then it is popped off the stack and ignored.\n-    fn build_from(&mut self, from: uint, mk: |~Ast, ~Ast| -> Ast)\n-                 -> Result<~Ast, Error> {\n+    fn build_from(&mut self, from: uint, mk: |Ast, Ast| -> Ast)\n+                 -> Result<Ast, Error> {\n         if from >= self.stack.len() {\n             return self.err(\"Empty group or alternate not allowed.\")\n         }\n@@ -859,7 +859,7 @@ impl<'a> Parser<'a> {\n         while i > from {\n             i = i - 1;\n             match self.stack.pop().unwrap() {\n-                Ast(x) => combined = ~mk(x, combined),\n+                Ast(x) => combined = mk(x, combined),\n                 _ => {},\n             }\n         }\n@@ -961,11 +961,11 @@ fn perl_unicode_class(which: char) -> Vec<(char, char)> {\n \n // Returns a concatenation of two expressions. This also guarantees that a\n // `Cat` expression will never be a direct child of another `Cat` expression.\n-fn concat_flatten(x: ~Ast, y: ~Ast) -> Ast {\n+fn concat_flatten(x: Ast, y: Ast) -> Ast {\n     match (x, y) {\n-        (~Cat(mut xs), ~Cat(ys)) => { xs.push_all_move(ys); Cat(xs) }\n-        (~Cat(mut xs), ast) => { xs.push(ast); Cat(xs) }\n-        (ast, ~Cat(mut xs)) => { xs.unshift(ast); Cat(xs) }\n+        (Cat(mut xs), Cat(ys)) => { xs.push_all_move(ys); Cat(xs) }\n+        (Cat(mut xs), ast) => { xs.push(ast); Cat(xs) }\n+        (ast, Cat(mut xs)) => { xs.unshift(ast); Cat(xs) }\n         (ast1, ast2) => Cat(vec!(ast1, ast2)),\n     }\n }"}, {"sha": "b40968283bd50ddc42309410a2bc02dcff5cf906", "filename": "src/libregex/re.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "patch": "@@ -109,7 +109,7 @@ pub struct Regex {\n     #[doc(hidden)]\n     pub original: ~str,\n     #[doc(hidden)]\n-    pub names: ~[Option<~str>],\n+    pub names: Vec<Option<~str>>,\n     #[doc(hidden)]\n     pub p: MaybeNative,\n }\n@@ -477,14 +477,13 @@ impl Regex {\n                    (&self, text: &str, limit: uint, mut rep: R) -> StrBuf {\n         let mut new = StrBuf::with_capacity(text.len());\n         let mut last_match = 0u;\n-        let mut i = 0;\n-        for cap in self.captures_iter(text) {\n+\n+        for (i, cap) in self.captures_iter(text).enumerate() {\n             // It'd be nicer to use the 'take' iterator instead, but it seemed\n             // awkward given that '0' => no limit.\n             if limit > 0 && i >= limit {\n                 break\n             }\n-            i += 1;\n \n             let (s, e) = cap.pos(0).unwrap(); // captures only reports matches\n             new.push_str(text.slice(last_match, s));\n@@ -800,7 +799,7 @@ impl<'r, 't> Iterator<Captures<'t>> for FindCaptures<'r, 't> {\n \n         // Don't accept empty matches immediately following a match.\n         // i.e., no infinite loops please.\n-        if e - s == 0 && Some(self.last_end) == self.last_match {\n+        if e == s && Some(self.last_end) == self.last_match {\n             self.last_end += 1;\n             return self.next()\n         }\n@@ -842,7 +841,7 @@ impl<'r, 't> Iterator<(uint, uint)> for FindMatches<'r, 't> {\n \n         // Don't accept empty matches immediately following a match.\n         // i.e., no infinite loops please.\n-        if e - s == 0 && Some(self.last_end) == self.last_match {\n+        if e == s && Some(self.last_end) == self.last_match {\n             self.last_end += 1;\n             return self.next()\n         }"}, {"sha": "17c66bc670a92cd55b07ae0619597bd7de9bdbce", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "patch": "@@ -150,6 +150,7 @@ fn easy1() -> Regex { regex!(\"A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$\")\n fn medium() -> Regex { regex!(\"[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n fn hard() -> Regex { regex!(\"[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n \n+#[allow(deprecated_owned_vector)]\n fn gen_text(n: uint) -> ~str {\n     let mut rng = task_rng();\n     let mut bytes = rng.gen_ascii_str(n).into_bytes();\n@@ -176,4 +177,3 @@ throughput!(medium_32K,medium(), 32<<10)\n throughput!(hard_32, hard(), 32)\n throughput!(hard_1K, hard(), 1<<10)\n throughput!(hard_32K,hard(), 32<<10)\n-"}, {"sha": "ea89c8986930eb17f4841c9482912ca205f1939d", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "patch": "@@ -169,17 +169,15 @@ impl<'r, 't> Nfa<'r, 't> {\n             self.ic = next_ic;\n             next_ic = self.chars.advance();\n \n-            let mut i = 0;\n-            while i < clist.size {\n+            for i in range(0, clist.size) {\n                 let pc = clist.pc(i);\n                 let step_state = self.step(groups.as_mut_slice(), nlist,\n                                            clist.groups(i), pc);\n                 match step_state {\n                     StepMatchEarlyReturn => return vec![Some(0), Some(0)],\n-                    StepMatch => { matched = true; clist.empty() },\n+                    StepMatch => { matched = true; break },\n                     StepContinue => {},\n                 }\n-                i += 1;\n             }\n             mem::swap(&mut clist, &mut nlist);\n             nlist.empty();\n@@ -226,7 +224,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                     let found = ranges.as_slice();\n                     let found = found.bsearch(|&rc| class_cmp(casei, c, rc));\n                     let found = found.is_some();\n-                    if (found && !negate) || (!found && negate) {\n+                    if found ^ negate {\n                         self.add(nlist, pc+1, caps);\n                     }\n                 }\n@@ -568,20 +566,10 @@ pub fn find_prefix(needle: &[u8], haystack: &[u8]) -> Option<uint> {\n     if nlen > hlen || nlen == 0 {\n         return None\n     }\n-    let mut hayi = 0u;\n-    'HAYSTACK: loop {\n-        if hayi > hlen - nlen {\n-            break\n+    for (offset, window) in haystack.windows(nlen).enumerate() {\n+        if window == needle {\n+            return Some(offset)\n         }\n-        let mut nedi = 0;\n-        while nedi < nlen {\n-            if haystack[hayi+nedi] != needle[nedi] {\n-                hayi += 1;\n-                continue 'HAYSTACK\n-            }\n-            nedi += 1;\n-        }\n-        return Some(hayi)\n     }\n     None\n }"}, {"sha": "8b134d5af8bbc3ed89ef47c34f68538ec43b9c77", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9f3ea42361a5a938a4f22beff28bb2ade48af4/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=7e9f3ea42361a5a938a4f22beff28bb2ade48af4", "patch": "@@ -102,7 +102,7 @@ struct NfaGen<'a> {\n     cx: &'a ExtCtxt<'a>,\n     sp: codemap::Span,\n     prog: Program,\n-    names: ~[Option<~str>],\n+    names: Vec<Option<~str>>,\n     original: ~str,\n }\n \n@@ -112,7 +112,7 @@ impl<'a> NfaGen<'a> {\n         // expression returned.\n         let num_cap_locs = 2 * self.prog.num_captures();\n         let num_insts = self.prog.insts.len();\n-        let cap_names = self.vec_expr(self.names,\n+        let cap_names = self.vec_expr(self.names.as_slice(),\n             |cx, name| match name {\n                 &Some(ref name) => {\n                     let name = name.as_slice();\n@@ -187,18 +187,16 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n                 self.ic = next_ic;\n                 next_ic = self.chars.advance();\n \n-                let mut i = 0;\n-                while i < clist.size {\n+                for i in range(0, clist.size) {\n                     let pc = clist.pc(i);\n                     let step_state = self.step(&mut groups, nlist,\n                                                clist.groups(i), pc);\n                     match step_state {\n                         StepMatchEarlyReturn =>\n                             return vec![Some(0u), Some(0u)],\n-                        StepMatch => { matched = true; clist.empty() },\n+                        StepMatch => { matched = true; break },\n                         StepContinue => {},\n                     }\n-                    i += 1;\n                 }\n                 ::std::mem::swap(&mut clist, &mut nlist);\n                 nlist.empty();\n@@ -309,7 +307,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n ::regex::Regex {\n     original: ~$regex,\n-    names: ~$cap_names,\n+    names: vec!$cap_names,\n     p: ::regex::native::Native(exec),\n }\n         })"}]}