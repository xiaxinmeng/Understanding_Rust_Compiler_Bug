{"sha": "31486a639d19d121b31d1fcc4cb93390ee976081", "node_id": "C_kwDOAAsO6NoAKDMxNDg2YTYzOWQxOWQxMjFiMzFkMWZjYzRjYjkzMzkwZWU5NzYwODE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-14T10:53:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-14T10:53:35Z"}, "message": "Auto merge of #14141 - matklad:utf-32, r=lnicola\n\nSupport UTF-32 position encoding\n\nLooks like this is a native encoding for Emacs at least!", "tree": {"sha": "6098dfaf1ce9439de1a2d607be17f242f99feb7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6098dfaf1ce9439de1a2d607be17f242f99feb7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31486a639d19d121b31d1fcc4cb93390ee976081", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31486a639d19d121b31d1fcc4cb93390ee976081", "html_url": "https://github.com/rust-lang/rust/commit/31486a639d19d121b31d1fcc4cb93390ee976081", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31486a639d19d121b31d1fcc4cb93390ee976081/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a57b019808370d6b4d95a7e7dae354fe12de9db", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a57b019808370d6b4d95a7e7dae354fe12de9db", "html_url": "https://github.com/rust-lang/rust/commit/2a57b019808370d6b4d95a7e7dae354fe12de9db"}, {"sha": "9fdcf5787dc8de0408b151ba5b40f7a6f013b2a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fdcf5787dc8de0408b151ba5b40f7a6f013b2a0", "html_url": "https://github.com/rust-lang/rust/commit/9fdcf5787dc8de0408b151ba5b40f7a6f013b2a0"}], "stats": {"total": 370, "additions": 211, "deletions": 159}, "files": [{"sha": "6d8a3eeb7396fe4a1a8a7ec1fd8b3454007fe547", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -711,6 +711,7 @@ dependencies = [\n  \"limit\",\n  \"memchr\",\n  \"once_cell\",\n+ \"oorandom\",\n  \"parser\",\n  \"profile\",\n  \"rayon\","}, {"sha": "57daaf623df29864c47bbe1bc1f9841fc8066316", "filename": "crates/ide-db/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2FCargo.toml?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -37,8 +37,9 @@ text-edit.workspace = true\n hir.workspace = true\n \n [dev-dependencies]\n-xshell = \"0.2.2\"\n expect-test = \"1.4.0\"\n+oorandom = \"11.1.3\"\n+xshell = \"0.2.2\"\n \n # local deps\n test-utils.workspace = true"}, {"sha": "16814a1e636fa2e51376bd86cafb7ab0d3215927", "filename": "crates/ide-db/src/line_index.rs", "status": "modified", "additions": 103, "deletions": 92, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fline_index.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -7,56 +7,72 @@ use syntax::{TextRange, TextSize};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LineIndex {\n-    /// Offset the the beginning of each line, zero-based\n+    /// Offset the beginning of each line, zero-based.\n     pub(crate) newlines: Vec<TextSize>,\n-    /// List of non-ASCII characters on each line\n-    pub(crate) utf16_lines: NoHashHashMap<u32, Vec<Utf16Char>>,\n+    /// List of non-ASCII characters on each line.\n+    pub(crate) line_wide_chars: NoHashHashMap<u32, Vec<WideChar>>,\n }\n \n+/// Line/Column information in native, utf8 format.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct LineColUtf16 {\n+pub struct LineCol {\n     /// Zero-based\n     pub line: u32,\n-    /// Zero-based\n+    /// Zero-based utf8 offset\n     pub col: u32,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct LineCol {\n+pub enum WideEncoding {\n+    Utf16,\n+    Utf32,\n+}\n+\n+/// Line/Column information in legacy encodings.\n+///\n+/// Deliberately not a generic type and different from `LineCol`.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct WideLineCol {\n     /// Zero-based\n     pub line: u32,\n-    /// Zero-based utf8 offset\n+    /// Zero-based\n     pub col: u32,\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub(crate) struct Utf16Char {\n+pub(crate) struct WideChar {\n     /// Start offset of a character inside a line, zero-based\n     pub(crate) start: TextSize,\n     /// End offset of a character inside a line, zero-based\n     pub(crate) end: TextSize,\n }\n \n-impl Utf16Char {\n+impl WideChar {\n     /// Returns the length in 8-bit UTF-8 code units.\n     fn len(&self) -> TextSize {\n         self.end - self.start\n     }\n \n-    /// Returns the length in 16-bit UTF-16 code units.\n-    fn len_utf16(&self) -> usize {\n-        if self.len() == TextSize::from(4) {\n-            2\n-        } else {\n-            1\n+    /// Returns the length in UTF-16 or UTF-32 code units.\n+    fn wide_len(&self, enc: WideEncoding) -> usize {\n+        match enc {\n+            WideEncoding::Utf16 => {\n+                if self.len() == TextSize::from(4) {\n+                    2\n+                } else {\n+                    1\n+                }\n+            }\n+\n+            WideEncoding::Utf32 => 1,\n         }\n     }\n }\n \n impl LineIndex {\n     pub fn new(text: &str) -> LineIndex {\n-        let mut utf16_lines = NoHashHashMap::default();\n-        let mut utf16_chars = Vec::new();\n+        let mut line_wide_chars = NoHashHashMap::default();\n+        let mut wide_chars = Vec::new();\n \n         let mut newlines = Vec::with_capacity(16);\n         newlines.push(TextSize::from(0));\n@@ -71,8 +87,8 @@ impl LineIndex {\n                 newlines.push(curr_row);\n \n                 // Save any utf-16 characters seen in the previous line\n-                if !utf16_chars.is_empty() {\n-                    utf16_lines.insert(line, mem::take(&mut utf16_chars));\n+                if !wide_chars.is_empty() {\n+                    line_wide_chars.insert(line, mem::take(&mut wide_chars));\n                 }\n \n                 // Prepare for processing the next line\n@@ -82,18 +98,18 @@ impl LineIndex {\n             }\n \n             if !c.is_ascii() {\n-                utf16_chars.push(Utf16Char { start: curr_col, end: curr_col + c_len });\n+                wide_chars.push(WideChar { start: curr_col, end: curr_col + c_len });\n             }\n \n             curr_col += c_len;\n         }\n \n         // Save any utf-16 characters seen in the last line\n-        if !utf16_chars.is_empty() {\n-            utf16_lines.insert(line, utf16_chars);\n+        if !wide_chars.is_empty() {\n+            line_wide_chars.insert(line, wide_chars);\n         }\n \n-        LineIndex { newlines, utf16_lines }\n+        LineIndex { newlines, line_wide_chars }\n     }\n \n     pub fn line_col(&self, offset: TextSize) -> LineCol {\n@@ -109,13 +125,13 @@ impl LineIndex {\n             .map(|offset| offset + TextSize::from(line_col.col))\n     }\n \n-    pub fn to_utf16(&self, line_col: LineCol) -> LineColUtf16 {\n-        let col = self.utf8_to_utf16_col(line_col.line, line_col.col.into());\n-        LineColUtf16 { line: line_col.line, col: col as u32 }\n+    pub fn to_wide(&self, enc: WideEncoding, line_col: LineCol) -> WideLineCol {\n+        let col = self.utf8_to_wide_col(enc, line_col.line, line_col.col.into());\n+        WideLineCol { line: line_col.line, col: col as u32 }\n     }\n \n-    pub fn to_utf8(&self, line_col: LineColUtf16) -> LineCol {\n-        let col = self.utf16_to_utf8_col(line_col.line, line_col.col);\n+    pub fn to_utf8(&self, enc: WideEncoding, line_col: WideLineCol) -> LineCol {\n+        let col = self.wide_to_utf8_col(enc, line_col.line, line_col.col);\n         LineCol { line: line_col.line, col: col.into() }\n     }\n \n@@ -132,12 +148,12 @@ impl LineIndex {\n             .filter(|it| !it.is_empty())\n     }\n \n-    fn utf8_to_utf16_col(&self, line: u32, col: TextSize) -> usize {\n+    fn utf8_to_wide_col(&self, enc: WideEncoding, line: u32, col: TextSize) -> usize {\n         let mut res: usize = col.into();\n-        if let Some(utf16_chars) = self.utf16_lines.get(&line) {\n-            for c in utf16_chars {\n+        if let Some(wide_chars) = self.line_wide_chars.get(&line) {\n+            for c in wide_chars {\n                 if c.end <= col {\n-                    res -= usize::from(c.len()) - c.len_utf16();\n+                    res -= usize::from(c.len()) - c.wide_len(enc);\n                 } else {\n                     // From here on, all utf16 characters come *after* the character we are mapping,\n                     // so we don't need to take them into account\n@@ -148,11 +164,11 @@ impl LineIndex {\n         res\n     }\n \n-    fn utf16_to_utf8_col(&self, line: u32, mut col: u32) -> TextSize {\n-        if let Some(utf16_chars) = self.utf16_lines.get(&line) {\n-            for c in utf16_chars {\n+    fn wide_to_utf8_col(&self, enc: WideEncoding, line: u32, mut col: u32) -> TextSize {\n+        if let Some(wide_chars) = self.line_wide_chars.get(&line) {\n+            for c in wide_chars {\n                 if col > u32::from(c.start) {\n-                    col += u32::from(c.len()) - c.len_utf16() as u32;\n+                    col += u32::from(c.len()) - c.wide_len(enc) as u32;\n                 } else {\n                     // From here on, all utf16 characters come *after* the character we are mapping,\n                     // so we don't need to take them into account\n@@ -167,6 +183,9 @@ impl LineIndex {\n \n #[cfg(test)]\n mod tests {\n+    use test_utils::skip_slow_tests;\n+\n+    use super::WideEncoding::{Utf16, Utf32};\n     use super::*;\n \n     #[test]\n@@ -210,67 +229,59 @@ mod tests {\n const C: char = 'x';\n \",\n         );\n-        assert_eq!(col_index.utf16_lines.len(), 0);\n+        assert_eq!(col_index.line_wide_chars.len(), 0);\n     }\n \n     #[test]\n-    fn test_single_char() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = '\u30e1';\n-\",\n-        );\n-\n-        assert_eq!(col_index.utf16_lines.len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1].len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n-\n-        // UTF-8 to UTF-16, no changes\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n-\n-        // UTF-8 to UTF-16\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 22.into()), 20);\n-\n-        // UTF-16 to UTF-8, no changes\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n-\n-        // UTF-16 to UTF-8\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21));\n-\n-        let col_index = LineIndex::new(\"a\ud801\udc0fb\");\n-        assert_eq!(col_index.utf16_to_utf8_col(0, 3), TextSize::from(5));\n-    }\n-\n-    #[test]\n-    fn test_string() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = \\\"\u30e1 \u30e1\\\";\n-\",\n-        );\n-\n-        assert_eq!(col_index.utf16_lines.len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1].len(), 2);\n-        assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n-        assert_eq!(col_index.utf16_lines[&1][1], Utf16Char { start: 21.into(), end: 24.into() });\n-\n-        // UTF-8 to UTF-16\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n-\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 21.into()), 19);\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 25.into()), 21);\n-\n-        assert!(col_index.utf8_to_utf16_col(2, 15.into()) == 15);\n-\n-        // UTF-16 to UTF-8\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n+    fn test_every_chars() {\n+        if skip_slow_tests() {\n+            return;\n+        }\n \n-        // \u30e1 UTF-8: 0xE3 0x83 0xA1, UTF-16: 0x30E1\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 17), TextSize::from(17)); // first \u30e1 at 17..20\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 18), TextSize::from(20)); // space\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21)); // second \u30e1 at 21..24\n+        let text: String = {\n+            let mut chars: Vec<char> = ((0 as char)..char::MAX).collect(); // Neat!\n+            chars.extend(\"\\n\".repeat(chars.len() / 16).chars());\n+            let mut rng = oorandom::Rand32::new(stdx::rand::seed());\n+            stdx::rand::shuffle(&mut chars, |i| rng.rand_range(0..i as u32) as usize);\n+            chars.into_iter().collect()\n+        };\n+        assert!(text.contains('\ud83d\udca9')); // Sanity check.\n+\n+        let line_index = LineIndex::new(&text);\n+\n+        let mut lin_col = LineCol { line: 0, col: 0 };\n+        let mut col_utf16 = 0;\n+        let mut col_utf32 = 0;\n+        for (offset, c) in text.char_indices() {\n+            let got_offset = line_index.offset(lin_col).unwrap();\n+            assert_eq!(usize::from(got_offset), offset);\n+\n+            let got_lin_col = line_index.line_col(got_offset);\n+            assert_eq!(got_lin_col, lin_col);\n+\n+            for enc in [Utf16, Utf32] {\n+                let wide_lin_col = line_index.to_wide(enc, lin_col);\n+                let got_lin_col = line_index.to_utf8(enc, wide_lin_col);\n+                assert_eq!(got_lin_col, lin_col);\n+\n+                let want_col = match enc {\n+                    Utf16 => col_utf16,\n+                    Utf32 => col_utf32,\n+                };\n+                assert_eq!(wide_lin_col.col, want_col)\n+            }\n \n-        assert_eq!(col_index.utf16_to_utf8_col(2, 15), TextSize::from(15));\n+            if c == '\\n' {\n+                lin_col.line += 1;\n+                lin_col.col = 0;\n+                col_utf16 = 0;\n+                col_utf32 = 0;\n+            } else {\n+                lin_col.col += c.len_utf8() as u32;\n+                col_utf16 += c.len_utf16() as u32;\n+                col_utf32 += 1;\n+            }\n+        }\n     }\n \n     #[test]"}, {"sha": "f2b535bdc7efed42599e2c7a29b8fbdcf215d63a", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -115,7 +115,7 @@ pub use ide_db::{\n         SourceRoot, SourceRootId,\n     },\n     label::Label,\n-    line_index::{LineCol, LineColUtf16, LineIndex},\n+    line_index::{LineCol, LineIndex},\n     search::{ReferenceCategory, SearchScope},\n     source_change::{FileSystemEdit, SourceChange},\n     symbol_index::Query,"}, {"sha": "e606072a82375de5c67dda98688b272bce281441", "filename": "crates/ide/src/shuffle_crate_graph.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -18,7 +18,9 @@ pub(crate) fn shuffle_crate_graph(db: &mut RootDatabase) {\n     let crate_graph = db.crate_graph();\n \n     let mut shuffled_ids = crate_graph.iter().collect::<Vec<_>>();\n-    shuffle(&mut shuffled_ids);\n+\n+    let mut rng = oorandom::Rand32::new(stdx::rand::seed());\n+    stdx::rand::shuffle(&mut shuffled_ids, |i| rng.rand_range(0..i as u32) as usize);\n \n     let mut new_graph = CrateGraph::default();\n \n@@ -52,21 +54,3 @@ pub(crate) fn shuffle_crate_graph(db: &mut RootDatabase) {\n \n     db.set_crate_graph_with_durability(Arc::new(new_graph), Durability::HIGH);\n }\n-\n-fn shuffle<T>(slice: &mut [T]) {\n-    let mut rng = oorandom::Rand32::new(seed());\n-\n-    let mut remaining = slice.len() - 1;\n-    while remaining > 0 {\n-        let index = rng.rand_range(0..remaining as u32);\n-        slice.swap(remaining, index as usize);\n-        remaining -= 1;\n-    }\n-}\n-\n-fn seed() -> u64 {\n-    use std::collections::hash_map::RandomState;\n-    use std::hash::{BuildHasher, Hasher};\n-\n-    RandomState::new().build_hasher().finish()\n-}"}, {"sha": "a9ed05021daa524ae7c9b3327e403373dc817263", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -1,4 +1,5 @@\n //! Advertises the capabilities of the LSP Server.\n+use ide_db::line_index::WideEncoding;\n use lsp_types::{\n     CallHierarchyServerCapability, ClientCapabilities, CodeActionKind, CodeActionOptions,\n     CodeActionProviderCapability, CodeLensOptions, CompletionOptions,\n@@ -16,16 +17,19 @@ use lsp_types::{\n use serde_json::json;\n \n use crate::config::{Config, RustfmtConfig};\n-use crate::lsp_ext::supports_utf8;\n+use crate::line_index::PositionEncoding;\n+use crate::lsp_ext::negotiated_encoding;\n use crate::semantic_tokens;\n \n pub fn server_capabilities(config: &Config) -> ServerCapabilities {\n     ServerCapabilities {\n-        position_encoding: if supports_utf8(config.caps()) {\n-            Some(PositionEncodingKind::UTF8)\n-        } else {\n-            None\n-        },\n+        position_encoding: Some(match negotiated_encoding(config.caps()) {\n+            PositionEncoding::Utf8 => PositionEncodingKind::UTF8,\n+            PositionEncoding::Wide(wide) => match wide {\n+                WideEncoding::Utf16 => PositionEncodingKind::UTF16,\n+                WideEncoding::Utf32 => PositionEncodingKind::UTF32,\n+            },\n+        }),\n         text_document_sync: Some(TextDocumentSyncCapability::Options(TextDocumentSyncOptions {\n             open_close: Some(true),\n             change: Some(TextDocumentSyncKind::INCREMENTAL),"}, {"sha": "3fc1aa4eaeb4aaaad35bb744ebfcbc53f4d0ecd6", "filename": "crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -11,6 +11,7 @@ use ide::{\n use ide_db::LineIndexDatabase;\n \n use ide_db::base_db::salsa::{self, ParallelDatabase};\n+use ide_db::line_index::WideEncoding;\n use lsp_types::{self, lsif};\n use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n use vfs::{AbsPathBuf, Vfs};\n@@ -127,7 +128,7 @@ impl LsifManager<'_> {\n         let line_index = self.db.line_index(file_id);\n         let line_index = LineIndex {\n             index: line_index,\n-            encoding: PositionEncoding::Utf16,\n+            encoding: PositionEncoding::Wide(WideEncoding::Utf16),\n             endings: LineEndings::Unix,\n         };\n         let range_id = self.add_vertex(lsif::Vertex::Range {\n@@ -249,7 +250,7 @@ impl LsifManager<'_> {\n         let line_index = self.db.line_index(file_id);\n         let line_index = LineIndex {\n             index: line_index,\n-            encoding: PositionEncoding::Utf16,\n+            encoding: PositionEncoding::Wide(WideEncoding::Utf16),\n             endings: LineEndings::Unix,\n         };\n         let result = folds"}, {"sha": "f609a50a05fafdd82de792cc63af4e4c84b2b2b0", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -33,7 +33,7 @@ use crate::{\n     caps::completion_item_edit_resolve,\n     diagnostics::DiagnosticsMapConfig,\n     line_index::PositionEncoding,\n-    lsp_ext::{self, supports_utf8, WorkspaceSymbolSearchKind, WorkspaceSymbolSearchScope},\n+    lsp_ext::{self, negotiated_encoding, WorkspaceSymbolSearchKind, WorkspaceSymbolSearchScope},\n };\n \n mod patch_old_style;\n@@ -999,11 +999,7 @@ impl Config {\n     }\n \n     pub fn position_encoding(&self) -> PositionEncoding {\n-        if supports_utf8(&self.caps) {\n-            PositionEncoding::Utf8\n-        } else {\n-            PositionEncoding::Utf16\n-        }\n+        negotiated_encoding(&self.caps)\n     }\n \n     fn experimental(&self, index: &'static str) -> bool {"}, {"sha": "415fa4e02f20cf7805c46b5d456c54916da65c8b", "filename": "crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -3,6 +3,7 @@\n use std::collections::HashMap;\n \n use flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};\n+use ide_db::line_index::WideEncoding;\n use itertools::Itertools;\n use stdx::format_to;\n use vfs::{AbsPath, AbsPathBuf};\n@@ -95,7 +96,8 @@ fn position(\n         let mut char_offset = 0;\n         let len_func = match position_encoding {\n             PositionEncoding::Utf8 => char::len_utf8,\n-            PositionEncoding::Utf16 => char::len_utf16,\n+            PositionEncoding::Wide(WideEncoding::Utf16) => char::len_utf16,\n+            PositionEncoding::Wide(WideEncoding::Utf32) => |_| 1,\n         };\n         for c in line.text.chars() {\n             char_offset += 1;"}, {"sha": "50af38cd6fe3746d70df37bfcfdde8cf1a53fd94", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -1,7 +1,10 @@\n //! Conversion lsp_types types to rust-analyzer specific ones.\n use anyhow::format_err;\n-use ide::{Annotation, AnnotationKind, AssistKind, LineCol, LineColUtf16};\n-use ide_db::base_db::{FileId, FilePosition, FileRange};\n+use ide::{Annotation, AnnotationKind, AssistKind, LineCol};\n+use ide_db::{\n+    base_db::{FileId, FilePosition, FileRange},\n+    line_index::WideLineCol,\n+};\n use syntax::{TextRange, TextSize};\n use vfs::AbsPathBuf;\n \n@@ -26,9 +29,9 @@ pub(crate) fn vfs_path(url: &lsp_types::Url) -> Result<vfs::VfsPath> {\n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> Result<TextSize> {\n     let line_col = match line_index.encoding {\n         PositionEncoding::Utf8 => LineCol { line: position.line, col: position.character },\n-        PositionEncoding::Utf16 => {\n-            let line_col = LineColUtf16 { line: position.line, col: position.character };\n-            line_index.index.to_utf8(line_col)\n+        PositionEncoding::Wide(enc) => {\n+            let line_col = WideLineCol { line: position.line, col: position.character };\n+            line_index.index.to_utf8(enc, line_col)\n         }\n     };\n     let text_size ="}, {"sha": "791cd931d42a6bb0b90fb7de8de69a79b4ed1865", "filename": "crates/rust-analyzer/src/line_index.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -7,9 +7,12 @@\n \n use std::sync::Arc;\n \n+use ide_db::line_index::WideEncoding;\n+\n+#[derive(Clone, Copy)]\n pub enum PositionEncoding {\n     Utf8,\n-    Utf16,\n+    Wide(WideEncoding),\n }\n \n pub(crate) struct LineIndex {"}, {"sha": "e33589cc53696a90890c4d57e70e10ec12f3d8e8", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -2,6 +2,7 @@\n \n use std::{collections::HashMap, path::PathBuf};\n \n+use ide_db::line_index::WideEncoding;\n use lsp_types::request::Request;\n use lsp_types::PositionEncodingKind;\n use lsp_types::{\n@@ -10,6 +11,8 @@ use lsp_types::{\n };\n use serde::{Deserialize, Serialize};\n \n+use crate::line_index::PositionEncoding;\n+\n pub enum AnalyzerStatus {}\n \n impl Request for AnalyzerStatus {\n@@ -481,16 +484,22 @@ pub(crate) enum CodeLensResolveData {\n     References(lsp_types::TextDocumentPositionParams),\n }\n \n-pub fn supports_utf8(caps: &lsp_types::ClientCapabilities) -> bool {\n-    match &caps.general {\n-        Some(general) => general\n-            .position_encodings\n-            .as_deref()\n-            .unwrap_or_default()\n-            .iter()\n-            .any(|it| it == &PositionEncodingKind::UTF8),\n-        _ => false,\n+pub fn negotiated_encoding(caps: &lsp_types::ClientCapabilities) -> PositionEncoding {\n+    let client_encodings = match &caps.general {\n+        Some(general) => general.position_encodings.as_deref().unwrap_or_default(),\n+        None => &[],\n+    };\n+\n+    for enc in client_encodings {\n+        if enc == &PositionEncodingKind::UTF8 {\n+            return PositionEncoding::Utf8;\n+        } else if enc == &PositionEncodingKind::UTF32 {\n+            return PositionEncoding::Wide(WideEncoding::Utf32);\n+        }\n+        // NB: intentionally prefer just about anything else to utf-16.\n     }\n+\n+    PositionEncoding::Wide(WideEncoding::Utf16)\n }\n \n pub enum MoveItem {}"}, {"sha": "30f1c53c198f31d54e8668f8f2fe52d33bea46d1", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -161,6 +161,7 @@ impl GlobalState {\n }\n \n pub(crate) fn apply_document_changes(\n+    encoding: PositionEncoding,\n     file_contents: impl FnOnce() -> String,\n     mut content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n ) -> String {\n@@ -192,9 +193,9 @@ pub(crate) fn apply_document_changes(\n     let mut line_index = LineIndex {\n         // the index will be overwritten in the bottom loop's first iteration\n         index: Arc::new(ide::LineIndex::new(&text)),\n-        // We don't care about line endings or offset encoding here.\n+        // We don't care about line endings here.\n         endings: LineEndings::Unix,\n-        encoding: PositionEncoding::Utf16,\n+        encoding,\n     };\n \n     // The changes we got must be applied sequentially, but can cross lines so we\n@@ -256,6 +257,7 @@ pub(crate) fn all_edits_are_disjoint(\n \n #[cfg(test)]\n mod tests {\n+    use ide_db::line_index::WideEncoding;\n     use lsp_types::{\n         CompletionItem, CompletionTextEdit, InsertReplaceEdit, Position, Range,\n         TextDocumentContentChangeEvent,\n@@ -278,9 +280,11 @@ mod tests {\n             };\n         }\n \n-        let text = apply_document_changes(|| String::new(), vec![]);\n+        let encoding = PositionEncoding::Wide(WideEncoding::Utf16);\n+        let text = apply_document_changes(encoding, || String::new(), vec![]);\n         assert_eq!(text, \"\");\n         let text = apply_document_changes(\n+            encoding,\n             || text,\n             vec![TextDocumentContentChangeEvent {\n                 range: None,\n@@ -289,39 +293,49 @@ mod tests {\n             }],\n         );\n         assert_eq!(text, \"the\");\n-        let text = apply_document_changes(|| text, c![0, 3; 0, 3 => \" quick\"]);\n+        let text = apply_document_changes(encoding, || text, c![0, 3; 0, 3 => \" quick\"]);\n         assert_eq!(text, \"the quick\");\n-        let text = apply_document_changes(|| text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n         assert_eq!(text, \"quick foxes\");\n-        let text = apply_document_changes(|| text, c![0, 11; 0, 11 => \"\\ndream\"]);\n+        let text = apply_document_changes(encoding, || text, c![0, 11; 0, 11 => \"\\ndream\"]);\n         assert_eq!(text, \"quick foxes\\ndream\");\n-        let text = apply_document_changes(|| text, c![1, 0; 1, 0 => \"have \"]);\n+        let text = apply_document_changes(encoding, || text, c![1, 0; 1, 0 => \"have \"]);\n         assert_eq!(text, \"quick foxes\\nhave dream\");\n         let text = apply_document_changes(\n+            encoding,\n             || text,\n             c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n-        let text = apply_document_changes(|| text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n+        let text = apply_document_changes(\n+            encoding,\n+            || text,\n+            c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"],\n+        );\n         assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n         let text = apply_document_changes(\n+            encoding,\n             || text,\n             c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n-        let text = apply_document_changes(|| text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n         assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n \n         let text = String::from(\"\u2764\ufe0f\");\n-        let text = apply_document_changes(|| text, c![0, 0; 0, 0 => \"a\"]);\n+        let text = apply_document_changes(encoding, || text, c![0, 0; 0, 0 => \"a\"]);\n         assert_eq!(text, \"a\u2764\ufe0f\");\n \n         let text = String::from(\"a\\nb\");\n-        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n         assert_eq!(text, \"adcb\");\n \n         let text = String::from(\"a\\nb\");\n-        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n         assert_eq!(text, \"a\u021bc\\ncb\");\n     }\n "}, {"sha": "d1e38b33c7de2e38f342801e612c57a8c9787270", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -831,6 +831,7 @@ impl GlobalState {\n                     let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n                     let text = apply_document_changes(\n+                        this.config.position_encoding(),\n                         || std::str::from_utf8(vfs.file_contents(file_id)).unwrap().into(),\n                         params.content_changes,\n                     );"}, {"sha": "78cd4b8e2b1bcca2bac88cad09709a322d2ba76a", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -31,8 +31,8 @@ pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::P\n     let line_col = line_index.index.line_col(offset);\n     match line_index.encoding {\n         PositionEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n-        PositionEncoding::Utf16 => {\n-            let line_col = line_index.index.to_utf16(line_col);\n+        PositionEncoding::Wide(enc) => {\n+            let line_col = line_index.index.to_wide(enc, line_col);\n             lsp_types::Position::new(line_col.line, line_col.col)\n         }\n     }\n@@ -1429,7 +1429,7 @@ fn main() {\n         let line_index = LineIndex {\n             index: Arc::new(ide::LineIndex::new(text)),\n             endings: LineEndings::Unix,\n-            encoding: PositionEncoding::Utf16,\n+            encoding: PositionEncoding::Utf8,\n         };\n         let converted: Vec<lsp_types::FoldingRange> =\n             folds.into_iter().map(|it| folding_range(text, &line_index, true, it)).collect();"}, {"sha": "5639aaf57cd9713162e671258a7d3e6fccda299d", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -11,6 +11,7 @@ pub mod hash;\n pub mod process;\n pub mod panic_context;\n pub mod non_empty_vec;\n+pub mod rand;\n \n pub use always_assert::{always, never};\n "}, {"sha": "b38506caef5cadcdca9dbfdbe0e9295ff0ad1a10", "filename": "crates/stdx/src/rand.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fstdx%2Fsrc%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/crates%2Fstdx%2Fsrc%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Frand.rs?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -0,0 +1,21 @@\n+//! We don't use `rand`, as that's too many things for us.\n+//!\n+//! Currently, we use oorandom instead, but it misses these two utilities.\n+//! Perhaps we should switch to `fastrand`, or our own small prng, it's not like\n+//! we need anything move complicatied that xor-shift.\n+\n+pub fn shuffle<T>(slice: &mut [T], mut rand_index: impl FnMut(usize) -> usize) {\n+    let mut remaining = slice.len() - 1;\n+    while remaining > 0 {\n+        let index = rand_index(remaining);\n+        slice.swap(remaining, index);\n+        remaining -= 1;\n+    }\n+}\n+\n+pub fn seed() -> u64 {\n+    use std::collections::hash_map::RandomState;\n+    use std::hash::{BuildHasher, Hasher};\n+\n+    RandomState::new().build_hasher().finish()\n+}"}, {"sha": "c3623a5cc46cf841d0c2ead53b6d21bfdc5c9dbd", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31486a639d19d121b31d1fcc4cb93390ee976081/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/31486a639d19d121b31d1fcc4cb93390ee976081/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=31486a639d19d121b31d1fcc4cb93390ee976081", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: ec29403e67dfd15b\n+lsp_ext.rs hash: d87477896dfe41d4\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:"}]}