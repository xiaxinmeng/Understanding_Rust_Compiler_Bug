{"sha": "f6905694658e2f239c7054f063e962d9097dd1be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2OTA1Njk0NjU4ZTJmMjM5YzcwNTRmMDYzZTk2MmQ5MDk3ZGQxYmU=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-08-15T22:04:11Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-09-04T23:12:54Z"}, "message": "Review comments", "tree": {"sha": "47ed69919a1f81794d07e68420222b391ada1f83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47ed69919a1f81794d07e68420222b391ada1f83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6905694658e2f239c7054f063e962d9097dd1be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6905694658e2f239c7054f063e962d9097dd1be", "html_url": "https://github.com/rust-lang/rust/commit/f6905694658e2f239c7054f063e962d9097dd1be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6905694658e2f239c7054f063e962d9097dd1be/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76c728901e6b9d9b1c90de78c0f612f7a3fc63d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5", "html_url": "https://github.com/rust-lang/rust/commit/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5"}], "stats": {"total": 261, "additions": 130, "deletions": 131}, "files": [{"sha": "763b078e7703ed135fc7dcdae44a8753082616b1", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f6905694658e2f239c7054f063e962d9097dd1be/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6905694658e2f239c7054f063e962d9097dd1be/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=f6905694658e2f239c7054f063e962d9097dd1be", "patch": "@@ -112,43 +112,39 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         match application_ty.name {\n             chalk_ir::TypeName::Ref(mutbl) => {\n                 let data = application_ty.substitution.interned();\n-                let lifetime = match &**data[0].interned() {\n-                    chalk_ir::GenericArgData::Lifetime(t) => t,\n+                match (&**data[0].interned(), &**data[1].interned()) {\n+                    (\n+                        chalk_ir::GenericArgData::Lifetime(lifetime),\n+                        chalk_ir::GenericArgData::Ty(ty),\n+                    ) => Some(match mutbl {\n+                        chalk_ir::Mutability::Not => write!(fmt, \"(&{:?} {:?})\", lifetime, ty),\n+                        chalk_ir::Mutability::Mut => write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty),\n+                    }),\n                     _ => unreachable!(),\n-                };\n-                let ty = match &**data[1].interned() {\n-                    chalk_ir::GenericArgData::Ty(t) => t,\n-                    _ => unreachable!(),\n-                };\n-                return Some(match mutbl {\n-                    chalk_ir::Mutability::Not => write!(fmt, \"(&{:?} {:?})\", lifetime, ty),\n-                    chalk_ir::Mutability::Mut => write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty),\n-                });\n+                }\n             }\n             chalk_ir::TypeName::Array => {\n                 let data = application_ty.substitution.interned();\n-                let ty = match &**data[0].interned() {\n-                    chalk_ir::GenericArgData::Ty(t) => t,\n-                    _ => unreachable!(),\n-                };\n-                let len = match &**data[1].interned() {\n-                    chalk_ir::GenericArgData::Const(t) => t,\n+                match (&**data[0].interned(), &**data[1].interned()) {\n+                    (chalk_ir::GenericArgData::Ty(ty), chalk_ir::GenericArgData::Const(len)) => {\n+                        Some(write!(fmt, \"[{:?}; {:?}]\", ty, len))\n+                    }\n                     _ => unreachable!(),\n-                };\n-                return Some(write!(fmt, \"[{:?}; {:?}]\", ty, len));\n+                }\n             }\n             chalk_ir::TypeName::Slice => {\n                 let data = application_ty.substitution.interned();\n                 let ty = match &**data[0].interned() {\n                     chalk_ir::GenericArgData::Ty(t) => t,\n                     _ => unreachable!(),\n                 };\n-                return Some(write!(fmt, \"[{:?}]\", ty));\n+                Some(write!(fmt, \"[{:?}]\", ty))\n+            }\n+            _ => {\n+                let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n+                Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n             }\n-            _ => {}\n         }\n-        let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n-        Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n     }\n \n     fn debug_substitution("}, {"sha": "7cc567dabb28f7f59daaaab5a96670b1428a54f5", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 92, "deletions": 74, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/f6905694658e2f239c7054f063e962d9097dd1be/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6905694658e2f239c7054f063e962d9097dd1be/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=f6905694658e2f239c7054f063e962d9097dd1be", "patch": "@@ -21,10 +21,9 @@ use std::sync::Arc;\n use crate::chalk::lowering::{self, LowerInto};\n \n pub struct RustIrDatabase<'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub interner: RustInterner<'tcx>,\n-    pub restatic_placeholder: ty::Region<'tcx>,\n-    pub reempty_placeholder: ty::Region<'tcx>,\n+    pub(crate) interner: RustInterner<'tcx>,\n+    pub(crate) restatic_placeholder: ty::Region<'tcx>,\n+    pub(crate) reempty_placeholder: ty::Region<'tcx>,\n }\n \n impl fmt::Debug for RustIrDatabase<'_> {\n@@ -39,15 +38,15 @@ impl<'tcx> RustIrDatabase<'tcx> {\n         def_id: DefId,\n         bound_vars: SubstsRef<'tcx>,\n     ) -> Vec<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        let predicates = self.tcx.predicates_of(def_id).predicates;\n+        let predicates = self.interner.tcx.predicates_of(def_id).predicates;\n         let mut regions_substitutor = lowering::RegionsSubstitutor::new(\n-            self.tcx,\n+            self.interner.tcx,\n             self.restatic_placeholder,\n             self.reempty_placeholder,\n         );\n         predicates\n             .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n+            .map(|(wc, _)| wc.subst(self.interner.tcx, bound_vars))\n             .map(|wc| wc.fold_with(&mut regions_substitutor))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect()\n     }\n@@ -63,7 +62,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         assoc_type_id: chalk_ir::AssocTypeId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::AssociatedTyDatum<RustInterner<'tcx>>> {\n         let def_id = assoc_type_id.0;\n-        let assoc_item = self.tcx.associated_item(def_id);\n+        let assoc_item = self.interner.tcx.associated_item(def_id);\n         let trait_def_id = match assoc_item.container {\n             AssocItemContainer::TraitContainer(def_id) => def_id,\n             _ => unimplemented!(\"Not possible??\"),\n@@ -72,7 +71,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             AssocKind::Type => {}\n             _ => unimplemented!(\"Not possible??\"),\n         }\n-        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n         // FIXME(chalk): this really isn't right I don't think. The functions\n         // for GATs are a bit hard to figure out. Are these supposed to be where\n@@ -95,39 +94,63 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::TraitDatum<RustInterner<'tcx>>> {\n         let def_id = trait_id.0;\n-        let trait_def = self.tcx.trait_def(def_id);\n+        let trait_def = self.interner.tcx.trait_def(def_id);\n \n-        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n \n         let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n         let associated_ty_ids: Vec<_> = self\n+            .interner\n             .tcx\n             .associated_items(def_id)\n             .in_definition_order()\n             .filter(|i| i.kind == AssocKind::Type)\n             .map(|i| chalk_ir::AssocTypeId(i.def_id))\n             .collect();\n \n-        let well_known =\n-            if self.tcx.lang_items().sized_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::Sized)\n-            } else if self.tcx.lang_items().copy_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::Copy)\n-            } else if self.tcx.lang_items().clone_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::Clone)\n-            } else if self.tcx.lang_items().drop_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::Drop)\n-            } else if self.tcx.lang_items().fn_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::Fn)\n-            } else if self.tcx.lang_items().fn_once_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::FnOnce)\n-            } else if self.tcx.lang_items().fn_mut_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::FnMut)\n-            } else {\n-                None\n-            };\n+        let well_known = if self\n+            .interner\n+            .tcx\n+            .lang_items()\n+            .sized_trait()\n+            .map(|t| def_id == t)\n+            .unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Sized)\n+        } else if self.interner.tcx.lang_items().copy_trait().map(|t| def_id == t).unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Copy)\n+        } else if self.interner.tcx.lang_items().clone_trait().map(|t| def_id == t).unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Clone)\n+        } else if self.interner.tcx.lang_items().drop_trait().map(|t| def_id == t).unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Drop)\n+        } else if self.interner.tcx.lang_items().fn_trait().map(|t| def_id == t).unwrap_or(false) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Fn)\n+        } else if self\n+            .interner\n+            .tcx\n+            .lang_items()\n+            .fn_once_trait()\n+            .map(|t| def_id == t)\n+            .unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::FnOnce)\n+        } else if self\n+            .interner\n+            .tcx\n+            .lang_items()\n+            .fn_mut_trait()\n+            .map(|t| def_id == t)\n+            .unwrap_or(false)\n+        {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::FnMut)\n+        } else {\n+            None\n+        };\n         Arc::new(chalk_solve::rust_ir::TraitDatum {\n             id: trait_id,\n             binders: chalk_ir::Binders::new(\n@@ -138,7 +161,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 auto: trait_def.has_auto_impl,\n                 marker: trait_def.is_marker,\n                 upstream: !def_id.is_local(),\n-                fundamental: self.tcx.has_attr(def_id, sym::fundamental),\n+                fundamental: self.interner.tcx.has_attr(def_id, sym::fundamental),\n                 non_enumerable: true,\n                 coinductive: false,\n             },\n@@ -153,7 +176,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::AdtDatum<RustInterner<'tcx>>> {\n         let adt_def = adt_id.0;\n \n-        let bound_vars = bound_vars_for_item(self.tcx, adt_def.did);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, adt_def.did);\n         let binders = binders_for(&self.interner, bound_vars);\n \n         let where_clauses = self.where_clauses_for(adt_def.did, bound_vars);\n@@ -165,16 +188,11 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 fields: variant\n                     .fields\n                     .iter()\n-                    .map(|field| {\n-                        self.tcx\n-                            .type_of(field.did)\n-                            .subst(self.tcx, bound_vars)\n-                            .lower_into(&self.interner)\n-                    })\n+                    .map(|field| field.ty(self.interner.tcx, bound_vars).lower_into(&self.interner))\n                     .collect(),\n             })\n             .collect();\n-        let struct_datum = Arc::new(chalk_solve::rust_ir::AdtDatum {\n+        Arc::new(chalk_solve::rust_ir::AdtDatum {\n             id: adt_id,\n             binders: chalk_ir::Binders::new(\n                 binders,\n@@ -190,8 +208,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 ty::AdtKind::Union => chalk_solve::rust_ir::AdtKind::Union,\n                 ty::AdtKind::Enum => chalk_solve::rust_ir::AdtKind::Enum,\n             },\n-        });\n-        struct_datum\n+        })\n     }\n \n     fn adt_repr(\n@@ -210,27 +227,25 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         fn_def_id: chalk_ir::FnDefId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::FnDefDatum<RustInterner<'tcx>>> {\n         let def_id = fn_def_id.0;\n-        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n \n         let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n-        let sig = self.tcx.fn_sig(def_id);\n-        let inputs_and_output = sig.inputs_and_output();\n-        let inputs_and_output = inputs_and_output.subst(self.tcx, bound_vars);\n+        let sig = self.interner.tcx.fn_sig(def_id);\n         let (inputs_and_output, iobinders, _) = crate::chalk::lowering::collect_bound_vars(\n             &self.interner,\n-            self.tcx,\n-            &inputs_and_output,\n+            self.interner.tcx,\n+            &sig.inputs_and_output().subst(self.interner.tcx, bound_vars),\n         );\n \n         let argument_types = inputs_and_output[..inputs_and_output.len() - 1]\n             .iter()\n-            .map(|t| t.subst(self.tcx, &bound_vars).lower_into(&self.interner))\n+            .map(|t| t.subst(self.interner.tcx, &bound_vars).lower_into(&self.interner))\n             .collect();\n \n         let return_type = inputs_and_output[inputs_and_output.len() - 1]\n-            .subst(self.tcx, &bound_vars)\n+            .subst(self.interner.tcx, &bound_vars)\n             .lower_into(&self.interner);\n \n         let bound = chalk_solve::rust_ir::FnDefDatumBound {\n@@ -257,13 +272,13 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         impl_id: chalk_ir::ImplId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::ImplDatum<RustInterner<'tcx>>> {\n         let def_id = impl_id.0;\n-        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n \n-        let trait_ref = self.tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n-        let trait_ref = trait_ref.subst(self.tcx, bound_vars);\n+        let trait_ref = self.interner.tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+        let trait_ref = trait_ref.subst(self.interner.tcx, bound_vars);\n         let mut regions_substitutor = lowering::RegionsSubstitutor::new(\n-            self.tcx,\n+            self.interner.tcx,\n             self.restatic_placeholder,\n             self.reempty_placeholder,\n         );\n@@ -296,16 +311,16 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         // require us to be able to interconvert `Ty<'tcx>`, and we're\n         // not there yet.\n \n-        let all_impls = self.tcx.all_impls(def_id);\n+        let all_impls = self.interner.tcx.all_impls(def_id);\n         let matched_impls = all_impls.filter(|impl_def_id| {\n             use chalk_ir::could_match::CouldMatch;\n-            let trait_ref = self.tcx.impl_trait_ref(*impl_def_id).unwrap();\n-            let bound_vars = bound_vars_for_item(self.tcx, *impl_def_id);\n+            let trait_ref = self.interner.tcx.impl_trait_ref(*impl_def_id).unwrap();\n+            let bound_vars = bound_vars_for_item(self.interner.tcx, *impl_def_id);\n \n             let self_ty = trait_ref.self_ty();\n-            let self_ty = self_ty.subst(self.tcx, bound_vars);\n+            let self_ty = self_ty.subst(self.interner.tcx, bound_vars);\n             let mut regions_substitutor = lowering::RegionsSubstitutor::new(\n-                self.tcx,\n+                self.interner.tcx,\n                 self.restatic_placeholder,\n                 self.reempty_placeholder,\n             );\n@@ -326,9 +341,9 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> bool {\n         let trait_def_id = auto_trait_id.0;\n         let adt_def = adt_id.0;\n-        let all_impls = self.tcx.all_impls(trait_def_id);\n+        let all_impls = self.interner.tcx.all_impls(trait_def_id);\n         for impl_def_id in all_impls {\n-            let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n+            let trait_ref = self.interner.tcx.impl_trait_ref(impl_def_id).unwrap();\n             let self_ty = trait_ref.self_ty();\n             match *self_ty.kind() {\n                 ty::Adt(impl_adt_def, _) => {\n@@ -347,7 +362,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         associated_ty_id: chalk_solve::rust_ir::AssociatedTyValueId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n         let def_id = associated_ty_id.0;\n-        let assoc_item = self.tcx.associated_item(def_id);\n+        let assoc_item = self.interner.tcx.associated_item(def_id);\n         let impl_id = match assoc_item.container {\n             AssocItemContainer::TraitContainer(def_id) => def_id,\n             _ => unimplemented!(\"Not possible??\"),\n@@ -356,9 +371,9 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             AssocKind::Type => {}\n             _ => unimplemented!(\"Not possible??\"),\n         }\n-        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n-        let ty = self.tcx.type_of(def_id);\n+        let ty = self.interner.tcx.type_of(def_id);\n \n         Arc::new(chalk_solve::rust_ir::AssociatedTyValue {\n             impl_id: chalk_ir::ImplId(impl_id),\n@@ -385,7 +400,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         &self,\n         opaque_ty_id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n-        let bound_vars = bound_vars_for_item(self.tcx, opaque_ty_id.0);\n+        let bound_vars = bound_vars_for_item(self.interner.tcx, opaque_ty_id.0);\n         let binders = binders_for(&self.interner, bound_vars);\n         let where_clauses = self.where_clauses_for(opaque_ty_id.0, bound_vars);\n \n@@ -395,7 +410,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         };\n         Arc::new(chalk_solve::rust_ir::OpaqueTyDatum {\n             opaque_ty_id,\n-            bound: chalk_ir::Binders::new(chalk_ir::VariableKinds::empty(&self.interner), value),\n+            bound: chalk_ir::Binders::empty(&self.interner, value),\n         })\n     }\n \n@@ -412,28 +427,31 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Option<chalk_ir::TraitId<RustInterner<'tcx>>> {\n         use chalk_solve::rust_ir::WellKnownTrait::*;\n         let def_id = match well_known_trait {\n-            Sized => self.tcx.lang_items().sized_trait(),\n-            Copy => self.tcx.lang_items().copy_trait(),\n-            Clone => self.tcx.lang_items().clone_trait(),\n-            Drop => self.tcx.lang_items().drop_trait(),\n-            Fn => self.tcx.lang_items().fn_trait(),\n-            FnMut => self.tcx.lang_items().fn_mut_trait(),\n-            FnOnce => self.tcx.lang_items().fn_once_trait(),\n-            Unsize => self.tcx.lang_items().unsize_trait(),\n+            Sized => self.interner.tcx.lang_items().sized_trait(),\n+            Copy => self.interner.tcx.lang_items().copy_trait(),\n+            Clone => self.interner.tcx.lang_items().clone_trait(),\n+            Drop => self.interner.tcx.lang_items().drop_trait(),\n+            Fn => self.interner.tcx.lang_items().fn_trait(),\n+            FnMut => self.interner.tcx.lang_items().fn_mut_trait(),\n+            FnOnce => self.interner.tcx.lang_items().fn_once_trait(),\n+            Unsize => self.interner.tcx.lang_items().unsize_trait(),\n         };\n         def_id.map(chalk_ir::TraitId)\n     }\n \n     fn is_object_safe(&self, trait_id: chalk_ir::TraitId<RustInterner<'tcx>>) -> bool {\n-        self.tcx.is_object_safe(trait_id.0)\n+        self.interner.tcx.is_object_safe(trait_id.0)\n     }\n \n     fn hidden_opaque_type(\n         &self,\n         _id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n     ) -> chalk_ir::Ty<RustInterner<'tcx>> {\n         // FIXME(chalk): actually get hidden ty\n-        self.tcx.mk_ty(ty::Tuple(self.tcx.intern_substs(&[]))).lower_into(&self.interner)\n+        self.interner\n+            .tcx\n+            .mk_ty(ty::Tuple(self.interner.tcx.intern_substs(&[])))\n+            .lower_into(&self.interner)\n     }\n \n     fn closure_kind("}, {"sha": "a67bd492a39e77dd9dd2c10b96a9d0b148610ff0", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6905694658e2f239c7054f063e962d9097dd1be/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6905694658e2f239c7054f063e962d9097dd1be/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=f6905694658e2f239c7054f063e962d9097dd1be", "patch": "@@ -880,10 +880,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n         result\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        t.super_fold_with(self)\n-    }\n-\n     fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n         match r {\n             ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n@@ -914,18 +910,18 @@ crate struct ParamsSubstitutor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     binder_index: ty::DebruijnIndex,\n     list: Vec<rustc_middle::ty::ParamTy>,\n-    next_ty_placehoder: usize,\n+    next_ty_placeholder: usize,\n     crate params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n     crate named_regions: BTreeMap<DefId, u32>,\n }\n \n impl<'tcx> ParamsSubstitutor<'tcx> {\n-    crate fn new(tcx: TyCtxt<'tcx>, next_ty_placehoder: usize) -> Self {\n+    crate fn new(tcx: TyCtxt<'tcx>, next_ty_placeholder: usize) -> Self {\n         ParamsSubstitutor {\n             tcx,\n             binder_index: ty::INNERMOST,\n             list: vec![],\n-            next_ty_placehoder,\n+            next_ty_placeholder,\n             params: rustc_data_structures::fx::FxHashMap::default(),\n             named_regions: BTreeMap::default(),\n         }\n@@ -957,7 +953,7 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n                 })),\n                 None => {\n                     self.list.push(param);\n-                    let idx = self.list.len() - 1 + self.next_ty_placehoder;\n+                    let idx = self.list.len() - 1 + self.next_ty_placeholder;\n                     self.params.insert(idx, param);\n                     self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                         universe: ty::UniverseIndex::from_usize(0),\n@@ -997,29 +993,25 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n /// Used to collect `Placeholder`s.\n crate struct PlaceholdersCollector {\n     universe_index: ty::UniverseIndex,\n-    crate next_ty_placehoder: usize,\n+    crate next_ty_placeholder: usize,\n     crate next_anon_region_placeholder: u32,\n }\n \n impl PlaceholdersCollector {\n     crate fn new() -> Self {\n         PlaceholdersCollector {\n             universe_index: ty::UniverseIndex::ROOT,\n-            next_ty_placehoder: 0,\n+            next_ty_placeholder: 0,\n             next_anon_region_placeholder: 0,\n         }\n     }\n }\n \n impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n-        t.super_visit_with(self)\n-    }\n-\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         match t.kind {\n             ty::Placeholder(p) if p.universe == self.universe_index => {\n-                self.next_ty_placehoder = self.next_ty_placehoder.max(p.name.as_usize() + 1);\n+                self.next_ty_placeholder = self.next_ty_placeholder.max(p.name.as_usize() + 1);\n             }\n \n             _ => (),\n@@ -1065,14 +1057,6 @@ impl<'tcx> TypeFolder<'tcx> for RegionsSubstitutor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> Binder<T> {\n-        t.super_fold_with(self)\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        t.super_fold_with(self)\n-    }\n-\n     fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n         match r {\n             ty::ReStatic => self.restatic_placeholder,"}, {"sha": "c0d4a5d0e7e5c2ea78cb50502a3f2d309542e454", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6905694658e2f239c7054f063e962d9097dd1be/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6905694658e2f239c7054f063e962d9097dd1be/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=f6905694658e2f239c7054f063e962d9097dd1be", "patch": "@@ -53,8 +53,9 @@ crate fn evaluate_goal<'tcx>(\n     }));\n \n     let mut params_substitutor =\n-        ParamsSubstitutor::new(tcx, placeholders_collector.next_ty_placehoder);\n+        ParamsSubstitutor::new(tcx, placeholders_collector.next_ty_placeholder);\n     let obligation = obligation.fold_with(&mut params_substitutor);\n+    // FIXME(chalk): we really should be substituting these back in the solution\n     let _params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n \n     let mut regions_substitutor =\n@@ -63,7 +64,7 @@ crate fn evaluate_goal<'tcx>(\n \n     let max_universe = obligation.max_universe.index();\n \n-    let _lowered_goal: chalk_ir::UCanonical<\n+    let lowered_goal: chalk_ir::UCanonical<\n         chalk_ir::InEnvironment<chalk_ir::Goal<ChalkRustInterner<'tcx>>>,\n     > = chalk_ir::UCanonical {\n         canonical: chalk_ir::Canonical {\n@@ -101,17 +102,17 @@ crate fn evaluate_goal<'tcx>(\n \n     use chalk_solve::Solver;\n     let mut solver = chalk_engine::solve::SLGSolver::new(32, None);\n-    let db = ChalkRustIrDatabase { tcx, interner, restatic_placeholder, reempty_placeholder };\n-    let solution = chalk_solve::logging::with_tracing_logs(|| solver.solve(&db, &_lowered_goal));\n+    let db = ChalkRustIrDatabase { interner, restatic_placeholder, reempty_placeholder };\n+    let solution = chalk_solve::logging::with_tracing_logs(|| solver.solve(&db, &lowered_goal));\n \n     // Ideally, the code to convert *back* to rustc types would live close to\n     // the code to convert *from* rustc types. Right now though, we don't\n     // really need this and so it's really minimal.\n     // Right now, we also treat a `Unique` solution the same as\n     // `Ambig(Definite)`. This really isn't right.\n-    let make_solution = |_subst: chalk_ir::Substitution<_>| {\n+    let make_solution = |subst: chalk_ir::Substitution<_>| {\n         let mut var_values: IndexVec<BoundVar, GenericArg<'tcx>> = IndexVec::new();\n-        _subst.as_slice(&interner).iter().for_each(|p| {\n+        subst.as_slice(&interner).iter().for_each(|p| {\n             var_values.push(p.lower_into(&interner));\n         });\n         let sol = Canonical {\n@@ -128,13 +129,13 @@ crate fn evaluate_goal<'tcx>(\n     };\n     solution\n         .map(|s| match s {\n-            Solution::Unique(_subst) => {\n+            Solution::Unique(subst) => {\n                 // FIXME(chalk): handle constraints\n-                make_solution(_subst.value.subst)\n+                make_solution(subst.value.subst)\n             }\n-            Solution::Ambig(_guidance) => {\n-                match _guidance {\n-                    chalk_solve::Guidance::Definite(_subst) => make_solution(_subst.value),\n+            Solution::Ambig(guidance) => {\n+                match guidance {\n+                    chalk_solve::Guidance::Definite(subst) => make_solution(subst.value),\n                     chalk_solve::Guidance::Suggested(_) => unimplemented!(),\n                     chalk_solve::Guidance::Unknown => {\n                         // chalk_fulfill doesn't use the var_values here, so"}]}