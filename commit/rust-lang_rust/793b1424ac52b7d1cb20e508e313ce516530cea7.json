{"sha": "793b1424ac52b7d1cb20e508e313ce516530cea7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5M2IxNDI0YWM1MmI3ZDFjYjIwZTUwOGUzMTNjZTUxNjUzMGNlYTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-19T16:01:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-19T16:01:43Z"}, "message": "auto merge of #15772 : treeman/rust/hashset-doc, r=alexcrichton\n\nExample how to use the set with a custom type. Fill in examples for the missing methods. Also group implemented traits below `HashSet` method impl.", "tree": {"sha": "f400197674a3da0aa6b82a3ec04c7484b66ab452", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f400197674a3da0aa6b82a3ec04c7484b66ab452"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/793b1424ac52b7d1cb20e508e313ce516530cea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/793b1424ac52b7d1cb20e508e313ce516530cea7", "html_url": "https://github.com/rust-lang/rust/commit/793b1424ac52b7d1cb20e508e313ce516530cea7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/793b1424ac52b7d1cb20e508e313ce516530cea7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca3843482928a1acf9482aa2e6cb29a850392ac7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3843482928a1acf9482aa2e6cb29a850392ac7", "html_url": "https://github.com/rust-lang/rust/commit/ca3843482928a1acf9482aa2e6cb29a850392ac7"}, {"sha": "01b6fd3e82f84a504f37597152c39da9929fbfbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b6fd3e82f84a504f37597152c39da9929fbfbf", "html_url": "https://github.com/rust-lang/rust/commit/01b6fd3e82f84a504f37597152c39da9929fbfbf"}], "stats": {"total": 186, "additions": 140, "deletions": 46}, "files": [{"sha": "14027bc1f544fd868dbd0fd3df90742d36dae616", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 140, "deletions": 46, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/793b1424ac52b7d1cb20e508e313ce516530cea7/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1424ac52b7d1cb20e508e313ce516530cea7/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=793b1424ac52b7d1cb20e508e313ce516530cea7", "patch": "@@ -1514,54 +1514,44 @@ pub type SetMoveItems<K> =\n ///     println!(\"{}\", *book);\n /// }\n /// ```\n+///\n+/// The easiest way to use `HashSet` with a custom type is to derive\n+/// `Eq` and `Hash`. We must also derive `PartialEq`, this will in the\n+/// future be implied by `Eq`.\n+///\n+/// ```rust\n+/// use std::collections::HashSet;\n+///\n+/// #[deriving(Hash, Eq, PartialEq, Show)]\n+/// struct Viking<'a> {\n+///     name: &'a str,\n+///     power: uint,\n+/// }\n+///\n+/// let mut vikings = HashSet::new();\n+///\n+/// vikings.insert(Viking { name: \"Einar\", power: 9u });\n+/// vikings.insert(Viking { name: \"Einar\", power: 9u });\n+/// vikings.insert(Viking { name: \"Olaf\", power: 4u });\n+/// vikings.insert(Viking { name: \"Harald\", power: 8u });\n+///\n+/// // Use derived implementation to print the vikings.\n+/// for x in vikings.iter() {\n+///     println!(\"{}\", x);\n+/// }\n+/// ```\n #[deriving(Clone)]\n pub struct HashSet<T, H = RandomSipHasher> {\n     map: HashMap<T, (), H>\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n-    fn eq(&self, other: &HashSet<T, H>) -> bool {\n-        if self.len() != other.len() { return false; }\n-\n-        self.iter().all(|key| other.contains(key))\n-    }\n-}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Collection for HashSet<T, H> {\n-    fn len(&self) -> uint { self.map.len() }\n-}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n-    fn clear(&mut self) { self.map.clear() }\n-}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n-    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n-\n-    fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n-        self.iter().all(|v| !other.contains(v))\n-    }\n-\n-    fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n-        self.iter().all(|v| other.contains(v))\n-    }\n-}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n-    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n-\n-    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-}\n-\n impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n-    /// Create an empty HashSet\n+    /// Create an empty HashSet.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// # use std::collections::HashSet;\n+    /// use std::collections::HashSet;\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// ```\n     #[inline]\n@@ -1575,7 +1565,7 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # use std::collections::HashSet;\n+    /// use std::collections::HashSet;\n     /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n     /// ```\n     #[inline]\n@@ -1589,6 +1579,17 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// keys.\n     ///\n     /// The hash set is also created with the default initial capacity.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::collections::HashSet;\n+    /// use std::hash::sip::SipHasher;\n+    ///\n+    /// let h = SipHasher::new();\n+    /// let mut set = HashSet::with_hasher(h);\n+    /// set.insert(2u);\n+    /// ```\n     #[inline]\n     pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n         HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n@@ -1601,6 +1602,17 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// is designed to allow `HashSet`s to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::collections::HashSet;\n+    /// use std::hash::sip::SipHasher;\n+    ///\n+    /// let h = SipHasher::new();\n+    /// let mut set = HashSet::with_capacity_and_hasher(10u, h);\n+    /// set.insert(1i);\n+    /// ```\n     #[inline]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> {\n         HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n@@ -1611,7 +1623,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # use std::collections::HashSet;\n+    /// use std::collections::HashSet;\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// set.reserve(10);\n     /// ```\n@@ -1621,6 +1633,45 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n \n     /// Returns true if the hash set contains a value equivalent to the\n     /// given query value.\n+    ///\n+    /// # Example\n+    ///\n+    /// This is a slightly silly example where we define the number's\n+    /// parity as the equivilance class. It is important that the\n+    /// values hash the same, which is why we implement `Hash`.\n+    ///\n+    /// ```rust\n+    /// use std::collections::HashSet;\n+    /// use std::hash::Hash;\n+    /// use std::hash::sip::SipState;\n+    ///\n+    /// #[deriving(Eq, PartialEq)]\n+    /// struct EvenOrOdd {\n+    ///     num: uint\n+    /// };\n+    ///\n+    /// impl Hash for EvenOrOdd {\n+    ///     fn hash(&self, state: &mut SipState) {\n+    ///         let parity = self.num % 2;\n+    ///         parity.hash(state);\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n+    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n+    ///         self.num % 2 == other.num % 2\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut set = HashSet::new();\n+    /// set.insert(EvenOrOdd { num: 3u });\n+    ///\n+    /// assert!(set.contains_equiv(&EvenOrOdd { num: 3u }));\n+    /// assert!(set.contains_equiv(&EvenOrOdd { num: 5u }));\n+    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 4u }));\n+    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 2u }));\n+    ///\n+    /// ```\n     pub fn contains_equiv<Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool {\n       self.map.contains_key_equiv(value)\n     }\n@@ -1631,7 +1682,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # use std::collections::HashSet;\n+    /// use std::collections::HashSet;\n+    ///\n     /// let mut set = HashSet::new();\n     /// set.insert(\"a\");\n     /// set.insert(\"b\");\n@@ -1652,7 +1704,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # use std::collections::HashSet;\n+    /// use std::collections::HashSet;\n+    ///\n     /// let mut set = HashSet::new();\n     /// set.insert(\"a\".to_string());\n     /// set.insert(\"b\".to_string());\n@@ -1674,7 +1727,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # use std::collections::HashSet;\n+    /// use std::collections::HashSet;\n+    ///\n     /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n     /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n@@ -1703,7 +1757,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # use std::collections::HashSet;\n+    /// use std::collections::HashSet;\n+    ///\n     /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n     /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n@@ -1728,7 +1783,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # use std::collections::HashSet;\n+    /// use std::collections::HashSet;\n+    ///\n     /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n     /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n@@ -1753,7 +1809,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # use std::collections::HashSet;\n+    /// use std::collections::HashSet;\n+    ///\n     /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n     /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n@@ -1771,6 +1828,43 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     }\n }\n \n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n+    fn eq(&self, other: &HashSet<T, H>) -> bool {\n+        if self.len() != other.len() { return false; }\n+\n+        self.iter().all(|key| other.contains(key))\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Collection for HashSet<T, H> {\n+    fn len(&self) -> uint { self.map.len() }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n+    fn clear(&mut self) { self.map.clear() }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n+    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n+\n+    fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n+        self.iter().all(|v| !other.contains(v))\n+    }\n+\n+    fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n+        self.iter().all(|v| other.contains(v))\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n+    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+}\n+\n+\n impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));"}]}