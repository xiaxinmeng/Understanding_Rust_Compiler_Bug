{"sha": "a9a348f2fbb9f69d2378850de39797e516c5c77b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YTM0OGYyZmJiOWY2OWQyMzc4ODUwZGUzOTc5N2U1MTZjNWM3N2I=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-05T14:53:27Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-05T14:53:27Z"}, "message": "extra::treemap: share code between the mutable and immutable iterators.\n\nYay for macros.", "tree": {"sha": "b801bcd5cc0448aed777490b4d114e57ec42a49e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b801bcd5cc0448aed777490b4d114e57ec42a49e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9a348f2fbb9f69d2378850de39797e516c5c77b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9a348f2fbb9f69d2378850de39797e516c5c77b", "html_url": "https://github.com/rust-lang/rust/commit/a9a348f2fbb9f69d2378850de39797e516c5c77b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9a348f2fbb9f69d2378850de39797e516c5c77b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e33fcf9da9a238b8c71b46b8257f94d02c990b5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e33fcf9da9a238b8c71b46b8257f94d02c990b5c", "html_url": "https://github.com/rust-lang/rust/commit/e33fcf9da9a238b8c71b46b8257f94d02c990b5c"}], "stats": {"total": 476, "additions": 205, "deletions": 271}, "files": [{"sha": "f4fd81437fc6eaf4bad91ec78541d024564abfc5", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 205, "deletions": 271, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/a9a348f2fbb9f69d2378850de39797e516c5c77b/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a348f2fbb9f69d2378850de39797e516c5c77b/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=a9a348f2fbb9f69d2378850de39797e516c5c77b", "patch": "@@ -169,8 +169,57 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     }\n \n \n+    /// Get a lazy iterator that consumes the treemap.\n+    pub fn move_iter(self) -> TreeMapMoveIterator<K, V> {\n+        let TreeMap { root: root, length: length } = self;\n+        let stk = match root {\n+            None => ~[],\n+            Some(~tn) => ~[tn]\n+        };\n+        TreeMapMoveIterator {\n+            stack: stk,\n+            remaining: length\n+        }\n+    }\n+}\n+\n+// range iterators.\n+\n+macro_rules! bound_setup {\n+    // initialiser of the iterator to manipulate\n+    ($iter:expr,\n+     // whether we are looking for the lower or upper bound.\n+     $is_lower_bound:expr) => {\n+        {\n+            let mut iter = $iter;\n+            loop {\n+                if !iter.node.is_null() {\n+                    let node_k = unsafe {&(*iter.node).key};\n+                    match k.cmp(node_k) {\n+                        Less => iter.traverse_left(),\n+                        Greater => iter.traverse_right(),\n+                        Equal => {\n+                            if $is_lower_bound {\n+                                iter.traverse_complete();\n+                                return iter;\n+                            } else {\n+                                iter.traverse_right()\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    iter.traverse_complete();\n+                    return iter;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Get a lazy iterator that should be initialized using\n-    /// `iter_traverse_left`/`iter_traverse_right`/`iter_traverse_complete`.\n+    /// `traverse_left`/`traverse_right`/`traverse_complete`.\n     fn iter_for_traversal<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n         TreeMapIterator {\n             stack: ~[],\n@@ -183,49 +232,17 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n     /// If all keys in map are less than `k` an empty iterator is returned.\n     pub fn lower_bound<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n-        let mut iter: TreeMapIterator<'a, K, V> = self.iter_for_traversal();\n-        loop {\n-            match iter.node {\n-              Some(r) => {\n-                match k.cmp(&r.key) {\n-                  Less => iter_traverse_left(&mut iter),\n-                  Greater => iter_traverse_right(&mut iter),\n-                  Equal => {\n-                    iter_traverse_complete(&mut iter);\n-                    return iter;\n-                  }\n-                }\n-              }\n-              None => {\n-                iter_traverse_complete(&mut iter);\n-                return iter;\n-              }\n-            }\n-        }\n+        bound_setup!(self.iter_for_traversal(), true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n     /// If all keys in map are not greater than `k` an empty iterator is returned.\n     pub fn upper_bound<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n-        let mut iter: TreeMapIterator<'a, K, V> = self.iter_for_traversal();\n-        loop {\n-            match iter.node {\n-              Some(r) => {\n-                match k.cmp(&r.key) {\n-                  Less => iter_traverse_left(&mut iter),\n-                  Greater => iter_traverse_right(&mut iter),\n-                  Equal => iter_traverse_right(&mut iter)\n-                }\n-              }\n-              None => {\n-                iter_traverse_complete(&mut iter);\n-                return iter;\n-              }\n-            }\n-        }\n+        bound_setup!(self.iter_for_traversal(), false)\n     }\n+\n     /// Get a lazy iterator that should be initialized using\n-    /// `mut_iter_traverse_left`/`mut_iter_traverse_right`/`mut_iter_traverse_complete`.\n+    /// `traverse_left`/`traverse_right`/`traverse_complete`.\n     fn mut_iter_for_traversal<'a>(&'a mut self) -> TreeMapMutIterator<'a, K, V> {\n         TreeMapMutIterator {\n             stack: ~[],\n@@ -241,23 +258,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// If all keys in map are less than `k` an empty iterator is\n     /// returned.\n     pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> TreeMapMutIterator<'a, K, V> {\n-        let mut iter = self.mut_iter_for_traversal();\n-        loop {\n-            if !iter.node.is_null() {\n-                let node_k = unsafe {&(*iter.node).key};\n-                match k.cmp(node_k) {\n-                    Less => mut_iter_traverse_left(&mut iter),\n-                    Greater => mut_iter_traverse_right(&mut iter),\n-                    Equal => {\n-                        mut_iter_traverse_complete(&mut iter);\n-                        return iter;\n-                    }\n-                }\n-            } else {\n-                mut_iter_traverse_complete(&mut iter);\n-                return iter;\n-            }\n-        }\n+        bound_setup!(self.mut_iter_for_traversal(), true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair (with the\n@@ -266,160 +267,26 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// If all keys in map are not greater than `k` an empty iterator\n     /// is returned.\n     pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> TreeMapMutIterator<'a, K, V> {\n-        let mut iter = self.mut_iter_for_traversal();\n-        loop {\n-            if !iter.node.is_null() {\n-                let node_k = unsafe {&(*iter.node).key};\n-                match k.cmp(node_k) {\n-                  Less => mut_iter_traverse_left(&mut iter),\n-                  Greater => mut_iter_traverse_right(&mut iter),\n-                  Equal => mut_iter_traverse_right(&mut iter)\n-                }\n-            } else {\n-                mut_iter_traverse_complete(&mut iter);\n-                return iter;\n-            }\n-        }\n-    }\n-\n-    /// Get a lazy iterator that consumes the treemap.\n-    pub fn move_iter(self) -> TreeMapMoveIterator<K, V> {\n-        let TreeMap { root: root, length: length } = self;\n-        let stk = match root {\n-            None => ~[],\n-            Some(~tn) => ~[tn]\n-        };\n-        TreeMapMoveIterator {\n-            stack: stk,\n-            remaining: length\n-        }\n+        bound_setup!(self.mut_iter_for_traversal(), false)\n     }\n }\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<'a, K, V> {\n     priv stack: ~[&'a TreeNode<K, V>],\n-    priv node: Option<&'a TreeNode<K, V>>,\n+    // See the comment on TreeMapMutIterator; this is just to allow\n+    // code-sharing (for this immutable-values iterator it *could* very\n+    // well be Option<&'a TreeNode<K,V>>).\n+    priv node: *TreeNode<K, V>,\n     priv remaining_min: uint,\n     priv remaining_max: uint\n }\n \n-fn deref<'a, K, V>(node: &'a Option<~TreeNode<K, V>>) -> Option<&'a TreeNode<K, V>> {\n-    match *node {\n-        Some(ref n) => {\n-            let n: &TreeNode<K, V> = *n;\n-            Some(n)\n-        }\n-        None => None\n-    }\n-}\n-\n-impl<'a, K, V> TreeMapIterator<'a, K, V> {\n-    #[inline(always)]\n-    fn next_(&mut self, forward: bool) -> Option<(&'a K, &'a V)> {\n-        while !self.stack.is_empty() || self.node.is_some() {\n-            match self.node {\n-              Some(x) => {\n-                self.stack.push(x);\n-                self.node = deref(if forward { &x.left } else { &x.right });\n-              }\n-              None => {\n-                let res = self.stack.pop();\n-                self.node = deref(if forward { &res.right } else { &res.left });\n-                self.remaining_max -= 1;\n-                if self.remaining_min > 0 {\n-                    self.remaining_min -= 1;\n-                }\n-                return Some((&res.key, &res.value));\n-              }\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for TreeMapIterator<'a, K, V> {\n-    /// Advance the iterator to the next node (in order) and return a\n-    /// tuple with a reference to the key and value. If there are no\n-    /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.next_(true)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining_min, Some(self.remaining_max))\n-    }\n-}\n-\n /// Lazy backward iterator over a map\n pub struct TreeMapRevIterator<'a, K, V> {\n     priv iter: TreeMapIterator<'a, K, V>,\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for TreeMapRevIterator<'a, K, V> {\n-    /// Advance the iterator to the next node (in order) and return a\n-    /// tuple with a reference to the key and value. If there are no\n-    /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.iter.next_(false)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n-/// initialize TreeMapIterator pointing to element inside tree structure.\n-///\n-/// They should be used in following manner:\n-///   - create iterator using TreeMap::iter_for_traversal\n-///   - find required node using `iter_traverse_left`/`iter_traverse_right`\n-///     (current node is `TreeMapIterator::node` field)\n-///   - complete initialization with `iter_traverse_complete`\n-#[inline]\n-fn iter_traverse_left<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n-    let node = it.node.unwrap();\n-    it.stack.push(node);\n-    it.node = deref(&node.left);\n-}\n-\n-#[inline]\n-fn iter_traverse_right<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n-    it.node = deref(&it.node.get_ref().right);\n-}\n-\n-/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n-/// initialize TreeMapIterator pointing to element inside tree structure.\n-///\n-/// Completes traversal. Should be called before using iterator.\n-/// Iteration will start from `self.node`.\n-/// If `self.node` is None iteration will start from last node from which we\n-/// traversed left.\n-#[inline]\n-fn iter_traverse_complete<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n-    match it.node {\n-        Some(n) => {\n-            it.stack.push(n);\n-            it.node = None;\n-        }\n-        None => ()\n-    }\n-}\n-\n-\n-fn mut_deref<K, V>(x: &mut Option<~TreeNode<K, V>>) -> *mut TreeNode<K, V> {\n-    match *x {\n-        Some(ref mut n) => {\n-            let n: &mut TreeNode<K, V> = *n;\n-            n as *mut TreeNode<K, V>\n-        }\n-        None => ptr::mut_null()\n-    }\n-}\n-\n /// Lazy forward iterator over a map that allows for the mutation of\n /// the values.\n pub struct TreeMapMutIterator<'a, K, V> {\n@@ -448,102 +315,169 @@ pub struct TreeMapMutIterator<'a, K, V> {\n     priv remaining_max: uint\n }\n \n-impl<'a, K, V> TreeMapMutIterator<'a, K, V> {\n-    #[inline(always)]\n-    fn next_(&mut self, forward: bool) -> Option<(&'a K, &'a mut V)> {\n-        while !self.stack.is_empty() || !self.node.is_null() {\n-            let node = self.node;\n-            if !node.is_null() {\n-                let node = unsafe {&mut *node};\n-                {\n-                    let next_node = if forward { &mut node.left } else { &mut node.right };\n-                    self.node = mut_deref(next_node);\n+/// Lazy backward iterator over a map\n+pub struct TreeMapMutRevIterator<'a, K, V> {\n+    priv iter: TreeMapMutIterator<'a, K, V>,\n+}\n+\n+\n+// FIXME #5846 we want to be able to choose between &x and &mut x\n+// (with many different `x`) below, so we need to optionally pass mut\n+// as a tt, but the only thing we can do with a `tt` is pass them to\n+// other macros, so this takes the `& <mutability> <operand>` token\n+// sequence and forces their evalutation as an expression.\n+macro_rules! addr { ($e:expr) => { $e }}\n+\n+macro_rules! define_iterator {\n+    ($name:ident,\n+     $rev_name:ident,\n+     // the type of the values of the treemap in the return value of\n+     // the iterator (i.e. &V or &mut V). This is non-hygienic in the\n+     // name of the lifetime.\n+     value_type = $value_type:ty,\n+\n+     // the function to go from &m Option<~TreeNode> to *m TreeNode\n+     deref = $deref:ident,\n+\n+     // see comment on `addr!`, this is just an optional `mut`, but\n+     // there's no support for 0-or-1 repeats.\n+     addr_mut = $($addr_mut:tt)*\n+     ) => {\n+        // private methods on the forward iterator\n+        impl<'a, K, V> $name<'a, K, V> {\n+            #[inline(always)]\n+            fn next_(&mut self, forward: bool) -> Option<(&'a K, $value_type)> {\n+                while !self.stack.is_empty() || !self.node.is_null() {\n+                    if !self.node.is_null() {\n+                        let node = unsafe {addr!(& $($addr_mut)* *self.node)};\n+                        {\n+                            let next_node = if forward {\n+                                addr!(& $($addr_mut)* node.left)\n+                            } else {\n+                                addr!(& $($addr_mut)* node.right)\n+                            };\n+                            self.node = $deref(next_node);\n+                        }\n+                        self.stack.push(node);\n+                    } else {\n+                        let node = self.stack.pop();\n+                        let next_node = if forward {\n+                            addr!(& $($addr_mut)* node.right)\n+                        } else {\n+                            addr!(& $($addr_mut)* node.left)\n+                        };\n+                        self.node = $deref(next_node);\n+                        self.remaining_max -= 1;\n+                        if self.remaining_min > 0 {\n+                            self.remaining_min -= 1;\n+                        }\n+                        return Some((&node.key, addr!(& $($addr_mut)* node.value)));\n+                    }\n                 }\n+                None\n+            }\n+\n+            /// traverse_left, traverse_right and traverse_complete are\n+            /// used to initialize TreeMapIterator/TreeMapMutIterator\n+            /// pointing to element inside tree structure.\n+            ///\n+            /// They should be used in following manner:\n+            ///   - create iterator using TreeMap::[mut_]iter_for_traversal\n+            ///   - find required node using `traverse_left`/`traverse_right`\n+            ///     (current node is `TreeMapIterator::node` field)\n+            ///   - complete initialization with `traverse_complete`\n+            ///\n+            /// After this, iteration will start from `self.node`.  If\n+            /// `self.node` is None iteration will start from last\n+            /// node from which we traversed left.\n+            #[inline]\n+            fn traverse_left(&mut self) {\n+                let node = unsafe {addr!(& $($addr_mut)* *self.node)};\n+                self.node = $deref(addr!(& $($addr_mut)* node.left));\n                 self.stack.push(node);\n-            } else {\n-                let node = self.stack.pop();\n-                self.node = mut_deref(if forward { &mut node.right } else { &mut node.left });\n-                self.remaining_max -= 1;\n-                if self.remaining_min > 0 {\n-                    self.remaining_min -= 1;\n+            }\n+\n+            #[inline]\n+            fn traverse_right(&mut self) {\n+                let node = unsafe {addr!(& $($addr_mut)* *self.node)};\n+                self.node = $deref(addr!(& $($addr_mut)* node.right));\n+            }\n+\n+            #[inline]\n+            fn traverse_complete(&mut self) {\n+                if !self.node.is_null() {\n+                    unsafe {\n+                        self.stack.push(addr!(& $($addr_mut)* *self.node));\n+                    }\n+                    self.node = ptr::RawPtr::null();\n                 }\n-                return Some((&node.key, &mut node.value));\n             }\n         }\n-        None\n-    }\n-}\n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for TreeMapMutIterator<'a, K, V> {\n-    /// Advance the iterator to the next node (in order) and return a\n-    /// tuple with a reference to the key and value. If there are no\n-    /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.next_(true)\n-    }\n+        // the forward Iterator impl.\n+        impl<'a, K, V> Iterator<(&'a K, $value_type)> for $name<'a, K, V> {\n+            /// Advance the iterator to the next node (in order) and return a\n+            /// tuple with a reference to the key and value. If there are no\n+            /// more nodes, return `None`.\n+            fn next(&mut self) -> Option<(&'a K, $value_type)> {\n+                self.next_(true)\n+            }\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining_min, Some(self.remaining_max))\n-    }\n-}\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                (self.remaining_min, Some(self.remaining_max))\n+            }\n+        }\n \n-/// Lazy backward iterator over a map\n-pub struct TreeMapMutRevIterator<'a, K, V> {\n-    priv iter: TreeMapMutIterator<'a, K, V>,\n-}\n+        // the reverse Iterator impl.\n+        impl<'a, K, V> Iterator<(&'a K, $value_type)> for $rev_name<'a, K, V> {\n+            fn next(&mut self) -> Option<(&'a K, $value_type)> {\n+                self.iter.next_(false)\n+            }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for TreeMapMutRevIterator<'a, K, V> {\n-    /// Advance the iterator to the next node (in order) and return a\n-    /// tuple with a reference to the key and value. If there are no\n-    /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.iter.next_(false)\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                self.iter.size_hint()\n+            }\n+        }\n     }\n+} // end of define_iterator\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n+define_iterator! {\n+    TreeMapIterator,\n+    TreeMapRevIterator,\n+    value_type = &'a V,\n+    deref = deref,\n+\n+    // immutable, so no mut\n+    addr_mut =\n }\n+define_iterator! {\n+    TreeMapMutIterator,\n+    TreeMapMutRevIterator,\n+    value_type = &'a mut V,\n+    deref = mut_deref,\n \n-/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n-/// initialize TreeMapMutIterator pointing to element inside tree structure.\n-///\n-/// They should be used in following manner:\n-///   - create iterator using TreeMap::iter_for_traversal\n-///   - find required node using `iter_traverse_left`/`iter_traverse_right`\n-///     (current node is `TreeMapMutIterator::node` field)\n-///   - complete initialization with `iter_traverse_complete`\n-#[inline]\n-fn mut_iter_traverse_left<'a, K, V>(it: &mut TreeMapMutIterator<'a, K, V>) {\n-    // guaranteed to be non-null\n-    let node = unsafe {&mut *it.node};\n-    it.node = mut_deref(&mut node.left);\n-    it.stack.push(node);\n+    addr_mut = mut\n }\n \n-#[inline]\n-fn mut_iter_traverse_right<'a, K, V>(it: &mut TreeMapMutIterator<'a, K, V>) {\n-    // guaranteed to be non-null\n-    let node = unsafe {&mut *it.node};\n-    it.node = mut_deref(&mut node.right);\n+fn deref<'a, K, V>(node: &'a Option<~TreeNode<K, V>>) -> *TreeNode<K, V> {\n+    match *node {\n+        Some(ref n) => {\n+            let n: &TreeNode<K, V> = *n;\n+            n as *TreeNode<K, V>\n+        }\n+        None => ptr::null()\n+    }\n }\n \n-/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n-/// initialize TreeMapMutIterator pointing to element inside tree structure.\n-///\n-/// Completes traversal. Should be called before using iterator.\n-/// Iteration will start from `self.node`.\n-/// If `self.node` is None iteration will start from last node from which we\n-/// traversed left.\n-#[inline]\n-fn mut_iter_traverse_complete<'a, K, V>(it: &mut TreeMapMutIterator<'a, K, V>) {\n-    if !it.node.is_null() {\n-        unsafe {\n-            it.stack.push(&mut *it.node);\n+fn mut_deref<K, V>(x: &mut Option<~TreeNode<K, V>>) -> *mut TreeNode<K, V> {\n+    match *x {\n+        Some(ref mut n) => {\n+            let n: &mut TreeNode<K, V> = *n;\n+            n as *mut TreeNode<K, V>\n         }\n-        it.node = ptr::mut_null();\n+        None => ptr::mut_null()\n     }\n }\n "}]}