{"sha": "66c297d847ce06a8982d4d322221b17a3cd04f90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YzI5N2Q4NDdjZTA2YTg5ODJkNGQzMjIyMjFiMTdhM2NkMDRmOTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-17T16:43:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-17T16:43:20Z"}, "message": "auto merge of #19800 : sfackler/rust/core-hash, r=alexcrichton\n\nr? @alexcrichton", "tree": {"sha": "176a26b3e25b0e62d904e7af64476098e9f3e46e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/176a26b3e25b0e62d904e7af64476098e9f3e46e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66c297d847ce06a8982d4d322221b17a3cd04f90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66c297d847ce06a8982d4d322221b17a3cd04f90", "html_url": "https://github.com/rust-lang/rust/commit/66c297d847ce06a8982d4d322221b17a3cd04f90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66c297d847ce06a8982d4d322221b17a3cd04f90/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c533efd090e709a682468813aff36c368fdcd9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c533efd090e709a682468813aff36c368fdcd9d", "html_url": "https://github.com/rust-lang/rust/commit/2c533efd090e709a682468813aff36c368fdcd9d"}, {"sha": "24a8ef63ff786dd702d428f73fd64aac2a828f19", "url": "https://api.github.com/repos/rust-lang/rust/commits/24a8ef63ff786dd702d428f73fd64aac2a828f19", "html_url": "https://github.com/rust-lang/rust/commit/24a8ef63ff786dd702d428f73fd64aac2a828f19"}], "stats": {"total": 605, "additions": 433, "deletions": 172}, "files": [{"sha": "c6afeb063fbdef6bbc544495b0956d2a3a908df7", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -15,6 +15,7 @@ use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n+use core::hash::{mod, Hash};\n use core::kinds::Sized;\n use core::mem;\n use core::option::Option;\n@@ -93,6 +94,14 @@ impl<Sized? T: Ord> Ord for Box<T> {\n }\n impl<Sized? T: Eq> Eq for Box<T> {}\n \n+impl<S: hash::Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n+\n+\n /// Extension methods for an owning `Any` trait object.\n #[unstable = \"post-DST and coherence changes, this will not be a trait but \\\n               rather a direct `impl` on `Box<Any>`\"]"}, {"sha": "61b5d43d1cb5011449f3e216135d14ff73a3112f", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -64,7 +64,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![no_std]\n-#![feature(lang_items, phase, unsafe_destructor)]\n+#![feature(lang_items, phase, unsafe_destructor, default_type_params)]\n \n #[phase(plugin, link)]\n extern crate core;"}, {"sha": "7af816f2e09ff493119dfba204f307edd7df433c", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -147,6 +147,7 @@ use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n+use core::hash::{mod, Hash};\n use core::kinds::marker;\n use core::mem::{transmute, min_align_of, size_of, forget};\n use core::ops::{Deref, Drop};\n@@ -594,6 +595,14 @@ impl<T: Ord> Ord for Rc<T> {\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n \n+// FIXME (#18248) Make `T` `Sized?`\n+impl<S: hash::Writer, T: Hash<S>> Hash<S> for Rc<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n+\n #[experimental = \"Show is experimental.\"]\n impl<T: fmt::Show> fmt::Show for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "1d60d7612a0b7cee5b2152d05739eacd3cf2da3f", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -67,7 +67,6 @@ pub mod slice;\n pub mod str;\n pub mod string;\n pub mod vec;\n-pub mod hash;\n pub mod vec_map;\n \n pub mod bitv {\n@@ -116,5 +115,5 @@ mod std {\n     pub use core::clone;    // deriving(Clone)\n     pub use core::cmp;      // deriving(Eq, Ord, etc.)\n     pub use core::kinds;    // deriving(Copy)\n-    pub use hash;           // deriving(Hash)\n+    pub use core::hash;     // deriving(Hash)\n }"}, {"sha": "d14552afebee8db509f8134e5ad848bf7306bd43", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -60,10 +60,10 @@ use self::DecompositionType::*;\n use core::borrow::{BorrowFrom, Cow, ToOwned};\n use core::default::Default;\n use core::fmt;\n+use core::hash;\n use core::cmp;\n use core::iter::AdditiveIterator;\n \n-use hash;\n use ring_buf::RingBuf;\n use string::String;\n use unicode;"}, {"sha": "bc179cb37fb7c1baa741ba1be054d408f4f8d26b", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -17,13 +17,13 @@ use core::prelude::*;\n use core::borrow::{Cow, IntoCow};\n use core::default::Default;\n use core::fmt;\n+use core::hash;\n use core::mem;\n use core::ptr;\n use core::ops;\n // FIXME: ICE's abound if you import the `Slice` type while importing `Slice` trait\n use core::raw::Slice as RawSlice;\n \n-use hash;\n use slice::CloneSliceExt;\n use str;\n use str::{CharRange, CowString, FromStr, StrAllocating, Owned};"}, {"sha": "fa4cfc99753c2d9b2f61931703a3c804dc5bd631", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -20,6 +20,7 @@ use core::borrow::{Cow, IntoCow};\n use core::cmp::max;\n use core::default::Default;\n use core::fmt;\n+use core::hash::{mod, Hash};\n use core::kinds::marker::{ContravariantLifetime, InvariantType};\n use core::kinds::Sized;\n use core::mem;\n@@ -619,6 +620,13 @@ impl<T: Ord> Ord for Vec<T> {\n     }\n }\n \n+impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state);\n+    }\n+}\n+\n // FIXME: #13996: need a way to mark the return value as `noalias`\n #[inline(never)]\n unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {"}, {"sha": "5762acb8e71fe421aac0b8f17fb845dccb5a7c83", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -17,12 +17,12 @@ use core::prelude::*;\n \n use core::default::Default;\n use core::fmt;\n+use core::hash::{Hash, Writer};\n use core::iter;\n use core::iter::{Enumerate, FilterMap};\n use core::mem::replace;\n use core::ops::FnOnce;\n \n-use hash::{Hash, Writer};\n use {vec, slice};\n use vec::Vec;\n \n@@ -642,7 +642,7 @@ pub type MoveItems<V> = FilterMap<\n mod test_map {\n     use std::prelude::*;\n     use vec::Vec;\n-    use hash::hash;\n+    use core::hash::hash;\n \n     use super::VecMap;\n "}, {"sha": "671ab8258293072b39ce7cb1bf3609a72392980e", "filename": "src/libcore/hash/mod.rs", "status": "renamed", "additions": 7, "deletions": 157, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -61,16 +61,12 @@\n \n #![allow(unused_must_use)]\n \n-use core::prelude::*;\n+use prelude::*;\n \n-use alloc::boxed::Box;\n-use alloc::rc::Rc;\n-use core::borrow::{Cow, ToOwned};\n-use core::intrinsics::TypeId;\n-use core::mem;\n-use core::num::Int;\n-\n-use vec::Vec;\n+use borrow::{Cow, ToOwned};\n+use intrinsics::TypeId;\n+use mem;\n+use num::Int;\n \n /// Reexport the `sip::hash` function as our default hasher.\n pub use self::sip::hash as hash;\n@@ -92,6 +88,7 @@ pub trait Hasher<S> {\n     fn hash<Sized? T: Hash<S>>(&self, value: &T) -> u64;\n }\n \n+#[allow(missing_docs)]\n pub trait Writer {\n     fn write(&mut self, bytes: &[u8]);\n }\n@@ -103,7 +100,7 @@ macro_rules! impl_hash {\n         impl<S: Writer> Hash<S> for $ty {\n             #[inline]\n             fn hash(&self, state: &mut S) {\n-                let a: [u8, ..::core::$ty::BYTES] = unsafe {\n+                let a: [u8, ..::$ty::BYTES] = unsafe {\n                     mem::transmute((*self as $uty).to_le() as $ty)\n                 };\n                 state.write(a.as_slice())\n@@ -197,13 +194,6 @@ impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n }\n \n \n-impl<S: Writer, T: Hash<S>> Hash<S> for Vec<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_slice().hash(state);\n-    }\n-}\n-\n impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n@@ -218,36 +208,6 @@ impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a mut T {\n     }\n }\n \n-impl<S: Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-\n-// FIXME (#18248) Make `T` `Sized?`\n-impl<S: Writer, T: Hash<S>> Hash<S> for Rc<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-\n-impl<S: Writer, T: Hash<S>> Hash<S> for Option<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        match *self {\n-            Some(ref x) => {\n-                0u8.hash(state);\n-                x.hash(state);\n-            }\n-            None => {\n-                1u8.hash(state);\n-            }\n-        }\n-    }\n-}\n-\n impl<S: Writer, T> Hash<S> for *const T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n@@ -273,119 +233,9 @@ impl<S: Writer> Hash<S> for TypeId {\n     }\n }\n \n-impl<S: Writer, T: Hash<S>, U: Hash<S>> Hash<S> for Result<T, U> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        match *self {\n-            Ok(ref t) => { 1u.hash(state); t.hash(state); }\n-            Err(ref t) => { 2u.hash(state); t.hash(state); }\n-        }\n-    }\n-}\n-\n impl<'a, T, Sized? B, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         Hash::hash(&**self, state)\n     }\n }\n-\n-//////////////////////////////////////////////////////////////////////////////\n-\n-#[cfg(test)]\n-mod tests {\n-    use core::kinds::Sized;\n-    use std::mem;\n-\n-    use slice::SliceExt;\n-    use super::{Hash, Hasher, Writer};\n-\n-    struct MyWriterHasher;\n-\n-    impl Hasher<MyWriter> for MyWriterHasher {\n-        fn hash<Sized? T: Hash<MyWriter>>(&self, value: &T) -> u64 {\n-            let mut state = MyWriter { hash: 0 };\n-            value.hash(&mut state);\n-            state.hash\n-        }\n-    }\n-\n-    struct MyWriter {\n-        hash: u64,\n-    }\n-\n-    impl Writer for MyWriter {\n-        // Most things we'll just add up the bytes.\n-        fn write(&mut self, buf: &[u8]) {\n-            for byte in buf.iter() {\n-                self.hash += *byte as u64;\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_writer_hasher() {\n-        use alloc::boxed::Box;\n-\n-        let hasher = MyWriterHasher;\n-\n-        assert_eq!(hasher.hash(&()), 0);\n-\n-        assert_eq!(hasher.hash(&5u8), 5);\n-        assert_eq!(hasher.hash(&5u16), 5);\n-        assert_eq!(hasher.hash(&5u32), 5);\n-        assert_eq!(hasher.hash(&5u64), 5);\n-        assert_eq!(hasher.hash(&5u), 5);\n-\n-        assert_eq!(hasher.hash(&5i8), 5);\n-        assert_eq!(hasher.hash(&5i16), 5);\n-        assert_eq!(hasher.hash(&5i32), 5);\n-        assert_eq!(hasher.hash(&5i64), 5);\n-        assert_eq!(hasher.hash(&5i), 5);\n-\n-        assert_eq!(hasher.hash(&false), 0);\n-        assert_eq!(hasher.hash(&true), 1);\n-\n-        assert_eq!(hasher.hash(&'a'), 97);\n-\n-        let s: &str = \"a\";\n-        assert_eq!(hasher.hash(& s), 97 + 0xFF);\n-        // FIXME (#18283) Enable test\n-        //let s: Box<str> = box \"a\";\n-        //assert_eq!(hasher.hash(& s), 97 + 0xFF);\n-        let cs: &[u8] = &[1u8, 2u8, 3u8];\n-        assert_eq!(hasher.hash(& cs), 9);\n-        let cs: Box<[u8]> = box [1u8, 2u8, 3u8];\n-        assert_eq!(hasher.hash(& cs), 9);\n-\n-        // FIXME (#18248) Add tests for hashing Rc<str> and Rc<[T]>\n-\n-        unsafe {\n-            let ptr: *const int = mem::transmute(5i);\n-            assert_eq!(hasher.hash(&ptr), 5);\n-        }\n-\n-        unsafe {\n-            let ptr: *mut int = mem::transmute(5i);\n-            assert_eq!(hasher.hash(&ptr), 5);\n-        }\n-    }\n-\n-    struct Custom {\n-        hash: u64\n-    }\n-\n-    impl Hash<u64> for Custom {\n-        fn hash(&self, state: &mut u64) {\n-            *state = self.hash;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_custom_state() {\n-        let custom = Custom { hash: 5 };\n-        let mut state = 0;\n-        custom.hash(&mut state);\n-        assert_eq!(state, 5);\n-    }\n-}", "previous_filename": "src/libcollections/hash/mod.rs"}, {"sha": "62752072e2f2d3dbb7e8b2d6a34e994805897857", "filename": "src/libcore/hash/sip.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -24,9 +24,8 @@\n //! As such, all cryptographic uses of this implementation are strongly\n //! discouraged.\n \n-use core::prelude::*;\n-\n-use core::default::Default;\n+use prelude::*;\n+use default::Default;\n \n use super::{Hash, Hasher, Writer};\n ", "previous_filename": "src/libcollections/hash/sip.rs"}, {"sha": "729cb69193e63d06a5dc8698ecae39f2ea4d101c", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -121,6 +121,7 @@ pub mod simd;\n pub mod slice;\n pub mod str;\n pub mod tuple;\n+pub mod hash;\n // FIXME #15320: primitive documentation needs top-level modules, this\n // should be `core::tuple::unit`.\n #[path = \"tuple/unit.rs\"]\n@@ -142,4 +143,5 @@ mod std {\n     pub use kinds;\n     pub use option;\n     pub use fmt;\n+    pub use hash;\n }"}, {"sha": "020e907a423da968900e8b3f6df667bded9855f4", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -164,7 +164,7 @@ use ops::{Deref, FnOnce};\n // which basically means it must be `Option`.\n \n /// The `Option` type.\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n #[stable]\n pub enum Option<T> {\n     /// No value"}, {"sha": "6dd23abf11f4764c12489d9a6d24754dcbad73c8", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -244,7 +244,7 @@ use ops::{FnMut, FnOnce};\n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n /// See the [`std::result`](index.html) module documentation for details.\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n #[must_use]\n #[stable]\n pub enum Result<T, E> {"}, {"sha": "23f9be124dadb74f86c3ca5eee52eb2833e01a41", "filename": "src/libcoretest/hash/mod.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use core::kinds::Sized;\n+use std::mem;\n+\n+use core::slice::SliceExt;\n+use core::hash::{Hash, Hasher, Writer};\n+\n+struct MyWriterHasher;\n+\n+impl Hasher<MyWriter> for MyWriterHasher {\n+    fn hash<Sized? T: Hash<MyWriter>>(&self, value: &T) -> u64 {\n+        let mut state = MyWriter { hash: 0 };\n+        value.hash(&mut state);\n+        state.hash\n+    }\n+}\n+\n+struct MyWriter {\n+    hash: u64,\n+}\n+\n+impl Writer for MyWriter {\n+    // Most things we'll just add up the bytes.\n+    fn write(&mut self, buf: &[u8]) {\n+        for byte in buf.iter() {\n+            self.hash += *byte as u64;\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_writer_hasher() {\n+    let hasher = MyWriterHasher;\n+\n+    assert_eq!(hasher.hash(&()), 0);\n+\n+    assert_eq!(hasher.hash(&5u8), 5);\n+    assert_eq!(hasher.hash(&5u16), 5);\n+    assert_eq!(hasher.hash(&5u32), 5);\n+    assert_eq!(hasher.hash(&5u64), 5);\n+    assert_eq!(hasher.hash(&5u), 5);\n+\n+    assert_eq!(hasher.hash(&5i8), 5);\n+    assert_eq!(hasher.hash(&5i16), 5);\n+    assert_eq!(hasher.hash(&5i32), 5);\n+    assert_eq!(hasher.hash(&5i64), 5);\n+    assert_eq!(hasher.hash(&5i), 5);\n+\n+    assert_eq!(hasher.hash(&false), 0);\n+    assert_eq!(hasher.hash(&true), 1);\n+\n+    assert_eq!(hasher.hash(&'a'), 97);\n+\n+    let s: &str = \"a\";\n+    assert_eq!(hasher.hash(& s), 97 + 0xFF);\n+    // FIXME (#18283) Enable test\n+    //let s: Box<str> = box \"a\";\n+    //assert_eq!(hasher.hash(& s), 97 + 0xFF);\n+    let cs: &[u8] = &[1u8, 2u8, 3u8];\n+    assert_eq!(hasher.hash(& cs), 9);\n+    let cs: Box<[u8]> = box [1u8, 2u8, 3u8];\n+    assert_eq!(hasher.hash(& cs), 9);\n+\n+    // FIXME (#18248) Add tests for hashing Rc<str> and Rc<[T]>\n+\n+    unsafe {\n+        let ptr: *const int = mem::transmute(5i);\n+        assert_eq!(hasher.hash(&ptr), 5);\n+    }\n+\n+    unsafe {\n+        let ptr: *mut int = mem::transmute(5i);\n+        assert_eq!(hasher.hash(&ptr), 5);\n+    }\n+}\n+\n+struct Custom {\n+    hash: u64\n+}\n+\n+impl Hash<u64> for Custom {\n+    fn hash(&self, state: &mut u64) {\n+        *state = self.hash;\n+    }\n+}\n+\n+#[test]\n+fn test_custom_state() {\n+    let custom = Custom { hash: 5 };\n+    let mut state = 0;\n+    custom.hash(&mut state);\n+    assert_eq!(state, 5);\n+}"}, {"sha": "8801c2975c8f285feb95562eb573c9004e46c336", "filename": "src/libcoretest/hash/sip.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -0,0 +1,283 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use test::Bencher;\n+use std::prelude::*;\n+use std::fmt;\n+\n+use str::Str;\n+use string::String;\n+use slice::{AsSlice, SlicePrelude};\n+use vec::Vec;\n+\n+use core::hash::{Hash, Writer};\n+use core::hash::sip::{SipState, hash, hash_with_keys};\n+\n+// Hash just the bytes of the slice, without length prefix\n+struct Bytes<'a>(&'a [u8]);\n+\n+impl<'a, S: Writer> Hash<S> for Bytes<'a> {\n+    #[allow(unused_must_use)]\n+    fn hash(&self, state: &mut S) {\n+        let Bytes(v) = *self;\n+        state.write(v);\n+    }\n+}\n+\n+#[test]\n+#[allow(unused_must_use)]\n+fn test_siphash() {\n+    let vecs : [[u8, ..8], ..64] = [\n+        [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n+        [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n+        [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n+        [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n+        [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n+        [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n+        [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n+        [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n+        [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n+        [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n+        [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n+        [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n+        [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n+        [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n+        [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n+        [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n+        [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n+        [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n+        [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n+        [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n+        [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n+        [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n+        [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n+        [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n+        [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n+        [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n+        [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n+        [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n+        [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n+        [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n+        [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n+        [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n+        [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n+        [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n+        [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n+        [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n+        [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n+        [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n+        [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n+        [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n+        [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n+        [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n+        [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n+        [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n+        [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n+        [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n+        [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n+        [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n+        [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n+        [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n+        [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n+        [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n+        [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n+        [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n+        [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n+        [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n+        [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n+        [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n+        [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n+        [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n+        [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n+        [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n+        [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n+        [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n+    ];\n+\n+    let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n+    let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n+    let mut buf = Vec::new();\n+    let mut t = 0;\n+    let mut state_inc = SipState::new_with_keys(k0, k1);\n+    let mut state_full = SipState::new_with_keys(k0, k1);\n+\n+    fn to_hex_str(r: &[u8, ..8]) -> String {\n+        let mut s = String::new();\n+        for b in r.iter() {\n+            s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n+        }\n+        s\n+    }\n+\n+    fn result_bytes(h: u64) -> Vec<u8> {\n+        vec![(h >> 0) as u8,\n+          (h >> 8) as u8,\n+          (h >> 16) as u8,\n+          (h >> 24) as u8,\n+          (h >> 32) as u8,\n+          (h >> 40) as u8,\n+          (h >> 48) as u8,\n+          (h >> 56) as u8,\n+        ]\n+    }\n+\n+    fn result_str(h: u64) -> String {\n+        let r = result_bytes(h);\n+        let mut s = String::new();\n+        for b in r.iter() {\n+            s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n+        }\n+        s\n+    }\n+\n+    while t < 64 {\n+        debug!(\"siphash test {}: {}\", t, buf);\n+        let vec = u8to64_le!(vecs[t], 0);\n+        let out = hash_with_keys(k0, k1, &Bytes(buf.as_slice()));\n+        debug!(\"got {}, expected {}\", out, vec);\n+        assert_eq!(vec, out);\n+\n+        state_full.reset();\n+        state_full.write(buf.as_slice());\n+        let f = result_str(state_full.result());\n+        let i = result_str(state_inc.result());\n+        let v = to_hex_str(&vecs[t]);\n+        debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n+\n+        assert_eq!(f, i);\n+        assert_eq!(f, v);\n+\n+        buf.push(t as u8);\n+        state_inc.write(&[t as u8]);\n+\n+        t += 1;\n+    }\n+}\n+\n+#[test] #[cfg(target_arch = \"arm\")]\n+fn test_hash_uint() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+    assert!(hash(&(val as u64)) != hash(&(val as uint)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n+}\n+#[test] #[cfg(target_arch = \"x86_64\")]\n+fn test_hash_uint() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+    assert_eq!(hash(&(val as u64)), hash(&(val as uint)));\n+    assert!(hash(&(val as u32)) != hash(&(val as uint)));\n+}\n+#[test] #[cfg(target_arch = \"x86\")]\n+fn test_hash_uint() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+    assert!(hash(&(val as u64)) != hash(&(val as uint)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n+}\n+\n+#[test]\n+fn test_hash_idempotent() {\n+    let val64 = 0xdeadbeef_deadbeef_u64;\n+    assert_eq!(hash(&val64), hash(&val64));\n+    let val32 = 0xdeadbeef_u32;\n+    assert_eq!(hash(&val32), hash(&val32));\n+}\n+\n+#[test]\n+fn test_hash_no_bytes_dropped_64() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+\n+    assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 4)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 5)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 6)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 7)));\n+\n+    fn zero_byte(val: u64, byte: uint) -> u64 {\n+        assert!(byte < 8);\n+        val & !(0xff << (byte * 8))\n+    }\n+}\n+\n+#[test]\n+fn test_hash_no_bytes_dropped_32() {\n+    let val = 0xdeadbeef_u32;\n+\n+    assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+\n+    fn zero_byte(val: u32, byte: uint) -> u32 {\n+        assert!(byte < 4);\n+        val & !(0xff << (byte * 8))\n+    }\n+}\n+\n+#[test]\n+fn test_hash_no_concat_alias() {\n+    let s = (\"aa\", \"bb\");\n+    let t = (\"aabb\", \"\");\n+    let u = (\"a\", \"abb\");\n+\n+    assert!(s != t && t != u);\n+    assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n+\n+    let v: (&[u8], &[u8], &[u8]) = (&[1u8], &[0u8, 0], &[0u8]);\n+    let w: (&[u8], &[u8], &[u8]) = (&[1u8, 0, 0, 0], &[], &[]);\n+\n+    assert!(v != w);\n+    assert!(hash(&v) != hash(&w));\n+}\n+\n+#[bench]\n+fn bench_str_under_8_bytes(b: &mut Bencher) {\n+    let s = \"foo\";\n+    b.iter(|| {\n+        assert_eq!(hash(&s), 16262950014981195938);\n+    })\n+}\n+\n+#[bench]\n+fn bench_str_of_8_bytes(b: &mut Bencher) {\n+    let s = \"foobar78\";\n+    b.iter(|| {\n+        assert_eq!(hash(&s), 4898293253460910787);\n+    })\n+}\n+\n+#[bench]\n+fn bench_str_over_8_bytes(b: &mut Bencher) {\n+    let s = \"foobarbaz0\";\n+    b.iter(|| {\n+        assert_eq!(hash(&s), 10581415515220175264);\n+    })\n+}\n+\n+#[bench]\n+fn bench_long_str(b: &mut Bencher) {\n+    let s = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor \\\n+incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud \\\n+exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute \\\n+irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla \\\n+pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui \\\n+officia deserunt mollit anim id est laborum.\";\n+    b.iter(|| {\n+        assert_eq!(hash(&s), 17717065544121360093);\n+    })\n+}\n+\n+#[bench]\n+fn bench_u64(b: &mut Bencher) {\n+    let u = 16262950014981195938u64;\n+    b.iter(|| {\n+        assert_eq!(hash(&u), 5254097107239593357);\n+    })\n+}"}, {"sha": "05d862d7bc7f47d088f94323104a4f02268a854e", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(globs, unsafe_destructor, macro_rules, slicing_syntax)]\n+#![feature(globs, unsafe_destructor, macro_rules, slicing_syntax, default_type_params)]\n #![feature(unboxed_closures)]\n \n extern crate core;\n@@ -21,6 +21,7 @@ mod char;\n mod cmp;\n mod finally;\n mod fmt;\n+mod hash;\n mod iter;\n mod mem;\n mod num;"}, {"sha": "6649b93e4b0570c9347269e241ee050e7dd6084a", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -70,7 +70,7 @@\n use core::prelude::*;\n \n use collections::string::String;\n-use collections::hash;\n+use core::hash;\n use core::fmt;\n use core::kinds::{Sized, marker};\n use core::mem;"}, {"sha": "a63abec96d59bd800f79556ecb75f8a32ca9decb", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -61,7 +61,7 @@\n \n #![experimental]\n \n-pub use core_collections::hash::{Hash, Hasher, Writer, hash, sip};\n+pub use core::hash::{Hash, Hasher, Writer, hash, sip};\n \n use core::kinds::Sized;\n use default::Default;"}]}