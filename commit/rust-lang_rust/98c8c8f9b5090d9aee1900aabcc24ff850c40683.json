{"sha": "98c8c8f9b5090d9aee1900aabcc24ff850c40683", "node_id": "C_kwDOAAsO6NoAKDk4YzhjOGY5YjUwOTBkOWFlZTE5MDBhYWJjYzI0ZmY4NTBjNDA2ODM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-14T19:27:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-14T19:27:04Z"}, "message": "Auto merge of #2030 - saethlin:track-alloc-history, r=oli-obk\n\nPrint spans where tags are created and invalidated\n\n5225225 called this \"automatic tag tracking\" and I think that may be a reasonable description, but I would like to kill tag tracking as a primary use of Miri if possible. Tag tracking isn't always possible; for example if the UB is only detected with isolation off and the failing tag is made unstable by removing isolation. (also it's bad UX to run the tool twice)\n\nThis is just one of the things we can do with https://github.com/rust-lang/miri/pull/2024\n\nThe memory usage of this is _shockingly_ low, I think because the memory usage of Miri is driven by allocations where each byte ends up with its own very large stack. The memory usage in this change is linear with the number of tags, not tags * bytes. If memory usage gets out of control we can cap the number of events we save per allocation, from experience we tend to only use the most recent few in diagnostics but of course there's no guarantee of that so if we can manage to keep everything that would be best.\n\nIn many cases now I can tell exactly what these codebases are doing wrong just from the new outputs here, which I think is extremely cool.\n\nNew helps generated with plain old `cargo miri test` on `rust-argon2` v1.0.0:\n```\ntest argon2::tests::single_thread_verification_multi_lane_hash ... error: Undefined Behavior: trying to reborrow <1485898> for Unique permission at alloc110523[0x0], but that tag does not exist in the borrow stack for this location\n   --> /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/mem/manually_drop.rs:89:9\n    |\n89  |         slot.value\n    |         ^^^^^^^^^^\n    |         |\n    |         trying to reborrow <1485898> for Unique permission at alloc110523[0x0], but that tag does not exist in the borrow stack for this location\n    |         this error occurs as part of a reborrow at alloc110523[0x0..0x20]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\nhelp: <1485898> was created by a retag at offsets [0x0..0x20]\n   --> src/memory.rs:42:13\n    |\n42  |             vec.push(unsafe { &mut (*ptr) });\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: <1485898> was later invalidated at offsets [0x0..0x20]\n   --> src/memory.rs:42:31\n    |\n42  |             vec.push(unsafe { &mut (*ptr) });\n    |                               ^^^^^^^^^^^\n```\n\nAnd with `-Zmiri-tag-raw-pointers` on `slab` v0.4.5\n```\nerror: Undefined Behavior: trying to reborrow <2915> for Unique permission at alloc1418[0x0], but that tag does not exist in the borrow stack for this location\n   --> /tmp/slab-0.4.5/src/lib.rs:835:16\n    |\n835 |         match (&mut *ptr1, &mut *ptr2) {\n    |                ^^^^^^^^^^\n    |                |\n    |                trying to reborrow <2915> for Unique permission at alloc1418[0x0], but that tag does not exist in the borrow stack for this location\n    |                this error occurs as part of a reborrow at alloc1418[0x0..0x10]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\nhelp: <2915> was created by a retag at offsets [0x0..0x10]\n   --> /tmp/slab-0.4.5/src/lib.rs:833:20\n    |\n833 |         let ptr1 = self.entries.get_unchecked_mut(key1) as *mut Entry<T>;\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: <2915> was later invalidated at offsets [0x0..0x20]\n   --> /tmp/slab-0.4.5/src/lib.rs:834:20\n    |\n834 |         let ptr2 = self.entries.get_unchecked_mut(key2) as *mut Entry<T>;\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nAnd without raw pointer tagging, `cargo miri test` on `half` v1.8.2\n```\nerror: Undefined Behavior: trying to reborrow <untagged> for Unique permission at alloc1340[0x0], but that tag only grants SharedReadOnly permission for this location\n   --> /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/slice/raw.rs:141:9\n    |\n141 |         &mut *ptr::slice_from_raw_parts_mut(data, len)\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n    |         trying to reborrow <untagged> for Unique permission at alloc1340[0x0], but that tag only grants SharedReadOnly permission for this location\n    |         this error occurs as part of a reborrow at alloc1340[0x0..0x6]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\nhelp: tag was most recently created at offsets [0x0..0x6]\n   --> /tmp/half-1.8.2/src/slice.rs:309:22\n    |\n309 |         let length = self.len();\n    |                      ^^^^^^^^^^\nhelp: this tag was also created here at offsets [0x0..0x6]\n   --> /tmp/half-1.8.2/src/slice.rs:308:23\n    |\n308 |         let pointer = self.as_ptr() as *mut u16;\n    |                       ^^^^^^^^^^^^^\n```\nThe second suggestion is close to guesswork, but from experience it tends to be correct (as in, it tends to locate the pointer the user wanted) more often that it doesn't.", "tree": {"sha": "cfdb8efe1986792b238c8ff4a7122282fb9682ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfdb8efe1986792b238c8ff4a7122282fb9682ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98c8c8f9b5090d9aee1900aabcc24ff850c40683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98c8c8f9b5090d9aee1900aabcc24ff850c40683", "html_url": "https://github.com/rust-lang/rust/commit/98c8c8f9b5090d9aee1900aabcc24ff850c40683", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98c8c8f9b5090d9aee1900aabcc24ff850c40683/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d76c2c5e1c189b3ad89b8eab080d2b1f97f7d986", "url": "https://api.github.com/repos/rust-lang/rust/commits/d76c2c5e1c189b3ad89b8eab080d2b1f97f7d986", "html_url": "https://github.com/rust-lang/rust/commit/d76c2c5e1c189b3ad89b8eab080d2b1f97f7d986"}, {"sha": "8ff0aac06c73d75d5eebea173889fb2ca94c0c75", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff0aac06c73d75d5eebea173889fb2ca94c0c75", "html_url": "https://github.com/rust-lang/rust/commit/8ff0aac06c73d75d5eebea173889fb2ca94c0c75"}], "stats": {"total": 627, "additions": 503, "deletions": 124}, "files": [{"sha": "8afcf851ba4e99d883ef2192e485c52427c3e8ed", "filename": "src/diagnostics.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=98c8c8f9b5090d9aee1900aabcc24ff850c40683", "patch": "@@ -7,7 +7,8 @@ use log::trace;\n use rustc_middle::ty;\n use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n \n-use crate::stacked_borrows::{AccessKind, SbTag};\n+use crate::helpers::HexRange;\n+use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind, SbTag};\n use crate::*;\n \n /// Details of premature program termination.\n@@ -19,6 +20,7 @@ pub enum TerminationInfo {\n         msg: String,\n         help: Option<String>,\n         url: String,\n+        history: Option<TagHistory>,\n     },\n     Deadlock,\n     MultipleSymbolDefinitions {\n@@ -155,12 +157,46 @@ pub fn report_error<'tcx, 'mir>(\n                         (None, format!(\"pass the flag `-Zmiri-disable-isolation` to disable isolation;\")),\n                         (None, format!(\"or pass `-Zmiri-isolation-error=warn` to configure Miri to return an error code from isolated operations (if supported for that operation) and continue with a warning\")),\n                     ],\n-                ExperimentalUb { url, help, .. } => {\n+                ExperimentalUb { url, help, history, .. } => {\n                     msg.extend(help.clone());\n-                    vec![\n+                    let mut helps = vec![\n                         (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\")),\n-                        (None, format!(\"see {} for further information\", url))\n-                    ]\n+                        (None, format!(\"see {} for further information\", url)),\n+                    ];\n+                    match history {\n+                        Some(TagHistory::Tagged {tag, created: (created_range, created_span), invalidated, protected }) => {\n+                            let msg = format!(\"{:?} was created by a retag at offsets {}\", tag, HexRange(*created_range));\n+                            helps.push((Some(created_span.clone()), msg));\n+                            if let Some((invalidated_range, invalidated_span)) = invalidated {\n+                                let msg = format!(\"{:?} was later invalidated at offsets {}\", tag, HexRange(*invalidated_range));\n+                                helps.push((Some(invalidated_span.clone()), msg));\n+                            }\n+                            if let Some((protecting_tag, protecting_tag_span, protection_span)) = protected {\n+                                helps.push((Some(protecting_tag_span.clone()), format!(\"{:?} was protected due to {:?} which was created here\", tag, protecting_tag)));\n+                                helps.push((Some(protection_span.clone()), \"this protector is live for this call\".to_string()));\n+                            }\n+                        }\n+                        Some(TagHistory::Untagged{ recently_created, recently_invalidated, matching_created, protected }) => {\n+                            if let Some((range, span)) = recently_created {\n+                                let msg = format!(\"tag was most recently created at offsets {}\", HexRange(*range));\n+                                helps.push((Some(span.clone()), msg));\n+                            }\n+                            if let Some((range, span)) = recently_invalidated {\n+                                let msg = format!(\"tag was later invalidated at offsets {}\", HexRange(*range));\n+                                helps.push((Some(span.clone()), msg));\n+                            }\n+                            if let Some((range, span)) = matching_created {\n+                                let msg = format!(\"this tag was also created here at offsets {}\", HexRange(*range));\n+                                helps.push((Some(span.clone()), msg));\n+                            }\n+                            if let Some((protecting_tag, protecting_tag_span, protection_span)) = protected {\n+                                helps.push((Some(protecting_tag_span.clone()), format!(\"{:?} was protected due to a tag which was created here\", protecting_tag)));\n+                                helps.push((Some(protection_span.clone()), \"this protector is live for this call\".to_string()));\n+                            }\n+                        }\n+                        None => {}\n+                    }\n+                    helps\n                 }\n                 MultipleSymbolDefinitions { first, first_crate, second, second_crate, .. } =>\n                     vec!["}, {"sha": "0341c788023525513e41a9de1429bb4a3074bc32", "filename": "src/helpers.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=98c8c8f9b5090d9aee1900aabcc24ff850c40683", "patch": "@@ -2,6 +2,7 @@ pub mod convert;\n \n use std::mem;\n use std::num::NonZeroUsize;\n+use std::rc::Rc;\n use std::time::Duration;\n \n use log::trace;\n@@ -816,7 +817,7 @@ pub fn isolation_abort_error(name: &str) -> InterpResult<'static> {\n \n /// Retrieve the list of local crates that should have been passed by cargo-miri in\n /// MIRI_LOCAL_CRATES and turn them into `CrateNum`s.\n-pub fn get_local_crates(tcx: &TyCtxt<'_>) -> Vec<CrateNum> {\n+pub fn get_local_crates(tcx: &TyCtxt<'_>) -> Rc<[CrateNum]> {\n     // Convert the local crate names from the passed-in config into CrateNums so that they can\n     // be looked up quickly during execution\n     let local_crate_names = std::env::var(\"MIRI_LOCAL_CRATES\")\n@@ -830,5 +831,14 @@ pub fn get_local_crates(tcx: &TyCtxt<'_>) -> Vec<CrateNum> {\n             local_crates.push(crate_num);\n         }\n     }\n-    local_crates\n+    Rc::from(local_crates.as_slice())\n+}\n+\n+/// Formats an AllocRange like [0x1..0x3], for use in diagnostics.\n+pub struct HexRange(pub AllocRange);\n+\n+impl std::fmt::Display for HexRange {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"[{:#x}..{:#x}]\", self.0.start.bytes(), self.0.end().bytes())\n+    }\n }"}, {"sha": "a2317b22929a957ab6325b9e9ce323f191929eae", "filename": "src/machine.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=98c8c8f9b5090d9aee1900aabcc24ff850c40683", "patch": "@@ -6,6 +6,7 @@ use std::cell::RefCell;\n use std::collections::HashSet;\n use std::fmt;\n use std::num::NonZeroU64;\n+use std::rc::Rc;\n use std::time::Instant;\n \n use rand::rngs::StdRng;\n@@ -273,7 +274,7 @@ pub struct Evaluator<'mir, 'tcx> {\n     pub(crate) backtrace_style: BacktraceStyle,\n \n     /// Crates which are considered local for the purposes of error reporting.\n-    pub(crate) local_crates: Vec<CrateNum>,\n+    pub(crate) local_crates: Rc<[CrateNum]>,\n \n     /// Mapping extern static names to their base pointer.\n     extern_statics: FxHashMap<Symbol, Pointer<Tag>>,\n@@ -569,7 +570,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n         let stacks = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            Some(Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind))\n+            Some(Stacks::new_allocation(\n+                id,\n+                alloc.size(),\n+                stacked_borrows,\n+                kind,\n+                &ecx.machine.threads,\n+                ecx.machine.local_crates.clone(),\n+            ))\n         } else {\n             None\n         };\n@@ -634,6 +642,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 tag,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n+                &machine.threads,\n             )\n         } else {\n             Ok(())\n@@ -656,7 +665,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 alloc_id,\n                 tag,\n                 range,\n-                machine.stacked_borrows.as_mut().unwrap(),\n+                machine.stacked_borrows.as_ref().unwrap(),\n+                &machine.threads,\n             )\n         } else {\n             Ok(())\n@@ -682,7 +692,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 alloc_id,\n                 tag,\n                 range,\n-                machine.stacked_borrows.as_mut().unwrap(),\n+                machine.stacked_borrows.as_ref().unwrap(),\n             )\n         } else {\n             Ok(())"}, {"sha": "8dda4a9e22a0e8f7b742896242712f658b47dece", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 161, "deletions": 112, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=98c8c8f9b5090d9aee1900aabcc24ff850c40683", "patch": "@@ -5,6 +5,7 @@ use log::trace;\n use std::cell::RefCell;\n use std::fmt;\n use std::num::NonZeroU64;\n+use std::rc::Rc;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::Mutability;\n@@ -13,12 +14,18 @@ use rustc_middle::ty::{\n     self,\n     layout::{HasParamEnv, LayoutOf},\n };\n+use rustc_span::def_id::CrateNum;\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n use std::collections::HashSet;\n \n use crate::*;\n \n+pub mod diagnostics;\n+use diagnostics::AllocHistory;\n+\n+use diagnostics::TagHistory;\n+\n pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n pub type AllocExtra = Stacks;\n@@ -90,6 +97,8 @@ pub struct Stack {\n pub struct Stacks {\n     // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n     stacks: RefCell<RangeMap<Stack>>,\n+    /// Stores past operations on this allocation\n+    history: RefCell<AllocHistory>,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -112,6 +121,7 @@ pub struct GlobalStateInner {\n     /// Whether to track raw pointers.\n     tag_raw: bool,\n }\n+\n /// We need interior mutable access to the global state.\n pub type GlobalState = RefCell<GlobalStateInner>;\n \n@@ -221,13 +231,18 @@ impl GlobalStateInner {\n }\n \n /// Error reporting\n-fn err_sb_ub(msg: String, help: Option<String>) -> InterpError<'static> {\n+pub fn err_sb_ub(\n+    msg: String,\n+    help: Option<String>,\n+    history: Option<TagHistory>,\n+) -> InterpError<'static> {\n     err_machine_stop!(TerminationInfo::ExperimentalUb {\n         msg,\n         help,\n         url: format!(\n             \"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\"\n         ),\n+        history\n     })\n }\n \n@@ -306,33 +321,44 @@ impl<'tcx> Stack {\n     /// The `provoking_access` argument is only used to produce diagnostics.\n     /// It is `Some` when we are granting the contained access for said tag, and it is\n     /// `None` during a deallocation.\n+    /// Within `provoking_access, the `AllocRange` refers the entire operation, and\n+    /// the `Size` refers to the specific location in the `AllocRange` that we are\n+    /// currently checking.\n     fn check_protector(\n         item: &Item,\n-        provoking_access: Option<(SbTag, AccessKind)>,\n+        provoking_access: Option<(SbTag, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n+        alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n         if let SbTag::Tagged(id) = item.tag {\n             if global.tracked_pointer_tags.contains(&id) {\n                 register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n                     *item,\n-                    provoking_access,\n+                    provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n                 ));\n             }\n         }\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n-                if let Some((tag, _)) = provoking_access {\n+                if let Some((tag, alloc_range, offset, _access)) = provoking_access {\n                     Err(err_sb_ub(\n                         format!(\n                             \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n                             tag, item\n                         ),\n                         None,\n+                        alloc_history.get_logs_relevant_to(\n+                            tag,\n+                            alloc_range,\n+                            offset,\n+                            Some(item.tag),\n+                        ),\n                     ))?\n                 } else {\n                     Err(err_sb_ub(\n                         format!(\"deallocating while item is protected: {:?}\", item),\n                         None,\n+                        None,\n                     ))?\n                 }\n             }\n@@ -348,15 +374,17 @@ impl<'tcx> Stack {\n         &mut self,\n         access: AccessKind,\n         tag: SbTag,\n-        (alloc_id, range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n-        global: &GlobalStateInner,\n+        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n+        global: &mut GlobalStateInner,\n+        threads: &ThreadManager<'_, 'tcx>,\n+        alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self\n-            .find_granting(access, tag)\n-            .ok_or_else(|| self.access_error(access, tag, alloc_id, range, offset))?;\n+        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n+            alloc_history.access_error(access, tag, alloc_id, alloc_range, offset, self)\n+        })?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -366,7 +394,13 @@ impl<'tcx> Stack {\n             let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n-                Stack::check_protector(&item, Some((tag, access)), global)?;\n+                Stack::check_protector(\n+                    &item,\n+                    Some((tag, alloc_range, offset, access)),\n+                    global,\n+                    alloc_history,\n+                )?;\n+                alloc_history.log_invalidation(item.tag, alloc_range, threads);\n             }\n         } else {\n             // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n@@ -381,8 +415,14 @@ impl<'tcx> Stack {\n                 let item = &mut self.borrows[idx];\n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n-                    Stack::check_protector(item, Some((tag, access)), global)?;\n+                    Stack::check_protector(\n+                        item,\n+                        Some((tag, alloc_range, offset, access)),\n+                        global,\n+                        alloc_history,\n+                    )?;\n                     item.perm = Permission::Disabled;\n+                    alloc_history.log_invalidation(item.tag, alloc_range, threads);\n                 }\n             }\n         }\n@@ -396,20 +436,24 @@ impl<'tcx> Stack {\n     fn dealloc(\n         &mut self,\n         tag: SbTag,\n-        dbg_ptr: Pointer<AllocId>, // just for debug printing and error messages\n+        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalStateInner,\n+        alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n         self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n             err_sb_ub(format!(\n                 \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n-                tag, dbg_ptr,\n-            ), None)\n+                tag, alloc_id,\n+                ),\n+                None,\n+                alloc_history.get_logs_relevant_to(tag, alloc_range, offset, None),\n+            )\n         })?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n         for item in self.borrows.drain(..).rev() {\n-            Stack::check_protector(&item, None, global)?;\n+            Stack::check_protector(&item, None, global, alloc_history)?;\n         }\n \n         Ok(())\n@@ -426,16 +470,18 @@ impl<'tcx> Stack {\n         derived_from: SbTag,\n         new: Item,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n-        global: &GlobalStateInner,\n+        global: &mut GlobalStateInner,\n+        threads: &ThreadManager<'_, 'tcx>,\n+        alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let granting_idx = self\n-            .find_granting(access, derived_from)\n-            .ok_or_else(|| self.grant_error(derived_from, new, alloc_id, alloc_range, offset))?;\n+        let granting_idx = self.find_granting(access, derived_from).ok_or_else(|| {\n+            alloc_history.grant_error(derived_from, new, alloc_id, alloc_range, offset, self)\n+        })?;\n \n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n@@ -454,7 +500,14 @@ impl<'tcx> Stack {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access.\n             // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            self.access(access, derived_from, (alloc_id, alloc_range, offset), global)?;\n+            self.access(\n+                access,\n+                derived_from,\n+                (alloc_id, alloc_range, offset),\n+                global,\n+                threads,\n+                alloc_history,\n+            )?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n             // on top of `derived_from`, and we want the new item at the top so that we\n@@ -474,94 +527,32 @@ impl<'tcx> Stack {\n \n         Ok(())\n     }\n-\n-    /// Report a descriptive error when `new` could not be granted from `derived_from`.\n-    fn grant_error(\n-        &self,\n-        derived_from: SbTag,\n-        new: Item,\n-        alloc_id: AllocId,\n-        alloc_range: AllocRange,\n-        error_offset: Size,\n-    ) -> InterpError<'static> {\n-        let action = format!(\n-            \"trying to reborrow {:?} for {:?} permission at {}[{:#x}]\",\n-            derived_from,\n-            new.perm,\n-            alloc_id,\n-            error_offset.bytes(),\n-        );\n-        err_sb_ub(\n-            format!(\"{}{}\", action, self.error_cause(derived_from)),\n-            Some(Self::operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n-        )\n-    }\n-\n-    /// Report a descriptive error when `access` is not permitted based on `tag`.\n-    fn access_error(\n-        &self,\n-        access: AccessKind,\n-        tag: SbTag,\n-        alloc_id: AllocId,\n-        alloc_range: AllocRange,\n-        error_offset: Size,\n-    ) -> InterpError<'static> {\n-        let action = format!(\n-            \"attempting a {} using {:?} at {}[{:#x}]\",\n-            access,\n-            tag,\n-            alloc_id,\n-            error_offset.bytes(),\n-        );\n-        err_sb_ub(\n-            format!(\"{}{}\", action, self.error_cause(tag)),\n-            Some(Self::operation_summary(\"an access\", alloc_id, alloc_range)),\n-        )\n-    }\n-\n-    fn operation_summary(\n-        operation: &'static str,\n-        alloc_id: AllocId,\n-        alloc_range: AllocRange,\n-    ) -> String {\n-        format!(\n-            \"this error occurs as part of {} at {:?}[{:#x}..{:#x}]\",\n-            operation,\n-            alloc_id,\n-            alloc_range.start.bytes(),\n-            alloc_range.end().bytes()\n-        )\n-    }\n-\n-    fn error_cause(&self, tag: SbTag) -> &'static str {\n-        if self.borrows.iter().any(|item| item.tag == tag && item.perm != Permission::Disabled) {\n-            \", but that tag only grants SharedReadOnly permission for this location\"\n-        } else {\n-            \", but that tag does not exist in the borrow stack for this location\"\n-        }\n-    }\n }\n // # Stacked Borrows Core End\n \n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n-    fn new(size: Size, perm: Permission, tag: SbTag) -> Self {\n+    fn new(size: Size, perm: Permission, tag: SbTag, local_crates: Rc<[CrateNum]>) -> Self {\n         let item = Item { perm, tag, protector: None };\n         let stack = Stack { borrows: vec![item] };\n \n-        Stacks { stacks: RefCell::new(RangeMap::new(size, stack)) }\n+        Stacks {\n+            stacks: RefCell::new(RangeMap::new(size, stack)),\n+            history: RefCell::new(AllocHistory::new(local_crates)),\n+        }\n     }\n \n     /// Call `f` on every stack in the range.\n     fn for_each(\n         &self,\n         range: AllocRange,\n-        f: impl Fn(Size, &mut Stack) -> InterpResult<'tcx>,\n+        mut f: impl FnMut(Size, &mut Stack, &mut AllocHistory) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let mut stacks = self.stacks.borrow_mut();\n+        let history = &mut *self.history.borrow_mut();\n         for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack)?;\n+            f(offset, stack, history)?;\n         }\n         Ok(())\n     }\n@@ -570,11 +561,12 @@ impl<'tcx> Stacks {\n     fn for_each_mut(\n         &mut self,\n         range: AllocRange,\n-        f: impl Fn(Size, &mut Stack) -> InterpResult<'tcx>,\n+        mut f: impl FnMut(Size, &mut Stack, &mut AllocHistory) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let stacks = self.stacks.get_mut();\n+        let history = &mut *self.history.borrow_mut();\n         for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack)?;\n+            f(offset, stack, history)?;\n         }\n         Ok(())\n     }\n@@ -587,6 +579,8 @@ impl Stacks {\n         size: Size,\n         state: &GlobalState,\n         kind: MemoryKind<MiriMemoryKind>,\n+        threads: &ThreadManager<'_, '_>,\n+        local_crates: Rc<[CrateNum]>,\n     ) -> Self {\n         let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n@@ -620,7 +614,14 @@ impl Stacks {\n                 (tag, Permission::SharedReadWrite)\n             }\n         };\n-        Stacks::new(size, perm, base_tag)\n+        let stacks = Stacks::new(size, perm, base_tag, local_crates);\n+        stacks.history.borrow_mut().log_creation(\n+            None,\n+            base_tag,\n+            alloc_range(Size::ZERO, size),\n+            threads,\n+        );\n+        stacks\n     }\n \n     #[inline(always)]\n@@ -630,16 +631,24 @@ impl Stacks {\n         tag: SbTag,\n         range: AllocRange,\n         state: &GlobalState,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"read access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let global = &*state.borrow();\n-        self.for_each(range, move |offset, stack| {\n-            stack.access(AccessKind::Read, tag, (alloc_id, range, offset), global)\n+        let mut state = state.borrow_mut();\n+        self.for_each(range, |offset, stack, history| {\n+            stack.access(\n+                AccessKind::Read,\n+                tag,\n+                (alloc_id, range, offset),\n+                &mut state,\n+                threads,\n+                history,\n+            )\n         })\n     }\n \n@@ -649,17 +658,25 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: SbTag,\n         range: AllocRange,\n-        state: &mut GlobalState,\n+        state: &GlobalState,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let global = state.get_mut();\n-        self.for_each_mut(range, move |offset, stack| {\n-            stack.access(AccessKind::Write, tag, (alloc_id, range, offset), global)\n+        let mut state = state.borrow_mut();\n+        self.for_each_mut(range, |offset, stack, history| {\n+            stack.access(\n+                AccessKind::Write,\n+                tag,\n+                (alloc_id, range, offset),\n+                &mut state,\n+                threads,\n+                history,\n+            )\n         })\n     }\n \n@@ -669,13 +686,14 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: SbTag,\n         range: AllocRange,\n-        state: &mut GlobalState,\n+        state: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n-        let global = state.get_mut();\n-        self.for_each_mut(range, move |offset, stack| {\n-            stack.dealloc(tag, Pointer::new(alloc_id, offset), global)\n-        })\n+        let mut state = state.borrow_mut();\n+        self.for_each_mut(range, |offset, stack, history| {\n+            stack.dealloc(tag, (alloc_id, range, offset), &mut state, history)\n+        })?;\n+        Ok(())\n     }\n }\n \n@@ -705,6 +723,22 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         let (alloc_id, base_offset, orig_tag) = this.ptr_get_alloc_id(place.ptr)?;\n \n+        {\n+            let extra = this.get_alloc_extra(alloc_id)?;\n+            let stacked_borrows =\n+                extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+            let mut alloc_history = stacked_borrows.history.borrow_mut();\n+            alloc_history.log_creation(\n+                Some(orig_tag),\n+                new_tag,\n+                alloc_range(base_offset, base_offset + size),\n+                &this.machine.threads,\n+            );\n+            if protect {\n+                alloc_history.log_protector(orig_tag, new_tag, &this.machine.threads);\n+            }\n+        }\n+\n         // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n         let (alloc_size, _) =\n             this.get_alloc_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n@@ -753,7 +787,6 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let extra = this.get_alloc_extra(alloc_id)?;\n                 let stacked_borrows =\n                     extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n-                let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -764,8 +797,16 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Permission::SharedReadWrite\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    stacked_borrows.for_each(range, |offset, stack| {\n-                        stack.grant(orig_tag, item, (alloc_id, range, offset), &*global)\n+                    let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n+                    stacked_borrows.for_each(range, |offset, stack, history| {\n+                        stack.grant(\n+                            orig_tag,\n+                            item,\n+                            (alloc_id, range, offset),\n+                            &mut *global,\n+                            &this.machine.threads,\n+                            history,\n+                        )\n                     })\n                 })?;\n                 return Ok(());\n@@ -774,15 +815,23 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Here we can avoid `borrow()` calls because we have mutable references.\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n-        let (alloc_extra, memory_extra) = this.get_alloc_extra_mut(alloc_id)?;\n+        let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n         let stacked_borrows =\n             alloc_extra.stacked_borrows.as_mut().expect(\"we should have Stacked Borrows data\");\n-        let global = memory_extra.stacked_borrows.as_mut().unwrap().get_mut();\n         let item = Item { perm, tag: new_tag, protector };\n         let range = alloc_range(base_offset, size);\n-        stacked_borrows.for_each_mut(alloc_range(base_offset, size), |offset, stack| {\n-            stack.grant(orig_tag, item, (alloc_id, range, offset), global)\n+        let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n+        stacked_borrows.for_each_mut(range, |offset, stack, history| {\n+            stack.grant(\n+                orig_tag,\n+                item,\n+                (alloc_id, range, offset),\n+                &mut global,\n+                &machine.threads,\n+                history,\n+            )\n         })?;\n+\n         Ok(())\n     }\n "}, {"sha": "734c3a14e3b3b69e9931b351e427ea0b395e5ac2", "filename": "src/stacked_borrows/diagnostics.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=98c8c8f9b5090d9aee1900aabcc24ff850c40683", "patch": "@@ -0,0 +1,274 @@\n+use smallvec::SmallVec;\n+use std::rc::Rc;\n+\n+use rustc_middle::mir::interpret::{AllocId, AllocRange};\n+use rustc_span::def_id::CrateNum;\n+use rustc_span::{Span, SpanData};\n+use rustc_target::abi::Size;\n+\n+use crate::helpers::HexRange;\n+use crate::stacked_borrows::{err_sb_ub, AccessKind, Permission};\n+use crate::Item;\n+use crate::SbTag;\n+use crate::Stack;\n+use crate::ThreadManager;\n+\n+use rustc_middle::mir::interpret::InterpError;\n+\n+#[derive(Clone, Debug)]\n+pub struct AllocHistory {\n+    // The time tags can be compressed down to one bit per event, by just storing a Vec<u8>\n+    // where each bit is set to indicate if the event was a creation or a retag\n+    current_time: usize,\n+    creations: smallvec::SmallVec<[Event; 2]>,\n+    invalidations: smallvec::SmallVec<[Event; 1]>,\n+    protectors: smallvec::SmallVec<[Protection; 1]>,\n+    /// This field is a clone of the `local_crates` field on `Evaluator`.\n+    local_crates: Rc<[CrateNum]>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct Protection {\n+    orig_tag: SbTag,\n+    tag: SbTag,\n+    span: Span,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct Event {\n+    time: usize,\n+    parent: Option<SbTag>,\n+    tag: SbTag,\n+    range: AllocRange,\n+    span: Span,\n+}\n+\n+pub enum TagHistory {\n+    Tagged {\n+        tag: SbTag,\n+        created: (AllocRange, SpanData),\n+        invalidated: Option<(AllocRange, SpanData)>,\n+        protected: Option<(SbTag, SpanData, SpanData)>,\n+    },\n+    Untagged {\n+        recently_created: Option<(AllocRange, SpanData)>,\n+        recently_invalidated: Option<(AllocRange, SpanData)>,\n+        matching_created: Option<(AllocRange, SpanData)>,\n+        protected: Option<(SbTag, SpanData, SpanData)>,\n+    },\n+}\n+\n+impl AllocHistory {\n+    pub fn new(local_crates: Rc<[CrateNum]>) -> Self {\n+        Self {\n+            current_time: 0,\n+            creations: SmallVec::new(),\n+            invalidations: SmallVec::new(),\n+            protectors: SmallVec::new(),\n+            local_crates,\n+        }\n+    }\n+\n+    fn current_span(&self, threads: &ThreadManager<'_, '_>) -> Span {\n+        threads\n+            .active_thread_stack()\n+            .into_iter()\n+            .rev()\n+            .find(|frame| {\n+                let def_id = frame.instance.def_id();\n+                def_id.is_local() || self.local_crates.contains(&def_id.krate)\n+            })\n+            .map(|frame| frame.current_span())\n+            .unwrap_or(rustc_span::DUMMY_SP)\n+    }\n+\n+    pub fn log_creation(\n+        &mut self,\n+        parent: Option<SbTag>,\n+        tag: SbTag,\n+        range: AllocRange,\n+        threads: &ThreadManager<'_, '_>,\n+    ) {\n+        let span = self.current_span(threads);\n+        self.creations.push(Event { parent, tag, range, span, time: self.current_time });\n+        self.current_time += 1;\n+    }\n+\n+    pub fn log_invalidation(\n+        &mut self,\n+        tag: SbTag,\n+        range: AllocRange,\n+        threads: &ThreadManager<'_, '_>,\n+    ) {\n+        let span = self.current_span(threads);\n+        self.invalidations.push(Event { parent: None, tag, range, span, time: self.current_time });\n+        self.current_time += 1;\n+    }\n+\n+    pub fn log_protector(&mut self, orig_tag: SbTag, tag: SbTag, threads: &ThreadManager<'_, '_>) {\n+        let span = self.current_span(threads);\n+        self.protectors.push(Protection { orig_tag, tag, span });\n+        self.current_time += 1;\n+    }\n+\n+    pub fn get_logs_relevant_to(\n+        &self,\n+        tag: SbTag,\n+        alloc_range: AllocRange,\n+        offset: Size,\n+        protector_tag: Option<SbTag>,\n+    ) -> Option<TagHistory> {\n+        let protected = protector_tag\n+            .and_then(|protector| {\n+                self.protectors.iter().find_map(|protection| {\n+                    if protection.tag == protector {\n+                        Some((protection.orig_tag, protection.span.data()))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            })\n+            .and_then(|(tag, call_span)| {\n+                self.creations.iter().rev().find_map(|event| {\n+                    if event.tag == tag {\n+                        Some((event.parent?, event.span.data(), call_span))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            });\n+\n+        if let SbTag::Tagged(_) = tag {\n+            let get_matching = |events: &[Event]| {\n+                events.iter().rev().find_map(|event| {\n+                    if event.tag == tag { Some((event.range, event.span.data())) } else { None }\n+                })\n+            };\n+            Some(TagHistory::Tagged {\n+                tag,\n+                created: get_matching(&self.creations)?,\n+                invalidated: get_matching(&self.invalidations),\n+                protected,\n+            })\n+        } else {\n+            let mut created_time = 0;\n+            // Find the most recently created tag that satsfies this offset\n+            let recently_created = self.creations.iter().rev().find_map(|event| {\n+                if event.tag == tag && offset >= event.range.start && offset < event.range.end() {\n+                    created_time = event.time;\n+                    Some((event.range, event.span.data()))\n+                } else {\n+                    None\n+                }\n+            });\n+\n+            // Find a different recently created tag that satisfies this whole operation, predates\n+            // the recently created tag, and has a different span.\n+            // We're trying to make a guess at which span the user wanted to provide the tag that\n+            // they're using.\n+            let matching_created = recently_created.and_then(|(_created_range, created_span)| {\n+                self.creations.iter().rev().find_map(|event| {\n+                    if event.tag == tag\n+                        && alloc_range.start >= event.range.start\n+                        && alloc_range.end() <= event.range.end()\n+                        && event.span.data() != created_span\n+                        && event.time != created_time\n+                    {\n+                        Some((event.range, event.span.data()))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            });\n+\n+            // Find the most recent invalidation of this tag which post-dates the creation\n+            let recently_invalidated = recently_created.and_then(|_| {\n+                self.invalidations\n+                    .iter()\n+                    .rev()\n+                    .take_while(|event| event.time > created_time)\n+                    .find_map(|event| {\n+                        if event.tag == tag\n+                            && offset >= event.range.start\n+                            && offset < event.range.end()\n+                        {\n+                            Some((event.range, event.span.data()))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+            });\n+\n+            Some(TagHistory::Untagged {\n+                recently_created,\n+                matching_created,\n+                recently_invalidated,\n+                protected,\n+            })\n+        }\n+    }\n+\n+    /// Report a descriptive error when `new` could not be granted from `derived_from`.\n+    pub fn grant_error(\n+        &self,\n+        derived_from: SbTag,\n+        new: Item,\n+        alloc_id: AllocId,\n+        alloc_range: AllocRange,\n+        error_offset: Size,\n+        stack: &Stack,\n+    ) -> InterpError<'static> {\n+        let action = format!(\n+            \"trying to reborrow {:?} for {:?} permission at {}[{:#x}]\",\n+            derived_from,\n+            new.perm,\n+            alloc_id,\n+            error_offset.bytes(),\n+        );\n+        err_sb_ub(\n+            format!(\"{}{}\", action, error_cause(stack, derived_from)),\n+            Some(operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n+            self.get_logs_relevant_to(derived_from, alloc_range, error_offset, None),\n+        )\n+    }\n+\n+    /// Report a descriptive error when `access` is not permitted based on `tag`.\n+    pub fn access_error(\n+        &self,\n+        access: AccessKind,\n+        tag: SbTag,\n+        alloc_id: AllocId,\n+        alloc_range: AllocRange,\n+        error_offset: Size,\n+        stack: &Stack,\n+    ) -> InterpError<'static> {\n+        let action = format!(\n+            \"attempting a {} using {:?} at {}[{:#x}]\",\n+            access,\n+            tag,\n+            alloc_id,\n+            error_offset.bytes(),\n+        );\n+        err_sb_ub(\n+            format!(\"{}{}\", action, error_cause(stack, tag)),\n+            Some(operation_summary(\"an access\", alloc_id, alloc_range)),\n+            self.get_logs_relevant_to(tag, alloc_range, error_offset, None),\n+        )\n+    }\n+}\n+\n+fn operation_summary(\n+    operation: &'static str,\n+    alloc_id: AllocId,\n+    alloc_range: AllocRange,\n+) -> String {\n+    format!(\"this error occurs as part of {} at {:?}{}\", operation, alloc_id, HexRange(alloc_range))\n+}\n+\n+fn error_cause(stack: &Stack, tag: SbTag) -> &'static str {\n+    if stack.borrows.iter().any(|item| item.tag == tag && item.perm != Permission::Disabled) {\n+        \", but that tag only grants SharedReadOnly permission for this location\"\n+    } else {\n+        \", but that tag does not exist in the borrow stack for this location\"\n+    }\n+}"}, {"sha": "5673af048fc5309dda251315e75fb07eaa31c472", "filename": "src/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c8c8f9b5090d9aee1900aabcc24ff850c40683/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=98c8c8f9b5090d9aee1900aabcc24ff850c40683", "patch": "@@ -263,7 +263,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Borrow the stack of the active thread.\n-    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n+    pub fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n         &self.threads[self.active_thread].stack\n     }\n "}]}