{"sha": "7073ee4e31d32cfdc1401cfefaa2e3ed07b43f48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNzNlZTRlMzFkMzJjZmRjMTQwMWNmZWZhYTJlM2VkMDdiNDNmNDg=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-28T01:55:15Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-28T02:43:21Z"}, "message": "Some work on backwarding for issue #702.", "tree": {"sha": "de98c87b5648c3956b88827e76608112ec559104", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de98c87b5648c3956b88827e76608112ec559104"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7073ee4e31d32cfdc1401cfefaa2e3ed07b43f48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7073ee4e31d32cfdc1401cfefaa2e3ed07b43f48", "html_url": "https://github.com/rust-lang/rust/commit/7073ee4e31d32cfdc1401cfefaa2e3ed07b43f48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7073ee4e31d32cfdc1401cfefaa2e3ed07b43f48/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54c1c07ab1a9ba311bde3a1f80687a7e64c7edae", "url": "https://api.github.com/repos/rust-lang/rust/commits/54c1c07ab1a9ba311bde3a1f80687a7e64c7edae", "html_url": "https://github.com/rust-lang/rust/commit/54c1c07ab1a9ba311bde3a1f80687a7e64c7edae"}], "stats": {"total": 120, "additions": 100, "deletions": 20}, "files": [{"sha": "0b0b31b20640743c25166c6e90df1ed84d029708", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 100, "deletions": 20, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/7073ee4e31d32cfdc1401cfefaa2e3ed07b43f48/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7073ee4e31d32cfdc1401cfefaa2e3ed07b43f48/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7073ee4e31d32cfdc1401cfefaa2e3ed07b43f48", "patch": "@@ -6534,6 +6534,7 @@ fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n // helper function for create_vtbl.\n fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                        ty_params: &ast::ty_param[], with_obj_ty: ty::t,\n+                       backwarding_vtbl: option::t[ValueRef],\n                        additional_field_tys: &ty::t[]) -> ValueRef {\n \n \n@@ -6552,9 +6553,14 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let mcx: @local_ctxt = @{path: cx.path + ~[\"method\", m.ident] with *cx};\n \n     // Make up a name for the forwarding function.\n-    let s: str =\n-        mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n-                                             \"forwarding_fn\");\n+    let fn_name: str;\n+    alt (backwarding_vtbl) {\n+        none. { fn_name = \"forwarding_fn\"; }\n+        some(_) { fn_name = \"backwarding_fn\"; }\n+    }\n+\n+    let s: str = mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n+                                                      fn_name);\n \n     // Get the forwarding function's type and declare it.\n     let llforwarding_fn_ty: TypeRef =\n@@ -6574,6 +6580,21 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let llself_obj_ptr = alloca(bcx, fcx.lcx.ccx.rust_object_type);\n     bcx.build.Store(fcx.llenv, llself_obj_ptr);\n \n+    // Do backwarding if necessary.\n+    alt (backwarding_vtbl) {\n+        none. { /* fall through */ }\n+        some(bv) {\n+            // Grab the vtable out of the self-object.\n+            let llself_obj_vtbl =\n+                bcx.build.GEP(llself_obj_ptr, ~[C_int(0),\n+                                                C_int(abi::obj_field_vtbl)]);\n+\n+            // And replace it with the backwarding vtbl.\n+            let llbv = bcx.build.PointerCast(bv, T_ptr(T_empty_struct()));\n+            bcx.build.Store(llbv, llself_obj_vtbl);\n+        }\n+    }\n+\n     // Grab hold of the outer object so we can pass it into the inner object,\n     // in case that inner object needs to make any self-calls.  (Such calls\n     // will need to dispatch back through the outer object.)\n@@ -6733,22 +6754,21 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     ret llfn;\n }\n \n+// Used only inside create_vtbl and create_backwarding_vtbl to distinguish\n+// different kinds of slots we'll have to create.\n+tag vtbl_mthd {\n+    // Normal methods are complete AST nodes, but for forwarding methods,\n+    // the only information we'll have about them is their type.\n+    normal_mthd(@ast::method);\n+    fwding_mthd(@ty::method);\n+}\n+\n // Create a vtable for an object being translated.  Returns a pointer into\n // read-only memory.\n fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n                ty_params: &ast::ty_param[], with_obj_ty: option::t[ty::t],\n                additional_field_tys: &ty::t[]) -> ValueRef {\n \n-    // Used only inside create_vtbl to distinguish different kinds of slots\n-    // we'll have to create.\n-    tag vtbl_mthd {\n-\n-        // Normal methods are complete AST nodes, but for forwarding methods,\n-        // the only information we'll have about them is their type.\n-        normal_mthd(@ast::method);\n-        fwding_mthd(@ty::method);\n-    }\n-\n     let dtor = C_null(T_ptr(T_i8()));\n     alt ob.dtor {\n       some(d) {\n@@ -6760,6 +6780,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n \n     let llmethods: ValueRef[] = ~[dtor];\n     let meths: vtbl_mthd[] = ~[];\n+    let backwarding_vtbl: option::t[ValueRef] = none;\n \n     alt with_obj_ty {\n       none. {\n@@ -6794,8 +6815,8 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n           }\n           _ {\n             // Shouldn't happen.\n-            cx.ccx.sess.bug(\"create_vtbl(): trying to extend a \" +\n-                                \"non-object\");\n+            cx.ccx.sess.bug(\"create_vtbl(): trying to extend a \\\n+                            non-object\");\n           }\n         }\n \n@@ -6805,7 +6826,6 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n                         addtl_meths: (@ast::method)[]) ->\n            option::t[vtbl_mthd] {\n \n-\n             alt m {\n               fwding_mthd(fm) {\n                 // Since fm is a fwding_mthd, and we're checking to\n@@ -6863,7 +6883,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n                                                   meths);\n \n     // Now that we have our list of methods, we can process them in order.\n-    for m: vtbl_mthd  in meths {\n+    for m: vtbl_mthd in meths {\n         alt m {\n           normal_mthd(nm) {\n             llmethods += ~[process_normal_mthd(cx, nm, self_ty, ty_params)];\n@@ -6877,13 +6897,14 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n                 // This shouldn't happen; if we're trying to process a\n                 // forwarding method, then we should always have a\n                 // with_obj_ty.\n-                cx.ccx.sess.bug(\"create_vtbl(): trying to create \" +\n-                                    \"forwarding method without a type \" +\n-                                    \"of object to forward to\");\n+                cx.ccx.sess.bug(\"create_vtbl(): trying to create \\\n+                                forwarding method without a type \\\n+                                of object to forward to\");\n               }\n               some(t) {\n                 llmethods +=\n                     ~[process_fwding_mthd(cx, sp, fm, ty_params, t,\n+                                          backwarding_vtbl,\n                                           additional_field_tys)];\n               }\n             }\n@@ -6914,6 +6935,65 @@ fn trans_dtor(cx: @local_ctxt, self_ty: ty::t, ty_params: &ast::ty_param[],\n     ret llfn;\n }\n \n+fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, with_obj_ty: ty::t,\n+                           outer_obj_ty: ty::t) -> ValueRef {\n+\n+    // This vtbl needs to have slots for all of the methods on an inner\n+    // object, and it needs to forward them to the corresponding slots on the\n+    // outer object.  All we know about either one are their types.\n+\n+    let dtor = C_null(T_ptr(T_i8()));\n+    let llmethods: ValueRef[] = ~[dtor];\n+    let meths: vtbl_mthd[]= ~[];\n+\n+    // Gather up methods on the inner object.\n+    alt ty::struct(cx.ccx.tcx, with_obj_ty) {\n+        ty::ty_obj(with_obj_methods) {\n+            for m: ty::method in with_obj_methods {\n+                meths += ~[fwding_mthd(@m)];\n+            }\n+        }\n+        _ {\n+            // Shouldn't happen.\n+            cx.ccx.sess.bug(\"create_backwarding_vtbl(): trying to extend a \\\n+                            non-object\");\n+        }\n+    }\n+\n+    // Methods should have already been sorted, so no need to do so again.\n+\n+    for m: vtbl_mthd in meths {\n+        alt m {\n+            normal_mthd(nm) {\n+                cx.ccx.sess.bug(\"backwarding vtables shouldn't contain \\\n+                                 normal methods\");\n+            }\n+            fwding_mthd(fm) {\n+                // We pass outer_obj_ty to process_fwding_mthd() because it's\n+                // the one being forwarded to.\n+                llmethods += ~[process_fwding_mthd(\n+                        cx, sp, fm, ~[], outer_obj_ty,\n+                        none,\n+                        ~[])];\n+            }\n+        }\n+    }\n+\n+    let vtbl = C_struct(llmethods);\n+    let vtbl_name =\n+        mangle_internal_name_by_path(cx.ccx,\n+                                     cx.path + ~[\"backwarding_vtbl\"]);\n+    let gvar =\n+        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n+    llvm::LLVMSetInitializer(gvar, vtbl);\n+    llvm::LLVMSetGlobalConstant(gvar, True);\n+    llvm::LLVMSetLinkage(gvar,\n+                         lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n+\n+    ret gvar;\n+\n+}\n+\n // trans_obj: creates an LLVM function that is the object constructor for the\n // object being translated.\n fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,"}]}