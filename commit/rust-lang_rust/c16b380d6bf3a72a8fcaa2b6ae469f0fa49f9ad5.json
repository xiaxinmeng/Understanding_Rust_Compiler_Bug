{"sha": "c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5", "node_id": "C_kwDOAAsO6NoAKGMxNmIzODBkNmJmM2E3MmE4ZmNhYTJiNmFlNDY5ZjBmYTQ5ZjlhZDU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-27T12:13:55Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-28T02:52:02Z"}, "message": "finally we can actually have adjacent allocations :)", "tree": {"sha": "840a2fd147274723f8d2eef184bcdabe69ea9e18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/840a2fd147274723f8d2eef184bcdabe69ea9e18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5", "html_url": "https://github.com/rust-lang/rust/commit/c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "html_url": "https://github.com/rust-lang/rust/commit/7fafbde038ed492ba0ecc6c57f2a7ba229042df7"}], "stats": {"total": 75, "additions": 70, "deletions": 5}, "files": [{"sha": "1a630259cf6af2840723e68c669f8be0654122ac", "filename": "src/intptrcast.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5", "patch": "@@ -1,4 +1,5 @@\n use std::cell::RefCell;\n+use std::cmp::max;\n use std::collections::hash_map::Entry;\n \n use log::trace;\n@@ -198,11 +199,11 @@ impl<'mir, 'tcx> GlobalStateInner {\n                     slack,\n                 );\n \n-                // Remember next base address.  Leave a gap of at least 1 to avoid two zero-sized allocations\n-                // having the same base address, and to avoid ambiguous provenance for the address between two\n-                // allocations (also see https://github.com/rust-lang/unsafe-code-guidelines/issues/313).\n-                let size_plus_1 = size.bytes().checked_add(1).unwrap();\n-                global_state.next_base_addr = base_addr.checked_add(size_plus_1).unwrap();\n+                // Remember next base address.  If this allocation is zero-sized, leave a gap\n+                // of at least 1 to avoid two allocations having the same base address.\n+                // (The logic in `alloc_id_from_addr` assumes unique addresses, and function\n+                // pointers to different functions need to be distinguishable!)\n+                global_state.next_base_addr = base_addr.checked_add(max(size.bytes(), 1)).unwrap();\n                 // Given that `next_base_addr` increases in each allocation, pushing the\n                 // corresponding tuple keeps `int_to_ptr_map` sorted\n                 global_state.int_to_ptr_map.push((base_addr, alloc_id));"}, {"sha": "d0dc8b5d876222d42d2e47f034596d5070cbd6b7", "filename": "tests/pass/adjacent-allocs.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5/tests%2Fpass%2Fadjacent-allocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5/tests%2Fpass%2Fadjacent-allocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fadjacent-allocs.rs?ref=c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5", "patch": "@@ -1,5 +1,20 @@\n // compile-flags: -Zmiri-permissive-provenance\n \n+fn ensure_allocs_can_be_adjacent() {\n+    for _ in 0..512 {\n+        let n = 0u64;\n+        let ptr: *const u64 = &n;\n+        let ptr2 = {\n+            let m = 0u64;\n+            &m as *const u64\n+        };\n+        if ptr.wrapping_add(1) == ptr2 {\n+            return;\n+        }\n+    }\n+    panic!(\"never saw adjacent stack variables?\");\n+}\n+\n fn test1() {\n     // The slack between allocations is random.\n     // Loop a few times to hit the zero-slack case.\n@@ -42,6 +57,7 @@ fn test2() {\n }\n \n fn main() {\n+    ensure_allocs_can_be_adjacent();\n     test1();\n     test2();\n }"}, {"sha": "aebf5b222389517b9cff907eabcebf6613029416", "filename": "tests/pass/intptrcast.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5/tests%2Fpass%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5/tests%2Fpass%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fintptrcast.rs?ref=c16b380d6bf3a72a8fcaa2b6ae469f0fa49f9ad5", "patch": "@@ -1,5 +1,7 @@\n // compile-flags: -Zmiri-permissive-provenance\n \n+use std::mem;\n+\n // This strips provenance\n fn transmute_ptr_to_int<T>(x: *const T) -> usize {\n     unsafe { std::mem::transmute(x) }\n@@ -100,6 +102,51 @@ fn zst_deref_of_dangling() {\n     let _val = unsafe { *zst };\n }\n \n+fn functions() {\n+    // Roundtrip a few functions through integers. Do this multiple times to make sure this does not\n+    // work by chance. If we did not give unique addresses to ZST allocations -- which fn\n+    // allocations are -- then we might be unable to cast back, or we might call the wrong function!\n+    // Every function gets at most one address so doing a loop would not help...\n+    fn fn0() -> i32 {\n+        0\n+    }\n+    fn fn1() -> i32 {\n+        1\n+    }\n+    fn fn2() -> i32 {\n+        2\n+    }\n+    fn fn3() -> i32 {\n+        3\n+    }\n+    fn fn4() -> i32 {\n+        4\n+    }\n+    fn fn5() -> i32 {\n+        5\n+    }\n+    fn fn6() -> i32 {\n+        6\n+    }\n+    fn fn7() -> i32 {\n+        7\n+    }\n+    let fns = [\n+        fn0 as fn() -> i32 as *const () as usize,\n+        fn1 as fn() -> i32 as *const () as usize,\n+        fn2 as fn() -> i32 as *const () as usize,\n+        fn3 as fn() -> i32 as *const () as usize,\n+        fn4 as fn() -> i32 as *const () as usize,\n+        fn5 as fn() -> i32 as *const () as usize,\n+        fn6 as fn() -> i32 as *const () as usize,\n+        fn7 as fn() -> i32 as *const () as usize,\n+    ];\n+    for (idx, &addr) in fns.iter().enumerate() {\n+        let fun: fn() -> i32 = unsafe { mem::transmute(addr as *const ()) };\n+        assert_eq!(fun(), idx as i32);\n+    }\n+}\n+\n fn main() {\n     cast();\n     cast_dangling();\n@@ -112,4 +159,5 @@ fn main() {\n     ptr_eq_out_of_bounds_null();\n     ptr_eq_integer();\n     zst_deref_of_dangling();\n+    functions();\n }"}]}