{"sha": "0eb6753fc5b51df9d79b495c3812440958cd0052", "node_id": "C_kwDOAAsO6NoAKDBlYjY3NTNmYzViNTFkZjlkNzliNDk1YzM4MTI0NDA5NThjZDAwNTI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-27T21:32:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-27T21:32:30Z"}, "message": "Rollup merge of #93365 - nnethercote:more-arena-cleanups, r=oli-obk\n\nMore arena cleanups\n\nA sequel to #90990.\n\nr? `@oli-obk`", "tree": {"sha": "f23c58fd80951d088f213afdc24daa91a665fd98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f23c58fd80951d088f213afdc24daa91a665fd98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eb6753fc5b51df9d79b495c3812440958cd0052", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh8w9uCRBK7hj4Ov3rIwAAFzQIAFWbz5jc5jynnP51G/K0GrDR\ne3HcqUPTQaW7bEvyzvFbndak/EwqqFxbwdb/epOFqUTrWdKy5qwY8E3qex8oYcp3\nXPFsHPnf8PG3KO/mrOU3RSogNB9/FOYhmr1mPwscQAlDtXu2VppqkytEAOjgGT23\nDwQvX+yqmgSFcsW2XDRhTKdwZiYeLTx29PXcXPy6Y+0FIcxmeyvvKntqLhbdRUGj\nY/QejnmbTZzKpfQUhiVXa2r649nYBJXKV3Dh+41T6xVWXZI0y9LsuvrNI4T/VT3H\nY3DVKuG6FiFIz5G6LMJC4fT+c7snA8ZFDV8Pmczq27pipCHBRur1MNQZycpi02g=\n=Dg9f\n-----END PGP SIGNATURE-----\n", "payload": "tree f23c58fd80951d088f213afdc24daa91a665fd98\nparent 8347f7851a4f662ac8d89636c728610dc8971a75\nparent 6035487715a528cba30ff4dc0bb9c632e3d24db3\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643319150 +0100\ncommitter GitHub <noreply@github.com> 1643319150 +0100\n\nRollup merge of #93365 - nnethercote:more-arena-cleanups, r=oli-obk\n\nMore arena cleanups\n\nA sequel to #90990.\n\nr? `@oli-obk`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb6753fc5b51df9d79b495c3812440958cd0052", "html_url": "https://github.com/rust-lang/rust/commit/0eb6753fc5b51df9d79b495c3812440958cd0052", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eb6753fc5b51df9d79b495c3812440958cd0052/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8347f7851a4f662ac8d89636c728610dc8971a75", "url": "https://api.github.com/repos/rust-lang/rust/commits/8347f7851a4f662ac8d89636c728610dc8971a75", "html_url": "https://github.com/rust-lang/rust/commit/8347f7851a4f662ac8d89636c728610dc8971a75"}, {"sha": "6035487715a528cba30ff4dc0bb9c632e3d24db3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6035487715a528cba30ff4dc0bb9c632e3d24db3", "html_url": "https://github.com/rust-lang/rust/commit/6035487715a528cba30ff4dc0bb9c632e3d24db3"}], "stats": {"total": 61, "additions": 40, "deletions": 21}, "files": [{"sha": "3928d70c0ede2c9b9c716e822e35f9649e5d020c", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0eb6753fc5b51df9d79b495c3812440958cd0052/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb6753fc5b51df9d79b495c3812440958cd0052/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=0eb6753fc5b51df9d79b495c3812440958cd0052", "patch": "@@ -45,24 +45,24 @@ pub struct TypedArena<T> {\n     end: Cell<*mut T>,\n \n     /// A vector of arena chunks.\n-    chunks: RefCell<Vec<TypedArenaChunk<T>>>,\n+    chunks: RefCell<Vec<ArenaChunk<T>>>,\n \n     /// Marker indicating that dropping the arena causes its owned\n     /// instances of `T` to be dropped.\n     _own: PhantomData<T>,\n }\n \n-struct TypedArenaChunk<T> {\n+struct ArenaChunk<T = u8> {\n     /// The raw storage for the arena chunk.\n     storage: Box<[MaybeUninit<T>]>,\n     /// The number of valid entries in the chunk.\n     entries: usize,\n }\n \n-impl<T> TypedArenaChunk<T> {\n+impl<T> ArenaChunk<T> {\n     #[inline]\n-    unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n-        TypedArenaChunk { storage: Box::new_uninit_slice(capacity), entries: 0 }\n+    unsafe fn new(capacity: usize) -> ArenaChunk<T> {\n+        ArenaChunk { storage: Box::new_uninit_slice(capacity), entries: 0 }\n     }\n \n     /// Destroys this arena chunk.\n@@ -125,6 +125,11 @@ impl<I, T> IterExt<T> for I\n where\n     I: IntoIterator<Item = T>,\n {\n+    // This default collects into a `SmallVec` and then allocates by copying\n+    // from it. The specializations below for types like `Vec` are more\n+    // efficient, copying directly without the intermediate collecting step.\n+    // This default could be made more efficient, like\n+    // `DroplessArena::alloc_from_iter`, but it's not hot enough to bother.\n     #[inline]\n     default fn alloc_from_iter(self, arena: &TypedArena<T>) -> &mut [T] {\n         let vec: SmallVec<[_; 8]> = self.into_iter().collect();\n@@ -139,7 +144,7 @@ impl<T, const N: usize> IterExt<T> for std::array::IntoIter<T, N> {\n         if len == 0 {\n             return &mut [];\n         }\n-        // Move the content to the arena by copying and then forgetting it\n+        // Move the content to the arena by copying and then forgetting it.\n         unsafe {\n             let start_ptr = arena.alloc_raw_slice(len);\n             self.as_slice().as_ptr().copy_to_nonoverlapping(start_ptr, len);\n@@ -156,7 +161,7 @@ impl<T> IterExt<T> for Vec<T> {\n         if len == 0 {\n             return &mut [];\n         }\n-        // Move the content to the arena by copying and then forgetting it\n+        // Move the content to the arena by copying and then forgetting it.\n         unsafe {\n             let start_ptr = arena.alloc_raw_slice(len);\n             self.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n@@ -173,7 +178,7 @@ impl<A: smallvec::Array> IterExt<A::Item> for SmallVec<A> {\n         if len == 0 {\n             return &mut [];\n         }\n-        // Move the content to the arena by copying and then forgetting it\n+        // Move the content to the arena by copying and then forgetting it.\n         unsafe {\n             let start_ptr = arena.alloc_raw_slice(len);\n             self.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n@@ -272,7 +277,7 @@ impl<T> TypedArena<T> {\n             // Also ensure that this chunk can fit `additional`.\n             new_cap = cmp::max(additional, new_cap);\n \n-            let mut chunk = TypedArenaChunk::<T>::new(new_cap);\n+            let mut chunk = ArenaChunk::<T>::new(new_cap);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n             chunks.push(chunk);\n@@ -281,7 +286,7 @@ impl<T> TypedArena<T> {\n \n     // Drops the contents of the last chunk. The last chunk is partially empty, unlike all other\n     // chunks.\n-    fn clear_last_chunk(&self, last_chunk: &mut TypedArenaChunk<T>) {\n+    fn clear_last_chunk(&self, last_chunk: &mut ArenaChunk<T>) {\n         // Determine how much was filled.\n         let start = last_chunk.start() as usize;\n         // We obtain the value of the pointer to the first uninitialized element.\n@@ -340,7 +345,7 @@ pub struct DroplessArena {\n     end: Cell<*mut u8>,\n \n     /// A vector of arena chunks.\n-    chunks: RefCell<Vec<TypedArenaChunk<u8>>>,\n+    chunks: RefCell<Vec<ArenaChunk>>,\n }\n \n unsafe impl Send for DroplessArena {}\n@@ -378,7 +383,7 @@ impl DroplessArena {\n             // Also ensure that this chunk can fit `additional`.\n             new_cap = cmp::max(additional, new_cap);\n \n-            let mut chunk = TypedArenaChunk::<u8>::new(new_cap);\n+            let mut chunk = ArenaChunk::new(new_cap);\n             self.start.set(chunk.start());\n             self.end.set(chunk.end());\n             chunks.push(chunk);\n@@ -520,10 +525,19 @@ impl DroplessArena {\n     }\n }\n \n-// Declare an `Arena` containing one dropless arena and many typed arenas (the\n-// types of the typed arenas are specified by the arguments). The dropless\n-// arena will be used for any types that impl `Copy`, and also for any of the\n-// specified types that satisfy `!mem::needs_drop`.\n+/// Declare an `Arena` containing one dropless arena and many typed arenas (the\n+/// types of the typed arenas are specified by the arguments).\n+///\n+/// There are three cases of interest.\n+/// - Types that are `Copy`: these need not be specified in the arguments. They\n+///   will use the `DroplessArena`.\n+/// - Types that are `!Copy` and `!Drop`: these must be specified in the\n+///   arguments. An empty `TypedArena` will be created for each one, but the\n+///   `DroplessArena` will always be used and the `TypedArena` will stay empty.\n+///   This is odd but harmless, because an empty arena allocates no memory.\n+/// - Types that are `!Copy` and `Drop`: these must be specified in the\n+///   arguments. The `TypedArena` will be used for them.\n+///\n #[rustc_macro_transparency = \"semitransparent\"]\n pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     #[derive(Default)]\n@@ -532,7 +546,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n         $($name: $crate::TypedArena<$ty>,)*\n     }\n \n-    pub trait ArenaAllocatable<'tcx, T = Self>: Sized {\n+    pub trait ArenaAllocatable<'tcx, C = rustc_arena::IsNotCopy>: Sized {\n         fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self;\n         fn allocate_from_iter<'a>(\n             arena: &'a Arena<'tcx>,\n@@ -541,7 +555,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     }\n \n     // Any type that impls `Copy` can be arena-allocated in the `DroplessArena`.\n-    impl<'tcx, T: Copy> ArenaAllocatable<'tcx, ()> for T {\n+    impl<'tcx, T: Copy> ArenaAllocatable<'tcx, rustc_arena::IsCopy> for T {\n         #[inline]\n         fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n             arena.dropless.alloc(self)\n@@ -555,7 +569,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n         }\n     }\n     $(\n-        impl<'tcx> ArenaAllocatable<'tcx, $ty> for $ty {\n+        impl<'tcx> ArenaAllocatable<'tcx, rustc_arena::IsNotCopy> for $ty {\n             #[inline]\n             fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n                 if !::std::mem::needs_drop::<Self>() {\n@@ -581,7 +595,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n \n     impl<'tcx> Arena<'tcx> {\n         #[inline]\n-        pub fn alloc<T: ArenaAllocatable<'tcx, U>, U>(&self, value: T) -> &mut T {\n+        pub fn alloc<T: ArenaAllocatable<'tcx, C>, C>(&self, value: T) -> &mut T {\n             value.allocate_on(self)\n         }\n \n@@ -594,7 +608,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n             self.dropless.alloc_slice(value)\n         }\n \n-        pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, U>, U>(\n+        pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, C>, C>(\n             &'a self,\n             iter: impl ::std::iter::IntoIterator<Item = T>,\n         ) -> &'a mut [T] {\n@@ -603,5 +617,10 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     }\n }\n \n+// Marker types that let us give different behaviour for arenas allocating\n+// `Copy` types vs `!Copy` types.\n+pub struct IsCopy;\n+pub struct IsNotCopy;\n+\n #[cfg(test)]\n mod tests;"}]}