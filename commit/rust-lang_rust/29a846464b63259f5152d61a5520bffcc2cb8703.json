{"sha": "29a846464b63259f5152d61a5520bffcc2cb8703", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YTg0NjQ2NGI2MzI1OWY1MTUyZDYxYTU1MjBiZmZjYzJjYjg3MDM=", "commit": {"author": {"name": "Leander Tentrup", "email": "leander.tentrup@gmail.com", "date": "2020-04-16T12:29:58Z"}, "committer": {"name": "Leander Tentrup", "email": "leander.tentrup@gmail.com", "date": "2020-04-18T13:02:51Z"}, "message": "Refactor flattening logic for highlighted syntax ranges", "tree": {"sha": "996c0c95a03db806c84da492156a1d95ff40f486", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/996c0c95a03db806c84da492156a1d95ff40f486"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29a846464b63259f5152d61a5520bffcc2cb8703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29a846464b63259f5152d61a5520bffcc2cb8703", "html_url": "https://github.com/rust-lang/rust/commit/29a846464b63259f5152d61a5520bffcc2cb8703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29a846464b63259f5152d61a5520bffcc2cb8703/comments", "author": {"login": "ltentrup", "id": 201808, "node_id": "MDQ6VXNlcjIwMTgwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/201808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ltentrup", "html_url": "https://github.com/ltentrup", "followers_url": "https://api.github.com/users/ltentrup/followers", "following_url": "https://api.github.com/users/ltentrup/following{/other_user}", "gists_url": "https://api.github.com/users/ltentrup/gists{/gist_id}", "starred_url": "https://api.github.com/users/ltentrup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ltentrup/subscriptions", "organizations_url": "https://api.github.com/users/ltentrup/orgs", "repos_url": "https://api.github.com/users/ltentrup/repos", "events_url": "https://api.github.com/users/ltentrup/events{/privacy}", "received_events_url": "https://api.github.com/users/ltentrup/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ltentrup", "id": 201808, "node_id": "MDQ6VXNlcjIwMTgwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/201808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ltentrup", "html_url": "https://github.com/ltentrup", "followers_url": "https://api.github.com/users/ltentrup/followers", "following_url": "https://api.github.com/users/ltentrup/following{/other_user}", "gists_url": "https://api.github.com/users/ltentrup/gists{/gist_id}", "starred_url": "https://api.github.com/users/ltentrup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ltentrup/subscriptions", "organizations_url": "https://api.github.com/users/ltentrup/orgs", "repos_url": "https://api.github.com/users/ltentrup/repos", "events_url": "https://api.github.com/users/ltentrup/events{/privacy}", "received_events_url": "https://api.github.com/users/ltentrup/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84e3304a9bf0d68e30d58b1e37a6db2e9ec97525", "url": "https://api.github.com/repos/rust-lang/rust/commits/84e3304a9bf0d68e30d58b1e37a6db2e9ec97525", "html_url": "https://github.com/rust-lang/rust/commit/84e3304a9bf0d68e30d58b1e37a6db2e9ec97525"}], "stats": {"total": 139, "additions": 85, "deletions": 54}, "files": [{"sha": "e7d9bf6961597125034d3a64b2cf06b9d7b1c2b2", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 85, "deletions": 54, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/29a846464b63259f5152d61a5520bffcc2cb8703/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a846464b63259f5152d61a5520bffcc2cb8703/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=29a846464b63259f5152d61a5520bffcc2cb8703", "patch": "@@ -31,6 +31,80 @@ pub struct HighlightedRange {\n     pub binding_hash: Option<u64>,\n }\n \n+#[derive(Debug)]\n+struct HighlightedRangeStack {\n+    stack: Vec<Vec<HighlightedRange>>,\n+}\n+\n+/// We use a stack to implement the flattening logic for the highlighted\n+/// syntax ranges.\n+impl HighlightedRangeStack {\n+    fn new() -> Self {\n+        Self { stack: vec![Vec::new()] }\n+    }\n+\n+    fn push(&mut self) {\n+        self.stack.push(Vec::new());\n+    }\n+\n+    /// Flattens the highlighted ranges.\n+    ///\n+    /// For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n+    /// 1) parent-range: Attribute [0, 23)\n+    /// 2) child-range: String [16, 21)\n+    ///\n+    /// The following code implements the flattening, for our example this results to:\n+    /// `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n+    fn pop(&mut self) {\n+        let children = self.stack.pop().unwrap();\n+        let prev = self.stack.last_mut().unwrap();\n+        let needs_flattening = !children.is_empty()\n+            && !prev.is_empty()\n+            && children.first().unwrap().range.is_subrange(&prev.last().unwrap().range);\n+        if !needs_flattening {\n+            prev.extend(children);\n+        } else {\n+            let mut parent = prev.pop().unwrap();\n+            for ele in children {\n+                assert!(ele.range.is_subrange(&parent.range));\n+                let mut cloned = parent.clone();\n+                parent.range = TextRange::from_to(parent.range.start(), ele.range.start());\n+                cloned.range = TextRange::from_to(ele.range.end(), cloned.range.end());\n+                if !parent.range.is_empty() {\n+                    prev.push(parent);\n+                }\n+                prev.push(ele);\n+                parent = cloned;\n+            }\n+            if !parent.range.is_empty() {\n+                prev.push(parent);\n+            }\n+        }\n+    }\n+\n+    fn add(&mut self, range: HighlightedRange) {\n+        self.stack\n+            .last_mut()\n+            .expect(\"during DFS traversal, the stack must not be empty\")\n+            .push(range)\n+    }\n+\n+    fn flattened(mut self) -> Vec<HighlightedRange> {\n+        assert_eq!(\n+            self.stack.len(),\n+            1,\n+            \"after DFS traversal, the stack should only contain a single element\"\n+        );\n+        let res = self.stack.pop().unwrap();\n+        // Check that ranges are sorted and disjoint\n+        assert!(res\n+            .iter()\n+            .zip(res.iter().skip(1))\n+            .all(|(left, right)| left.range.end() <= right.range.start()));\n+        res\n+    }\n+}\n+\n pub(crate) fn highlight(\n     db: &RootDatabase,\n     file_id: FileId,\n@@ -57,52 +131,17 @@ pub(crate) fn highlight(\n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n     // We use a stack for the DFS traversal below.\n     // When we leave a node, the we use it to flatten the highlighted ranges.\n-    let mut res: Vec<Vec<HighlightedRange>> = vec![Vec::new()];\n+    let mut stack = HighlightedRangeStack::new();\n \n     let mut current_macro_call: Option<ast::MacroCall> = None;\n \n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n     for event in root.preorder_with_tokens() {\n         match &event {\n-            WalkEvent::Enter(_) => res.push(Vec::new()),\n-            WalkEvent::Leave(_) => {\n-                /* Flattens the highlighted ranges.\n-                 *\n-                 * For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n-                 * 1) parent-range: Attribute [0, 23)\n-                 * 2) child-range: String [16, 21)\n-                 *\n-                 * The following code implements the flattening, for our example this results to:\n-                 * `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n-                 */\n-                let children = res.pop().unwrap();\n-                let prev = res.last_mut().unwrap();\n-                let needs_flattening = !children.is_empty()\n-                    && !prev.is_empty()\n-                    && children.first().unwrap().range.is_subrange(&prev.last().unwrap().range);\n-                if !needs_flattening {\n-                    prev.extend(children);\n-                } else {\n-                    let mut parent = prev.pop().unwrap();\n-                    for ele in children {\n-                        assert!(ele.range.is_subrange(&parent.range));\n-                        let mut cloned = parent.clone();\n-                        parent.range = TextRange::from_to(parent.range.start(), ele.range.start());\n-                        cloned.range = TextRange::from_to(ele.range.end(), cloned.range.end());\n-                        if !parent.range.is_empty() {\n-                            prev.push(parent);\n-                        }\n-                        prev.push(ele);\n-                        parent = cloned;\n-                    }\n-                    if !parent.range.is_empty() {\n-                        prev.push(parent);\n-                    }\n-                }\n-            }\n+            WalkEvent::Enter(_) => stack.push(),\n+            WalkEvent::Leave(_) => stack.pop(),\n         };\n-        let current = res.last_mut().expect(\"during DFS traversal, the stack must not be empty\");\n \n         let event_range = match &event {\n             WalkEvent::Enter(it) => it.text_range(),\n@@ -119,7 +158,7 @@ pub(crate) fn highlight(\n             WalkEvent::Enter(Some(mc)) => {\n                 current_macro_call = Some(mc.clone());\n                 if let Some(range) = macro_call_range(&mc) {\n-                    current.push(HighlightedRange {\n+                    stack.add(HighlightedRange {\n                         range,\n                         highlight: HighlightTag::Macro.into(),\n                         binding_hash: None,\n@@ -161,27 +200,19 @@ pub(crate) fn highlight(\n \n         if let Some(token) = element.as_token().cloned().and_then(ast::RawString::cast) {\n             let expanded = element_to_highlight.as_token().unwrap().clone();\n-            if highlight_injection(current, &sema, token, expanded).is_some() {\n+            if highlight_injection(&mut stack, &sema, token, expanded).is_some() {\n                 continue;\n             }\n         }\n \n         if let Some((highlight, binding_hash)) =\n             highlight_element(&sema, &mut bindings_shadow_count, element_to_highlight)\n         {\n-            current.push(HighlightedRange { range, highlight, binding_hash });\n+            stack.add(HighlightedRange { range, highlight, binding_hash });\n         }\n     }\n \n-    assert_eq!(res.len(), 1, \"after DFS traversal, the stack should only contain a single element\");\n-    let mut res = res.pop().unwrap();\n-    res.sort_by_key(|range| range.range.start());\n-    // Check that ranges are sorted and disjoint\n-    assert!(res\n-        .iter()\n-        .zip(res.iter().skip(1))\n-        .all(|(left, right)| left.range.end() <= right.range.start()));\n-    res\n+    stack.flattened()\n }\n \n fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n@@ -358,7 +389,7 @@ fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n }\n \n fn highlight_injection(\n-    acc: &mut Vec<HighlightedRange>,\n+    acc: &mut HighlightedRangeStack,\n     sema: &Semantics<RootDatabase>,\n     literal: ast::RawString,\n     expanded: SyntaxToken,\n@@ -373,7 +404,7 @@ fn highlight_injection(\n     let (analysis, tmp_file_id) = Analysis::from_single_file(value);\n \n     if let Some(range) = literal.open_quote_text_range() {\n-        acc.push(HighlightedRange {\n+        acc.add(HighlightedRange {\n             range,\n             highlight: HighlightTag::StringLiteral.into(),\n             binding_hash: None,\n@@ -383,12 +414,12 @@ fn highlight_injection(\n     for mut h in analysis.highlight(tmp_file_id).unwrap() {\n         if let Some(r) = literal.map_range_up(h.range) {\n             h.range = r;\n-            acc.push(h)\n+            acc.add(h)\n         }\n     }\n \n     if let Some(range) = literal.close_quote_text_range() {\n-        acc.push(HighlightedRange {\n+        acc.add(HighlightedRange {\n             range,\n             highlight: HighlightTag::StringLiteral.into(),\n             binding_hash: None,"}]}