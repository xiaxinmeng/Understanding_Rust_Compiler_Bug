{"sha": "51d85e10601e07ff0997ca3a199149f728ba0665", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZDg1ZTEwNjAxZTA3ZmYwOTk3Y2EzYTE5OTE0OWY3MjhiYTA2NjU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-01T22:24:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-01T22:24:17Z"}, "message": "Merge #9454\n\n9454: feat: Empower `replace_if_let_with_match` r=Veykril a=Veykril\n\nNow instead of only working on `if let ... {} else {}` if expressions it now works on all of them where the condition expression is the same text-wise.\r\n\r\nThis includes if let expressions without an else block, in which case a simple `_ => ()` will be generated in the resulting match but also in more complex cases where multiple `if let` expressions are chained.\r\n\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "d39ab28228c7e791dacf1b5c1e3b3515c8601693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d39ab28228c7e791dacf1b5c1e3b3515c8601693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51d85e10601e07ff0997ca3a199149f728ba0665", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg3kCRCRBK7hj4Ov3rIwAAyAkIAHJn6EITiDORvNZL1t53GL+V\nLLB8llB643gw3bYKllMRFyzaZ+004/LXxhWn4xZjdqNKJ6GPZMS2MJkQPncSC13w\nH0qTy9rhhF9T6eicVN+tut+mVAYzuwg3nHzuMfjEVSZ/xSpbq23Pxfk/qUuzt020\nHqzqNaQA4FS3D5VqL8fmD48kOeuFlWT05PR+gJCcmHn1eMPRndkSysjC0miTnveM\nPPbXwHWPIKRVpCd0HOlJt8bZGK8Ydn4mtkA8uptVYZY1zCz/8g6CVdl+hIizx7qz\n1sI1sjL+u5eXiezqWl8t2qOknJdC6Q991uXTak9ZO4KrQ2bIhsmfxy2sFvx2jd8=\n=pZpm\n-----END PGP SIGNATURE-----\n", "payload": "tree d39ab28228c7e791dacf1b5c1e3b3515c8601693\nparent 334c7eba8d0211d093185e9308aa5c747e6677ea\nparent 20be999304c068c6c54e8cca998afe892356c11a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1625178257 +0000\ncommitter GitHub <noreply@github.com> 1625178257 +0000\n\nMerge #9454\n\n9454: feat: Empower `replace_if_let_with_match` r=Veykril a=Veykril\n\nNow instead of only working on `if let ... {} else {}` if expressions it now works on all of them where the condition expression is the same text-wise.\r\n\r\nThis includes if let expressions without an else block, in which case a simple `_ => ()` will be generated in the resulting match but also in more complex cases where multiple `if let` expressions are chained.\r\n\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51d85e10601e07ff0997ca3a199149f728ba0665", "html_url": "https://github.com/rust-lang/rust/commit/51d85e10601e07ff0997ca3a199149f728ba0665", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51d85e10601e07ff0997ca3a199149f728ba0665/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "334c7eba8d0211d093185e9308aa5c747e6677ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/334c7eba8d0211d093185e9308aa5c747e6677ea", "html_url": "https://github.com/rust-lang/rust/commit/334c7eba8d0211d093185e9308aa5c747e6677ea"}, {"sha": "20be999304c068c6c54e8cca998afe892356c11a", "url": "https://api.github.com/repos/rust-lang/rust/commits/20be999304c068c6c54e8cca998afe892356c11a", "html_url": "https://github.com/rust-lang/rust/commit/20be999304c068c6c54e8cca998afe892356c11a"}], "stats": {"total": 177, "additions": 112, "deletions": 65}, "files": [{"sha": "888b4d090b00672fb735c24921e5fe34cb257fb9", "filename": "crates/ide_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 109, "deletions": 61, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/51d85e10601e07ff0997ca3a199149f728ba0665/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51d85e10601e07ff0997ca3a199149f728ba0665/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=51d85e10601e07ff0997ca3a199149f728ba0665", "patch": "@@ -1,4 +1,4 @@\n-use std::iter;\n+use std::iter::{self, successors};\n \n use ide_db::{ty_filter::TryEnum, RootDatabase};\n use syntax::{\n@@ -17,7 +17,7 @@ use crate::{\n \n // Assist: replace_if_let_with_match\n //\n-// Replaces `if let` with an else branch with a `match` expression.\n+// Replaces a `if let` expression with a `match` expression.\n //\n // ```\n // enum Action { Move { distance: u32 }, Stop }\n@@ -43,14 +43,28 @@ use crate::{\n // ```\n pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n-    let cond = if_expr.condition()?;\n-    let pat = cond.pat()?;\n-    let expr = cond.expr()?;\n-    let then_block = if_expr.then_branch()?;\n-    let else_block = match if_expr.else_branch()? {\n-        ast::ElseBranch::Block(it) => it,\n-        ast::ElseBranch::IfExpr(_) => return None,\n-    };\n+    let mut else_block = None;\n+    let if_exprs = successors(Some(if_expr.clone()), |expr| match expr.else_branch()? {\n+        ast::ElseBranch::IfExpr(expr) => Some(expr),\n+        ast::ElseBranch::Block(block) => {\n+            else_block = Some(block);\n+            None\n+        }\n+    });\n+    let scrutinee_to_be_expr = if_expr.condition()?.expr()?;\n+\n+    let mut pat_bodies = Vec::new();\n+    for if_expr in if_exprs {\n+        let cond = if_expr.condition()?;\n+        let expr = cond.expr()?;\n+        if scrutinee_to_be_expr.syntax().text() != expr.syntax().text() {\n+            // Only if all condition expressions are equal we can merge them into a match\n+            return None;\n+        }\n+        let pat = cond.pat()?;\n+        let body = if_expr.then_branch()?;\n+        pat_bodies.push((pat, body));\n+    }\n \n     let target = if_expr.syntax().text_range();\n     acc.add(\n@@ -59,33 +73,50 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n         target,\n         move |edit| {\n             let match_expr = {\n-                let then_arm = {\n-                    let then_block = then_block.reset_indent().indent(IndentLevel(1));\n-                    let then_expr = unwrap_trivial_block(then_block);\n-                    make::match_arm(vec![pat.clone()], then_expr)\n-                };\n                 let else_arm = {\n-                    let pattern = ctx\n-                        .sema\n-                        .type_of_pat(&pat)\n-                        .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n-                        .map(|it| {\n-                            if does_pat_match_variant(&pat, &it.sad_pattern()) {\n-                                it.happy_pattern()\n-                            } else {\n-                                it.sad_pattern()\n+                    match else_block {\n+                        Some(else_block) => {\n+                            let pattern = match &*pat_bodies {\n+                                [(pat, _)] => ctx\n+                                    .sema\n+                                    .type_of_pat(&pat)\n+                                    .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n+                                    .map(|it| {\n+                                        if does_pat_match_variant(&pat, &it.sad_pattern()) {\n+                                            it.happy_pattern()\n+                                        } else {\n+                                            it.sad_pattern()\n+                                        }\n+                                    }),\n+                                _ => None,\n                             }\n-                        })\n-                        .unwrap_or_else(|| make::wildcard_pat().into());\n-                    let else_expr = unwrap_trivial_block(else_block);\n-                    make::match_arm(vec![pattern], else_expr)\n+                            .unwrap_or_else(|| make::wildcard_pat().into());\n+                            make::match_arm(iter::once(pattern), unwrap_trivial_block(else_block))\n+                        }\n+                        None => make::match_arm(\n+                            iter::once(make::wildcard_pat().into()),\n+                            make::expr_unit().into(),\n+                        ),\n+                    }\n                 };\n-                let match_expr =\n-                    make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]));\n+                let arms = pat_bodies\n+                    .into_iter()\n+                    .map(|(pat, body)| {\n+                        let body = body.reset_indent().indent(IndentLevel(1));\n+                        make::match_arm(vec![pat], unwrap_trivial_block(body))\n+                    })\n+                    .chain(iter::once(else_arm));\n+                let match_expr = make::expr_match(scrutinee_to_be_expr, make::match_arm_list(arms));\n                 match_expr.indent(IndentLevel::from_node(if_expr.syntax()))\n             };\n \n-            edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n+            let expr =\n+                if if_expr.syntax().parent().map_or(false, |it| ast::IfExpr::can_cast(it.kind())) {\n+                    make::block_expr(None, Some(match_expr)).into()\n+                } else {\n+                    match_expr\n+                };\n+            edit.replace_ast::<ast::Expr>(if_expr.into(), expr);\n         },\n     )\n }\n@@ -182,79 +213,96 @@ mod tests {\n     use crate::tests::{check_assist, check_assist_target};\n \n     #[test]\n-    fn test_replace_if_let_with_match_unwraps_simple_expressions() {\n+    fn test_if_let_with_match_no_else() {\n         check_assist(\n             replace_if_let_with_match,\n             r#\"\n impl VariantData {\n-    pub fn is_struct(&self) -> bool {\n+    pub fn foo(&self) {\n         if $0let VariantData::Struct(..) = *self {\n-            true\n-        } else {\n-            false\n+            self.foo();\n         }\n     }\n }           \"#,\n             r#\"\n impl VariantData {\n-    pub fn is_struct(&self) -> bool {\n+    pub fn foo(&self) {\n         match *self {\n-            VariantData::Struct(..) => true,\n-            _ => false,\n+            VariantData::Struct(..) => {\n+                self.foo();\n+            }\n+            _ => (),\n         }\n     }\n }           \"#,\n         )\n     }\n \n     #[test]\n-    fn test_replace_if_let_with_match_doesnt_unwrap_multiline_expressions() {\n+    fn test_if_let_with_match_basic() {\n         check_assist(\n             replace_if_let_with_match,\n             r#\"\n-fn foo() {\n-    if $0let VariantData::Struct(..) = a {\n-        bar(\n-            123\n-        )\n-    } else {\n-        false\n-    }\n-}           \"#,\n-            r#\"\n-fn foo() {\n-    match a {\n-        VariantData::Struct(..) => {\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        if $0let VariantData::Struct(..) = *self {\n+            true\n+        } else if let VariantData::Tuple(..) = *self {\n+            false\n+        } else {\n             bar(\n                 123\n             )\n         }\n-        _ => false,\n+    }\n+}           \"#,\n+            r#\"\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        match *self {\n+            VariantData::Struct(..) => true,\n+            VariantData::Tuple(..) => false,\n+            _ => {\n+                    bar(\n+                        123\n+                    )\n+                }\n+        }\n     }\n }           \"#,\n         )\n     }\n \n     #[test]\n-    fn replace_if_let_with_match_target() {\n-        check_assist_target(\n+    fn test_if_let_with_match_on_tail_if_let() {\n+        check_assist(\n             replace_if_let_with_match,\n             r#\"\n impl VariantData {\n     pub fn is_struct(&self) -> bool {\n-        if $0let VariantData::Struct(..) = *self {\n+        if let VariantData::Struct(..) = *self {\n             true\n+        } else if let$0 VariantData::Tuple(..) = *self {\n+            false\n         } else {\n             false\n         }\n     }\n }           \"#,\n-            \"if let VariantData::Struct(..) = *self {\n+            r#\"\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        if let VariantData::Struct(..) = *self {\n             true\n         } else {\n-            false\n-        }\",\n-        );\n+    match *self {\n+            VariantData::Tuple(..) => false,\n+            _ => false,\n+        }\n+}\n+    }\n+}           \"#,\n+        )\n     }\n \n     #[test]"}, {"sha": "c3839a2b0bebfac7caa5284f8618590f46b6189f", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51d85e10601e07ff0997ca3a199149f728ba0665/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51d85e10601e07ff0997ca3a199149f728ba0665/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=51d85e10601e07ff0997ca3a199149f728ba0665", "patch": "@@ -48,15 +48,14 @@ pub fn extract_trivial_expression(block: &ast::BlockExpr) -> Option<ast::Expr> {\n         return Some(expr);\n     }\n     // Unwrap `{ continue; }`\n-    let (stmt,) = block.statements().next_tuple()?;\n+    let stmt = block.statements().next()?;\n     if let ast::Stmt::ExprStmt(expr_stmt) = stmt {\n         if has_anything_else(expr_stmt.syntax()) {\n             return None;\n         }\n         let expr = expr_stmt.expr()?;\n-        match expr.syntax().kind() {\n-            CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR => return Some(expr),\n-            _ => (),\n+        if matches!(expr.syntax().kind(), CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR) {\n+            return Some(expr);\n         }\n     }\n     None"}]}