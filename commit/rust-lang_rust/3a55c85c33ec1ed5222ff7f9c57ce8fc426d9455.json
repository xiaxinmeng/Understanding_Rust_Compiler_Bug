{"sha": "3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNTVjODVjMzNlYzFlZDUyMjJmZjdmOWM1N2NlOGZjNDI2ZDk0NTU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-06-17T09:45:38Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-29T08:10:58Z"}, "message": "Incorporate RalfJung's suggestions\n\nThis splits \"valid\" into \"valid for reads\" and \"valid for writes\", and\nalso adds the concept of operation size to validity. Now functions which\noperate on sequences state that e.g. pointer args must be \"valid for reads of\nsize x\".", "tree": {"sha": "c93a19fdc4e62ba773cf45ec8520f0ba15498a5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c93a19fdc4e62ba773cf45ec8520f0ba15498a5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455", "html_url": "https://github.com/rust-lang/rust/commit/3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea5570cf277601f479a0a5fc8e65adfac60d2922", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea5570cf277601f479a0a5fc8e65adfac60d2922", "html_url": "https://github.com/rust-lang/rust/commit/ea5570cf277601f479a0a5fc8e65adfac60d2922"}], "stats": {"total": 101, "additions": 49, "deletions": 52}, "files": [{"sha": "b9b086db010699c04d0fc349c27aee14ecc3039a", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455", "patch": "@@ -976,19 +976,15 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Behavior is undefined if any of the following conditions are violated:\n     ///\n-    /// * Both `src` and `dst` must be properly aligned.\n+    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n     ///\n-    /// * `src.offset(i)` must be [valid] for all `i` in `0..count`. In other\n-    ///   words, the region of memory which begins at `src` and has a length of\n-    ///   `count * size_of::<T>()` bytes must belong to a single, live\n-    ///   allocation.\n+    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n     ///\n-    /// * `dst.offset(i)` must be [valid] for all `i` in `0..count`. In other\n-    ///   words, the region of memory which begins at `dst` and has a length of\n-    ///   `count * size_of::<T>()` bytes must belong to a single, live\n-    ///   allocation.\n+    /// * Both `src` and `dst` must be properly aligned.\n     ///\n-    /// * The two regions of memory must *not* overlap.\n+    /// * The region of memory beginning at `src` with a size of `count *\n+    ///   size_of::<T>()` bytes must *not* overlap with the region of memory\n+    ///   beginning at `dst` with the same size.\n     ///\n     /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n     /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the values\n@@ -1064,17 +1060,11 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Behavior is undefined if any of the following conditions are violated:\n     ///\n-    /// * Both `src` and `dst` must be properly aligned.\n+    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n     ///\n-    /// * `src.offset(i)` must be [valid] for all `i` in `0..count`. In other\n-    ///   words, the region of memory which begins at `src` and has a length of\n-    ///   `count * size_of::<T>()` bytes must belong to a single, live\n-    ///   allocation.\n+    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n     ///\n-    /// * `dst.offset(i)` must be [valid] for all `i` in `0..count`. In other\n-    ///   words, the region of memory which begins at `dst` and has a length of\n-    ///   `count * size_of::<T>()` bytes must belong to a single, live\n-    ///   allocation.\n+    /// * Both `src` and `dst` must be properly aligned.\n     ///\n     /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n     /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the values\n@@ -1116,12 +1106,9 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Behavior is undefined if any of the following conditions are violated:\n     ///\n-    /// * `dst` must be properly aligned.\n+    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n     ///\n-    /// * `dst.offset(i)` must be [valid] for all `i` in `0..count`. In other\n-    ///   words, the region of memory which begins at `dst` and has a length of\n-    ///   `count * size_of::<T>()` bytes must belong to a single, live\n-    ///   allocation.\n+    /// * `dst` must be properly aligned.\n     ///\n     /// Additionally, the caller must ensure that writing `count *\n     /// size_of::<T>()` bytes to the given region of memory results in a valid"}, {"sha": "ee209b9ccca701bad6facdb4c8bb1e0247d7ebc4", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=3a55c85c33ec1ed5222ff7f9c57ce8fc426d9455", "patch": "@@ -19,25 +19,38 @@\n //! Many functions in this module take raw pointers as arguments and dereference\n //! them. For this to be safe, these pointers must be valid. However, because\n //! rust does not yet have a formal memory model, determining whether an\n-//! arbitrary pointer is a valid one can be tricky. One thing is certain:\n-//! creating a raw pointer from a reference (e.g. `&x as *const _`) *always*\n-//! results in a valid pointer. By exploiting this\u2014and by taking care when\n-//! using [pointer arithmetic]\u2014users can be confident in the correctness of\n-//! their unsafe code.\n+//! arbitrary pointer is valid for a given operation can be tricky.\n //!\n-//! For more information on dereferencing raw pointers, see the both the [book]\n-//! and the section in the reference devoted to [undefined behavior][ub].\n+//! There are two types of operations on memory, reads and writes. It is\n+//! possible for a `*mut` to be valid for one operation and not the other. Since\n+//! a `*const` can only be read and not written, it has no such ambiguity. For\n+//! example, a `*mut` is not valid for writes if a a reference exists which\n+//! [refers to the same memory][aliasing]. Therefore, each function in this\n+//! module will document which operations must be valid on any `*mut` arguments.\n+//!\n+//! Additionally, some functions (e.g. [`copy`]) take a single pointer but\n+//! operate on many values. In this case, the function will state the size of\n+//! the operation for which the pointer must be valid. For example,\n+//! `copy::<T>(&src, &mut dst, 3)` requires `dst` to be valid for writes of\n+//! `size_of::<T>() * 3` bytes. When the documentation requires that a pointer\n+//! be valid for an operation but omits the size of that operation, the size is\n+//! implied to be `size_of::<T>()` bytes.\n+//!\n+//! For more information on the safety implications of dereferencing raw\n+//! pointers, see the both the [book] and the section in the reference devoted\n+//! to [undefined behavior][ub].\n //!\n //! ## Alignment\n //!\n //! Valid pointers are not necessarily properly aligned. However, most functions\n //! require their arguments to be properly aligned, and will explicitly state\n-//! this requirement in the `Safety` section. Notable exceptions to this are\n+//! this requirement in their documentation. Notable exceptions to this are\n //! [`read_unaligned`] and [`write_unaligned`].\n //!\n-//! [ub]: ../../reference/behavior-considered-undefined.html\n+//! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/second-edition/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n-//! [pointer arithmetic]: ../../std/primitive.pointer.html#method.offset\n+//! [ub]: ../../reference/behavior-considered-undefined.html\n+//! [`copy`]: ./fn.copy.html\n //! [`read_unaligned`]: ./fn.read_unaligned.html\n //! [`write_unaligned`]: ./fn.write_unaligned.html\n \n@@ -83,7 +96,7 @@ pub use intrinsics::write_bytes;\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `to_drop` must be [valid].\n+/// * `to_drop` must be [valid] for reads.\n ///\n /// * `to_drop` must be properly aligned.\n ///\n@@ -178,7 +191,7 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * Both `x` and `y` must be [valid].\n+/// * Both `x` and `y` must be [valid] for reads and writes.\n ///\n /// * Both `x` and `y` must be properly aligned.\n ///\n@@ -240,17 +253,14 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * Both `x` and `y` must be properly aligned.\n-///\n-/// * `x.offset(i)` must be [valid] for all `i` in `0..count`. In other words,\n-///   the region of memory which begins at `x` and has a length of `count *\n-///   size_of::<T>()` bytes must belong to a single, live allocation.\n+/// * Both `x` and `y` must be [valid] for reads and writes of `count *\n+///   size_of::<T>()` bytes.\n ///\n-/// * `y.offset(i)` must be [valid] for all `i` in `0..count`. In other words,\n-///   the region of memory which begins at `y` and has a length of `count *\n-///   size_of::<T>()` bytes must belong to a single, live allocation.\n+/// * Both `x` and `y` must be properly aligned.\n ///\n-/// * The two regions of memory must *not* overlap.\n+/// * The region of memory beginning at `x` with a size of `count *\n+///   size_of::<T>()` bytes must *not* overlap with the region of memory\n+///   beginning at `y` with the same size.\n ///\n /// [valid]: ../ptr/index.html#safety\n ///\n@@ -359,7 +369,7 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `dest` must be [valid].\n+/// * `dest` must be [valid] for writes.\n ///\n /// * `dest` must be properly aligned.\n ///\n@@ -395,7 +405,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `src` must be [valid].\n+/// * `src` must be [valid] for reads.\n ///\n /// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n ///   case.\n@@ -508,7 +518,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `src` must be [valid].\n+/// * `src` must be [valid] for reads.\n ///\n /// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n@@ -585,7 +595,7 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `dst` must be [valid].\n+/// * `dst` must be [valid] for writes.\n ///\n /// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n ///   case.\n@@ -659,7 +669,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `dst` must be [valid].\n+/// * `dst` must be [valid] for writes.\n ///\n /// [valid]: ../ptr/index.html#safety\n ///\n@@ -734,7 +744,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `src` must be [valid].\n+/// * `src` must be [valid] for reads.\n ///\n /// * `src` must be properly aligned.\n ///\n@@ -809,7 +819,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `dst` must be [valid].\n+/// * `dst` must be [valid] for writes.\n ///\n /// * `dst` must be properly aligned.\n ///"}]}