{"sha": "3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZDFhNDhmM2Y3YWMwZWVmZmIyYWE1ZDc5YmMwOWRhZjgyN2ZjM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-06T21:31:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-06T21:31:26Z"}, "message": "Auto merge of #27893 - nikomatsakis:mir, r=nrc\n\nThis PR contains a new crate, `rustc_mir`, which implements the MIR as specified in the RFC (more or less). There are no targeted unit tests at the moment, as I didn't decide what kind of infrastructure would be best and didn't take the time to implement it. \r\n\r\n~~NB: In packaging up this PR, I realized that MIR construction code is not triggering for methods right now, I think it's only for fixed fns. I'll push a fix for this soon. Hopefully it doesn't stop any crates from building. :)~~ Fixed. Everything still seems to work.\r\n\r\nHowever, the MIR construction code (`librustc_mir/build`) is intentionally quite distinct from the code which munges the compiler's data structures (`librustc_mir/tcx`). The interface between the two is the `HIR` trait (`librustc_mir/hir`). To avoid confusion with @nrc's work, perhaps a better name for this trait is warranted, although ultimately this trait *will* be connected to the HIR, I imagine, so in a way the name is perfect. Anyway, I'm open to suggestions. The initial motivation for this split was to allow for the MIR construction code to be unit-tested. But while I didn't end up writing unit tests (yet), I did find the split made the code immensely easier to think about, since the messiness of our existing system, with its myriad hashtables, punning, and so forth, is confined to one part, which simply transforms to a more fully explicit AST-like form. I tried to separate out the commits somewhat, but since this mostly new code, it mostly winds up coming in one fell swoop in the MIR commit.\r\n\r\nQuick guide to the MIR crate:\r\n\r\n- `repr.rs` defines the MIR itself; each MIR instance is parameterized by some HIR `H`\r\n- `build/` is the MIR construction code, parameterized by a particular HIR\r\n- `hir/` is the definition of the HIR interface\r\n- `tcx/` is the impl of the HIR interface for the tcx\r\n- `dump.rs` is the minimal compiler pass that invokes the HIR\r\n\r\nOne open question:\r\n\r\n- In the HIR trait, I used exclusively struct-like variants. I found I like this more, since things have names. Should I convert the repr code?", "tree": {"sha": "3bfe81ff0c313bbf801c1a3b41a27dc3260b54b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bfe81ff0c313bbf801c1a3b41a27dc3260b54b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "html_url": "https://github.com/rust-lang/rust/commit/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01b9cc58ba0c91ec265d8c1ad9225b2ca777464e", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b9cc58ba0c91ec265d8c1ad9225b2ca777464e", "html_url": "https://github.com/rust-lang/rust/commit/01b9cc58ba0c91ec265d8c1ad9225b2ca777464e"}, {"sha": "c8a661838ed3f4db7a9402df880e539b46f0a0f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a661838ed3f4db7a9402df880e539b46f0a0f1", "html_url": "https://github.com/rust-lang/rust/commit/c8a661838ed3f4db7a9402df880e539b46f0a0f1"}], "stats": {"total": 6264, "additions": 6161, "deletions": 103}, "files": [{"sha": "b424c1d8779934861f5a11f1c9947a37bf419909", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -54,7 +54,7 @@ TARGET_CRATES := libc std flate arena term \\\n                  log graphviz core rbml alloc \\\n                  rustc_unicode rustc_bitflags \\\n \t\t alloc_system\n-RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n+RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_front rustc_platform_intrinsics\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n@@ -70,11 +70,12 @@ DEPS_std := core libc rand alloc collections rustc_unicode \\\n DEPS_graphviz := std\n DEPS_syntax := std term serialize log fmt_macros arena libc rustc_bitflags\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n-                     rustc_typeck rustc_resolve log syntax serialize rustc_llvm \\\n+                     rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n \t\t             rustc_trans rustc_privacy rustc_lint rustc_front\n \n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n \t                log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics\n+DEPS_rustc_mir := rustc rustc_front syntax\n DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics\n DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n DEPS_rustc_resolve := rustc rustc_front log syntax"}, {"sha": "9ede86937e8af5a47061465c2f69e3a512f2a95c", "filename": "mk/main.mk", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -172,6 +172,18 @@ RUST_LIB_FLAGS_ST3 += -C prefer-dynamic\n # by not emitting them.\n RUSTFLAGS_STAGE0 += -Z no-landing-pads\n \n+# Enable MIR to \"always build\" for crates where this works. This is\n+# just temporary while MIR is being actively built up -- it's just a\n+# poor man's unit testing infrastructure. Anyway we only want this for\n+# stage1/stage2.\n+define ADD_MIR_FLAG\n+RUSTFLAGS1_$(1) += -Z always-build-mir\n+RUSTFLAGS2_$(1) += -Z always-build-mir\n+endef\n+$(foreach crate,$(TARGET_CRATES),$(eval $(call ADD_MIR_FLAG,$(crate))))\n+$(foreach crate,$(RUSTC_CRATES),$(eval $(call ADD_MIR_FLAG,$(crate))))\n+$(foreach crate,$(HOST_CRATES),$(eval $(call ADD_MIR_FLAG,$(crate))))\n+\n # platform-specific auto-configuration\n include $(CFG_SRC_DIR)mk/platform.mk\n "}, {"sha": "d6fa55bf7f51661429b997992350324cc6f9f586", "filename": "mk/target.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -93,6 +93,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n \t\t$$(LLVM_LIBDIR_RUSTFLAGS_$(2)) \\\n \t\t$$(LLVM_STDCPP_RUSTFLAGS_$(2)) \\\n \t\t$$(RUSTFLAGS_$(4)) \\\n+\t\t$$(RUSTFLAGS$(1)_$(4)) \\\n \t\t$$(RUSTFLAGS$(1)_$(4)_T_$(2)) \\\n \t\t--out-dir $$(@D) \\\n \t\t-C extra-filename=-$$(CFG_FILENAME_EXTRA) \\"}, {"sha": "4b2c0189b6b46fb018e9d24b69277e2439f7acb8", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -313,6 +313,13 @@ pub enum LabelText<'a> {\n     /// are also the escape sequences `\\l` which left-justifies the\n     /// preceding line and `\\r` which right-justifies it.\n     EscStr(Cow<'a, str>),\n+\n+    /// This uses a graphviz [HTML string label][html]. The string is\n+    /// printed exactly as given, but between `<` and `>`. **No\n+    /// escaping is performed.**\n+    ///\n+    /// [html]: http://www.graphviz.org/content/node-shapes#html\n+    HtmlStr(Cow<'a, str>),\n }\n \n /// The style for a node or edge.\n@@ -453,6 +460,14 @@ pub trait Labeller<'a,N,E> {\n     /// is a valid DOT identifier.\n     fn node_id(&'a self, n: &N) -> Id<'a>;\n \n+    /// Maps `n` to one of the [graphviz `shape` names][1]. If `None`\n+    /// is returned, no `shape` attribute is specified.\n+    ///\n+    /// [1]: http://www.graphviz.org/content/node-shapes\n+    fn node_shape(&'a self, _node: &N) -> Option<LabelText<'a>> {\n+        None\n+    }\n+\n     /// Maps `n` to a label that will be used in the rendered output.\n     /// The label need not be unique, and may be the empty string; the\n     /// default is just the output from `node_id`.\n@@ -479,6 +494,16 @@ pub trait Labeller<'a,N,E> {\n     }\n }\n \n+/// Escape tags in such a way that it is suitable for inclusion in a\n+/// Graphviz HTML label.\n+pub fn escape_html(s: &str) -> String {\n+    s\n+        .replace(\"&\", \"&amp;\")\n+        .replace(\"\\\"\", \"&quot;\")\n+        .replace(\"<\", \"&lt;\")\n+        .replace(\">\", \"&gt;\")\n+}\n+\n impl<'a> LabelText<'a> {\n     pub fn label<S:IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n         LabelStr(s.into_cow())\n@@ -488,6 +513,10 @@ impl<'a> LabelText<'a> {\n         EscStr(s.into_cow())\n     }\n \n+    pub fn html<S:IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n+        HtmlStr(s.into_cow())\n+    }\n+\n     fn escape_char<F>(c: char, mut f: F) where F: FnMut(char) {\n         match c {\n             // not escaping \\\\, since Graphviz escString needs to\n@@ -505,10 +534,12 @@ impl<'a> LabelText<'a> {\n     }\n \n     /// Renders text as string suitable for a label in a .dot file.\n-    pub fn escape(&self) -> String {\n+    /// This includes quotes or suitable delimeters.\n+    pub fn to_dot_string(&self) -> String {\n         match self {\n-            &LabelStr(ref s) => s.escape_default(),\n-            &EscStr(ref s) => LabelText::escape_str(&s[..]),\n+            &LabelStr(ref s) => format!(\"\\\"{}\\\"\", s.escape_default()),\n+            &EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(&s[..])),\n+            &HtmlStr(ref s) => format!(\"<{}>\", s),\n         }\n     }\n \n@@ -524,6 +555,7 @@ impl<'a> LabelText<'a> {\n             } else {\n                 s\n             },\n+            HtmlStr(s) => s,\n         }\n     }\n \n@@ -612,14 +644,15 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n         try!(indent(w));\n         let id = g.node_id(n);\n \n-        let escaped = &g.node_label(n).escape();\n+        let escaped = &g.node_label(n).to_dot_string();\n+        let shape;\n \n         let mut text = vec![id.as_slice()];\n \n         if !options.contains(&RenderOption::NoNodeLabels) {\n-            text.push(\"[label=\\\"\");\n+            text.push(\"[label=\");\n             text.push(escaped);\n-            text.push(\"\\\"]\");\n+            text.push(\"]\");\n         }\n \n         let style = g.node_style(n);\n@@ -629,12 +662,19 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n             text.push(\"\\\"]\");\n         }\n \n+        if let Some(s) = g.node_shape(n) {\n+            shape = s.to_dot_string();\n+            text.push(\"[shape=\");\n+            text.push(&shape);\n+            text.push(\"]\");\n+        }\n+\n         text.push(\";\");\n         try!(writeln(w, &text));\n     }\n \n     for e in g.edges().iter() {\n-        let escaped_label = &g.edge_label(e).escape();\n+        let escaped_label = &g.edge_label(e).to_dot_string();\n         try!(indent(w));\n         let source = g.source(e);\n         let target = g.target(e);\n@@ -644,9 +684,9 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n         let mut text = vec![source_id.as_slice(), \" -> \", target_id.as_slice()];\n \n         if !options.contains(&RenderOption::NoEdgeLabels) {\n-            text.push(\"[label=\\\"\");\n+            text.push(\"[label=\");\n             text.push(escaped_label);\n-            text.push(\"\\\"]\");\n+            text.push(\"]\");\n         }\n \n         let style = g.edge_style(e);\n@@ -667,7 +707,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n mod tests {\n     use self::NodeLabels::*;\n     use super::{Id, Labeller, Nodes, Edges, GraphWalk, render, Style};\n-    use super::LabelText::{self, LabelStr, EscStr};\n+    use super::LabelText::{self, LabelStr, EscStr, HtmlStr};\n     use std::io;\n     use std::io::prelude::*;\n     use std::borrow::IntoCow;\n@@ -805,12 +845,12 @@ mod tests {\n         fn node_id(&'a self, n: &Node) -> Id<'a> { self.graph.node_id(n) }\n         fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n             match self.graph.node_label(n) {\n-                LabelStr(s) | EscStr(s) => EscStr(s),\n+                LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n             }\n         }\n         fn edge_label(&'a self, e: & &'a Edge) -> LabelText<'a> {\n             match self.graph.edge_label(e) {\n-                LabelStr(s) | EscStr(s) => EscStr(s),\n+                LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n             }\n         }\n     }"}, {"sha": "abf2d5f3625dc2019e5930e64e4a4ce9744fd583", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -470,8 +470,8 @@ impl tr for def::Def {\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n           def::DefTyParam(s, index, def_id, n) => def::DefTyParam(s, index, def_id.tr(dcx), n),\n           def::DefUse(did) => def::DefUse(did.tr(dcx)),\n-          def::DefUpvar(nid1, nid2) => {\n-            def::DefUpvar(dcx.tr_id(nid1), dcx.tr_id(nid2))\n+          def::DefUpvar(nid1, index, nid2) => {\n+            def::DefUpvar(dcx.tr_id(nid1), index, dcx.tr_id(nid2))\n           }\n           def::DefStruct(did) => def::DefStruct(did.tr(dcx)),\n           def::DefRegion(nid) => def::DefRegion(dcx.tr_id(nid)),"}, {"sha": "86133aad67216a0ee760e2918205e49319953998", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -38,6 +38,7 @@ pub enum Def {\n     DefTyParam(ParamSpace, u32, DefId, ast::Name),\n     DefUse(DefId),\n     DefUpvar(ast::NodeId,  // id of closed over local\n+             usize,        // index in the freevars list of the closure\n              ast::NodeId), // expr node that creates the closure\n \n     /// Note that if it's a tuple struct's definition, the node id of the DefId\n@@ -129,7 +130,7 @@ impl Def {\n                 id\n             }\n             DefLocal(id) |\n-            DefUpvar(id, _) |\n+            DefUpvar(id, _, _) |\n             DefRegion(id) |\n             DefLabel(id)  |\n             DefSelfTy(_, Some((_, id))) => {"}, {"sha": "d2bb31f10bd14025a1e93ff532589cbf349e21d9", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -246,7 +246,7 @@ impl OverloadedCallType {\n pub struct ExprUseVisitor<'d, 't, 'a: 't, 'tcx:'a+'d+'t> {\n     typer: &'t infer::InferCtxt<'a, 'tcx>,\n     mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n-    delegate: &'d mut (Delegate<'tcx>+'d),\n+    delegate: &'d mut Delegate<'tcx>,\n }\n \n // If the TYPER results in an error, it's because the type check"}, {"sha": "51005ef8b97704c2c2b71846df9359cc52a38b18", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -578,7 +578,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               }))\n           }\n \n-          def::DefUpvar(var_id, fn_node_id) => {\n+          def::DefUpvar(var_id, _, fn_node_id) => {\n               let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n                   ty::TyClosure(closure_id, _) => {"}, {"sha": "f08cbb41438511b41e2215e00de9ae9fbc4c1886", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -329,6 +329,9 @@ impl RegionMaps {\n     pub fn item_extent(&self, n: ast::NodeId) -> CodeExtent {\n         self.lookup_code_extent(CodeExtentData::DestructionScope(n))\n     }\n+    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent> {\n+        self.code_extent_interner.borrow().get(&CodeExtentData::DestructionScope(n)).cloned()\n+    }\n     pub fn intern_code_extent(&self,\n                               e: CodeExtentData,\n                               parent: CodeExtent) -> CodeExtent {"}, {"sha": "9f2c87b1a0a5ee250f71348618f003ea7fde88b0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -3475,6 +3475,13 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             .expect(\"variant_with_id: unknown variant\")\n     }\n \n+    pub fn variant_index_with_id(&self, vid: DefId) -> usize {\n+        self.variants\n+            .iter()\n+            .position(|v| v.did == vid)\n+            .expect(\"variant_index_with_id: unknown variant\")\n+    }\n+\n     pub fn variant_of_def(&self, def: def::Def) -> &VariantDefData<'tcx, 'container> {\n         match def {\n             def::DefVariant(_, vid, _) => self.variant_with_id(vid),\n@@ -5191,28 +5198,12 @@ impl<'tcx> TyS<'tcx> {\n \n                         if !adjusted_ty.references_error() {\n                             for i in 0..adj.autoderefs {\n-                                let method_call = MethodCall::autoderef(expr_id, i as u32);\n-                                match method_type(method_call) {\n-                                    Some(method_ty) => {\n-                                        // Overloaded deref operators have all late-bound\n-                                        // regions fully instantiated and coverge.\n-                                        let fn_ret =\n-                                            cx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n-                                        adjusted_ty = fn_ret.unwrap();\n-                                    }\n-                                    None => {}\n-                                }\n-                                match adjusted_ty.builtin_deref(true, NoPreference) {\n-                                    Some(mt) => { adjusted_ty = mt.ty; }\n-                                    None => {\n-                                        cx.sess.span_bug(\n-                                            span,\n-                                            &format!(\"the {}th autoderef failed: {}\",\n-                                                    i,\n-                                                     adjusted_ty)\n-                                            );\n-                                    }\n-                                }\n+                                adjusted_ty =\n+                                    adjusted_ty.adjust_for_autoderef(cx,\n+                                                                     expr_id,\n+                                                                     span,\n+                                                                     i as u32,\n+                                                                     &mut method_type);\n                             }\n                         }\n \n@@ -5228,6 +5219,36 @@ impl<'tcx> TyS<'tcx> {\n         };\n     }\n \n+    pub fn adjust_for_autoderef<F>(&'tcx self,\n+                                   cx: &ctxt<'tcx>,\n+                                   expr_id: ast::NodeId,\n+                                   expr_span: Span,\n+                                   autoderef: u32, // how many autoderefs so far?\n+                                   mut method_type: F)\n+                                   -> Ty<'tcx> where\n+        F: FnMut(MethodCall) -> Option<Ty<'tcx>>,\n+    {\n+        let method_call = MethodCall::autoderef(expr_id, autoderef);\n+        let mut adjusted_ty = self;\n+        if let Some(method_ty) = method_type(method_call) {\n+            // Method calls always have all late-bound regions\n+            // fully instantiated.\n+            let fn_ret = cx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n+            adjusted_ty = fn_ret.unwrap();\n+        }\n+        match adjusted_ty.builtin_deref(true, NoPreference) {\n+            Some(mt) => mt.ty,\n+            None => {\n+                cx.sess.span_bug(\n+                    expr_span,\n+                    &format!(\"the {}th autoderef failed: {}\",\n+                             autoderef,\n+                             adjusted_ty)\n+                        );\n+            }\n+        }\n+    }\n+\n     pub fn adjust_for_autoref(&'tcx self, cx: &ctxt<'tcx>,\n                               autoref: Option<AutoRef<'tcx>>)\n                               -> Ty<'tcx> {"}, {"sha": "b56283e756723c965fd8c7ccfef15d7bc1755096", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -104,6 +104,7 @@ pub struct Options {\n     pub parse_only: bool,\n     pub no_trans: bool,\n     pub treat_err_as_bug: bool,\n+    pub always_build_mir: bool,\n     pub no_analysis: bool,\n     pub debugging_opts: DebuggingOptions,\n     /// Whether to write dependency files. It's (enabled, optional filename).\n@@ -216,6 +217,7 @@ pub fn basic_options() -> Options {\n         parse_only: false,\n         no_trans: false,\n         treat_err_as_bug: false,\n+        always_build_mir: false,\n         no_analysis: false,\n         debugging_opts: basic_debugging_options(),\n         write_dependency_info: (false, None),\n@@ -583,6 +585,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"Run all passes except translation; no output\"),\n     treat_err_as_bug: bool = (false, parse_bool,\n           \"Treat all errors that occur as bugs\"),\n+    always_build_mir: bool = (false, parse_bool,\n+          \"Always build MIR for all fns, even without a #[rustc_mir] annotation\"),\n     no_analysis: bool = (false, parse_bool,\n           \"Parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list,\n@@ -894,6 +898,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let parse_only = debugging_opts.parse_only;\n     let no_trans = debugging_opts.no_trans;\n     let treat_err_as_bug = debugging_opts.treat_err_as_bug;\n+    let always_build_mir = debugging_opts.always_build_mir;\n     let no_analysis = debugging_opts.no_analysis;\n \n     if debugging_opts.debug_llvm {\n@@ -1049,6 +1054,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         parse_only: parse_only,\n         no_trans: no_trans,\n         treat_err_as_bug: treat_err_as_bug,\n+        always_build_mir: always_build_mir,\n         no_analysis: no_analysis,\n         debugging_opts: debugging_opts,\n         write_dependency_info: write_dependency_info,"}, {"sha": "4a45797602d811f270571b29794150c9b4c579ef", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -13,54 +13,19 @@\n #![allow(non_snake_case)]\n \n use middle::def_id::DefId;\n-use std::collections::hash_state::DefaultState;\n-use std::collections::{HashMap, HashSet};\n-use std::default::Default;\n-use std::hash::{Hasher, Hash};\n use syntax::ast;\n \n-pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n-pub type FnvHashSet<V> = HashSet<V, DefaultState<FnvHasher>>;\n+pub use rustc_data_structures::fnv::FnvHashMap;\n+pub use rustc_data_structures::fnv::FnvHashSet;\n \n pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n pub type DefIdMap<T> = FnvHashMap<DefId, T>;\n \n pub type NodeSet = FnvHashSet<ast::NodeId>;\n pub type DefIdSet = FnvHashSet<DefId>;\n \n-pub fn FnvHashMap<K: Hash + Eq, V>() -> FnvHashMap<K, V> {\n-    Default::default()\n-}\n-pub fn FnvHashSet<V: Hash + Eq>() -> FnvHashSet<V> {\n-    Default::default()\n-}\n-\n pub fn NodeMap<T>() -> NodeMap<T> { FnvHashMap() }\n pub fn DefIdMap<T>() -> DefIdMap<T> { FnvHashMap() }\n pub fn NodeSet() -> NodeSet { FnvHashSet() }\n pub fn DefIdSet() -> DefIdSet { FnvHashSet() }\n \n-/// A speedy hash algorithm for node ids and def ids. The hashmap in\n-/// libcollections by default uses SipHash which isn't quite as speedy as we\n-/// want. In the compiler we're not really worried about DOS attempts, so we\n-/// just default to a non-cryptographic hash.\n-///\n-/// This uses FNV hashing, as described here:\n-/// http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n-pub struct FnvHasher(u64);\n-\n-impl Default for FnvHasher {\n-    fn default() -> FnvHasher { FnvHasher(0xcbf29ce484222325) }\n-}\n-\n-impl Hasher for FnvHasher {\n-    fn write(&mut self, bytes: &[u8]) {\n-        let FnvHasher(mut hash) = *self;\n-        for byte in bytes {\n-            hash = hash ^ (*byte as u64);\n-            hash = hash.wrapping_mul(0x100000001b3);\n-        }\n-        *self = FnvHasher(hash);\n-    }\n-    fn finish(&self) -> u64 { self.0 }\n-}"}, {"sha": "77baa84c0236d020e2d7ab133575d68b2f9cded7", "filename": "src/librustc_data_structures/fnv.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_data_structures%2Ffnv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_data_structures%2Ffnv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffnv.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::{HashMap, HashSet};\n+use std::collections::hash_state::DefaultState;\n+use std::default::Default;\n+use std::hash::{Hasher, Hash};\n+\n+pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n+pub type FnvHashSet<V> = HashSet<V, DefaultState<FnvHasher>>;\n+\n+#[allow(non_snake_case)]\n+pub fn FnvHashMap<K: Hash + Eq, V>() -> FnvHashMap<K, V> {\n+    Default::default()\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn FnvHashSet<V: Hash + Eq>() -> FnvHashSet<V> {\n+    Default::default()\n+}\n+\n+/// A speedy hash algorithm for node ids and def ids. The hashmap in\n+/// libcollections by default uses SipHash which isn't quite as speedy as we\n+/// want. In the compiler we're not really worried about DOS attempts, so we\n+/// just default to a non-cryptographic hash.\n+///\n+/// This uses FNV hashing, as described here:\n+/// http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n+pub struct FnvHasher(u64);\n+\n+impl Default for FnvHasher {\n+    fn default() -> FnvHasher { FnvHasher(0xcbf29ce484222325) }\n+}\n+\n+impl Hasher for FnvHasher {\n+    fn write(&mut self, bytes: &[u8]) {\n+        let FnvHasher(mut hash) = *self;\n+        for byte in bytes {\n+            hash = hash ^ (*byte as u64);\n+            hash = hash.wrapping_mul(0x100000001b3);\n+        }\n+        *self = FnvHasher(hash);\n+    }\n+    fn finish(&self) -> u64 { self.0 }\n+}"}, {"sha": "4a3810c822b4dd5bf8062b1882c7ecf122793261", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -119,11 +119,21 @@ impl<N:Debug,E:Debug> Graph<N,E> {\n         &self.nodes\n     }\n \n+    #[inline]\n+    pub fn len_nodes(&self) -> usize {\n+        self.nodes.len()\n+    }\n+\n     #[inline]\n     pub fn all_edges<'a>(&'a self) -> &'a [Edge<E>] {\n         &self.edges\n     }\n \n+    #[inline]\n+    pub fn len_edges(&self) -> usize {\n+        self.edges.len()\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Node construction\n "}, {"sha": "4688742a4ab7583665e7db549b354e0daf06bbf9", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -28,6 +28,8 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(rustc_private, staged_api)]\n+#![feature(hashmap_hasher)]\n+\n #![cfg_attr(test, feature(test))]\n \n #[macro_use] extern crate log;\n@@ -39,6 +41,7 @@ pub mod ivar;\n pub mod snapshot_vec;\n pub mod transitive_relation;\n pub mod unify;\n+pub mod fnv;\n \n // See comments in src/librustc/lib.rs\n #[doc(hidden)]"}, {"sha": "f3038624ac107e467a5304d4569e550f6d2e3975", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -10,6 +10,7 @@\n \n use rustc::front;\n use rustc::front::map as hir_map;\n+use rustc_mir as mir;\n use rustc::session::Session;\n use rustc::session::config::{self, Input, OutputFilenames};\n use rustc::session::search_paths::PathKind;\n@@ -706,6 +707,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n         // passes are timed inside typeck\n         typeck::check_crate(tcx, trait_map);\n \n+        time(time_passes, \"MIR dump\", ||\n+             mir::dump::dump_crate(tcx));\n+\n         time(time_passes, \"const checking\", ||\n             middle::check_const::check_crate(tcx));\n "}, {"sha": "7d9c74fe48702d74b1f6900f2b25ee0bec600111", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -45,6 +45,7 @@ extern crate rustc_borrowck;\n extern crate rustc_front;\n extern crate rustc_lint;\n extern crate rustc_privacy;\n+extern crate rustc_mir;\n extern crate rustc_resolve;\n extern crate rustc_trans;\n extern crate rustc_typeck;"}, {"sha": "5604c78e098d81a4d433677cce4721a3f980943f", "filename": "src/librustc_mir/build/block.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hair::*;\n+use repr::*;\n+use build::{BlockAnd, Builder};\n+\n+impl<H:Hair> Builder<H> {\n+    pub fn ast_block(&mut self,\n+                     destination: &Lvalue<H>,\n+                     mut block: BasicBlock,\n+                     ast_block: H::Block)\n+                     -> BlockAnd<()> {\n+        let this = self;\n+        let Block { extent, span: _, stmts, expr } = this.hir.mirror(ast_block);\n+        this.in_scope(extent, block, |this| {\n+            unpack!(block = this.stmts(block, stmts));\n+            this.into(destination, block, expr)\n+        })\n+    }\n+}"}, {"sha": "955e1b7146a46fc6881f20d8af46620c4a80722e", "filename": "src/librustc_mir/build/cfg.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+\n+\n+//! Routines for manipulating the control-flow graph.\n+\n+use build::CFG;\n+use hair::*;\n+use repr::*;\n+\n+impl<H:Hair> CFG<H> {\n+    pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<H> {\n+        &self.basic_blocks[blk.index()]\n+    }\n+\n+    pub fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<H> {\n+        &mut self.basic_blocks[blk.index()]\n+    }\n+\n+    pub fn end_point(&self, block: BasicBlock) -> ExecutionPoint {\n+        ExecutionPoint {\n+            block: block,\n+            statement: self.block_data(block).statements.len() as u32\n+        }\n+    }\n+\n+    pub fn start_new_block(&mut self) -> BasicBlock {\n+        let node_index = self.basic_blocks.len();\n+        self.basic_blocks.push(BasicBlockData::new(Terminator::Diverge));\n+        BasicBlock::new(node_index)\n+    }\n+\n+    pub fn push(&mut self, block: BasicBlock, statement: Statement<H>) {\n+        debug!(\"push({:?}, {:?})\", block, statement);\n+        self.block_data_mut(block).statements.push(statement);\n+    }\n+\n+    pub fn push_assign_constant(&mut self,\n+                                block: BasicBlock,\n+                                span: H::Span,\n+                                temp: &Lvalue<H>,\n+                                constant: Constant<H>) {\n+        self.push_assign(block, span, temp, Rvalue::Use(Operand::Constant(constant)));\n+    }\n+\n+    pub fn push_drop(&mut self, block: BasicBlock, span: H::Span,\n+                     kind: DropKind, lvalue: &Lvalue<H>) {\n+        self.push(block, Statement {\n+            span: span,\n+            kind: StatementKind::Drop(kind, lvalue.clone())\n+        });\n+    }\n+\n+    pub fn push_assign(&mut self,\n+                       block: BasicBlock,\n+                       span: H::Span,\n+                       lvalue: &Lvalue<H>,\n+                       rvalue: Rvalue<H>) {\n+        self.push(block, Statement {\n+            span: span,\n+            kind: StatementKind::Assign(lvalue.clone(), rvalue)\n+        });\n+    }\n+\n+    pub fn terminate(&mut self,\n+                     block: BasicBlock,\n+                     terminator: Terminator<H>) {\n+        // Check whether this block has already been terminated. For\n+        // this, we rely on the fact that the initial state is to have\n+        // a Diverge terminator and an empty list of targets (which\n+        // is not a valid state).\n+        debug_assert!(match self.block_data(block).terminator { Terminator::Diverge => true,\n+                                                                _ => false },\n+                      \"terminate: block {:?} already has a terminator set\", block);\n+\n+        self.block_data_mut(block).terminator = terminator;\n+    }\n+}\n+"}, {"sha": "a6d06c447a4c0efba77214fce174a150d87dc5aa", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,123 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! See docs in build/expr/mod.rs\n+\n+use rustc_data_structures::fnv::FnvHashMap;\n+\n+use build::{Builder};\n+use hair::*;\n+use repr::*;\n+\n+impl<H:Hair> Builder<H> {\n+    /// Compile `expr`, yielding a compile-time constant. Assumes that\n+    /// `expr` is a valid compile-time constant!\n+    pub fn as_constant<M>(&mut self, expr: M) -> Constant<H>\n+        where M: Mirror<H, Output=Expr<H>>\n+    {\n+        let expr = self.hir.mirror(expr);\n+        self.expr_as_constant(expr)\n+    }\n+\n+    fn expr_as_constant(&mut self, expr: Expr<H>) -> Constant<H> {\n+        let this = self;\n+        let Expr { ty: _, temp_lifetime: _, span, kind } = expr;\n+        let kind = match kind {\n+            ExprKind::Scope { extent: _, value } => {\n+                return this.as_constant(value);\n+            }\n+            ExprKind::Paren { arg } => {\n+                return this.as_constant(arg);\n+            }\n+            ExprKind::Literal { literal } => {\n+                ConstantKind::Literal(literal)\n+            }\n+            ExprKind::Vec { fields } => {\n+                let fields = this.as_constants(fields);\n+                ConstantKind::Aggregate(AggregateKind::Vec, fields)\n+            }\n+            ExprKind::Tuple { fields } => {\n+                let fields = this.as_constants(fields);\n+                ConstantKind::Aggregate(AggregateKind::Tuple, fields)\n+            }\n+            ExprKind::Adt { adt_def, variant_index, substs, fields, base: None } => {\n+                let field_names = this.hir.fields(adt_def, variant_index);\n+                let fields = this.named_field_constants(field_names, fields);\n+                ConstantKind::Aggregate(AggregateKind::Adt(adt_def, variant_index, substs), fields)\n+            }\n+            ExprKind::Repeat { value, count } => {\n+                let value = Box::new(this.as_constant(value));\n+                let count = Box::new(this.as_constant(count));\n+                ConstantKind::Repeat(value, count)\n+            }\n+            ExprKind::Binary { op, lhs, rhs } => {\n+                let lhs = Box::new(this.as_constant(lhs));\n+                let rhs = Box::new(this.as_constant(rhs));\n+                ConstantKind::BinaryOp(op, lhs, rhs)\n+            }\n+            ExprKind::Unary { op, arg } => {\n+                let arg = Box::new(this.as_constant(arg));\n+                ConstantKind::UnaryOp(op, arg)\n+            }\n+            ExprKind::Field { lhs, name } => {\n+                let lhs = this.as_constant(lhs);\n+                ConstantKind::Projection(\n+                    Box::new(ConstantProjection {\n+                        base: lhs,\n+                        elem: ProjectionElem::Field(name),\n+                    }))\n+            }\n+            ExprKind::Deref { arg } => {\n+                let arg = this.as_constant(arg);\n+                ConstantKind::Projection(\n+                    Box::new(ConstantProjection {\n+                        base: arg,\n+                        elem: ProjectionElem::Deref,\n+                    }))\n+            }\n+            ExprKind::Call { fun, args } => {\n+                let fun = this.as_constant(fun);\n+                let args = this.as_constants(args);\n+                ConstantKind::Call(Box::new(fun), args)\n+            }\n+            _ => {\n+                this.hir.span_bug(\n+                    span,\n+                    &format!(\"expression is not a valid constant {:?}\", kind));\n+            }\n+        };\n+        Constant { span: span, kind: kind }\n+    }\n+\n+    fn as_constants(&mut self,\n+                    exprs: Vec<ExprRef<H>>)\n+                    -> Vec<Constant<H>>\n+    {\n+        exprs.into_iter().map(|expr| self.as_constant(expr)).collect()\n+    }\n+\n+    fn named_field_constants(&mut self,\n+                             field_names: Vec<Field<H>>,\n+                             field_exprs: Vec<FieldExprRef<H>>)\n+                             -> Vec<Constant<H>>\n+    {\n+        let fields_map: FnvHashMap<_, _> =\n+            field_exprs.into_iter()\n+                       .map(|f| (f.name, self.as_constant(f.expr)))\n+                       .collect();\n+\n+        let fields: Vec<_> =\n+            field_names.into_iter()\n+                       .map(|n| fields_map[&n].clone())\n+                       .collect();\n+\n+        fields\n+    }\n+}"}, {"sha": "0ceafcc9a62667f1fa152d01c3e41bc7efd04699", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! See docs in build/expr/mod.rs\n+\n+use build::{BlockAnd, Builder};\n+use build::expr::category::Category;\n+use hair::*;\n+use repr::*;\n+\n+impl<H:Hair> Builder<H> {\n+    /// Compile `expr`, yielding an lvalue that we can move from etc.\n+    pub fn as_lvalue<M>(&mut self,\n+                        block: BasicBlock,\n+                        expr: M)\n+                        -> BlockAnd<Lvalue<H>>\n+        where M: Mirror<H, Output=Expr<H>>\n+    {\n+        let expr = self.hir.mirror(expr);\n+        self.expr_as_lvalue(block, expr)\n+    }\n+\n+    fn expr_as_lvalue(&mut self,\n+                      mut block: BasicBlock,\n+                      expr: Expr<H>)\n+                      -> BlockAnd<Lvalue<H>>\n+    {\n+        debug!(\"expr_as_lvalue(block={:?}, expr={:?})\",\n+               block, expr);\n+\n+        let this = self;\n+        let expr_span = expr.span;\n+        match expr.kind {\n+            ExprKind::Scope { extent, value } => {\n+                this.in_scope(extent, block, |this| {\n+                    this.as_lvalue(block, value)\n+                })\n+            }\n+            ExprKind::Paren { arg } => {\n+                this.as_lvalue(block, arg)\n+            }\n+            ExprKind::Field { lhs, name } => {\n+                let lvalue = unpack!(block = this.as_lvalue(block, lhs));\n+                let lvalue = lvalue.field(name);\n+                block.and(lvalue)\n+            }\n+            ExprKind::Deref { arg } => {\n+                let lvalue = unpack!(block = this.as_lvalue(block, arg));\n+                let lvalue = lvalue.deref();\n+                block.and(lvalue)\n+            }\n+            ExprKind::Index { lhs, index } => {\n+                let (usize_ty, bool_ty) = (this.hir.usize_ty(), this.hir.bool_ty());\n+\n+                let slice = unpack!(block = this.as_lvalue(block, lhs));\n+\n+                let idx = unpack!(block = this.as_operand(block, index));\n+\n+                // bounds check:\n+                let (len, lt) = (this.temp(usize_ty.clone()), this.temp(bool_ty));\n+                this.cfg.push_assign(block, expr_span, // len = len(slice)\n+                                     &len, Rvalue::Len(slice.clone()));\n+                this.cfg.push_assign(block, expr_span, // lt = idx < len\n+                                     &lt, Rvalue::BinaryOp(BinOp::Lt,\n+                                                           idx.clone(),\n+                                                           Operand::Consume(len)));\n+\n+                let (success, failure) = (this.cfg.start_new_block(),\n+                                          this.cfg.start_new_block());\n+                this.cfg.terminate(block,\n+                                   Terminator::If {\n+                                       cond: Operand::Consume(lt),\n+                                       targets: [success, failure]\n+                                   });\n+                this.panic(failure);\n+                success.and(slice.index(idx))\n+            }\n+            ExprKind::SelfRef => {\n+                block.and(Lvalue::Arg(0))\n+            }\n+            ExprKind::VarRef { id } => {\n+                let index = this.var_indices[&id];\n+                block.and(Lvalue::Var(index))\n+            }\n+            ExprKind::StaticRef { id } => {\n+                block.and(Lvalue::Static(id))\n+            }\n+\n+            ExprKind::Vec { .. } |\n+            ExprKind::Tuple { .. } |\n+            ExprKind::Adt { .. } |\n+            ExprKind::Closure { .. } |\n+            ExprKind::Unary { .. } |\n+            ExprKind::Binary { .. } |\n+            ExprKind::LogicalOp { .. } |\n+            ExprKind::Box { .. } |\n+            ExprKind::Cast { .. } |\n+            ExprKind::ReifyFnPointer { .. } |\n+            ExprKind::UnsafeFnPointer { .. } |\n+            ExprKind::Unsize { .. } |\n+            ExprKind::Repeat { .. } |\n+            ExprKind::Borrow { .. } |\n+            ExprKind::If { .. } |\n+            ExprKind::Match { .. } |\n+            ExprKind::Loop { .. } |\n+            ExprKind::Block { .. } |\n+            ExprKind::Assign { .. } |\n+            ExprKind::AssignOp { .. } |\n+            ExprKind::Break { .. } |\n+            ExprKind::Continue { .. } |\n+            ExprKind::Return { .. } |\n+            ExprKind::Literal { .. } |\n+            ExprKind::InlineAsm { .. } |\n+            ExprKind::Call { .. } => {\n+                // these are not lvalues, so we need to make a temporary.\n+                debug_assert!(match Category::of(&expr.kind) {\n+                    Some(Category::Lvalue) => false,\n+                    _ => true,\n+                });\n+                this.as_temp(block, expr)\n+            }\n+        }\n+    }\n+}"}, {"sha": "ee090571b7cc5950dd1a1ff3e03534553a185b68", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! See docs in build/expr/mod.rs\n+\n+use build::{BlockAnd, Builder};\n+use build::expr::category::Category;\n+use hair::*;\n+use repr::*;\n+\n+impl<H:Hair> Builder<H> {\n+    /// Compile `expr` into a value that can be used as an operand.\n+    /// If `expr` is an lvalue like `x`, this will introduce a\n+    /// temporary `tmp = x`, so that we capture the value of `x` at\n+    /// this time.\n+    pub fn as_operand<M>(&mut self,\n+                         block: BasicBlock,\n+                         expr: M)\n+                         -> BlockAnd<Operand<H>>\n+        where M: Mirror<H, Output=Expr<H>>\n+    {\n+        let expr = self.hir.mirror(expr);\n+        self.expr_as_operand(block, expr)\n+    }\n+\n+    fn expr_as_operand(&mut self,\n+                       mut block: BasicBlock,\n+                       expr: Expr<H>)\n+                       -> BlockAnd<Operand<H>>\n+    {\n+        debug!(\"expr_as_operand(block={:?}, expr={:?})\",\n+               block, expr);\n+        let this = self;\n+\n+        match expr.kind {\n+            ExprKind::Scope { extent, value } => {\n+                return this.in_scope(extent, block, |this| {\n+                    this.as_operand(block, value)\n+                });\n+            }\n+            ExprKind::Paren { arg } => {\n+                return this.as_operand(block, arg);\n+            }\n+            _ => { }\n+        }\n+\n+        let category = Category::of(&expr.kind).unwrap();\n+        debug!(\"expr_as_operand: category={:?} for={:?}\", category, expr.kind);\n+        match category {\n+            Category::Constant => {\n+                let constant = this.as_constant(expr);\n+                block.and(Operand::Constant(constant))\n+            }\n+            Category::Lvalue |\n+            Category::Rvalue(..) => {\n+                let operand = unpack!(block = this.as_temp(block, expr));\n+                block.and(Operand::Consume(operand))\n+            }\n+        }\n+    }\n+}"}, {"sha": "e4d3ad21503ed0de6b4acce88627aaa8ffb0d7ef", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,220 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! See docs in build/expr/mod.rs\n+\n+use rustc_data_structures::fnv::FnvHashMap;\n+\n+use build::{BlockAnd, Builder};\n+use build::expr::category::{Category, RvalueFunc};\n+use hair::*;\n+use repr::*;\n+\n+impl<H:Hair> Builder<H> {\n+    /// Compile `expr`, yielding an rvalue.\n+    pub fn as_rvalue<M>(&mut self,\n+                        block: BasicBlock,\n+                        expr: M)\n+                        -> BlockAnd<Rvalue<H>>\n+        where M: Mirror<H, Output=Expr<H>>\n+    {\n+        let expr = self.hir.mirror(expr);\n+        self.expr_as_rvalue(block, expr)\n+    }\n+\n+    fn expr_as_rvalue(&mut self,\n+                      mut block: BasicBlock,\n+                      expr: Expr<H>)\n+                      -> BlockAnd<Rvalue<H>>\n+    {\n+        debug!(\"expr_as_rvalue(block={:?}, expr={:?})\",\n+               block, expr);\n+\n+        let this = self;\n+        let expr_span = expr.span;\n+\n+        match expr.kind {\n+            ExprKind::Scope { extent, value } => {\n+                this.in_scope(extent, block, |this| {\n+                    this.as_rvalue(block, value)\n+                })\n+            }\n+            ExprKind::Paren { arg } => {\n+                this.as_rvalue(block, arg)\n+            }\n+            ExprKind::InlineAsm { asm } => {\n+                block.and(Rvalue::InlineAsm(asm))\n+            }\n+            ExprKind::Repeat { value, count } => {\n+                let value_operand = unpack!(block = this.as_operand(block, value));\n+                let count_operand = unpack!(block = this.as_operand(block, count));\n+                block.and(Rvalue::Repeat(value_operand, count_operand))\n+            }\n+            ExprKind::Borrow { region, borrow_kind, arg } => {\n+                let arg_lvalue = unpack!(block = this.as_lvalue(block, arg));\n+                block.and(Rvalue::Ref(region, borrow_kind, arg_lvalue))\n+            }\n+            ExprKind::Binary { op, lhs, rhs } => {\n+                let lhs = unpack!(block = this.as_operand(block, lhs));\n+                let rhs = unpack!(block = this.as_operand(block, rhs));\n+                block.and(Rvalue::BinaryOp(op, lhs, rhs))\n+            }\n+            ExprKind::Unary { op, arg } => {\n+                let arg = unpack!(block = this.as_operand(block, arg));\n+                block.and(Rvalue::UnaryOp(op, arg))\n+            }\n+            ExprKind::Box { place: _, value } => {\n+                let value = this.hir.mirror(value);\n+                let value_ty = value.ty.clone();\n+                let result = this.temp(value_ty.clone());\n+\n+                // to start, malloc some memory of suitable type (thus far, uninitialized):\n+                let rvalue = Rvalue::Box(value.ty.clone());\n+                this.cfg.push_assign(block, expr_span, &result, rvalue);\n+\n+                // schedule a shallow free of that memory, lest we unwind:\n+                let extent = this.extent_of_innermost_scope().unwrap();\n+                this.schedule_drop(expr_span, extent, DropKind::Shallow, &result, value_ty);\n+\n+                // initialize the box contents:\n+                let contents = result.clone().deref();\n+                unpack!(block = this.into(&contents, block, value));\n+\n+                // now that the result is fully initialized, cancel the drop\n+                // by \"using\" the result (which is linear):\n+                block.and(Rvalue::Use(Operand::Consume(result)))\n+            }\n+            ExprKind::Cast { source } => {\n+                let source = unpack!(block = this.as_operand(block, source));\n+                block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n+            }\n+            ExprKind::ReifyFnPointer { source } => {\n+                let source = unpack!(block = this.as_operand(block, source));\n+                block.and(Rvalue::Cast(CastKind::ReifyFnPointer, source, expr.ty))\n+            }\n+            ExprKind::UnsafeFnPointer { source } => {\n+                let source = unpack!(block = this.as_operand(block, source));\n+                block.and(Rvalue::Cast(CastKind::UnsafeFnPointer, source, expr.ty))\n+            }\n+            ExprKind::Unsize { source } => {\n+                let source = unpack!(block = this.as_operand(block, source));\n+                block.and(Rvalue::Cast(CastKind::Unsize, source, expr.ty))\n+            }\n+            ExprKind::Vec { fields } => {\n+                // (*) We would (maybe) be closer to trans if we\n+                // handled this and other aggregate cases via\n+                // `into()`, not `as_rvalue` -- in that case, instead\n+                // of generating\n+                //\n+                //     let tmp1 = ...1;\n+                //     let tmp2 = ...2;\n+                //     dest = Rvalue::Aggregate(Foo, [tmp1, tmp2])\n+                //\n+                // we could just generate\n+                //\n+                //     dest.f = ...1;\n+                //     dest.g = ...2;\n+                //\n+                // The problem is that then we would need to:\n+                //\n+                // (a) have a more complex mechanism for handling\n+                //     partial cleanup;\n+                // (b) distinguish the case where the type `Foo` has a\n+                //     destructor, in which case creating an instance\n+                //     as a whole \"arms\" the destructor, and you can't\n+                //     write individual fields; and,\n+                // (c) handle the case where the type Foo has no\n+                //     fields. We don't want `let x: ();` to compile\n+                //     to the same MIR as `let x = ();`.\n+\n+                // first process the set of fields\n+                let fields: Vec<_> =\n+                    fields.into_iter()\n+                          .map(|f| unpack!(block = this.as_operand(block, f)))\n+                          .collect();\n+\n+                block.and(Rvalue::Aggregate(AggregateKind::Vec, fields))\n+            }\n+            ExprKind::Tuple { fields } => { // see (*) above\n+                // first process the set of fields\n+                let fields: Vec<_> =\n+                    fields.into_iter()\n+                          .map(|f| unpack!(block = this.as_operand(block, f)))\n+                          .collect();\n+\n+                block.and(Rvalue::Aggregate(AggregateKind::Tuple, fields))\n+            }\n+            ExprKind::Closure { closure_id, substs, upvars } => { // see (*) above\n+                let upvars =\n+                    upvars.into_iter()\n+                          .map(|upvar| unpack!(block = this.as_operand(block, upvar)))\n+                          .collect();\n+                block.and(Rvalue::Aggregate(AggregateKind::Closure(closure_id, substs), upvars))\n+            }\n+            ExprKind::Adt { adt_def, variant_index, substs, fields, base } => { // see (*) above\n+                // first process the set of fields\n+                let fields_map: FnvHashMap<_, _> =\n+                    fields.into_iter()\n+                          .map(|f| (f.name, unpack!(block = this.as_operand(block, f.expr))))\n+                          .collect();\n+\n+                let field_names =\n+                    this.hir.fields(adt_def, variant_index);\n+\n+                let base =\n+                    base.map(|base| unpack!(block = this.as_lvalue(block, base)));\n+\n+                // for the actual values we use, take either the\n+                // expr the user specified or, if they didn't\n+                // specify something for this field name, create a\n+                // path relative to the base (which must have been\n+                // supplied, or the IR is internally\n+                // inconsistent).\n+                let fields: Vec<_> =\n+                    field_names.into_iter()\n+                               .map(|n| match fields_map.get(&n) {\n+                                   Some(v) => v.clone(),\n+                                   None => Operand::Consume(base.clone().unwrap().field(n)),\n+                               })\n+                               .collect();\n+\n+                block.and(Rvalue::Aggregate(AggregateKind::Adt(adt_def, variant_index, substs),\n+                                            fields))\n+            }\n+            ExprKind::Literal { .. } |\n+            ExprKind::Block { .. } |\n+            ExprKind::Match { .. } |\n+            ExprKind::If { .. } |\n+            ExprKind::Loop { .. } |\n+            ExprKind::LogicalOp { .. } |\n+            ExprKind::Call { .. } |\n+            ExprKind::Field { .. } |\n+            ExprKind::Deref { .. } |\n+            ExprKind::Index { .. } |\n+            ExprKind::VarRef { .. } |\n+            ExprKind::SelfRef |\n+            ExprKind::Assign { .. } |\n+            ExprKind::AssignOp { .. } |\n+            ExprKind::Break { .. } |\n+            ExprKind::Continue { .. } |\n+            ExprKind::Return { .. } |\n+            ExprKind::StaticRef { .. } => {\n+                // these do not have corresponding `Rvalue` variants,\n+                // so make an operand and then return that\n+                debug_assert!(match Category::of(&expr.kind) {\n+                    Some(Category::Rvalue(RvalueFunc::AsRvalue)) => false,\n+                    _ => true,\n+                });\n+                let operand = unpack!(block = this.as_operand(block, expr));\n+                block.and(Rvalue::Use(operand))\n+            }\n+        }\n+    }\n+}"}, {"sha": "50f04e0177b0bfa50dd82a1a2ab5ac71a8d69960", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! See docs in build/expr/mod.rs\n+\n+use build::{BlockAnd, Builder};\n+use build::expr::category::Category;\n+use hair::*;\n+use repr::*;\n+\n+impl<H:Hair> Builder<H> {\n+    /// Compile `expr` into a fresh temporary. This is used when building\n+    /// up rvalues so as to freeze the value that will be consumed.\n+    pub fn as_temp<M>(&mut self,\n+                      block: BasicBlock,\n+                      expr: M)\n+                      -> BlockAnd<Lvalue<H>>\n+        where M: Mirror<H, Output=Expr<H>>\n+    {\n+        let expr = self.hir.mirror(expr);\n+        self.expr_as_temp(block, expr)\n+    }\n+\n+    fn expr_as_temp(&mut self,\n+                    mut block: BasicBlock,\n+                    expr: Expr<H>)\n+                    -> BlockAnd<Lvalue<H>>\n+    {\n+        debug!(\"expr_as_temp(block={:?}, expr={:?})\",\n+               block, expr);\n+        let this = self;\n+\n+        match expr.kind {\n+            ExprKind::Scope { extent, value } => {\n+                return this.in_scope(extent, block, |this| {\n+                    this.as_temp(block, value)\n+                });\n+            }\n+            ExprKind::Paren { arg } => {\n+                return this.as_temp(block, arg);\n+            }\n+            _ => { }\n+        }\n+\n+        let expr_ty = expr.ty.clone();\n+        let temp = this.temp(expr_ty.clone());\n+        let temp_lifetime = match expr.temp_lifetime {\n+            Some(t) => t,\n+            None => {\n+                this.hir.span_bug(\n+                    expr.span,\n+                    &format!(\"no temp_lifetime for expr\"));\n+            }\n+        };\n+        this.schedule_drop(expr.span, temp_lifetime, DropKind::Deep, &temp, expr_ty);\n+\n+        // Careful here not to cause an infinite cycle. If we always\n+        // called `into`, then for lvalues like `x.f`, it would\n+        // eventually fallback to us, and we'd loop. There's a reason\n+        // for this: `as_temp` is the point where we bridge the \"by\n+        // reference\" semantics of `as_lvalue` with the \"by value\"\n+        // semantics of `into`, `as_operand`, `as_rvalue`, and (of\n+        // course) `as_temp`.\n+        match Category::of(&expr.kind).unwrap() {\n+            Category::Lvalue => {\n+                let expr_span = expr.span;\n+                let lvalue = unpack!(block = this.as_lvalue(block, expr));\n+                let rvalue = Rvalue::Use(Operand::Consume(lvalue));\n+                this.cfg.push_assign(block, expr_span, &temp, rvalue);\n+            }\n+            _ => {\n+                unpack!(block = this.into(&temp, block, expr));\n+            }\n+        }\n+\n+        block.and(temp)\n+    }\n+}"}, {"sha": "1f9928acdc81bf8c1216e1a27ee7f3c6b7dbf2af", "filename": "src/librustc_mir/build/expr/category.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hair::*;\n+\n+#[derive(Debug, PartialEq)]\n+pub enum Category {\n+    // An assignable memory location like `x`, `x.f`, `foo()[3]`, that\n+    // sort of thing. Something that could appear on the LHS of an `=`\n+    // sign.\n+    Lvalue,\n+\n+    // A literal like `23` or `\"foo\"`. Does not include constant\n+    // expressions like `3 + 5`.\n+    Constant,\n+\n+    // Something that generates a new value at runtime, like `x + y`\n+    // or `foo()`.\n+    Rvalue(RvalueFunc),\n+}\n+\n+// Rvalues fall into different \"styles\" that will determine which fn\n+// is best suited to generate them.\n+#[derive(Debug, PartialEq)]\n+pub enum RvalueFunc {\n+    // Best generated by `into`. This is generally exprs that\n+    // cause branching, like `match`, but also includes calls.\n+    Into,\n+\n+    // Best generated by `as_rvalue`. This is usually the case.\n+    AsRvalue,\n+}\n+\n+/// Determines the category for a given expression. Note that scope\n+/// and paren expressions have no category.\n+impl Category {\n+    pub fn of<H:Hair>(ek: &ExprKind<H>) -> Option<Category> {\n+        match *ek {\n+            ExprKind::Scope { .. } |\n+            ExprKind::Paren { .. } =>\n+                None,\n+\n+            ExprKind::Field { .. } |\n+            ExprKind::Deref { .. } |\n+            ExprKind::Index { .. } |\n+            ExprKind::SelfRef |\n+            ExprKind::VarRef { .. } |\n+            ExprKind::StaticRef { .. } =>\n+                Some(Category::Lvalue),\n+\n+            ExprKind::LogicalOp { .. } |\n+            ExprKind::If { .. } |\n+            ExprKind::Match { .. } |\n+            ExprKind::Call { .. } =>\n+                Some(Category::Rvalue(RvalueFunc::Into)),\n+\n+            ExprKind::Vec { .. } |\n+            ExprKind::Tuple { .. } |\n+            ExprKind::Adt { .. } |\n+            ExprKind::Closure { .. } |\n+            ExprKind::Unary { .. } |\n+            ExprKind::Binary { .. } |\n+            ExprKind::Box { .. } |\n+            ExprKind::Cast { .. } |\n+            ExprKind::ReifyFnPointer { .. } |\n+            ExprKind::UnsafeFnPointer { .. } |\n+            ExprKind::Unsize { .. } |\n+            ExprKind::Repeat { .. } |\n+            ExprKind::Borrow { .. } |\n+            ExprKind::Assign { .. } |\n+            ExprKind::AssignOp { .. } |\n+            ExprKind::InlineAsm { .. } =>\n+                Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n+\n+            ExprKind::Literal { .. } =>\n+                Some(Category::Constant),\n+\n+            ExprKind::Loop { .. } |\n+            ExprKind::Block { .. } |\n+            ExprKind::Break { .. } |\n+            ExprKind::Continue { .. } |\n+            ExprKind::Return { .. } =>\n+                // FIXME(#27840) these probably want their own\n+                // category, like \"nonterminating\"\n+                Some(Category::Rvalue(RvalueFunc::Into)),\n+        }\n+    }\n+}"}, {"sha": "b409903ad7eb51f19a02378f658f903ec899796b", "filename": "src/librustc_mir/build/expr/into.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,282 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! See docs in build/expr/mod.rs\n+\n+use build::{BlockAnd, Builder};\n+use build::expr::category::{Category, RvalueFunc};\n+use build::scope::LoopScope;\n+use hair::*;\n+use repr::*;\n+\n+impl<H:Hair> Builder<H> {\n+    /// Compile `expr`, storing the result into `destination`, which\n+    /// is assumed to be uninitialized.\n+    pub fn into_expr(&mut self,\n+                     destination: &Lvalue<H>,\n+                     mut block: BasicBlock,\n+                     expr: Expr<H>)\n+                     -> BlockAnd<()>\n+    {\n+        debug!(\"into_expr(destination={:?}, block={:?}, expr={:?})\",\n+               destination, block, expr);\n+\n+        // since we frequently have to reference `self` from within a\n+        // closure, where `self` would be shadowed, it's easier to\n+        // just use the name `this` uniformly\n+        let this = self;\n+        let expr_span = expr.span;\n+\n+        match expr.kind {\n+            ExprKind::Scope { extent, value } => {\n+                this.in_scope(extent, block, |this| {\n+                    this.into(destination, block, value)\n+                })\n+            }\n+            ExprKind::Paren { arg } => {\n+                this.into(destination, block, arg)\n+            }\n+            ExprKind::Block { body: ast_block } => {\n+                this.ast_block(destination, block, ast_block)\n+            }\n+            ExprKind::Match { discriminant, arms } => {\n+                this.match_expr(destination, expr_span, block, discriminant, arms)\n+            }\n+            ExprKind::If { condition: cond_expr, then: then_expr, otherwise: else_expr } => {\n+                let operand = unpack!(block = this.as_operand(block, cond_expr));\n+\n+                let mut then_block = this.cfg.start_new_block();\n+                let mut else_block = this.cfg.start_new_block();\n+                this.cfg.terminate(block, Terminator::If {\n+                    cond: operand,\n+                    targets: [then_block, else_block]\n+                });\n+\n+                unpack!(then_block = this.into(destination, then_block, then_expr));\n+                unpack!(else_block = this.into(destination, else_block, else_expr));\n+\n+                let join_block = this.cfg.start_new_block();\n+                this.cfg.terminate(then_block, Terminator::Goto { target: join_block });\n+                this.cfg.terminate(else_block, Terminator::Goto { target: join_block });\n+\n+                join_block.unit()\n+            }\n+            ExprKind::LogicalOp { op, lhs, rhs } => {\n+                // And:\n+                //\n+                // [block: If(lhs)] -true-> [else_block: If(rhs)] -true-> [true_block]\n+                //        |                          | (false)\n+                //        +----------false-----------+------------------> [false_block]\n+                //\n+                // Or:\n+                //\n+                // [block: If(lhs)] -false-> [else_block: If(rhs)] -true-> [true_block]\n+                //        |                          | (false)\n+                //        +----------true------------+-------------------> [false_block]\n+\n+                let (true_block, false_block, mut else_block, join_block) =\n+                    (this.cfg.start_new_block(), this.cfg.start_new_block(),\n+                     this.cfg.start_new_block(), this.cfg.start_new_block());\n+\n+                let lhs = unpack!(block = this.as_operand(block, lhs));\n+                let blocks = match op {\n+                    LogicalOp::And => [else_block, false_block],\n+                    LogicalOp::Or => [true_block, else_block],\n+                };\n+                this.cfg.terminate(block, Terminator::If { cond: lhs, targets: blocks });\n+\n+                let rhs = unpack!(else_block = this.as_operand(else_block, rhs));\n+                this.cfg.terminate(else_block, Terminator::If {\n+                    cond: rhs,\n+                    targets: [true_block, false_block]\n+                });\n+\n+                this.cfg.push_assign_constant(\n+                    true_block, expr_span, destination,\n+                    Constant {\n+                        span: expr_span,\n+                        kind: ConstantKind::Literal(Literal::Bool { value: true }),\n+                    });\n+\n+                this.cfg.push_assign_constant(\n+                    false_block, expr_span, destination,\n+                    Constant {\n+                        span: expr_span,\n+                        kind: ConstantKind::Literal(Literal::Bool { value: false }),\n+                    });\n+\n+                this.cfg.terminate(true_block, Terminator::Goto { target: join_block });\n+                this.cfg.terminate(false_block, Terminator::Goto { target: join_block });\n+\n+                join_block.unit()\n+            }\n+            ExprKind::Loop { condition: opt_cond_expr, body } => {\n+                // [block] --> [loop_block] ~~> [loop_block_end] -1-> [exit_block]\n+                //                  ^                  |\n+                //                  |                  0\n+                //                  |                  |\n+                //                  |                  v\n+                //           [body_block_end] <~~~ [body_block]\n+                //\n+                // If `opt_cond_expr` is `None`, then the graph is somewhat simplified:\n+                //\n+                // [block] --> [loop_block / body_block ] ~~> [body_block_end]    [exit_block]\n+                //                         ^                          |\n+                //                         |                          |\n+                //                         +--------------------------+\n+                //\n+\n+                let loop_block = this.cfg.start_new_block();\n+                let exit_block = this.cfg.start_new_block();\n+\n+                // start the loop\n+                this.cfg.terminate(block, Terminator::Goto { target: loop_block });\n+\n+                this.in_loop_scope(loop_block, exit_block, |this| {\n+                    // conduct the test, if necessary\n+                    let body_block;\n+                    let opt_cond_expr = opt_cond_expr; // FIXME rustc bug\n+                    if let Some(cond_expr) = opt_cond_expr {\n+                        let loop_block_end;\n+                        let cond = unpack!(loop_block_end = this.as_operand(loop_block, cond_expr));\n+                        body_block = this.cfg.start_new_block();\n+                        this.cfg.terminate(loop_block_end,\n+                                           Terminator::If {\n+                                               cond: cond,\n+                                               targets: [body_block, exit_block]\n+                                           });\n+                    } else {\n+                        body_block = loop_block;\n+                    }\n+\n+                    // execute the body, branching back to the test\n+                    let unit_temp = this.unit_temp.clone();\n+                    let body_block_end = unpack!(this.into(&unit_temp, body_block, body));\n+                    this.cfg.terminate(body_block_end, Terminator::Goto { target: loop_block });\n+\n+                    // final point is exit_block\n+                    exit_block.unit()\n+                })\n+            }\n+            ExprKind::Assign { lhs, rhs } => {\n+                // Note: we evaluate assignments right-to-left. This\n+                // is better for borrowck interaction with overloaded\n+                // operators like x[j] = x[i].\n+                let rhs = unpack!(block = this.as_operand(block, rhs));\n+                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+                this.cfg.push_drop(block, expr_span, DropKind::Deep, &lhs);\n+                this.cfg.push_assign(block, expr_span, &lhs, Rvalue::Use(rhs));\n+                block.unit()\n+            }\n+            ExprKind::AssignOp { op, lhs, rhs } => {\n+                // FIXME(#28160) there is an interesting semantics\n+                // question raised here -- should we \"freeze\" the\n+                // value of the lhs here?  I'm inclined to think not,\n+                // since it seems closer to the semantics of the\n+                // overloaded version, which takes `&mut self`.  This\n+                // only affects weird things like `x += {x += 1; x}`\n+                // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n+\n+                // As above, RTL.\n+                let rhs = unpack!(block = this.as_operand(block, rhs));\n+                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+\n+                // we don't have to drop prior contents or anything\n+                // because AssignOp is only legal for Copy types\n+                // (overloaded ops should be desugared into a call).\n+                this.cfg.push_assign(block, expr_span, &lhs,\n+                                     Rvalue::BinaryOp(op,\n+                                                      Operand::Consume(lhs.clone()),\n+                                                      rhs));\n+\n+                block.unit()\n+            }\n+            ExprKind::Continue { label } => {\n+                this.break_or_continue(expr_span, label, block,\n+                                       |loop_scope| loop_scope.continue_block)\n+            }\n+            ExprKind::Break { label } => {\n+                this.break_or_continue(expr_span, label, block,\n+                                       |loop_scope| loop_scope.break_block)\n+            }\n+            ExprKind::Return { value } => {\n+                unpack!(block = this.into(&Lvalue::ReturnPointer, block, value));\n+                let extent = this.extent_of_outermost_scope().unwrap();\n+                this.exit_scope(expr_span, extent, block, END_BLOCK);\n+                this.cfg.start_new_block().unit()\n+            }\n+            ExprKind::Call { fun, args } => {\n+                let fun = unpack!(block = this.as_lvalue(block, fun));\n+                let args: Vec<_> =\n+                    args.into_iter()\n+                        .map(|arg| unpack!(block = this.as_lvalue(block, arg)))\n+                        .collect();\n+                let success = this.cfg.start_new_block();\n+                let panic = this.diverge_cleanup();\n+                this.cfg.terminate(block,\n+                                   Terminator::Call {\n+                                       data: CallData {\n+                                           destination: destination.clone(),\n+                                           func: fun,\n+                                           args: args\n+                                       },\n+                                       targets: [success, panic]\n+                                   });\n+                success.unit()\n+            }\n+\n+            // these are the cases that are more naturally handled by some other mode\n+            ExprKind::Unary { .. } |\n+            ExprKind::Binary { .. } |\n+            ExprKind::Box { .. } |\n+            ExprKind::Cast { .. } |\n+            ExprKind::ReifyFnPointer { .. } |\n+            ExprKind::UnsafeFnPointer { .. } |\n+            ExprKind::Unsize { .. } |\n+            ExprKind::Repeat { .. } |\n+            ExprKind::Borrow { .. } |\n+            ExprKind::VarRef { .. } |\n+            ExprKind::SelfRef |\n+            ExprKind::StaticRef { .. } |\n+            ExprKind::Vec { .. } |\n+            ExprKind::Tuple { .. } |\n+            ExprKind::Adt { .. } |\n+            ExprKind::Closure { .. } |\n+            ExprKind::Index { .. } |\n+            ExprKind::Deref { .. } |\n+            ExprKind::Literal { .. } |\n+            ExprKind::InlineAsm { .. } |\n+            ExprKind::Field { .. } => {\n+                debug_assert!(match Category::of(&expr.kind).unwrap() {\n+                    Category::Rvalue(RvalueFunc::Into) => false,\n+                    _ => true,\n+                });\n+\n+                let rvalue = unpack!(block = this.as_rvalue(block, expr));\n+                this.cfg.push_assign(block, expr_span, destination, rvalue);\n+                block.unit()\n+            }\n+        }\n+    }\n+\n+    fn break_or_continue<F>(&mut self,\n+                            span: H::Span,\n+                            label: Option<H::CodeExtent>,\n+                            block: BasicBlock,\n+                            exit_selector: F)\n+                            -> BlockAnd<()>\n+        where F: FnOnce(&LoopScope<H>) -> BasicBlock\n+    {\n+        let loop_scope = self.find_loop_scope(span, label);\n+        let exit_block = exit_selector(&loop_scope);\n+        self.exit_scope(span, loop_scope.extent, block, exit_block);\n+        self.cfg.start_new_block().unit()\n+    }\n+}"}, {"sha": "0f168f307aa01b5cb07c1f7a922ed0fea5708057", "filename": "src/librustc_mir/build/expr/mod.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Translates expressions into MIR. As a caller into this module, you\n+//! have many options, but the first thing you have to decide is\n+//! whether you are evaluating this expression for its *value*, its\n+//! *location*, or as a *constant*.\n+//!\n+//! Typically, you want the value: e.g., if you are doing `expr_a +\n+//! expr_b`, you want the values of those expressions. In that case,\n+//! you want one of the following functions. Note that if the expr has\n+//! a type that is not `Copy`, then using any of these functions will\n+//! \"move\" the value out of its current home (if any).\n+//!\n+//! - `into` -- writes the value into a specific location, which\n+//!   should be uninitialized\n+//! - `as_operand` -- evaluates the value and yields an `Operand`,\n+//!   suitable for use as an argument to an `Rvalue`\n+//! - `as_temp` -- evaluates into a temporary; this is similar to `as_operand`\n+//!   except it always returns a fresh lvalue, even for constants\n+//! - `as_rvalue` -- yields an `Rvalue`, suitable for use in an assignment;\n+//!   as of this writing, never needed outside of the `expr` module itself\n+//!\n+//! Sometimes though want the expression's *location*. An example\n+//! would be during a match statement, or the operand of the `&`\n+//! operator. In that case, you want `as_lvalue`. This will create a\n+//! temporary if necessary.\n+//!\n+//! Finally, if it's a constant you seek, then call\n+//! `as_constant`. This creates a `Constant<H>`, but naturally it can\n+//! only be used on constant expressions and hence is needed only in\n+//! very limited contexts.\n+//!\n+//! ### Implementation notes\n+//!\n+//! For any given kind of expression, there is generally one way that\n+//! can be translated most naturally. This is specified by the\n+//! `Category::of` function in the `category` module. For example, a\n+//! struct expression (or other expression that creates a new value)\n+//! is typically easiest to write in terms of `as_rvalue` or `into`,\n+//! whereas a reference to a field is easiest to write in terms of\n+//! `as_lvalue`. (The exception to this is scope and paren\n+//! expressions, which have no category.)\n+//!\n+//! Therefore, the various functions above make use of one another in\n+//! a descending fashion. For any given expression, you should pick\n+//! the most suitable spot to implement it, and then just let the\n+//! other fns cycle around. The handoff works like this:\n+//!\n+//! - `into(lv)` -> fallback is to create a rvalue with `as_rvalue` and assign it to `lv`\n+//! - `as_rvalue` -> fallback is to create an Operand with `as_operand` and use `Rvalue::use`\n+//! - `as_operand` -> either invokes `as_constant` or `as_temp`\n+//! - `as_constant` -> (no fallback)\n+//! - `as_temp` -> creates a temporary and either calls `as_lvalue` or `into`\n+//! - `as_lvalue` -> for rvalues, falls back to `as_temp` and returns that\n+//!\n+//! As you can see, there is a cycle where `into` can (in theory) fallback to `as_temp`\n+//! which can fallback to `into`. So if one of the `ExprKind` variants is not, in fact,\n+//! implemented in the category where it is supposed to be, there will be a problem.\n+//!\n+//! Of those fallbacks, the most interesting one is `as_temp`, because\n+//! it discriminates based on the category of the expression. This is\n+//! basically the point where the \"by value\" operations are bridged\n+//! over to the \"by reference\" mode (`as_lvalue`).\n+\n+mod as_constant;\n+mod as_lvalue;\n+mod as_rvalue;\n+mod as_operand;\n+mod as_temp;\n+mod category;\n+mod into;"}, {"sha": "426e59f1c401c912170c62c38b569d7c2407731b", "filename": "src/librustc_mir/build/into.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! In general, there are a number of things for which it's convenient\n+//! to just call `builder.into` and have it emit its result into a\n+//! given location. This is basically for expressions or things that can be\n+//! wrapped up as expressions (e.g. blocks). To make this ergonomic, we use this\n+//! latter `EvalInto` trait.\n+\n+use build::{BlockAnd, Builder};\n+use hair::*;\n+use repr::*;\n+\n+pub trait EvalInto<H:Hair> {\n+    fn eval_into(self, builder: &mut Builder<H>, destination: &Lvalue<H>,\n+                 block: BasicBlock) -> BlockAnd<()>;\n+}\n+\n+impl<H:Hair> Builder<H> {\n+    pub fn into<E>(&mut self,\n+                   destination: &Lvalue<H>,\n+                   block: BasicBlock,\n+                   expr: E)\n+                   -> BlockAnd<()>\n+        where E: EvalInto<H>\n+    {\n+        expr.eval_into(self, destination, block)\n+    }\n+}\n+\n+impl<H:Hair> EvalInto<H> for ExprRef<H> {\n+    fn eval_into(self,\n+                 builder: &mut Builder<H>,\n+                 destination: &Lvalue<H>,\n+                 block: BasicBlock)\n+                 -> BlockAnd<()> {\n+        let expr = builder.hir.mirror(self);\n+        builder.into_expr(destination, block, expr)\n+    }\n+}\n+\n+impl<H:Hair> EvalInto<H> for Expr<H> {\n+    fn eval_into(self,\n+                 builder: &mut Builder<H>,\n+                 destination: &Lvalue<H>,\n+                 block: BasicBlock)\n+                 -> BlockAnd<()> {\n+        builder.into_expr(destination, block, self)\n+    }\n+}\n+\n+impl<H:Hair> EvalInto<H> for Option<ExprRef<H>> {\n+    fn eval_into(self,\n+                 builder: &mut Builder<H>,\n+                 destination: &Lvalue<H>,\n+                 block: BasicBlock)\n+                 -> BlockAnd<()> {\n+        match self {\n+            Some(expr) => builder.into(destination, block, expr),\n+            None => block.unit()\n+        }\n+    }\n+}"}, {"sha": "7f0b3ee3b316bb13a13e4cd1d57cb0f83a2cae6f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "added", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,403 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code related to match expresions. These are sufficiently complex\n+//! to warrant their own module and submodules. :) This main module\n+//! includes the high-level algorithm, the submodules contain the\n+//! details.\n+\n+use build::{BlockAnd, Builder};\n+use repr::*;\n+use hair::*;\n+\n+// helper functions, broken out by category:\n+mod simplify;\n+mod test;\n+mod util;\n+\n+impl<H:Hair> Builder<H> {\n+    pub fn match_expr(&mut self,\n+                      destination: &Lvalue<H>,\n+                      span: H::Span,\n+                      mut block: BasicBlock,\n+                      discriminant: ExprRef<H>,\n+                      arms: Vec<Arm<H>>)\n+                      -> BlockAnd<()>\n+    {\n+        let discriminant_lvalue =\n+            unpack!(block = self.as_lvalue(block, discriminant));\n+\n+        let arm_blocks: Vec<BasicBlock> =\n+            arms.iter()\n+                .map(|_| self.cfg.start_new_block())\n+                .collect();\n+\n+        let arm_bodies: Vec<ExprRef<H>> =\n+            arms.iter()\n+                .map(|arm| arm.body.clone())\n+                .collect();\n+\n+        // assemble a list of candidates: there is one candidate per\n+        // pattern, which means there may be more than one candidate\n+        // *per arm*. These candidates are kept sorted such that the\n+        // highest priority candidate comes last in the list. This the\n+        // reverse of the order in which candidates are written in the\n+        // source.\n+        let candidates: Vec<Candidate<H>> =\n+            arms.into_iter()\n+                .zip(arm_blocks.iter())\n+                .rev() // highest priority comes last\n+                .flat_map(|(arm, &arm_block)| {\n+                    let guard = arm.guard;\n+                    arm.patterns.into_iter()\n+                                .rev()\n+                                .map(move |pat| (arm_block, pat, guard.clone()))\n+                })\n+                .map(|(arm_block, pattern, guard)| {\n+                    Candidate {\n+                        match_pairs: vec![self.match_pair(discriminant_lvalue.clone(), pattern)],\n+                        bindings: vec![],\n+                        guard: guard,\n+                        arm_block: arm_block,\n+                    }\n+                })\n+                .collect();\n+\n+        // this will generate code to test discriminant_lvalue and\n+        // branch to the appropriate arm block\n+        let var_extent = self.extent_of_innermost_scope().unwrap();\n+        self.match_candidates(span, var_extent, candidates, block);\n+\n+        // all the arm blocks will rejoin here\n+        let end_block = self.cfg.start_new_block();\n+\n+        for (arm_body, &arm_block) in arm_bodies.into_iter().zip(arm_blocks.iter()) {\n+            let mut arm_block = arm_block;\n+            unpack!(arm_block = self.into(destination, arm_block, arm_body));\n+            self.cfg.terminate(arm_block, Terminator::Goto { target: end_block });\n+        }\n+\n+        end_block.unit()\n+    }\n+\n+    pub fn expr_into_pattern(&mut self,\n+                             mut block: BasicBlock,\n+                             var_extent: H::CodeExtent,          // lifetime of vars\n+                             irrefutable_pat: PatternRef<H>,\n+                             initializer: ExprRef<H>)\n+                             -> BlockAnd<()>\n+    {\n+        // optimize the case of `let x = ...`\n+        let irrefutable_pat = self.hir.mirror(irrefutable_pat);\n+        match irrefutable_pat.kind {\n+            PatternKind::Binding { mutability,\n+                                   name,\n+                                   mode: BindingMode::ByValue,\n+                                   var,\n+                                   ty,\n+                                   subpattern: None } => {\n+                let index = self.declare_binding(var_extent, mutability, name,\n+                                                 var, ty, irrefutable_pat.span);\n+                let lvalue = Lvalue::Var(index);\n+                return self.into(&lvalue, block, initializer);\n+            }\n+            _ => { }\n+        }\n+        let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n+        self.lvalue_into_pattern(block, var_extent,\n+                                 PatternRef::Mirror(Box::new(irrefutable_pat)), &lvalue)\n+    }\n+\n+    pub fn lvalue_into_pattern(&mut self,\n+                               mut block: BasicBlock,\n+                               var_extent: H::CodeExtent,\n+                               irrefutable_pat: PatternRef<H>,\n+                               initializer: &Lvalue<H>)\n+                               -> BlockAnd<()>\n+    {\n+        // create a dummy candidate\n+        let mut candidate = Candidate::<H> {\n+            match_pairs: vec![self.match_pair(initializer.clone(), irrefutable_pat)],\n+            bindings: vec![],\n+            guard: None,\n+            arm_block: block\n+        };\n+\n+        // Simplify the candidate. Since the pattern is irrefutable, this should\n+        // always convert all match-pairs into bindings.\n+        unpack!(block = self.simplify_candidate(block, &mut candidate));\n+\n+        if !candidate.match_pairs.is_empty() {\n+            self.hir.span_bug(\n+                candidate.match_pairs[0].pattern.span,\n+                &format!(\"match pairs {:?} remaining after simplifying irrefutable pattern\",\n+                         candidate.match_pairs));\n+        }\n+\n+        // now apply the bindings, which will also declare the variables\n+        self.bind_matched_candidate(block, var_extent, candidate.bindings);\n+\n+        block.unit()\n+    }\n+\n+    pub fn declare_uninitialized_variables(&mut self,\n+                                           var_extent: H::CodeExtent,\n+                                           pattern: PatternRef<H>)\n+    {\n+        let pattern = self.hir.mirror(pattern);\n+        match pattern.kind {\n+            PatternKind::Binding { mutability, name, mode: _, var, ty, subpattern } => {\n+                self.declare_binding(var_extent, mutability, name, var, ty, pattern.span);\n+                if let Some(subpattern) = subpattern {\n+                    self.declare_uninitialized_variables(var_extent, subpattern);\n+                }\n+            }\n+            PatternKind::Array { prefix, slice, suffix } |\n+            PatternKind::Slice { prefix, slice, suffix } => {\n+                for subpattern in prefix.into_iter().chain(slice).chain(suffix) {\n+                    self.declare_uninitialized_variables(var_extent, subpattern);\n+                }\n+            }\n+            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n+            }\n+            PatternKind::Deref { subpattern } => {\n+                self.declare_uninitialized_variables(var_extent, subpattern);\n+            }\n+            PatternKind::Leaf { subpatterns } |\n+            PatternKind::Variant { subpatterns, .. } => {\n+                for subpattern in subpatterns {\n+                    self.declare_uninitialized_variables(var_extent, subpattern.pattern);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+struct Candidate<H:Hair> {\n+    // all of these must be satisfied...\n+    match_pairs: Vec<MatchPair<H>>,\n+\n+    // ...these bindings established...\n+    bindings: Vec<Binding<H>>,\n+\n+    // ...and the guard must be evaluated...\n+    guard: Option<ExprRef<H>>,\n+\n+    // ...and then we branch here.\n+    arm_block: BasicBlock,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct Binding<H:Hair> {\n+    span: H::Span,\n+    source: Lvalue<H>,\n+    name: H::Ident,\n+    var_id: H::VarId,\n+    var_ty: H::Ty,\n+    mutability: Mutability,\n+    binding_mode: BindingMode<H>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct MatchPair<H:Hair> {\n+    // this lvalue...\n+    lvalue: Lvalue<H>,\n+\n+    // ... must match this pattern.\n+    pattern: Pattern<H>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+enum TestKind<H:Hair> {\n+    // test the branches of enum\n+    Switch { adt_def: H::AdtDef },\n+\n+    // test for equality\n+    Eq { value: Constant<H>, ty: H::Ty },\n+\n+    // test whether the value falls within an inclusive range\n+    Range { lo: Constant<H>, hi: Constant<H>, ty: H::Ty },\n+\n+    // test length of the slice is equal to len\n+    Len { len: usize, op: BinOp },\n+}\n+\n+#[derive(Debug)]\n+struct Test<H:Hair> {\n+    span: H::Span,\n+    kind: TestKind<H>,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Main matching algorithm\n+\n+impl<H:Hair> Builder<H> {\n+    fn match_candidates(&mut self,\n+                        span: H::Span,\n+                        var_extent: H::CodeExtent,\n+                        mut candidates: Vec<Candidate<H>>,\n+                        mut block: BasicBlock)\n+    {\n+        debug!(\"matched_candidate(span={:?}, var_extent={:?}, block={:?}, candidates={:?})\",\n+               span, var_extent, block, candidates);\n+\n+        // Start by simplifying candidates. Once this process is\n+        // complete, all the match pairs which remain require some\n+        // form of test, whether it be a switch or pattern comparison.\n+        for candidate in &mut candidates {\n+            unpack!(block = self.simplify_candidate(block, candidate));\n+        }\n+\n+        // The candidates are inversely sorted by priority. Check to\n+        // see whether the candidates in the front of the queue (and\n+        // hence back of the vec) have satisfied all their match\n+        // pairs.\n+        let fully_matched =\n+            candidates.iter().rev().take_while(|c| c.match_pairs.is_empty()).count();\n+        debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n+        for _ in 0..fully_matched {\n+            // If so, apply any bindings, test the guard (if any), and\n+            // branch to the arm.\n+            let candidate = candidates.pop().unwrap();\n+            match self.bind_and_guard_matched_candidate(block, var_extent, candidate) {\n+                None => { return; }\n+                Some(b) => { block = b; }\n+            }\n+        }\n+\n+        // If there are no candidates that still need testing, we're done.\n+        // Since all matches are exhaustive, execution should never reach this point.\n+        if candidates.is_empty() {\n+            return self.panic(block);\n+        }\n+\n+        // otherwise, extract the next match pair and construct tests\n+        let match_pair = &candidates.last().unwrap().match_pairs[0];\n+        let test = self.test(match_pair);\n+        debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n+        let target_blocks = self.perform_test(block, &match_pair.lvalue, &test);\n+\n+        for (outcome, mut target_block) in target_blocks.into_iter().enumerate() {\n+            let applicable_candidates: Vec<Candidate<H>> =\n+                candidates.iter()\n+                          .filter_map(|candidate| {\n+                              unpack!(target_block =\n+                                      self.candidate_under_assumption(target_block,\n+                                                                      &match_pair.lvalue,\n+                                                                      &test.kind,\n+                                                                      outcome,\n+                                                                      candidate))\n+                          })\n+                          .collect();\n+            self.match_candidates(span, var_extent, applicable_candidates, target_block);\n+        }\n+    }\n+\n+    /// Initializes each of the bindings from the candidate by\n+    /// moving/copying/ref'ing the source as appropriate. Tests the\n+    /// guard, if any, and then branches to the arm. Returns the block\n+    /// for the case where the guard fails.\n+    ///\n+    /// Note: we check earlier that if there is a guard, there cannot\n+    /// be move bindings.  This isn't really important for the\n+    /// self-consistency of this fn, but the reason for it should be\n+    /// clear: after we've done the assignments, if there were move\n+    /// bindings, further tests would be a use-after-move (which would\n+    /// in turn be detected by the borrowck code that runs on the\n+    /// MIR).\n+    fn bind_and_guard_matched_candidate(&mut self,\n+                                        mut block: BasicBlock,\n+                                        var_extent: H::CodeExtent,\n+                                        candidate: Candidate<H>)\n+                                        -> Option<BasicBlock> {\n+        debug!(\"bind_and_guard_matched_candidate(block={:?}, var_extent={:?}, candidate={:?})\",\n+               block, var_extent, candidate);\n+\n+        debug_assert!(candidate.match_pairs.is_empty());\n+\n+        self.bind_matched_candidate(block, var_extent, candidate.bindings);\n+\n+        if let Some(guard) = candidate.guard {\n+            // the block to branch to if the guard fails; if there is no\n+            // guard, this block is simply unreachable\n+            let cond = unpack!(block = self.as_operand(block, guard));\n+            let otherwise = self.cfg.start_new_block();\n+            self.cfg.terminate(block, Terminator::If { cond: cond,\n+                                                       targets: [candidate.arm_block, otherwise]});\n+            Some(otherwise)\n+        } else {\n+            self.cfg.terminate(block, Terminator::Goto { target: candidate.arm_block });\n+            None\n+        }\n+    }\n+\n+    fn bind_matched_candidate(&mut self,\n+                              block: BasicBlock,\n+                              var_extent: H::CodeExtent,\n+                              bindings: Vec<Binding<H>>) {\n+        debug!(\"bind_matched_candidate(block={:?}, var_extent={:?}, bindings={:?})\",\n+               block, var_extent, bindings);\n+\n+        // Assign each of the bindings. This may trigger moves out of the candidate.\n+        for binding in bindings {\n+            // Create a variable for the `var_id` being bound. In the\n+            // case where there are multiple patterns for a single\n+            // arm, it may already exist.\n+            let var_index = if !self.var_indices.contains_key(&binding.var_id) {\n+                self.declare_binding(var_extent,\n+                                     binding.mutability,\n+                                     binding.name,\n+                                     binding.var_id,\n+                                     binding.var_ty,\n+                                     binding.span)\n+            } else {\n+                self.var_indices[&binding.var_id]\n+            };\n+\n+            let rvalue = match binding.binding_mode {\n+                BindingMode::ByValue =>\n+                    Rvalue::Use(Operand::Consume(binding.source)),\n+                BindingMode::ByRef(region, borrow_kind) =>\n+                    Rvalue::Ref(region, borrow_kind, binding.source),\n+            };\n+\n+            self.cfg.push_assign(block, binding.span, &Lvalue::Var(var_index), rvalue);\n+        }\n+    }\n+\n+    fn declare_binding(&mut self,\n+                       var_extent: H::CodeExtent,\n+                       mutability: Mutability,\n+                       name: H::Ident,\n+                       var_id: H::VarId,\n+                       var_ty: H::Ty,\n+                       span: H::Span)\n+                       -> u32\n+    {\n+        debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, var_extent={:?}, span={:?})\",\n+               var_id, name, var_ty, var_extent, span);\n+\n+        let index = self.var_decls.len();\n+        self.var_decls.push(VarDecl::<H> {\n+            mutability: mutability,\n+            name: name,\n+            ty: var_ty.clone(),\n+        });\n+        let index = index as u32;\n+        self.schedule_drop(span, var_extent, DropKind::Deep, &Lvalue::Var(index), var_ty);\n+        self.var_indices.insert(var_id, index);\n+\n+        debug!(\"declare_binding: index={:?}\", index);\n+\n+        index\n+    }\n+}\n+"}, {"sha": "f15b2ed5d4e59a57c423179fb28d577a549aada2", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Simplifying Candidates\n+//!\n+//! *Simplifying* a match pair `lvalue @ pattern` means breaking it down\n+//! into bindings or other, simpler match pairs. For example:\n+//!\n+//! - `lvalue @ (P1, P2)` can be simplified to `[lvalue.0 @ P1, lvalue.1 @ P2]`\n+//! - `lvalue @ x` can be simplified to `[]` by binding `x` to `lvalue`\n+//!\n+//! The `simplify_candidate` routine just repeatedly applies these\n+//! sort of simplifications until there is nothing left to\n+//! simplify. Match pairs cannot be simplified if they require some\n+//! sort of test: for example, testing which variant an enum is, or\n+//! testing a value against a constant.\n+\n+use build::{BlockAnd, Builder};\n+use build::matches::{Binding, MatchPair, Candidate};\n+use hair::*;\n+use repr::*;\n+\n+use std::mem;\n+\n+impl<H:Hair> Builder<H> {\n+    pub fn simplify_candidate(&mut self,\n+                              mut block: BasicBlock,\n+                              candidate: &mut Candidate<H>)\n+                              -> BlockAnd<()>\n+    {\n+        // repeatedly simplify match pairs until fixed point is reached\n+        loop {\n+            let match_pairs = mem::replace(&mut candidate.match_pairs, vec![]);\n+            let mut progress = match_pairs.len(); // count how many were simplified\n+            for match_pair in match_pairs {\n+                match self.simplify_match_pair(block, match_pair, candidate) {\n+                    Ok(b) => { block = b; }\n+                    Err(match_pair) => {\n+                        candidate.match_pairs.push(match_pair);\n+                        progress -= 1; // this one was not simplified\n+                    }\n+                }\n+            }\n+            if progress == 0 {\n+                return block.unit(); // if we were not able to simplify any, done.\n+            }\n+        }\n+    }\n+\n+    /// Tries to simplify `match_pair`, returning true if\n+    /// successful. If successful, new match pairs and bindings will\n+    /// have been pushed into the candidate. On failure (if false is\n+    /// returned), no changes are made to candidate.\n+    fn simplify_match_pair(&mut self,\n+                           mut block: BasicBlock,\n+                           match_pair: MatchPair<H>,\n+                           candidate: &mut Candidate<H>)\n+                           -> Result<BasicBlock, MatchPair<H>> // returns Err() if cannot simplify\n+    {\n+        match match_pair.pattern.kind {\n+            PatternKind::Wild(..) => {\n+                // nothing left to do\n+                Ok(block)\n+            }\n+\n+            PatternKind::Binding { name, mutability, mode, var, ty, subpattern } => {\n+                candidate.bindings.push(Binding {\n+                    name: name,\n+                    mutability: mutability,\n+                    span: match_pair.pattern.span,\n+                    source: match_pair.lvalue.clone(),\n+                    var_id: var,\n+                    var_ty: ty,\n+                    binding_mode: mode,\n+                });\n+\n+                if let Some(subpattern) = subpattern {\n+                    // this is the `x @ P` case; have to keep matching against `P` now\n+                    let subpattern = self.hir.mirror(subpattern);\n+                    candidate.match_pairs.push(MatchPair::new(match_pair.lvalue, subpattern));\n+                }\n+\n+                Ok(block)\n+            }\n+\n+            PatternKind::Constant { .. } => {\n+                // FIXME normalize patterns when possible\n+                Err(match_pair)\n+            }\n+\n+            PatternKind::Array { prefix, slice, suffix } => {\n+                unpack!(block = self.prefix_suffix_slice(&mut candidate.match_pairs,\n+                                                         block,\n+                                                         match_pair.lvalue.clone(),\n+                                                         prefix,\n+                                                         slice,\n+                                                         suffix));\n+                Ok(block)\n+            }\n+\n+            PatternKind::Slice { .. } |\n+            PatternKind::Range { .. } |\n+            PatternKind::Variant { .. } => {\n+                // cannot simplify, test is required\n+                Err(match_pair)\n+            }\n+\n+            PatternKind::Leaf { subpatterns } => {\n+                // tuple struct, match subpats (if any)\n+                candidate.match_pairs.extend(\n+                    self.field_match_pairs(match_pair.lvalue, subpatterns));\n+                Ok(block)\n+            }\n+\n+            PatternKind::Deref { subpattern } => {\n+                let lvalue = match_pair.lvalue.deref();\n+                let subpattern = self.hir.mirror(subpattern);\n+                candidate.match_pairs.push(MatchPair::new(lvalue, subpattern));\n+                Ok(block)\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "2d0a6e61beb2819954f8aa1e5f572611cce7633b", "filename": "src/librustc_mir/build/matches/test.rs", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,347 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Testing candidates\n+//\n+// After candidates have been simplified, the only match pairs that\n+// remain are those that require some sort of test. The functions here\n+// identify what tests are needed, perform the tests, and then filter\n+// the candidates based on the result.\n+\n+use build::{BlockAnd, Builder};\n+use build::matches::{Candidate, MatchPair, Test, TestKind};\n+use hair::*;\n+use repr::*;\n+\n+impl<H:Hair> Builder<H> {\n+    /// Identifies what test is needed to decide if `match_pair` is applicable.\n+    ///\n+    /// It is a bug to call this with a simplifyable pattern.\n+    pub fn test(&mut self, match_pair: &MatchPair<H>) -> Test<H> {\n+        match match_pair.pattern.kind {\n+            PatternKind::Variant { ref adt_def, variant_index: _, subpatterns: _ } => {\n+                Test {\n+                    span: match_pair.pattern.span,\n+                    kind: TestKind::Switch { adt_def: adt_def.clone() },\n+                }\n+            }\n+\n+            PatternKind::Constant { ref expr } => {\n+                let expr = self.as_constant(expr.clone());\n+                Test {\n+                    span: match_pair.pattern.span,\n+                    kind: TestKind::Eq { value: expr, ty: match_pair.pattern.ty.clone() },\n+                }\n+            }\n+\n+            PatternKind::Range { ref lo, ref hi } => {\n+                let lo = self.as_constant(lo.clone());\n+                let hi = self.as_constant(hi.clone());\n+                Test {\n+                    span: match_pair.pattern.span,\n+                    kind: TestKind::Range { lo: lo, hi: hi, ty: match_pair.pattern.ty.clone() },\n+                }\n+            }\n+\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+                let len = prefix.len() + suffix.len();\n+                let op = if slice.is_some() {BinOp::Ge} else {BinOp::Eq};\n+                Test {\n+                    span: match_pair.pattern.span,\n+                    kind: TestKind::Len { len: len, op: op },\n+                }\n+            }\n+\n+            PatternKind::Array { .. } |\n+            PatternKind::Wild |\n+            PatternKind::Binding { .. } |\n+            PatternKind::Leaf { .. } |\n+            PatternKind::Deref { .. } => {\n+                self.error_simplifyable(match_pair)\n+            }\n+        }\n+    }\n+\n+    /// Generates the code to perform a test.\n+    pub fn perform_test(&mut self,\n+                        block: BasicBlock,\n+                        lvalue: &Lvalue<H>,\n+                        test: &Test<H>)\n+                        -> Vec<BasicBlock> {\n+        match test.kind.clone() {\n+            TestKind::Switch { adt_def } => {\n+                let num_enum_variants = self.hir.num_variants(adt_def);\n+                let target_blocks: Vec<_> =\n+                    (0..num_enum_variants).map(|_| self.cfg.start_new_block())\n+                                          .collect();\n+                self.cfg.terminate(block, Terminator::Switch {\n+                    discr: lvalue.clone(),\n+                    targets: target_blocks.clone()\n+                });\n+                target_blocks\n+            }\n+\n+            TestKind::Eq { value, ty } => {\n+                // call PartialEq::eq(discrim, constant)\n+                let constant = self.push_constant(block, test.span, ty.clone(), value);\n+                let item_ref = self.hir.partial_eq(ty);\n+                self.call_comparison_fn(block, test.span, item_ref, lvalue.clone(), constant)\n+            }\n+\n+            TestKind::Range { lo, hi, ty } => {\n+                // Test `v` by computing `PartialOrd::le(lo, v) && PartialOrd::le(v, hi)`.\n+                let lo = self.push_constant(block, test.span, ty.clone(), lo);\n+                let hi = self.push_constant(block, test.span, ty.clone(), hi);\n+                let item_ref = self.hir.partial_le(ty);\n+\n+                let lo_blocks =\n+                    self.call_comparison_fn(block, test.span, item_ref.clone(), lo, lvalue.clone());\n+\n+                let hi_blocks =\n+                    self.call_comparison_fn(lo_blocks[0], test.span, item_ref, lvalue.clone(), hi);\n+\n+                let failure = self.cfg.start_new_block();\n+                self.cfg.terminate(lo_blocks[1], Terminator::Goto { target: failure });\n+                self.cfg.terminate(hi_blocks[1], Terminator::Goto { target: failure });\n+\n+                vec![hi_blocks[0], failure]\n+            }\n+\n+            TestKind::Len { len, op } => {\n+                let (usize_ty, bool_ty) = (self.hir.usize_ty(), self.hir.bool_ty());\n+                let (actual, result) = (self.temp(usize_ty), self.temp(bool_ty));\n+\n+                // actual = len(lvalue)\n+                self.cfg.push_assign(\n+                    block, test.span,\n+                    &actual, Rvalue::Len(lvalue.clone()));\n+\n+                // expected = <N>\n+                let expected =\n+                    self.push_usize(block, test.span, len);\n+\n+                // result = actual == expected OR result = actual < expected\n+                self.cfg.push_assign(\n+                    block, test.span,\n+                    &result, Rvalue::BinaryOp(op,\n+                                              Operand::Consume(actual),\n+                                              Operand::Consume(expected)));\n+\n+                // branch based on result\n+                let target_blocks: Vec<_> = vec![self.cfg.start_new_block(),\n+                                                 self.cfg.start_new_block()];\n+                self.cfg.terminate(block, Terminator::If {\n+                    cond: Operand::Consume(result),\n+                    targets: [target_blocks[0], target_blocks[1]]\n+                });\n+\n+                target_blocks\n+            }\n+        }\n+    }\n+\n+    fn call_comparison_fn(&mut self,\n+                          block: BasicBlock,\n+                          span: H::Span,\n+                          item_ref: ItemRef<H>,\n+                          lvalue1: Lvalue<H>,\n+                          lvalue2: Lvalue<H>)\n+                          -> Vec<BasicBlock> {\n+        let target_blocks = vec![self.cfg.start_new_block(),\n+                                 self.cfg.start_new_block()];\n+\n+        let bool_ty = self.hir.bool_ty();\n+        let eq_result = self.temp(bool_ty);\n+        let func = self.push_item_ref(block, span, item_ref);\n+        let call_blocks = [self.cfg.start_new_block(), self.diverge_cleanup()];\n+        self.cfg.terminate(block,\n+                           Terminator::Call {\n+                               data: CallData {\n+                                   destination: eq_result.clone(),\n+                                   func: func,\n+                                   args: vec![lvalue1, lvalue2],\n+                               },\n+                               targets: call_blocks,\n+                           });\n+\n+        // check the result\n+        self.cfg.terminate(call_blocks[0],\n+                           Terminator::If {\n+                               cond: Operand::Consume(eq_result),\n+                               targets: [target_blocks[0], target_blocks[1]]\n+                           });\n+\n+        target_blocks\n+    }\n+\n+    /// Given a candidate and the outcome of a test we have performed,\n+    /// transforms the candidate into a new candidate that reflects\n+    /// further tests still needed. Returns `None` if this candidate\n+    /// has now been ruled out.\n+    ///\n+    /// For example, if a candidate included the patterns `[x.0 @\n+    /// Ok(P1), x.1 @ 22]`, and we did a switch test on `x.0` and\n+    /// found the variant `Err` (as indicated by the `test_outcome`\n+    /// parameter), we would return `None`. But if the test_outcome\n+    /// were `Ok`, we would return `Some([x.0.downcast<Ok>.0 @ P1, x.1\n+    /// @ 22])`.\n+    pub fn candidate_under_assumption(&mut self,\n+                                      mut block: BasicBlock,\n+                                      test_lvalue: &Lvalue<H>,\n+                                      test_kind: &TestKind<H>,\n+                                      test_outcome: usize,\n+                                      candidate: &Candidate<H>)\n+                                      -> BlockAnd<Option<Candidate<H>>> {\n+        let candidate = candidate.clone();\n+        let match_pairs = candidate.match_pairs;\n+        let result = unpack!(block = self.match_pairs_under_assumption(block,\n+                                                                       test_lvalue,\n+                                                                       test_kind,\n+                                                                       test_outcome,\n+                                                                       match_pairs));\n+        block.and(match result {\n+            Some(match_pairs) => Some(Candidate { match_pairs: match_pairs, ..candidate }),\n+            None => None\n+        })\n+    }\n+\n+    /// Helper for candidate_under_assumption that does the actual\n+    /// work of transforming the list of match pairs.\n+    fn match_pairs_under_assumption(&mut self,\n+                                    mut block: BasicBlock,\n+                                    test_lvalue: &Lvalue<H>,\n+                                    test_kind: &TestKind<H>,\n+                                    test_outcome: usize,\n+                                    match_pairs: Vec<MatchPair<H>>)\n+                                    -> BlockAnd<Option<Vec<MatchPair<H>>>> {\n+        let mut result = vec![];\n+\n+        for match_pair in match_pairs {\n+            // if the match pair is testing a different lvalue, it\n+            // is unaffected by this test.\n+            if match_pair.lvalue != *test_lvalue {\n+                result.push(match_pair);\n+                continue;\n+            }\n+\n+            let desired_test = self.test(&match_pair);\n+\n+            if *test_kind != desired_test.kind {\n+                // if the match pair wants to (e.g.) test for\n+                // equality against some particular constant, but\n+                // we did a switch, then we can't say whether it\n+                // matches or not, so we still have to include it\n+                // as a possibility.\n+                //\n+                // For example, we have a constant `FOO:\n+                // Option<i32> = Some(22)`, and `match_pair` is `x\n+                // @ FOO`, but we did a switch on the variant\n+                // (`Some` vs `None`). (OK, in principle this\n+                // could tell us something, but we're not that\n+                // smart yet to actually dig into the constant\n+                // itself)\n+                result.push(match_pair);\n+                continue;\n+            }\n+\n+            let opt_consequent_match_pairs =\n+                unpack!(block = self.consequent_match_pairs_under_assumption(block,\n+                                                                             match_pair,\n+                                                                             test_outcome));\n+            match opt_consequent_match_pairs {\n+                None => {\n+                    // Right kind of test, but wrong outcome. That\n+                    // means this **entire candidate** is\n+                    // inapplicable, since the candidate is only\n+                    // applicable if all of its match-pairs apply (and\n+                    // this one doesn't).\n+                    return block.and(None);\n+                }\n+\n+                Some(consequent_match_pairs) => {\n+                    // Test passed; add any new patterns we have to test to the final result.\n+                    result.extend(consequent_match_pairs)\n+                }\n+            }\n+        }\n+        block.and(Some(result))\n+    }\n+\n+    /// Identifies what test is needed to decide if `match_pair` is applicable.\n+    ///\n+    /// It is a bug to call this with a simplifyable pattern.\n+    pub fn consequent_match_pairs_under_assumption(&mut self,\n+                                                   mut block: BasicBlock,\n+                                                   match_pair: MatchPair<H>,\n+                                                   test_outcome: usize)\n+                                                   -> BlockAnd<Option<Vec<MatchPair<H>>>> {\n+        match match_pair.pattern.kind {\n+            PatternKind::Variant { adt_def, variant_index, subpatterns } => {\n+                if test_outcome != variant_index {\n+                    return block.and(None);\n+                }\n+\n+                let elem = ProjectionElem::Downcast(adt_def, variant_index);\n+                let downcast_lvalue = match_pair.lvalue.clone().elem(elem);\n+                let consequent_match_pairs =\n+                    subpatterns.into_iter()\n+                               .map(|subpattern| {\n+                                   let lvalue =\n+                                       downcast_lvalue.clone().field(\n+                                           subpattern.field);\n+                                   self.match_pair(lvalue, subpattern.pattern)\n+                               })\n+                               .collect();\n+                block.and(Some(consequent_match_pairs))\n+            }\n+\n+            PatternKind::Constant { .. } |\n+            PatternKind::Range { .. } => {\n+                // these are boolean tests: if we are on the 0th\n+                // successor, then they passed, and otherwise they\n+                // failed, but there are never any more tests to come.\n+                if test_outcome == 0 {\n+                    block.and(Some(vec![]))\n+                } else {\n+                    block.and(None)\n+                }\n+            }\n+\n+            PatternKind::Slice { prefix, slice, suffix } => {\n+                if test_outcome == 0 {\n+                    let mut consequent_match_pairs = vec![];\n+                    unpack!(block = self.prefix_suffix_slice(&mut consequent_match_pairs,\n+                                                             block,\n+                                                             match_pair.lvalue,\n+                                                             prefix,\n+                                                             slice,\n+                                                             suffix));\n+                    block.and(Some(consequent_match_pairs))\n+                } else {\n+                    block.and(None)\n+                }\n+            }\n+\n+            PatternKind::Array { .. } |\n+            PatternKind::Wild |\n+            PatternKind::Binding { .. } |\n+            PatternKind::Leaf { .. } |\n+            PatternKind::Deref { .. } => {\n+                self.error_simplifyable(&match_pair)\n+            }\n+        }\n+    }\n+\n+    fn error_simplifyable(&mut self, match_pair: &MatchPair<H>) -> ! {\n+        self.hir.span_bug(\n+            match_pair.pattern.span,\n+            &format!(\"simplifyable pattern found: {:?}\", match_pair.pattern))\n+    }\n+}"}, {"sha": "65a08868666352ad48ee5bfc1fc4380d973575e0", "filename": "src/librustc_mir/build/matches/util.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use build::{BlockAnd, Builder};\n+use build::matches::MatchPair;\n+use hair::*;\n+use repr::*;\n+use std::u32;\n+\n+impl<H:Hair> Builder<H> {\n+    pub fn field_match_pairs(&mut self,\n+                             lvalue: Lvalue<H>,\n+                             subpatterns: Vec<FieldPatternRef<H>>)\n+                             -> Vec<MatchPair<H>> {\n+        subpatterns.into_iter()\n+                   .map(|fieldpat| {\n+                       let lvalue = lvalue.clone().field(fieldpat.field);\n+                       self.match_pair(lvalue, fieldpat.pattern)\n+                   })\n+                   .collect()\n+    }\n+\n+    pub fn match_pair(&mut self, lvalue: Lvalue<H>, pattern: PatternRef<H>) -> MatchPair<H> {\n+        let pattern = self.hir.mirror(pattern);\n+        MatchPair::new(lvalue, pattern)\n+    }\n+\n+    /// When processing an array/slice pattern like `lv @ [x, y, ..s, z]`,\n+    /// this function converts the prefix (`x`, `y`) and suffix (`z`) into\n+    /// distinct match pairs:\n+    ///\n+    ///     lv[0 of 3] @ x  // see ProjectionElem::ConstantIndex (and its Debug impl)\n+    ///     lv[1 of 3] @ y  // to explain the `[x of y]` notation\n+    ///     lv[-1 of 3] @ z\n+    ///\n+    /// If a slice like `s` is present, then the function also creates\n+    /// a temporary like:\n+    ///\n+    ///     tmp0 = lv[2..-1] // using the special Rvalue::Slice\n+    ///\n+    /// and creates a match pair `tmp0 @ s`\n+    pub fn prefix_suffix_slice(&mut self,\n+                               match_pairs: &mut Vec<MatchPair<H>>,\n+                               block: BasicBlock,\n+                               lvalue: Lvalue<H>,\n+                               prefix: Vec<PatternRef<H>>,\n+                               opt_slice: Option<PatternRef<H>>,\n+                               suffix: Vec<PatternRef<H>>)\n+                               -> BlockAnd<()>\n+    {\n+        // If there is a `..P` pattern, create a temporary `t0` for\n+        // the slice and then a match pair `t0 @ P`:\n+        if let Some(slice) = opt_slice {\n+            let slice = self.hir.mirror(slice);\n+            let prefix_len = prefix.len();\n+            let suffix_len = suffix.len();\n+            let rvalue = Rvalue::Slice { input: lvalue.clone(),\n+                                         from_start: prefix_len,\n+                                         from_end: suffix_len };\n+            let temp = self.temp(slice.ty.clone()); // no need to schedule drop, temp is always copy\n+            self.cfg.push_assign(block, slice.span, &temp, rvalue);\n+            match_pairs.push(MatchPair::new(temp, slice));\n+        }\n+\n+        self.prefix_suffix(match_pairs, lvalue, prefix, suffix);\n+\n+        block.unit()\n+    }\n+\n+    /// Helper for `prefix_suffix_slice` which just processes the prefix and suffix.\n+    fn prefix_suffix(&mut self,\n+                     match_pairs: &mut Vec<MatchPair<H>>,\n+                     lvalue: Lvalue<H>,\n+                     prefix: Vec<PatternRef<H>>,\n+                     suffix: Vec<PatternRef<H>>)\n+    {\n+        let min_length = prefix.len() + suffix.len();\n+        assert!(min_length < u32::MAX as usize);\n+        let min_length = min_length as u32;\n+\n+        let prefix_pairs: Vec<_> =\n+            prefix.into_iter()\n+                  .enumerate()\n+                  .map(|(idx, subpattern)| {\n+                      let elem = ProjectionElem::ConstantIndex {\n+                          offset: idx as u32,\n+                          min_length: min_length,\n+                          from_end: false,\n+                      };\n+                      let lvalue = lvalue.clone().elem(elem);\n+                      self.match_pair(lvalue, subpattern)\n+                  })\n+                  .collect();\n+\n+        let suffix_pairs: Vec<_> =\n+            suffix.into_iter()\n+                  .rev()\n+                  .enumerate()\n+                  .map(|(idx, subpattern)| {\n+                      let elem = ProjectionElem::ConstantIndex {\n+                          offset: (idx+1) as u32,\n+                          min_length: min_length,\n+                          from_end: true,\n+                      };\n+                      let lvalue = lvalue.clone().elem(elem);\n+                      self.match_pair(lvalue, subpattern)\n+                  })\n+                  .collect();\n+\n+        match_pairs.extend(prefix_pairs.into_iter().chain(suffix_pairs));\n+    }\n+}\n+\n+impl<H:Hair> MatchPair<H> {\n+    pub fn new(lvalue: Lvalue<H>, pattern: Pattern<H>) -> MatchPair<H> {\n+        MatchPair { lvalue: lvalue, pattern: pattern }\n+    }\n+}"}, {"sha": "1c44988e4b407060071d2fcaa5db68dba4949158", "filename": "src/librustc_mir/build/misc.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Miscellaneous builder routines that are not specific to building any particular\n+//! kind of thing.\n+\n+use build::Builder;\n+use hair::*;\n+use repr::*;\n+\n+use std::u32;\n+\n+impl<H:Hair> Builder<H> {\n+    /// Add a new temporary value of type `ty` storing the result of\n+    /// evaluating `expr`.\n+    ///\n+    /// NB: **No cleanup is scheduled for this temporary.** You should\n+    /// call `schedule_drop` once the temporary is initialized.\n+    pub fn temp(&mut self, ty: H::Ty) -> Lvalue<H> {\n+        let index = self.temp_decls.len();\n+        self.temp_decls.push(TempDecl { ty: ty });\n+        assert!(index < (u32::MAX) as usize);\n+        let lvalue = Lvalue::Temp(index as u32);\n+        debug!(\"temp: created temp {:?} with type {:?}\",\n+               lvalue, self.temp_decls.last().unwrap().ty);\n+        lvalue\n+    }\n+\n+    pub fn push_constant(&mut self,\n+                         block: BasicBlock,\n+                         span: H::Span,\n+                         ty: H::Ty,\n+                         constant: Constant<H>)\n+                         -> Lvalue<H> {\n+        let temp = self.temp(ty);\n+        self.cfg.push_assign_constant(block, span, &temp, constant);\n+        temp\n+    }\n+\n+    pub fn push_usize(&mut self,\n+                      block: BasicBlock,\n+                      span: H::Span,\n+                      value: usize)\n+                      -> Lvalue<H> {\n+        let usize_ty = self.hir.usize_ty();\n+        let temp = self.temp(usize_ty);\n+        self.cfg.push_assign_constant(\n+            block, span, &temp,\n+            Constant {\n+                span: span,\n+                kind: ConstantKind::Literal(Literal::Uint { bits: IntegralBits::BSize,\n+                                                            value: value as u64 }),\n+            });\n+        temp\n+    }\n+\n+    pub fn push_item_ref(&mut self,\n+                         block: BasicBlock,\n+                         span: H::Span,\n+                         item_ref: ItemRef<H>)\n+                         -> Lvalue<H> {\n+        let constant = Constant {\n+            span: span,\n+            kind: ConstantKind::Literal(Literal::Item {\n+                def_id: item_ref.def_id,\n+                substs: item_ref.substs\n+            })\n+        };\n+        self.push_constant(block, span, item_ref.ty, constant)\n+    }\n+}"}, {"sha": "9d00044c6609daca916698aae5944cd1ab9e4f32", "filename": "src/librustc_mir/build/mod.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,174 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hair::{self, Hair};\n+use rustc_data_structures::fnv::FnvHashMap;\n+use repr::*;\n+\n+struct Builder<H:Hair> {\n+    hir: H,\n+    extents: FnvHashMap<H::CodeExtent, Vec<GraphExtent>>,\n+    cfg: CFG<H>,\n+    scopes: Vec<scope::Scope<H>>,\n+    loop_scopes: Vec<scope::LoopScope<H>>,\n+    unit_temp: Lvalue<H>,\n+    var_decls: Vec<VarDecl<H>>,\n+    var_indices: FnvHashMap<H::VarId, u32>,\n+    temp_decls: Vec<TempDecl<H>>,\n+}\n+\n+struct CFG<H:Hair> {\n+    basic_blocks: Vec<BasicBlockData<H>>\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// The `BlockAnd` \"monad\" packages up the new basic block along with a\n+// produced value (sometimes just unit, of course). The `unpack!`\n+// macro (and methods below) makes working with `BlockAnd` much more\n+// convenient.\n+\n+#[must_use] // if you don't use one of these results, you're leaving a dangling edge\n+struct BlockAnd<T>(BasicBlock, T);\n+\n+impl BasicBlock {\n+    fn and<T>(self, v: T) -> BlockAnd<T> {\n+        BlockAnd(self, v)\n+    }\n+\n+    fn unit(self) -> BlockAnd<()> {\n+        BlockAnd(self, ())\n+    }\n+}\n+\n+/// Update a block pointer and return the value.\n+/// Use it like `let x = unpack!(block = self.foo(block, foo))`.\n+macro_rules! unpack {\n+    ($x:ident = $c:expr) => {\n+        {\n+            let BlockAnd(b, v) = $c;\n+            $x = b;\n+            v\n+        }\n+    };\n+\n+    ($c:expr) => {\n+        {\n+            let BlockAnd(b, ()) = $c;\n+            b\n+        }\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// construct() -- the main entry point for building MIR for a function\n+\n+pub fn construct<H:Hair>(mut hir: H,\n+                        _span: H::Span,\n+                        implicit_arguments: Vec<H::Ty>,\n+                        explicit_arguments: Vec<(H::Ty, H::Pattern)>,\n+                        argument_extent: H::CodeExtent,\n+                        ast_block: H::Block)\n+                        -> Mir<H> {\n+    let cfg = CFG { basic_blocks: vec![] };\n+\n+    // it's handy to have a temporary of type `()` sometimes, so make\n+    // one from the start and keep it available\n+    let temp_decls = vec![TempDecl::<H> { ty: hir.unit_ty() }];\n+    let unit_temp = Lvalue::Temp(0);\n+\n+    let mut builder = Builder {\n+        hir: hir,\n+        cfg: cfg,\n+        extents: FnvHashMap(),\n+        scopes: vec![],\n+        loop_scopes: vec![],\n+        temp_decls: temp_decls,\n+        var_decls: vec![],\n+        var_indices: FnvHashMap(),\n+        unit_temp: unit_temp,\n+    };\n+\n+    assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n+    assert_eq!(builder.cfg.start_new_block(), END_BLOCK);\n+    assert_eq!(builder.cfg.start_new_block(), DIVERGE_BLOCK);\n+\n+    let mut block = START_BLOCK;\n+    let arg_decls = unpack!(block = builder.args_and_body(block,\n+                                                          implicit_arguments,\n+                                                          explicit_arguments,\n+                                                          argument_extent,\n+                                                          ast_block));\n+\n+    builder.cfg.terminate(block, Terminator::Goto { target: END_BLOCK });\n+    builder.cfg.terminate(END_BLOCK, Terminator::Return);\n+\n+    Mir  {\n+        basic_blocks: builder.cfg.basic_blocks,\n+        extents: builder.extents,\n+        var_decls: builder.var_decls,\n+        arg_decls: arg_decls,\n+        temp_decls: builder.temp_decls,\n+    }\n+}\n+\n+impl<H:Hair> Builder<H> {\n+    fn args_and_body(&mut self,\n+                     mut block: BasicBlock,\n+                     implicit_arguments: Vec<H::Ty>,\n+                     explicit_arguments: Vec<(H::Ty, H::Pattern)>,\n+                     argument_extent: H::CodeExtent,\n+                     ast_block: H::Block)\n+                     -> BlockAnd<Vec<ArgDecl<H>>>\n+    {\n+        self.in_scope(argument_extent, block, |this| {\n+            let arg_decls = {\n+                let implicit_arg_decls = implicit_arguments.into_iter()\n+                                                           .map(|ty| ArgDecl { ty: ty });\n+\n+                // to start, translate the argument patterns and collect the\n+                // argument types.\n+                let explicit_arg_decls =\n+                    explicit_arguments\n+                    .into_iter()\n+                    .enumerate()\n+                    .map(|(index, (ty, pattern))| {\n+                        let lvalue = Lvalue::Arg(index as u32);\n+                        unpack!(block = this.lvalue_into_pattern(block,\n+                                                                 argument_extent,\n+                                                                 hair::PatternRef::Hair(pattern),\n+                                                                 &lvalue));\n+                        ArgDecl { ty: ty }\n+                    });\n+\n+                implicit_arg_decls.chain(explicit_arg_decls).collect()\n+            };\n+\n+            // start the first basic block and translate the body\n+            unpack!(block = this.ast_block(&Lvalue::ReturnPointer, block, ast_block));\n+\n+            block.and(arg_decls)\n+        })\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Builder methods are broken up into modules, depending on what kind\n+// of thing is being translated. Note that they use the `unpack` macro\n+// above extensively.\n+\n+mod block;\n+mod cfg;\n+mod expr;\n+mod into;\n+mod matches;\n+mod misc;\n+mod scope;\n+mod stmt;\n+"}, {"sha": "87a4731ac74be68bd4fc519715af80250813c109", "filename": "src/librustc_mir/build/scope.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,304 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+Managing the scope stack. The scopes are tied to lexical scopes, so as\n+we descend the HAIR, we push a scope on the stack, translate ite\n+contents, and then pop it off. Every scope is named by a\n+`H::CodeExtent`.\n+\n+### SEME Regions\n+\n+When pushing a new scope, we record the current point in the graph (a\n+basic block); this marks the entry to the scope. We then generate more\n+stuff in the control-flow graph. Whenever the scope is exited, either\n+via a `break` or `return` or just by fallthrough, that marks an exit\n+from the scope. Each lexical scope thus corresponds to a single-entry,\n+multiple-exit (SEME) region in the control-flow graph.\n+\n+For now, we keep a mapping from each `H::CodeExtent` to its\n+corresponding SEME region for later reference (see caveat in next\n+paragraph). This is because region scopes are tied to\n+them. Eventually, when we shift to non-lexical lifetimes, three should\n+be no need to remember this mapping.\n+\n+There is one additional wrinkle, actually, that I wanted to hide from\n+you but duty compels me to mention. In the course of translating\n+matches, it sometimes happen that certain code (namely guards) gets\n+executed multiple times. This means that the scope lexical scope may\n+in fact correspond to multiple, disjoint SEME regions. So in fact our\n+mapping os from one scope to a vector of SEME regions.\n+\n+### Drops\n+\n+The primary purpose for scopes is to insert drops: while translating\n+the contents, we also accumulate lvalues that need to be dropped upon\n+exit from each scope. This is done by calling `schedule_drop`. Once a\n+drop is scheduled, whenever we branch out we will insert drops of all\n+those lvalues onto the outgoing edge. Note that we don't know the full\n+set of scheduled drops up front, and so whenever we exit from the\n+scope we only drop the values scheduled thus far. For example, consider\n+the scope S corresponding to this loop:\n+\n+```\n+loop {\n+    let x = ...;\n+    if cond { break; }\n+    let y = ...;\n+}\n+```\n+\n+When processing the `let x`, we will add one drop to the scope for\n+`x`.  The break will then insert a drop for `x`. When we process `let\n+y`, we will add another drop (in fact, to a subscope, but let's ignore\n+that for now); any later drops would also drop `y`.\n+\n+### Early exit\n+\n+There are numerous \"normal\" ways to early exit a scope: `break`,\n+`continue`, `return` (panics are handled separately). Whenever an\n+early exit occurs, the method `exit_scope` is called. It is given the\n+current point in execution where the early exit occurs, as well as the\n+scope you want to branch to (note that all early exits from to some\n+other enclosing scope). `exit_scope` will record thid exit point and\n+also add all drops.\n+\n+Panics are handled in a similar fashion, except that a panic always\n+returns out to the `DIVERGE_BLOCK`. To trigger a panic, simply call\n+`panic(p)` with the current point `p`. Or else you can call\n+`diverge_cleanup`, which will produce a block that you can branch to\n+which does the appropriate cleanup and then diverges. `panic(p)`\n+simply calls `diverge_cleanup()` and adds an edge from `p` to the\n+result.\n+\n+### Loop scopes\n+\n+In addition to the normal scope stack, we track a loop scope stack\n+that contains only loops. It tracks where a `break` and `continue`\n+should go to.\n+\n+*/\n+\n+use build::{BlockAnd, Builder, CFG};\n+use hair::Hair;\n+use repr::*;\n+\n+pub struct Scope<H:Hair> {\n+    extent: H::CodeExtent,\n+    exits: Vec<ExecutionPoint>,\n+    drops: Vec<(DropKind, H::Span, Lvalue<H>)>,\n+    cached_block: Option<BasicBlock>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct LoopScope<H:Hair> {\n+    pub extent: H::CodeExtent,      // extent of the loop\n+    pub continue_block: BasicBlock, // where to go on a `loop`\n+    pub break_block: BasicBlock,    // where to go on a `break\n+}\n+\n+impl<H:Hair> Builder<H> {\n+    /// Start a loop scope, which tracks where `continue` and `break`\n+    /// should branch to. See module comment for more details.\n+    pub fn in_loop_scope<F,R>(&mut self,\n+                              loop_block: BasicBlock,\n+                              break_block: BasicBlock,\n+                              f: F)\n+                              -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<H>) -> BlockAnd<R>\n+    {\n+        let extent = self.extent_of_innermost_scope().unwrap();\n+        let loop_scope = LoopScope::<H> { extent: extent.clone(),\n+                                          continue_block: loop_block,\n+                                          break_block: break_block };\n+        self.loop_scopes.push(loop_scope);\n+        let r = f(self);\n+        assert!(self.loop_scopes.pop().unwrap().extent == extent);\n+        r\n+    }\n+\n+    /// Start a scope. The closure `f` should translate the contents\n+    /// of the scope. See module comment for more details.\n+    pub fn in_scope<F,R>(&mut self,\n+                         extent: H::CodeExtent,\n+                         block: BasicBlock,\n+                         f: F)\n+                         -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<H>) -> BlockAnd<R>\n+    {\n+        debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n+\n+        let start_point = self.cfg.end_point(block);\n+\n+        // push scope, execute `f`, then pop scope again\n+        self.scopes.push(Scope {\n+            extent: extent.clone(),\n+            drops: vec![],\n+            exits: vec![],\n+            cached_block: None,\n+        });\n+        let BlockAnd(fallthrough_block, rv) = f(self);\n+        let mut scope = self.scopes.pop().unwrap();\n+\n+        // add in any drops needed on the fallthrough path (any other\n+        // exiting paths, such as those that arise from `break`, will\n+        // have drops already)\n+        for (kind, span, lvalue) in scope.drops {\n+            self.cfg.push_drop(fallthrough_block, span, kind, &lvalue);\n+        }\n+\n+        // add the implicit fallthrough edge\n+        scope.exits.push(self.cfg.end_point(fallthrough_block));\n+\n+        // compute the extent from start to finish and store it in the graph\n+        let graph_extent = self.graph_extent(start_point, scope.exits);\n+        self.extents.entry(extent)\n+                    .or_insert(vec![])\n+                    .push(graph_extent);\n+\n+        debug!(\"in_scope: exiting extent={:?} fallthrough_block={:?}\", extent, fallthrough_block);\n+        fallthrough_block.and(rv)\n+    }\n+\n+    /// Creates a graph extent (SEME region) from an entry point and\n+    /// exit points.\n+    fn graph_extent(&self, entry: ExecutionPoint, exits: Vec<ExecutionPoint>) -> GraphExtent {\n+        if exits.len() == 1 && entry.block == exits[0].block {\n+            GraphExtent { entry: entry, exit: GraphExtentExit::Statement(exits[0].statement) }\n+        } else {\n+            GraphExtent { entry: entry, exit: GraphExtentExit::Points(exits) }\n+        }\n+    }\n+\n+    /// Finds the loop scope for a given label. This is used for\n+    /// resolving `break` and `continue`.\n+    pub fn find_loop_scope(&mut self,\n+                           span: H::Span,\n+                           label: Option<H::CodeExtent>)\n+                           -> LoopScope<H> {\n+        let loop_scope =\n+            match label {\n+                None => {\n+                    // no label? return the innermost loop scope\n+                    self.loop_scopes.iter()\n+                                    .rev()\n+                                    .next()\n+                }\n+                Some(label) => {\n+                    // otherwise, find the loop-scope with the correct id\n+                    self.loop_scopes.iter()\n+                                    .rev()\n+                                    .filter(|loop_scope| loop_scope.extent == label)\n+                                    .next()\n+                }\n+            };\n+\n+        match loop_scope {\n+            Some(loop_scope) => loop_scope.clone(),\n+            None => self.hir.span_bug(span, \"no enclosing loop scope found?\")\n+        }\n+    }\n+\n+    /// Branch out of `block` to `target`, exiting all scopes up to\n+    /// and including `extent`.  This will insert whatever drops are\n+    /// needed, as well as tracking this exit for the SEME region. See\n+    /// module comment for details.\n+    pub fn exit_scope(&mut self,\n+                      span: H::Span,\n+                      extent: H::CodeExtent,\n+                      block: BasicBlock,\n+                      target: BasicBlock) {\n+        let popped_scopes =\n+            match self.scopes.iter().rev().position(|scope| scope.extent == extent) {\n+                Some(p) => p + 1,\n+                None => self.hir.span_bug(span, &format!(\"extent {:?} does not enclose\",\n+                                                              extent)),\n+            };\n+\n+        for scope in self.scopes.iter_mut().rev().take(popped_scopes) {\n+            for &(kind, drop_span, ref lvalue) in &scope.drops {\n+                self.cfg.push_drop(block, drop_span, kind, lvalue);\n+            }\n+\n+            scope.exits.push(self.cfg.end_point(block));\n+        }\n+\n+        self.cfg.terminate(block, Terminator::Goto { target: target });\n+    }\n+\n+    /// Creates a path that performs all required cleanup for\n+    /// unwinding. This path terminates in DIVERGE. Returns the start\n+    /// of the path. See module comment for more details.\n+    pub fn diverge_cleanup(&mut self) -> BasicBlock {\n+        diverge_cleanup_helper(&mut self.cfg, &mut self.scopes)\n+    }\n+\n+    /// Create diverge cleanup and branch to it from `block`.\n+    pub fn panic(&mut self, block: BasicBlock) {\n+        let cleanup = self.diverge_cleanup();\n+        self.cfg.terminate(block, Terminator::Panic { target: cleanup });\n+    }\n+\n+    /// Indicates that `lvalue` should be dropped on exit from\n+    /// `extent`.\n+    pub fn schedule_drop(&mut self,\n+                         span: H::Span,\n+                         extent: H::CodeExtent,\n+                         kind: DropKind,\n+                         lvalue: &Lvalue<H>,\n+                         lvalue_ty: H::Ty)\n+    {\n+        if self.hir.needs_drop(lvalue_ty, span) {\n+            match self.scopes.iter_mut().rev().find(|s| s.extent == extent) {\n+                Some(scope) => {\n+                    scope.drops.push((kind, span, lvalue.clone()));\n+                    scope.cached_block = None;\n+                }\n+                None => self.hir.span_bug(span, &format!(\"extent {:?} not in scope to drop {:?}\",\n+                                                         extent, lvalue)),\n+            }\n+        }\n+    }\n+\n+    pub fn extent_of_innermost_scope(&self) -> Option<H::CodeExtent> {\n+        self.scopes.last().map(|scope| scope.extent)\n+    }\n+\n+    pub fn extent_of_outermost_scope(&self) -> Option<H::CodeExtent> {\n+        self.scopes.first().map(|scope| scope.extent)\n+    }\n+}\n+\n+fn diverge_cleanup_helper<H:Hair>(cfg: &mut CFG<H>,\n+                                 scopes: &mut [Scope<H>])\n+                                 -> BasicBlock {\n+    let len = scopes.len();\n+\n+    if len == 0 {\n+        return DIVERGE_BLOCK;\n+    }\n+\n+    let (remaining, scope) = scopes.split_at_mut(len - 1);\n+    let scope = &mut scope[0];\n+\n+    if let Some(b) = scope.cached_block {\n+        return b;\n+    }\n+\n+    let block = cfg.start_new_block();\n+    for &(kind, span, ref lvalue) in &scope.drops {\n+        cfg.push_drop(block, span, kind, lvalue);\n+    }\n+    scope.cached_block = Some(block);\n+\n+    let remaining_cleanup_block = diverge_cleanup_helper(cfg, remaining);\n+    cfg.terminate(block, Terminator::Goto { target: remaining_cleanup_block });\n+    block\n+}"}, {"sha": "9d5a83154d4028d37760b15604a743ed035f69f5", "filename": "src/librustc_mir/build/stmt.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use build::{BlockAnd, Builder};\n+use hair::*;\n+use repr::*;\n+\n+impl<H:Hair> Builder<H> {\n+    pub fn stmts(&mut self, mut block: BasicBlock, stmts: Vec<StmtRef<H>>) -> BlockAnd<()> {\n+        for stmt in stmts {\n+            unpack!(block = self.stmt(block, stmt));\n+        }\n+        block.unit()\n+    }\n+\n+    pub fn stmt(&mut self, mut block: BasicBlock, stmt: StmtRef<H>) -> BlockAnd<()> {\n+        let this = self;\n+        let Stmt { span, kind } = this.hir.mirror(stmt);\n+        match kind {\n+            StmtKind::Let { remainder_scope,\n+                            init_scope,\n+                            pattern,\n+                            initializer: Some(initializer),\n+                            stmts } => {\n+                this.in_scope(remainder_scope, block, |this| {\n+                    unpack!(block = this.in_scope(init_scope, block, |this| {\n+                        this.expr_into_pattern(block, remainder_scope, pattern, initializer)\n+                    }));\n+                    this.stmts(block, stmts)\n+                })\n+            }\n+\n+            StmtKind::Let { remainder_scope, init_scope, pattern, initializer: None, stmts } => {\n+                this.in_scope(remainder_scope, block, |this| {\n+                    unpack!(block = this.in_scope(init_scope, block, |this| {\n+                        this.declare_uninitialized_variables(remainder_scope, pattern);\n+                        block.unit()\n+                    }));\n+                    this.stmts(block, stmts)\n+                })\n+            }\n+\n+            StmtKind::Expr { scope, expr } => {\n+                this.in_scope(scope, block, |this| {\n+                    let expr = this.hir.mirror(expr);\n+                    let temp = this.temp(expr.ty.clone());\n+                    unpack!(block = this.into(&temp, block, expr));\n+                    this.cfg.push_drop(block, span, DropKind::Deep, &temp);\n+                    block.unit()\n+                })\n+            }\n+        }\n+    }\n+}"}, {"sha": "8e608de024e84657101888a0bd91a918d9485d45", "filename": "src/librustc_mir/dump.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdump.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,225 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An experimental pass that scources for `#[rustc_mir]` attributes,\n+//! builds the resulting MIR, and dumps it out into a file for inspection.\n+//!\n+//! The attribute formats that are currently accepted are:\n+//!\n+//! - `#[rustc_mir(graphviz=\"file.gv\")]`\n+//! - `#[rustc_mir(pretty=\"file.mir\")]`\n+\n+extern crate syntax;\n+extern crate rustc;\n+extern crate rustc_front;\n+\n+use build;\n+use dot;\n+use repr::Mir;\n+use std::fs::File;\n+use tcx::{PatNode, Cx};\n+\n+use self::rustc::middle::def_id::DefId;\n+use self::rustc::middle::infer;\n+use self::rustc::middle::region::CodeExtentData;\n+use self::rustc::middle::ty::{self, Ty};\n+use self::rustc::util::common::ErrorReported;\n+use self::rustc_front::hir;\n+use self::rustc_front::attr::{AttrMetaMethods};\n+use self::rustc_front::visit;\n+use self::syntax::ast;\n+use self::syntax::codemap::Span;\n+\n+pub fn dump_crate(tcx: &ty::ctxt) {\n+    let mut dump = OuterDump { tcx: tcx };\n+    visit::walk_crate(&mut dump, tcx.map.krate());\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// OuterDump -- walks a crate, looking for fn items and methods to build MIR from\n+\n+struct OuterDump<'a,'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+}\n+\n+impl<'a, 'tcx> OuterDump<'a, 'tcx> {\n+    fn visit_mir<OP>(&self, attributes: &'tcx [hir::Attribute], mut walk_op: OP)\n+        where OP: FnMut(&mut InnerDump<'a,'tcx>)\n+    {\n+        let mut built_mir = false;\n+\n+        for attr in attributes {\n+            if attr.check_name(\"rustc_mir\") {\n+                let mut closure_dump = InnerDump { tcx: self.tcx, attr: Some(attr) };\n+                walk_op(&mut closure_dump);\n+                built_mir = true;\n+            }\n+        }\n+\n+        let always_build_mir = self.tcx.sess.opts.always_build_mir;\n+        if !built_mir && always_build_mir {\n+            let mut closure_dump = InnerDump { tcx: self.tcx, attr: None };\n+            walk_op(&mut closure_dump);\n+        }\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> visit::Visitor<'tcx> for OuterDump<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        self.visit_mir(&item.attrs, |c| visit::walk_item(c, item));\n+        visit::walk_item(self, item);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        match trait_item.node {\n+            hir::MethodTraitItem(_, Some(_)) => {\n+                self.visit_mir(&trait_item.attrs, |c| visit::walk_trait_item(c, trait_item));\n+            }\n+            _ => { }\n+        }\n+        visit::walk_trait_item(self, trait_item);\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// InnerDump -- dumps MIR for a single fn and its contained closures\n+\n+struct InnerDump<'a,'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    attr: Option<&'a hir::Attribute>,\n+}\n+\n+impl<'a, 'tcx> visit::Visitor<'tcx> for InnerDump<'a,'tcx> {\n+    fn visit_item(&mut self, _: &'tcx hir::Item) {\n+        // ignore nested items; they need their own graphviz annotation\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fk: visit::FnKind<'tcx>,\n+                decl: &'tcx hir::FnDecl,\n+                body: &'tcx hir::Block,\n+                span: Span,\n+                id: ast::NodeId) {\n+        let (prefix, implicit_arg_tys) = match fk {\n+            visit::FnKind::Closure =>\n+                (format!(\"{}-\", id), vec![closure_self_ty(&self.tcx, id, body.id)]),\n+            _ =>\n+                (format!(\"\"), vec![]),\n+        };\n+\n+        let param_env =\n+            ty::ParameterEnvironment::for_item(self.tcx, id);\n+\n+        let infcx =\n+            infer::new_infer_ctxt(self.tcx,\n+                                  &self.tcx.tables,\n+                                  Some(param_env),\n+                                  true);\n+\n+        match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n+            Ok(mir) => {\n+                let meta_item_list =\n+                    self.attr.iter()\n+                             .flat_map(|a| a.meta_item_list())\n+                             .flat_map(|l| l.iter());\n+                for item in meta_item_list {\n+                    if item.check_name(\"graphviz\") {\n+                        match item.value_str() {\n+                            Some(s) => {\n+                                match\n+                                    File::create(format!(\"{}{}\", prefix, s))\n+                                    .and_then(|ref mut output| dot::render(&mir, output))\n+                                {\n+                                    Ok(()) => { }\n+                                    Err(e) => {\n+                                        self.tcx.sess.span_fatal(\n+                                            item.span,\n+                                            &format!(\"Error writing graphviz \\\n+                                                      results to `{}`: {}\",\n+                                                     s, e));\n+                                    }\n+                                }\n+                            }\n+                            None => {\n+                                self.tcx.sess.span_err(\n+                                    item.span,\n+                                    &format!(\"graphviz attribute requires a path\"));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            Err(ErrorReported) => { }\n+        }\n+\n+        visit::walk_fn(self, fk, decl, body, span);\n+    }\n+}\n+\n+fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n+                         implicit_arg_tys: Vec<Ty<'tcx>>,\n+                         fn_id: ast::NodeId,\n+                         span: Span,\n+                         decl: &'tcx hir::FnDecl,\n+                         body: &'tcx hir::Block)\n+                         -> Result<Mir<Cx<'a,'tcx>>, ErrorReported> {\n+    let arguments =\n+        decl.inputs\n+            .iter()\n+            .map(|arg| {\n+                let ty = cx.tcx.node_id_to_type(arg.id);\n+                (ty, PatNode::irrefutable(&arg.pat))\n+            })\n+            .collect();\n+\n+    let parameter_scope =\n+        cx.tcx.region_maps.lookup_code_extent(\n+            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.id });\n+    Ok(build::construct(cx,\n+                        span,\n+                        implicit_arg_tys,\n+                        arguments,\n+                        parameter_scope,\n+                        body))\n+}\n+\n+fn closure_self_ty<'a,'tcx>(tcx: &ty::ctxt<'tcx>,\n+                            closure_expr_id: ast::NodeId,\n+                            body_id: ast::NodeId)\n+                            -> Ty<'tcx>\n+{\n+    let closure_ty = tcx.node_id_to_type(closure_expr_id);\n+\n+    // We're just hard-coding the idea that the signature will be\n+    // &self or &mut self and hence will have a bound region with\n+    // number 0, hokey.\n+    let region =\n+        ty::Region::ReFree(\n+            ty::FreeRegion {\n+                scope: tcx.region_maps.item_extent(body_id),\n+                bound_region: ty::BoundRegion::BrAnon(0)\n+            });\n+    let region =\n+        tcx.mk_region(region);\n+\n+    match tcx.closure_kind(DefId::local(closure_expr_id)) {\n+        ty::ClosureKind::FnClosureKind =>\n+            tcx.mk_ref(region,\n+                       ty::TypeAndMut { ty: closure_ty,\n+                                        mutbl: hir::MutImmutable }),\n+        ty::ClosureKind::FnMutClosureKind =>\n+            tcx.mk_ref(region,\n+                       ty::TypeAndMut { ty: closure_ty,\n+                                        mutbl: hir::MutMutable }),\n+        ty::ClosureKind::FnOnceClosureKind =>\n+            closure_ty\n+    }\n+}"}, {"sha": "01ccf20ae06545ddf31f60f96f89f24f1cd89c15", "filename": "src/librustc_mir/graphviz/mod.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dot;\n+use hair::Hair;\n+use repr::*;\n+use std::borrow::IntoCow;\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub struct EdgeIndex {\n+    source: BasicBlock,\n+    target: BasicBlock,\n+    index: usize,\n+}\n+\n+impl<'a,H:Hair> dot::Labeller<'a, BasicBlock, EdgeIndex> for Mir<H> {\n+    fn graph_id(&'a self) -> dot::Id<'a> {\n+        dot::Id::new(\"Mir\").unwrap()\n+    }\n+\n+    fn node_id(&'a self, n: &BasicBlock) -> dot::Id<'a> {\n+        dot::Id::new(format!(\"BB{}\", n.index())).unwrap()\n+    }\n+\n+    fn node_shape(&'a self, _: &BasicBlock) -> Option<dot::LabelText<'a>> {\n+        Some(dot::LabelText::label(\"none\"))\n+    }\n+\n+    fn node_label(&'a self, &n: &BasicBlock) -> dot::LabelText<'a> {\n+        let mut buffer = String::new();\n+        buffer.push_str(\"<TABLE ALIGN=\\\"LEFT\\\">\");\n+\n+        buffer.push_str(\"<TR><TD>\");\n+        buffer.push_str(&format!(\"{:?}\", n));\n+        buffer.push_str(\"</TD></TR>\");\n+\n+        let data = self.basic_block_data(n);\n+        for statement in &data.statements {\n+            buffer.push_str(\"<TR><TD>\");\n+            buffer.push_str(&escape(format!(\"{:?}\", statement)));\n+            buffer.push_str(\"</TD></TR>\");\n+        }\n+\n+        buffer.push_str(\"<TR><TD>\");\n+        buffer.push_str(&escape(format!(\"{:?}\", &data.terminator)));\n+        buffer.push_str(\"</TD></TR>\");\n+\n+        buffer.push_str(\"</TABLE>\");\n+\n+        dot::LabelText::html(buffer)\n+    }\n+\n+    fn edge_label(&'a self, edge: &EdgeIndex) -> dot::LabelText<'a> {\n+        dot::LabelText::label(format!(\"{}\", edge.index))\n+    }\n+}\n+\n+impl<'a,H:Hair> dot::GraphWalk<'a, BasicBlock, EdgeIndex> for Mir<H> {\n+    fn nodes(&'a self) -> dot::Nodes<'a, BasicBlock> {\n+        self.all_basic_blocks().into_cow()\n+    }\n+\n+    fn edges(&'a self) -> dot::Edges<'a, EdgeIndex> {\n+        self.all_basic_blocks()\n+            .into_iter()\n+            .flat_map(|source| {\n+                self.basic_block_data(source).terminator\n+                                             .successors()\n+                                             .iter()\n+                                             .enumerate()\n+                                             .map(move |(index, &target)| {\n+                                                 EdgeIndex { source: source,\n+                                                             target: target,\n+                                                             index: index }\n+                                             })\n+            })\n+            .collect::<Vec<_>>()\n+            .into_cow()\n+    }\n+\n+    fn source(&'a self, edge: &EdgeIndex) -> BasicBlock {\n+        edge.source\n+    }\n+\n+    fn target(&'a self, edge: &EdgeIndex) -> BasicBlock {\n+        edge.target\n+    }\n+}\n+\n+fn escape(text: String) -> String {\n+    let text = dot::escape_html(&text);\n+    let text = all_to_subscript(\"Temp\", text);\n+    let text = all_to_subscript(\"Var\", text);\n+    let text = all_to_subscript(\"Arg\", text);\n+    let text = all_to_subscript(\"BB\", text);\n+    text\n+}\n+\n+/// A call like `all_to_subscript(\"Temp\", \"Temp(123)\")` will convert\n+/// to `Temp\u2081\u2082\u2083`.\n+fn all_to_subscript(header: &str, mut text: String) -> String {\n+    let mut offset = 0;\n+    while offset < text.len() {\n+        if let Some(text1) = to_subscript1(header, &text, &mut offset) {\n+            text = text1;\n+        }\n+    }\n+    return text;\n+\n+    /// Looks for `Foo(\\d*)` where `header==\"Foo\"` and replaces the `\\d` with subscripts.\n+    /// Updates `offset` to point to the next location where we might want to search.\n+    /// Returns an updated string if changes were made, else None.\n+    fn to_subscript1(header: &str, text: &str, offset: &mut usize) -> Option<String> {\n+        let a = match text[*offset..].find(header) {\n+            None => { *offset = text.len(); return None; }\n+            Some(a) => a + *offset,\n+        };\n+\n+        // Example:\n+        //\n+        // header: \"Foo\"\n+        // text:   ....Foo(123)...\n+        //             ^  ^\n+        //             a  b\n+\n+        let b = a + header.len();\n+        *offset = b;\n+\n+        let mut chars = text[b..].chars();\n+        if Some('(') != chars.next() {\n+            return None;\n+        }\n+\n+        let mut result = String::new();\n+        result.push_str(&text[..b]);\n+\n+        while let Some(c) = chars.next() {\n+            if c == ')' { break; }\n+            if !c.is_digit(10) { return None; }\n+\n+            // 0x208 is _0 in unicode, 0x209 is _1, etc\n+            const SUBSCRIPTS: &'static str = \"\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089\";\n+            let n = (c as usize) - ('0' as usize);\n+            result.extend(SUBSCRIPTS.chars().skip(n).take(1));\n+        }\n+\n+        result.extend(chars);\n+        return Some(result);\n+    }\n+}"}, {"sha": "c63a0348337129a568a7f05e1906c5f7dfd63e2e", "filename": "src/librustc_mir/hair.rs", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fhair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Fhair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,382 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The MIR is translated from some high-level abstract IR\n+//! (HAIR). This section defines the HAIR along with a trait for\n+//! accessing it. The intention is to allow MIR construction to be\n+//! unit-tested and separated from the Rust source and compiler data\n+//! structures.\n+\n+use repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp};\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+\n+pub trait Hair: Sized+Debug+Clone+Eq+Hash { // (*)\n+\n+    // (*) the `Sized` and Debug` bounds are the only ones that really\n+    // make sense.  The rest are just there so that we can\n+    // `#[derive(Clone)]` on things that are parameterized over\n+    // `H:HAIR`. It's kind of lame.\n+\n+    type VarId: Copy+Debug+Eq+Hash;                              // e.g., NodeId for a variable\n+    type DefId: Copy+Debug+Eq+Hash;                              // e.g., DefId\n+    type AdtDef: Copy+Debug+Eq+Hash;                             // e.g., AdtDef<'tcx>\n+    type Name: Copy+Debug+Eq+Hash;                               // e.g., ast::Name\n+    type Ident: Copy+Debug+Eq+Hash;                              // e.g., ast::Ident\n+    type InternedString: Clone+Debug+Eq+Hash;                    // e.g., InternedString\n+    type Bytes: Clone+Debug+Eq+Hash;                             // e.g., Rc<Vec<u8>>\n+    type Span: Copy+Debug+Eq;                                    // e.g., syntax::codemap::Span\n+    type Projection: Clone+Debug+Eq;                             // e.g., ty::ProjectionTy<'tcx>\n+    type Substs: Clone+Debug+Eq;                                 // e.g., substs::Substs<'tcx>\n+    type ClosureSubsts: Clone+Debug+Eq;                          // e.g., ty::ClosureSubsts<'tcx>\n+    type Ty: Clone+Debug+Eq;                                     // e.g., ty::Ty<'tcx>\n+    type Region: Copy+Debug;                                     // e.g., ty::Region\n+    type CodeExtent: Copy+Debug+Hash+Eq;                         // e.g., region::CodeExtent\n+    type Pattern: Clone+Debug+Mirror<Self,Output=Pattern<Self>>; // e.g., &P<ast::Pat>\n+    type Expr: Clone+Debug+Mirror<Self,Output=Expr<Self>>;       // e.g., &P<ast::Expr>\n+    type Stmt: Clone+Debug+Mirror<Self,Output=Stmt<Self>>;       // e.g., &P<ast::Stmt>\n+    type Block: Clone+Debug+Mirror<Self,Output=Block<Self>>;     // e.g., &P<ast::Block>\n+    type InlineAsm: Clone+Debug+Eq+Hash;                         // e.g., ast::InlineAsm\n+\n+    /// Normalizes `ast` into the appropriate `mirror` type.\n+    fn mirror<M:Mirror<Self>>(&mut self, ast: M) -> M::Output {\n+        ast.make_mirror(self)\n+    }\n+\n+    /// Returns the unit type `()`\n+    fn unit_ty(&mut self) -> Self::Ty;\n+\n+    /// Returns the type `usize`.\n+    fn usize_ty(&mut self) -> Self::Ty;\n+\n+    /// Returns the type `bool`.\n+    fn bool_ty(&mut self) -> Self::Ty;\n+\n+    /// Returns a reference to `PartialEq::<T,T>::eq`\n+    fn partial_eq(&mut self, ty: Self::Ty) -> ItemRef<Self>;\n+\n+    /// Returns a reference to `PartialOrd::<T,T>::le`\n+    fn partial_le(&mut self, ty: Self::Ty) -> ItemRef<Self>;\n+\n+    /// Returns the number of variants for the given enum\n+    fn num_variants(&mut self, adt: Self::AdtDef) -> usize;\n+\n+    fn fields(&mut self, adt: Self::AdtDef, variant_index: usize) -> Vec<Field<Self>>;\n+\n+    /// true if a value of type `ty` (may) need to be dropped; this\n+    /// may return false even for non-Copy types if there is no\n+    /// destructor to execute. If correct result is not known, may be\n+    /// approximated by returning `true`; this will result in more\n+    /// drops but not incorrect code.\n+    fn needs_drop(&mut self, ty: Self::Ty, span: Self::Span) -> bool;\n+\n+    /// Report an internal inconsistency.\n+    fn span_bug(&mut self, span: Self::Span, message: &str) -> !;\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ItemRef<H:Hair> {\n+    pub ty: H::Ty,\n+    pub def_id: H::DefId,\n+    pub substs: H::Substs,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Block<H:Hair> {\n+    pub extent: H::CodeExtent,\n+    pub span: H::Span,\n+    pub stmts: Vec<StmtRef<H>>,\n+    pub expr: Option<ExprRef<H>>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum StmtRef<H:Hair> {\n+    Hair(H::Stmt),\n+    Mirror(Box<Stmt<H>>),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Stmt<H:Hair> {\n+    pub span: H::Span,\n+    pub kind: StmtKind<H>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum StmtKind<H:Hair> {\n+    Expr {\n+        /// scope for this statement; may be used as lifetime of temporaries\n+        scope: H::CodeExtent,\n+\n+        /// expression being evaluated in this statement\n+        expr: ExprRef<H>\n+    },\n+\n+    Let {\n+        /// scope for variables bound in this let; covers this and\n+        /// remaining statements in block\n+        remainder_scope: H::CodeExtent,\n+\n+        /// scope for the initialization itself; might be used as\n+        /// lifetime of temporaries\n+        init_scope: H::CodeExtent,\n+\n+        /// let <PAT> = ...\n+        pattern: PatternRef<H>,\n+\n+        /// let pat = <INIT> ...\n+        initializer: Option<ExprRef<H>>,\n+\n+        /// let pat = init; <STMTS>\n+        stmts: Vec<StmtRef<H>>\n+    },\n+}\n+\n+// The Hair trait implementor translates their expressions (`H::Expr`)\n+// into instances of this `Expr` enum. This translation can be done\n+// basically as lazilly or as eagerly as desired: every recursive\n+// reference to an expression in this enum is an `ExprRef<H>`, which\n+// may in turn be another instance of this enum (boxed), or else an\n+// untranslated `H::Expr`. Note that instances of `Expr` are very\n+// shortlived. They are created by `Hair::to_expr`, analyzed and\n+// converted into MIR, and then discarded.\n+//\n+// If you compare `Expr` to the full compiler AST, you will see it is\n+// a good bit simpler. In fact, a number of the more straight-forward\n+// MIR simplifications are already done in the impl of `Hair`. For\n+// example, method calls and overloaded operators are absent: they are\n+// expected to be converted into `Expr::Call` instances.\n+#[derive(Clone, Debug)]\n+pub struct Expr<H:Hair> {\n+    // type of this expression\n+    pub ty: H::Ty,\n+\n+    // lifetime of this expression if it should be spilled into a\n+    // temporary; should be None only if in a constant context\n+    pub temp_lifetime: Option<H::CodeExtent>,\n+\n+    // span of the expression in the source\n+    pub span: H::Span,\n+\n+    // kind of expression\n+    pub kind: ExprKind<H>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum ExprKind<H:Hair> {\n+    Scope { extent: H::CodeExtent, value: ExprRef<H> },\n+    Paren { arg: ExprRef<H> }, // ugh. should be able to remove this!\n+    Box { place: Option<ExprRef<H>>, value: ExprRef<H> },\n+    Call { fun: ExprRef<H>, args: Vec<ExprRef<H>> },\n+    Deref { arg: ExprRef<H> }, // NOT overloaded!\n+    Binary { op: BinOp, lhs: ExprRef<H>, rhs: ExprRef<H> }, // NOT overloaded!\n+    LogicalOp { op: LogicalOp, lhs: ExprRef<H>, rhs: ExprRef<H> },\n+    Unary { op: UnOp, arg: ExprRef<H> }, // NOT overloaded!\n+    Cast { source: ExprRef<H> },\n+    ReifyFnPointer { source: ExprRef<H> },\n+    UnsafeFnPointer { source: ExprRef<H> },\n+    Unsize { source: ExprRef<H> },\n+    If { condition: ExprRef<H>, then: ExprRef<H>, otherwise: Option<ExprRef<H>> },\n+    Loop { condition: Option<ExprRef<H>>, body: ExprRef<H>, },\n+    Match { discriminant: ExprRef<H>, arms: Vec<Arm<H>> },\n+    Block { body: H::Block },\n+    Assign { lhs: ExprRef<H>, rhs: ExprRef<H> },\n+    AssignOp { op: BinOp, lhs: ExprRef<H>, rhs: ExprRef<H> },\n+    Field { lhs: ExprRef<H>, name: Field<H> },\n+    Index { lhs: ExprRef<H>, index: ExprRef<H> },\n+    VarRef { id: H::VarId },\n+    SelfRef, // first argument, used for self in a closure\n+    StaticRef { id: H::DefId },\n+    Borrow { region: H::Region, borrow_kind: BorrowKind, arg: ExprRef<H> },\n+    Break { label: Option<H::CodeExtent> },\n+    Continue { label: Option<H::CodeExtent> },\n+    Return { value: Option<ExprRef<H>> },\n+    Repeat { value: ExprRef<H>, count: ExprRef<H> },\n+    Vec { fields: Vec<ExprRef<H>> },\n+    Tuple { fields: Vec<ExprRef<H>> },\n+    Adt { adt_def: H::AdtDef,\n+          variant_index: usize,\n+          substs: H::Substs,\n+          fields: Vec<FieldExprRef<H>>,\n+          base: Option<ExprRef<H>> },\n+    Closure { closure_id: H::DefId, substs: H::ClosureSubsts,\n+              upvars: Vec<ExprRef<H>> },\n+    Literal { literal: Literal<H> },\n+    InlineAsm { asm: H::InlineAsm },\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum ExprRef<H:Hair> {\n+    Hair(H::Expr),\n+    Mirror(Box<Expr<H>>),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct FieldExprRef<H:Hair> {\n+    pub name: Field<H>,\n+    pub expr: ExprRef<H>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Arm<H:Hair> {\n+    pub patterns: Vec<PatternRef<H>>,\n+    pub guard: Option<ExprRef<H>>,\n+    pub body: ExprRef<H>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Pattern<H:Hair> {\n+    pub ty: H::Ty,\n+    pub span: H::Span,\n+    pub kind: PatternKind<H>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum LogicalOp {\n+    And,\n+    Or\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum PatternKind<H:Hair> {\n+    Wild,\n+\n+    // x, ref x, x @ P, etc\n+    Binding { mutability: Mutability,\n+              name: H::Ident,\n+              mode: BindingMode<H>,\n+              var: H::VarId,\n+              ty: H::Ty,\n+              subpattern: Option<PatternRef<H>> },\n+\n+    // Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n+    Variant { adt_def: H::AdtDef, variant_index: usize, subpatterns: Vec<FieldPatternRef<H>> },\n+\n+    // (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n+    Leaf { subpatterns: Vec<FieldPatternRef<H>> },\n+\n+    Deref { subpattern: PatternRef<H> }, // box P, &P, &mut P, etc\n+\n+    Constant { expr: ExprRef<H> },\n+\n+    Range { lo: ExprRef<H>, hi: ExprRef<H> },\n+\n+    // matches against a slice, checking the length and extracting elements\n+    Slice { prefix: Vec<PatternRef<H>>,\n+            slice: Option<PatternRef<H>>,\n+            suffix: Vec<PatternRef<H>> },\n+\n+    // fixed match against an array, irrefutable\n+    Array { prefix: Vec<PatternRef<H>>,\n+            slice: Option<PatternRef<H>>,\n+            suffix: Vec<PatternRef<H>> },\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum BindingMode<H:Hair> {\n+    ByValue,\n+    ByRef(H::Region, BorrowKind),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum PatternRef<H:Hair> {\n+    Hair(H::Pattern),\n+    Mirror(Box<Pattern<H>>),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct FieldPatternRef<H:Hair> {\n+    pub field: Field<H>,\n+    pub pattern: PatternRef<H>,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// The Mirror trait\n+\n+/// \"Mirroring\" is the process of converting from a Hair type into one\n+/// of the types in this file. For example, the mirror of a `H::Expr`\n+/// is an `Expr<H>`. Mirroring is the point at which the actual IR is\n+/// converting into the more idealized representation described in\n+/// this file. Mirroring is gradual: when you mirror an outer\n+/// expression like `e1 + e2`, the references to the inner expressions\n+/// `e1` and `e2` are `ExprRef<H>` instances, and they may or may not\n+/// be eagerly mirrored.  This allows a single AST node from the\n+/// compiler to expand into one or more Hair nodes, which lets the Hair\n+/// nodes be simpler.\n+pub trait Mirror<H:Hair> {\n+    type Output;\n+\n+    fn make_mirror(self, hir: &mut H) -> Self::Output;\n+}\n+\n+impl<H:Hair> Mirror<H> for Expr<H> {\n+    type Output = Expr<H>;\n+\n+    fn make_mirror(self, _: &mut H) -> Expr<H> {\n+        self\n+    }\n+}\n+\n+impl<H:Hair> Mirror<H> for ExprRef<H> {\n+    type Output = Expr<H>;\n+\n+    fn make_mirror(self, hir: &mut H) -> Expr<H> {\n+        match self {\n+            ExprRef::Hair(h) => h.make_mirror(hir),\n+            ExprRef::Mirror(m) => *m,\n+        }\n+    }\n+}\n+\n+impl<H:Hair> Mirror<H> for Stmt<H> {\n+    type Output = Stmt<H>;\n+\n+    fn make_mirror(self, _: &mut H) -> Stmt<H> {\n+        self\n+    }\n+}\n+\n+impl<H:Hair> Mirror<H> for StmtRef<H> {\n+    type Output = Stmt<H>;\n+\n+    fn make_mirror(self, hir: &mut H) -> Stmt<H> {\n+        match self {\n+            StmtRef::Hair(h) => h.make_mirror(hir),\n+            StmtRef::Mirror(m) => *m,\n+        }\n+    }\n+}\n+\n+impl<H:Hair> Mirror<H> for Pattern<H> {\n+    type Output = Pattern<H>;\n+\n+    fn make_mirror(self, _: &mut H) -> Pattern<H> {\n+        self\n+    }\n+}\n+\n+impl<H:Hair> Mirror<H> for PatternRef<H> {\n+    type Output = Pattern<H>;\n+\n+    fn make_mirror(self, hir: &mut H) -> Pattern<H> {\n+        match self {\n+            PatternRef::Hair(h) => h.make_mirror(hir),\n+            PatternRef::Mirror(m) => *m,\n+        }\n+    }\n+}\n+\n+impl<H:Hair> Mirror<H> for Block<H> {\n+    type Output = Block<H>;\n+\n+    fn make_mirror(self, _: &mut H) -> Block<H> {\n+        self\n+    }\n+}\n+"}, {"sha": "ebec1609959ddb3d1f5f9beba14d39f72bd5a880", "filename": "src/librustc_mir/lib.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Rust MIR: a lowered representation of Rust. Also: an experiment!\n+\n+*/\n+\n+#![crate_name = \"rustc_mir\"]\n+#![crate_type = \"rlib\"]\n+#![crate_type = \"dylib\"]\n+\n+#![feature(ref_slice)]\n+#![feature(rustc_private)]\n+#![feature(into_cow)]\n+\n+#[macro_use] extern crate log;\n+extern crate graphviz as dot;\n+extern crate rustc_data_structures;\n+\n+pub mod build;\n+pub mod dump;\n+pub mod hair;\n+pub mod repr;\n+mod graphviz;\n+mod tcx;"}, {"sha": "a54942144c5ec8494dc18b23eb0f0169a1e31241", "filename": "src/librustc_mir/repr.rs", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Frepr.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,689 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hair::Hair;\n+use rustc_data_structures::fnv::FnvHashMap;\n+use std::fmt::{Debug, Formatter, Error};\n+use std::slice;\n+use std::u32;\n+\n+/// Lowered representation of a single function.\n+pub struct Mir<H:Hair> {\n+    pub basic_blocks: Vec<BasicBlockData<H>>,\n+\n+    // for every node id\n+    pub extents: FnvHashMap<H::CodeExtent, Vec<GraphExtent>>,\n+\n+    pub var_decls: Vec<VarDecl<H>>,\n+    pub arg_decls: Vec<ArgDecl<H>>,\n+    pub temp_decls: Vec<TempDecl<H>>,\n+}\n+\n+/// where execution begins\n+pub const START_BLOCK: BasicBlock = BasicBlock(0);\n+\n+/// where execution ends, on normal return\n+pub const END_BLOCK: BasicBlock = BasicBlock(1);\n+\n+/// where execution ends, on panic\n+pub const DIVERGE_BLOCK: BasicBlock = BasicBlock(2);\n+\n+impl<H:Hair> Mir<H> {\n+    pub fn all_basic_blocks(&self) -> Vec<BasicBlock> {\n+        (0..self.basic_blocks.len())\n+            .map(|i| BasicBlock::new(i))\n+            .collect()\n+    }\n+\n+    pub fn basic_block_data(&self, bb: BasicBlock) -> &BasicBlockData<H> {\n+        &self.basic_blocks[bb.index()]\n+    }\n+\n+    pub fn basic_block_data_mut(&mut self, bb: BasicBlock) -> &mut BasicBlockData<H> {\n+        &mut self.basic_blocks[bb.index()]\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Mutability and borrow kinds\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Mutability {\n+    Mut,\n+    Not,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum BorrowKind {\n+    /// Data must be immutable and is aliasable.\n+    Shared,\n+\n+    /// Data must be immutable but not aliasable.  This kind of borrow\n+    /// cannot currently be expressed by the user and is used only in\n+    /// implicit closure bindings. It is needed when you the closure\n+    /// is borrowing or mutating a mutable referent, e.g.:\n+    ///\n+    ///    let x: &mut isize = ...;\n+    ///    let y = || *x += 5;\n+    ///\n+    /// If we were to try to translate this closure into a more explicit\n+    /// form, we'd encounter an error with the code as written:\n+    ///\n+    ///    struct Env { x: & &mut isize }\n+    ///    let x: &mut isize = ...;\n+    ///    let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n+    ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    ///\n+    /// This is then illegal because you cannot mutate a `&mut` found\n+    /// in an aliasable location. To solve, you'd have to translate with\n+    /// an `&mut` borrow:\n+    ///\n+    ///    struct Env { x: & &mut isize }\n+    ///    let x: &mut isize = ...;\n+    ///    let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n+    ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    ///\n+    /// Now the assignment to `**env.x` is legal, but creating a\n+    /// mutable pointer to `x` is not because `x` is not mutable. We\n+    /// could fix this by declaring `x` as `let mut x`. This is ok in\n+    /// user code, if awkward, but extra weird for closures, since the\n+    /// borrow is hidden.\n+    ///\n+    /// So we introduce a \"unique imm\" borrow -- the referent is\n+    /// immutable, but not aliasable. This solves the problem. For\n+    /// simplicity, we don't give users the way to express this\n+    /// borrow, it's just used when translating closures.\n+    Unique,\n+\n+    /// Data is mutable and not aliasable.\n+    Mut\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Variables and temps\n+\n+// A \"variable\" is a binding declared by the user as part of the fn\n+// decl, a let, etc.\n+pub struct VarDecl<H:Hair> {\n+    pub mutability: Mutability,\n+    pub name: H::Ident,\n+    pub ty: H::Ty,\n+}\n+\n+// A \"temp\" is a temporary that we place on the stack. They are\n+// anonymous, always mutable, and have only a type.\n+pub struct TempDecl<H:Hair> {\n+    pub ty: H::Ty,\n+}\n+\n+// A \"arg\" is one of the function's formal arguments. These are\n+// anonymous and distinct from the bindings that the user declares.\n+//\n+// For example, in this function:\n+//\n+// ```\n+// fn foo((x, y): (i32, u32)) { ... }\n+// ```\n+//\n+// there is only one argument, of type `(i32, u32)`, but two bindings\n+// (`x` and `y`).\n+pub struct ArgDecl<H:Hair> {\n+    pub ty: H::Ty,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Graph extents\n+\n+/// A moment in the flow of execution. It corresponds to a point in\n+/// between two statements:\n+///\n+///    BB[block]:\n+///                          <--- if statement == 0\n+///        STMT[0]\n+///                          <--- if statement == 1\n+///        STMT[1]\n+///        ...\n+///                          <--- if statement == n-1\n+///        STMT[n-1]\n+///                          <--- if statement == n\n+///\n+/// where the block has `n` statements.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct ExecutionPoint {\n+    pub block: BasicBlock,\n+    pub statement: u32,\n+}\n+\n+/// A single-entry-multiple-exit region in the graph. We build one of\n+/// these for every node-id during MIR construction. By construction\n+/// we are assured that the entry dominates all points within, and\n+/// that, for every interior point X, it is postdominated by some exit.\n+pub struct GraphExtent {\n+    pub entry: ExecutionPoint,\n+    pub exit: GraphExtentExit,\n+}\n+\n+pub enum GraphExtentExit {\n+    /// `Statement(X)`: a very common special case covering a span\n+    /// that is local to a single block. It starts at the entry point\n+    /// and extends until the start of statement `X` (non-inclusive).\n+    Statement(u32),\n+\n+    /// The more general case where the exits are a set of points.\n+    Points(Vec<ExecutionPoint>),\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// BasicBlock\n+\n+/// The index of a particular basic block. The index is into the `basic_blocks`\n+/// list of the `Mir`.\n+///\n+/// (We use a `u32` internally just to save memory.)\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub struct BasicBlock(u32);\n+\n+impl BasicBlock {\n+    pub fn new(index: usize) -> BasicBlock {\n+        assert!(index < (u32::MAX as usize));\n+        BasicBlock(index as u32)\n+    }\n+\n+    /// Extract the index.\n+    pub fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+impl Debug for BasicBlock {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        write!(fmt, \"BB({})\", self.0)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// BasicBlock and Terminator\n+\n+#[derive(Debug)]\n+pub struct BasicBlockData<H:Hair> {\n+    pub statements: Vec<Statement<H>>,\n+    pub terminator: Terminator<H>,\n+}\n+\n+pub enum Terminator<H:Hair> {\n+    /// block should have one successor in the graph; we jump there\n+    Goto { target: BasicBlock },\n+\n+    /// block should initiate unwinding; should be one successor\n+    /// that does cleanup and branches to DIVERGE_BLOCK\n+    Panic { target: BasicBlock },\n+\n+    /// jump to branch 0 if this lvalue evaluates to true\n+    If { cond: Operand<H>, targets: [BasicBlock; 2] },\n+\n+    /// lvalue evaluates to some enum; jump depending on the branch\n+    Switch { discr: Lvalue<H>, targets: Vec<BasicBlock> },\n+\n+    /// Indicates that the last statement in the block panics, aborts,\n+    /// etc. No successors. This terminator appears on exactly one\n+    /// basic block which we create in advance. However, during\n+    /// construction, we use this value as a sentinel for \"terminator\n+    /// not yet assigned\", and assert at the end that only the\n+    /// well-known diverging block actually diverges.\n+    Diverge,\n+\n+    /// Indicates a normal return. The ReturnPointer lvalue should\n+    /// have been filled in by now. This should only occur in the\n+    /// `END_BLOCK`.\n+    Return,\n+\n+    /// block ends with a call; it should have two successors. The\n+    /// first successor indicates normal return. The second indicates\n+    /// unwinding.\n+    Call { data: CallData<H>, targets: [BasicBlock; 2] },\n+}\n+\n+impl<H:Hair> Terminator<H> {\n+    pub fn successors(&self) -> &[BasicBlock] {\n+        use self::Terminator::*;\n+        match *self {\n+            Goto { target: ref b } => slice::ref_slice(b),\n+            Panic { target: ref b } => slice::ref_slice(b),\n+            If { cond: _, targets: ref b } => b,\n+            Switch { discr: _, targets: ref b } => b,\n+            Diverge => &[],\n+            Return => &[],\n+            Call { data: _, targets: ref b } => b,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct CallData<H:Hair> {\n+    /// where the return value is written to\n+    pub destination: Lvalue<H>,\n+\n+    /// the fn being called\n+    pub func: Lvalue<H>,\n+\n+    /// the arguments\n+    pub args: Vec<Lvalue<H>>,\n+}\n+\n+impl<H:Hair> BasicBlockData<H> {\n+    pub fn new(terminator: Terminator<H>) -> BasicBlockData<H> {\n+        BasicBlockData {\n+            statements: vec![],\n+            terminator: terminator,\n+        }\n+    }\n+}\n+\n+impl<H:Hair> Debug for Terminator<H> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        use self::Terminator::*;\n+        match *self {\n+            Goto { target } =>\n+                write!(fmt, \"goto -> {:?}\", target),\n+            Panic { target } =>\n+                write!(fmt, \"panic -> {:?}\", target),\n+            If { cond: ref lv, ref targets } =>\n+                write!(fmt, \"if({:?}) -> {:?}\", lv, targets),\n+            Switch { discr: ref lv, ref targets } =>\n+                write!(fmt, \"switch({:?}) -> {:?}\", lv, targets),\n+            Diverge =>\n+                write!(fmt, \"diverge\"),\n+            Return =>\n+                write!(fmt, \"return\"),\n+            Call { data: ref c, targets } => {\n+                try!(write!(fmt, \"{:?} = {:?}(\", c.destination, c.func));\n+                for (index, arg) in c.args.iter().enumerate() {\n+                    if index > 0 { try!(write!(fmt, \", \")); }\n+                    try!(write!(fmt, \"{:?}\", arg));\n+                }\n+                write!(fmt, \") -> {:?}\", targets)\n+            }\n+        }\n+    }\n+}\n+\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Statements\n+\n+pub struct Statement<H:Hair> {\n+    pub span: H::Span,\n+    pub kind: StatementKind<H>,\n+}\n+\n+#[derive(Debug)]\n+pub enum StatementKind<H:Hair> {\n+    Assign(Lvalue<H>, Rvalue<H>),\n+    Drop(DropKind, Lvalue<H>),\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum DropKind {\n+    Shallow,\n+    Deep\n+}\n+\n+impl<H:Hair> Debug for Statement<H> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        use self::StatementKind::*;\n+        match self.kind {\n+            Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv),\n+            Drop(DropKind::Shallow, ref lv) => write!(fmt, \"shallow_drop {:?}\", lv),\n+            Drop(DropKind::Deep, ref lv) => write!(fmt, \"drop {:?}\", lv),\n+        }\n+    }\n+}\n+///////////////////////////////////////////////////////////////////////////\n+// Lvalues\n+\n+/// A path to a value; something that can be evaluated without\n+/// changing or disturbing program state.\n+#[derive(Clone, PartialEq)]\n+pub enum Lvalue<H:Hair> {\n+    /// local variable declared by the user\n+    Var(u32),\n+\n+    /// temporary introduced during lowering into MIR\n+    Temp(u32),\n+\n+    /// formal parameter of the function; note that these are NOT the\n+    /// bindings that the user declares, which are vars\n+    Arg(u32),\n+\n+    /// static or static mut variable\n+    Static(H::DefId),\n+\n+    /// the return pointer of the fn\n+    ReturnPointer,\n+\n+    /// projection out of an lvalue (access a field, deref a pointer, etc)\n+    Projection(Box<LvalueProjection<H>>)\n+}\n+\n+/// The `Projection` data structure defines things of the form `B.x`\n+/// or `*B` or `B[index]`. Note that it is parameterized because it is\n+/// shared between `Constant` and `Lvalue`. See the aliases\n+/// `LvalueProjection` etc below.\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct Projection<H:Hair,B,V> {\n+    pub base: B,\n+    pub elem: ProjectionElem<H,V>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum ProjectionElem<H:Hair,V> {\n+    Deref,\n+    Field(Field<H>),\n+    Index(V),\n+\n+    // These indices are generated by slice patterns. Easiest to explain\n+    // by example:\n+    //\n+    // ```\n+    // [X, _, .._, _, _] => { offset: 0, min_length: 4, from_end: false },\n+    // [_, X, .._, _, _] => { offset: 1, min_length: 4, from_end: false },\n+    // [_, _, .._, X, _] => { offset: 2, min_length: 4, from_end: true },\n+    // [_, _, .._, _, X] => { offset: 1, min_length: 4, from_end: true },\n+    // ```\n+    ConstantIndex {\n+        offset: u32,      // index or -index (in Python terms), depending on from_end\n+        min_length: u32,  // thing being indexed must be at least this long\n+        from_end: bool,   // counting backwards from end?\n+    },\n+\n+    // \"Downcast\" to a variant of an ADT. Currently, we only introduce\n+    // this for ADTs with more than one variant. It may be better to\n+    // just introduce it always, or always for enums.\n+    Downcast(H::AdtDef, usize),\n+}\n+\n+/// Alias for projections as they appear in lvalues, where the base is an lvalue\n+/// and the index is an operand.\n+pub type LvalueProjection<H> =\n+    Projection<H,Lvalue<H>,Operand<H>>;\n+\n+/// Alias for projections as they appear in lvalues, where the base is an lvalue\n+/// and the index is an operand.\n+pub type LvalueElem<H> =\n+    ProjectionElem<H,Operand<H>>;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum Field<H:Hair> {\n+    Named(H::Name),\n+    Indexed(usize),\n+}\n+\n+impl<H:Hair> Lvalue<H> {\n+    pub fn field(self, f: Field<H>) -> Lvalue<H> {\n+        self.elem(ProjectionElem::Field(f))\n+    }\n+\n+    pub fn deref(self) -> Lvalue<H> {\n+        self.elem(ProjectionElem::Deref)\n+    }\n+\n+    pub fn index(self, index: Operand<H>) -> Lvalue<H> {\n+        self.elem(ProjectionElem::Index(index))\n+    }\n+\n+    pub fn elem(self, elem: LvalueElem<H>) -> Lvalue<H> {\n+        Lvalue::Projection(Box::new(LvalueProjection { base: self, elem: elem }))\n+    }\n+}\n+\n+impl<H:Hair> Debug for Lvalue<H> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        use self::Lvalue::*;\n+\n+        match *self {\n+            Var(id) =>\n+                write!(fmt,\"Var({:?})\", id),\n+            Arg(id) =>\n+                write!(fmt,\"Arg({:?})\", id),\n+            Temp(id) =>\n+                write!(fmt,\"Temp({:?})\", id),\n+            Static(id) =>\n+                write!(fmt,\"Static({:?})\", id),\n+            ReturnPointer =>\n+                write!(fmt,\"ReturnPointer\"),\n+            Projection(ref data) =>\n+                match data.elem {\n+                    ProjectionElem::Downcast(_, variant_index) =>\n+                        write!(fmt,\"({:?} as {:?})\", data.base, variant_index),\n+                    ProjectionElem::Deref =>\n+                        write!(fmt,\"(*{:?})\", data.base),\n+                    ProjectionElem::Field(Field::Named(name)) =>\n+                        write!(fmt,\"{:?}.{:?}\", data.base, name),\n+                    ProjectionElem::Field(Field::Indexed(index)) =>\n+                        write!(fmt,\"{:?}.{:?}\", data.base, index),\n+                    ProjectionElem::Index(ref index) =>\n+                        write!(fmt,\"{:?}[{:?}]\", data.base, index),\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n+                        write!(fmt,\"{:?}[{:?} of {:?}]\", data.base, offset, min_length),\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n+                        write!(fmt,\"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n+                },\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Operands\n+//\n+// These are values that can appear inside an rvalue (or an index\n+// lvalue). They are intentionally limited to prevent rvalues from\n+// being nested in one another.\n+\n+#[derive(Clone, PartialEq)]\n+pub enum Operand<H:Hair> {\n+    Consume(Lvalue<H>),\n+    Constant(Constant<H>),\n+}\n+\n+impl<H:Hair> Debug for Operand<H> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        use self::Operand::*;\n+        match *self {\n+            Constant(ref a) => write!(fmt, \"{:?}\", a),\n+            Consume(ref lv) => write!(fmt, \"{:?}\", lv),\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Rvalues\n+\n+#[derive(Clone)]\n+pub enum Rvalue<H:Hair> {\n+    // x (either a move or copy, depending on type of x)\n+    Use(Operand<H>),\n+\n+    // [x; 32]\n+    Repeat(Operand<H>, Operand<H>),\n+\n+    // &x or &mut x\n+    Ref(H::Region, BorrowKind, Lvalue<H>),\n+\n+    // length of a [X] or [X;n] value\n+    Len(Lvalue<H>),\n+\n+    Cast(CastKind, Operand<H>, H::Ty),\n+\n+    BinaryOp(BinOp, Operand<H>, Operand<H>),\n+\n+    UnaryOp(UnOp, Operand<H>),\n+\n+    // Creates an *uninitialized* Box\n+    Box(H::Ty),\n+\n+    // Create an aggregate value, like a tuple or struct.  This is\n+    // only needed because we want to distinguish `dest = Foo { x:\n+    // ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n+    // that `Foo` has a destructor. These rvalues can be optimized\n+    // away after type-checking and before lowering.\n+    Aggregate(AggregateKind<H>, Vec<Operand<H>>),\n+\n+    // Generates a slice of the form `&input[from_start..L-from_end]`\n+    // where `L` is the length of the slice. This is only created by\n+    // slice pattern matching, so e.g. a pattern of the form `[x, y,\n+    // .., z]` might create a slice with `from_start=2` and\n+    // `from_end=1`.\n+    Slice {\n+        input: Lvalue<H>,\n+        from_start: usize,\n+        from_end: usize,\n+    },\n+\n+    InlineAsm(H::InlineAsm),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum CastKind {\n+    Misc,\n+\n+    /// Convert unique, zero-sized type for a fn to fn()\n+    ReifyFnPointer,\n+\n+    /// Convert safe fn() to unsafe fn()\n+    UnsafeFnPointer,\n+\n+    /// \"Unsize\" -- convert a thin-or-fat pointer to a fat pointer.\n+    /// trans must figure out the details once full monomorphization\n+    /// is known. For example, this could be used to cast from a\n+    /// `&[i32;N]` to a `&[i32]`, or a `Box<T>` to a `Box<Trait>`\n+    /// (presuming `T: Trait`).\n+    Unsize,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum AggregateKind<H:Hair> {\n+    Vec,\n+    Tuple,\n+    Adt(H::AdtDef, usize, H::Substs),\n+    Closure(H::DefId, H::ClosureSubsts),\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum BinOp {\n+    /// The `+` operator (addition)\n+    Add,\n+    /// The `-` operator (subtraction)\n+    Sub,\n+    /// The `*` operator (multiplication)\n+    Mul,\n+    /// The `/` operator (division)\n+    Div,\n+    /// The `%` operator (modulus)\n+    Rem,\n+    /// The `^` operator (bitwise xor)\n+    BitXor,\n+    /// The `&` operator (bitwise and)\n+    BitAnd,\n+    /// The `|` operator (bitwise or)\n+    BitOr,\n+    /// The `<<` operator (shift left)\n+    Shl,\n+    /// The `>>` operator (shift right)\n+    Shr,\n+    /// The `==` operator (equality)\n+    Eq,\n+    /// The `<` operator (less than)\n+    Lt,\n+    /// The `<=` operator (less than or equal to)\n+    Le,\n+    /// The `!=` operator (not equal to)\n+    Ne,\n+    /// The `>=` operator (greater than or equal to)\n+    Ge,\n+    /// The `>` operator (greater than)\n+    Gt,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum UnOp {\n+    /// The `!` operator for logical inversion\n+    Not,\n+    /// The `-` operator for negation\n+    Neg\n+}\n+\n+impl<H:Hair> Debug for Rvalue<H> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        use self::Rvalue::*;\n+\n+        match *self {\n+            Use(ref lvalue) => write!(fmt, \"{:?}\", lvalue),\n+            Repeat(ref a, ref b) => write!(fmt, \"[{:?}; {:?}]\", a, b),\n+            Ref(ref a, bk, ref b) => write!(fmt, \"&{:?} {:?} {:?}\", a, bk, b),\n+            Len(ref a) => write!(fmt, \"LEN({:?})\", a),\n+            Cast(ref kind, ref lv, ref ty) => write!(fmt, \"{:?} as {:?} ({:?}\", lv, ty, kind),\n+            BinaryOp(ref op, ref a, ref b) => write!(fmt, \"{:?}({:?},{:?})\", op, a, b),\n+            UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n+            Box(ref t) => write!(fmt, \"Box {:?}\", t),\n+            Aggregate(ref kind, ref lvs) => write!(fmt, \"Aggregate<{:?}>({:?})\", kind, lvs),\n+            InlineAsm(ref asm) => write!(fmt, \"InlineAsm({:?})\", asm),\n+            Slice { ref input, from_start, from_end } => write!(fmt, \"{:?}[{:?}..-{:?}]\",\n+                                                                input, from_start, from_end),\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Constants\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct Constant<H:Hair> {\n+    pub span: H::Span,\n+    pub kind: ConstantKind<H>\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum ConstantKind<H:Hair> {\n+    Literal(Literal<H>),\n+    Aggregate(AggregateKind<H>, Vec<Constant<H>>),\n+    Call(Box<Constant<H>>, Vec<Constant<H>>),\n+    Cast(Box<Constant<H>>, H::Ty),\n+    Repeat(Box<Constant<H>>, Box<Constant<H>>),\n+    Ref(BorrowKind, Box<Constant<H>>),\n+    BinaryOp(BinOp, Box<Constant<H>>, Box<Constant<H>>),\n+    UnaryOp(UnOp, Box<Constant<H>>),\n+    Projection(Box<ConstantProjection<H>>)\n+}\n+\n+pub type ConstantProjection<H> =\n+    Projection<H,Constant<H>,Constant<H>>;\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum Literal<H:Hair> {\n+    Item { def_id: H::DefId, substs: H::Substs },\n+    Projection { projection: H::Projection },\n+    Int { bits: IntegralBits, value: i64 },\n+    Uint { bits: IntegralBits, value: u64 },\n+    Float { bits: FloatBits, value: f64 },\n+    Char { c: char },\n+    Bool { value: bool },\n+    Bytes { value: H::Bytes },\n+    String { value: H::InternedString },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n+pub enum IntegralBits {\n+    B8, B16, B32, B64, BSize\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n+pub enum FloatBits {\n+    F32, F64\n+}"}, {"sha": "033e6ed2968b6226ea436fb2600a466d7e84ab13", "filename": "src/librustc_mir/tcx/block.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Ftcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Ftcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fblock.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hair::*;\n+\n+use tcx::Cx;\n+use tcx::pattern::PatNode;\n+use tcx::rustc::middle::region::{BlockRemainder, CodeExtentData};\n+use tcx::rustc_front::hir;\n+use tcx::syntax::ast;\n+use tcx::syntax::ptr::P;\n+use tcx::to_ref::ToRef;\n+\n+impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Block {\n+    type Output = Block<Cx<'a,'tcx>>;\n+\n+    fn make_mirror(self, cx: &mut Cx<'a,'tcx>) -> Block<Cx<'a,'tcx>> {\n+        // We have to eagerly translate the \"spine\" of the statements\n+        // in order to get the lexical scoping correctly.\n+        let stmts = mirror_stmts(cx, self.id, self.stmts.iter().enumerate());\n+        Block {\n+            extent: cx.tcx.region_maps.node_extent(self.id),\n+            span: self.span,\n+            stmts: stmts,\n+            expr: self.expr.to_ref()\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Stmt {\n+    type Output = Stmt<Cx<'a,'tcx>>;\n+\n+    fn make_mirror(self, _cx: &mut Cx<'a,'tcx>) -> Stmt<Cx<'a,'tcx>> {\n+        // In order to get the scoping correct, we eagerly mirror\n+        // statements when we translate the enclosing block, so we\n+        // should in fact never get to this point.\n+        panic!(\"statements are eagerly mirrored\");\n+    }\n+}\n+\n+fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n+                                  block_id: ast::NodeId,\n+                                  mut stmts: STMTS)\n+                                  -> Vec<StmtRef<Cx<'a,'tcx>>>\n+    where STMTS: Iterator<Item=(usize, &'tcx P<hir::Stmt>)>\n+{\n+    let mut result = vec![];\n+    while let Some((index, stmt)) = stmts.next() {\n+        match stmt.node {\n+            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) =>\n+                result.push(\n+                    StmtRef::Mirror(\n+                        Box::new(Stmt { span: stmt.span,\n+                                        kind: StmtKind::Expr {\n+                                            scope: cx.tcx.region_maps.node_extent(id),\n+                                            expr: expr.to_ref() } }))),\n+\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclItem(..) => { /* ignore for purposes of the MIR */ }\n+                    hir::DeclLocal(ref local) => {\n+                        let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n+                            block: block_id,\n+                            first_statement_index: index as u32\n+                        });\n+                        let remainder_extent =\n+                            cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n+\n+                        // pull in all following statements, since\n+                        // they are within the scope of this let:\n+                        let following_stmts = mirror_stmts(cx, block_id, stmts);\n+\n+                        result.push(\n+                            StmtRef::Mirror(\n+                                Box::new(Stmt {\n+                                    span: stmt.span,\n+                                    kind: StmtKind::Let {\n+                                        remainder_scope: remainder_extent,\n+                                        init_scope: cx.tcx.region_maps.node_extent(id),\n+                                        pattern: PatNode::irrefutable(&local.pat).to_ref(),\n+                                        initializer: local.init.to_ref(),\n+                                        stmts: following_stmts\n+                                    }\n+                                })));\n+\n+                        return result;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    return result;\n+}\n+\n+pub fn to_expr_ref<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n+                               block: &'tcx hir::Block)\n+                               -> ExprRef<Cx<'a, 'tcx>> {\n+    let block_ty = cx.tcx.node_id_to_type(block.id);\n+    let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n+    let expr = Expr {\n+        ty: block_ty,\n+        temp_lifetime: temp_lifetime,\n+        span: block.span,\n+        kind: ExprKind::Block { body: block }\n+    };\n+    expr.to_ref()\n+}"}, {"sha": "6352af39f1489b75d64e93e826cb7e9d061abcc0", "filename": "src/librustc_mir/tcx/expr.rs", "status": "added", "additions": 870, "deletions": 0, "changes": 870, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,870 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hair::*;\n+use repr::*;\n+use rustc_data_structures::fnv::FnvHashMap;\n+use std::rc::Rc;\n+use tcx::Cx;\n+use tcx::block;\n+use tcx::pattern::PatNode;\n+use tcx::rustc::front::map;\n+use tcx::rustc::middle::def;\n+use tcx::rustc::middle::def_id::DefId;\n+use tcx::rustc::middle::region::CodeExtent;\n+use tcx::rustc::middle::pat_util;\n+use tcx::rustc::middle::ty::{self, Ty};\n+use tcx::rustc_front::hir;\n+use tcx::rustc_front::util as hir_util;\n+use tcx::syntax::codemap::Span;\n+use tcx::syntax::parse::token;\n+use tcx::syntax::ptr::P;\n+use tcx::to_ref::ToRef;\n+\n+impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n+    type Output = Expr<Cx<'a,'tcx>>;\n+\n+    fn make_mirror(self, cx: &mut Cx<'a,'tcx>) -> Expr<Cx<'a,'tcx>> {\n+        debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n+\n+        let expr_ty = cx.tcx.expr_ty(self); // note: no adjustments (yet)!\n+\n+        let kind = match self.node {\n+            // Here comes the interesting stuff:\n+\n+            hir::ExprMethodCall(_, _, ref args) => {\n+                // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n+                let expr = method_callee(cx, self, ty::MethodCall::expr(self.id));\n+                let args = args.iter()\n+                               .map(|e| e.to_ref())\n+                               .collect();\n+                ExprKind::Call {\n+                    fun: expr.to_ref(),\n+                    args: args\n+                }\n+            }\n+\n+            hir::ExprAddrOf(mutbl, ref expr) => {\n+                let region = match expr_ty.sty {\n+                    ty::TyRef(r, _) => r,\n+                    _ => cx.tcx.sess.span_bug(expr.span, \"type of & not region\")\n+                };\n+                ExprKind::Borrow { region: *region,\n+                                   borrow_kind: to_borrow_kind(mutbl),\n+                                   arg: expr.to_ref() }\n+            }\n+\n+            hir::ExprBlock(ref blk) => {\n+                ExprKind::Block {\n+                    body: &**blk\n+                }\n+            }\n+\n+            hir::ExprAssign(ref lhs, ref rhs) => {\n+                ExprKind::Assign {\n+                    lhs: lhs.to_ref(),\n+                    rhs: rhs.to_ref(),\n+                }\n+            }\n+\n+            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+                let op = bin_op(op.node);\n+                ExprKind::AssignOp {\n+                    op: op,\n+                    lhs: lhs.to_ref(),\n+                    rhs: rhs.to_ref(),\n+                }\n+            }\n+\n+            hir::ExprLit(ref lit) => {\n+                let literal = convert_literal(cx, self.span, expr_ty, lit);\n+                ExprKind::Literal { literal: literal }\n+            }\n+\n+            hir::ExprBinary(op, ref lhs, ref rhs) => {\n+                if cx.tcx.is_method_call(self.id) {\n+                    let pass_args = if hir_util::is_by_value_binop(op.node) {\n+                        PassArgs::ByValue\n+                    } else {\n+                        PassArgs::ByRef\n+                    };\n+                    overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n+                                        pass_args, lhs.to_ref(), vec![rhs])\n+                } else {\n+                    // FIXME overflow\n+                    match op.node {\n+                        hir::BinOp_::BiAnd => {\n+                            ExprKind::LogicalOp { op: LogicalOp::And,\n+                                                  lhs: lhs.to_ref(),\n+                                                  rhs: rhs.to_ref() }\n+                        }\n+                        hir::BinOp_::BiOr => {\n+                            ExprKind::LogicalOp { op: LogicalOp::Or,\n+                                                  lhs: lhs.to_ref(),\n+                                                  rhs: rhs.to_ref() }\n+                        }\n+                        _ => {\n+                            let op = bin_op(op.node);\n+                            ExprKind::Binary { op: op,\n+                                               lhs: lhs.to_ref(),\n+                                               rhs: rhs.to_ref() }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            hir::ExprIndex(ref lhs, ref index) => {\n+                if cx.tcx.is_method_call(self.id) {\n+                    overloaded_lvalue(cx, self, ty::MethodCall::expr(self.id),\n+                                      PassArgs::ByValue, lhs.to_ref(), vec![index])\n+                } else {\n+                    ExprKind::Index { lhs: lhs.to_ref(),\n+                                      index: index.to_ref() }\n+                }\n+            }\n+\n+            hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n+                if cx.tcx.is_method_call(self.id) {\n+                    overloaded_lvalue(cx, self, ty::MethodCall::expr(self.id),\n+                                      PassArgs::ByValue, arg.to_ref(), vec![])\n+                } else {\n+                    ExprKind::Deref { arg: arg.to_ref() }\n+                }\n+            }\n+\n+            hir::ExprUnary(hir::UnOp::UnUniq, ref arg) => {\n+                assert!(!cx.tcx.is_method_call(self.id));\n+                ExprKind::Box { place: None, value: arg.to_ref() }\n+            }\n+\n+            hir::ExprUnary(op, ref arg) => {\n+                if cx.tcx.is_method_call(self.id) {\n+                    overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n+                                        PassArgs::ByValue, arg.to_ref(), vec![])\n+                } else {\n+                    // FIXME overflow\n+                    let op = match op {\n+                        hir::UnOp::UnNot => UnOp::Not,\n+                        hir::UnOp::UnNeg => UnOp::Neg,\n+                        hir::UnOp::UnUniq | hir::UnOp::UnDeref => {\n+                            cx.tcx.sess.span_bug(\n+                                self.span,\n+                                &format!(\"operator should have been handled elsewhere {:?}\", op));\n+                        }\n+                    };\n+                    ExprKind::Unary { op: op, arg: arg.to_ref() }\n+                }\n+            }\n+\n+            hir::ExprStruct(_, ref fields, ref base) => {\n+                match expr_ty.sty {\n+                    ty::TyStruct(adt, substs) => {\n+                        ExprKind::Adt {\n+                            adt_def: adt,\n+                            variant_index: 0,\n+                            substs: substs,\n+                            fields: fields.to_ref(),\n+                            base: base.to_ref(),\n+                        }\n+                    }\n+                    ty::TyEnum(adt, substs) => {\n+                        match cx.tcx.def_map.borrow()[&self.id].full_def() {\n+                            def::DefVariant(enum_id, variant_id, true) => {\n+                                debug_assert!(adt.did == enum_id);\n+                                let index = adt.variant_index_with_id(variant_id);\n+                                ExprKind::Adt {\n+                                    adt_def: adt,\n+                                    variant_index: index,\n+                                    substs: substs,\n+                                    fields: fields.to_ref(),\n+                                    base: base.to_ref(),\n+                                }\n+                            }\n+                            ref def => {\n+                                cx.tcx.sess.span_bug(\n+                                    self.span,\n+                                    &format!(\"unexpected def: {:?}\", def));\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        cx.tcx.sess.span_bug(\n+                            self.span,\n+                            &format!(\"unexpected type for struct literal: {:?}\", expr_ty));\n+                    }\n+                }\n+            }\n+\n+            hir::ExprClosure(..) => {\n+                let closure_ty = cx.tcx.expr_ty(self);\n+                let (def_id, substs) = match closure_ty.sty {\n+                    ty::TyClosure(def_id, ref substs) => (def_id, substs),\n+                    _ => {\n+                        cx.tcx.sess.span_bug(self.span,\n+                                          &format!(\"closure expr w/o closure type: {:?}\",\n+                                                   closure_ty));\n+                    }\n+                };\n+                let upvars = cx.tcx.with_freevars(self.id, |freevars| {\n+                    freevars.iter()\n+                            .enumerate()\n+                            .map(|(i, fv)| capture_freevar(cx, self, fv, substs.upvar_tys[i]))\n+                            .collect()\n+                });\n+                ExprKind::Closure {\n+                    closure_id: def_id,\n+                    substs: &**substs,\n+                    upvars: upvars,\n+                }\n+            }\n+\n+            hir::ExprRange(ref start, ref end) => {\n+                let range_ty = cx.tcx.expr_ty(self);\n+                let (adt_def, substs) = match range_ty.sty {\n+                    ty::TyStruct(adt_def, substs) => (adt_def, substs),\n+                    _ => {\n+                        cx.tcx.sess.span_bug(\n+                            self.span,\n+                            &format!(\"unexpanded ast\"));\n+                    }\n+                };\n+\n+                let field_expr_ref = |s: &'tcx P<hir::Expr>, nm: &str| {\n+                    FieldExprRef { name: Field::Named(token::intern(nm)),\n+                                   expr: s.to_ref() }\n+                };\n+\n+                let start_field = start.as_ref()\n+                                       .into_iter()\n+                                       .map(|s| field_expr_ref(s, \"start\"));\n+\n+                let end_field = end.as_ref()\n+                                   .into_iter()\n+                                   .map(|e| field_expr_ref(e, \"end\"));\n+\n+                ExprKind::Adt { adt_def: adt_def,\n+                                variant_index: 0,\n+                                substs: substs,\n+                                fields: start_field.chain(end_field).collect(),\n+                                base: None }\n+            }\n+\n+            hir::ExprPath(..) => {\n+                convert_path_expr(cx, self)\n+            }\n+\n+            hir::ExprInlineAsm(ref asm) => {\n+                ExprKind::InlineAsm { asm: asm }\n+            }\n+\n+            // Now comes the rote stuff:\n+\n+            hir::ExprParen(ref p) =>\n+                ExprKind::Paren { arg: p.to_ref() },\n+            hir::ExprRepeat(ref v, ref c) =>\n+                ExprKind::Repeat { value: v.to_ref(), count: c.to_ref() },\n+            hir::ExprRet(ref v) =>\n+                ExprKind::Return { value: v.to_ref() },\n+            hir::ExprBreak(label) =>\n+                ExprKind::Break { label: label.map(|_| loop_label(cx, self)) },\n+            hir::ExprAgain(label) =>\n+                ExprKind::Continue { label: label.map(|_| loop_label(cx, self)) },\n+            hir::ExprMatch(ref discr, ref arms, _) =>\n+                ExprKind::Match { discriminant: discr.to_ref(),\n+                                  arms: arms.iter().map(|a| convert_arm(cx, a)).collect() },\n+            hir::ExprIf(ref cond, ref then, ref otherwise) =>\n+                ExprKind::If { condition: cond.to_ref(),\n+                               then: block::to_expr_ref(cx, then),\n+                               otherwise: otherwise.to_ref() },\n+            hir::ExprWhile(ref cond, ref body, _) =>\n+                ExprKind::Loop { condition: Some(cond.to_ref()),\n+                                 body: block::to_expr_ref(cx, body) },\n+            hir::ExprLoop(ref body, _) =>\n+                ExprKind::Loop { condition: None,\n+                                 body: block::to_expr_ref(cx, body) },\n+            hir::ExprField(ref source, ident) =>\n+                ExprKind::Field { lhs: source.to_ref(),\n+                                  name: Field::Named(ident.node.name) },\n+            hir::ExprTupField(ref source, ident) =>\n+                ExprKind::Field { lhs: source.to_ref(),\n+                                  name: Field::Indexed(ident.node) },\n+            hir::ExprCast(ref source, _) =>\n+                ExprKind::Cast { source: source.to_ref() },\n+            hir::ExprBox(ref place, ref value) =>\n+                ExprKind::Box { place: place.to_ref(), value: value.to_ref() },\n+            hir::ExprVec(ref fields) =>\n+                ExprKind::Vec { fields: fields.to_ref() },\n+            hir::ExprTup(ref fields) =>\n+                ExprKind::Tuple { fields: fields.to_ref() },\n+            hir::ExprCall(ref fun, ref args) =>\n+                ExprKind::Call { fun: fun.to_ref(), args: args.to_ref() },\n+        };\n+\n+        let temp_lifetime = cx.tcx.region_maps.temporary_scope(self.id);\n+        let expr_extent = cx.tcx.region_maps.node_extent(self.id);\n+\n+        let mut expr = Expr {\n+            temp_lifetime: temp_lifetime,\n+            ty: expr_ty,\n+            span: self.span,\n+            kind: kind,\n+        };\n+\n+        // Now apply adjustments, if any.\n+        match cx.tcx.tables.borrow().adjustments.get(&self.id) {\n+            None => { }\n+            Some(&ty::AdjustReifyFnPointer) => {\n+                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+                expr = Expr {\n+                    temp_lifetime: temp_lifetime,\n+                    ty: adjusted_ty,\n+                    span: self.span,\n+                    kind: ExprKind::ReifyFnPointer { source: expr.to_ref() },\n+                };\n+            }\n+            Some(&ty::AdjustUnsafeFnPointer) => {\n+                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+                expr = Expr {\n+                    temp_lifetime: temp_lifetime,\n+                    ty: adjusted_ty,\n+                    span: self.span,\n+                    kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n+                };\n+            }\n+            Some(&ty::AdjustDerefRef(ref adj)) => {\n+                for i in 0..adj.autoderefs {\n+                    let i = i as u32;\n+                    let adjusted_ty =\n+                        expr.ty.adjust_for_autoderef(\n+                            cx.tcx,\n+                            self.id,\n+                            self.span,\n+                            i,\n+                            |mc| cx.tcx.tables.borrow().method_map.get(&mc).map(|m| m.ty));\n+                    let kind = if cx.tcx.is_overloaded_autoderef(self.id, i) {\n+                        overloaded_lvalue(cx, self, ty::MethodCall::autoderef(self.id, i),\n+                                          PassArgs::ByValue, expr.to_ref(), vec![])\n+                    } else {\n+                        ExprKind::Deref { arg: expr.to_ref() }\n+                    };\n+                    expr = Expr {\n+                        temp_lifetime: temp_lifetime,\n+                        ty: adjusted_ty,\n+                        span: self.span,\n+                        kind: kind\n+                    };\n+                }\n+\n+                if let Some(target) = adj.unsize {\n+                    expr = Expr {\n+                        temp_lifetime: temp_lifetime,\n+                        ty: target,\n+                        span: self.span,\n+                        kind: ExprKind::Unsize { source: expr.to_ref() }\n+                    };\n+                } else if let Some(autoref) = adj.autoref {\n+                    let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n+                    match autoref {\n+                        ty::AutoPtr(r, m) => {\n+                            expr = Expr {\n+                                temp_lifetime: temp_lifetime,\n+                                ty: adjusted_ty,\n+                                span: self.span,\n+                                kind: ExprKind::Borrow { region: *r,\n+                                                         borrow_kind: to_borrow_kind(m),\n+                                                         arg: expr.to_ref() }\n+                            };\n+                        }\n+                        ty::AutoUnsafe(m) => {\n+                            // Convert this to a suitable `&foo` and\n+                            // then an unsafe coercion. Limit the region to be just this\n+                            // expression.\n+                            let region = ty::ReScope(expr_extent);\n+                            let region = cx.tcx.mk_region(region);\n+                            expr = Expr {\n+                                temp_lifetime: temp_lifetime,\n+                                ty: cx.tcx.mk_ref(region, ty::TypeAndMut { ty: expr.ty, mutbl: m }),\n+                                span: self.span,\n+                                kind: ExprKind::Borrow { region: *region,\n+                                                         borrow_kind: to_borrow_kind(m),\n+                                                         arg: expr.to_ref() }\n+                            };\n+                            expr = Expr {\n+                                temp_lifetime: temp_lifetime,\n+                                ty: adjusted_ty,\n+                                span: self.span,\n+                                kind: ExprKind::Cast { source: expr.to_ref() }\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Next, wrap this up in the expr's scope.\n+        expr = Expr {\n+            temp_lifetime: temp_lifetime,\n+            ty: expr.ty,\n+            span: self.span,\n+            kind: ExprKind::Scope { extent: expr_extent,\n+                                    value: expr.to_ref() }\n+        };\n+\n+        // Finally, create a destruction scope, if any.\n+        if let Some(extent) = cx.tcx.region_maps.opt_destruction_extent(self.id) {\n+            expr = Expr {\n+                temp_lifetime: temp_lifetime,\n+                ty: expr.ty,\n+                span: self.span,\n+                kind: ExprKind::Scope { extent: extent, value: expr.to_ref() }\n+            };\n+        }\n+\n+        // OK, all done!\n+        expr\n+    }\n+}\n+\n+fn method_callee<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n+                             expr: &hir::Expr,\n+                             method_call: ty::MethodCall)\n+                             -> Expr<Cx<'a,'tcx>> {\n+    let tables = cx.tcx.tables.borrow();\n+    let callee = &tables.method_map[&method_call];\n+    let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n+    Expr {\n+        temp_lifetime: temp_lifetime,\n+        ty: callee.ty,\n+        span: expr.span,\n+        kind: ExprKind::Literal {\n+            literal: Literal::Item {\n+                def_id: callee.def_id,\n+                substs: callee.substs,\n+            }\n+        }\n+    }\n+}\n+\n+fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n+    match m {\n+        hir::MutMutable => BorrowKind::Mut,\n+        hir::MutImmutable => BorrowKind::Shared,\n+    }\n+}\n+\n+fn convert_literal<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n+                               expr_span: Span,\n+                               expr_ty: Ty<'tcx>,\n+                               literal: &hir::Lit)\n+                               -> Literal<Cx<'a,'tcx>>\n+{\n+    use repr::IntegralBits::*;\n+    match (&literal.node, &expr_ty.sty) {\n+        (&hir::LitStr(ref text, _), _) =>\n+            Literal::String { value: text.clone() },\n+        (&hir::LitByteStr(ref bytes), _) =>\n+            Literal::Bytes { value: bytes.clone() },\n+        (&hir::LitByte(c), _) =>\n+            Literal::Uint { bits: B8, value: c as u64 },\n+        (&hir::LitChar(c), _) =>\n+            Literal::Char { c: c },\n+        (&hir::LitInt(v, _), &ty::TyUint(hir::TyU8)) =>\n+            Literal::Uint { bits: B8, value: v },\n+        (&hir::LitInt(v, _), &ty::TyUint(hir::TyU16)) =>\n+            Literal::Uint { bits: B16, value: v },\n+        (&hir::LitInt(v, _), &ty::TyUint(hir::TyU32)) =>\n+            Literal::Uint { bits: B32, value: v },\n+        (&hir::LitInt(v, _), &ty::TyUint(hir::TyU64)) =>\n+            Literal::Uint { bits: B64, value: v },\n+        (&hir::LitInt(v, _), &ty::TyUint(hir::TyUs)) =>\n+            Literal::Uint { bits: BSize, value: v },\n+        (&hir::LitInt(v, hir::SignedIntLit(_, hir::Sign::Minus)), &ty::TyInt(hir::TyI8)) =>\n+            Literal::Int { bits: B8, value: -(v as i64) },\n+        (&hir::LitInt(v, hir::SignedIntLit(_, hir::Sign::Minus)), &ty::TyInt(hir::TyI16)) =>\n+            Literal::Int { bits: B16, value: -(v as i64) },\n+        (&hir::LitInt(v, hir::SignedIntLit(_, hir::Sign::Minus)), &ty::TyInt(hir::TyI32)) =>\n+            Literal::Int { bits: B32, value: -(v as i64) },\n+        (&hir::LitInt(v, hir::SignedIntLit(_, hir::Sign::Minus)), &ty::TyInt(hir::TyI64)) =>\n+            Literal::Int { bits: B64, value: -(v as i64) },\n+        (&hir::LitInt(v, hir::SignedIntLit(_, hir::Sign::Minus)), &ty::TyInt(hir::TyIs)) =>\n+            Literal::Int { bits: BSize, value: -(v as i64) },\n+        (&hir::LitInt(v, _), &ty::TyInt(hir::TyI8)) =>\n+            Literal::Int { bits: B8, value: v as i64 },\n+        (&hir::LitInt(v, _), &ty::TyInt(hir::TyI16)) =>\n+            Literal::Int { bits: B16, value: v as i64 },\n+        (&hir::LitInt(v, _), &ty::TyInt(hir::TyI32)) =>\n+            Literal::Int { bits: B32, value: v as i64 },\n+        (&hir::LitInt(v, _), &ty::TyInt(hir::TyI64)) =>\n+            Literal::Int { bits: B64, value: v as i64 },\n+        (&hir::LitInt(v, _), &ty::TyInt(hir::TyIs)) =>\n+            Literal::Int { bits: BSize, value: v as i64 },\n+        (&hir::LitFloat(ref v, _), &ty::TyFloat(hir::TyF32)) |\n+        (&hir::LitFloatUnsuffixed(ref v), &ty::TyFloat(hir::TyF32)) =>\n+            Literal::Float { bits: FloatBits::F32, value: v.parse::<f64>().unwrap() },\n+        (&hir::LitFloat(ref v, _), &ty::TyFloat(hir::TyF64)) |\n+        (&hir::LitFloatUnsuffixed(ref v), &ty::TyFloat(hir::TyF64)) =>\n+            Literal::Float { bits: FloatBits::F64, value: v.parse::<f64>().unwrap() },\n+        (&hir::LitBool(v), _) =>\n+            Literal::Bool { value: v },\n+        (ref l, ref t) =>\n+            cx.tcx.sess.span_bug(\n+                expr_span,\n+                &format!(\"Invalid literal/type combination: {:?},{:?}\", l, t))\n+    }\n+}\n+\n+fn convert_arm<'a,'tcx:'a>(cx: &Cx<'a,'tcx>, arm: &'tcx hir::Arm) -> Arm<Cx<'a,'tcx>> {\n+    let map = if arm.pats.len() == 1 {\n+        None\n+    } else {\n+        let mut map = FnvHashMap();\n+        pat_util::pat_bindings(&cx.tcx.def_map, &arm.pats[0], |_, p_id, _, path| {\n+            map.insert(path.node, p_id);\n+        });\n+        Some(Rc::new(map))\n+    };\n+\n+    Arm { patterns: arm.pats.iter().map(|p| PatNode::new(p, map.clone()).to_ref()).collect(),\n+          guard: arm.guard.to_ref(),\n+          body: arm.body.to_ref() }\n+}\n+\n+fn convert_path_expr<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n+                                 expr: &'tcx hir::Expr)\n+                                 -> ExprKind<Cx<'a,'tcx>>\n+{\n+    let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n+    match cx.tcx.def_map.borrow()[&expr.id].full_def() {\n+        def::DefVariant(_, def_id, false) |\n+        def::DefStruct(def_id) |\n+        def::DefFn(def_id, _) |\n+        def::DefConst(def_id) |\n+        def::DefMethod(def_id) |\n+        def::DefAssociatedConst(def_id) =>\n+            ExprKind::Literal {\n+                literal: Literal::Item { def_id: def_id, substs: substs }\n+            },\n+\n+        def::DefStatic(node_id, _) =>\n+            ExprKind::StaticRef {\n+                id: node_id,\n+            },\n+\n+        def @ def::DefLocal(..) |\n+        def @ def::DefUpvar(..) =>\n+            convert_var(cx, expr, def),\n+\n+        def =>\n+            cx.tcx.sess.span_bug(\n+                expr.span,\n+                &format!(\"def `{:?}` not yet implemented\", def)),\n+    }\n+}\n+\n+fn convert_var<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n+                           expr: &'tcx hir::Expr,\n+                           def: def::Def)\n+                           -> ExprKind<Cx<'a,'tcx>>\n+{\n+    let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n+\n+    match def {\n+        def::DefLocal(node_id) => {\n+            ExprKind::VarRef {\n+                id: node_id,\n+            }\n+        }\n+\n+        def::DefUpvar(id_var, index, closure_expr_id) => {\n+            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n+            let var_ty = cx.tcx.node_id_to_type(id_var);\n+\n+            let body_id = match cx.tcx.map.find(closure_expr_id) {\n+                Some(map::NodeExpr(expr)) => {\n+                    match expr.node {\n+                        hir::ExprClosure(_, _, ref body) => body.id,\n+                        _ => {\n+                            cx.tcx.sess.span_bug(expr.span,\n+                                              &format!(\"closure expr is not a closure expr\"));\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    cx.tcx.sess.span_bug(expr.span,\n+                                      &format!(\"ast-map has garbage for closure expr\"));\n+                }\n+            };\n+\n+            // FIXME free regions in closures are not right\n+            let closure_ty =\n+                cx.tcx.node_id_to_type(closure_expr_id);\n+\n+            // FIXME we're just hard-coding the idea that the\n+            // signature will be &self or &mut self and hence will\n+            // have a bound region with number 0\n+            let region =\n+                ty::Region::ReFree(\n+                    ty::FreeRegion {\n+                        scope: cx.tcx.region_maps.node_extent(body_id),\n+                        bound_region: ty::BoundRegion::BrAnon(0)\n+                    });\n+            let region =\n+                cx.tcx.mk_region(region);\n+\n+            let self_expr = match cx.tcx.closure_kind(DefId::local(closure_expr_id)) {\n+                ty::ClosureKind::FnClosureKind => {\n+                    let ref_closure_ty =\n+                        cx.tcx.mk_ref(region,\n+                                   ty::TypeAndMut { ty: closure_ty,\n+                                                    mutbl: hir::MutImmutable });\n+                    Expr {\n+                        ty: closure_ty,\n+                        temp_lifetime: temp_lifetime,\n+                        span: expr.span,\n+                        kind: ExprKind::Deref {\n+                            arg: Expr {\n+                                ty: ref_closure_ty,\n+                                temp_lifetime: temp_lifetime,\n+                                span: expr.span,\n+                                kind: ExprKind::SelfRef\n+                            }.to_ref()\n+                        }\n+                    }\n+                }\n+                ty::ClosureKind::FnMutClosureKind => {\n+                    let ref_closure_ty =\n+                        cx.tcx.mk_ref(region,\n+                                   ty::TypeAndMut { ty: closure_ty,\n+                                                    mutbl: hir::MutMutable });\n+                    Expr {\n+                        ty: closure_ty,\n+                        temp_lifetime: temp_lifetime,\n+                        span: expr.span,\n+                        kind: ExprKind::Deref {\n+                            arg: Expr {\n+                                ty: ref_closure_ty,\n+                                temp_lifetime: temp_lifetime,\n+                                span: expr.span,\n+                                kind: ExprKind::SelfRef\n+                            }.to_ref()\n+                        }\n+                    }\n+                }\n+                ty::ClosureKind::FnOnceClosureKind => {\n+                    Expr {\n+                        ty: closure_ty,\n+                        temp_lifetime: temp_lifetime,\n+                        span: expr.span,\n+                        kind: ExprKind::SelfRef\n+                    }\n+                }\n+            };\n+\n+            // at this point we have `self.n`, which loads up the upvar\n+            let field_kind =\n+                ExprKind::Field { lhs: self_expr.to_ref(),\n+                                  name: Field::Indexed(index) };\n+\n+            // ...but the upvar might be an `&T` or `&mut T` capture, at which\n+            // point we need an implicit deref\n+            let upvar_id = ty::UpvarId { var_id: id_var, closure_expr_id: closure_expr_id };\n+            let upvar_capture = match cx.tcx.upvar_capture(upvar_id) {\n+                Some(c) => c,\n+                None => {\n+                    cx.tcx.sess.span_bug(\n+                        expr.span,\n+                        &format!(\"no upvar_capture for {:?}\", upvar_id));\n+                }\n+            };\n+            match upvar_capture {\n+                ty::UpvarCapture::ByValue => field_kind,\n+                ty::UpvarCapture::ByRef(_) => {\n+                    ExprKind::Deref {\n+                        arg: Expr {\n+                            temp_lifetime: temp_lifetime,\n+                            ty: var_ty,\n+                            span: expr.span,\n+                            kind: field_kind,\n+                        }.to_ref()\n+                    }\n+                }\n+            }\n+        }\n+\n+        _ => cx.tcx.sess.span_bug(expr.span, \"type of & not region\")\n+    }\n+}\n+\n+\n+fn bin_op(op: hir::BinOp_) -> BinOp {\n+    match op {\n+        hir::BinOp_::BiAdd => BinOp::Add,\n+        hir::BinOp_::BiSub => BinOp::Sub,\n+        hir::BinOp_::BiMul => BinOp::Mul,\n+        hir::BinOp_::BiDiv => BinOp::Div,\n+        hir::BinOp_::BiRem => BinOp::Rem,\n+        hir::BinOp_::BiBitXor => BinOp::BitXor,\n+        hir::BinOp_::BiBitAnd => BinOp::BitAnd,\n+        hir::BinOp_::BiBitOr => BinOp::BitOr,\n+        hir::BinOp_::BiShl => BinOp::Shl,\n+        hir::BinOp_::BiShr => BinOp::Shr,\n+        hir::BinOp_::BiEq => BinOp::Eq,\n+        hir::BinOp_::BiLt => BinOp::Lt,\n+        hir::BinOp_::BiLe => BinOp::Le,\n+        hir::BinOp_::BiNe => BinOp::Ne,\n+        hir::BinOp_::BiGe => BinOp::Ge,\n+        hir::BinOp_::BiGt => BinOp::Gt,\n+        _ => panic!(\"no equivalent for ast binop {:?}\", op)\n+    }\n+}\n+\n+enum PassArgs {\n+    ByValue,\n+    ByRef\n+}\n+\n+fn overloaded_operator<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n+                                   expr: &'tcx hir::Expr,\n+                                   method_call: ty::MethodCall,\n+                                   pass_args: PassArgs,\n+                                   receiver: ExprRef<Cx<'a,'tcx>>,\n+                                   args: Vec<&'tcx P<hir::Expr>>)\n+                                   -> ExprKind<Cx<'a,'tcx>>\n+{\n+    // the receiver has all the adjustments that are needed, so we can\n+    // just push a reference to it\n+    let mut argrefs = vec![receiver];\n+\n+    // the arguments, unfortunately, do not, so if this is a ByRef\n+    // operator, we have to gin up the autorefs (but by value is easy)\n+    match pass_args {\n+        PassArgs::ByValue => {\n+            argrefs.extend(\n+                args.iter()\n+                    .map(|arg| arg.to_ref()))\n+        }\n+\n+        PassArgs::ByRef => {\n+            let scope = cx.tcx.region_maps.node_extent(expr.id);\n+            let region = cx.tcx.mk_region(ty::ReScope(scope));\n+            let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n+            argrefs.extend(\n+                args.iter()\n+                    .map(|arg| {\n+                        let arg_ty = cx.tcx.expr_ty_adjusted(arg);\n+                        let adjusted_ty =\n+                            cx.tcx.mk_ref(region,\n+                                       ty::TypeAndMut { ty: arg_ty,\n+                                                        mutbl: hir::MutImmutable });\n+                        Expr {\n+                            temp_lifetime: temp_lifetime,\n+                            ty: adjusted_ty,\n+                            span: expr.span,\n+                            kind: ExprKind::Borrow { region: *region,\n+                                                     borrow_kind: BorrowKind::Shared,\n+                                                     arg: arg.to_ref() }\n+                        }.to_ref()\n+                    }))\n+        }\n+    }\n+\n+    // now create the call itself\n+    let fun = method_callee(cx, expr, method_call);\n+    ExprKind::Call {\n+        fun: fun.to_ref(),\n+        args: argrefs,\n+    }\n+}\n+\n+fn overloaded_lvalue<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n+                                 expr: &'tcx hir::Expr,\n+                                 method_call: ty::MethodCall,\n+                                 pass_args: PassArgs,\n+                                 receiver: ExprRef<Cx<'a,'tcx>>,\n+                                 args: Vec<&'tcx P<hir::Expr>>)\n+                                 -> ExprKind<Cx<'a,'tcx>>\n+{\n+    // For an overloaded *x or x[y] expression of type T, the method\n+    // call returns an &T and we must add the deref so that the types\n+    // line up (this is because `*x` and `x[y]` represent lvalues):\n+\n+    // to find the type &T of the content returned by the method;\n+    let tables = cx.tcx.tables.borrow();\n+    let callee = &tables.method_map[&method_call];\n+    let ref_ty = callee.ty.fn_ret();\n+    let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap().unwrap();\n+    //                                              1~~~~~   2~~~~~\n+    // (1) callees always have all late-bound regions fully instantiated,\n+    // (2) overloaded methods don't return `!`\n+\n+    // construct the complete expression `foo()` for the overloaded call,\n+    // which will yield the &T type\n+    let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n+    let ref_kind = overloaded_operator(cx, expr, method_call, pass_args, receiver, args);\n+    let ref_expr = Expr {\n+        temp_lifetime: temp_lifetime,\n+        ty: ref_ty,\n+        span: expr.span,\n+        kind: ref_kind,\n+    };\n+\n+    // construct and return a deref wrapper `*foo()`\n+    ExprKind::Deref { arg: ref_expr.to_ref() }\n+}\n+\n+fn capture_freevar<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n+                               closure_expr: &'tcx hir::Expr,\n+                               freevar: &ty::Freevar,\n+                               freevar_ty: Ty<'tcx>)\n+                               -> ExprRef<Cx<'a,'tcx>> {\n+    let id_var = freevar.def.def_id().node;\n+    let upvar_id = ty::UpvarId { var_id: id_var, closure_expr_id: closure_expr.id };\n+    let upvar_capture = cx.tcx.upvar_capture(upvar_id).unwrap();\n+    let temp_lifetime = cx.tcx.region_maps.temporary_scope(closure_expr.id);\n+    let var_ty = cx.tcx.node_id_to_type(id_var);\n+    let captured_var = Expr { temp_lifetime: temp_lifetime,\n+                              ty: var_ty,\n+                              span: closure_expr.span,\n+                              kind: convert_var(cx, closure_expr, freevar.def) };\n+    match upvar_capture {\n+        ty::UpvarCapture::ByValue => {\n+            captured_var.to_ref()\n+        }\n+        ty::UpvarCapture::ByRef(upvar_borrow) => {\n+            let borrow_kind = match upvar_borrow.kind {\n+                ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n+                ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n+                ty::BorrowKind::MutBorrow => BorrowKind::Mut,\n+            };\n+            Expr {\n+                temp_lifetime: temp_lifetime,\n+                ty: freevar_ty,\n+                span: closure_expr.span,\n+                kind: ExprKind::Borrow { region: upvar_borrow.region,\n+                                         borrow_kind: borrow_kind,\n+                                         arg: captured_var.to_ref() }\n+            }.to_ref()\n+        }\n+    }\n+}\n+\n+fn loop_label<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n+                          expr: &'tcx hir::Expr)\n+                          -> CodeExtent\n+{\n+    match cx.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n+        Some(def::DefLabel(loop_id)) => cx.tcx.region_maps.node_extent(loop_id),\n+        d => {\n+            cx.tcx.sess.span_bug(\n+                expr.span,\n+                &format!(\"loop scope resolved to {:?}\", d));\n+        }\n+    }\n+}"}, {"sha": "2e9eae0956d9693700a6245cb5913aff269dbb51", "filename": "src/librustc_mir/tcx/mod.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hair::*;\n+use repr::*;\n+use std::fmt::{Debug, Formatter, Error};\n+use std::hash::{Hash, Hasher};\n+use std::rc::Rc;\n+\n+use self::rustc::middle::def_id::DefId;\n+use self::rustc::middle::infer::InferCtxt;\n+use self::rustc::middle::region::CodeExtent;\n+use self::rustc::middle::subst::{self, Subst, Substs};\n+use self::rustc::middle::ty::{self, Ty};\n+use self::rustc_front::hir;\n+use self::syntax::ast;\n+use self::syntax::codemap::Span;\n+use self::syntax::parse::token::{self, special_idents, InternedString};\n+\n+extern crate rustc;\n+extern crate rustc_front;\n+extern crate syntax;\n+\n+#[derive(Copy, Clone)]\n+pub struct Cx<'a,'tcx:'a> {\n+    pub tcx: &'a ty::ctxt<'tcx>,\n+    pub infcx: &'a InferCtxt<'a,'tcx>,\n+}\n+\n+impl<'a,'tcx> Cx<'a,'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a,'tcx>) -> Cx<'a,'tcx> {\n+        Cx { tcx: infcx.tcx, infcx: infcx }\n+    }\n+}\n+\n+pub use self::pattern::PatNode;\n+\n+impl<'a,'tcx:'a> Hair for Cx<'a, 'tcx> {\n+    type VarId = ast::NodeId;\n+    type DefId = DefId;\n+    type AdtDef = ty::AdtDef<'tcx>;\n+    type Name = ast::Name;\n+    type Ident = ast::Ident;\n+    type InternedString = InternedString;\n+    type Bytes = Rc<Vec<u8>>;\n+    type Span = Span;\n+    type Projection = ty::ProjectionTy<'tcx>;\n+    type Substs = &'tcx subst::Substs<'tcx>;\n+    type ClosureSubsts = &'tcx ty::ClosureSubsts<'tcx>;\n+    type Ty = Ty<'tcx>;\n+    type Region = ty::Region;\n+    type CodeExtent = CodeExtent;\n+    type Pattern = PatNode<'tcx>;\n+    type Expr = &'tcx hir::Expr;\n+    type Stmt = &'tcx hir::Stmt;\n+    type Block = &'tcx hir::Block;\n+    type InlineAsm = &'tcx hir::InlineAsm;\n+\n+    fn unit_ty(&mut self) -> Ty<'tcx> {\n+        self.tcx.mk_nil()\n+    }\n+\n+    fn usize_ty(&mut self) -> Ty<'tcx> {\n+        self.tcx.types.usize\n+    }\n+\n+    fn bool_ty(&mut self) -> Ty<'tcx> {\n+        self.tcx.types.bool\n+    }\n+\n+    fn partial_eq(&mut self, ty: Ty<'tcx>) -> ItemRef<Self> {\n+        let eq_def_id = self.tcx.lang_items.eq_trait().unwrap();\n+        self.cmp_method_ref(eq_def_id, \"eq\", ty)\n+    }\n+\n+    fn partial_le(&mut self, ty: Ty<'tcx>) -> ItemRef<Self> {\n+        let ord_def_id = self.tcx.lang_items.ord_trait().unwrap();\n+        self.cmp_method_ref(ord_def_id, \"le\", ty)\n+    }\n+\n+    fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {\n+        adt_def.variants.len()\n+    }\n+\n+    fn fields(&mut self, adt_def: ty::AdtDef<'tcx>, variant_index: usize) -> Vec<Field<Self>> {\n+        adt_def.variants[variant_index]\n+            .fields\n+            .iter()\n+            .enumerate()\n+            .map(|(index, field)| {\n+                if field.name == special_idents::unnamed_field.name {\n+                    Field::Indexed(index)\n+                } else {\n+                    Field::Named(field.name)\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    fn needs_drop(&mut self, ty: Ty<'tcx>, span: Self::Span) -> bool {\n+        if self.infcx.type_moves_by_default(ty, span) {\n+            // FIXME(#21859) we should do an add'l check here to determine if\n+            // any dtor will execute, but the relevant fn\n+            // (`type_needs_drop`) is currently factored into\n+            // `librustc_trans`, so we can't easily do so.\n+            true\n+        } else {\n+            // if type implements Copy, cannot require drop\n+            false\n+        }\n+    }\n+\n+    fn span_bug(&mut self, span: Self::Span, message: &str) -> ! {\n+        self.tcx.sess.span_bug(span, message)\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Cx<'a,'tcx> {\n+    fn cmp_method_ref(&mut self,\n+                      trait_def_id: DefId,\n+                      method_name: &str,\n+                      arg_ty: Ty<'tcx>)\n+                      -> ItemRef<Cx<'a,'tcx>> {\n+        let method_name = token::intern(method_name);\n+        let substs = Substs::new_trait(vec![arg_ty], vec![], arg_ty);\n+        for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n+            match *trait_item {\n+                ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n+                    if method.name == method_name {\n+                        let method_ty = self.tcx.lookup_item_type(method.def_id);\n+                        let method_ty = method_ty.ty.subst(self.tcx, &substs);\n+                        return ItemRef {\n+                            ty: method_ty,\n+                            def_id: method.def_id,\n+                            substs: self.tcx.mk_substs(substs),\n+                        };\n+                    }\n+                }\n+                ty::ImplOrTraitItem::ConstTraitItem(..) |\n+                ty::ImplOrTraitItem::TypeTraitItem(..) => {\n+                }\n+            }\n+        }\n+\n+        self.tcx.sess.bug(\n+            &format!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id));\n+    }\n+}\n+\n+// We only need this impl so that we do deriving for things that are\n+// defined relative to the `Hair` trait. See `Hair` trait for more\n+// details.\n+impl<'a,'tcx> PartialEq for Cx<'a,'tcx> {\n+    fn eq(&self, _: &Cx<'a,'tcx>) -> bool {\n+        panic!(\"Cx should never ACTUALLY be compared for equality\")\n+    }\n+}\n+\n+impl<'a,'tcx> Eq for Cx<'a,'tcx> { }\n+\n+impl<'a,'tcx> Hash for Cx<'a,'tcx> {\n+    fn hash<H: Hasher>(&self, _: &mut H) {\n+        panic!(\"Cx should never ACTUALLY be hashed\")\n+    }\n+}\n+\n+impl<'a,'tcx> Debug for Cx<'a,'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+        write!(fmt, \"Tcx\")\n+    }\n+}\n+\n+mod block;\n+mod expr;\n+mod pattern;\n+mod to_ref;\n+"}, {"sha": "eee0911f1cd9ef51708d89ba9b85b7cd1bb432c5", "filename": "src/librustc_mir/tcx/pattern.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,291 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hair::*;\n+use repr::*;\n+\n+use rustc_data_structures::fnv::FnvHashMap;\n+use std::rc::Rc;\n+use tcx::Cx;\n+use tcx::rustc::middle::const_eval::lookup_const_by_id;\n+use tcx::rustc::middle::def;\n+use tcx::rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n+use tcx::rustc::middle::ty::{self, Ty};\n+use tcx::rustc_front::hir;\n+use tcx::syntax::ast;\n+use tcx::syntax::ptr::P;\n+use tcx::to_ref::ToRef;\n+\n+/// When there are multiple patterns in a single arm, each one has its\n+/// own node-ids for the bindings.  References to the variables always\n+/// use the node-ids from the first pattern in the arm, so we just\n+/// remap the ids for all subsequent bindings to the first one.\n+///\n+/// Example:\n+/// ```\n+/// match foo {\n+///    Test1(flavor /* def 1 */) |\n+///    Test2(flavor /* def 2 */) if flavor /* ref 1 */.is_tasty() => { ... }\n+///    _ => { ... }\n+/// }\n+/// ```\n+#[derive(Clone, Debug)]\n+pub struct PatNode<'tcx> {\n+    pat: &'tcx hir::Pat,\n+    binding_map: Option<Rc<FnvHashMap<ast::Ident, ast::NodeId>>>\n+}\n+\n+impl<'tcx> PatNode<'tcx> {\n+    pub fn new(pat: &'tcx hir::Pat,\n+               binding_map: Option<Rc<FnvHashMap<ast::Ident, ast::NodeId>>>)\n+               -> PatNode<'tcx> {\n+        PatNode {\n+            pat: pat,\n+            binding_map: binding_map,\n+        }\n+    }\n+\n+    pub fn irrefutable(pat: &'tcx hir::Pat)\n+                       -> PatNode<'tcx> {\n+        PatNode::new(pat, None)\n+    }\n+\n+    fn pat_ref<'a>(&self, pat: &'tcx hir::Pat) -> PatternRef<Cx<'a,'tcx>> {\n+        PatNode::new(pat, self.binding_map.clone()).to_ref()\n+    }\n+\n+    fn pat_refs<'a>(&self, pats: &'tcx Vec<P<hir::Pat>>) -> Vec<PatternRef<Cx<'a,'tcx>>> {\n+        pats.iter().map(|p| self.pat_ref(p)).collect()\n+    }\n+\n+    fn opt_pat_ref<'a>(&self, pat: &'tcx Option<P<hir::Pat>>) -> Option<PatternRef<Cx<'a,'tcx>>> {\n+        pat.as_ref().map(|p| self.pat_ref(p))\n+    }\n+\n+    fn slice_or_array_pattern<'a>(&self,\n+                                  cx: &mut Cx<'a, 'tcx>,\n+                                  ty: Ty<'tcx>,\n+                                  prefix: &'tcx Vec<P<hir::Pat>>,\n+                                  slice: &'tcx Option<P<hir::Pat>>,\n+                                  suffix: &'tcx Vec<P<hir::Pat>>)\n+                                  -> PatternKind<Cx<'a,'tcx>>\n+    {\n+        match ty.sty {\n+            ty::TySlice(..) =>\n+                // matching a slice or fixed-length array\n+                PatternKind::Slice {\n+                    prefix: self.pat_refs(prefix),\n+                    slice: self.opt_pat_ref(slice),\n+                    suffix: self.pat_refs(suffix),\n+                },\n+\n+            ty::TyArray(_, len) => {\n+                // fixed-length array\n+                assert!(len >= prefix.len() + suffix.len());\n+                PatternKind::Array {\n+                    prefix: self.pat_refs(prefix),\n+                    slice: self.opt_pat_ref(slice),\n+                    suffix: self.pat_refs(suffix),\n+                }\n+            }\n+\n+            _ => {\n+                cx.tcx.sess.span_bug(\n+                    self.pat.span,\n+                    \"unexpanded macro or bad constant etc\");\n+            }\n+        }\n+    }\n+\n+    fn variant_or_leaf<'a>(&self,\n+                           cx: &mut Cx<'a, 'tcx>,\n+                           subpatterns: Vec<FieldPatternRef<Cx<'a,'tcx>>>)\n+                           -> PatternKind<Cx<'a,'tcx>>\n+    {\n+        let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n+        match def {\n+            def::DefVariant(enum_id, variant_id, _) => {\n+                let adt_def = cx.tcx.lookup_adt_def(enum_id);\n+                if adt_def.variants.len() > 1 {\n+                    PatternKind::Variant { adt_def: adt_def,\n+                                           variant_index: adt_def.variant_index_with_id(variant_id),\n+                                           subpatterns: subpatterns }\n+                } else {\n+                    PatternKind::Leaf { subpatterns: subpatterns }\n+                }\n+            }\n+\n+            // NB: resolving to DefStruct means the struct *constructor*,\n+            // not the struct as a type.\n+            def::DefStruct(..) | def::DefTy(..) => {\n+                PatternKind::Leaf { subpatterns: subpatterns }\n+            }\n+\n+            _ => {\n+                cx.tcx.sess.span_bug(\n+                    self.pat.span,\n+                    &format!(\"inappropriate def for pattern: {:?}\", def));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for PatNode<'tcx> {\n+    type Output = Pattern<Cx<'a,'tcx>>;\n+\n+    fn make_mirror(self, cx: &mut Cx<'a,'tcx>) -> Pattern<Cx<'a,'tcx>> {\n+        let kind = match self.pat.node {\n+            hir::PatWild(..) =>\n+                PatternKind::Wild,\n+\n+            hir::PatLit(ref lt) =>\n+                PatternKind::Constant { expr: lt.to_ref() },\n+\n+            hir::PatRange(ref begin, ref end) =>\n+                PatternKind::Range { lo: begin.to_ref(),\n+                                     hi: end.to_ref() },\n+\n+            hir::PatEnum(..) | hir::PatIdent(..) | hir::PatQPath(..)\n+                if pat_is_resolved_const(&cx.tcx.def_map, self.pat) =>\n+            {\n+                let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n+                match def {\n+                    def::DefConst(def_id) | def::DefAssociatedConst(def_id) =>\n+                        match lookup_const_by_id(cx.tcx, def_id, Some(self.pat.id)) {\n+                            Some(const_expr) =>\n+                                PatternKind::Constant { expr: const_expr.to_ref() },\n+                            None =>\n+                                cx.tcx.sess.span_bug(\n+                                    self.pat.span,\n+                                    &format!(\"cannot eval constant: {:?}\", def_id)),\n+                        },\n+                    _ =>\n+                        cx.tcx.sess.span_bug(\n+                            self.pat.span,\n+                            &format!(\"def not a constant: {:?}\", def)),\n+                }\n+            }\n+\n+            hir::PatRegion(ref subpattern, _) |\n+            hir::PatBox(ref subpattern) => {\n+                PatternKind::Deref { subpattern: self.pat_ref(subpattern) }\n+            }\n+\n+            hir::PatVec(ref prefix, ref slice, ref suffix) => {\n+                let ty = cx.tcx.node_id_to_type(self.pat.id);\n+                match ty.sty {\n+                    ty::TyRef(_, mt) =>\n+                        PatternKind::Deref {\n+                            subpattern: Pattern {\n+                                ty: mt.ty,\n+                                span: self.pat.span,\n+                                kind: self.slice_or_array_pattern(cx, mt.ty, prefix,\n+                                                                  slice, suffix),\n+                            }.to_ref()\n+                        },\n+\n+                    ty::TySlice(..) |\n+                    ty::TyArray(..) =>\n+                        self.slice_or_array_pattern(cx, ty, prefix, slice, suffix),\n+\n+                    ref sty =>\n+                        cx.tcx.sess.span_bug(\n+                            self.pat.span,\n+                            &format!(\"unexpanded type for vector pattern: {:?}\", sty)),\n+                }\n+            }\n+\n+            hir::PatTup(ref subpatterns) => {\n+                let subpatterns =\n+                    subpatterns.iter()\n+                               .enumerate()\n+                               .map(|(i, subpattern)| FieldPatternRef {\n+                                   field: Field::Indexed(i),\n+                                   pattern: self.pat_ref(subpattern),\n+                               })\n+                               .collect();\n+\n+                PatternKind::Leaf { subpatterns: subpatterns }\n+            }\n+\n+            hir::PatIdent(bm, ref ident, ref sub)\n+                if pat_is_binding(&cx.tcx.def_map, self.pat) =>\n+            {\n+                let id = match self.binding_map {\n+                    None => self.pat.id,\n+                    Some(ref map) => map[&ident.node],\n+                };\n+                let var_ty = cx.tcx.node_id_to_type(self.pat.id);\n+                let region = match var_ty.sty {\n+                    ty::TyRef(&r, _) => Some(r),\n+                    _ => None,\n+                };\n+                let (mutability, mode) = match bm {\n+                    hir::BindByValue(hir::MutMutable) =>\n+                        (Mutability::Mut, BindingMode::ByValue),\n+                    hir::BindByValue(hir::MutImmutable) =>\n+                        (Mutability::Not, BindingMode::ByValue),\n+                    hir::BindByRef(hir::MutMutable) =>\n+                        (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Mut)),\n+                    hir::BindByRef(hir::MutImmutable) =>\n+                        (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Shared)),\n+                };\n+                PatternKind::Binding {\n+                    mutability: mutability,\n+                    mode: mode,\n+                    name: ident.node,\n+                    var: id,\n+                    ty: var_ty,\n+                    subpattern: self.opt_pat_ref(sub),\n+                }\n+            }\n+\n+            hir::PatIdent(..) => {\n+                self.variant_or_leaf(cx, vec![])\n+            }\n+\n+            hir::PatEnum(_, ref opt_subpatterns) => {\n+                let subpatterns =\n+                    opt_subpatterns.iter()\n+                                   .flat_map(|v| v.iter())\n+                                   .enumerate()\n+                                   .map(|(i, field)| FieldPatternRef {\n+                                       field: Field::Indexed(i),\n+                                       pattern: self.pat_ref(field),\n+                                   })\n+                                   .collect();\n+                self.variant_or_leaf(cx, subpatterns)\n+            }\n+\n+            hir::PatStruct(_, ref fields, _) => {\n+                let subpatterns =\n+                    fields.iter()\n+                          .map(|field| FieldPatternRef {\n+                              field: Field::Named(field.node.ident.name),\n+                              pattern: self.pat_ref(&field.node.pat),\n+                          })\n+                          .collect();\n+                self.variant_or_leaf(cx, subpatterns)\n+            }\n+\n+            hir::PatQPath(..) => {\n+                cx.tcx.sess.span_bug(\n+                    self.pat.span,\n+                    \"unexpanded macro or bad constant etc\");\n+            }\n+        };\n+\n+        let ty = cx.tcx.node_id_to_type(self.pat.id);\n+\n+        Pattern { span: self.pat.span,\n+                  ty: ty,\n+                  kind: kind }\n+    }\n+}"}, {"sha": "6d5e4c2e3fd7a3e13682266d1b4c1cd70c727da3", "filename": "src/librustc_mir/tcx/to_ref.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hair::*;\n+use repr::*;\n+\n+use tcx::Cx;\n+use tcx::pattern::PatNode;\n+use tcx::rustc_front::hir;\n+use tcx::syntax::ptr::P;\n+\n+pub trait ToRef<H> {\n+    type Output;\n+    fn to_ref(self) -> Self::Output;\n+}\n+\n+impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for &'tcx hir::Expr {\n+    type Output = ExprRef<Cx<'a,'tcx>>;\n+\n+    fn to_ref(self) -> ExprRef<Cx<'a,'tcx>> {\n+        ExprRef::Hair(self)\n+    }\n+}\n+\n+impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for &'tcx P<hir::Expr> {\n+    type Output = ExprRef<Cx<'a,'tcx>>;\n+\n+    fn to_ref(self) -> ExprRef<Cx<'a,'tcx>> {\n+        ExprRef::Hair(&**self)\n+    }\n+}\n+\n+impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for Expr<Cx<'a,'tcx>> {\n+    type Output = ExprRef<Cx<'a,'tcx>>;\n+\n+    fn to_ref(self) -> ExprRef<Cx<'a,'tcx>> {\n+        ExprRef::Mirror(Box::new(self))\n+    }\n+}\n+\n+impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for PatNode<'tcx> {\n+    type Output = PatternRef<Cx<'a,'tcx>>;\n+\n+    fn to_ref(self) -> PatternRef<Cx<'a,'tcx>> {\n+        PatternRef::Hair(self)\n+    }\n+}\n+\n+impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for Pattern<Cx<'a,'tcx>> {\n+    type Output = PatternRef<Cx<'a,'tcx>>;\n+\n+    fn to_ref(self) -> PatternRef<Cx<'a,'tcx>> {\n+        PatternRef::Mirror(Box::new(self))\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T,U> ToRef<Cx<'a,'tcx>> for &'tcx Option<T>\n+    where &'tcx T: ToRef<Cx<'a,'tcx>, Output=U>\n+{\n+    type Output = Option<U>;\n+\n+    fn to_ref(self) -> Option<U> {\n+        self.as_ref().map(|expr| expr.to_ref())\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T,U> ToRef<Cx<'a,'tcx>> for &'tcx Vec<T>\n+    where &'tcx T: ToRef<Cx<'a,'tcx>, Output=U>\n+{\n+    type Output = Vec<U>;\n+\n+    fn to_ref(self) -> Vec<U> {\n+        self.iter().map(|expr| expr.to_ref()).collect()\n+    }\n+}\n+\n+impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for &'tcx hir::Field {\n+    type Output = FieldExprRef<Cx<'a,'tcx>>;\n+\n+    fn to_ref(self) -> FieldExprRef<Cx<'a,'tcx>> {\n+        FieldExprRef {\n+            name: Field::Named(self.ident.node.name),\n+            expr: self.expr.to_ref()\n+        }\n+    }\n+}\n+"}, {"sha": "cd5f2a2e76477f1a65cfa945d83ca5ce02173972", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -62,7 +62,7 @@ use rustc::middle::pat_util::pat_bindings;\n use rustc::middle::privacy::*;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n-use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n+use rustc::util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast;\n@@ -95,7 +95,6 @@ use rustc_front::hir::TypeImplItem;\n use rustc_front::util::walk_pat;\n \n use std::collections::{HashMap, HashSet};\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n@@ -1152,7 +1151,7 @@ pub struct Resolver<'a, 'tcx:'a> {\n \n     def_map: DefMap,\n     freevars: RefCell<FreevarMap>,\n-    freevars_seen: RefCell<NodeMap<NodeSet>>,\n+    freevars_seen: RefCell<NodeMap<NodeMap<usize>>>,\n     export_map: ExportMap,\n     trait_map: TraitMap,\n     external_exports: ExternalExports,\n@@ -1992,21 +1991,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         ClosureRibKind(function_id) => {\n                             let prev_def = def;\n-                            def = DefUpvar(node_id, function_id);\n \n                             let mut seen = self.freevars_seen.borrow_mut();\n-                            let seen = match seen.entry(function_id) {\n-                                Occupied(v) => v.into_mut(),\n-                                Vacant(v) => v.insert(NodeSet()),\n-                            };\n-                            if seen.contains(&node_id) {\n+                            let seen = seen.entry(function_id).or_insert_with(|| NodeMap());\n+                            if let Some(&index) = seen.get(&node_id) {\n+                                def = DefUpvar(node_id, index, function_id);\n                                 continue;\n                             }\n-                            match self.freevars.borrow_mut().entry(function_id) {\n-                                Occupied(v) => v.into_mut(),\n-                                Vacant(v) => v.insert(vec![]),\n-                            }.push(Freevar { def: prev_def, span: span });\n-                            seen.insert(node_id);\n+                            let mut freevars = self.freevars.borrow_mut();\n+                            let vec = freevars.entry(function_id)\n+                                              .or_insert_with(|| vec![]);\n+                            let depth = vec.len();\n+                            vec.push(Freevar { def: prev_def, span: span });\n+\n+                            def = DefUpvar(node_id, depth, function_id);\n+                            seen.insert(node_id, depth);\n                         }\n                         ItemRibKind | MethodRibKind => {\n                             // This was an attempt to access an upvar inside a"}, {"sha": "c6866004df949254f515bac2b5d81b2154c9e845", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -1428,19 +1428,19 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool {\n     let (vid, field) = match discr.node {\n         hir::ExprPath(..) => match bcx.def(discr.id) {\n-            def::DefLocal(vid) | def::DefUpvar(vid, _) => (vid, None),\n+            def::DefLocal(vid) | def::DefUpvar(vid, _, _) => (vid, None),\n             _ => return false\n         },\n         hir::ExprField(ref base, field) => {\n             let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n-                Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _)) => vid,\n+                Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::NamedField(field.node.name)))\n         },\n         hir::ExprTupField(ref base, field) => {\n             let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n-                Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _)) => vid,\n+                Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::PositionalField(field.node)))"}, {"sha": "7602956cb8e326bf1902116324fc9313857470d1", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -1319,7 +1319,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     match def {\n-        def::DefUpvar(nid, _) => {\n+        def::DefUpvar(nid, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             let lval = Lvalue::new_with_hint(\"expr::trans_local_var (upvar)\","}, {"sha": "b1fbf97d1a74b7d68e357e144c11a89271b9e36b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -4318,7 +4318,7 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 defn: def::Def)\n                                                 -> (TypeScheme<'tcx>, GenericPredicates<'tcx>) {\n     match defn {\n-        def::DefLocal(nid) | def::DefUpvar(nid, _) => {\n+        def::DefLocal(nid) | def::DefUpvar(nid, _, _) => {\n             let typ = fcx.local_ty(sp, nid);\n             (ty::TypeScheme { generics: ty::Generics::empty(), ty: typ },\n              ty::GenericPredicates::empty())"}, {"sha": "1cc2eaa62782126b351cadf69da8de4f7f388fda", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -272,13 +272,20 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                        feature\")),\n     (\"rustc_variance\", Normal, Gated(\"rustc_attrs\",\n                                      \"the `#[rustc_variance]` attribute \\\n-                                      is an experimental feature\")),\n+                                      is just used for rustc unit tests \\\n+                                      and will never be stable\")),\n     (\"rustc_error\", Whitelisted, Gated(\"rustc_attrs\",\n                                        \"the `#[rustc_error]` attribute \\\n-                                        is an experimental feature\")),\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\")),\n     (\"rustc_move_fragments\", Normal, Gated(\"rustc_attrs\",\n                                            \"the `#[rustc_move_fragments]` attribute \\\n-                                            is an experimental feature\")),\n+                                            is just used for rustc unit tests \\\n+                                            and will never be stable\")),\n+    (\"rustc_mir\", Normal, Gated(\"rustc_attrs\",\n+                                \"the `#[rustc_mir]` attribute \\\n+                                 is just used for rustc unit tests \\\n+                                 and will never be stable\")),\n \n     (\"allow_internal_unstable\", Normal, Gated(\"allow_internal_unstable\",\n                                               EXPLAIN_ALLOW_INTERNAL_UNSTABLE)),"}, {"sha": "bb5b70829a163a29a3426043f01e0644e131f878", "filename": "src/test/compile-fail/feature-gate-rustc-attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs?ref=3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "patch": "@@ -12,9 +12,9 @@\n \n // Test that `#[rustc_*]` attributes are gated by `rustc_attrs` feature gate.\n \n-#[rustc_variance] //~ ERROR the `#[rustc_variance]` attribute is an experimental feature\n-#[rustc_error] //~ ERROR the `#[rustc_error]` attribute is an experimental feature\n-#[rustc_move_fragments] //~ ERROR the `#[rustc_move_fragments]` attribute is an experimental feature\n+#[rustc_variance] //~ ERROR the `#[rustc_variance]` attribute is just used for rustc unit tests and will never be stable\n+#[rustc_error] //~ ERROR the `#[rustc_error]` attribute is just used for rustc unit tests and will never be stable\n+#[rustc_move_fragments] //~ ERROR the `#[rustc_move_fragments]` attribute is just used for rustc unit tests and will never be stable\n #[rustc_foo]\n //~^ ERROR unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics\n "}]}