{"sha": "a6e5a912f985278d610482733e3a5bbdfccb3c04", "node_id": "C_kwDOAAsO6NoAKGE2ZTVhOTEyZjk4NTI3OGQ2MTA0ODI3MzNlM2E1YmJkZmNjYjNjMDQ", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-16T15:42:40Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-16T15:42:40Z"}, "message": "Expand `format_args!` with more details", "tree": {"sha": "729a142387407638a584454da3696b2a8d8f195b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/729a142387407638a584454da3696b2a8d8f195b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6e5a912f985278d610482733e3a5bbdfccb3c04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6e5a912f985278d610482733e3a5bbdfccb3c04", "html_url": "https://github.com/rust-lang/rust/commit/a6e5a912f985278d610482733e3a5bbdfccb3c04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6e5a912f985278d610482733e3a5bbdfccb3c04/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbd14e98403dc5e19f19fdf913808656d81a0516", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbd14e98403dc5e19f19fdf913808656d81a0516", "html_url": "https://github.com/rust-lang/rust/commit/cbd14e98403dc5e19f19fdf913808656d81a0516"}], "stats": {"total": 189, "additions": 154, "deletions": 35}, "files": [{"sha": "12e01bc69c23ff59f87654a1ffbb030c92178863", "filename": "crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a6e5a912f985278d610482733e3a5bbdfccb3c04/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6e5a912f985278d610482733e3a5bbdfccb3c04/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=a6e5a912f985278d610482733e3a5bbdfccb3c04", "patch": "@@ -193,17 +193,17 @@ fn main() {\n     format_args!(\"{} {:?}\", arg1(a, b, c), arg2);\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n     ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n }\n \n fn main() {\n-    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(arg2), $crate::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[\"\", \" \", ], &[$crate::fmt::ArgumentV1::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(arg2), $crate::fmt::Debug::fmt), ]);\n }\n-\"#]],\n+\"##]],\n     );\n }\n \n@@ -221,17 +221,17 @@ fn main() {\n     format_args!(\"{} {:?}\", a::<A,B>(), b);\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n     ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n }\n \n fn main() {\n-    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(b), $crate::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[\"\", \" \", ], &[$crate::fmt::ArgumentV1::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(b), $crate::fmt::Debug::fmt), ]);\n }\n-\"#]],\n+\"##]],\n     );\n }\n \n@@ -250,7 +250,7 @@ fn main() {\n         format_args!/*+errors*/(\"{} {:?}\", a.);\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n@@ -259,10 +259,10 @@ macro_rules! format_args {\n \n fn main() {\n     let _ =\n-        /* parse error: expected field name or number */\n-$crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a.), $crate::fmt::Display::fmt), ]);\n+        /* error: no rule matches input tokens *//* parse error: expected field name or number */\n+$crate::fmt::Arguments::new_v1(&[\"\", \" \", ], &[$crate::fmt::ArgumentV1::new(&(a.), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(), $crate::fmt::Debug::fmt), ]);\n }\n-\"#]],\n+\"##]],\n     );\n }\n "}, {"sha": "3f9ea96545ce2364378049fd5d814dafb5f1a116", "filename": "crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 143, "deletions": 24, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/a6e5a912f985278d610482733e3a5bbdfccb3c04/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6e5a912f985278d610482733e3a5bbdfccb3c04/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=a6e5a912f985278d610482733e3a5bbdfccb3c04", "patch": "@@ -1,9 +1,13 @@\n //! Builtin macro\n \n+use std::mem;\n+\n+use ::tt::Ident;\n use base_db::{AnchoredPath, Edition, FileId};\n use cfg::CfgExpr;\n use either::Either;\n use mbe::{parse_exprs_with_sep, parse_to_token_tree, TokenMap};\n+use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, AstToken},\n     SmolStr,\n@@ -90,11 +94,6 @@ register_builtin! {\n     (module_path, ModulePath) => module_path_expand,\n     (assert, Assert) => assert_expand,\n     (stringify, Stringify) => stringify_expand,\n-    (format_args, FormatArgs) => format_args_expand,\n-    (const_format_args, ConstFormatArgs) => format_args_expand,\n-    // format_args_nl only differs in that it adds a newline in the end,\n-    // so we use the same stub expansion for now\n-    (format_args_nl, FormatArgsNl) => format_args_expand,\n     (llvm_asm, LlvmAsm) => asm_expand,\n     (asm, Asm) => asm_expand,\n     (global_asm, GlobalAsm) => global_asm_expand,\n@@ -106,6 +105,9 @@ register_builtin! {\n     (trace_macros, TraceMacros) => trace_macros_expand,\n \n     EAGER:\n+    (format_args, FormatArgs) => format_args_expand,\n+    (const_format_args, ConstFormatArgs) => format_args_expand,\n+    (format_args_nl, FormatArgsNl) => format_args_nl_expand,\n     (compile_error, CompileError) => compile_error_expand,\n     (concat, Concat) => concat_expand,\n     (concat_idents, ConcatIdents) => concat_idents_expand,\n@@ -232,42 +234,159 @@ fn file_expand(\n }\n \n fn format_args_expand(\n+    db: &dyn ExpandDatabase,\n+    id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<ExpandedEager> {\n+    format_args_expand_general(db, id, tt, \"\")\n+        .map(|x| ExpandedEager { subtree: x, included_file: None })\n+}\n+\n+fn format_args_nl_expand(\n+    db: &dyn ExpandDatabase,\n+    id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<ExpandedEager> {\n+    format_args_expand_general(db, id, tt, \"\\\\n\")\n+        .map(|x| ExpandedEager { subtree: x, included_file: None })\n+}\n+\n+fn format_args_expand_general(\n     _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n+    end_string: &str,\n ) -> ExpandResult<tt::Subtree> {\n-    // We expand `format_args!(\"\", a1, a2)` to\n-    // ```\n-    // $crate::fmt::Arguments::new_v1(&[], &[\n-    //   $crate::fmt::ArgumentV1::new(&arg1,$crate::fmt::Display::fmt),\n-    //   $crate::fmt::ArgumentV1::new(&arg2,$crate::fmt::Display::fmt),\n-    // ])\n-    // ```,\n-    // which is still not really correct, but close enough for now\n-    let mut args = parse_exprs_with_sep(tt, ',');\n+    let args = parse_exprs_with_sep(tt, ',');\n+\n+    let expand_error =\n+        ExpandResult::new(tt::Subtree::empty(), mbe::ExpandError::NoMatchingRule.into());\n \n     if args.is_empty() {\n-        return ExpandResult::new(tt::Subtree::empty(), mbe::ExpandError::NoMatchingRule.into());\n+        return expand_error;\n     }\n-    for arg in &mut args {\n+    let mut key_args = FxHashMap::default();\n+    let mut args = args.into_iter().filter_map(|mut arg| {\n         // Remove `key =`.\n         if matches!(arg.token_trees.get(1), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=')\n         {\n             // but not with `==`\n-            if !matches!(arg.token_trees.get(2), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=' )\n+            if !matches!(arg.token_trees.get(2), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=')\n             {\n-                arg.token_trees.drain(..2);\n+                let key = arg.token_trees.drain(..2).next().unwrap();\n+                key_args.insert(key.to_string(), arg);\n+                return None;\n+            }\n+        }\n+        Some(arg)\n+    }).collect::<Vec<_>>().into_iter();\n+    // ^^^^^^^ we need this collect, to enforce the side effect of the filter_map closure (building the `key_args`)\n+    let format_subtree = args.next().unwrap();\n+    let format_string = (|| {\n+        let token_tree = format_subtree.token_trees.get(0)?;\n+        match token_tree {\n+            tt::TokenTree::Leaf(l) => match l {\n+                tt::Leaf::Literal(l) => {\n+                    let text = l.text.strip_prefix('\"')?.strip_suffix('\"')?;\n+                    let span = l.span;\n+                    Some((text, span))\n+                }\n+                _ => None,\n+            },\n+            tt::TokenTree::Subtree(_) => None,\n+        }\n+    })();\n+    let Some((format_string, _format_string_span)) = format_string else {\n+        return expand_error;\n+    };\n+    let mut format_iter = format_string.chars().peekable();\n+    let mut parts = vec![];\n+    let mut last_part = String::new();\n+    let mut arg_tts = vec![];\n+    let mut err = None;\n+    while let Some(c) = format_iter.next() {\n+        // Parsing the format string. See https://doc.rust-lang.org/std/fmt/index.html#syntax for the grammar and more info\n+        match c {\n+            '{' => {\n+                if format_iter.peek() == Some(&'{') {\n+                    format_iter.next();\n+                    last_part.push('{');\n+                    continue;\n+                }\n+                let mut argument = String::new();\n+                while ![Some(&'}'), Some(&':')].contains(&format_iter.peek()) {\n+                    argument.push(match format_iter.next() {\n+                        Some(c) => c,\n+                        None => return expand_error,\n+                    });\n+                }\n+                let format_spec = match format_iter.next().unwrap() {\n+                    '}' => \"\".to_owned(),\n+                    ':' => {\n+                        let mut s = String::new();\n+                        while let Some(c) = format_iter.next() {\n+                            if c == '}' {\n+                                break;\n+                            }\n+                            s.push(c);\n+                        }\n+                        s\n+                    }\n+                    _ => unreachable!(),\n+                };\n+                parts.push(mem::take(&mut last_part));\n+                let arg_tree = if argument.is_empty() {\n+                    match args.next() {\n+                        Some(x) => x,\n+                        None => {\n+                            err = Some(mbe::ExpandError::NoMatchingRule.into());\n+                            tt::Subtree::empty()\n+                        }\n+                    }\n+                } else if let Some(tree) = key_args.get(&argument) {\n+                    tree.clone()\n+                } else {\n+                    // FIXME: we should pick the related substring of the `_format_string_span` as the span. You\n+                    // can use `.char_indices()` instead of `.char()` for `format_iter` to find the substring interval.\n+                    let ident = Ident::new(argument, tt::TokenId::unspecified());\n+                    quote!(#ident)\n+                };\n+                let formatter = match &*format_spec {\n+                    \"?\" => quote!(#DOLLAR_CRATE::fmt::Debug::fmt),\n+                    \"\" => quote!(#DOLLAR_CRATE::fmt::Display::fmt),\n+                    _ => {\n+                        // FIXME: implement the rest and return expand error here\n+                        quote!(#DOLLAR_CRATE::fmt::Display::fmt)\n+                    }\n+                };\n+                arg_tts.push(\n+                    quote! { #DOLLAR_CRATE::fmt::ArgumentV1::new(&(#arg_tree), #formatter), },\n+                );\n+            }\n+            '}' => {\n+                if format_iter.peek() == Some(&'}') {\n+                    format_iter.next();\n+                    last_part.push('}');\n+                } else {\n+                    return expand_error;\n+                }\n             }\n+            _ => last_part.push(c),\n         }\n     }\n-    let _format_string = args.remove(0);\n-    let arg_tts = args.into_iter().flat_map(|arg| {\n-        quote! { #DOLLAR_CRATE::fmt::ArgumentV1::new(&(#arg), #DOLLAR_CRATE::fmt::Display::fmt), }\n-    }.token_trees);\n+    last_part += end_string;\n+    if !last_part.is_empty() {\n+        parts.push(last_part);\n+    }\n+    let part_tts = parts.into_iter().map(|x| {\n+        let l = tt::Literal { span: tt::TokenId::unspecified(), text: format!(\"\\\"{}\\\"\", x).into() };\n+        quote!(#l ,)\n+    });\n+    let arg_tts = arg_tts.into_iter().flat_map(|arg| arg.token_trees);\n     let expanded = quote! {\n-        #DOLLAR_CRATE::fmt::Arguments::new_v1(&[], &[##arg_tts])\n+        #DOLLAR_CRATE::fmt::Arguments::new_v1(&[##part_tts], &[##arg_tts])\n     };\n-    ExpandResult::ok(expanded)\n+    ExpandResult { value: expanded, err }\n }\n \n fn asm_expand("}, {"sha": "327e1502d19e0a08b42482645c44ef6512e3109e", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_strings.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6e5a912f985278d610482733e3a5bbdfccb3c04/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/a6e5a912f985278d610482733e3a5bbdfccb3c04/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html?ref=a6e5a912f985278d610482733e3a5bbdfccb3c04", "patch": "@@ -171,5 +171,5 @@\n     <span class=\"macro\">assert</span><span class=\"macro_bang\">!</span><span class=\"parenthesis macro\">(</span><span class=\"bool_literal macro\">true</span><span class=\"comma macro\">,</span> <span class=\"string_literal macro\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\"> asdasd\"</span><span class=\"comma macro\">,</span> <span class=\"numeric_literal macro\">1</span><span class=\"parenthesis macro\">)</span><span class=\"semicolon\">;</span>\n     <span class=\"macro\">toho</span><span class=\"macro_bang\">!</span><span class=\"parenthesis macro\">(</span><span class=\"string_literal macro\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\">fmt\"</span><span class=\"comma macro\">,</span> <span class=\"numeric_literal macro\">0</span><span class=\"parenthesis macro\">)</span><span class=\"semicolon\">;</span>\n     <span class=\"macro unsafe\">asm</span><span class=\"macro_bang\">!</span><span class=\"parenthesis macro\">(</span><span class=\"string_literal macro\">\"mov eax, </span><span class=\"format_specifier\">{</span><span class=\"numeric_literal\">0</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\">\"</span><span class=\"parenthesis macro\">)</span><span class=\"semicolon\">;</span>\n-    <span class=\"macro\">format_args</span><span class=\"macro_bang\">!</span><span class=\"parenthesis macro\">(</span><span class=\"none macro\">concat</span><span class=\"punctuation macro\">!</span><span class=\"parenthesis macro\">(</span><span class=\"string_literal macro\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\">\"</span><span class=\"parenthesis macro\">)</span><span class=\"comma macro\">,</span> <span class=\"string_literal macro\">\"{}\"</span><span class=\"parenthesis macro\">)</span><span class=\"semicolon\">;</span>\n+    <span class=\"macro\">format_args</span><span class=\"macro_bang\">!</span><span class=\"parenthesis macro\">(</span><span class=\"none macro\">concat</span><span class=\"punctuation macro\">!</span><span class=\"parenthesis macro\">(</span><span class=\"string_literal macro\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\">\"</span><span class=\"parenthesis macro\">)</span><span class=\"comma macro\">,</span> <span class=\"string_literal macro\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\">\"</span><span class=\"parenthesis macro\">)</span><span class=\"semicolon\">;</span>\n <span class=\"brace\">}</span></code></pre>\n\\ No newline at end of file"}]}