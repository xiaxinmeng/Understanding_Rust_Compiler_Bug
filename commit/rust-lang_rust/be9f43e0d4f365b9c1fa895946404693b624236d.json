{"sha": "be9f43e0d4f365b9c1fa895946404693b624236d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlOWY0M2UwZDRmMzY1YjljMWZhODk1OTQ2NDA0NjkzYjYyNDIzNmQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-22T19:52:51Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-30T10:10:48Z"}, "message": "rustdoc: refactor(?) synthetic impl building.", "tree": {"sha": "9ca9103e3ddd3ce7addd6be2f0f2cbcb7b735f62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ca9103e3ddd3ce7addd6be2f0f2cbcb7b735f62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be9f43e0d4f365b9c1fa895946404693b624236d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be9f43e0d4f365b9c1fa895946404693b624236d", "html_url": "https://github.com/rust-lang/rust/commit/be9f43e0d4f365b9c1fa895946404693b624236d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be9f43e0d4f365b9c1fa895946404693b624236d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c835607907a6f7ed59938b591b50774872d9ac13", "url": "https://api.github.com/repos/rust-lang/rust/commits/c835607907a6f7ed59938b591b50774872d9ac13", "html_url": "https://github.com/rust-lang/rust/commit/c835607907a6f7ed59938b591b50774872d9ac13"}], "stats": {"total": 305, "additions": 106, "deletions": 199}, "files": [{"sha": "ec495506a42b74c06bef53a2b0ec2a87b120ddfd", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 23, "deletions": 56, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/be9f43e0d4f365b9c1fa895946404693b624236d/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9f43e0d4f365b9c1fa895946404693b624236d/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=be9f43e0d4f365b9c1fa895946404693b624236d", "patch": "@@ -44,7 +44,6 @@ impl<A> AutoTraitResult<A> {\n pub struct AutoTraitInfo<'cx> {\n     pub full_user_env: ty::ParamEnv<'cx>,\n     pub region_data: RegionConstraintData<'cx>,\n-    pub names_map: FxHashSet<String>,\n     pub vid_to_region: FxHashMap<ty::RegionVid, ty::Region<'cx>>,\n }\n \n@@ -78,15 +77,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     pub fn find_auto_trait_generics<A>(\n         &self,\n         ty: Ty<'tcx>,\n-        param_env_def_id: DefId,\n+        orig_env: ty::ParamEnv<'tcx>,\n         trait_did: DefId,\n-        generics: &ty::Generics,\n         auto_trait_callback: impl for<'i> Fn(&InferCtxt<'_, 'tcx, 'i>, AutoTraitInfo<'i>) -> A,\n     ) -> AutoTraitResult<A> {\n         let tcx = self.tcx;\n \n-        let orig_params = tcx.param_env(param_env_def_id);\n-\n         let trait_ref = ty::TraitRef {\n             def_id: trait_did,\n             substs: tcx.mk_substs_trait(ty, &[]),\n@@ -98,16 +94,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             let mut selcx = SelectionContext::with_negative(&infcx, true);\n             let result = selcx.select(&Obligation::new(\n                 ObligationCause::dummy(),\n-                orig_params,\n+                orig_env,\n                 trait_pred.to_poly_trait_predicate(),\n             ));\n \n             match result {\n                 Ok(Some(Vtable::VtableImpl(_))) => {\n                     debug!(\n-                        \"find_auto_trait_generics(ty={:?}, trait_did={:?}, generics={:?}): \\\n+                        \"find_auto_trait_generics({:?}): \\\n                          manual impl found, bailing out\",\n-                        ty, trait_did, generics\n+                        trait_ref\n                     );\n                     true\n                 }\n@@ -160,8 +156,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 &mut infcx,\n                 trait_did,\n                 ty,\n-                orig_params.clone(),\n-                orig_params,\n+                orig_env,\n+                orig_env,\n                 &mut fresh_preds,\n                 false,\n             ) {\n@@ -173,21 +169,21 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 &mut infcx,\n                 trait_did,\n                 ty,\n-                new_env.clone(),\n+                new_env,\n                 user_env,\n                 &mut fresh_preds,\n                 true,\n             ).unwrap_or_else(|| {\n                 panic!(\n                     \"Failed to fully process: {:?} {:?} {:?}\",\n-                    ty, trait_did, orig_params\n+                    ty, trait_did, orig_env\n                 )\n             });\n \n             debug!(\n-                \"find_auto_trait_generics(ty={:?}, trait_did={:?}, generics={:?}): fulfilling \\\n+                \"find_auto_trait_generics({:?}): fulfilling \\\n                  with {:?}\",\n-                ty, trait_did, generics, full_env\n+                trait_ref, full_env\n             );\n             infcx.clear_caches();\n \n@@ -209,23 +205,14 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 )\n             });\n \n-            let names_map: FxHashSet<String> = generics\n-                .params\n-                .iter()\n-                .filter_map(|param| match param.kind {\n-                    ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n-                    _ => None,\n-                })\n-                .collect();\n-\n             let body_id_map: FxHashMap<_, _> = infcx\n                 .region_obligations\n                 .borrow()\n                 .iter()\n                 .map(|&(id, _)| (id, vec![]))\n                 .collect();\n \n-            infcx.process_registered_region_obligations(&body_id_map, None, full_env.clone());\n+            infcx.process_registered_region_obligations(&body_id_map, None, full_env);\n \n             let region_data = infcx\n                 .borrow_region_constraints()\n@@ -237,7 +224,6 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             let info = AutoTraitInfo {\n                 full_user_env,\n                 region_data,\n-                names_map,\n                 vid_to_region,\n             };\n \n@@ -284,7 +270,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // the final synthesized generics: we don't want our generated docs page to contain something\n     // like 'T: Copy + Clone', as that's redundant. Therefore, we keep track of a separate\n     // 'user_env', which only holds the predicates that will actually be displayed to the user.\n-    pub fn evaluate_predicates<'b, 'gcx, 'c>(\n+    fn evaluate_predicates<'b, 'gcx, 'c>(\n         &self,\n         infcx: &InferCtxt<'b, 'tcx, 'c>,\n         trait_did: DefId,\n@@ -311,13 +297,13 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         let mut user_computed_preds: FxHashSet<_> =\n             user_env.caller_bounds.iter().cloned().collect();\n \n-        let mut new_env = param_env.clone();\n+        let mut new_env = param_env;\n         let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n \n         while let Some(pred) = predicates.pop_front() {\n             infcx.clear_caches();\n \n-            if !already_visited.insert(pred.clone()) {\n+            if !already_visited.insert(pred) {\n                 continue;\n             }\n \n@@ -365,7 +351,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         already_visited.remove(&pred);\n                         self.add_user_pred(\n                             &mut user_computed_preds,\n-                            ty::Predicate::Trait(pred.clone()),\n+                            ty::Predicate::Trait(pred),\n                         );\n                         predicates.push_back(pred);\n                     } else {\n@@ -384,7 +370,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n             computed_preds.extend(user_computed_preds.iter().cloned());\n             let normalized_preds =\n-                elaborate_predicates(tcx, computed_preds.clone().into_iter().collect());\n+                elaborate_predicates(tcx, computed_preds.iter().cloned().collect());\n             new_env = ty::ParamEnv::new(\n                 tcx.mk_predicates(normalized_preds),\n                 param_env.reveal,\n@@ -519,28 +505,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn region_name(&self, region: Region<'_>) -> Option<String> {\n-        match region {\n-            &ty::ReEarlyBound(r) => Some(r.name.to_string()),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn get_lifetime(&self, region: Region<'_>,\n-                        names_map: &FxHashMap<String, String>) -> String {\n-        self.region_name(region)\n-            .map(|name|\n-                names_map.get(&name).unwrap_or_else(||\n-                    panic!(\"Missing lifetime with name {:?} for {:?}\", name, region)\n-                )\n-            )\n-            .cloned()\n-            .unwrap_or_else(|| \"'static\".to_owned())\n-    }\n-\n     // This is very similar to handle_lifetimes. However, instead of matching ty::Region's\n     // to each other, we match ty::RegionVid's to ty::Region's\n-    pub fn map_vid_to_region<'cx>(\n+    fn map_vid_to_region<'cx>(\n         &self,\n         regions: &RegionConstraintData<'cx>,\n     ) -> FxHashMap<ty::RegionVid, ty::Region<'cx>> {\n@@ -650,7 +617,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn evaluate_nested_obligations<\n+    fn evaluate_nested_obligations<\n         'b,\n         'c,\n         'd,\n@@ -669,10 +636,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n \n         for (obligation, mut predicate) in nested\n-            .map(|o| (o.clone(), o.predicate.clone()))\n+            .map(|o| (o.clone(), o.predicate))\n         {\n             let is_new_pred =\n-                fresh_preds.insert(self.clean_pred(select.infcx(), predicate.clone()));\n+                fresh_preds.insert(self.clean_pred(select.infcx(), predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n             predicate = select.infcx().resolve_type_vars_if_possible(&predicate);\n@@ -690,14 +657,14 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n             match &predicate {\n-                &ty::Predicate::Trait(ref p) => {\n+                &ty::Predicate::Trait(p) => {\n                     if self.is_param_no_infer(p.skip_binder().trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred {\n \n                         self.add_user_pred(computed_preds, predicate);\n                     }\n-                    predicates.push_back(p.clone());\n+                    predicates.push_back(p);\n                 }\n                 &ty::Predicate::Projection(p) => {\n                     debug!(\"evaluate_nested_obligations: examining projection predicate {:?}\",\n@@ -739,7 +706,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     if p.ty().skip_binder().has_infer_types() {\n                         debug!(\"Projecting and unifying projection predicate {:?}\",\n                                predicate);\n-                        match poly_project_and_unify_type(select, &obligation.with(p.clone())) {\n+                        match poly_project_and_unify_type(select, &obligation.with(p)) {\n                             Err(e) => {\n                                 debug!(\n                                     \"evaluate_nested_obligations: Unable to unify predicate \\"}, {"sha": "11e8192521d79901d131832bf575f83964fb90f9", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 68, "deletions": 116, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/be9f43e0d4f365b9c1fa895946404693b624236d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9f43e0d4f365b9c1fa895946404693b624236d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=be9f43e0d4f365b9c1fa895946404693b624236d", "patch": "@@ -1,18 +1,18 @@\n use rustc::hir;\n-use rustc::traits::auto_trait as auto;\n+use rustc::traits::auto_trait::{self, AutoTraitResult};\n use rustc::ty::{self, TypeFoldable};\n use std::fmt::Debug;\n \n use super::*;\n \n pub struct AutoTraitFinder<'a, 'tcx> {\n     pub cx: &'a core::DocContext<'tcx>,\n-    pub f: auto::AutoTraitFinder<'a, 'tcx>,\n+    pub f: auto_trait::AutoTraitFinder<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     pub fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n-        let f = auto::AutoTraitFinder::new(cx.tcx);\n+        let f = auto_trait::AutoTraitFinder::new(cx.tcx);\n \n         AutoTraitFinder { cx, f }\n     }\n@@ -24,68 +24,66 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         param_env_def_id: DefId,\n     ) -> Vec<Item> {\n-        let generics = self.cx.tcx.generics_of(param_env_def_id);\n+        let param_env = self.cx.tcx.param_env(param_env_def_id);\n \n-        debug!(\n-            \"get_auto_trait_impls(param_env_def_id={:?}, generics={:?}\",\n-            param_env_def_id, generics\n-        );\n-        let auto_traits: Vec<_> = self.cx\n-            .send_trait\n-            .and_then(|send_trait| {\n-                self.get_auto_trait_impl_for(\n-                    ty,\n-                    param_env_def_id,\n-                    generics,\n-                    send_trait,\n-                )\n-            })\n-            .into_iter()\n-            .chain(self.get_auto_trait_impl_for(\n-                ty,\n-                param_env_def_id,\n-                generics,\n-                self.cx.tcx.require_lang_item(lang_items::SyncTraitLangItem),\n-            ).into_iter())\n-            .collect();\n-\n-        debug!(\n-            \"get_auto_traits: type {:?} auto_traits {:?}\",\n-            param_env_def_id, auto_traits\n+        debug!(\"get_auto_trait_impls({:?})\", ty);\n+        let auto_traits = self.cx.send_trait.into_iter().chain(\n+            Some(self.cx.tcx.require_lang_item(lang_items::SyncTraitLangItem))\n         );\n-        auto_traits\n-    }\n-\n-    fn get_auto_trait_impl_for(\n-        &self,\n-        ty: Ty<'tcx>,\n-        param_env_def_id: DefId,\n-        generics: &ty::Generics,\n-        trait_def_id: DefId,\n-    ) -> Option<Item> {\n-        if !self.cx\n-            .generated_synthetics\n-            .borrow_mut()\n-            .insert((param_env_def_id, trait_def_id))\n-        {\n-            debug!(\n-                \"get_auto_trait_impl_for(param_env_def_id={:?}, generics={:?}, \\\n-                 trait_def_id={:?}): already generated, aborting\",\n-                param_env_def_id, generics, trait_def_id\n-            );\n-            return None;\n-        }\n-\n-        let result = self.find_auto_trait_generics(ty, param_env_def_id, trait_def_id, &generics);\n-\n-        if result.is_auto() {\n+        auto_traits.filter_map(|trait_def_id| {\n             let trait_ref = ty::TraitRef {\n                 def_id: trait_def_id,\n                 substs: self.cx.tcx.mk_substs_trait(ty, &[]),\n             };\n+            if !self.cx\n+                .generated_synthetics\n+                .borrow_mut()\n+                .insert((ty, trait_def_id))\n+            {\n+                debug!(\n+                    \"get_auto_trait_impl_for({:?}): already generated, aborting\",\n+                    trait_ref\n+                );\n+                return None;\n+            }\n \n-            let polarity;\n+            let result = self.f.find_auto_trait_generics(\n+                ty,\n+                param_env,\n+                trait_def_id,\n+                |infcx, info| {\n+                    let region_data = info.region_data;\n+\n+                    let names_map = self.cx.tcx.generics_of(param_env_def_id)\n+                        .params\n+                        .iter()\n+                        .filter_map(|param| match param.kind {\n+                            ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n+                            _ => None,\n+                        })\n+                        .map(|name| (name.clone(), Lifetime(name)))\n+                        .collect();\n+                    let lifetime_predicates =\n+                        self.handle_lifetimes(&region_data, &names_map);\n+                    let new_generics = self.param_env_to_generics(\n+                        infcx.tcx,\n+                        param_env_def_id,\n+                        info.full_user_env,\n+                        lifetime_predicates,\n+                        info.vid_to_region,\n+                    );\n \n+                    debug!(\n+                        \"find_auto_trait_generics(param_env_def_id={:?}, trait_def_id={:?}): \\\n+                            finished with {:?}\",\n+                        param_env_def_id, trait_def_id, new_generics\n+                    );\n+\n+                    new_generics\n+                },\n+            );\n+\n+            let polarity;\n             let new_generics = match result {\n                 AutoTraitResult::PositiveImpl(new_generics) => {\n                     polarity = None;\n@@ -106,21 +104,18 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     // Instead, we generate `impl !Send for Foo<T>`, which better\n                     // expresses the fact that `Foo<T>` never implements `Send`,\n                     // regardless of the choice of `T`.\n-                    let real_generics = (generics, &Default::default());\n-\n-                    // Clean the generics, but ignore the '?Sized' bounds generated\n-                    // by the `Clean` impl\n-                    let clean_generics = real_generics.clean(self.cx);\n+                    let params = (self.cx.tcx.generics_of(param_env_def_id), &Default::default())\n+                        .clean(self.cx).params;\n \n                     Generics {\n-                        params: clean_generics.params,\n+                        params,\n                         where_predicates: Vec::new(),\n                     }\n                 }\n-                _ => unreachable!(),\n+                AutoTraitResult::ExplicitImpl => return None,\n             };\n \n-            return Some(Item {\n+            Some(Item {\n                 source: Span::empty(),\n                 name: None,\n                 attrs: Default::default(),\n@@ -139,49 +134,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     synthetic: true,\n                     blanket_impl: None,\n                 }),\n-            });\n-        }\n-        None\n-    }\n-\n-    fn find_auto_trait_generics(\n-        &self,\n-        ty: Ty<'tcx>,\n-        param_env_def_id: DefId,\n-        trait_did: DefId,\n-        generics: &ty::Generics,\n-    ) -> AutoTraitResult {\n-        match self.f.find_auto_trait_generics(ty, param_env_def_id, trait_did, generics,\n-                |infcx, mut info| {\n-                    let region_data = info.region_data;\n-                    let names_map =\n-                        info.names_map\n-                            .drain()\n-                            .map(|name| (name.clone(), Lifetime(name)))\n-                            .collect();\n-                    let lifetime_predicates =\n-                        self.handle_lifetimes(&region_data, &names_map);\n-                    let new_generics = self.param_env_to_generics(\n-                        infcx.tcx,\n-                        param_env_def_id,\n-                        info.full_user_env,\n-                        generics,\n-                        lifetime_predicates,\n-                        info.vid_to_region,\n-                    );\n-\n-                    debug!(\n-                        \"find_auto_trait_generics(ty={:?}, trait_did={:?}, generics={:?}): \\\n-                         finished with {:?}\",\n-                        ty, trait_did, generics, new_generics\n-                    );\n-\n-                    new_generics\n-                }) {\n-            auto::AutoTraitResult::ExplicitImpl => AutoTraitResult::ExplicitImpl,\n-            auto::AutoTraitResult::NegativeImpl => AutoTraitResult::NegativeImpl,\n-            auto::AutoTraitResult::PositiveImpl(res) => AutoTraitResult::PositiveImpl(res),\n-        }\n+            })\n+        }).collect()\n     }\n \n     fn get_lifetime(\n@@ -497,14 +451,13 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         tcx: TyCtxt<'b, 'c, 'cx>,\n         param_env_def_id: DefId,\n         param_env: ty::ParamEnv<'cx>,\n-        type_generics: &ty::Generics,\n         mut existing_predicates: Vec<WherePredicate>,\n         vid_to_region: FxHashMap<ty::RegionVid, ty::Region<'cx>>,\n     ) -> Generics {\n         debug!(\n-            \"param_env_to_generics(param_env_def_id={:?}, param_env={:?}, type_generics={:?}, \\\n+            \"param_env_to_generics(param_env_def_id={:?}, param_env={:?}, \\\n              existing_predicates={:?})\",\n-            param_env_def_id, param_env, type_generics, existing_predicates\n+            param_env_def_id, param_env, existing_predicates\n         );\n \n         // The `Sized` trait must be handled specially, since we only display it when\n@@ -534,11 +487,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 (replaced.clone(), replaced.clean(self.cx))\n             });\n \n-        let full_generics = (type_generics, &tcx.explicit_predicates_of(param_env_def_id));\n-        let Generics {\n-            params: mut generic_params,\n-            ..\n-        } = full_generics.clean(self.cx);\n+        let mut generic_params = (\n+            tcx.generics_of(param_env_def_id),\n+            &tcx.explicit_predicates_of(param_env_def_id),\n+        ).clean(self.cx).params;\n \n         let mut has_sized = FxHashSet::default();\n         let mut ty_to_bounds: FxHashMap<_, FxHashSet<_>> = Default::default();"}, {"sha": "5c42d705bd579e155bff1345a4a1cd24b5c9f25d", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be9f43e0d4f365b9c1fa895946404693b624236d/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9f43e0d4f365b9c1fa895946404693b624236d/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=be9f43e0d4f365b9c1fa895946404693b624236d", "patch": "@@ -25,23 +25,23 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         param_env_def_id: DefId,\n     ) -> Vec<Item> {\n-        debug!(\"get_blanket_impls(param_env_def_id={:?}, ...)\", param_env_def_id);\n-        let mut impls = Vec::new();\n         let param_env = self.cx.tcx.param_env(param_env_def_id);\n+\n+        debug!(\"get_blanket_impls({:?})\", ty);\n+        let mut impls = Vec::new();\n         for &trait_def_id in self.cx.all_traits.iter() {\n             if !self.cx.renderinfo.borrow().access_levels.is_doc_reachable(trait_def_id) ||\n                self.cx.generated_synthetics\n                       .borrow_mut()\n-                      .get(&(param_env_def_id, trait_def_id))\n+                      .get(&(ty, trait_def_id))\n                       .is_some() {\n                 continue\n             }\n             self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n+                debug!(\"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n+                        trait_def_id, impl_def_id);\n                 let trait_ref = self.cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let may_apply = self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                    debug!(\"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n-                           trait_def_id, impl_def_id);\n-\n                     match trait_ref.self_ty().sty {\n                         ty::Param(_) => {},\n                         _ => return false,\n@@ -84,12 +84,12 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                 debug!(\"get_blanket_impls: found applicable impl: {}\\\n                         for trait_ref={:?}, ty={:?}\",\n                         may_apply, trait_ref, ty);\n-\n                 if !may_apply {\n-                    return\n+                    return;\n                 }\n+\n                 self.cx.generated_synthetics.borrow_mut()\n-                                            .insert((param_env_def_id, trait_def_id));\n+                                            .insert((ty, trait_def_id));\n                 let provided_trait_methods =\n                     self.cx.tcx.provided_trait_methods(trait_def_id)\n                                 .into_iter()\n@@ -111,6 +111,8 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             &self.cx.tcx.explicit_predicates_of(impl_def_id),\n                         ).clean(self.cx),\n                         provided_trait_methods,\n+                        // FIXME(eddyb) compute both `trait_` and `for_` from\n+                        // the post-inference `trait_ref`, as it's more accurate.\n                         trait_: Some(trait_ref.clean(self.cx).get_trait_type().unwrap()),\n                         for_: ty.clean(self.cx),\n                         items: self.cx.tcx.associated_items(impl_def_id)"}, {"sha": "dd4900cfaeec60b2fc2dbcfbc079fcca61b86c6d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/be9f43e0d4f365b9c1fa895946404693b624236d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9f43e0d4f365b9c1fa895946404693b624236d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=be9f43e0d4f365b9c1fa895946404693b624236d", "patch": "@@ -4452,21 +4452,6 @@ enum SimpleBound {\n     Outlives(Lifetime),\n }\n \n-enum AutoTraitResult {\n-    ExplicitImpl,\n-    PositiveImpl(Generics),\n-    NegativeImpl,\n-}\n-\n-impl AutoTraitResult {\n-    fn is_auto(&self) -> bool {\n-        match *self {\n-            AutoTraitResult::PositiveImpl(_) | AutoTraitResult::NegativeImpl => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n impl From<GenericBound> for SimpleBound {\n     fn from(bound: GenericBound) -> Self {\n         match bound.clone() {"}, {"sha": "831adb301efcb2d3c8cae20844b00f0d182396bc", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/be9f43e0d4f365b9c1fa895946404693b624236d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9f43e0d4f365b9c1fa895946404693b624236d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=be9f43e0d4f365b9c1fa895946404693b624236d", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::def::Def;\n use rustc::hir::HirId;\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{Ty, TyCtxt};\n use rustc::lint::{self, LintPass};\n use rustc::session::config::ErrorOutputType;\n use rustc::session::DiagnosticOutput;\n@@ -70,8 +70,9 @@ pub struct DocContext<'tcx> {\n     pub send_trait: Option<DefId>,\n     pub fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n     pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n-    /// Maps (type_id, trait_id) -> auto trait impl\n-    pub generated_synthetics: RefCell<FxHashSet<(DefId, DefId)>>,\n+    /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n+    // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n+    pub generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n     pub all_traits: Vec<DefId>,\n }\n "}]}