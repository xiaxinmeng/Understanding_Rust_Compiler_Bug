{"sha": "4305b67d316394da2483213fdbf80d321507bad2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMDViNjdkMzE2Mzk0ZGEyNDgzMjEzZmRiZjgwZDMyMTUwN2JhZDI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-21T05:44:38Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-21T19:02:02Z"}, "message": "statements and expressions", "tree": {"sha": "569d6bcb7894de9cb35241ea1879be28b1780f9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/569d6bcb7894de9cb35241ea1879be28b1780f9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4305b67d316394da2483213fdbf80d321507bad2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4305b67d316394da2483213fdbf80d321507bad2", "html_url": "https://github.com/rust-lang/rust/commit/4305b67d316394da2483213fdbf80d321507bad2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4305b67d316394da2483213fdbf80d321507bad2/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c5e17a2e560d3fe2ec28884ad191433616f3e8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5e17a2e560d3fe2ec28884ad191433616f3e8f", "html_url": "https://github.com/rust-lang/rust/commit/0c5e17a2e560d3fe2ec28884ad191433616f3e8f"}], "stats": {"total": 127, "additions": 67, "deletions": 60}, "files": [{"sha": "e2fb41e424bef281152ed274bd0f146f2b1b8491", "filename": "src/doc/reference/src/expressions.md", "status": "modified", "additions": 64, "deletions": 57, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4305b67d316394da2483213fdbf80d321507bad2/src%2Fdoc%2Freference%2Fsrc%2Fexpressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/4305b67d316394da2483213fdbf80d321507bad2/src%2Fdoc%2Freference%2Fsrc%2Fexpressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fexpressions.md?ref=4305b67d316394da2483213fdbf80d321507bad2", "patch": "@@ -79,17 +79,17 @@ Here are some examples:\n \n ### Moved and copied types\n \n-When a [local variable](#variables) is used as an\n-[rvalue](#lvalues-rvalues-and-temporaries), the variable will be copied\n-if its type implements `Copy`. All others are moved.\n+When a [local variable](variables.html) is used as an\n+[rvalue](expressions.html#lvalues-rvalues-and-temporaries), the variable will\n+be copied if its type implements `Copy`. All others are moved.\n \n ## Literal expressions\n \n-A _literal expression_ consists of one of the [literal](#literals) forms\n+A _literal expression_ consists of one of the [literal](tokens.md#literals) forms\n described earlier. It directly describes a number, character, string, boolean\n value, or the unit value.\n \n-```{.literals}\n+```text\n ();        // unit type\n \"hello\";   // string type\n '5';       // character type\n@@ -98,13 +98,15 @@ value, or the unit value.\n \n ## Path expressions\n \n-A [path](#paths) used as an expression context denotes either a local variable\n-or an item. Path expressions are [lvalues](#lvalues-rvalues-and-temporaries).\n+A [path](paths.html) used as an expression context denotes either a local\n+variable or an item. Path expressions are\n+[lvalues](expressions.html#lvalues-rvalues-and-temporaries).\n \n ## Tuple expressions\n \n Tuples are written by enclosing zero or more comma-separated expressions in\n-parentheses. They are used to create [tuple-typed](#tuple-types) values.\n+parentheses. They are used to create [tuple-typed](types.html#tuple-types)\n+values.\n \n ```{.tuple}\n (0.0, 4.5);\n@@ -122,21 +124,20 @@ comma:\n ## Struct expressions\n \n There are several forms of struct expressions. A _struct expression_\n-consists of the [path](#paths) of a [struct item](#structs), followed by\n-a brace-enclosed list of zero or more comma-separated name-value pairs,\n-providing the field values of a new instance of the struct. A field name\n-can be any identifier, and is separated from its value expression by a colon.\n-The location denoted by a struct field is mutable if and only if the\n-enclosing struct is mutable.\n+consists of the [path](#paths) of a [struct item](items.html#structs), followed\n+by a brace-enclosed list of zero or more comma-separated name-value pairs,\n+providing the field values of a new instance of the struct. A field name can be\n+any identifier, and is separated from its value expression by a colon.  The\n+location denoted by a struct field is mutable if and only if the enclosing\n+struct is mutable.\n \n A _tuple struct expression_ consists of the [path](#paths) of a [struct\n-item](#structs), followed by a parenthesized list of one or more\n-comma-separated expressions (in other words, the path of a struct item\n-followed by a tuple expression). The struct item must be a tuple struct\n-item.\n+item](items.html#structs), followed by a parenthesized list of one or more\n+comma-separated expressions (in other words, the path of a struct item followed\n+by a tuple expression). The struct item must be a tuple struct item.\n \n A _unit-like struct expression_ consists only of the [path](#paths) of a\n-[struct item](#structs).\n+[struct item](items.html#structs).\n \n The following are examples of struct expressions:\n \n@@ -216,24 +217,24 @@ A _method call_ consists of an expression followed by a single dot, an\n identifier, and a parenthesized expression-list. Method calls are resolved to\n methods on specific traits, either statically dispatching to a method if the\n exact `self`-type of the left-hand-side is known, or dynamically dispatching if\n-the left-hand-side expression is an indirect [trait object](#trait-objects).\n+the left-hand-side expression is an indirect [trait object](trait-objects.html).\n \n ## Field expressions\n \n A _field expression_ consists of an expression followed by a single dot and an\n identifier, when not immediately followed by a parenthesized expression-list\n (the latter is a [method call expression](#method-call-expressions)). A field\n-expression denotes a field of a [struct](#struct-types).\n+expression denotes a field of a [struct](types.html#struct-types).\n \n ```{.ignore .field}\n mystruct.myfield;\n foo().x;\n (Struct {a: 10, b: 20}).a;\n ```\n \n-A field access is an [lvalue](#lvalues-rvalues-and-temporaries) referring to\n-the value of that field. When the type providing the field inherits mutability,\n-it can be [assigned](#assignment-expressions) to.\n+A field access is an [lvalue](expressions.html#lvalues-rvalues-and-temporaries)\n+referring to the value of that field. When the type providing the field\n+inherits mutability, it can be [assigned](#assignment-expressions) to.\n \n Also, if the type of the expression to the left of the dot is a\n pointer, it is automatically dereferenced as many times as necessary\n@@ -242,12 +243,13 @@ fewer autoderefs to more.\n \n ## Array expressions\n \n-An [array](#array-and-slice-types) _expression_ is written by enclosing zero\n-or more comma-separated expressions of uniform type in square brackets.\n+An [array](types.html#array-and-slice-types) _expression_ is written by\n+enclosing zero or more comma-separated expressions of uniform type in square\n+brackets.\n \n In the `[expr ';' expr]` form, the expression after the `';'` must be a\n constant expression that can be evaluated at compile time, such as a\n-[literal](#literals) or a [static item](#static-items).\n+[literal](tokens.html#literals) or a [static item](items.html#static-items).\n \n ```\n [1, 2, 3, 4];\n@@ -258,14 +260,15 @@ constant expression that can be evaluated at compile time, such as a\n \n ## Index expressions\n \n-[Array](#array-and-slice-types)-typed expressions can be indexed by\n+[Array](types.html#array-and-slice-types)-typed expressions can be indexed by\n writing a square-bracket-enclosed expression (the index) after them. When the\n-array is mutable, the resulting [lvalue](#lvalues-rvalues-and-temporaries) can\n-be assigned to.\n+array is mutable, the resulting\n+[lvalue](expressions.html#lvalues-rvalues-and-temporaries) can be assigned to.\n \n Indices are zero-based, and may be of any integral type. Vector access is\n-bounds-checked at compile-time for constant arrays being accessed with a constant index value.\n-Otherwise a check will be performed at run-time that will put the thread in a _panicked state_ if it fails.\n+bounds-checked at compile-time for constant arrays being accessed with a\n+constant index value.  Otherwise a check will be performed at run-time that\n+will put the thread in a _panicked state_ if it fails.\n \n ```{should-fail}\n ([1, 2, 3, 4])[0];\n@@ -333,14 +336,15 @@ all written as prefix operators, before the expression they apply to.\n     is an error to apply negation to unsigned types; for example, the compiler\n     rejects `-1u32`.\n * `*`\n-  : Dereference. When applied to a [pointer](#pointer-types) it denotes the\n-    pointed-to location. For pointers to mutable locations, the resulting\n-    [lvalue](#lvalues-rvalues-and-temporaries) can be assigned to.\n-    On non-pointer types, it calls the `deref` method of the `std::ops::Deref`\n-    trait, or the `deref_mut` method of the `std::ops::DerefMut` trait (if\n-    implemented by the type and required for an outer expression that will or\n-    could mutate the dereference), and produces the result of dereferencing the\n-    `&` or `&mut` borrowed pointer returned from the overload method.\n+  : Dereference. When applied to a [pointer](types.html#pointer-types) it\n+    denotes the pointed-to location. For pointers to mutable locations, the\n+    resulting [lvalue](expressions.html#lvalues-rvalues-and-temporaries) can be\n+    assigned to.  On non-pointer types, it calls the `deref` method of the\n+    `std::ops::Deref` trait, or the `deref_mut` method of the\n+    `std::ops::DerefMut` trait (if implemented by the type and required for an\n+    outer expression that will or could mutate the dereference), and produces\n+    the result of dereferencing the `&` or `&mut` borrowed pointer returned\n+    from the overload method.\n * `!`\n   : Logical negation. On the boolean type, this flips between `true` and\n     `false`. On integer types, this inverts the individual bits in the\n@@ -480,8 +484,9 @@ surprising side-effects on the dynamic execution semantics.\n ### Assignment expressions\n \n An _assignment expression_ consists of an\n-[lvalue](#lvalues-rvalues-and-temporaries) expression followed by an equals\n-sign (`=`) and an [rvalue](#lvalues-rvalues-and-temporaries) expression.\n+[lvalue](expressions.html#lvalues-rvalues-and-temporaries) expression followed\n+by an equals sign (`=`) and an\n+[rvalue](expressions.html#lvalues-rvalues-and-temporaries) expression.\n \n Evaluating an assignment expression [either copies or\n moves](#moved-and-copied-types) its right-hand operand to its left-hand\n@@ -571,15 +576,16 @@ Lambda expressions are most useful when passing functions as arguments to other\n functions, as an abbreviation for defining and capturing a separate function.\n \n Significantly, lambda expressions _capture their environment_, which regular\n-[function definitions](#functions) do not. The exact type of capture depends\n-on the [function type](#function-types) inferred for the lambda expression. In\n-the simplest and least-expensive form (analogous to a ```|| { }``` expression),\n-the lambda expression captures its environment by reference, effectively\n-borrowing pointers to all outer variables mentioned inside the function.\n-Alternately, the compiler may infer that a lambda expression should copy or\n-move values (depending on their type) from the environment into the lambda\n-expression's captured environment. A lambda can be forced to capture its\n-environment by moving values by prefixing it with the `move` keyword.\n+[function definitions](items.html#functions) do not. The exact type of capture\n+depends on the [function type](types.html#function-types) inferred for the\n+lambda expression. In the simplest and least-expensive form (analogous to a\n+```|| { }``` expression), the lambda expression captures its environment by\n+reference, effectively borrowing pointers to all outer variables mentioned\n+inside the function.  Alternately, the compiler may infer that a lambda\n+expression should copy or move values (depending on their type) from the\n+environment into the lambda expression's captured environment. A lambda can be\n+forced to capture its environment by moving values by prefixing it with the\n+`move` keyword.\n \n In this example, we define a function `ten_times` that takes a higher-order\n function argument, and we then call it with a lambda expression as an argument,\n@@ -715,12 +721,13 @@ stands for a *single* data field, whereas a wildcard `..` stands for *all* the\n fields of a particular variant.\n \n A `match` behaves differently depending on whether or not the head expression\n-is an [lvalue or an rvalue](#lvalues-rvalues-and-temporaries). If the head\n-expression is an rvalue, it is first evaluated into a temporary location, and\n-the resulting value is sequentially compared to the patterns in the arms until\n-a match is found. The first arm with a matching pattern is chosen as the branch\n-target of the `match`, any variables bound by the pattern are assigned to local\n-variables in the arm's block, and control enters the block.\n+is an [lvalue or an rvalue](expressions.html#lvalues-rvalues-and-temporaries).\n+If the head expression is an rvalue, it is first evaluated into a temporary\n+location, and the resulting value is sequentially compared to the patterns in\n+the arms until a match is found. The first arm with a matching pattern is\n+chosen as the branch target of the `match`, any variables bound by the pattern\n+are assigned to local variables in the arm's block, and control enters the\n+block.\n \n When the head expression is an lvalue, the match does not allocate a temporary\n location (however, a by-value binding may copy or move from the lvalue). When"}, {"sha": "ebb7d8bfa7cd057dcf0fe9f10b45f0267296848a", "filename": "src/doc/reference/src/statements.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4305b67d316394da2483213fdbf80d321507bad2/src%2Fdoc%2Freference%2Fsrc%2Fstatements.md", "raw_url": "https://github.com/rust-lang/rust/raw/4305b67d316394da2483213fdbf80d321507bad2/src%2Fdoc%2Freference%2Fsrc%2Fstatements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fstatements.md?ref=4305b67d316394da2483213fdbf80d321507bad2", "patch": "@@ -1,7 +1,7 @@\n # Statements\n \n A _statement_ is a component of a block, which is in turn a component of an\n-outer [expression](#expressions) or [function](#functions).\n+outer [expression](expressions.html) or [function](items.html#functions).\n \n Rust has two kinds of statement: [declaration\n statements](#declaration-statements) and [expression\n@@ -16,7 +16,7 @@ items.\n ### Item declarations\n \n An _item declaration statement_ has a syntactic form identical to an\n-[item](#items) declaration within a module. Declaring an item &mdash; a\n+[item](items.html) declaration within a module. Declaring an item &mdash; a\n function, enumeration, struct, type, static, trait, implementation or module\n &mdash; locally within a statement block is simply a way of restricting its\n scope to a narrow region containing all of its uses; it is otherwise identical\n@@ -36,7 +36,7 @@ declaration until the end of the enclosing block scope.\n \n ## Expression statements\n \n-An _expression statement_ is one that evaluates an [expression](#expressions)\n+An _expression statement_ is one that evaluates an [expression](expressions.html)\n and ignores its result. The type of an expression statement `e;` is always\n `()`, regardless of the type of `e`. As a rule, an expression statement's\n purpose is to trigger the effects of evaluating its expression."}]}