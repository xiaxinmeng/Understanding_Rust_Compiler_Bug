{"sha": "6cdccc5a78fac61d68fc04d342b999e69df149ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZGNjYzVhNzhmYWM2MWQ2OGZjMDRkMzQyYjk5OWU2OWRmMTQ5YWM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-06-13T23:27:18Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-15T15:27:35Z"}, "message": "Make impl-trait-ref associated types work in methods", "tree": {"sha": "27f2702ac00ecb57207d9deb4ba758126009de98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27f2702ac00ecb57207d9deb4ba758126009de98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cdccc5a78fac61d68fc04d342b999e69df149ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cdccc5a78fac61d68fc04d342b999e69df149ac", "html_url": "https://github.com/rust-lang/rust/commit/6cdccc5a78fac61d68fc04d342b999e69df149ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cdccc5a78fac61d68fc04d342b999e69df149ac/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1af72660a76605a485866ba3a80a79d331586a0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1af72660a76605a485866ba3a80a79d331586a0a", "html_url": "https://github.com/rust-lang/rust/commit/1af72660a76605a485866ba3a80a79d331586a0a"}], "stats": {"total": 113, "additions": 85, "deletions": 28}, "files": [{"sha": "4ef8f380e82487516018998dc3b46f17215946fa", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cdccc5a78fac61d68fc04d342b999e69df149ac/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cdccc5a78fac61d68fc04d342b999e69df149ac/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=6cdccc5a78fac61d68fc04d342b999e69df149ac", "patch": "@@ -389,15 +389,19 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n             }\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n+            debug!(\"normalize_projection_type: projected_ty={} no progress\",\n+                   projected_ty.repr(selcx.tcx()));\n             Some(Normalized {\n                 value: projected_ty,\n                 obligations: vec!()\n             })\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n+            debug!(\"normalize_projection_type: too many candidates\");\n             None\n         }\n         Err(ProjectionTyError::TraitSelectionError(_)) => {\n+            debug!(\"normalize_projection_type: ERROR\");\n             // if we got an error processing the `T as Trait` part,\n             // just return `ty::err` but add the obligation `T :\n             // Trait`, which when processed will cause the error to be"}, {"sha": "915aadd722b2ce89ee4d86ac16c046354da98ffe", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6cdccc5a78fac61d68fc04d342b999e69df149ac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cdccc5a78fac61d68fc04d342b999e69df149ac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=6cdccc5a78fac61d68fc04d342b999e69df149ac", "patch": "@@ -59,10 +59,12 @@ struct Candidate<'tcx> {\n }\n \n enum CandidateKind<'tcx> {\n-    InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n+    InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>,\n+                          /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n     ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ usize, /* vtable index */ usize),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, ty::TraitRef<'tcx>,\n-                           subst::Substs<'tcx>, ItemIndex),\n+                           subst::Substs<'tcx>, ItemIndex,\n+                           /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n     ClosureCandidate(/* Trait */ ast::DefId, ItemIndex),\n     WhereClauseCandidate(ty::PolyTraitRef<'tcx>, ItemIndex),\n     ProjectionCandidate(ast::DefId, ItemIndex),\n@@ -398,24 +400,24 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n+        let impl_ty = impl_ty.subst(self.tcx(), &impl_substs);\n \n-        // We can't use instantiate_type_scheme here as it will pollute\n-        // the fcx's fulfillment context if this probe is rolled back.\n+        // Determine the receiver type that the method itself expects.\n+        let xform_self_ty = self.xform_self_ty(&item, impl_ty, &impl_substs);\n+\n+        // We can't use normalize_associated_types_in as it will pollute the\n+        // fcx's fulfillment context after this probe is over.\n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n         let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n-        let traits::Normalized { value: impl_ty, .. } =\n-            traits::normalize(selcx, cause, &impl_ty.subst(self.tcx(), &impl_substs));\n-\n-        // Determine the receiver type that the method itself expects.\n-        let xform_self_ty =\n-            self.xform_self_ty(&item, impl_ty, &impl_substs);\n-        debug!(\"assemble_inherent_impl_probe: self ty = {:?}\",\n+        let traits::Normalized { value: xform_self_ty, obligations } =\n+            traits::normalize(selcx, cause, &xform_self_ty);\n+        debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n                xform_self_ty.repr(self.tcx()));\n \n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n             item: item,\n-            kind: InherentImplCandidate(impl_def_id, impl_substs)\n+            kind: InherentImplCandidate(impl_def_id, impl_substs, obligations)\n         });\n     }\n \n@@ -661,12 +663,24 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                    impl_trait_ref.self_ty(),\n                                    impl_trait_ref.substs);\n \n+            // Normalize the receiver. We can't use normalize_associated_types_in\n+            // as it will pollute the fcx's fulfillment context after this probe\n+            // is over.\n+            let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n+            let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n+            let traits::Normalized { value: xform_self_ty, obligations } =\n+                traits::normalize(selcx, cause, &xform_self_ty);\n+\n             debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n-                kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, item_index)\n+                kind: ExtensionImplCandidate(impl_def_id,\n+                                             impl_trait_ref,\n+                                             impl_substs,\n+                                             item_index,\n+                                             obligations)\n             });\n         });\n     }\n@@ -1034,8 +1048,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             // match as well (or at least may match, sometimes we\n             // don't have enough information to fully evaluate).\n             match probe.kind {\n-                InherentImplCandidate(impl_def_id, ref substs) |\n-                ExtensionImplCandidate(impl_def_id, _, ref substs, _) => {\n+                InherentImplCandidate(impl_def_id, ref substs, ref ref_obligations) |\n+                ExtensionImplCandidate(impl_def_id, _, ref substs, _, ref ref_obligations) => {\n                     let selcx = &mut traits::SelectionContext::new(self.infcx(), self.fcx);\n                     let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n@@ -1054,8 +1068,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n \n                     // Evaluate those obligations to see if they might possibly hold.\n-                    obligations.iter().all(|o| selcx.evaluate_obligation(o)) &&\n-                        norm_obligations.iter().all(|o| selcx.evaluate_obligation(o))\n+                    obligations.iter()\n+                        .chain(norm_obligations.iter()).chain(ref_obligations.iter())\n+                        .all(|o| selcx.evaluate_obligation(o))\n+\n                 }\n \n                 ProjectionCandidate(..) |\n@@ -1289,13 +1305,13 @@ impl<'tcx> Candidate<'tcx> {\n         Pick {\n             item: self.item.clone(),\n             kind: match self.kind {\n-                InherentImplCandidate(def_id, _) => {\n+                InherentImplCandidate(def_id, _, _) => {\n                     InherentImplPick(def_id)\n                 }\n                 ObjectCandidate(def_id, item_num, real_index) => {\n                     ObjectPick(def_id, item_num, real_index)\n                 }\n-                ExtensionImplCandidate(def_id, _, _, index) => {\n+                ExtensionImplCandidate(def_id, _, _, index, _) => {\n                     ExtensionImplPick(def_id, index)\n                 }\n                 ClosureCandidate(trait_def_id, index) => {\n@@ -1323,9 +1339,9 @@ impl<'tcx> Candidate<'tcx> {\n \n     fn to_source(&self) -> CandidateSource {\n         match self.kind {\n-            InherentImplCandidate(def_id, _) => ImplSource(def_id),\n+            InherentImplCandidate(def_id, _, _) => ImplSource(def_id),\n             ObjectCandidate(def_id, _, _) => TraitSource(def_id),\n-            ExtensionImplCandidate(def_id, _, _, _) => ImplSource(def_id),\n+            ExtensionImplCandidate(def_id, _, _, _, _) => ImplSource(def_id),\n             ClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n             WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n             ProjectionCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n@@ -1343,7 +1359,7 @@ impl<'tcx> Candidate<'tcx> {\n             ClosureCandidate(trait_def_id, item_num) => {\n                 Some((trait_def_id, item_num))\n             }\n-            ExtensionImplCandidate(_, ref trait_ref, _, item_num) => {\n+            ExtensionImplCandidate(_, ref trait_ref, _, item_num, _) => {\n                 Some((trait_ref.def_id, item_num))\n             }\n             WhereClauseCandidate(ref trait_ref, item_num) => {\n@@ -1367,13 +1383,14 @@ impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n-            InherentImplCandidate(ref a, ref b) =>\n-                format!(\"InherentImplCandidate({},{})\", a.repr(tcx), b.repr(tcx)),\n+            InherentImplCandidate(ref a, ref b, ref c) =>\n+                format!(\"InherentImplCandidate({},{},{})\", a.repr(tcx), b.repr(tcx),\n+                        c.repr(tcx)),\n             ObjectCandidate(a, b, c) =>\n                 format!(\"ObjectCandidate({},{},{})\", a.repr(tcx), b, c),\n-            ExtensionImplCandidate(ref a, ref b, ref c, ref d) =>\n-                format!(\"ExtensionImplCandidate({},{},{},{})\", a.repr(tcx), b.repr(tcx),\n-                        c.repr(tcx), d),\n+            ExtensionImplCandidate(ref a, ref b, ref c, ref d, ref e) =>\n+                format!(\"ExtensionImplCandidate({},{},{},{},{})\", a.repr(tcx), b.repr(tcx),\n+                        c.repr(tcx), d, e.repr(tcx)),\n             ClosureCandidate(ref a, ref b) =>\n                 format!(\"ClosureCandidate({},{})\", a.repr(tcx), b),\n             WhereClauseCandidate(ref a, ref b) =>"}, {"sha": "b57687a49fa6f21511c8ede013839e6d6c792123", "filename": "src/test/run-pass/associated-types-method.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6cdccc5a78fac61d68fc04d342b999e69df149ac/src%2Ftest%2Frun-pass%2Fassociated-types-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cdccc5a78fac61d68fc04d342b999e69df149ac/src%2Ftest%2Frun-pass%2Fassociated-types-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-method.rs?ref=6cdccc5a78fac61d68fc04d342b999e69df149ac", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that methods whose impl-trait-ref contains associated types\n+// are supported.\n+\n+trait Device {\n+    type Resources;\n+}\n+struct Foo<D, R>(D, R);\n+\n+trait Tr {\n+    fn present(&self) {}\n+}\n+\n+impl<D: Device> Tr for Foo<D, D::Resources> {\n+    fn present(&self) {}\n+}\n+\n+struct Res;\n+struct Dev;\n+impl Device for Dev {\n+    type Resources = Res;\n+}\n+\n+fn main() {\n+    let foo = Foo(Dev, Res);\n+    foo.present();\n+}"}, {"sha": "0ba7feece6061cde69696051489d75c703efec66", "filename": "src/test/run-pass/issue-25679.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cdccc5a78fac61d68fc04d342b999e69df149ac/src%2Ftest%2Frun-pass%2Fissue-25679.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cdccc5a78fac61d68fc04d342b999e69df149ac/src%2Ftest%2Frun-pass%2Fissue-25679.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25679.rs?ref=6cdccc5a78fac61d68fc04d342b999e69df149ac", "patch": "@@ -13,7 +13,7 @@ trait Device {\n }\n struct Foo<D, R>(D, R);\n \n-impl<D: Device, S> Foo<D, S> {\n+impl<D: Device> Foo<D, D::Resources> {\n     fn present(&self) {}\n }\n "}]}