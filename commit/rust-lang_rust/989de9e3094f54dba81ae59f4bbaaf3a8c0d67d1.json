{"sha": "989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4OWRlOWUzMDk0ZjU0ZGJhODFhZTU5ZjRiYmFhZjNhOGMwZDY3ZDE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-20T17:03:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-20T17:03:19Z"}, "message": "Merge #6172\n\n6172: Add qualify path assist r=matklad a=Veykril\n\nThis implements a `qualify_path` assist which works quite similar to the `auto_import` assist but instead of adding imports to the file it well, qualifies the path. This PR also moves out the `AutoImportAssets` struct and functions from `auto_import` into a utils submodule as most of this is now shared between `auto_import` and `qualify_path`.\r\n\r\nChanges made to `AutoImportAssets` are solely in its `search_for_imports` function which now takes a prefixed parameter to discern between using `find_use_path_prefixed` and `find_use_path` as the former is the required behavior by `auto_import` and the latter by this assist.\r\n\r\nFor missing imported traits instead of importing this will qualify the path with a trait cast as in:\r\n```rust\r\ntest_mod::TestStruct::TEST_CONST<|>\r\n```\r\nbecomes\r\n```rust\r\n<test_mod::TestStruct as test_mod::TestTrait>::TEST_CONST\r\n```\r\n\r\nand for trait methods ideally it would do the following:\r\n```rust\r\nlet test_struct = test_mod::TestStruct {};\r\ntest_struct.test_meth<|>od()\r\n```\r\nbecomes\r\n```rust\r\nlet test_struct = test_mod::TestStruct {};\r\ntest_mod::TestTrait::test_method(&test_struct)\r\n```\r\n\r\nFixes #4124.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "d9d931042534ef62c280b50792a29a8371266d96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9d931042534ef62c280b50792a29a8371266d96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfjxhXCRBK7hj4Ov3rIwAAdHIIAJtb6xh56iG7TwQtGQgq14RR\nUnOZoRi6SR5KbJ2vCTnxXyRmll5Ol3JFT1+h3huEaKaGAViowkO6dccPXHXPMgnD\n4mTvsMCLJ/D8WJUP9sPa8MDk8pUZ/a+uBW7qt6ZEp38Q4Lay5EzNLHQMIiU7TvUb\n6tAikNfPAuA7E7MyKJeyG2HARzfCJYsPjouD6ZyOPgOlgZZ0JtCl/l4K0/ztqWlX\nZ10nkWpjH6iebG/2dfcSMX9kY+gR7PvRC1fqk4o0g0uU7wuoHvCcw/oRIPksivoc\nFpg1jKsCPlIZMSYRaCYGK3XIpspKYyeTEkMDa0I4O7EG7qF8IbwFUxeElM1Pdnk=\n=Fa0k\n-----END PGP SIGNATURE-----\n", "payload": "tree d9d931042534ef62c280b50792a29a8371266d96\nparent 20d369a826e8f333cba1988325480a49a730f00e\nparent 1d612a6ec48390c38d577cd35369e0891fe6cb6e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1603213399 +0000\ncommitter GitHub <noreply@github.com> 1603213399 +0000\n\nMerge #6172\n\n6172: Add qualify path assist r=matklad a=Veykril\n\nThis implements a `qualify_path` assist which works quite similar to the `auto_import` assist but instead of adding imports to the file it well, qualifies the path. This PR also moves out the `AutoImportAssets` struct and functions from `auto_import` into a utils submodule as most of this is now shared between `auto_import` and `qualify_path`.\r\n\r\nChanges made to `AutoImportAssets` are solely in its `search_for_imports` function which now takes a prefixed parameter to discern between using `find_use_path_prefixed` and `find_use_path` as the former is the required behavior by `auto_import` and the latter by this assist.\r\n\r\nFor missing imported traits instead of importing this will qualify the path with a trait cast as in:\r\n```rust\r\ntest_mod::TestStruct::TEST_CONST<|>\r\n```\r\nbecomes\r\n```rust\r\n<test_mod::TestStruct as test_mod::TestTrait>::TEST_CONST\r\n```\r\n\r\nand for trait methods ideally it would do the following:\r\n```rust\r\nlet test_struct = test_mod::TestStruct {};\r\ntest_struct.test_meth<|>od()\r\n```\r\nbecomes\r\n```rust\r\nlet test_struct = test_mod::TestStruct {};\r\ntest_mod::TestTrait::test_method(&test_struct)\r\n```\r\n\r\nFixes #4124.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1", "html_url": "https://github.com/rust-lang/rust/commit/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20d369a826e8f333cba1988325480a49a730f00e", "url": "https://api.github.com/repos/rust-lang/rust/commits/20d369a826e8f333cba1988325480a49a730f00e", "html_url": "https://github.com/rust-lang/rust/commit/20d369a826e8f333cba1988325480a49a730f00e"}, {"sha": "1d612a6ec48390c38d577cd35369e0891fe6cb6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d612a6ec48390c38d577cd35369e0891fe6cb6e", "html_url": "https://github.com/rust-lang/rust/commit/1d612a6ec48390c38d577cd35369e0891fe6cb6e"}], "stats": {"total": 1114, "additions": 1090, "deletions": 24}, "files": [{"sha": "e49e641b3d709e5faa915c3ac049603bd6f87601", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1", "patch": "@@ -100,7 +100,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let group = import_group_message(import_assets.import_candidate());\n     let scope = ImportScope::find_insert_use_container(import_assets.syntax_under_caret(), ctx)?;\n     let syntax = scope.as_syntax_node();\n-    for import in proposed_imports {\n+    for (import, _) in proposed_imports {\n         acc.add_group(\n             &group,\n             AssistId(\"auto_import\", AssistKind::QuickFix),"}, {"sha": "f436bdbbfa63fbb394afa48eb206539f928bc8a2", "filename": "crates/assists/src/handlers/qualify_path.rs", "status": "added", "additions": 1048, "deletions": 0, "changes": 1048, "blob_url": "https://github.com/rust-lang/rust/blob/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1", "patch": "@@ -0,0 +1,1048 @@\n+use std::iter;\n+\n+use hir::AsName;\n+use ide_db::RootDatabase;\n+use syntax::{\n+    ast,\n+    ast::{make, ArgListOwner},\n+    AstNode,\n+};\n+use test_utils::mark;\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    utils::import_assets::{ImportAssets, ImportCandidate},\n+    utils::mod_path_to_ast,\n+    AssistId, AssistKind, GroupLabel,\n+};\n+\n+// Assist: qualify_path\n+//\n+// If the name is unresolved, provides all possible qualified paths for it.\n+//\n+// ```\n+// fn main() {\n+//     let map = HashMap<|>::new();\n+// }\n+// # pub mod std { pub mod collections { pub struct HashMap { } } }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let map = std::collections::HashMap::new();\n+// }\n+// # pub mod std { pub mod collections { pub struct HashMap { } } }\n+// ```\n+pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let import_assets =\n+        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n+            ImportAssets::for_regular_path(path_under_caret, &ctx.sema)\n+        } else if let Some(method_under_caret) =\n+            ctx.find_node_at_offset_with_descend::<ast::MethodCallExpr>()\n+        {\n+            ImportAssets::for_method_call(method_under_caret, &ctx.sema)\n+        } else {\n+            None\n+        }?;\n+    let proposed_imports = import_assets.search_for_relative_paths(&ctx.sema);\n+    if proposed_imports.is_empty() {\n+        return None;\n+    }\n+\n+    let candidate = import_assets.import_candidate();\n+    let range = ctx.sema.original_range(import_assets.syntax_under_caret()).range;\n+\n+    let qualify_candidate = match candidate {\n+        ImportCandidate::QualifierStart(_) => {\n+            mark::hit!(qualify_path_qualifier_start);\n+            let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+            let segment = path.segment()?;\n+            QualifyCandidate::QualifierStart(segment)\n+        }\n+        ImportCandidate::UnqualifiedName(_) => {\n+            mark::hit!(qualify_path_unqualified_name);\n+            QualifyCandidate::UnqualifiedName\n+        }\n+        ImportCandidate::TraitAssocItem(_) => {\n+            mark::hit!(qualify_path_trait_assoc_item);\n+            let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+            let (qualifier, segment) = (path.qualifier()?, path.segment()?);\n+            QualifyCandidate::TraitAssocItem(qualifier, segment)\n+        }\n+        ImportCandidate::TraitMethod(_) => {\n+            mark::hit!(qualify_path_trait_method);\n+            let mcall_expr = ast::MethodCallExpr::cast(import_assets.syntax_under_caret().clone())?;\n+            QualifyCandidate::TraitMethod(ctx.sema.db, mcall_expr)\n+        }\n+    };\n+\n+    let group_label = group_label(candidate);\n+    for (import, item) in proposed_imports {\n+        acc.add_group(\n+            &group_label,\n+            AssistId(\"qualify_path\", AssistKind::QuickFix),\n+            label(candidate, &import),\n+            range,\n+            |builder| {\n+                qualify_candidate.qualify(\n+                    |replace_with: String| builder.replace(range, replace_with),\n+                    import,\n+                    item,\n+                )\n+            },\n+        );\n+    }\n+    Some(())\n+}\n+\n+enum QualifyCandidate<'db> {\n+    QualifierStart(ast::PathSegment),\n+    UnqualifiedName,\n+    TraitAssocItem(ast::Path, ast::PathSegment),\n+    TraitMethod(&'db RootDatabase, ast::MethodCallExpr),\n+}\n+\n+impl QualifyCandidate<'_> {\n+    fn qualify(&self, mut replacer: impl FnMut(String), import: hir::ModPath, item: hir::ItemInNs) {\n+        match self {\n+            QualifyCandidate::QualifierStart(segment) => {\n+                let import = mod_path_to_ast(&import);\n+                replacer(format!(\"{}::{}\", import, segment));\n+            }\n+            QualifyCandidate::UnqualifiedName => replacer(mod_path_to_ast(&import).to_string()),\n+            QualifyCandidate::TraitAssocItem(qualifier, segment) => {\n+                let import = mod_path_to_ast(&import);\n+                replacer(format!(\"<{} as {}>::{}\", qualifier, import, segment));\n+            }\n+            &QualifyCandidate::TraitMethod(db, ref mcall_expr) => {\n+                Self::qualify_trait_method(db, mcall_expr, replacer, import, item);\n+            }\n+        }\n+    }\n+\n+    fn qualify_trait_method(\n+        db: &RootDatabase,\n+        mcall_expr: &ast::MethodCallExpr,\n+        mut replacer: impl FnMut(String),\n+        import: hir::ModPath,\n+        item: hir::ItemInNs,\n+    ) -> Option<()> {\n+        let receiver = mcall_expr.receiver()?;\n+        let trait_method_name = mcall_expr.name_ref()?;\n+        let arg_list = mcall_expr.arg_list().map(|arg_list| arg_list.args());\n+        let trait_ = item_as_trait(item)?;\n+        let method = find_trait_method(db, trait_, &trait_method_name)?;\n+        if let Some(self_access) = method.self_param(db).map(|sp| sp.access(db)) {\n+            let import = mod_path_to_ast(&import);\n+            let receiver = match self_access {\n+                hir::Access::Shared => make::expr_ref(receiver, false),\n+                hir::Access::Exclusive => make::expr_ref(receiver, true),\n+                hir::Access::Owned => receiver,\n+            };\n+            replacer(format!(\n+                \"{}::{}{}\",\n+                import,\n+                trait_method_name,\n+                match arg_list.clone() {\n+                    Some(args) => make::arg_list(iter::once(receiver).chain(args)),\n+                    None => make::arg_list(iter::once(receiver)),\n+                }\n+            ));\n+        }\n+        Some(())\n+    }\n+}\n+\n+fn find_trait_method(\n+    db: &RootDatabase,\n+    trait_: hir::Trait,\n+    trait_method_name: &ast::NameRef,\n+) -> Option<hir::Function> {\n+    if let Some(hir::AssocItem::Function(method)) =\n+        trait_.items(db).into_iter().find(|item: &hir::AssocItem| {\n+            item.name(db).map(|name| name == trait_method_name.as_name()).unwrap_or(false)\n+        })\n+    {\n+        Some(method)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn item_as_trait(item: hir::ItemInNs) -> Option<hir::Trait> {\n+    if let hir::ModuleDef::Trait(trait_) = hir::ModuleDef::from(item.as_module_def_id()?) {\n+        Some(trait_)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n+    let name = match candidate {\n+        ImportCandidate::UnqualifiedName(it) | ImportCandidate::QualifierStart(it) => &it.name,\n+        ImportCandidate::TraitAssocItem(it) | ImportCandidate::TraitMethod(it) => &it.name,\n+    };\n+    GroupLabel(format!(\"Qualify {}\", name))\n+}\n+\n+fn label(candidate: &ImportCandidate, import: &hir::ModPath) -> String {\n+    match candidate {\n+        ImportCandidate::UnqualifiedName(_) => format!(\"Qualify as `{}`\", &import),\n+        ImportCandidate::QualifierStart(_) => format!(\"Qualify with `{}`\", &import),\n+        ImportCandidate::TraitAssocItem(_) => format!(\"Qualify `{}`\", &import),\n+        ImportCandidate::TraitMethod(_) => format!(\"Qualify with cast as `{}`\", &import),\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn applicable_when_found_an_import_partial() {\n+        mark::check!(qualify_path_unqualified_name);\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod std {\n+                pub mod fmt {\n+                    pub struct Formatter;\n+                }\n+            }\n+\n+            use std::fmt;\n+\n+            <|>Formatter\n+            \",\n+            r\"\n+            mod std {\n+                pub mod fmt {\n+                    pub struct Formatter;\n+                }\n+            }\n+\n+            use std::fmt;\n+\n+            fmt::Formatter\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn applicable_when_found_an_import() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            <|>PubStruct\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            PubMod::PubStruct\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn applicable_in_macros() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            macro_rules! foo {\n+                ($i:ident) => { fn foo(a: $i) {} }\n+            }\n+            foo!(Pub<|>Struct);\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            macro_rules! foo {\n+                ($i:ident) => { fn foo(a: $i) {} }\n+            }\n+            foo!(PubMod::PubStruct);\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn applicable_when_found_multiple_imports() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            PubSt<|>ruct\n+\n+            pub mod PubMod1 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod2 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod3 {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            PubMod3::PubStruct\n+\n+            pub mod PubMod1 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod2 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod3 {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_already_imported_types() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            use PubMod::PubStruct;\n+\n+            PubStruct<|>\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_types_with_private_paths() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            PrivateStruct<|>\n+\n+            pub mod PubMod {\n+                struct PrivateStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_no_imports_found() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            \"\n+            PubStruct<|>\",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_in_import_statements() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            use PubStruct<|>;\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\",\n+        );\n+    }\n+\n+    #[test]\n+    fn qualify_function() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            test_function<|>\n+\n+            pub mod PubMod {\n+                pub fn test_function() {};\n+            }\n+            \",\n+            r\"\n+            PubMod::test_function\n+\n+            pub mod PubMod {\n+                pub fn test_function() {};\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn qualify_macro() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:crate_with_macro\n+#[macro_export]\n+macro_rules! foo {\n+    () => ()\n+}\n+\n+//- /main.rs crate:main deps:crate_with_macro\n+fn main() {\n+    foo<|>\n+}\n+\",\n+            r\"\n+fn main() {\n+    crate_with_macro::foo\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn qualify_path_target() {\n+        check_assist_target(\n+            qualify_path,\n+            r\"\n+            struct AssistInfo {\n+                group_label: Option<<|>GroupLabel>,\n+            }\n+\n+            mod m { pub struct GroupLabel; }\n+            \",\n+            \"GroupLabel\",\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_path_start_is_imported() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            pub mod mod1 {\n+                pub mod mod2 {\n+                    pub mod mod3 {\n+                        pub struct TestStruct;\n+                    }\n+                }\n+            }\n+\n+            use mod1::mod2;\n+            fn main() {\n+                mod2::mod3::TestStruct<|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_function() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            pub mod test_mod {\n+                pub fn test_function() {}\n+            }\n+\n+            use test_mod::test_function;\n+            fn main() {\n+                test_function<|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_struct_function() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    pub fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::test_function<|>\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    pub fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::test_function\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_struct_const() {\n+        mark::check!(qualify_path_qualifier_start);\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::TEST_CONST\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_trait_function() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::test_function<|>\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                <test_mod::TestStruct as test_mod::TestTrait>::test_function\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_function() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub trait TestTrait2 {\n+                    fn test_function();\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    fn test_function() {}\n+                }\n+                impl TestTrait for TestEnum {\n+                    fn test_function() {}\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                test_mod::TestEnum::test_function<|>;\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_trait_const() {\n+        mark::check!(qualify_path_trait_assoc_item);\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                <test_mod::TestStruct as test_mod::TestTrait>::TEST_CONST\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_const() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub trait TestTrait2 {\n+                    const TEST_CONST: f64;\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    const TEST_CONST: f64 = 42.0;\n+                }\n+                impl TestTrait for TestEnum {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                test_mod::TestEnum::TEST_CONST<|>;\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn trait_method() {\n+        mark::check!(qualify_path_trait_method);\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_mod::TestTrait::test_method(&test_struct)\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_multi_params() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self, test: i32);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self, test: i32) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_struct.test_meth<|>od(42)\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self, test: i32);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self, test: i32) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_mod::TestTrait::test_method(&test_struct, 42)\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_consume() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_mod::TestTrait::test_method(test_struct)\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_cross_crate() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+            \",\n+            r\"\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                dep::test_mod::TestTrait::test_method(&test_struct)\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_fn_cross_crate() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                dep::test_mod::TestStruct::test_func<|>tion\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+            \",\n+            r\"\n+            fn main() {\n+                <dep::test_mod::TestStruct as dep::test_mod::TestTrait>::test_function\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_const_cross_crate() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                dep::test_mod::TestStruct::CONST<|>\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    const CONST: bool;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const CONST: bool = true;\n+                }\n+            }\n+            \",\n+            r\"\n+            fn main() {\n+                <dep::test_mod::TestStruct as dep::test_mod::TestTrait>::CONST\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_fn_as_method_cross_crate() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_func<|>tion()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn private_trait_cross_crate() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_method() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub trait TestTrait2 {\n+                    fn test_method(&self);\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    fn test_method(&self) {}\n+                }\n+                impl TestTrait for TestEnum {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                let one = test_mod::TestEnum::One;\n+                one.test<|>_method();\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn dep_import() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:dep\n+pub struct Struct;\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    Struct<|>\n+}\n+\",\n+            r\"\n+fn main() {\n+    dep::Struct\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn whole_segment() {\n+        // Tests that only imports whose last segment matches the identifier get suggested.\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:dep\n+pub mod fmt {\n+    pub trait Display {}\n+}\n+\n+pub fn panic_fmt() {}\n+\n+//- /main.rs crate:main deps:dep\n+struct S;\n+\n+impl f<|>mt::Display for S {}\n+\",\n+            r\"\n+struct S;\n+\n+impl dep::fmt::Display for S {}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn macro_generated() {\n+        // Tests that macro-generated items are suggested from external crates.\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:dep\n+macro_rules! mac {\n+    () => {\n+        pub struct Cheese;\n+    };\n+}\n+\n+mac!();\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    Cheese<|>;\n+}\n+\",\n+            r\"\n+fn main() {\n+    dep::Cheese;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn casing() {\n+        // Tests that differently cased names don't interfere and we only suggest the matching one.\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:dep\n+pub struct FMT;\n+pub struct fmt;\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    FMT<|>;\n+}\n+\",\n+            r\"\n+fn main() {\n+    dep::FMT;\n+}\n+\",\n+        );\n+    }\n+}"}, {"sha": "f29b8212f9cdb3a1e199275f69a08608413678f0", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1", "patch": "@@ -150,6 +150,7 @@ mod handlers {\n     mod merge_match_arms;\n     mod move_bounds;\n     mod move_guard;\n+    mod qualify_path;\n     mod raw_string;\n     mod remove_dbg;\n     mod remove_mut;\n@@ -196,6 +197,7 @@ mod handlers {\n             move_bounds::move_bounds_to_where_clause,\n             move_guard::move_arm_cond_to_match_guard,\n             move_guard::move_guard_to_arm_body,\n+            qualify_path::qualify_path,\n             raw_string::add_hash,\n             raw_string::make_raw_string,\n             raw_string::make_usual_string,"}, {"sha": "7d561826318125f00171671eda6348582d9f9b27", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1", "patch": "@@ -712,6 +712,25 @@ fn handle(action: Action) {\n     )\n }\n \n+#[test]\n+fn doctest_qualify_path() {\n+    check_doc_test(\n+        \"qualify_path\",\n+        r#####\"\n+fn main() {\n+    let map = HashMap<|>::new();\n+}\n+pub mod std { pub mod collections { pub struct HashMap { } } }\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let map = std::collections::HashMap::new();\n+}\n+pub mod std { pub mod collections { pub struct HashMap { } } }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_remove_dbg() {\n     check_doc_test("}, {"sha": "23db3a74bdb1e814ad7318a6e597907502db4c2b", "filename": "crates/assists/src/utils/import_assets.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs?ref=989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1", "patch": "@@ -1,6 +1,4 @@\n //! Look up accessible paths for items.\n-use std::collections::BTreeSet;\n-\n use either::Either;\n use hir::{AsAssocItem, AssocItemContainer, ModuleDef, Semantics};\n use ide_db::{imports_locator, RootDatabase};\n@@ -29,12 +27,12 @@ pub(crate) enum ImportCandidate {\n #[derive(Debug)]\n pub(crate) struct TraitImportCandidate {\n     pub ty: hir::Type,\n-    pub name: String,\n+    pub name: ast::NameRef,\n }\n \n #[derive(Debug)]\n pub(crate) struct PathImportCandidate {\n-    pub name: String,\n+    pub name: ast::NameRef,\n }\n \n #[derive(Debug)]\n@@ -86,17 +84,17 @@ impl ImportAssets {\n     fn get_search_query(&self) -> &str {\n         match &self.import_candidate {\n             ImportCandidate::UnqualifiedName(candidate)\n-            | ImportCandidate::QualifierStart(candidate) => &candidate.name,\n+            | ImportCandidate::QualifierStart(candidate) => candidate.name.text(),\n             ImportCandidate::TraitAssocItem(candidate)\n-            | ImportCandidate::TraitMethod(candidate) => &candidate.name,\n+            | ImportCandidate::TraitMethod(candidate) => candidate.name.text(),\n         }\n     }\n \n     pub(crate) fn search_for_imports(\n         &self,\n         sema: &Semantics<RootDatabase>,\n         config: &InsertUseConfig,\n-    ) -> BTreeSet<hir::ModPath> {\n+    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n         let _p = profile::span(\"import_assists::search_for_imports\");\n         self.search_for(sema, Some(config.prefix_kind))\n     }\n@@ -106,7 +104,7 @@ impl ImportAssets {\n     pub(crate) fn search_for_relative_paths(\n         &self,\n         sema: &Semantics<RootDatabase>,\n-    ) -> BTreeSet<hir::ModPath> {\n+    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n         let _p = profile::span(\"import_assists::search_for_relative_paths\");\n         self.search_for(sema, None)\n     }\n@@ -115,7 +113,7 @@ impl ImportAssets {\n         &self,\n         sema: &Semantics<RootDatabase>,\n         prefixed: Option<hir::PrefixKind>,\n-    ) -> BTreeSet<hir::ModPath> {\n+    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n         let db = sema.db;\n         let mut trait_candidates = FxHashSet::default();\n         let current_crate = self.module_with_name_to_import.krate();\n@@ -181,7 +179,7 @@ impl ImportAssets {\n             }\n         };\n \n-        imports_locator::find_imports(sema, current_crate, &self.get_search_query())\n+        let mut res = imports_locator::find_imports(sema, current_crate, &self.get_search_query())\n             .into_iter()\n             .filter_map(filter)\n             .filter_map(|candidate| {\n@@ -191,10 +189,13 @@ impl ImportAssets {\n                 } else {\n                     self.module_with_name_to_import.find_use_path(db, item)\n                 }\n+                .map(|path| (path, item))\n             })\n-            .filter(|use_path| !use_path.segments.is_empty())\n+            .filter(|(use_path, _)| !use_path.segments.is_empty())\n             .take(20)\n-            .collect::<BTreeSet<_>>()\n+            .collect::<Vec<_>>();\n+        res.sort_by_key(|(path, _)| path.clone());\n+        res\n     }\n \n     fn assoc_to_trait(assoc: AssocItemContainer) -> Option<hir::Trait> {\n@@ -215,7 +216,7 @@ impl ImportCandidate {\n             Some(_) => None,\n             None => Some(Self::TraitMethod(TraitImportCandidate {\n                 ty: sema.type_of_expr(&method_call.receiver()?)?,\n-                name: method_call.name_ref()?.syntax().to_string(),\n+                name: method_call.name_ref()?,\n             })),\n         }\n     }\n@@ -243,24 +244,17 @@ impl ImportCandidate {\n                     hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => {\n                         ImportCandidate::TraitAssocItem(TraitImportCandidate {\n                             ty: assoc_item_path.ty(sema.db),\n-                            name: segment.syntax().to_string(),\n+                            name: segment.name_ref()?,\n                         })\n                     }\n                     _ => return None,\n                 }\n             } else {\n-                ImportCandidate::QualifierStart(PathImportCandidate {\n-                    name: qualifier_start.syntax().to_string(),\n-                })\n+                ImportCandidate::QualifierStart(PathImportCandidate { name: qualifier_start })\n             }\n         } else {\n             ImportCandidate::UnqualifiedName(PathImportCandidate {\n-                name: segment\n-                    .syntax()\n-                    .descendants()\n-                    .find_map(ast::NameRef::cast)?\n-                    .syntax()\n-                    .to_string(),\n+                name: segment.syntax().descendants().find_map(ast::NameRef::cast)?,\n             })\n         };\n         Some(candidate)"}, {"sha": "5b06cb7671882a1de9fda237b39d98013c5bbcb7", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=989de9e3094f54dba81ae59f4bbaaf3a8c0d67d1", "patch": "@@ -172,6 +172,9 @@ pub fn expr_call(f: ast::Expr, arg_list: ast::ArgList) -> ast::Expr {\n pub fn expr_method_call(receiver: ast::Expr, method: &str, arg_list: ast::ArgList) -> ast::Expr {\n     expr_from_text(&format!(\"{}.{}{}\", receiver, method, arg_list))\n }\n+pub fn expr_ref(expr: ast::Expr, exclusive: bool) -> ast::Expr {\n+    expr_from_text(&if exclusive { format!(\"&mut {}\", expr) } else { format!(\"&{}\", expr) })\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }"}]}