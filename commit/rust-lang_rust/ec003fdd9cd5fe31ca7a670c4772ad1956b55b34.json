{"sha": "ec003fdd9cd5fe31ca7a670c4772ad1956b55b34", "node_id": "C_kwDOAAsO6NoAKGVjMDAzZmRkOWNkNWZlMzFjYTdhNjcwYzQ3NzJhZDE5NTZiNTViMzQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-27T11:30:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-28T07:53:14Z"}, "message": "yield the main thread a number of times after its TLS dtors are done", "tree": {"sha": "c5a8046697145f9125c400b6b3cd43b0dcde8f0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5a8046697145f9125c400b6b3cd43b0dcde8f0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec003fdd9cd5fe31ca7a670c4772ad1956b55b34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec003fdd9cd5fe31ca7a670c4772ad1956b55b34", "html_url": "https://github.com/rust-lang/rust/commit/ec003fdd9cd5fe31ca7a670c4772ad1956b55b34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec003fdd9cd5fe31ca7a670c4772ad1956b55b34/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0849084d0664d1e50b7b4b086f6d221a054f5b46", "url": "https://api.github.com/repos/rust-lang/rust/commits/0849084d0664d1e50b7b4b086f6d221a054f5b46", "html_url": "https://github.com/rust-lang/rust/commit/0849084d0664d1e50b7b4b086f6d221a054f5b46"}], "stats": {"total": 51, "additions": 37, "deletions": 14}, "files": [{"sha": "f12c3518e831d93ed72a117f0b845b1f4423a253", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ec003fdd9cd5fe31ca7a670c4772ad1956b55b34/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec003fdd9cd5fe31ca7a670c4772ad1956b55b34/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=ec003fdd9cd5fe31ca7a670c4772ad1956b55b34", "patch": "@@ -24,6 +24,11 @@ use rustc_session::config::EntryFnType;\n use crate::shims::tls;\n use crate::*;\n \n+/// When the main thread would exit, we will yield to any other thread that is ready to execute.\n+/// But we must only do that a finite number of times, or a background thread running `loop {}`\n+/// will hang the program.\n+const MAIN_THREAD_YIELDS_AT_SHUTDOWN: u32 = 1_000;\n+\n #[derive(Copy, Clone, Debug, PartialEq)]\n pub enum AlignmentCheck {\n     /// Do not check alignment.\n@@ -180,6 +185,10 @@ enum MainThreadState {\n     #[default]\n     Running,\n     TlsDtors(tls::TlsDtorsState),\n+    Yield {\n+        remaining: u32,\n+    },\n+    Done,\n }\n \n impl MainThreadState {\n@@ -196,22 +205,36 @@ impl MainThreadState {\n                 match state.on_stack_empty(this)? {\n                     Poll::Pending => {} // just keep going\n                     Poll::Ready(()) => {\n-                        // Need to call `thread_terminated` ourselves since we are not going to\n-                        // return to the scheduler loop.\n-                        this.thread_terminated()?;\n-                        // Raise exception to stop program execution.\n-                        let ret_place = MPlaceTy::from_aligned_ptr(\n-                            this.machine.main_fn_ret_place.unwrap().ptr,\n-                            this.machine.layouts.isize,\n-                        );\n-                        let exit_code =\n-                            this.read_scalar(&ret_place.into())?.to_machine_isize(this)?;\n-                        throw_machine_stop!(TerminationInfo::Exit {\n-                            code: exit_code,\n-                            leak_check: true\n-                        });\n+                        // Give background threads a chance to finish by yielding the main thread a\n+                        // couple of times -- but only if we would also preempt threads randomly.\n+                        if this.machine.preemption_rate > 0.0 {\n+                            *self = Yield { remaining: MAIN_THREAD_YIELDS_AT_SHUTDOWN };\n+                        } else {\n+                            *self = Done;\n+                        }\n                     }\n                 },\n+            Yield { remaining } =>\n+                match remaining.checked_sub(1) {\n+                    None => *self = Done,\n+                    Some(new_remaining) => {\n+                        *remaining = new_remaining;\n+                        this.yield_active_thread();\n+                    }\n+                },\n+            Done => {\n+                // Figure out exit code.\n+                let ret_place = MPlaceTy::from_aligned_ptr(\n+                    this.machine.main_fn_ret_place.unwrap().ptr,\n+                    this.machine.layouts.isize,\n+                );\n+                let exit_code = this.read_scalar(&ret_place.into())?.to_machine_isize(this)?;\n+                // Need to call `thread_terminated` ourselves since we are not going to\n+                // return to the scheduler loop.\n+                this.thread_terminated()?;\n+                // Stop interpreter loop.\n+                throw_machine_stop!(TerminationInfo::Exit { code: exit_code, leak_check: true });\n+            }\n         }\n         Ok(Poll::Pending)\n     }"}]}