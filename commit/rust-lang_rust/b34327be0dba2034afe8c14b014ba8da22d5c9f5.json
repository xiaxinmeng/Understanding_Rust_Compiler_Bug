{"sha": "b34327be0dba2034afe8c14b014ba8da22d5c9f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNDMyN2JlMGRiYTIwMzRhZmU4YzE0YjAxNGJhOGRhMjJkNWM5ZjU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-03T22:18:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-04T00:03:29Z"}, "message": "rustc: Implement \"@Foo as @Bar\" for boxed traits", "tree": {"sha": "fa0ed5bbbee22f612ef1ec4e689626058d770571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa0ed5bbbee22f612ef1ec4e689626058d770571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b34327be0dba2034afe8c14b014ba8da22d5c9f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b34327be0dba2034afe8c14b014ba8da22d5c9f5", "html_url": "https://github.com/rust-lang/rust/commit/b34327be0dba2034afe8c14b014ba8da22d5c9f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b34327be0dba2034afe8c14b014ba8da22d5c9f5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d936773e56a2dc450bb620a8bab45b6a17fd12cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d936773e56a2dc450bb620a8bab45b6a17fd12cd", "html_url": "https://github.com/rust-lang/rust/commit/d936773e56a2dc450bb620a8bab45b6a17fd12cd"}], "stats": {"total": 120, "additions": 89, "deletions": 31}, "files": [{"sha": "29368ae95b80064eda545568d63a51ab421a2a96", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b34327be0dba2034afe8c14b014ba8da22d5c9f5/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34327be0dba2034afe8c14b014ba8da22d5c9f5/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=b34327be0dba2034afe8c14b014ba8da22d5c9f5", "patch": "@@ -929,6 +929,8 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n \n         if tag == (c::tag_table_mutbl as uint) {\n             dcx.maps.mutbl_map.insert(id, ());\n+        } else if tag == (c::tag_table_legacy_boxed_trait as uint) {\n+            dcx.tcx.legacy_boxed_traits.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val as uint];\n             let val_dsr = ebml::ebml_deserializer(val_doc);\n@@ -969,8 +971,6 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             } else if tag == (c::tag_table_adjustments as uint) {\n                 let adj = @ty::deserialize_AutoAdjustment(val_dsr).tr(xcx);\n                 dcx.tcx.adjustments.insert(id, adj);\n-            } else if tag == (c::tag_table_legacy_boxed_trait as uint) {\n-                dcx.tcx.legacy_boxed_traits.insert(id, ());\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n                     fmt!(\"unknown tag found in side tables: %x\", tag));"}, {"sha": "5bf62466595d9c3d1e43a05f0a9a4b3db2d50a6a", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b34327be0dba2034afe8c14b014ba8da22d5c9f5/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34327be0dba2034afe8c14b014ba8da22d5c9f5/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=b34327be0dba2034afe8c14b014ba8da22d5c9f5", "patch": "@@ -536,6 +536,7 @@ fn trans_trait_cast(bcx: block,\n                     dest: expr::Dest)\n     -> block\n {\n+    let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"impl::trans_cast\");\n \n     let lldest = match dest {\n@@ -548,16 +549,24 @@ fn trans_trait_cast(bcx: block,\n     let ccx = bcx.ccx();\n     let v_ty = expr_ty(bcx, val);\n \n-    // Allocate an @ box and store the value into it\n-    let {bcx: bcx, box: llbox, body: body} = malloc_boxed(bcx, v_ty);\n-    add_clean_free(bcx, llbox, heap_shared);\n-    let bcx = expr::trans_into(bcx, val, SaveIn(body));\n-    revoke_clean(bcx, llbox);\n+    let mut llboxdest = GEPi(bcx, lldest, [0u, 1u]);\n+    llboxdest = PointerCast(bcx, llboxdest,\n+                            T_ptr(type_of::type_of(bcx.ccx(), v_ty)));\n+\n+    if bcx.tcx().legacy_boxed_traits.contains_key(id) {\n+        // Allocate an @ box and store the value into it\n+        let {bcx: new_bcx, box: llbox, body: body} = malloc_boxed(bcx, v_ty);\n+        bcx = new_bcx;\n+        add_clean_free(bcx, llbox, heap_shared);\n+        bcx = expr::trans_into(bcx, val, SaveIn(body));\n+        revoke_clean(bcx, llbox);\n \n-    // Store the @ box into the pair\n-    Store(bcx, llbox, PointerCast(bcx,\n-                                  GEPi(bcx, lldest, [0u, 1u]),\n-                                  T_ptr(val_ty(llbox))));\n+        // Store the @ box into the pair\n+        Store(bcx, llbox, llboxdest);\n+    } else {\n+        // Just store the @ box into the pair.\n+        bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n+    }\n \n     // Store the vtable into the pair\n     let orig = ccx.maps.vtable_map.get(id)[0];"}, {"sha": "e8595b2f50a1d141b223a4ad8ff51d35b6b8185c", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b34327be0dba2034afe8c14b014ba8da22d5c9f5/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34327be0dba2034afe8c14b014ba8da22d5c9f5/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=b34327be0dba2034afe8c14b014ba8da22d5c9f5", "patch": "@@ -51,8 +51,18 @@ fn lookup_vtables(fcx: @fn_ctxt,\n             match *bound {\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n-                result.push(lookup_vtable(fcx, expr, *ty, i_ty,\n-                                          allow_unsafe, is_early));\n+                match lookup_vtable(fcx, expr, *ty, i_ty, allow_unsafe,\n+                                    is_early) {\n+                    Some(vtable) => result.push(vtable),\n+                    None => {\n+                        fcx.tcx().sess.span_fatal(\n+                            expr.span,\n+                            fmt!(\"failed to find an implementation of trait \\\n+                                  %s for %s\",\n+                                 ty_to_str(fcx.tcx(), i_ty),\n+                                 ty_to_str(fcx.tcx(), *ty)));\n+                    }\n+                }\n               }\n               _ => ()\n             }\n@@ -91,7 +101,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                  trait_ty: ty::t,\n                  allow_unsafe: bool,\n                  is_early: bool)\n-    -> vtable_origin\n+    -> Option<vtable_origin>\n {\n \n     debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n@@ -113,7 +123,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n             // The type has unconstrained type variables in it, so we can't\n             // do early resolution on it. Return some completely bogus vtable\n             // information: we aren't storing it anyways.\n-            return vtable_param(0, 0);\n+            return Some(vtable_param(0, 0));\n         }\n     };\n \n@@ -135,7 +145,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                                            idid);\n                                     relate_trait_tys(fcx, expr,\n                                                      trait_ty, ity);\n-                                    return vtable_param(n, n_bound);\n+                                    return Some(vtable_param(n, n_bound));\n                                 }\n                             }\n                             _ => tcx.sess.impossible_case(\n@@ -170,7 +180,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                     }\n                 }\n             }\n-            return vtable_trait(did, substs.tps);\n+            return Some(vtable_trait(did, substs.tps));\n         }\n \n         _ => {\n@@ -303,7 +313,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                                 None => {\n                                     assert is_early;\n                                     // Bail out with a bogus answer\n-                                    return vtable_param(0, 0);\n+                                    return Some(vtable_param(0, 0));\n                                 }\n                             };\n \n@@ -341,23 +351,20 @@ fn lookup_vtable(fcx: @fn_ctxt,\n \n             match found.len() {\n                 0 => { /* fallthrough */ }\n-                1 => { return found[0]; }\n+                1 => { return Some(found[0]); }\n                 _ => {\n                     if !is_early {\n                         fcx.ccx.tcx.sess.span_err(\n                             expr.span,\n                             ~\"multiple applicable methods in scope\");\n                     }\n-                    return found[0];\n+                    return Some(found[0]);\n                 }\n             }\n         }\n     }\n \n-    tcx.sess.span_fatal(\n-        expr.span,\n-        fmt!(\"failed to find an implementation of trait %s for %s\",\n-             ty_to_str(tcx, trait_ty), ty_to_str(tcx, ty)));\n+    return None;\n }\n \n fn fixup_ty(fcx: @fn_ctxt,\n@@ -459,13 +466,55 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n             Look up vtables for the type we're casting to,\n             passing in the source and target type\n             */\n-            let vtable = lookup_vtable(fcx, ex, fcx.expr_ty(src),\n-                                       target_ty, true, is_early);\n-            /*\n-            Map this expression to that vtable (that is: \"ex has\n-            vtable <vtable>\")\n-            */\n-            if !is_early { cx.vtable_map.insert(ex.id, @~[vtable]); }\n+            let ty = fcx.expr_ty(src);\n+            let vtable_opt = lookup_vtable(fcx, ex, ty, target_ty, true,\n+                                           is_early);\n+            match vtable_opt {\n+                None => {\n+                    // Try the new-style boxed trait; \"@int as @Trait\".\n+                    let mut err = false;\n+                    let ty = structurally_resolved_type(fcx, ex.span, ty);\n+                    match ty::get(ty).sty {\n+                        ty::ty_box(boxed_ty) => {\n+                            let vtable_opt = lookup_vtable(fcx, ex,\n+                                                           boxed_ty.ty,\n+                                                           target_ty, true,\n+                                                           is_early);\n+                            match vtable_opt {\n+                                Some(vtable) => {\n+                                    /*\n+                                    Map this expression to that vtable (that\n+                                    is: \"ex has vtable <vtable>\")\n+                                    */\n+                                    if !is_early {\n+                                        cx.vtable_map.insert(ex.id,\n+                                                             @~[vtable]);\n+                                    }\n+                                }\n+                                None => err = true\n+                            }\n+                        }\n+                        _ => err = true\n+                    }\n+\n+                    if err {\n+                        fcx.tcx().sess.span_fatal(\n+                            ex.span,\n+                            fmt!(\"failed to find an implementation of trait \\\n+                                  %s for %s\",\n+                                 ty_to_str(fcx.tcx(), target_ty),\n+                                 ty_to_str(fcx.tcx(), ty)));\n+                    }\n+                }\n+                Some(vtable) => {\n+                    /*\n+                    Map this expression to that vtable (that is: \"ex has\n+                    vtable <vtable>\")\n+                    */\n+                    if !is_early { cx.vtable_map.insert(ex.id, @~[vtable]); }\n+                    fcx.tcx().legacy_boxed_traits.insert(ex.id, ());\n+                }\n+            }\n           }\n           _ => ()\n         }"}]}