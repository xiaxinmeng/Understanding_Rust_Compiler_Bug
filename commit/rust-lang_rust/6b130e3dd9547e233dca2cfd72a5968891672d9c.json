{"sha": "6b130e3dd9547e233dca2cfd72a5968891672d9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMTMwZTNkZDk1NDdlMjMzZGNhMmNmZDcyYTU5Njg4OTE2NzJkOWM=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-23T18:56:36Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-11-04T10:07:47Z"}, "message": "Implement flexible target specification\n\nRemoves all target-specific knowledge from rustc. Some targets have changed\nduring this, but none of these should be very visible outside of\ncross-compilation. The changes make our targets more consistent.\n\niX86-unknown-linux-gnu is now only available as i686-unknown-linux-gnu. We\nused to accept any value of X greater than 1. i686 was released in 1995, and\nshould encompass the bare minimum of what Rust supports on x86 CPUs.\n\nThe only two windows targets are now i686-pc-windows-gnu and\nx86_64-pc-windows-gnu.\n\nThe iOS target has been renamed from arm-apple-ios to arm-apple-darwin.\n\nA complete list of the targets we accept now:\n\narm-apple-darwin\narm-linux-androideabi\narm-unknown-linux-gnueabi\narm-unknown-linux-gnueabihf\n\ni686-apple-darwin\ni686-pc-windows-gnu\ni686-unknown-freebsd\ni686-unknown-linux-gnu\n\nmips-unknown-linux-gnu\nmipsel-unknown-linux-gnu\n\nx86_64-apple-darwin\nx86_64-unknown-freebsd\nx86_64-unknown-linux-gnu\nx86_64-pc-windows-gnu\n\nCloses #16093\n\n[breaking-change]", "tree": {"sha": "e156144ba54fbba565c602bd7f4f9d99a369c058", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e156144ba54fbba565c602bd7f4f9d99a369c058"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b130e3dd9547e233dca2cfd72a5968891672d9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b130e3dd9547e233dca2cfd72a5968891672d9c", "html_url": "https://github.com/rust-lang/rust/commit/6b130e3dd9547e233dca2cfd72a5968891672d9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b130e3dd9547e233dca2cfd72a5968891672d9c/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82fb413d370f1f1094964ed07b65f97dba52cc30", "url": "https://api.github.com/repos/rust-lang/rust/commits/82fb413d370f1f1094964ed07b65f97dba52cc30", "html_url": "https://github.com/rust-lang/rust/commit/82fb413d370f1f1094964ed07b65f97dba52cc30"}], "stats": {"total": 2397, "additions": 1598, "deletions": 799}, "files": [{"sha": "9eccc2f6e4014c10accf8115ae924e3fe6be3551", "filename": "configure", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/configure", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -291,6 +291,22 @@ envopt() {\n     fi\n }\n \n+to_llvm_triple() {\n+    case $1 in\n+        i686-w64-mingw32) echo i686-pc-windows-gnu ;;\n+        x86_64-w64-mingw32) echo x86_64-pc-windows-gnu ;;\n+        *) echo $1 ;;\n+    esac\n+}\n+\n+to_gnu_triple() {\n+    case $1 in\n+        i686-pc-windows-gnu) echo i686-w64-mingw32 ;;\n+        x86_64-pc-windows-gnu) echo x86_64-w64-mingw32 ;;\n+        *) echo $1 ;;\n+    esac\n+}\n+\n msg \"looking for configure programs\"\n need_cmd cmp\n need_cmd mkdir\n@@ -350,37 +366,40 @@ case $CFG_OSTYPE in\n         # instead, msys defines $MSYSTEM which is MINGW32 on i686 and\n         # MINGW64 on x86_64.\n         CFG_CPUTYPE=i686\n-        CFG_OSTYPE=w64-mingw32\n+        CFG_OSTYPE=pc-windows-gnu\n         if [ \"$MSYSTEM\" = MINGW64 ]\n         then\n             CFG_CPUTYPE=x86_64\n-            CFG_OSTYPE=w64-mingw32\n         fi\n         ;;\n \n+    MSYS*)\n+        CFG_OSTYPE=pc-windows-gnu\n+        ;;\n+\n # Thad's Cygwin identifers below\n \n #   Vista 32 bit\n     CYGWIN_NT-6.0)\n-        CFG_OSTYPE=pc-mingw32\n+        CFG_OSTYPE=pc-windows-gnu\n         CFG_CPUTYPE=i686\n         ;;\n \n #   Vista 64 bit\n     CYGWIN_NT-6.0-WOW64)\n-        CFG_OSTYPE=w64-mingw32\n+        CFG_OSTYPE=pc-windows-gnu\n         CFG_CPUTYPE=x86_64\n         ;;\n \n #   Win 7 32 bit\n     CYGWIN_NT-6.1)\n-        CFG_OSTYPE=pc-mingw32\n+        CFG_OSTYPE=pc-windows-gnu\n         CFG_CPUTYPE=i686\n         ;;\n \n #   Win 7 64 bit\n     CYGWIN_NT-6.1-WOW64)\n-        CFG_OSTYPE=w64-mingw32\n+        CFG_OSTYPE=pc-windows-gnu\n         CFG_CPUTYPE=x86_64\n         ;;\n \n@@ -466,7 +485,6 @@ opt llvm-assertions 1 \"build LLVM with assertions\"\n opt debug 1 \"build with extra debug fun\"\n opt ratchet-bench 0 \"ratchet benchmarks\"\n opt fast-make 0 \"use .gitmodules as timestamp for submodule deps\"\n-opt mingw-cross 0 \"cross-compile for win32 using mingw\"\n opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n opt llvm-static-stdcpp 0 \"statically link to libstdc++ for LLVM\"\n@@ -487,7 +505,6 @@ valopt llvm-root \"\" \"set LLVM root\"\n valopt jemalloc-root \"\" \"set directory where libjemalloc_pic.a is located\"\n valopt build \"${DEFAULT_BUILD}\" \"GNUs ./configure syntax LLVM build triple\"\n valopt android-cross-path \"/opt/ndk_standalone\" \"Android NDK standalone path\"\n-valopt mingw32-cross-path \"\" \"MinGW32 cross compiler path\"\n \n # Many of these are saved below during the \"writing configuration\" step\n # (others are conditionally saved).\n@@ -501,12 +518,18 @@ valopt_nosave target \"${CFG_HOST}\" \"GNUs ./configure syntax LLVM target triples\"\n valopt_nosave mandir \"${CFG_PREFIX}/share/man\" \"install man pages in PATH\"\n valopt_nosave release-channel \"dev\" \"the name of the release channel to build\"\n \n+# Temporarily support old triples until buildbots get updated\n+CFG_BUILD=$(to_llvm_triple $CFG_BUILD)\n+putvar CFG_BUILD # Yes, this creates a duplicate entry, but the last one wins.\n+CFG_HOST=$(to_llvm_triple $CFG_HOST)\n+CFG_TARGET=$(to_llvm_triple $CFG_TARGET)\n+\n # On windows we just store the libraries in the bin directory because\n # there's no rpath. This is where the build system itself puts libraries;\n # --libdir is used to configure the installation directory.\n # FIXME: This needs to parameterized over target triples. Do it in platform.mk\n CFG_LIBDIR_RELATIVE=lib\n-if [ \"$CFG_OSTYPE\" = \"pc-mingw32\" ] || [ \"$CFG_OSTYPE\" = \"w64-mingw32\" ]\n+if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ]\n then\n     CFG_LIBDIR_RELATIVE=bin\n fi\n@@ -632,7 +655,7 @@ then\n fi\n \n BIN_SUF=\n-if [ \"$CFG_OSTYPE\" = \"pc-mingw32\" ] || [ \"$CFG_OSTYPE\" = \"w64-mingw32\" ]\n+if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ]\n then\n     BIN_SUF=.exe\n fi\n@@ -1100,12 +1123,15 @@ do\n \n     if [ ${do_reconfigure} -ne 0 ]\n     then\n-        msg \"configuring LLVM for $t\"\n+        # LLVM's configure doesn't recognize the new Windows triples yet\n+        gnu_t=$(to_gnu_triple $t)\n+\n+        msg \"configuring LLVM for $gnu_t\"\n \n         LLVM_TARGETS=\"--enable-targets=x86,x86_64,arm,mips\"\n-        LLVM_BUILD=\"--build=$t\"\n-        LLVM_HOST=\"--host=$t\"\n-        LLVM_TARGET=\"--target=$t\"\n+        LLVM_BUILD=\"--build=$gnu_t\"\n+        LLVM_HOST=\"--host=$gnu_t\"\n+        LLVM_TARGET=\"--target=$gnu_t\"\n \n         # Disable unused LLVM features\n         LLVM_OPTS=\"$LLVM_DBG_OPTS $LLVM_ASSERTION_OPTS --disable-docs --enable-bindings=none\"\n@@ -1119,7 +1145,7 @@ do\n         # (llvm's configure tries to find pthread first, so we have to disable it explicitly.)\n         # Also note that pthreads works badly on mingw-w64 systems: #8996\n         case \"$CFG_BUILD\" in\n-            (*-mingw32)\n+            (*-windows-*)\n             LLVM_OPTS=\"$LLVM_OPTS --disable-pthreads\"\n             ;;\n         esac\n@@ -1269,6 +1295,7 @@ putvar CFG_HOST\n putvar CFG_TARGET\n putvar CFG_LIBDIR_RELATIVE\n putvar CFG_DISABLE_MANAGE_SUBMODULES\n+putvar CFG_ANDROID_CROSS_PATH\n putvar CFG_MANDIR\n \n # Avoid spurious warnings from clang by feeding it original source on"}, {"sha": "6a66ff46a363ec6e75d807a41f0eb0fef1e658c1", "filename": "mk/cfg/arm-apple-ios", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Farm-apple-ios", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Farm-apple-ios", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-apple-ios?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -3,7 +3,7 @@ CFG_SDK_NAME_arm-apple-ios = iphoneos\n CFG_SDK_ARCHS_arm-apple-ios = armv7\n ifneq ($(findstring darwin,$(CFG_OSTYPE)),)\n CFG_IOS_SDK = $(shell xcrun --show-sdk-path -sdk iphoneos 2>/dev/null)\n-CFG_IOS_FLAGS = -target armv7-apple-darwin -isysroot $(CFG_IOS_SDK) -mios-version-min=7.0\n+CFG_IOS_FLAGS = -target armv7-apple-ios -isysroot $(CFG_IOS_SDK) -mios-version-min=7.0\n CC_arm-apple-ios = $(shell xcrun -find -sdk iphoneos clang)\n CXX_arm-apple-ios = $(shell xcrun -find -sdk iphoneos clang++)\n CPP_arm-apple-ios = $(shell xcrun -find -sdk iphoneos clang++)\n@@ -32,3 +32,4 @@ CFG_RUN_arm-apple-ios = $(2)\n CFG_RUN_TARG_arm-apple-ios = $(call CFG_RUN_arm-apple-ios,,$(2))\n RUSTC_FLAGS_arm-apple-ios := -C relocation_model=pic\n RUSTC_CROSS_FLAGS_arm-apple-ios :=-C relocation_model=pic\n+CFG_GNU_TRIPLE_arm-apple-ios := arm-apple-ios"}, {"sha": "e24a805b416e8f94b9461a45221bc2afdf9dcb93", "filename": "mk/cfg/arm-linux-androideabi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Farm-linux-androideabi", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Farm-linux-androideabi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-linux-androideabi?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -26,3 +26,4 @@ CFG_RUN_arm-linux-androideabi=\n CFG_RUN_TARG_arm-linux-androideabi=\n RUSTC_FLAGS_arm-linux-androideabi :=\n RUSTC_CROSS_FLAGS_arm-linux-androideabi :=\n+CFG_GNU_TRIPLE_arm-linux-androideabi := arm-linux-androideabi"}, {"sha": "4b7b9ad87ca3ad357c1190076e24e869cdf7d3ae", "filename": "mk/cfg/arm-unknown-linux-gnueabi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Farm-unknown-linux-gnueabi", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Farm-unknown-linux-gnueabi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-gnueabi?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -27,3 +27,4 @@ CFG_RUN_arm-unknown-linux-gnueabi=$(2)\n CFG_RUN_TARG_arm-unknown-linux-gnueabi=$(call CFG_RUN_arm-unknown-linux-gnueabi,,$(2))\n RUSTC_FLAGS_arm-unknown-linux-gnueabi :=\n RUSTC_CROSS_FLAGS_arm-unknown-linux-gnueabi :=\n+CFG_GNU_TRIPLE_arm-unknown-linux-gnueabi := arm-unknown-linux-gnueabi"}, {"sha": "535dce6b9f3e42987d517dab947a06d1e6838bb2", "filename": "mk/cfg/arm-unknown-linux-gnueabihf", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Farm-unknown-linux-gnueabihf", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Farm-unknown-linux-gnueabihf", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-gnueabihf?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -27,3 +27,4 @@ CFG_RUN_arm-unknown-linux-gnueabihf=$(2)\n CFG_RUN_TARG_arm-unknown-linux-gnueabihf=$(call CFG_RUN_arm-unknown-linux-gnueabihf,,$(2))\n RUSTC_FLAGS_arm-unknown-linux-gnueabihf := -C target-feature=+v6,+vfp2\n RUSTC_CROSS_FLAGS_arm-unknown-linux-gnueabihf :=\n+CFG_GNU_TRIPLE_arm-unknown-linux-gnueabihf := arm-unknown-linux-gnueabihf"}, {"sha": "0e0d2724ddbc4d990da91e5443dd528a73146e2b", "filename": "mk/cfg/i386-apple-ios", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fi386-apple-ios", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fi386-apple-ios", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi386-apple-ios?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -31,3 +31,4 @@ CFG_LDPATH_i386-apple-ios =\n CFG_RUN_i386-apple-ios = $(2)\n CFG_RUN_TARG_i386-apple-ios = $(call CFG_RUN_i386-apple-ios,,$(2))\n CFG_JEMALLOC_CFLAGS_i386-apple-ios = -target i386-apple-ios -Wl,-syslibroot $(CFG_IOSSIM_SDK) -Wl,-no_compact_unwind\n+CFG_GNU_TRIPLE_i386-apple-ios := i386-apple-ios"}, {"sha": "30ebbb34d4fb7408a1e83ad1558f049fd34e544c", "filename": "mk/cfg/i586-mingw32msvc", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/mk%2Fcfg%2Fi586-mingw32msvc", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/mk%2Fcfg%2Fi586-mingw32msvc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi586-mingw32msvc?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -1,29 +0,0 @@\n-# i586-mingw32msvc configuration\n-CC_i586-mingw32msvc=$(CFG_MINGW32_CROSS_PATH)/bin/i586-mingw32msvc-gcc\n-CXX_i586-mingw32msvc=$(CFG_MINGW32_CROSS_PATH)/bin/i586-mingw32msvc-g++\n-CPP_i586-mingw32msvc=$(CFG_MINGW32_CROSS_PATH)/bin/i586-mingw32msvc-cpp\n-AR_i586-mingw32msvc=$(CFG_MINGW32_CROSS_PATH)/bin/i586-mingw32msvc-ar\n-CFG_LIB_NAME_i586-mingw32msvc=$(1).dll\n-CFG_STATIC_LIB_NAME_i586-mingw32msvc=$(1).lib\n-CFG_LIB_GLOB_i586-mingw32msvc=$(1)-*.dll\n-CFG_LIB_DSYM_GLOB_i586-mingw32msvc=$(1)-*.dylib.dSYM\n-CFG_CFLAGS_i586-mingw32msvc := -march=i586 -m32 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_i586-mingw32msvc := -Wall -Werror -g -march=i586 -m32 $(CFLAGS)\n-CFG_GCCISH_CXXFLAGS_i586-mingw32msvc := -fno-rtti $(CXXFLAGS)\n-CFG_GCCISH_LINK_FLAGS_i586-mingw32msvc := -shared -g -m32\n-CFG_GCCISH_DEF_FLAG_i586-mingw32msvc :=\n-CFG_GCCISH_PRE_LIB_FLAGS_i586-mingw32msvc :=\n-CFG_GCCISH_POST_LIB_FLAGS_i586-mingw32msvc :=\n-CFG_DEF_SUFFIX_i586-mingw32msvc := .mingw32.def\n-CFG_LLC_FLAGS_i586-mingw32msvc :=\n-CFG_INSTALL_NAME_i586-mingw32msvc =\n-CFG_EXE_SUFFIX_i586-mingw32msvc := .exe\n-CFG_WINDOWSY_i586-mingw32msvc := 1\n-CFG_UNIXY_i586-mingw32msvc :=\n-CFG_PATH_MUNGE_i586-mingw32msvc := $(strip perl -i.bak -p \\\n-                             -e 's@\\\\(\\S)@/\\1@go;' \\\n-                             -e 's@^/([a-zA-Z])/@\\1:/@o;')\n-CFG_LDPATH_i586-mingw32msvc :=\n-CFG_RUN_i586-mingw32msvc=\n-CFG_RUN_TARG_i586-mingw32msvc=\n-"}, {"sha": "97ab0b31f6341f43f02779cf146ccd5937569f04", "filename": "mk/cfg/i686-apple-darwin", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fi686-apple-darwin", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fi686-apple-darwin", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-apple-darwin?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -24,4 +24,4 @@ CFG_PATH_MUNGE_i686-apple-darwin := true\n CFG_LDPATH_i686-apple-darwin :=\n CFG_RUN_i686-apple-darwin=$(2)\n CFG_RUN_TARG_i686-apple-darwin=$(call CFG_RUN_i686-apple-darwin,,$(2))\n-\n+CFG_GNU_TRIPLE_i686-apple-darwin := i686-apple-darwin"}, {"sha": "f24d8312f3ccfe23e84a9bbf40c378b361a849f1", "filename": "mk/cfg/i686-pc-windows-gnu", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fi686-pc-windows-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fi686-pc-windows-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-pc-windows-gnu?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,28 @@\n+# i686-pc-windows-gnu configuration\n+CROSS_PREFIX_i686-pc-windows-gnu=i686-pc-windows-gnu-\n+CC_i686-pc-windows-gnu=gcc\n+CXX_i686-pc-windows-gnu=g++\n+CPP_i686-pc-windows-gnu=gcc -E\n+AR_i686-pc-windows-gnu=ar\n+CFG_LIB_NAME_i686-pc-windows-gnu=$(1).dll\n+CFG_STATIC_LIB_NAME_i686-pc-windows-gnu=$(1).lib\n+CFG_LIB_GLOB_i686-pc-windows-gnu=$(1)-*.dll\n+CFG_LIB_DSYM_GLOB_i686-pc-windows-gnu=$(1)-*.dylib.dSYM\n+CFG_CFLAGS_i686-pc-windows-gnu := -march=i686 -m32 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_i686-pc-windows-gnu := -Wall -Werror -g -m32 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_i686-pc-windows-gnu := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_i686-pc-windows-gnu := -shared -g -m32\n+CFG_GCCISH_DEF_FLAG_i686-pc-windows-gnu :=\n+CFG_GCCISH_PRE_LIB_FLAGS_i686-pc-windows-gnu :=\n+CFG_GCCISH_POST_LIB_FLAGS_i686-pc-windows-gnu :=\n+CFG_DEF_SUFFIX_i686-pc-windows-gnu := .windows.def\n+CFG_LLC_FLAGS_i686-pc-windows-gnu :=\n+CFG_INSTALL_NAME_i686-pc-windows-gnu =\n+CFG_EXE_SUFFIX_i686-pc-windows-gnu := .exe\n+CFG_WINDOWSY_i686-pc-windows-gnu := 1\n+CFG_UNIXY_i686-pc-windows-gnu :=\n+CFG_PATH_MUNGE_i686-pc-windows-gnu :=\n+CFG_LDPATH_i686-pc-windows-gnu :=$(CFG_LDPATH_i686-pc-windows-gnu):$(PATH)\n+CFG_RUN_i686-pc-windows-gnu=PATH=\"$(CFG_LDPATH_i686-pc-windows-gnu):$(1)\" $(2)\n+CFG_RUN_TARG_i686-pc-windows-gnu=$(call CFG_RUN_i686-pc-windows-gnu,$(HLIB$(1)_H_$(CFG_BUILD)),$(2))\n+CFG_GNU_TRIPLE_i686-pc-windows-gnu := i686-w64-mingw32"}, {"sha": "76ed56d145b1411ff40ae3e9ee0442f48d3ae4e9", "filename": "mk/cfg/i686-unknown-linux-gnu", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fi686-unknown-linux-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fi686-unknown-linux-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-linux-gnu?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -24,4 +24,4 @@ CFG_PATH_MUNGE_i686-unknown-linux-gnu := true\n CFG_LDPATH_i686-unknown-linux-gnu :=\n CFG_RUN_i686-unknown-linux-gnu=$(2)\n CFG_RUN_TARG_i686-unknown-linux-gnu=$(call CFG_RUN_i686-unknown-linux-gnu,,$(2))\n-\n+CFG_GNU_TRIPLE_i686-unknown-linux-gnu := i686-unknown-linux-gnu"}, {"sha": "b62b805a4fb53456b295fa8f898adf2bd298a4f6", "filename": "mk/cfg/i686-w64-mingw32", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/mk%2Fcfg%2Fi686-w64-mingw32", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/mk%2Fcfg%2Fi686-w64-mingw32", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-w64-mingw32?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -1,31 +0,0 @@\n-# i686-w64-mingw32 configuration\n-CROSS_PREFIX_i686-w64-mingw32=i686-w64-mingw32-\n-CC_i686-w64-mingw32=gcc\n-CXX_i686-w64-mingw32=g++\n-CPP_i686-w64-mingw32=gcc -E\n-AR_i686-w64-mingw32=ar\n-CFG_LIB_NAME_i686-w64-mingw32=$(1).dll\n-CFG_STATIC_LIB_NAME_i686-w64-mingw32=$(1).lib\n-CFG_LIB_GLOB_i686-w64-mingw32=$(1)-*.dll\n-CFG_LIB_DSYM_GLOB_i686-w64-mingw32=$(1)-*.dylib.dSYM\n-CFG_CFLAGS_i686-w64-mingw32 := -march=i686 -m32 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_i686-w64-mingw32 := -Wall -Werror -g -m32 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n-CFG_GCCISH_CXXFLAGS_i686-w64-mingw32 := -fno-rtti $(CXXFLAGS)\n-CFG_GCCISH_LINK_FLAGS_i686-w64-mingw32 := -shared -g -m32\n-CFG_GCCISH_DEF_FLAG_i686-w64-mingw32 :=\n-CFG_GCCISH_PRE_LIB_FLAGS_i686-w64-mingw32 :=\n-CFG_GCCISH_POST_LIB_FLAGS_i686-w64-mingw32 :=\n-CFG_DEF_SUFFIX_i686-w64-mingw32 := .mingw32.def\n-CFG_LLC_FLAGS_i686-w64-mingw32 :=\n-CFG_INSTALL_NAME_i686-w64-mingw32 =\n-CFG_EXE_SUFFIX_i686-w64-mingw32 := .exe\n-CFG_WINDOWSY_i686-w64-mingw32 := 1\n-CFG_UNIXY_i686-w64-mingw32 :=\n-CFG_PATH_MUNGE_i686-w64-mingw32 :=\n-CFG_LDPATH_i686-w64-mingw32 :=$(CFG_LDPATH_i686-w64-mingw32):$(PATH)\n-CFG_RUN_i686-w64-mingw32=PATH=\"$(CFG_LDPATH_i686-w64-mingw32):$(1)\" $(2)\n-CFG_RUN_TARG_i686-w64-mingw32=$(call CFG_RUN_i686-w64-mingw32,$(HLIB$(1)_H_$(CFG_BUILD)),$(2))\n-# Stop rustc from OOMing when building itself (I think)\n-RUSTC_FLAGS_i686-w64-mingw32=-C link-args=\"-Wl,--large-address-aware\"\n-RUSTC_CROSS_FLAGS_i686-w64-mingw32 :=\n-"}, {"sha": "1caecec93d15dc6f522bea505b9723f1765215ed", "filename": "mk/cfg/mips-unknown-linux-gnu", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fmips-unknown-linux-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fmips-unknown-linux-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmips-unknown-linux-gnu?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -25,3 +25,4 @@ CFG_LDPATH_mips-unknown-linux-gnu :=\n CFG_RUN_mips-unknown-linux-gnu=\n CFG_RUN_TARG_mips-unknown-linux-gnu=\n RUSTC_FLAGS_mips-unknown-linux-gnu := -C target-cpu=mips32r2 -C target-feature=\"+mips32r2,+o32\" -C soft-float\n+CFG_GNU_TRIPLE_mips-unknown-linux-gnu := mips-unknown-linux-gnu"}, {"sha": "963965cbd6cb9b2f2fd0e513b8f4625fb7584346", "filename": "mk/cfg/mipsel-linux", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/mk%2Fcfg%2Fmipsel-linux", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/mk%2Fcfg%2Fmipsel-linux", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmipsel-linux?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -1,27 +0,0 @@\n-# mipsel-linux configuration\n-CC_mipsel-linux=mipsel-linux-gcc\n-CXX_mipsel-linux=mipsel-linux-g++\n-CPP_mipsel-linux=mipsel-linux-gcc\n-AR_mipsel-linux=mipsel-linux-ar\n-CFG_LIB_NAME_mipsel-linux=lib$(1).so\n-CFG_STATIC_LIB_NAME_mipsel-linux=lib$(1).a\n-CFG_LIB_GLOB_mipsel-linux=lib$(1)-*.so\n-CFG_LIB_DSYM_GLOB_mipsel-linux=lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_mipsel-linux := -mips32 -mabi=32 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_mipsel-linux := -Wall -g -fPIC -mips32 -mabi=32 $(CFLAGS)\n-CFG_GCCISH_CXXFLAGS_mipsel-linux := -fno-rtti $(CXXFLAGS)\n-CFG_GCCISH_LINK_FLAGS_mipsel-linux := -shared -fPIC -g -mips32\n-CFG_GCCISH_DEF_FLAG_mipsel-linux := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_mipsel-linux := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_mipsel-linux := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_mipsel-linux := .linux.def\n-CFG_LLC_FLAGS_mipsel-linux :=\n-CFG_INSTALL_NAME_mipsel-linux =\n-CFG_EXE_SUFFIX_mipsel-linux :=\n-CFG_WINDOWSY_mipsel-linux :=\n-CFG_UNIXY_mipsel-linux := 1\n-CFG_PATH_MUNGE_mipsel-linux := true\n-CFG_LDPATH_mipsel-linux :=\n-CFG_RUN_mipsel-linux=\n-CFG_RUN_TARG_mipsel-linux=\n-RUSTC_FLAGS_mipsel-linux := -C target-cpu=mips32 -C target-feature=\"+mips32,+o32\""}, {"sha": "d761d5dd090c3d4ddc5b44a292d760e687e5f25c", "filename": "mk/cfg/mipsel-unknown-linux-gnu", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fmipsel-unknown-linux-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fmipsel-unknown-linux-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmipsel-unknown-linux-gnu?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,28 @@\n+# mipsel-unknown-linux-gnu configuration\n+CC_mipsel-unknown-linux-gnu=mipsel-unknown-linux-gnu-gcc\n+CXX_mipsel-unknown-linux-gnu=mipsel-unknown-linux-gnu-g++\n+CPP_mipsel-unknown-linux-gnu=mipsel-unknown-linux-gnu-gcc\n+AR_mipsel-unknown-linux-gnu=mipsel-unknown-linux-gnu-ar\n+CFG_LIB_NAME_mipsel-unknown-linux-gnu=lib$(1).so\n+CFG_STATIC_LIB_NAME_mipsel-unknown-linux-gnu=lib$(1).a\n+CFG_LIB_GLOB_mipsel-unknown-linux-gnu=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_mipsel-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_mipsel-unknown-linux-gnu := -mips32 -mabi=32 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_mipsel-unknown-linux-gnu := -Wall -g -fPIC -mips32 -mabi=32 $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_mipsel-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_mipsel-unknown-linux-gnu := -shared -fPIC -g -mips32\n+CFG_GCCISH_DEF_FLAG_mipsel-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n+CFG_GCCISH_PRE_LIB_FLAGS_mipsel-unknown-linux-gnu := -Wl,-whole-archive\n+CFG_GCCISH_POST_LIB_FLAGS_mipsel-unknown-linux-gnu := -Wl,-no-whole-archive\n+CFG_DEF_SUFFIX_mipsel-unknown-linux-gnu := .linux.def\n+CFG_LLC_FLAGS_mipsel-unknown-linux-gnu :=\n+CFG_INSTALL_NAME_mipsel-unknown-linux-gnu =\n+CFG_EXE_SUFFIX_mipsel-unknown-linux-gnu :=\n+CFG_WINDOWSY_mipsel-unknown-linux-gnu :=\n+CFG_UNIXY_mipsel-unknown-linux-gnu := 1\n+CFG_PATH_MUNGE_mipsel-unknown-linux-gnu := true\n+CFG_LDPATH_mipsel-unknown-linux-gnu :=\n+CFG_RUN_mipsel-unknown-linux-gnu=\n+CFG_RUN_TARG_mipsel-unknown-linux-gnu=\n+RUSTC_FLAGS_mipsel-unknown-linux-gnu := -C target-cpu=mips32 -C target-feature=\"+mips32,+o32\"\n+CFG_GNU_TRIPLE_mipsel-unknown-linux-gnu := mipsel-unknown-linux-gnu"}, {"sha": "5da7c928da9bce33a4dbf8ce3514baeed4a3cea4", "filename": "mk/cfg/x86_64-apple-darwin", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fx86_64-apple-darwin", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fx86_64-apple-darwin", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-apple-darwin?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -24,3 +24,4 @@ CFG_PATH_MUNGE_x86_64-apple-darwin := true\n CFG_LDPATH_x86_64-apple-darwin :=\n CFG_RUN_x86_64-apple-darwin=$(2)\n CFG_RUN_TARG_x86_64-apple-darwin=$(call CFG_RUN_x86_64-apple-darwin,,$(2))\n+CFG_GNU_TRIPLE_x86_64-apple-darwin := x86_64-apple-darwin"}, {"sha": "fbe2e832f40883c97d71bdf3637aae191a3b0672", "filename": "mk/cfg/x86_64-pc-windows-gnu", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fx86_64-pc-windows-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fx86_64-pc-windows-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-gnu?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,28 @@\n+# x86_64-pc-windows-gnu configuration\n+CROSS_PREFIX_x86_64-pc-windows-gnu=x86_64-pc-windows-gnu-\n+CC_x86_64-pc-windows-gnu=gcc\n+CXX_x86_64-pc-windows-gnu=g++\n+CPP_x86_64-pc-windows-gnu=gcc -E\n+AR_x86_64-pc-windows-gnu=ar\n+CFG_LIB_NAME_x86_64-pc-windows-gnu=$(1).dll\n+CFG_STATIC_LIB_NAME_x86_64-pc-windows-gnu=$(1).lib\n+CFG_LIB_GLOB_x86_64-pc-windows-gnu=$(1)-*.dll\n+CFG_LIB_DSYM_GLOB_x86_64-pc-windows-gnu=$(1)-*.dylib.dSYM\n+CFG_CFLAGS_x86_64-pc-windows-gnu := -m64 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-pc-windows-gnu := -Wall -Werror -g -m64 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_x86_64-pc-windows-gnu := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_x86_64-pc-windows-gnu := -shared -g -m64\n+CFG_GCCISH_DEF_FLAG_x86_64-pc-windows-gnu :=\n+CFG_GCCISH_PRE_LIB_FLAGS_x86_64-pc-windows-gnu :=\n+CFG_GCCISH_POST_LIB_FLAGS_x86_64-pc-windows-gnu :=\n+CFG_DEF_SUFFIX_x86_64-pc-windows-gnu := .windows.def\n+CFG_LLC_FLAGS_x86_64-pc-windows-gnu :=\n+CFG_INSTALL_NAME_x86_64-pc-windows-gnu =\n+CFG_EXE_SUFFIX_x86_64-pc-windows-gnu := .exe\n+CFG_WINDOWSY_x86_64-pc-windows-gnu := 1\n+CFG_UNIXY_x86_64-pc-windows-gnu :=\n+CFG_PATH_MUNGE_x86_64-pc-windows-gnu :=\n+CFG_LDPATH_x86_64-pc-windows-gnu :=$(CFG_LDPATH_x86_64-pc-windows-gnu):$(PATH)\n+CFG_RUN_x86_64-pc-windows-gnu=PATH=\"$(CFG_LDPATH_x86_64-pc-windows-gnu):$(1)\" $(2)\n+CFG_RUN_TARG_x86_64-pc-windows-gnu=$(call CFG_RUN_x86_64-pc-windows-gnu,$(HLIB$(1)_H_$(CFG_BUILD)),$(2))\n+CFG_GNU_TRIPLE_x86_64-pc-windows-gnu := x86_64-w64-mingw32"}, {"sha": "50928d3c20e21afc3422684a3de390002a2511a6", "filename": "mk/cfg/x86_64-unknown-dragonfly", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fx86_64-unknown-dragonfly", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fx86_64-unknown-dragonfly", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-dragonfly?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -23,3 +23,4 @@ CFG_PATH_MUNGE_x86_64-unknown-dragonfly :=\n CFG_LDPATH_x86_64-unknown-dragonfly :=\n CFG_RUN_x86_64-unknown-dragonfly=$(2)\n CFG_RUN_TARG_x86_64-unknown-dragonfly=$(call CFG_RUN_x86_64-unknown-dragonfly,,$(2))\n+CFG_GNU_TRIPLE_x86_64-unknown-dragonfly := x86_64-unknown-dragonfly"}, {"sha": "1926c9873b7f1eb9b9bfeb2dbcb25c1fa94477f5", "filename": "mk/cfg/x86_64-unknown-freebsd", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fx86_64-unknown-freebsd", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fx86_64-unknown-freebsd", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-freebsd?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -23,3 +23,4 @@ CFG_PATH_MUNGE_x86_64-unknown-freebsd :=\n CFG_LDPATH_x86_64-unknown-freebsd :=\n CFG_RUN_x86_64-unknown-freebsd=$(2)\n CFG_RUN_TARG_x86_64-unknown-freebsd=$(call CFG_RUN_x86_64-unknown-freebsd,,$(2))\n+CFG_GNU_TRIPLE_x86_64-unknown-freebsd := x86_64-unknown-freebsd"}, {"sha": "5f165ade3a7cb3069841de457c7b6897e99584ed", "filename": "mk/cfg/x86_64-unknown-linux-gnu", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fx86_64-unknown-linux-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fcfg%2Fx86_64-unknown-linux-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-linux-gnu?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -24,3 +24,5 @@ CFG_PATH_MUNGE_x86_64-unknown-linux-gnu := true\n CFG_LDPATH_x86_64-unknown-linux-gnu :=\n CFG_RUN_x86_64-unknown-linux-gnu=$(2)\n CFG_RUN_TARG_x86_64-unknown-linux-gnu=$(call CFG_RUN_x86_64-unknown-linux-gnu,,$(2))\n+CFG_GNU_TRIPLE_x86_64-unknown-linux-gnu := x86_64-unknown-linux-gnu\n+"}, {"sha": "b292a83bbb432d8f58b1c9fe1cb960add4a88ae8", "filename": "mk/cfg/x86_64-w64-mingw32", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/mk%2Fcfg%2Fx86_64-w64-mingw32", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/mk%2Fcfg%2Fx86_64-w64-mingw32", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-w64-mingw32?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -1,28 +0,0 @@\n-# x86_64-w64-mingw32 configuration\n-CROSS_PREFIX_x86_64-w64-mingw32=x86_64-w64-mingw32-\n-CC_x86_64-w64-mingw32=gcc\n-CXX_x86_64-w64-mingw32=g++\n-CPP_x86_64-w64-mingw32=gcc -E\n-AR_x86_64-w64-mingw32=ar\n-CFG_LIB_NAME_x86_64-w64-mingw32=$(1).dll\n-CFG_STATIC_LIB_NAME_x86_64-w64-mingw32=$(1).lib\n-CFG_LIB_GLOB_x86_64-w64-mingw32=$(1)-*.dll\n-CFG_LIB_DSYM_GLOB_x86_64-w64-mingw32=$(1)-*.dylib.dSYM\n-CFG_CFLAGS_x86_64-w64-mingw32 := -m64 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_x86_64-w64-mingw32 := -Wall -Werror -g -m64 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n-CFG_GCCISH_CXXFLAGS_x86_64-w64-mingw32 := -fno-rtti $(CXXFLAGS)\n-CFG_GCCISH_LINK_FLAGS_x86_64-w64-mingw32 := -shared -g -m64\n-CFG_GCCISH_DEF_FLAG_x86_64-w64-mingw32 :=\n-CFG_GCCISH_PRE_LIB_FLAGS_x86_64-w64-mingw32 :=\n-CFG_GCCISH_POST_LIB_FLAGS_x86_64-w64-mingw32 :=\n-CFG_DEF_SUFFIX_x86_64-w64-mingw32 := .mingw32.def\n-CFG_LLC_FLAGS_x86_64-w64-mingw32 :=\n-CFG_INSTALL_NAME_x86_64-w64-mingw32 =\n-CFG_EXE_SUFFIX_x86_64-w64-mingw32 := .exe\n-CFG_WINDOWSY_x86_64-w64-mingw32 := 1\n-CFG_UNIXY_x86_64-w64-mingw32 :=\n-CFG_PATH_MUNGE_x86_64-w64-mingw32 :=\n-CFG_LDPATH_x86_64-w64-mingw32 :=$(CFG_LDPATH_x86_64-w64-mingw32):$(PATH)\n-CFG_RUN_x86_64-w64-mingw32=PATH=\"$(CFG_LDPATH_x86_64-w64-mingw32):$(1)\" $(2)\n-CFG_RUN_TARG_x86_64-w64-mingw32=$(call CFG_RUN_x86_64-w64-mingw32,$(HLIB$(1)_H_$(CFG_BUILD)),$(2))\n-RUSTC_CROSS_FLAGS_x86_64-w64-mingw32 :="}, {"sha": "e10fb4c7f7545cfb3fe93ec9ca36a1ca5cde75c8", "filename": "mk/main.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -311,7 +311,6 @@ export CFG_RELEASE\n export CFG_PACKAGE_NAME\n export CFG_BUILD\n export CFG_LLVM_ROOT\n-export CFG_ENABLE_MINGW_CROSS\n export CFG_PREFIX\n export CFG_LIBDIR\n export CFG_LIBDIR_RELATIVE"}, {"sha": "7204808c30a3bb29c02fdcd381cb852d53be7515", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -176,7 +176,7 @@ $$(JEMALLOC_LOCAL_$(1)): $$(JEMALLOC_DEPS) $$(MKFILE_DEPS)\n \t@$$(call E, make: jemalloc)\n \tcd \"$$(JEMALLOC_BUILD_DIR_$(1))\"; \"$(S)src/jemalloc/configure\" \\\n \t\t$$(JEMALLOC_ARGS_$(1)) --with-jemalloc-prefix=je_ $(CFG_JEMALLOC_FLAGS) \\\n-\t\t--build=$(CFG_BUILD) --host=$(1) \\\n+\t\t--build=$$(CFG_GNU_TRIPLE_$(CFG_BUILD)) --host=$$(CFG_GNU_TRIPLE_$(1)) \\\n \t\tCC=\"$$(CC_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n \t\tRANLIB=\"$$(AR_$(1)) s\" \\"}, {"sha": "e0610bfbdfe28e0d6a084e4ef175c8aed61234e9", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -75,9 +75,8 @@ def full_snapshot_name(date, rev, platform, hsh):\n \n \n def get_kernel(triple):\n-    os_name = triple.split('-')[-1]\n-    #scrub(os.getenv(\"CFG_ENABLE_MINGW_CROSS\")):\n-    if os_name == \"nt\" or os_name == \"mingw32\":\n+    os_name = triple.split('-')[2]\n+    if os_name == \"windows\":\n         return \"winnt\"\n     if os_name == \"darwin\":\n         return \"macos\""}, {"sha": "81f856c29d5d3446803381135e08b7cda390bd93", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 104, "deletions": 186, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -19,7 +19,7 @@ use driver::config::NoDebugInfo;\n use driver::session::Session;\n use driver::config;\n use metadata::common::LinkMeta;\n-use metadata::{encoder, cstore, filesearch, csearch, loader, creader};\n+use metadata::{encoder, cstore, filesearch, csearch, creader};\n use middle::trans::context::CrateContext;\n use middle::trans::common::gensym_name;\n use middle::ty;\n@@ -36,7 +36,6 @@ use std::str;\n use std::string::String;\n use flate;\n use serialize::hex::ToHex;\n-use syntax::abi;\n use syntax::ast;\n use syntax::ast_map::{PathElem, PathElems, PathName};\n use syntax::ast_map;\n@@ -363,17 +362,8 @@ pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> Stri\n pub fn get_cc_prog(sess: &Session) -> String {\n     match sess.opts.cg.linker {\n         Some(ref linker) => return linker.to_string(),\n-        None => {}\n+        None => sess.target.target.options.linker.clone(),\n     }\n-\n-    // In the future, FreeBSD will use clang as default compiler.\n-    // It would be flexible to use cc (system's default C compiler)\n-    // instead of hard-coded gcc.\n-    // For Windows, there is no cc command, so we add a condition to make it use gcc.\n-    match sess.targ_cfg.os {\n-        abi::OsWindows => \"gcc\",\n-        _ => \"cc\",\n-    }.to_string()\n }\n \n pub fn remove(sess: &Session, path: &Path) {\n@@ -397,7 +387,7 @@ pub fn link_binary(sess: &Session,\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n             sess.bug(format!(\"invalid output type `{}` for target os `{}`\",\n-                             crate_type, sess.targ_cfg.os).as_slice());\n+                             crate_type, sess.opts.target_triple).as_slice());\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -427,17 +417,20 @@ pub fn link_binary(sess: &Session,\n /// interaction with Rust code through static library is the only\n /// option for now\n pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n-    match sess.targ_cfg.os {\n-        abi::OsiOS => config::CrateTypeStaticlib,\n-        _ => config::CrateTypeExecutable\n+    if !sess.target.target.options.executables {\n+        config::CrateTypeStaticlib\n+    } else {\n+        config::CrateTypeExecutable\n     }\n }\n \n /// Checks if target supports crate_type as output\n pub fn invalid_output_for_target(sess: &Session,\n                                  crate_type: config::CrateType) -> bool {\n-    match (sess.targ_cfg.os, crate_type) {\n-        (abi::OsiOS, config::CrateTypeDylib) => true,\n+    match (sess.target.target.options.dynamic_linking,\n+           sess.target.target.options.executables, crate_type) {\n+        (false, _, config::CrateTypeDylib) => true,\n+        (_, false, config::CrateTypeExecutable) => true,\n         _ => false\n     }\n }\n@@ -459,15 +452,8 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n-            let (prefix, suffix) = match sess.targ_cfg.os {\n-                abi::OsWindows => (loader::WIN32_DLL_PREFIX, loader::WIN32_DLL_SUFFIX),\n-                abi::OsMacos => (loader::MACOS_DLL_PREFIX, loader::MACOS_DLL_SUFFIX),\n-                abi::OsLinux => (loader::LINUX_DLL_PREFIX, loader::LINUX_DLL_SUFFIX),\n-                abi::OsAndroid => (loader::ANDROID_DLL_PREFIX, loader::ANDROID_DLL_SUFFIX),\n-                abi::OsFreebsd => (loader::FREEBSD_DLL_PREFIX, loader::FREEBSD_DLL_SUFFIX),\n-                abi::OsDragonfly => (loader::DRAGONFLY_DLL_PREFIX, loader::DRAGONFLY_DLL_SUFFIX),\n-                abi::OsiOS => unreachable!(),\n-            };\n+            let (prefix, suffix) = (sess.target.target.options.dll_prefix.as_slice(),\n+                                    sess.target.target.options.dll_suffix.as_slice());\n             out_filename.with_filename(format!(\"{}{}{}\",\n                                                prefix,\n                                                libname,\n@@ -477,15 +463,8 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n-            match sess.targ_cfg.os {\n-                abi::OsWindows => out_filename.with_extension(\"exe\"),\n-                abi::OsMacos |\n-                abi::OsLinux |\n-                abi::OsAndroid |\n-                abi::OsFreebsd |\n-                abi::OsDragonfly |\n-                abi::OsiOS => out_filename.clone(),\n-            }\n+            let suffix = sess.target.target.options.exe_suffix.as_slice();\n+            out_filename.with_filename(format!(\"{}{}\", libname, suffix))\n         }\n     }\n }\n@@ -562,7 +541,8 @@ fn link_rlib<'a>(sess: &'a Session,\n         handler: handler,\n         dst: out_filename.clone(),\n         lib_search_paths: archive_search_paths(sess),\n-        os: sess.targ_cfg.os,\n+        slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n+        slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n         maybe_ar_prog: sess.opts.cg.ar.clone()\n     };\n     let mut ab = ArchiveBuilder::create(config);\n@@ -581,12 +561,12 @@ fn link_rlib<'a>(sess: &'a Session,\n     // symbol table of the archive.\n     ab.update_symbols();\n \n-    let mut ab = match sess.targ_cfg.os {\n+    let mut ab = match sess.target.target.options.is_like_osx {\n         // For OSX/iOS, we must be careful to update symbols only when adding\n         // object files.  We're about to start adding non-object files, so run\n         // `ar` now to process the object files.\n-        abi::OsMacos | abi::OsiOS => ab.build().extend(),\n-        _ => ab,\n+        true => ab.build().extend(),\n+        false => ab,\n     };\n \n     // Note that it is important that we add all of our non-object \"magical\n@@ -686,6 +666,13 @@ fn link_rlib<'a>(sess: &'a Session,\n                     remove(sess, &bc_filename);\n                 }\n             }\n+\n+            // After adding all files to the archive, we need to update the\n+            // symbol table of the archive. This currently dies on OSX (see\n+            // #11162), and isn't necessary there anyway\n+            if !sess.target.target.options.is_like_osx {\n+                ab.update_symbols();\n+            }\n         }\n \n         None => {}\n@@ -734,11 +721,13 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n // metadata file).\n fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n     let ab = link_rlib(sess, None, obj_filename, out_filename);\n-    let mut ab = match sess.targ_cfg.os {\n-        abi::OsMacos | abi::OsiOS => ab.build().extend(),\n-        _ => ab,\n+    let mut ab = match sess.target.target.options.is_like_osx {\n+        true => ab.build().extend(),\n+        false => ab,\n     };\n-    ab.add_native_library(\"morestack\").unwrap();\n+    if sess.target.target.options.morestack {\n+        ab.add_native_library(\"morestack\").unwrap();\n+    }\n     ab.add_native_library(\"compiler-rt\").unwrap();\n \n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n@@ -791,9 +780,13 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     let pname = get_cc_prog(sess);\n     let mut cmd = Command::new(pname.as_slice());\n \n-    cmd.args(sess.targ_cfg.target_strs.cc_args.as_slice());\n+    cmd.args(sess.target.target.options.pre_link_args.as_slice());\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n               trans, obj_filename, out_filename);\n+    cmd.args(sess.target.target.options.post_link_args.as_slice());\n+    if !sess.target.target.options.no_compiler_rt {\n+        cmd.arg(\"-lcompiler-rt\");\n+    }\n \n     if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n         println!(\"{}\", &cmd);\n@@ -831,16 +824,15 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // On OSX, debuggers need this utility to get run to do some munging of\n     // the symbols\n-    if (sess.targ_cfg.os == abi::OsMacos || sess.targ_cfg.os == abi::OsiOS)\n-        && (sess.opts.debuginfo != NoDebugInfo) {\n-            match Command::new(\"dsymutil\").arg(out_filename).output() {\n-                Ok(..) => {}\n-                Err(e) => {\n-                    sess.err(format!(\"failed to run dsymutil: {}\", e).as_slice());\n-                    sess.abort_if_errors();\n-                }\n+    if sess.target.target.options.is_like_osx && sess.opts.debuginfo != NoDebugInfo {\n+        match Command::new(\"dsymutil\").arg(out_filename).output() {\n+            Ok(..) => {}\n+            Err(e) => {\n+                sess.err(format!(\"failed to run dsymutil: {}\", e).as_slice());\n+                sess.abort_if_errors();\n             }\n         }\n+    }\n }\n \n fn link_args(cmd: &mut Command,\n@@ -854,10 +846,15 @@ fn link_args(cmd: &mut Command,\n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     let lib_path = sess.target_filesearch().get_lib_path();\n+\n+    // target descriptor\n+    let t = &sess.target.target;\n+\n     cmd.arg(\"-L\").arg(&lib_path);\n \n     cmd.arg(\"-o\").arg(out_filename).arg(obj_filename);\n \n+\n     // Stack growth requires statically linking a __morestack function. Note\n     // that this is listed *before* all other libraries. Due to the usage of the\n     // --as-needed flag below, the standard library may only be useful for its\n@@ -874,17 +871,15 @@ fn link_args(cmd: &mut Command,\n     // all contents of this library. This way we're guaranteed that the linker\n     // will include the __morestack symbol 100% of the time, always resolving\n     // references to it even if the object above didn't use it.\n-    match sess.targ_cfg.os {\n-        abi::OsMacos | abi::OsiOS => {\n+    if t.options.morestack {\n+        if t.options.is_like_osx {\n             let morestack = lib_path.join(\"libmorestack.a\");\n \n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(morestack.as_vec());\n             cmd.arg(v.as_slice());\n-        }\n-        _ => {\n-            cmd.args([\"-Wl,--whole-archive\", \"-lmorestack\",\n-                      \"-Wl,--no-whole-archive\"]);\n+        } else {\n+            cmd.args([\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n     }\n \n@@ -895,131 +890,72 @@ fn link_args(cmd: &mut Command,\n         cmd.arg(obj_filename.with_extension(\"metadata.o\"));\n     }\n \n-    // We want to prevent the compiler from accidentally leaking in any system\n-    // libraries, so we explicitly ask gcc to not link to any libraries by\n-    // default. Note that this does not happen for windows because windows pulls\n-    // in some large number of libraries and I couldn't quite figure out which\n-    // subset we wanted.\n-    //\n-    // FIXME(#11937) we should invoke the system linker directly\n-    if sess.targ_cfg.os != abi::OsWindows {\n-        cmd.arg(\"-nodefaultlibs\");\n-    }\n-\n     // Rust does its' own LTO\n     cmd.arg(\"-fno-lto\");\n \n-    // clang fails hard if -fno-use-linker-plugin is passed\n-    if sess.targ_cfg.os == abi::OsWindows {\n-        cmd.arg(\"-fno-use-linker-plugin\");\n+    if t.options.is_like_osx {\n+        // The dead_strip option to the linker specifies that functions and data\n+        // unreachable by the entry point will be removed. This is quite useful\n+        // with Rust's compilation model of compiling libraries at a time into\n+        // one object file. For example, this brings hello world from 1.7MB to\n+        // 458K.\n+        //\n+        // Note that this is done for both executables and dynamic libraries. We\n+        // won't get much benefit from dylibs because LLVM will have already\n+        // stripped away as much as it could. This has not been seen to impact\n+        // link times negatively.\n+        //\n+        // -dead_strip can't be part of the pre_link_args because it's also used for partial\n+        // linking when using multiple codegen units (-r). So we insert it here.\n+        cmd.arg(\"-Wl,-dead_strip\");\n     }\n \n     // If we're building a dylib, we don't use --gc-sections because LLVM has\n     // already done the best it can do, and we also don't want to eliminate the\n     // metadata. If we're building an executable, however, --gc-sections drops\n     // the size of hello world from 1.8MB to 597K, a 67% reduction.\n-    if !dylib && sess.targ_cfg.os != abi::OsMacos && sess.targ_cfg.os != abi::OsiOS {\n+    if !dylib && !t.options.is_like_osx {\n         cmd.arg(\"-Wl,--gc-sections\");\n     }\n \n     let used_link_args = sess.cstore.get_used_link_args().borrow();\n \n-    // Dynamically linked executables can be compiled as position independent if the default\n-    // relocation model of position independent code is not changed. This is a requirement to take\n-    // advantage of ASLR, as otherwise the functions in the executable are not randomized and can\n-    // be used during an exploit of a vulnerability in any code.\n-    if sess.targ_cfg.os == abi::OsLinux {\n-        let mut args = sess.opts.cg.link_args.iter().chain(used_link_args.iter());\n-        if !dylib && sess.opts.cg.relocation_model.as_slice() == \"pic\" &&\n-            !args.any(|x| x.as_slice() == \"-static\") {\n+    if t.options.position_independant_executables {\n+        let empty_vec = Vec::new();\n+        let empty_str = String::new();\n+        let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n+        let mut args = args.iter().chain(used_link_args.iter());\n+        if !dylib\n+            && (t.options.relocation_model.as_slice() == \"pic\"\n+                || sess.opts.cg.relocation_model.as_ref()\n+                   .unwrap_or(&empty_str).as_slice() == \"pic\")\n+            && !args.any(|x| x.as_slice() == \"-static\") {\n             cmd.arg(\"-pie\");\n         }\n     }\n \n-    if sess.targ_cfg.os == abi::OsLinux || sess.targ_cfg.os == abi::OsDragonfly {\n-        // GNU-style linkers will use this to omit linking to libraries which\n-        // don't actually fulfill any relocations, but only for libraries which\n-        // follow this flag. Thus, use it before specifying libraries to link to.\n-        cmd.arg(\"-Wl,--as-needed\");\n-\n+    if t.options.linker_is_gnu {\n         // GNU-style linkers support optimization with -O. GNU ld doesn't need a\n         // numeric argument, but other linkers do.\n         if sess.opts.optimize == config::Default ||\n            sess.opts.optimize == config::Aggressive {\n             cmd.arg(\"-Wl,-O1\");\n         }\n-    } else if sess.targ_cfg.os == abi::OsMacos || sess.targ_cfg.os == abi::OsiOS {\n-        // The dead_strip option to the linker specifies that functions and data\n-        // unreachable by the entry point will be removed. This is quite useful\n-        // with Rust's compilation model of compiling libraries at a time into\n-        // one object file. For example, this brings hello world from 1.7MB to\n-        // 458K.\n-        //\n-        // Note that this is done for both executables and dynamic libraries. We\n-        // won't get much benefit from dylibs because LLVM will have already\n-        // stripped away as much as it could. This has not been seen to impact\n-        // link times negatively.\n-        cmd.arg(\"-Wl,-dead_strip\");\n     }\n \n-    if sess.targ_cfg.os == abi::OsWindows {\n-        if sess.targ_cfg.arch == abi::X86 {\n-            // Make sure that we link to the dynamic libgcc, otherwise cross-module\n-            // DWARF stack unwinding will not work.\n-            // This behavior may be overridden by -Clink-args=\"-static-libgcc\"\n-            cmd.arg(\"-shared-libgcc\");\n-        } else {\n-            // On Win64 unwinding is handled by the OS, so we can link libgcc statically.\n-            cmd.arg(\"-static-libgcc\");\n-        }\n-\n-        // And here, we see obscure linker flags #45. On windows, it has been\n-        // found to be necessary to have this flag to compile liblibc.\n-        //\n-        // First a bit of background. On Windows, the file format is not ELF,\n-        // but COFF (at least according to LLVM). COFF doesn't officially allow\n-        // for section names over 8 characters, apparently. Our metadata\n-        // section, \".note.rustc\", you'll note is over 8 characters.\n-        //\n-        // On more recent versions of gcc on mingw, apparently the section name\n-        // is *not* truncated, but rather stored elsewhere in a separate lookup\n-        // table. On older versions of gcc, they apparently always truncated the\n-        // section names (at least in some cases). Truncating the section name\n-        // actually creates \"invalid\" objects [1] [2], but only for some\n-        // introspection tools, not in terms of whether it can be loaded.\n-        //\n-        // Long story short, passing this flag forces the linker to *not*\n-        // truncate section names (so we can find the metadata section after\n-        // it's compiled). The real kicker is that rust compiled just fine on\n-        // windows for quite a long time *without* this flag, so I have no idea\n-        // why it suddenly started failing for liblibc. Regardless, we\n-        // definitely don't want section name truncation, so we're keeping this\n-        // flag for windows.\n-        //\n-        // [1] - https://sourceware.org/bugzilla/show_bug.cgi?id=13130\n-        // [2] - https://code.google.com/p/go/issues/detail?id=2139\n-        cmd.arg(\"-Wl,--enable-long-section-names\");\n-\n-        // Always enable DEP (NX bit) when it is available\n-        cmd.arg(\"-Wl,--nxcompat\");\n-\n-        // Mark all dynamic libraries and executables as compatible with ASLR\n-        // FIXME #16514: ASLR is disabled on Windows due to MinGW-w64 bugs:\n-        // FIXME #17098: ASLR breaks gdb on Windows\n-        // FIXME #17684: ASLR breaks thread-local storage on Windows\n-        //cmd.arg(\"-Wl,--dynamicbase\");\n-\n-        // Mark all dynamic libraries and executables as compatible with the larger 4GiB address\n-        // space available to x86 Windows binaries on x86_64.\n-        if sess.targ_cfg.arch == abi::X86 {\n-            cmd.arg(\"-Wl,--large-address-aware\");\n-        }\n+    // We want to prevent the compiler from accidentally leaking in any system\n+    // libraries, so we explicitly ask gcc to not link to any libraries by\n+    // default. Note that this does not happen for windows because windows pulls\n+    // in some large number of libraries and I couldn't quite figure out which\n+    // subset we wanted.\n+    if !t.options.is_like_windows {\n+        cmd.arg(\"-nodefaultlibs\");\n     }\n \n-    if sess.targ_cfg.os == abi::OsAndroid {\n-        // Many of the symbols defined in compiler-rt are also defined in libgcc.\n-        // Android linker doesn't like that by default.\n-        cmd.arg(\"-Wl,--allow-multiple-definition\");\n+    // Mark all dynamic libraries and executables as compatible with ASLR\n+    // FIXME #17098: ASLR breaks gdb\n+    if t.options.is_like_windows && sess.opts.debuginfo == NoDebugInfo {\n+        // cmd.arg(\"-Wl,--dynamicbase\");\n     }\n \n     // Take careful note of the ordering of the arguments we pass to the linker\n@@ -1063,7 +999,7 @@ fn link_args(cmd: &mut Command,\n \n     if dylib {\n         // On mac we need to tell the linker to let this library be rpathed\n-        if sess.targ_cfg.os == abi::OsMacos {\n+        if sess.target.target.options.is_like_osx {\n             cmd.args([\"-dynamiclib\", \"-Wl,-dylib\"]);\n \n             if sess.opts.cg.rpath {\n@@ -1076,18 +1012,6 @@ fn link_args(cmd: &mut Command,\n         }\n     }\n \n-    if sess.targ_cfg.os == abi::OsFreebsd {\n-        cmd.args([\"-L/usr/local/lib\",\n-                  \"-L/usr/local/lib/gcc46\",\n-                  \"-L/usr/local/lib/gcc44\"]);\n-    }\n-    else if sess.targ_cfg.os == abi::OsDragonfly {\n-        cmd.args([\"-L/usr/local/lib\",\n-                  \"-L/usr/lib/gcc47\",\n-                  \"-L/usr/lib/gcc44\"]);\n-    }\n-\n-\n     // FIXME (#2397): At some point we want to rpath our guesses as to\n     // where extern libraries might live, based on the\n     // addl_lib_search_paths\n@@ -1103,27 +1027,20 @@ fn link_args(cmd: &mut Command,\n             path\n         };\n         let rpath_config = RPathConfig {\n-            os: sess.targ_cfg.os,\n             used_crates: sess.cstore.get_used_crates(cstore::RequireDynamic),\n             out_filename: out_filename.clone(),\n+            has_rpath: sess.target.target.options.has_rpath,\n+            is_like_osx: sess.target.target.options.is_like_osx,\n             get_install_prefix_lib_path: get_install_prefix_lib_path,\n             realpath: ::util::fs::realpath\n         };\n         cmd.args(rpath::get_rpath_flags(rpath_config).as_slice());\n     }\n \n-    // compiler-rt contains implementations of low-level LLVM helpers. This is\n-    // used to resolve symbols from the object file we just created, as well as\n-    // any system static libraries that may be expecting gcc instead. Most\n-    // symbols in libgcc also appear in compiler-rt.\n-    //\n-    // This is the end of the command line, so this library is used to resolve\n-    // *all* undefined symbols in all other libraries, and this is intentional.\n-    cmd.arg(\"-lcompiler-rt\");\n-\n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n-    cmd.args(sess.opts.cg.link_args.as_slice());\n+    let empty = Vec::new();\n+    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty).as_slice());\n     cmd.args(used_link_args.as_slice());\n }\n \n@@ -1152,8 +1069,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n     // For those that support this, we ensure we pass the option if the library\n     // was flagged \"static\" (most defaults are dynamic) to ensure that if\n     // libfoo.a and libfoo.so both exist that the right one is chosen.\n-    let takes_hints = sess.targ_cfg.os != abi::OsMacos &&\n-                      sess.targ_cfg.os != abi::OsiOS;\n+    let takes_hints = !sess.target.target.options.is_like_osx;\n \n     let libs = sess.cstore.get_used_libraries();\n     let libs = libs.borrow();\n@@ -1184,7 +1100,8 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n             let lib = archive::find_library(l.as_slice(),\n-                                            sess.targ_cfg.os,\n+                                            sess.target.target.options.staticlib_prefix.as_slice(),\n+                                            sess.target.target.options.staticlib_suffix.as_slice(),\n                                             search_path.as_slice(),\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();\n@@ -1257,7 +1174,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n \n     // Converts a library file-stem into a cc -l argument\n     fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n-        if stem.starts_with(\"lib\".as_bytes()) && config.os != abi::OsWindows {\n+        if stem.starts_with(\"lib\".as_bytes()) && !config.target.options.is_like_windows {\n             stem[3..]\n         } else {\n             stem\n@@ -1315,7 +1232,8 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     handler: handler,\n                     dst: dst.clone(),\n                     lib_search_paths: archive_search_paths(sess),\n-                    os: sess.targ_cfg.os,\n+                    slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n+                    slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n                     maybe_ar_prog: sess.opts.cg.ar.clone()\n                 };\n                 let mut archive = Archive::open(config);\n@@ -1342,7 +1260,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         if !dir.is_empty() { cmd.arg(\"-L\").arg(dir); }\n \n         let mut v = \"-l\".as_bytes().to_vec();\n-        v.push_all(unlib(&sess.targ_cfg, cratepath.filestem().unwrap()));\n+        v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n         cmd.arg(v.as_slice());\n     }\n }"}, {"sha": "a869db9eb6b564cb0fec3366048066e06c7b0223", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -18,7 +18,6 @@ use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef, ContextRef};\n use llvm::SMDiagnosticRef;\n use util::common::time;\n-use syntax::abi;\n use syntax::codemap;\n use syntax::diagnostic;\n use syntax::diagnostic::{Emitter, Handler, Level, mk_handler};\n@@ -150,20 +149,8 @@ impl Emitter for SharedEmitter {\n // Note that without those flags various linking errors might\n // arise as some of intrinsics are converted into function calls\n // and nobody provides implementations those functions\n-fn target_feature<'a>(sess: &'a Session) -> &'a str {\n-    match sess.targ_cfg.os {\n-        abi::OsAndroid => {\n-            if \"\" == sess.opts.cg.target_feature.as_slice() {\n-                \"+v7\"\n-            } else {\n-                sess.opts.cg.target_feature.as_slice()\n-            }\n-        },\n-        abi::OsiOS if sess.targ_cfg.arch == abi::Arm => {\n-            \"+v7,+thumb2,+vfp3,+neon\"\n-        },\n-        _ => sess.opts.cg.target_feature.as_slice()\n-    }\n+fn target_feature(sess: &Session) -> String {\n+    format!(\"{},{}\", sess.target.target.options.features, sess.opts.cg.target_feature)\n }\n \n fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n@@ -176,7 +163,11 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n }\n \n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n-    let reloc_model = match sess.opts.cg.relocation_model.as_slice() {\n+    let reloc_model_arg = match sess.opts.cg.relocation_model {\n+        Some(ref s) => s.as_slice(),\n+        None => sess.target.target.options.relocation_model.as_slice()\n+    };\n+    let reloc_model = match reloc_model_arg {\n         \"pic\" => llvm::RelocPIC,\n         \"static\" => llvm::RelocStatic,\n         \"default\" => llvm::RelocDefault,\n@@ -195,22 +186,22 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let use_softfp = sess.opts.cg.soft_float;\n \n     // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a parameter.\n-    // FIXME: #11954: mac64 unwinding may not work with fp elim\n     let no_fp_elim = (sess.opts.debuginfo != NoDebugInfo) ||\n-                     (sess.targ_cfg.os == abi::OsMacos &&\n-                      sess.targ_cfg.arch == abi::X86_64);\n+                     !sess.target.target.options.eliminate_frame_pointer;\n \n     let any_library = sess.crate_types.borrow().iter().any(|ty| {\n         *ty != config::CrateTypeExecutable\n     });\n \n-    // OSX has -dead_strip, which doesn't rely on ffunction_sections\n-    // FIXME(#13846) this should be enabled for windows\n-    let ffunction_sections = sess.targ_cfg.os != abi::OsMacos &&\n-                             sess.targ_cfg.os != abi::OsWindows;\n+    let ffunction_sections = sess.target.target.options.function_sections;\n     let fdata_sections = ffunction_sections;\n \n-    let code_model = match sess.opts.cg.code_model.as_slice() {\n+    let code_model_arg = match sess.opts.cg.code_model {\n+        Some(ref s) => s.as_slice(),\n+        None => sess.target.target.options.code_model.as_slice()\n+    };\n+\n+    let code_model = match code_model_arg {\n         \"default\" => llvm::CodeModelDefault,\n         \"small\" => llvm::CodeModelSmall,\n         \"kernel\" => llvm::CodeModelKernel,\n@@ -226,11 +217,15 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n         }\n     };\n \n-    let triple = sess.targ_cfg.target_strs.target_triple.as_slice();\n+    let triple = sess.target.target.llvm_target.as_slice();\n \n     let tm = unsafe {\n-            triple.with_c_str(|t| {\n-            sess.opts.cg.target_cpu.as_slice().with_c_str(|cpu| {\n+        triple.with_c_str(|t| {\n+            let cpu = match sess.opts.cg.target_cpu {\n+                Some(ref s) => s.as_slice(),\n+                None => sess.target.target.options.cpu.as_slice()\n+            };\n+            cpu.with_c_str(|cpu| {\n                 target_feature(sess).with_c_str(|features| {\n                     llvm::LLVMRustCreateTargetMachine(\n                         t, cpu, features,\n@@ -692,7 +687,7 @@ pub fn run_passes(sess: &Session,\n         // the desired path.  This will give the correct behavior whether or\n         // not GCC adds --force-exe-suffix.\n         let windows_output_path =\n-            if sess.targ_cfg.os == abi::OsWindows {\n+            if sess.target.target.options.is_like_windows {\n                 Some(output_path.with_extension(\"o.exe\"))\n             } else {\n                 None\n@@ -701,7 +696,7 @@ pub fn run_passes(sess: &Session,\n         let pname = get_cc_prog(sess);\n         let mut cmd = Command::new(pname.as_slice());\n \n-        cmd.args(sess.targ_cfg.target_strs.cc_args.as_slice());\n+        cmd.args(sess.target.target.options.pre_link_args.as_slice());\n         cmd.arg(\"-nostdlib\");\n \n         for index in range(0, trans.modules.len()) {\n@@ -712,6 +707,8 @@ pub fn run_passes(sess: &Session,\n            .arg(\"-o\")\n            .arg(windows_output_path.as_ref().unwrap_or(output_path));\n \n+        cmd.args(sess.target.target.options.post_link_args.as_slice());\n+\n         if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n             println!(\"{}\", &cmd);\n         }"}, {"sha": "8c1d7c839acd004473fc1cb713cfd3ee9bab54cf", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 52, "deletions": 105, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -17,17 +17,15 @@ use driver::session::Session;\n \n use back;\n use back::write;\n-use back::target_strs;\n-use back::{arm, x86, x86_64, mips, mipsel};\n+use rustc_back::target::Target;\n use lint;\n use metadata::cstore;\n \n-use syntax::abi;\n use syntax::ast;\n use syntax::ast::{IntTy, UintTy};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::diagnostic::{ColorConfig, Auto, Always, Never};\n+use syntax::diagnostic::{ColorConfig, Auto, Always, Never, SpanHandler};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n \n@@ -41,9 +39,7 @@ use std::fmt;\n use llvm;\n \n pub struct Config {\n-    pub os: abi::Os,\n-    pub arch: abi::Architecture,\n-    pub target_strs: target_strs::t,\n+    pub target: Target,\n     pub int_type: IntTy,\n     pub uint_type: UintTy,\n }\n@@ -291,6 +287,13 @@ macro_rules! cgoptions(\n             }\n         }\n \n+        fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(..) => false,\n+                None => { *slot = Some(true); true }\n+            }\n+        }\n+\n         fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = Some(s.to_string()); true },\n@@ -318,6 +321,18 @@ macro_rules! cgoptions(\n             }\n         }\n \n+        fn parse_opt_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n+                      -> bool {\n+            match v {\n+                Some(s) => {\n+                    let v = s.words().map(|s| s.to_string()).collect();\n+                    *slot = Some(v);\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n         fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n             use std::from_str::FromStr;\n             match v.and_then(FromStr::from_str) {\n@@ -351,11 +366,11 @@ cgoptions!(\n         \"tool to assemble archives with\"),\n     linker: Option<String> = (None, parse_opt_string,\n         \"system linker to link outputs with\"),\n-    link_args: Vec<String> = (Vec::new(), parse_list,\n+    link_args: Option<Vec<String>> = (None, parse_opt_list,\n         \"extra arguments to pass to the linker (space separated)\"),\n     lto: bool = (false, parse_bool,\n         \"perform LLVM link-time optimizations\"),\n-    target_cpu: String = (\"generic\".to_string(), parse_string,\n+    target_cpu: Option<String> = (None, parse_opt_string,\n         \"select target processor (llc -mcpu=help for details)\"),\n     target_feature: String = (\"\".to_string(), parse_string,\n         \"target specific attributes (llc -mattr=help for details)\"),\n@@ -379,11 +394,11 @@ cgoptions!(\n         \"prefer dynamic linking to static linking\"),\n     no_integrated_as: bool = (false, parse_bool,\n         \"use an external assembler rather than LLVM's integrated one\"),\n-    no_redzone: bool = (false, parse_bool,\n+    no_redzone: Option<bool> = (None, parse_opt_bool,\n         \"disable the use of the redzone\"),\n-    relocation_model: String = (\"pic\".to_string(), parse_string,\n+    relocation_model: Option<String> = (None, parse_opt_string,\n          \"choose the relocation model to use (llc -relocation-model for details)\"),\n-    code_model: String = (\"default\".to_string(), parse_string,\n+    code_model: Option<String> = (None, parse_opt_string,\n          \"choose the code model to use (llc -code-model for details)\"),\n     metadata: Vec<String> = (Vec::new(), parse_list,\n          \"metadata to mangle symbol names with\"),\n@@ -437,40 +452,27 @@ pub fn default_lib_output() -> CrateType {\n }\n \n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n-    let tos = match sess.targ_cfg.os {\n-        abi::OsWindows =>   InternedString::new(\"windows\"),\n-        abi::OsMacos =>     InternedString::new(\"macos\"),\n-        abi::OsLinux =>     InternedString::new(\"linux\"),\n-        abi::OsAndroid =>   InternedString::new(\"android\"),\n-        abi::OsFreebsd =>   InternedString::new(\"freebsd\"),\n-        abi::OsDragonfly => InternedString::new(\"dragonfly\"),\n-        abi::OsiOS =>       InternedString::new(\"ios\"),\n-    };\n+    use syntax::parse::token::intern_and_get_ident as intern;\n \n-    // ARM is bi-endian, however using NDK seems to default\n-    // to little-endian unless a flag is provided.\n-    let (end,arch,wordsz) = match sess.targ_cfg.arch {\n-        abi::X86 =>    (\"little\", \"x86\",    \"32\"),\n-        abi::X86_64 => (\"little\", \"x86_64\", \"64\"),\n-        abi::Arm =>    (\"little\", \"arm\",    \"32\"),\n-        abi::Mips =>   (\"big\",    \"mips\",   \"32\"),\n-        abi::Mipsel => (\"little\", \"mipsel\", \"32\")\n-    };\n+    let end = sess.target.target.target_endian.as_slice();\n+    let arch = sess.target.target.arch.as_slice();\n+    let wordsz = sess.target.target.target_word_size.as_slice();\n+    let os = sess.target.target.target_os.as_slice();\n \n-    let fam = match sess.targ_cfg.os {\n-        abi::OsWindows => InternedString::new(\"windows\"),\n-        _ => InternedString::new(\"unix\")\n+    let fam = match sess.target.target.options.is_like_windows {\n+        true  => InternedString::new(\"windows\"),\n+        false => InternedString::new(\"unix\")\n     };\n \n     let mk = attr::mk_name_value_item_str;\n     return vec!(// Target bindings.\n          attr::mk_word_item(fam.clone()),\n-         mk(InternedString::new(\"target_os\"), tos),\n+         mk(InternedString::new(\"target_os\"), intern(os)),\n          mk(InternedString::new(\"target_family\"), fam),\n-         mk(InternedString::new(\"target_arch\"), InternedString::new(arch)),\n-         mk(InternedString::new(\"target_endian\"), InternedString::new(end)),\n+         mk(InternedString::new(\"target_arch\"), intern(arch)),\n+         mk(InternedString::new(\"target_endian\"), intern(end)),\n          mk(InternedString::new(\"target_word_size\"),\n-            InternedString::new(wordsz))\n+            intern(wordsz))\n     );\n }\n \n@@ -495,78 +497,23 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n     v\n }\n \n-pub fn get_os(triple: &str) -> Option<abi::Os> {\n-    for &(name, os) in os_names.iter() {\n-        if triple.contains(name) { return Some(os) }\n-    }\n-    None\n-}\n-#[allow(non_upper_case_globals)]\n-static os_names : &'static [(&'static str, abi::Os)] = &[\n-    (\"mingw32\",   abi::OsWindows),\n-    (\"win32\",     abi::OsWindows),\n-    (\"windows\",   abi::OsWindows),\n-    (\"darwin\",    abi::OsMacos),\n-    (\"android\",   abi::OsAndroid),\n-    (\"linux\",     abi::OsLinux),\n-    (\"freebsd\",   abi::OsFreebsd),\n-    (\"dragonfly\", abi::OsDragonfly),\n-    (\"ios\",       abi::OsiOS)];\n-\n-pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    for &(arch, abi) in architecture_abis.iter() {\n-        if triple.contains(arch) { return Some(abi) }\n+pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n+    let target = match Target::search(opts.target_triple.as_slice()) {\n+        Ok(t) => t,\n+        Err(e) => {\n+            sp.handler().fatal((format!(\"Error loading target specification: {}\", e)).as_slice());\n     }\n-    None\n-}\n-#[allow(non_upper_case_globals)]\n-static architecture_abis : &'static [(&'static str, abi::Architecture)] = &[\n-    (\"i386\",   abi::X86),\n-    (\"i486\",   abi::X86),\n-    (\"i586\",   abi::X86),\n-    (\"i686\",   abi::X86),\n-    (\"i786\",   abi::X86),\n-\n-    (\"x86_64\", abi::X86_64),\n-\n-    (\"arm\",    abi::Arm),\n-    (\"xscale\", abi::Arm),\n-    (\"thumb\",  abi::Arm),\n-\n-    (\"mipsel\", abi::Mipsel),\n-    (\"mips\",   abi::Mips)];\n-\n-pub fn build_target_config(sopts: &Options) -> Config {\n-    let os = match get_os(sopts.target_triple.as_slice()) {\n-      Some(os) => os,\n-      None => early_error(\"unknown operating system\")\n-    };\n-    let arch = match get_arch(sopts.target_triple.as_slice()) {\n-      Some(arch) => arch,\n-      None => {\n-          early_error(format!(\"unknown architecture: {}\",\n-                              sopts.target_triple.as_slice()).as_slice())\n-      }\n-    };\n-    let (int_type, uint_type) = match arch {\n-      abi::X86 => (ast::TyI32, ast::TyU32),\n-      abi::X86_64 => (ast::TyI64, ast::TyU64),\n-      abi::Arm => (ast::TyI32, ast::TyU32),\n-      abi::Mips => (ast::TyI32, ast::TyU32),\n-      abi::Mipsel => (ast::TyI32, ast::TyU32)\n     };\n-    let target_triple = sopts.target_triple.clone();\n-    let target_strs = match arch {\n-      abi::X86 => x86::get_target_strs(target_triple, os),\n-      abi::X86_64 => x86_64::get_target_strs(target_triple, os),\n-      abi::Arm => arm::get_target_strs(target_triple, os),\n-      abi::Mips => mips::get_target_strs(target_triple, os),\n-      abi::Mipsel => mipsel::get_target_strs(target_triple, os)\n+\n+    let (int_type, uint_type) = match target.target_word_size.as_slice() {\n+        \"32\" => (ast::TyI32, ast::TyU32),\n+        \"64\" => (ast::TyI64, ast::TyU64),\n+        w    => sp.handler().fatal((format!(\"target specification was invalid: unrecognized \\\n+                                            target-word-size {}\", w)).as_slice())\n     };\n+\n     Config {\n-        os: os,\n-        arch: arch,\n-        target_strs: target_strs,\n+        target: target,\n         int_type: int_type,\n         uint_type: uint_type,\n     }"}, {"sha": "d347f113af32254dc1441f044e98d5a613504606", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -749,8 +749,8 @@ pub fn collect_crate_types(session: &Session,\n \n         if !res {\n             session.warn(format!(\"dropping unsupported crate type `{}` \\\n-                                   for target os `{}`\",\n-                                 *crate_type, session.targ_cfg.os).as_slice());\n+                                   for target `{}`\",\n+                                 *crate_type, session.opts.target_triple).as_slice());\n         }\n \n         res"}, {"sha": "7715f0e10f5590b573d64b5d01b24a33a478feac", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -435,7 +435,7 @@ pub fn early_warn(msg: &str) {\n \n pub fn list_metadata(sess: &Session, path: &Path,\n                      out: &mut io::Writer) -> io::IoResult<()> {\n-    metadata::loader::list_file_metadata(sess.targ_cfg.os, path, out)\n+    metadata::loader::list_file_metadata(sess.target.target.options.is_like_osx, path, out)\n }\n \n /// Run a procedure which will detect failures in the compiler and print nicer"}, {"sha": "57c65ccebc5b2d4b622c91c98070c2f4b47fc58b", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -32,7 +32,7 @@ use std::cell::{Cell, RefCell};\n // Represents the data associated with a compilation\n // session for a single crate.\n pub struct Session {\n-    pub targ_cfg: config::Config,\n+    pub target: config::Config,\n     pub opts: config::Options,\n     pub cstore: CStore,\n     pub parse_sess: ParseSess,\n@@ -219,7 +219,7 @@ pub fn build_session_(sopts: config::Options,\n                       local_crate_source_file: Option<Path>,\n                       span_diagnostic: diagnostic::SpanHandler)\n                       -> Session {\n-    let target_cfg = config::build_target_config(&sopts);\n+    let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic);\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,\n@@ -236,7 +236,7 @@ pub fn build_session_(sopts: config::Options,\n     );\n \n     let sess = Session {\n-        targ_cfg: target_cfg,\n+        target: target_cfg,\n         opts: sopts,\n         cstore: CStore::new(token::get_ident_interner()),\n         parse_sess: p_s,"}, {"sha": "c00551b220d692712d656b01f81966d80c6c0c4a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -210,7 +210,7 @@ impl LintPass for TypeLimits {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n                                 let int_type = if t == ast::TyI {\n-                                    cx.sess().targ_cfg.int_type\n+                                    cx.sess().target.int_type\n                                 } else { t };\n                                 let (min, max) = int_ty_range(int_type);\n                                 let negative = self.negated_expr_id == e.id;\n@@ -227,7 +227,7 @@ impl LintPass for TypeLimits {\n                     },\n                     ty::ty_uint(t) => {\n                         let uint_type = if t == ast::TyU {\n-                            cx.sess().targ_cfg.uint_type\n+                            cx.sess().target.uint_type\n                         } else { t };\n                         let (min, max) = uint_ty_range(uint_type);\n                         let lit_val: u64 = match lit.node {"}, {"sha": "91d7eeaf8f284144059b8a0259a8d198baced7b9", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -14,7 +14,7 @@\n \n use back::svh::Svh;\n use driver::session::Session;\n-use driver::{driver, config};\n+use driver::driver;\n use metadata::cstore;\n use metadata::cstore::{CStore, CrateSource};\n use metadata::decoder;\n@@ -237,6 +237,9 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                             Some(k) => {\n                                 if k.equiv(&(\"static\")) {\n                                     cstore::NativeStatic\n+                                } else if e.sess.target.target.options.is_like_osx\n+                                          && k.equiv(&(\"framework\")) {\n+                                    cstore::NativeFramework\n                                 } else if k.equiv(&(\"framework\")) {\n                                     cstore::NativeFramework\n                                 } else {\n@@ -285,8 +288,7 @@ fn register_native_lib(sess: &Session, span: Option<Span>, name: String,\n         }\n         return\n     }\n-    let is_osx = sess.targ_cfg.os == abi::OsMacos ||\n-                 sess.targ_cfg.os == abi::OsiOS;\n+    let is_osx = sess.target.target.options.is_like_osx;\n     if kind == cstore::NativeFramework && !is_osx {\n         let msg = \"native frameworks are only available on OSX targets\";\n         match span {\n@@ -400,8 +402,7 @@ fn resolve_crate<'a>(e: &mut Env,\n                 crate_name: name,\n                 hash: hash.map(|a| &*a),\n                 filesearch: e.sess.target_filesearch(),\n-                os: e.sess.targ_cfg.os,\n-                triple: e.sess.targ_cfg.target_strs.target_triple.as_slice(),\n+                triple: e.sess.opts.target_triple.as_slice(),\n                 root: root,\n                 rejected_via_hash: vec!(),\n                 rejected_via_triple: vec!(),\n@@ -451,10 +452,9 @@ impl<'a> PluginMetadataReader<'a> {\n \n     pub fn read_plugin_metadata(&mut self, krate: &ast::ViewItem) -> PluginMetadata {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n-        let target_triple = self.env.sess.targ_cfg.target_strs.target_triple.as_slice();\n+        let target_triple = self.env.sess.opts.target_triple.as_slice();\n         let is_cross = target_triple != driver::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n-        let os = config::get_os(driver::host_triple()).unwrap();\n         let mut load_ctxt = loader::Context {\n             sess: self.env.sess,\n             span: krate.span,\n@@ -463,7 +463,6 @@ impl<'a> PluginMetadataReader<'a> {\n             hash: None,\n             filesearch: self.env.sess.host_filesearch(),\n             triple: driver::host_triple(),\n-            os: os,\n             root: &None,\n             rejected_via_hash: vec!(),\n             rejected_via_triple: vec!(),\n@@ -475,7 +474,6 @@ impl<'a> PluginMetadataReader<'a> {\n                 // try loading from target crates (only valid if there are\n                 // no syntax extensions)\n                 load_ctxt.triple = target_triple;\n-                load_ctxt.os = self.env.sess.targ_cfg.os;\n                 load_ctxt.filesearch = self.env.sess.target_filesearch();\n                 let lib = load_ctxt.load_library_crate();\n                 if decoder::get_plugin_registrar_fn(lib.metadata.as_slice()).is_some() {"}, {"sha": "da7e78d272fd85694404b9b2014e0fa26f1427fe", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -2071,8 +2071,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate:\n     encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name.as_slice());\n     encode_crate_triple(&mut rbml_w,\n                         tcx.sess\n-                           .targ_cfg\n-                           .target_strs\n+                           .opts\n                            .target_triple\n                            .as_slice());\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);"}, {"sha": "f46af9088d81d7cd8662a8cb55b5650441f147f6", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 28, "deletions": 72, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -222,7 +222,6 @@ use metadata::cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n use metadata::decoder;\n use metadata::encoder;\n use metadata::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n-use syntax::abi;\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n use util::fs;\n@@ -240,24 +239,6 @@ use std::collections::hash_map::{Occupied, Vacant};\n use flate;\n use time;\n \n-pub const MACOS_DLL_PREFIX: &'static str = \"lib\";\n-pub const MACOS_DLL_SUFFIX: &'static str = \".dylib\";\n-\n-pub const WIN32_DLL_PREFIX: &'static str = \"\";\n-pub const WIN32_DLL_SUFFIX: &'static str = \".dll\";\n-\n-pub const LINUX_DLL_PREFIX: &'static str = \"lib\";\n-pub const LINUX_DLL_SUFFIX: &'static str = \".so\";\n-\n-pub const FREEBSD_DLL_PREFIX: &'static str = \"lib\";\n-pub const FREEBSD_DLL_SUFFIX: &'static str = \".so\";\n-\n-pub const DRAGONFLY_DLL_PREFIX: &'static str = \"lib\";\n-pub const DRAGONFLY_DLL_SUFFIX: &'static str = \".so\";\n-\n-pub const ANDROID_DLL_PREFIX: &'static str = \"lib\";\n-pub const ANDROID_DLL_SUFFIX: &'static str = \".so\";\n-\n pub struct CrateMismatch {\n     path: Path,\n     got: String,\n@@ -270,7 +251,6 @@ pub struct Context<'a> {\n     pub crate_name: &'a str,\n     pub hash: Option<&'a Svh>,\n     pub triple: &'a str,\n-    pub os: abi::Os,\n     pub filesearch: FileSearch<'a>,\n     pub root: &'a Option<CratePaths>,\n     pub rejected_via_hash: Vec<CrateMismatch>,\n@@ -387,9 +367,7 @@ impl<'a> Context<'a> {\n         let dypair = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = dypair.map(|(prefix, _)| {\n-            format!(\"{}{}\", prefix, self.crate_name)\n-        });\n+        let dylib_prefix = format!(\"{}{}\", dypair.ref0(), self.crate_name);\n         let rlib_prefix = format!(\"lib{}\", self.crate_name);\n \n         let mut candidates = HashMap::new();\n@@ -416,13 +394,9 @@ impl<'a> Context<'a> {\n                     file.ends_with(\".rlib\") {\n                 (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n                  true)\n-            } else if dypair.map_or(false, |(_, suffix)| {\n-                file.starts_with(dylib_prefix.as_ref().unwrap().as_slice()) &&\n-                file.ends_with(suffix)\n-            }) {\n-                let (_, suffix) = dypair.unwrap();\n-                let dylib_prefix = dylib_prefix.as_ref().unwrap().as_slice();\n-                (file.slice(dylib_prefix.len(), file.len() - suffix.len()),\n+            } else if file.starts_with(dylib_prefix.as_slice()) &&\n+                      file.ends_with(dypair.ref1().as_slice()) {\n+                (file.slice(dylib_prefix.len(), file.len() - dypair.ref1().len()),\n                  false)\n             } else {\n                 return FileDoesntMatch\n@@ -530,7 +504,8 @@ impl<'a> Context<'a> {\n \n         for lib in m.into_iter() {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n-            let metadata = match get_metadata_section(self.os, &lib) {\n+            let metadata = match get_metadata_section(self.sess.target.target.options.is_like_osx,\n+                                                      &lib) {\n                 Ok(blob) => {\n                     if self.crate_matches(blob.as_slice(), &lib) {\n                         blob\n@@ -617,16 +592,9 @@ impl<'a> Context<'a> {\n \n     // Returns the corresponding (prefix, suffix) that files need to have for\n     // dynamic libraries\n-    fn dylibname(&self) -> Option<(&'static str, &'static str)> {\n-        match self.os {\n-            abi::OsWindows => Some((WIN32_DLL_PREFIX, WIN32_DLL_SUFFIX)),\n-            abi::OsMacos => Some((MACOS_DLL_PREFIX, MACOS_DLL_SUFFIX)),\n-            abi::OsLinux => Some((LINUX_DLL_PREFIX, LINUX_DLL_SUFFIX)),\n-            abi::OsAndroid => Some((ANDROID_DLL_PREFIX, ANDROID_DLL_SUFFIX)),\n-            abi::OsFreebsd => Some((FREEBSD_DLL_PREFIX, FREEBSD_DLL_SUFFIX)),\n-            abi::OsDragonfly => Some((DRAGONFLY_DLL_PREFIX, DRAGONFLY_DLL_SUFFIX)),\n-            abi::OsiOS => None,\n-        }\n+    fn dylibname(&self) -> (String, String) {\n+        let t = &self.sess.target.target;\n+        (t.options.dll_prefix.clone(), t.options.dll_suffix.clone())\n     }\n \n     fn find_commandline_library(&mut self) -> Option<Library> {\n@@ -660,13 +628,9 @@ impl<'a> Context<'a> {\n                 if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n                     return true\n                 } else {\n-                    match dylibname {\n-                        Some((prefix, suffix)) => {\n-                            if file.starts_with(prefix) && file.ends_with(suffix) {\n-                                return true\n-                            }\n-                        }\n-                        None => {}\n+                    let (ref prefix, ref suffix) = dylibname;\n+                    if file.starts_with(prefix.as_slice()) && file.ends_with(suffix.as_slice()) {\n+                        return true\n                     }\n                 }\n                 sess.err(format!(\"extern location for {} is of an unknown type: {}\",\n@@ -726,15 +690,15 @@ impl ArchiveMetadata {\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(os: abi::Os, filename: &Path) -> Result<MetadataBlob, String> {\n+fn get_metadata_section(is_osx: bool, filename: &Path) -> Result<MetadataBlob, String> {\n     let start = time::precise_time_ns();\n-    let ret = get_metadata_section_imp(os, filename);\n+    let ret = get_metadata_section_imp(is_osx, filename);\n     info!(\"reading {} => {}ms\", filename.filename_display(),\n            (time::precise_time_ns() - start) / 1000000);\n     return ret;\n }\n \n-fn get_metadata_section_imp(os: abi::Os, filename: &Path) -> Result<MetadataBlob, String> {\n+fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlob, String> {\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n     }\n@@ -780,7 +744,7 @@ fn get_metadata_section_imp(os: abi::Os, filename: &Path) -> Result<MetadataBlob\n             let name = string::raw::from_buf_len(name_buf as *const u8,\n                                               name_len as uint);\n             debug!(\"get_metadata_section: name {}\", name);\n-            if read_meta_section_name(os).as_slice() == name.as_slice() {\n+            if read_meta_section_name(is_osx).as_slice() == name.as_slice() {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found =\n@@ -821,34 +785,26 @@ fn get_metadata_section_imp(os: abi::Os, filename: &Path) -> Result<MetadataBlob\n     }\n }\n \n-pub fn meta_section_name(os: abi::Os) -> Option<&'static str> {\n-    match os {\n-        abi::OsMacos => Some(\"__DATA,__note.rustc\"),\n-        abi::OsiOS => Some(\"__DATA,__note.rustc\"),\n-        abi::OsWindows => Some(\".note.rustc\"),\n-        abi::OsLinux => Some(\".note.rustc\"),\n-        abi::OsAndroid => Some(\".note.rustc\"),\n-        abi::OsFreebsd => Some(\".note.rustc\"),\n-        abi::OsDragonfly => Some(\".note.rustc\"),\n+pub fn meta_section_name(is_osx: bool) -> &'static str {\n+    if is_osx {\n+        \"__DATA,__note.rustc\"\n+    } else {\n+        \".note.rustc\"\n     }\n }\n \n-pub fn read_meta_section_name(os: abi::Os) -> &'static str {\n-    match os {\n-        abi::OsMacos => \"__note.rustc\",\n-        abi::OsiOS => unreachable!(),\n-        abi::OsWindows => \".note.rustc\",\n-        abi::OsLinux => \".note.rustc\",\n-        abi::OsAndroid => \".note.rustc\",\n-        abi::OsFreebsd => \".note.rustc\",\n-        abi::OsDragonfly => \".note.rustc\"\n+pub fn read_meta_section_name(is_osx: bool) -> &'static str {\n+    if is_osx {\n+        \"__note.rustc\"\n+    } else {\n+        \".note.rustc\"\n     }\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(os: abi::Os, path: &Path,\n+pub fn list_file_metadata(is_osx: bool, path: &Path,\n                           out: &mut io::Writer) -> io::IoResult<()> {\n-    match get_metadata_section(os, path) {\n+    match get_metadata_section(is_osx, path) {\n         Ok(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n         Err(msg) => {\n             write!(out, \"{}\\n\", msg)"}, {"sha": "0a28c93a34ec17cb34953502c644ac77ee824aee", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -135,13 +135,13 @@ fn calculate_type(sess: &session::Session,\n     sess.cstore.iter_crate_data(|cnum, data| {\n         let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n         if src.dylib.is_some() {\n-            add_library(sess, cnum, cstore::RequireDynamic, &mut formats);\n             debug!(\"adding dylib: {}\", data.name);\n+            add_library(sess, cnum, cstore::RequireDynamic, &mut formats);\n             let deps = csearch::get_dylib_dependency_formats(&sess.cstore, cnum);\n             for &(depnum, style) in deps.iter() {\n-                add_library(sess, depnum, style, &mut formats);\n                 debug!(\"adding {}: {}\", style,\n                        sess.cstore.get_crate_data(depnum).name.clone());\n+                add_library(sess, depnum, style, &mut formats);\n             }\n         }\n     });\n@@ -160,9 +160,9 @@ fn calculate_type(sess: &session::Session,\n         let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n         if src.dylib.is_none() && !formats.contains_key(&cnum) {\n             assert!(src.rlib.is_some());\n+            debug!(\"adding staticlib: {}\", data.name);\n             add_library(sess, cnum, cstore::RequireStatic, &mut formats);\n             ret[cnum as uint - 1] = Some(cstore::RequireStatic);\n-            debug!(\"adding staticlib: {}\", data.name);\n         }\n     });\n "}, {"sha": "d3658e89a2a5353d97ec36f3766b12bbbc8deb6a", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -62,7 +62,6 @@ use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n use middle::ty::Disr;\n-use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel};\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n@@ -410,14 +409,12 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match cx.sess().targ_cfg.arch {\n-                X86 | X86_64 => at_least_32,\n+            attempts = match cx.sess().target.target.arch.as_slice() {\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n                 // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n-                Arm => at_least_32,\n-                Mips => at_least_32,\n-                Mipsel => at_least_32,\n+                \"arm\" => at_least_32,\n+                _ => at_least_32,\n             }\n         }\n         attr::ReprAny => {"}, {"sha": "b80425e7ac85568be16c1d7a96a4338418b59b45", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -87,8 +87,7 @@ use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::rc::Rc;\n use std::{i8, i16, i32, i64};\n-use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel, Rust, RustCall};\n-use syntax::abi::{RustIntrinsic, Abi, OsWindows};\n+use syntax::abi::{Rust, RustCall, RustIntrinsic, Abi};\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -193,7 +192,8 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n         llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute);\n     }\n \n-    if ccx.tcx().sess.opts.cg.no_redzone {\n+    if ccx.tcx().sess.opts.cg.no_redzone\n+        .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n         llvm::SetFunctionAttribute(llfn, llvm::NoRedZoneAttribute)\n     }\n \n@@ -934,17 +934,16 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            match fn_ty.abi.for_target(ccx.sess().targ_cfg.os,\n-                                       ccx.sess().targ_cfg.arch) {\n-                Some(Rust) | Some(RustCall) => {\n+            match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n+                Rust | RustCall => {\n                     get_extern_rust_fn(ccx, t, name.as_slice(), did)\n                 }\n-                Some(RustIntrinsic) => {\n+                RustIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n-                Some(..) | None => {\n+                _ => {\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t,\n-                                                      name.as_slice(), None)\n+                                                      name.as_slice())\n                 }\n             }\n         }\n@@ -1143,9 +1142,10 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match ccx.sess().targ_cfg.arch {\n-        X86 | Arm | Mips | Mipsel => \"llvm.memcpy.p0i8.p0i8.i32\",\n-        X86_64 => \"llvm.memcpy.p0i8.p0i8.i64\"\n+    let key = match ccx.sess().target.target.target_word_size.as_slice() {\n+        \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n+        \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n+        tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n     };\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = PointerCast(cx, src, Type::i8p(ccx));\n@@ -1187,9 +1187,10 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: ty::t) {\n \n     let llty = type_of::type_of(ccx, ty);\n \n-    let intrinsic_key = match ccx.sess().targ_cfg.arch {\n-        X86 | Arm | Mips | Mipsel => \"llvm.memset.p0i8.i32\",\n-        X86_64 => \"llvm.memset.p0i8.i64\"\n+    let intrinsic_key = match ccx.sess().target.target.target_word_size.as_slice() {\n+        \"32\" => \"llvm.memset.p0i8.i32\",\n+        \"64\" => \"llvm.memset.p0i8.i64\",\n+        tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n     };\n \n     let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n@@ -2583,7 +2584,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n \n         // FIXME: #16581: Marking a symbol in the executable with `dllexport`\n         // linkage forces MinGW's linker to output a `.reloc` section for ASLR\n-        if ccx.sess().targ_cfg.os == OsWindows {\n+        if ccx.sess().target.target.options.is_like_windows {\n             unsafe { llvm::LLVMRustSetDLLExportStorageClass(llfn) }\n         }\n \n@@ -2803,9 +2804,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty,\n-                                                      name.get().as_slice(),\n-                                                      Some(ni.span))\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get().as_slice())\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, &*ni)\n@@ -2946,8 +2945,8 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     });\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let name = loader::meta_section_name(cx.sess().targ_cfg.os);\n-        name.unwrap_or(\"rust_metadata\").with_c_str(|buf| {\n+        let name = loader::meta_section_name(cx.sess().target.target.options.is_like_osx);\n+        name.with_c_str(|buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n         });\n     }"}, {"sha": "940964ce9af5c07e1ae56b5a048f9b181860b316", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -17,8 +17,6 @@ use middle::trans::cabi_x86_win64;\n use middle::trans::cabi_arm;\n use middle::trans::cabi_mips;\n use middle::trans::type_::Type;\n-use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel};\n-use syntax::abi::{OsWindows};\n \n #[deriving(Clone, PartialEq)]\n pub enum ArgKind {\n@@ -107,16 +105,16 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match ccx.sess().targ_cfg.arch {\n-        X86 => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n-        X86_64 =>\n-            if ccx.sess().targ_cfg.os == OsWindows {\n-                cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n-            } else {\n-                cabi_x86_64::compute_abi_info(ccx, atys, rty, ret_def)\n-            },\n-        Arm => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),\n-        Mips => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n-        Mipsel => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n+    match ccx.sess().target.target.arch.as_slice() {\n+        \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n+        \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n+            cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n+        } else {\n+            cabi_x86_64::compute_abi_info(ccx, atys, rty, ret_def)\n+        },\n+        \"arm\" => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),\n+        \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n+        a => ccx.sess().fatal((format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n+                              .as_slice()),\n     }\n }"}, {"sha": "6f8651c3e44f0d59251921c3b2e1e7de1066bf6e", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -13,7 +13,6 @@ use middle::trans::cabi::{ArgType, FnType};\n use middle::trans::type_::Type;\n use super::common::*;\n use super::machine::*;\n-use syntax::abi::{OsWindows, OsMacos, OsiOS};\n \n pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n@@ -34,19 +33,17 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n \n         enum Strategy { RetValue(Type), RetPointer }\n-        let strategy = match ccx.sess().targ_cfg.os {\n-            OsWindows | OsMacos | OsiOS => {\n-                match llsize_of_alloc(ccx, rty) {\n-                    1 => RetValue(Type::i8(ccx)),\n-                    2 => RetValue(Type::i16(ccx)),\n-                    4 => RetValue(Type::i32(ccx)),\n-                    8 => RetValue(Type::i64(ccx)),\n-                    _ => RetPointer\n-                }\n-            }\n-            _ => {\n-                RetPointer\n+        let t = &ccx.sess().target.target;\n+        let strategy = if t.options.is_like_osx || t.options.is_like_windows {\n+            match llsize_of_alloc(ccx, rty) {\n+                1 => RetValue(Type::i8(ccx)),\n+                2 => RetValue(Type::i16(ccx)),\n+                4 => RetValue(Type::i32(ccx)),\n+                8 => RetValue(Type::i64(ccx)),\n+                _ => RetPointer\n             }\n+        } else {\n+            RetPointer\n         };\n \n         match strategy {"}, {"sha": "7d2460093feee49cb93821b20b109cd4838c041f", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -34,7 +34,6 @@ use std::c_str::ToCStr;\n use std::ptr;\n use std::rc::Rc;\n use std::collections::{HashMap, HashSet};\n-use syntax::abi;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n@@ -220,16 +219,16 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n     let llmod = mod_name.with_c_str(|buf| {\n         llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n     });\n-    sess.targ_cfg\n-        .target_strs\n+    sess.target\n+        .target\n         .data_layout\n         .as_slice()\n         .with_c_str(|buf| {\n         llvm::LLVMSetDataLayout(llmod, buf);\n     });\n-    sess.targ_cfg\n-        .target_strs\n-        .target_triple\n+    sess.target\n+        .target\n+        .llvm_target\n         .as_slice()\n         .with_c_str(|buf| {\n         llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n@@ -378,8 +377,8 @@ impl LocalCrateContext {\n \n             let td = mk_target_data(shared.tcx\n                                           .sess\n-                                          .targ_cfg\n-                                          .target_strs\n+                                          .target\n+                                          .target\n                                           .data_layout\n                                           .as_slice());\n \n@@ -531,16 +530,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         }\n     }\n \n-    // Although there is an experimental implementation of LLVM which\n-    // supports SS on armv7 it wasn't approved by Apple, see:\n-    // http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20140505/216350.html\n-    // It looks like it might be never accepted to upstream LLVM.\n-    //\n-    // So far the decision was to disable them in default builds\n-    // but it could be enabled (with patched LLVM)\n     pub fn is_split_stack_supported(&self) -> bool {\n-        let ref cfg = self.sess().targ_cfg;\n-        (cfg.os != abi::OsiOS || cfg.arch != abi::Arm) && cfg.os != abi::OsWindows\n+        self.sess().target.target.options.morestack\n     }\n \n "}, {"sha": "ea7f28796f03c3b01befab8e7febdc784c4c2c24", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -211,7 +211,7 @@ use std::ptr;\n use std::rc::{Rc, Weak};\n use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n-use syntax::{abi, ast, codemap, ast_util, ast_map};\n+use syntax::{ast, codemap, ast_util, ast_map};\n use syntax::ast_util::PostExpansionMethod;\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n@@ -750,8 +750,7 @@ pub fn finalize(cx: &CrateContext) {\n         // instruct LLVM to emit an older version of dwarf, however,\n         // for OS X to understand. For more info see #11352\n         // This can be overridden using --llvm-opts -dwarf-version,N.\n-        if cx.sess().targ_cfg.os == abi::OsMacos ||\n-            cx.sess().targ_cfg.os == abi::OsiOS {\n+        if cx.sess().target.target.options.is_like_osx {\n             \"Dwarf Version\".with_c_str(\n                 |s| llvm::LLVMRustAddModuleFlag(cx.llmod(), s, 2));\n         }"}, {"sha": "bed45a28691183966947b12e1b48af15858f38c5", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 31, "deletions": 65, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -34,7 +34,7 @@ use syntax::parse::token::{InternedString, special_idents};\n use syntax::parse::token;\n use syntax::{ast};\n use syntax::{attr, ast_map};\n-use util::ppaux::{Repr, UserString};\n+use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n // Type definitions\n@@ -70,39 +70,35 @@ struct LlvmSignature {\n // Calls to external functions\n \n pub fn llvm_calling_convention(ccx: &CrateContext,\n-                               abi: Abi) -> Option<CallConv> {\n-    let os = ccx.sess().targ_cfg.os;\n-    let arch = ccx.sess().targ_cfg.arch;\n-    abi.for_target(os, arch).map(|abi| {\n-        match abi {\n-            RustIntrinsic => {\n-                // Intrinsics are emitted at the call site\n-                ccx.sess().bug(\"asked to register intrinsic fn\");\n-            }\n+                               abi: Abi) -> CallConv {\n+    match ccx.sess().target.target.adjust_abi(abi) {\n+        RustIntrinsic => {\n+            // Intrinsics are emitted at the call site\n+            ccx.sess().bug(\"asked to register intrinsic fn\");\n+        }\n \n-            Rust => {\n-                // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-                ccx.sess().unimpl(\"foreign functions with Rust ABI\");\n-            }\n+        Rust => {\n+            // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n+            ccx.sess().unimpl(\"foreign functions with Rust ABI\");\n+        }\n \n-            RustCall => {\n-                // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-                ccx.sess().unimpl(\"foreign functions with RustCall ABI\");\n-            }\n+        RustCall => {\n+            // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n+            ccx.sess().unimpl(\"foreign functions with RustCall ABI\");\n+        }\n \n-            // It's the ABI's job to select this, not us.\n-            System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n+        // It's the ABI's job to select this, not us.\n+        System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n \n-            Stdcall => llvm::X86StdcallCallConv,\n-            Fastcall => llvm::X86FastcallCallConv,\n-            C => llvm::CCallConv,\n-            Win64 => llvm::X86_64_Win64,\n+        Stdcall => llvm::X86StdcallCallConv,\n+        Fastcall => llvm::X86FastcallCallConv,\n+        C => llvm::CCallConv,\n+        Win64 => llvm::X86_64_Win64,\n \n-            // These API constants ought to be more specific...\n-            Cdecl => llvm::CCallConv,\n-            Aapcs => llvm::CCallConv,\n-        }\n-    })\n+        // These API constants ought to be more specific...\n+        Cdecl => llvm::CCallConv,\n+        Aapcs => llvm::CCallConv,\n+    }\n }\n \n pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n@@ -191,7 +187,7 @@ pub fn register_static(ccx: &CrateContext,\n }\n \n pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n-                                name: &str, span: Option<Span>) -> ValueRef {\n+                                name: &str) -> ValueRef {\n     /*!\n      * Registers a foreign function found in a library.\n      * Just adds a LLVM global.\n@@ -204,25 +200,7 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n            fty.repr(ccx.tcx()),\n            name);\n \n-    let cc = match llvm_calling_convention(ccx, abi) {\n-        Some(cc) => cc,\n-        None => {\n-            match span {\n-                Some(s) => {\n-                    ccx.sess().span_fatal(s,\n-                        format!(\"ABI `{}` has no suitable calling convention \\\n-                                 for target architecture\",\n-                                abi.user_string(ccx.tcx())).as_slice())\n-                }\n-                None => {\n-                    ccx.sess().fatal(\n-                        format!(\"ABI `{}` has no suitable calling convention \\\n-                                 for target architecture\",\n-                                abi.user_string(ccx.tcx())).as_slice())\n-                }\n-            }\n-        }\n-    };\n+    let cc = llvm_calling_convention(ccx, abi);\n \n     // Register the function as a C extern fn\n     let tys = foreign_types_for_fn_ty(ccx, fty);\n@@ -375,16 +353,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         llargs_foreign.push(llarg_foreign);\n     }\n \n-    let cc = match llvm_calling_convention(ccx, fn_abi) {\n-        Some(cc) => cc,\n-        None => {\n-            // FIXME(#8357) We really ought to report a span here\n-            ccx.sess().fatal(\n-                format!(\"ABI string `{}` has no suitable ABI \\\n-                         for target architecture\",\n-                         fn_abi.user_string(ccx.tcx())).as_slice());\n-        }\n-    };\n+    let cc = llvm_calling_convention(ccx, fn_abi);\n \n     // A function pointer is called without the declaration available, so we have to apply\n     // any attributes with ABI implications directly to the call instruction.\n@@ -498,8 +467,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                     abi => {\n                         let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n                         register_foreign_item_fn(ccx, abi, ty,\n-                                                 lname.get().as_slice(),\n-                                                 Some(foreign_item.span));\n+                                                 lname.get().as_slice());\n                         // Unlike for other items, we shouldn't call\n                         // `base::update_linkage` here.  Foreign items have\n                         // special linkage requirements, which are handled\n@@ -548,8 +516,7 @@ pub fn decl_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let cconv = match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            let c = llvm_calling_convention(ccx, fn_ty.abi);\n-            c.unwrap_or(llvm::CCallConv)\n+            llvm_calling_convention(ccx, fn_ty.abi)\n         }\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n     };\n@@ -572,8 +539,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let t = ty::node_id_to_type(ccx.tcx(), node_id);\n     let cconv = match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            let c = llvm_calling_convention(ccx, fn_ty.abi);\n-            c.unwrap_or(llvm::CCallConv)\n+            llvm_calling_convention(ccx, fn_ty.abi)\n         }\n         _ => panic!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n     };"}, {"sha": "7b8eb4e02b2bc26ec950ae8fec9a18753c80ccfd", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -17,7 +17,6 @@ use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n use middle::trans::context::CrateContext;\n \n use syntax::ast;\n-use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel};\n \n use std::c_str::ToCStr;\n use std::mem;\n@@ -105,9 +104,10 @@ impl Type {\n     }\n \n     pub fn int(ccx: &CrateContext) -> Type {\n-        match ccx.tcx().sess.targ_cfg.arch {\n-            X86 | Arm | Mips | Mipsel => Type::i32(ccx),\n-            X86_64 => Type::i64(ccx)\n+        match ccx.tcx().sess.target.target.target_word_size.as_slice() {\n+            \"32\" => Type::i32(ccx),\n+            \"64\" => Type::i64(ccx),\n+            tws => panic!(\"Unsupported target word size for int: {}\", tws),\n         }\n     }\n "}, {"sha": "0c7de4b3ac4e07e434c6bfdb03ff51dd9cd0d650", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -4840,7 +4840,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                 ast::TyU16 => disr as u16 as Disr == disr,\n                 ast::TyU32 => disr as u32 as Disr == disr,\n                 ast::TyU64 => disr as u64 as Disr == disr,\n-                ast::TyU => uint_in_range(ccx, ccx.tcx.sess.targ_cfg.uint_type, disr)\n+                ast::TyU => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n             }\n         }\n         fn int_in_range(ccx: &CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n@@ -4849,7 +4849,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                 ast::TyI16 => disr as i16 as Disr == disr,\n                 ast::TyI32 => disr as i32 as Disr == disr,\n                 ast::TyI64 => disr as i64 as Disr == disr,\n-                ast::TyI => int_in_range(ccx, ccx.tcx.sess.targ_cfg.int_type, disr)\n+                ast::TyI => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n             }\n         }\n         match ty {"}, {"sha": "db2f291e5e7deb260ec239dd76760b47696bda66", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -16,7 +16,6 @@ use std::io::{fs, TempDir};\n use std::io;\n use std::os;\n use std::str;\n-use syntax::abi;\n use syntax::diagnostic::Handler as ErrorHandler;\n \n pub static METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n@@ -25,15 +24,17 @@ pub struct ArchiveConfig<'a> {\n     pub handler: &'a ErrorHandler,\n     pub dst: Path,\n     pub lib_search_paths: Vec<Path>,\n-    pub os: abi::Os,\n+    pub slib_prefix: String,\n+    pub slib_suffix: String,\n     pub maybe_ar_prog: Option<String>\n }\n \n pub struct Archive<'a> {\n     handler: &'a ErrorHandler,\n     dst: Path,\n     lib_search_paths: Vec<Path>,\n-    os: abi::Os,\n+    slib_prefix: String,\n+    slib_suffix: String,\n     maybe_ar_prog: Option<String>\n }\n \n@@ -96,14 +97,11 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n     }\n }\n \n-pub fn find_library(name: &str, os: abi::Os, search_paths: &[Path],\n-                    handler: &ErrorHandler) -> Path {\n-    let (osprefix, osext) = match os {\n-        abi::OsWindows => (\"\", \"lib\"), _ => (\"lib\", \"a\"),\n-    };\n+pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n+                    search_paths: &[Path], handler: &ErrorHandler) -> Path {\n     // On Windows, static libraries sometimes show up as libfoo.a and other\n     // times show up as foo.lib\n-    let oslibname = format!(\"{}{}.{}\", osprefix, name, osext);\n+    let oslibname = format!(\"{}{}{}\", osprefix, name, ossuffix);\n     let unixlibname = format!(\"lib{}.a\", name);\n \n     for path in search_paths.iter() {\n@@ -122,12 +120,14 @@ pub fn find_library(name: &str, os: abi::Os, search_paths: &[Path],\n \n impl<'a> Archive<'a> {\n     fn new(config: ArchiveConfig<'a>) -> Archive<'a> {\n-        let ArchiveConfig { handler, dst, lib_search_paths, os, maybe_ar_prog } = config;\n+        let ArchiveConfig { handler, dst, lib_search_paths, slib_prefix, slib_suffix,\n+            maybe_ar_prog } = config;\n         Archive {\n             handler: handler,\n             dst: dst,\n             lib_search_paths: lib_search_paths,\n-            os: os,\n+            slib_prefix: slib_prefix,\n+            slib_suffix: slib_suffix,\n             maybe_ar_prog: maybe_ar_prog\n         }\n     }\n@@ -178,7 +178,9 @@ impl<'a> ArchiveBuilder<'a> {\n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n-        let location = find_library(name, self.archive.os,\n+        let location = find_library(name,\n+                                    self.archive.slib_prefix.as_slice(),\n+                                    self.archive.slib_suffix.as_slice(),\n                                     self.archive.lib_search_paths.as_slice(),\n                                     self.archive.handler);\n         self.add_archive(&location, name, [])"}, {"sha": "97d94437acd3328e6a0aa6b038173f399aa36095", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -51,3 +51,4 @@ pub mod svh;\n pub mod target_strs;\n pub mod x86;\n pub mod x86_64;\n+pub mod target;"}, {"sha": "e7ac1bbcf84742795cd820f662ce533e9b27e5d9", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -12,38 +12,26 @@\n use std::collections::HashSet;\n use std::os;\n use std::io::IoError;\n-use syntax::abi;\n use syntax::ast;\n \n pub struct RPathConfig<'a> {\n-    pub os: abi::Os,\n     pub used_crates: Vec<(ast::CrateNum, Option<Path>)>,\n     pub out_filename: Path,\n+    pub is_like_osx: bool,\n+    pub has_rpath: bool,\n     pub get_install_prefix_lib_path: ||:'a -> Path,\n     pub realpath: |&Path|:'a -> Result<Path, IoError>\n }\n \n pub fn get_rpath_flags(config: RPathConfig) -> Vec<String> {\n \n     // No rpath on windows\n-    if config.os == abi::OsWindows {\n+    if !config.has_rpath {\n         return Vec::new();\n     }\n \n     let mut flags = Vec::new();\n \n-    if config.os == abi::OsFreebsd {\n-        flags.push_all([\"-Wl,-rpath,/usr/local/lib/gcc46\".to_string(),\n-                        \"-Wl,-rpath,/usr/local/lib/gcc44\".to_string(),\n-                        \"-Wl,-z,origin\".to_string()]);\n-    }\n-    else if config.os == abi::OsDragonfly {\n-        flags.push_all([\"-Wl,-rpath,/usr/lib/gcc47\".to_string(),\n-                        \"-Wl,-rpath,/usr/lib/gcc44\".to_string(),\n-                        \"-Wl,-z,origin\".to_string()]);\n-    }\n-\n-\n     debug!(\"preparing the RPATH!\");\n \n     let libs = config.used_crates.clone();\n@@ -107,14 +95,11 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig,\n                                 lib: &Path) -> String {\n     use std::os;\n \n-    assert!(config.os != abi::OsWindows);\n-\n     // Mac doesn't appear to support $ORIGIN\n-    let prefix = match config.os {\n-        abi::OsAndroid | abi::OsLinux | abi::OsFreebsd | abi::OsDragonfly\n-                          => \"$ORIGIN\",\n-        abi::OsMacos => \"@loader_path\",\n-        abi::OsWindows | abi::OsiOS => unreachable!()\n+    let prefix = if config.is_like_osx {\n+        \"@loader_path\"\n+    } else {\n+        \"$ORIGIN\"\n     };\n \n     let mut lib = (config.realpath)(&os::make_absolute(lib)).unwrap();\n@@ -203,10 +188,11 @@ mod test {\n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn test_rpath_relative() {\n         let config = &mut RPathConfig {\n-            os: abi::OsLinux,\n             used_crates: Vec::new(),\n             out_filename: Path::new(\"bin/rustc\"),\n             get_install_prefix_lib_path: || panic!(),\n+            has_rpath: true,\n+            is_like_osx: false,\n             realpath: |p| Ok(p.clone())\n         };\n         let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n@@ -217,8 +203,9 @@ mod test {\n     #[cfg(target_os = \"freebsd\")]\n     fn test_rpath_relative() {\n         let config = &mut RPathConfig {\n-            os: abi::OsFreebsd,\n             used_crates: Vec::new(),\n+            has_rpath: true,\n+            is_like_osx: false,\n             out_filename: Path::new(\"bin/rustc\"),\n             get_install_prefix_lib_path: || panic!(),\n             realpath: |p| Ok(p.clone())\n@@ -231,8 +218,9 @@ mod test {\n     #[cfg(target_os = \"dragonfly\")]\n     fn test_rpath_relative() {\n         let config = &mut RPathConfig {\n-            os: abi::OsDragonfly,\n             used_crates: Vec::new(),\n+            has_rpath: true,\n+            is_like_osx: false,\n             out_filename: Path::new(\"bin/rustc\"),\n             get_install_prefix_lib_path: || panic!(),\n             realpath: |p| Ok(p.clone())\n@@ -245,8 +233,9 @@ mod test {\n     #[cfg(target_os = \"macos\")]\n     fn test_rpath_relative() {\n         let config = &mut RPathConfig {\n-            os: abi::OsMacos,\n             used_crates: Vec::new(),\n+            has_rpath: true,\n+            is_like_osx: true,\n             out_filename: Path::new(\"bin/rustc\"),\n             get_install_prefix_lib_path: || panic!(),\n             realpath: |p| Ok(p.clone())"}, {"sha": "795a2c18bc6e6322744cb9f2b6f1c80452c63640", "filename": "src/librustc_back/target/apple_base.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        // OSX has -dead_strip, which doesn't rely on ffunction_sections\n+        function_sections: false,\n+        linker: \"cc\".to_string(),\n+        dynamic_linking: true,\n+        executables: true,\n+        is_like_osx: true,\n+        morestack: true,\n+        has_rpath: true,\n+        dll_prefix: \"lib\".to_string(),\n+        dll_suffix: \".dylib\".to_string(),\n+        pre_link_args: Vec::new(),\n+        .. Default::default()\n+    }\n+}"}, {"sha": "8be98a517757fab22750975fc91090135011843e", "filename": "src/librustc_back/target/arm_apple_ios.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Farm_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Farm_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_apple_ios.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        data_layout: \"e-p:32:32:32\\\n+                      -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                      -f32:32:32-f64:64:64\\\n+                      -v64:64:64-v128:64:128\\\n+                      -a0:0:64-n32\".to_string(),\n+        llvm_target: \"arm-apple-ios\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"ios\".to_string(),\n+        options: TargetOptions {\n+            features: \"+v7,+thumb2,+vfp3,+neon\".to_string(),\n+            executables: false,\n+            dynamic_linking: false,\n+            // Although there is an experimental implementation of LLVM which\n+            // supports SS on armv7 it wasn't approved by Apple, see:\n+            // http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20140505/216350.html\n+            // It looks like it might be never accepted to upstream LLVM.\n+            morestack: false,\n+            .. super::apple_base::opts()\n+        }\n+    }\n+}"}, {"sha": "c76227207314a0149c64ba68cdc5082cbd6381dc", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::linux_base::opts();\n+    base.features = \"+v7\".to_string();\n+    // Many of the symbols defined in compiler-rt are also defined in libgcc.  Android\n+    // linker doesn't like that by default.\n+    base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n+\n+    Target {\n+        data_layout: \"e-p:32:32:32\\\n+                      -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                      -f32:32:32-f64:64:64\\\n+                      -v64:64:64-v128:64:128\\\n+                      -a0:0:64-n32\".to_string(),\n+        llvm_target: \"arm-linux-androideabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"android\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "aecab188264197e282f1e14bc849e40dc18d315e", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabi.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    let base = super::linux_base::opts();\n+    Target {\n+        data_layout: \"e-p:32:32:32\\\n+                      -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                      -f32:32:32-f64:64:64\\\n+                      -v64:64:64-v128:64:128\\\n+                      -a0:0:64-n32\".to_string(),\n+        llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+\n+        options: TargetOptions {\n+            features: \"+v6\".to_string(),\n+            .. base\n+        },\n+    }\n+}"}, {"sha": "32d183d6254e5eda5454de5830a6cc07ac4b6766", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    let base = super::linux_base::opts();\n+    Target {\n+        data_layout: \"e-p:32:32:32\\\n+                      -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                      -f32:32:32-f64:64:64\\\n+                      -v64:64:64-v128:64:128\\\n+                      -a0:0:64-n32\".to_string(),\n+        llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+\n+        options: TargetOptions {\n+            features: \"+v6,+vfp2\".to_string(),\n+            .. base\n+        }\n+    }\n+}"}, {"sha": "4e982b2b76eba2a972cc455e06e0354d05b11693", "filename": "src/librustc_back/target/dragonfly_base.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        linker: \"cc\".to_string(),\n+        dynamic_linking: true,\n+        executables: true,\n+        morestack: true,\n+        has_rpath: true,\n+        pre_link_args: vec!(\n+            \"-L/usr/local/lib\".to_string(),\n+            \"-L/usr/local/lib/gcc47\".to_string(),\n+            \"-L/usr/local/lib/gcc44\".to_string(),\n+        ),\n+\n+        .. Default::default()\n+    }\n+}\n+"}, {"sha": "ab8398fc60511d4ba9e98d27feb0a9aa188e3b42", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        linker: \"cc\".to_string(),\n+        dynamic_linking: true,\n+        executables: true,\n+        morestack: true,\n+        has_rpath: true,\n+        pre_link_args: vec!(\n+            \"-L/usr/local/lib\".to_string(),\n+            \"-L/usr/local/lib/gcc46\".to_string(),\n+            \"-L/usr/local/lib/gcc44\".to_string(),\n+        ),\n+\n+        .. Default::default()\n+    }\n+}\n+"}, {"sha": "fe336601a81ac93b1c0865ed49cf534939fadd84", "filename": "src/librustc_back/target/i386_apple_ios.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    Target {\n+        data_layout: \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n+                      -i32:32:32-i64:32:64\\\n+                      -f32:32:32-f64:32:64-v64:64:64\\\n+                      -v128:128:128-a0:0:64-f80:128:128\\\n+                      -n8:16:32\".to_string(),\n+        llvm_target: \"i386-apple-ios\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"ios\".to_string(),\n+\n+        options: super::apple_base::opts()\n+    }\n+}"}, {"sha": "eb1dbd2da63377197aacd432d5d7a9048d4619ea", "filename": "src/librustc_back/target/i686_apple_darwin.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    Target {\n+        data_layout: \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n+                      -i32:32:32-i64:32:64\\\n+                      -f32:32:32-f64:32:64-v64:64:64\\\n+                      -v128:128:128-a0:0:64-f80:128:128\\\n+                      -n8:16:32\".to_string(),\n+        llvm_target: \"i686-apple-darwin\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"macos\".to_string(),\n+\n+        options: super::apple_base::opts()\n+    }\n+}"}, {"sha": "4d75590e6647ce04f3cd5e6a7a8b7097aa3ae7f9", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut options = super::windows_base::opts();\n+\n+    // Mark all dynamic libraries and executables as compatible with the larger 4GiB address\n+    // space available to x86 Windows binaries on x86_64.\n+    options.pre_link_args.push(\"-Wl,--large-address-aware\".to_string());\n+\n+    // Make sure that we link to the dynamic libgcc, otherwise cross-module\n+    // DWARF stack unwinding will not work.\n+    // This behavior may be overridden by -Clink-args=\"-static-libgcc\"\n+    options.pre_link_args.push(\"-shared-libgcc\".to_string());\n+\n+    Target {\n+        data_layout: \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\".to_string(),\n+        llvm_target: \"i686-pc-windows-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        options: options,\n+    }\n+}"}, {"sha": "5229c443001734fd2434585a131d5b0c65976129", "filename": "src/librustc_back/target/i686_unknown_dragonfly.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    Target {\n+        data_layout: \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_string(),\n+        llvm_target: \"i686-unknown-dragonfly\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"dragonfly\".to_string(),\n+        options: super::dragonfly_base::opts()\n+    }\n+}"}, {"sha": "a7ee1b71bd8cdcec893c90d5c805773d2cbd4bdc", "filename": "src/librustc_back/target/i686_unknown_linux_gnu.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    Target {\n+        data_layout: \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_string(),\n+        llvm_target: \"i686-unknown-linux-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        options: super::linux_base::opts()\n+    }\n+}"}, {"sha": "51b817a6175ef64702c2bb7e96dd0611875db1c4", "filename": "src/librustc_back/target/linux_base.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        linker: \"cc\".to_string(),\n+        dynamic_linking: true,\n+        executables: true,\n+        morestack: true,\n+        linker_is_gnu: true,\n+        has_rpath: true,\n+        pre_link_args: vec!(\n+            // GNU-style linkers will use this to omit linking to libraries which\n+            // don't actually fulfill any relocations, but only for libraries which\n+            // follow this flag. Thus, use it before specifying libraries to link to.\n+            \"-Wl,--as-needed\".to_string(),\n+        ),\n+        position_independant_executables: true,\n+        .. Default::default()\n+    }\n+}"}, {"sha": "45e02ecb98ca6a0e02ecf83c2ace5a7bb152d737", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    Target {\n+        data_layout: \"E-p:32:32:32\\\n+                      -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                      -f32:32:32-f64:64:64\\\n+                      -v64:64:64-v128:64:128\\\n+                      -a0:0:64-n32\".to_string(),\n+        llvm_target: \"mips-unknown-linux-gnu\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"mips\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        options: super::linux_base::opts()\n+    }\n+}"}, {"sha": "1ba99b167c30a1a5b796b31055c6219bc84148b4", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    Target {\n+        data_layout: \"e-p:32:32:32\\\n+                      -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                      -f32:32:32-f64:64:64\\\n+                      -v64:64:64-v128:64:128\\\n+                      -a0:0:64-n32\".to_string(),\n+        llvm_target: \"mipsel-unknown-linux-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"mips\".to_string(),\n+        target_os: \"linux\".to_string(),\n+\n+        options: super::linux_base::opts()\n+    }\n+}"}, {"sha": "7013a890e790abdf4c1cd73c418edc365bf31e84", "filename": "src/librustc_back/target/mod.rs", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,379 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! [Flexible target specification.](https://github.com/rust-lang/rfcs/pull/131)\n+//!\n+//! Rust targets a wide variety of usecases, and in the interest of flexibility,\n+//! allows new target triples to be defined in configuration files. Most users\n+//! will not need to care about these, but this is invaluable when porting Rust\n+//! to a new platform, and allows for an unprecedented level of control over how\n+//! the compiler works.\n+//!\n+//! # Using custom targets\n+//!\n+//! A target triple, as passed via `rustc --target=TRIPLE`, will first be\n+//! compared against the list of built-in targets. This is to ease distributing\n+//! rustc (no need for configuration files) and also to hold these built-in\n+//! targets as immutable and sacred. If `TRIPLE` is not one of the built-in\n+//! targets, rustc will check if a file named `TRIPLE` exists. If it does, it\n+//! will be loaded as the target configuration. If the file does not exist,\n+//! rustc will search each directory in the environment variable\n+//! `RUST_TARGET_PATH` for a file named `TRIPLE.json`. The first one found will\n+//! be loaded. If no file is found in any of those directories, a fatal error\n+//! will be given.  `RUST_TARGET_PATH` includes `/etc/rustc` as its last entry,\n+//! to be searched by default.\n+//!\n+//! Projects defining their own targets should use\n+//! `--target=path/to/my-awesome-platform.json` instead of adding to\n+//! `RUST_TARGET_PATH`.\n+//!\n+//! # Defining a new target\n+//!\n+//! Targets are defined using [JSON](http://json.org/). The `Target` struct in\n+//! this module defines the format the JSON file should take, though each\n+//! underscore in the field names should be replaced with a hyphen (`-`) in the\n+//! JSON file. Some fields are required in every target specification, such as\n+//! `data-layout`, `llvm-target`, `target-endian`, `target-word-size`, and\n+//! `arch`. In general, options passed to rustc with `-C` override the target's\n+//! settings, though `target-feature` and `link-args` will *add* to the list\n+//! specified by the target, rather than replace.\n+\n+use serialize::json::Json;\n+use syntax::{diagnostic, abi};\n+use std::default::Default;\n+use std::io::fs::PathExtensions;\n+\n+mod windows_base;\n+mod linux_base;\n+mod apple_base;\n+mod freebsd_base;\n+mod dragonfly_base;\n+\n+mod arm_apple_ios;\n+mod arm_linux_androideabi;\n+mod arm_unknown_linux_gnueabi;\n+mod arm_unknown_linux_gnueabihf;\n+mod i686_apple_darwin;\n+mod i386_apple_ios;\n+mod i686_pc_windows_gnu;\n+mod i686_unknown_linux_gnu;\n+mod mips_unknown_linux_gnu;\n+mod mipsel_unknown_linux_gnu;\n+mod x86_64_apple_darwin;\n+mod x86_64_pc_windows_gnu;\n+mod x86_64_unknown_freebsd;\n+mod x86_64_unknown_dragonfly;\n+mod x86_64_unknown_linux_gnu;\n+\n+/// Everything `rustc` knows about how to compile for a specific target.\n+///\n+/// Every field here must be specified, and has no default value.\n+#[deriving(Clone, Show)]\n+pub struct Target {\n+    /// [Data layout](http://llvm.org/docs/LangRef.html#data-layout) to pass to LLVM.\n+    pub data_layout: String,\n+    /// Target triple to pass to LLVM.\n+    pub llvm_target: String,\n+    /// String to use as the `target_endian` `cfg` variable.\n+    pub target_endian: String,\n+    /// String to use as the `target_word_size` `cfg` variable.\n+    pub target_word_size: String,\n+    /// OS name to use for conditional compilation.\n+    pub target_os: String,\n+    /// Architecture to use for ABI considerations. Valid options: \"x86\", \"x86_64\", \"arm\", and\n+    /// \"mips\". \"mips\" includes \"mipsel\".\n+    pub arch: String,\n+    /// Optional settings with defaults.\n+    pub options: TargetOptions,\n+}\n+\n+/// Optional aspects of a target specification.\n+///\n+/// This has an implementation of `Default`, see each field for what the default is. In general,\n+/// these try to take \"minimal defaults\" that don't assume anything about the runtime they run in.\n+#[deriving(Clone, Show)]\n+pub struct TargetOptions {\n+    /// Linker to invoke. Defaults to \"cc\".\n+    pub linker: String,\n+    /// Linker arguments that are unconditionally passed *before* any user-defined libraries.\n+    pub pre_link_args: Vec<String>,\n+    /// Linker arguments that are unconditionally passed *after* any user-defined libraries.\n+    pub post_link_args: Vec<String>,\n+    /// Default CPU to pass to LLVM. Corresponds to `llc -mcpu=$cpu`. Defaults to \"default\".\n+    pub cpu: String,\n+    /// Default target features to pass to LLVM. These features will *always* be passed, and cannot\n+    /// be disabled even via `-C`. Corresponds to `llc -mattr=$features`.\n+    pub features: String,\n+    /// Whether dynamic linking is available on this target. Defaults to false.\n+    pub dynamic_linking: bool,\n+    /// Whether executables are available on this target. iOS, for example, only allows static\n+    /// libraries. Defaults to false.\n+    pub executables: bool,\n+    /// Whether LLVM's segmented stack prelude is supported by whatever runtime is available.\n+    /// Will emit stack checks and calls to __morestack. Defaults to false.\n+    pub morestack: bool,\n+    /// Relocation model to use in object file. Corresponds to `llc\n+    /// -relocation-model=$relocation_model`. Defaults to \"pic\".\n+    pub relocation_model: String,\n+    /// Code model to use. Corresponds to `llc -code-model=$code_model`. Defaults to \"default\".\n+    pub code_model: String,\n+    /// Do not emit code that uses the \"red zone\", if the ABI has one. Defaults to false.\n+    pub disable_redzone: bool,\n+    /// Eliminate frame pointers from stack frames if possible. Defaults to true.\n+    pub eliminate_frame_pointer: bool,\n+    /// Emit each function in its own section. Defaults to true.\n+    pub function_sections: bool,\n+    /// String to prepend to the name of every dynamic library. Defaults to \"lib\".\n+    pub dll_prefix: String,\n+    /// String to append to the name of every dynamic library. Defaults to \".so\".\n+    pub dll_suffix: String,\n+    /// String to append to the name of every executable.\n+    pub exe_suffix: String,\n+    /// String to prepend to the name of every static library. Defaults to \"lib\".\n+    pub staticlib_prefix: String,\n+    /// String to append to the name of every static library. Defaults to \".a\".\n+    pub staticlib_suffix: String,\n+    /// Whether the target toolchain is like OSX's. Only useful for compiling against iOS/OS X, in\n+    /// particular running dsymutil and some other stuff like `-dead_strip`. Defaults to false.\n+    pub is_like_osx: bool,\n+    /// Whether the target toolchain is like Windows'. Only useful for compiling against Windows,\n+    /// only realy used for figuring out how to find libraries, since Windows uses its own\n+    /// library naming convention. Defaults to false.\n+    pub is_like_windows: bool,\n+    /// Whether the linker support GNU-like arguments such as -O. Defaults to false.\n+    pub linker_is_gnu: bool,\n+    /// Whether the linker support rpaths or not. Defaults to false.\n+    pub has_rpath: bool,\n+    /// Whether to disable linking to compiler-rt. Defaults to false, as LLVM will emit references\n+    /// to the functions that compiler-rt provides.\n+    pub no_compiler_rt: bool,\n+    /// Dynamically linked executables can be compiled as position independent if the default\n+    /// relocation model of position independent code is not changed. This is a requirement to take\n+    /// advantage of ASLR, as otherwise the functions in the executable are not randomized and can\n+    /// be used during an exploit of a vulnerability in any code.\n+    pub position_independant_executables: bool,\n+}\n+\n+impl Default for TargetOptions {\n+    /// Create a set of \"sane defaults\" for any target. This is still incomplete, and if used for\n+    /// compilation, will certainly not work.\n+    fn default() -> TargetOptions {\n+        TargetOptions {\n+            linker: \"cc\".to_string(),\n+            pre_link_args: Vec::new(),\n+            post_link_args: Vec::new(),\n+            cpu: \"generic\".to_string(),\n+            features: \"\".to_string(),\n+            dynamic_linking: false,\n+            executables: false,\n+            morestack: false,\n+            relocation_model: \"pic\".to_string(),\n+            code_model: \"default\".to_string(),\n+            disable_redzone: false,\n+            eliminate_frame_pointer: true,\n+            function_sections: true,\n+            dll_prefix: \"lib\".to_string(),\n+            dll_suffix: \".so\".to_string(),\n+            exe_suffix: \"\".to_string(),\n+            staticlib_prefix: \"lib\".to_string(),\n+            staticlib_suffix: \".a\".to_string(),\n+            is_like_osx: false,\n+            is_like_windows: false,\n+            linker_is_gnu: false,\n+            has_rpath: false,\n+            no_compiler_rt: false,\n+            position_independant_executables: false,\n+        }\n+    }\n+}\n+\n+impl Target {\n+    /// Given a function ABI, turn \"System\" into the correct ABI for this target.\n+    pub fn adjust_abi(&self, abi: abi::Abi) -> abi::Abi {\n+        match abi {\n+            abi::System => {\n+                if self.options.is_like_windows && self.arch.as_slice() == \"x86\" {\n+                    abi::Stdcall\n+                } else {\n+                    abi::C\n+                }\n+            },\n+            abi => abi\n+        }\n+    }\n+\n+    /// Load a target descriptor from a JSON object.\n+    pub fn from_json(obj: Json) -> Target {\n+        // this is 1. ugly, 2. error prone.\n+\n+\n+        let handler = diagnostic::default_handler(diagnostic::Auto, None);\n+\n+        let get_req_field = |name: &str| {\n+            match obj.find(&name.to_string())\n+                     .map(|s| s.as_string())\n+                     .and_then(|os| os.map(|s| s.to_string())) {\n+                Some(val) => val,\n+                None =>\n+                    handler.fatal((format!(\"Field {} in target specification is required\", name))\n+                                  .as_slice())\n+            }\n+        };\n+\n+        let mut base = Target {\n+            data_layout: get_req_field(\"data-layout\"),\n+            llvm_target: get_req_field(\"llvm-target\"),\n+            target_endian: get_req_field(\"target-endian\"),\n+            target_word_size: get_req_field(\"target-word-size\"),\n+            arch: get_req_field(\"arch\"),\n+            target_os: get_req_field(\"os\"),\n+            options: Default::default(),\n+        };\n+\n+        macro_rules! key (\n+            ($key_name:ident) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                obj.find(&name).map(|o| o.as_string()\n+                                    .map(|s| base.options.$key_name = s.to_string()));\n+            } );\n+            ($key_name:ident, bool) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                obj.find(&name).map(|o| o.as_boolean().map(|s| base.options.$key_name = s));\n+            } );\n+            ($key_name:ident, list) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                obj.find(&name).map(|o| o.as_list()\n+                    .map(|v| base.options.$key_name = v.iter()\n+                        .map(|a| a.as_string().unwrap().to_string()).collect()\n+                        )\n+                    );\n+            } );\n+        )\n+\n+        key!(cpu);\n+        key!(linker);\n+        key!(relocation_model);\n+        key!(code_model);\n+        key!(dll_prefix);\n+        key!(dll_suffix);\n+        key!(exe_suffix);\n+        key!(staticlib_prefix);\n+        key!(staticlib_suffix);\n+        key!(features);\n+        key!(dynamic_linking, bool);\n+        key!(executables, bool);\n+        key!(morestack, bool);\n+        key!(disable_redzone, bool);\n+        key!(eliminate_frame_pointer, bool);\n+        key!(function_sections, bool);\n+        key!(is_like_osx, bool);\n+        key!(is_like_windows, bool);\n+        key!(linker_is_gnu, bool);\n+        key!(has_rpath, bool);\n+        key!(no_compiler_rt, bool);\n+        key!(pre_link_args, list);\n+        key!(post_link_args, list);\n+\n+        base\n+    }\n+\n+    /// Search RUST_TARGET_PATH for a JSON file specifying the given target triple. Note that it\n+    /// could also just be a bare filename already, so also check for that. If one of the hardcoded\n+    /// targets we know about, just return it directly.\n+    ///\n+    /// The error string could come from any of the APIs called, including filesystem access and\n+    /// JSON decoding.\n+    pub fn search(target: &str) -> Result<Target, String> {\n+        use std::os;\n+        use std::io::File;\n+        use std::path::Path;\n+        use serialize::json;\n+\n+        fn load_file(path: &Path) -> Result<Target, String> {\n+            let mut f = try!(File::open(path).map_err(|e| e.to_string()));\n+            let obj = try!(json::from_reader(&mut f).map_err(|e| e.to_string()));\n+            Ok(Target::from_json(obj))\n+        }\n+\n+        // this would use a match if stringify! were allowed in pattern position\n+        macro_rules! load_specific (\n+            ( $($name:ident),+ ) => (\n+                {\n+                    let target = target.replace(\"-\", \"_\");\n+                    let target = target.as_slice();\n+                    if false { }\n+                    $(\n+                        else if target == stringify!($name) {\n+                            let t = $name::target();\n+                            debug!(\"Got builtin target: {}\", t);\n+                            return Ok(t);\n+                        }\n+                    )*\n+                    else if target == \"x86_64-w64-mingw32\" {\n+                        let t = x86_64_pc_windows_gnu::target();\n+                        return Ok(t);\n+                    } else if target == \"i686-w64-mingw32\" {\n+                        let t = i686_pc_windows_gnu::target();\n+                        return Ok(t);\n+                    }\n+                }\n+            )\n+        )\n+\n+        load_specific!(\n+            x86_64_unknown_linux_gnu,\n+            i686_unknown_linux_gnu,\n+            mips_unknown_linux_gnu,\n+            mipsel_unknown_linux_gnu,\n+            arm_linux_androideabi,\n+            arm_unknown_linux_gnueabi,\n+            arm_unknown_linux_gnueabihf,\n+\n+            x86_64_unknown_freebsd,\n+\n+            x86_64_unknown_dragonfly,\n+\n+            x86_64_apple_darwin,\n+            i686_apple_darwin,\n+            i386_apple_ios,\n+            arm_apple_ios,\n+\n+            x86_64_pc_windows_gnu,\n+            i686_pc_windows_gnu\n+        )\n+\n+\n+        let path = Path::new(target);\n+\n+        if path.is_file() {\n+            return load_file(&path);\n+        }\n+\n+        let path = {\n+            let mut target = target.to_string();\n+            target.push_str(\".json\");\n+            Path::new(target)\n+        };\n+\n+        let target_path = os::getenv(\"RUST_TARGET_PATH\").unwrap_or(String::new());\n+\n+        let paths = os::split_paths(target_path.as_slice());\n+        // FIXME 16351: add a sane default search path?\n+\n+        for dir in paths.iter() {\n+            let p =  dir.join(path.clone());\n+            if p.is_file() {\n+                return load_file(&p);\n+            }\n+        }\n+\n+        Err(format!(\"Could not find specification for target {}\", target))\n+    }\n+}"}, {"sha": "148be8cab76e37aab16f2a2d7bb91d941f8879c9", "filename": "src/librustc_back/target/windows_base.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        // FIXME(#13846) this should be enabled for windows\n+        function_sections: false,\n+        linker: \"gcc\".to_string(),\n+        dynamic_linking: true,\n+        executables: true,\n+        dll_prefix: \"\".to_string(),\n+        dll_suffix: \".dll\".to_string(),\n+        exe_suffix: \".exe\".to_string(),\n+        staticlib_prefix: \"\".to_string(),\n+        staticlib_suffix: \".lib\".to_string(),\n+        morestack: false,\n+        is_like_windows: true,\n+        pre_link_args: vec!(\n+            // And here, we see obscure linker flags #45. On windows, it has been\n+            // found to be necessary to have this flag to compile liblibc.\n+            //\n+            // First a bit of background. On Windows, the file format is not ELF,\n+            // but COFF (at least according to LLVM). COFF doesn't officially allow\n+            // for section names over 8 characters, apparently. Our metadata\n+            // section, \".note.rustc\", you'll note is over 8 characters.\n+            //\n+            // On more recent versions of gcc on mingw, apparently the section name\n+            // is *not* truncated, but rather stored elsewhere in a separate lookup\n+            // table. On older versions of gcc, they apparently always truncated th\n+            // section names (at least in some cases). Truncating the section name\n+            // actually creates \"invalid\" objects [1] [2], but only for some\n+            // introspection tools, not in terms of whether it can be loaded.\n+            //\n+            // Long story short, passing this flag forces the linker to *not*\n+            // truncate section names (so we can find the metadata section after\n+            // it's compiled). The real kicker is that rust compiled just fine on\n+            // windows for quite a long time *without* this flag, so I have no idea\n+            // why it suddenly started failing for liblibc. Regardless, we\n+            // definitely don't want section name truncation, so we're keeping this\n+            // flag for windows.\n+            //\n+            // [1] - https://sourceware.org/bugzilla/show_bug.cgi?id=13130\n+            // [2] - https://code.google.com/p/go/issues/detail?id=2139\n+            \"-Wl,--enable-long-section-names\".to_string(),\n+\n+            // Tell GCC to avoid linker plugins, because we are not bundling\n+            // them with Windows installer, and Rust does its own LTO anyways.\n+            \"-fno-use-linker-plugin\".to_string(),\n+\n+            // Always enable DEP (NX bit) when it is available\n+            \"-Wl,--nxcompat\".to_string(),\n+        ),\n+\n+        .. Default::default()\n+    }\n+}"}, {"sha": "4e958d73a39da7341ca7eaa8a391ffb18916bc45", "filename": "src/librustc_back/target/x86_64_apple_darwin.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::apple_base::opts();\n+    base.eliminate_frame_pointer = false;\n+    base.pre_link_args.push(\"-m64\".to_string());\n+\n+    Target {\n+        data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                      s0:64:64-f80:128:128-n8:16:32:64\".to_string(),\n+        llvm_target: \"x86_64-apple-darwin\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"64\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"macos\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "9247e1da0a58d5fdc3496a1c6b09435eb69729fb", "filename": "src/librustc_back/target/x86_64_pc_windows_gnu.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::windows_base::opts();\n+    // On Win64 unwinding is handled by the OS, so we can link libgcc statically.\n+    base.pre_link_args.push(\"-static-libgcc\".to_string());\n+    base.pre_link_args.push(\"-m64\".to_string());\n+\n+    Target {\n+        // FIXME: Test this. Copied from linux (#2398)\n+        data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                      s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n+        llvm_target: \"x86_64-pc-windows-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"64\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "79f09a3b00bdb1b124c5645d71f61c56a80188fd", "filename": "src/librustc_back/target/x86_64_unknown_dragonfly.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    Target {\n+        data_layout: \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_string(),\n+        llvm_target: \"x86_64-unknown-dragonfly\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"32\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"dragonfly\".to_string(),\n+        options: super::dragonfly_base::opts()\n+    }\n+}"}, {"sha": "37801f3bf251944c9e211ab36da9acb9d48d3425", "filename": "src/librustc_back/target/x86_64_unknown_freebsd.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::freebsd_base::opts();\n+    base.pre_link_args.push(\"-m64\".to_string());\n+\n+    Target {\n+        data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                     f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                     s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n+        llvm_target: \"x86_64-unknown-freebsd\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"64\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"freebsd\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "ac04e6e14ba5c4256c810df7fa47d08c7642a16f", "filename": "src/librustc_back/target/x86_64_unknown_linux_gnu.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::linux_base::opts();\n+    base.pre_link_args.push(\"-m64\".to_string());\n+\n+    Target {\n+        data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                      s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n+        llvm_target: \"x86_64-unknown-linux-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_word_size: \"64\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "93662b3b63e12890939b1c3cbcdcda0788c506c5", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -183,7 +183,7 @@ fn runtest(test: &str, cratename: &str, libs: Vec<Path>, externs: core::Externs,\n     // environment to ensure that the target loads the right libraries at\n     // runtime. It would be a sad day if the *host* libraries were loaded as a\n     // mistake.\n-    let mut cmd = Command::new(outdir.path().join(\"rust_out\"));\n+    let mut cmd = Command::new(outdir.path().join(\"rust-out\"));\n     let newpath = {\n         let mut path = DynamicLibrary::search_path();\n         path.insert(0, libdir.clone());"}, {"sha": "912755d0ea0c952cd10490cd1df73ce616be99d3", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 10, "deletions": 64, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -37,30 +37,18 @@ pub enum Abi {\n #[allow(non_camel_case_types)]\n #[deriving(PartialEq)]\n pub enum Architecture {\n-    // NB. You cannot change the ordering of these\n-    // constants without adjusting IntelBits below.\n-    // (This is ensured by the test indices_are_correct().)\n     X86,\n     X86_64,\n     Arm,\n     Mips,\n     Mipsel\n }\n \n-#[allow(non_upper_case_globals)]\n-const IntelBits: u32 = (1 << (X86 as uint)) | (1 << (X86_64 as uint));\n-#[allow(non_upper_case_globals)]\n-const ArmBits: u32 = (1 << (Arm as uint));\n-\n pub struct AbiData {\n     abi: Abi,\n \n     // Name of this ABI as we like it called.\n     name: &'static str,\n-\n-    // Is it specific to a platform? If so, which one?  Also, what is\n-    // the name that LLVM gives it (in case we disagree)\n-    abi_arch: AbiArchitecture\n }\n \n pub enum AbiArchitecture {\n@@ -75,22 +63,21 @@ pub enum AbiArchitecture {\n #[allow(non_upper_case_globals)]\n static AbiDatas: &'static [AbiData] = &[\n     // Platform-specific ABIs\n-    AbiData {abi: Cdecl, name: \"cdecl\", abi_arch: Archs(IntelBits)},\n-    AbiData {abi: Stdcall, name: \"stdcall\", abi_arch: Archs(IntelBits)},\n-    AbiData {abi: Fastcall, name:\"fastcall\", abi_arch: Archs(IntelBits)},\n-    AbiData {abi: Aapcs, name: \"aapcs\", abi_arch: Archs(ArmBits)},\n-    AbiData {abi: Win64, name: \"win64\",\n-             abi_arch: Archs(1 << (X86_64 as uint))},\n+    AbiData {abi: Cdecl, name: \"cdecl\" },\n+    AbiData {abi: Stdcall, name: \"stdcall\" },\n+    AbiData {abi: Fastcall, name:\"fastcall\" },\n+    AbiData {abi: Aapcs, name: \"aapcs\" },\n+    AbiData {abi: Win64, name: \"win64\" },\n \n     // Cross-platform ABIs\n     //\n     // NB: Do not adjust this ordering without\n     // adjusting the indices below.\n-    AbiData {abi: Rust, name: \"Rust\", abi_arch: RustArch},\n-    AbiData {abi: C, name: \"C\", abi_arch: AllArch},\n-    AbiData {abi: System, name: \"system\", abi_arch: AllArch},\n-    AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\", abi_arch: RustArch},\n-    AbiData {abi: RustCall, name: \"rust-call\", abi_arch: RustArch},\n+    AbiData {abi: Rust, name: \"Rust\" },\n+    AbiData {abi: C, name: \"C\" },\n+    AbiData {abi: System, name: \"system\" },\n+    AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\" },\n+    AbiData {abi: RustCall, name: \"rust-call\" },\n ];\n \n /// Returns the ABI with the given name (if any).\n@@ -116,28 +103,6 @@ impl Abi {\n     pub fn name(&self) -> &'static str {\n         self.data().name\n     }\n-\n-    pub fn for_target(&self, os: Os, arch: Architecture) -> Option<Abi> {\n-        // If this ABI isn't actually for the specified architecture, then we\n-        // short circuit early\n-        match self.data().abi_arch {\n-            Archs(a) if a & arch.bit() == 0 => return None,\n-            Archs(_) | RustArch | AllArch => {}\n-        }\n-        // Transform this ABI as appropriate for the requested os/arch\n-        // combination.\n-        Some(match (*self, os, arch) {\n-            (System, OsWindows, X86) => Stdcall,\n-            (System, _, _) => C,\n-            (me, _, _) => me,\n-        })\n-    }\n-}\n-\n-impl Architecture {\n-    fn bit(&self) -> u32 {\n-        1 << (*self as uint)\n-    }\n }\n \n impl fmt::Show for Abi {\n@@ -184,23 +149,4 @@ fn indices_are_correct() {\n     for (i, abi_data) in AbiDatas.iter().enumerate() {\n         assert_eq!(i, abi_data.abi.index());\n     }\n-\n-    let bits = 1 << (X86 as uint);\n-    let bits = bits | 1 << (X86_64 as uint);\n-    assert_eq!(IntelBits, bits);\n-\n-    let bits = 1 << (Arm as uint);\n-    assert_eq!(ArmBits, bits);\n-}\n-\n-#[test]\n-fn pick_uniplatform() {\n-    assert_eq!(Stdcall.for_target(OsLinux, X86), Some(Stdcall));\n-    assert_eq!(Stdcall.for_target(OsLinux, Arm), None);\n-    assert_eq!(System.for_target(OsLinux, X86), Some(C));\n-    assert_eq!(System.for_target(OsWindows, X86), Some(Stdcall));\n-    assert_eq!(System.for_target(OsWindows, X86_64), Some(C));\n-    assert_eq!(System.for_target(OsWindows, Arm), Some(C));\n-    assert_eq!(Stdcall.for_target(OsWindows, X86), Some(Stdcall));\n-    assert_eq!(Stdcall.for_target(OsWindows, X86_64), Some(Stdcall));\n }"}, {"sha": "bc7e4e5863ee2e8aaaf8791a4d92b39930572fac", "filename": "src/test/run-make/rustdoc-hidden-line/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2FMakefile?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -4,6 +4,7 @@\n ifndef IS_WINDOWS\n \n all:\n+\t@echo $(RUSTDOC)\n \t$(HOST_RPATH_ENV) $(RUSTDOC) --test foo.rs\n \t$(HOST_RPATH_ENV) $(RUSTDOC) -w html -o $(TMPDIR)/doc foo.rs\n \tcp verify.sh $(TMPDIR)"}, {"sha": "746870d201f23de2d7c9676fd5ce0577d7b22845", "filename": "src/test/run-make/target-specs/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,11 @@\n+-include ../tools.mk\n+all:\n+\t$(RUSTC) foo.rs --target=my-awesome-platform.json --crate-type=lib --emit=asm\n+\tgrep --quiet --invert-match morestack < $(TMPDIR)/foo.s\n+\t$(RUSTC) foo.rs --target=my-invalid-platform.json 2>&1 | grep --quiet --invert-match \"Error loading taget specification\"\n+\t$(RUSTC) foo.rs --target=my-incomplete-platform.json 2>&1 | grep 'Field llvm-target'\n+\tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=my-awesome-platform --crate-type=lib --emit=asm\n+\tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=x86_64-unknown-linux-gnu --crate-type=lib --emit=asm\n+\t# The built-in target *should* override the one we have here, and thus we\n+\t# should have morestack\n+\tgrep --quiet morestack < $(TMPDIR)/foo.s"}, {"sha": "eeddd5e19a841b497c245879f89d71787c5a8dca", "filename": "src/test/run-make/target-specs/foo.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(lang_items)]\n+#![no_std]\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+\n+#[lang=\"start\"]\n+fn start(_main: *const u8, _argc: int, _argv: *const *const u8) -> int { 0 }\n+\n+extern {\n+    fn _foo() -> [u8, ..16];\n+}\n+\n+fn _main() {\n+    let _a = unsafe { _foo() };\n+}"}, {"sha": "f5f622bbcdaa69cb697aad58ac154d4465a1eb61", "filename": "src/test/run-make/target-specs/my-awesome-platform.json", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-awesome-platform.json", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-awesome-platform.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-awesome-platform.json?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,9 @@\n+{\n+    \"data-layout\": \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\",\n+    \"llvm-target\": \"i686-unknown-linux-gnu\",\n+    \"target-endian\": \"little\",\n+    \"target-word-size\": \"32\",\n+    \"arch\": \"x86\",\n+    \"os\": \"linux\",\n+    \"morestack\": false\n+}"}, {"sha": "5005a9ff83960cd1485aa17a1ccefb80c00d35c0", "filename": "src/test/run-make/target-specs/my-incomplete-platform.json", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-incomplete-platform.json", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-incomplete-platform.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-incomplete-platform.json?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,8 @@\n+{\n+    \"data-layout\": \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\",\n+    \"target-endian\": \"little\",\n+    \"target-word-size\": \"32\",\n+    \"arch\": \"x86\",\n+    \"os\": \"foo\",\n+    \"morestack\": false\n+}"}, {"sha": "3feac45b7d660a813db9b37d511551019ca5920a", "filename": "src/test/run-make/target-specs/my-invalid-platform.json", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-invalid-platform.json", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-invalid-platform.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-invalid-platform.json?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1 @@\n+wow this json is really broke!"}, {"sha": "f5f622bbcdaa69cb697aad58ac154d4465a1eb61", "filename": "src/test/run-make/target-specs/x86_64-unknown-linux-gnu.json", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2Fx86_64-unknown-linux-gnu.json", "raw_url": "https://github.com/rust-lang/rust/raw/6b130e3dd9547e233dca2cfd72a5968891672d9c/src%2Ftest%2Frun-make%2Ftarget-specs%2Fx86_64-unknown-linux-gnu.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Fx86_64-unknown-linux-gnu.json?ref=6b130e3dd9547e233dca2cfd72a5968891672d9c", "patch": "@@ -0,0 +1,9 @@\n+{\n+    \"data-layout\": \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\",\n+    \"llvm-target\": \"i686-unknown-linux-gnu\",\n+    \"target-endian\": \"little\",\n+    \"target-word-size\": \"32\",\n+    \"arch\": \"x86\",\n+    \"os\": \"linux\",\n+    \"morestack\": false\n+}"}]}