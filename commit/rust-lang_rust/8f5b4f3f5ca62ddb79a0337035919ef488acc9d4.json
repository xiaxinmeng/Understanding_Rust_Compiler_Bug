{"sha": "8f5b4f3f5ca62ddb79a0337035919ef488acc9d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNWI0ZjNmNWNhNjJkZGI3OWEwMzM3MDM1OTE5ZWY0ODhhY2M5ZDQ=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:26:52Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:26:52Z"}, "message": "literal representation restructure 1\n\nCombine macro expansion checks. Indentation is a little strange to\navoid rustfmt issue.", "tree": {"sha": "96efdc75ddeaddce19d038822656e74bab02965f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96efdc75ddeaddce19d038822656e74bab02965f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f5b4f3f5ca62ddb79a0337035919ef488acc9d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5b4f3f5ca62ddb79a0337035919ef488acc9d4", "html_url": "https://github.com/rust-lang/rust/commit/8f5b4f3f5ca62ddb79a0337035919ef488acc9d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f5b4f3f5ca62ddb79a0337035919ef488acc9d4/comments", "author": null, "committer": null, "parents": [{"sha": "180f87065f65ce304a88c3a813f2701f70c41c6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/180f87065f65ce304a88c3a813f2701f70c41c6a", "html_url": "https://github.com/rust-lang/rust/commit/180f87065f65ce304a88c3a813f2701f70c41c6a"}], "stats": {"total": 100, "additions": 48, "deletions": 52}, "files": [{"sha": "8b9783389225e8e58157cb62da146f834789de11", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 48, "deletions": 52, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/8f5b4f3f5ca62ddb79a0337035919ef488acc9d4/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5b4f3f5ca62ddb79a0337035919ef488acc9d4/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=8f5b4f3f5ca62ddb79a0337035919ef488acc9d4", "patch": "@@ -358,67 +358,63 @@ impl EarlyLintPass for LiteralDigitGrouping {\n impl LiteralDigitGrouping {\n     fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n         let in_macro = in_macro(lit.span);\n+\n+        if_chain! {\n+            if let Some(src) = snippet_opt(cx, lit.span);\n+            if let Some(firstch) = src.chars().next();\n+            if char::is_digit(firstch, 10);\n+            then {\n+\n+\n         match lit.kind {\n             LitKind::Int(..) => {\n                 // Lint integral literals.\n-                if_chain! {\n-                    if let Some(src) = snippet_opt(cx, lit.span);\n-                    if let Some(firstch) = src.chars().next();\n-                    if char::is_digit(firstch, 10);\n-                    then {\n-                        let digit_info = DigitInfo::new(&src, false);\n-                        let _ = Self::do_lint(digit_info.digits, digit_info.suffix, in_macro).map_err(|warning_type| {\n-                            warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n-                        });\n-                    }\n-                }\n+                let digit_info = DigitInfo::new(&src, false);\n+                let _ = Self::do_lint(digit_info.digits, digit_info.suffix, in_macro).map_err(|warning_type| {\n+                    warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n+                });\n             },\n             LitKind::Float(..) => {\n                 // Lint floating-point literals.\n-                if_chain! {\n-                    if let Some(src) = snippet_opt(cx, lit.span);\n-                    if let Some(firstch) = src.chars().next();\n-                    if char::is_digit(firstch, 10);\n-                    then {\n-                        let digit_info = DigitInfo::new(&src, true);\n-                        // Separate digits into integral and fractional parts.\n-                        let parts: Vec<&str> = digit_info\n-                            .digits\n-                            .split_terminator('.')\n-                            .collect();\n-\n-                        // Lint integral and fractional parts separately, and then check consistency of digit\n-                        // groups if both pass.\n-                        let _ = Self::do_lint(parts[0], digit_info.suffix, in_macro)\n-                            .map(|integral_group_size| {\n-                                if parts.len() > 1 {\n-                                    // Lint the fractional part of literal just like integral part, but reversed.\n-                                    let fractional_part = &parts[1].chars().rev().collect::<String>();\n-                                    let _ = Self::do_lint(fractional_part, None, in_macro)\n-                                        .map(|fractional_group_size| {\n-                                            let consistent = Self::parts_consistent(integral_group_size,\n-                                                                                    fractional_group_size,\n-                                                                                    parts[0].len(),\n-                                                                                    parts[1].len());\n-                                                if !consistent {\n-                                                    WarningType::InconsistentDigitGrouping.display(\n-                                                        &digit_info.grouping_hint(),\n-                                                        cx,\n-                                                        lit.span,\n-                                                    );\n-                                                }\n-                                        })\n-                                    .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(),\n-                                    cx,\n-                                    lit.span));\n-                                }\n-                            })\n-                        .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, lit.span));\n-                    }\n-                }\n+                let digit_info = DigitInfo::new(&src, true);\n+                // Separate digits into integral and fractional parts.\n+                let parts: Vec<&str> = digit_info\n+                    .digits\n+                    .split_terminator('.')\n+                    .collect();\n+\n+                // Lint integral and fractional parts separately, and then check consistency of digit\n+                // groups if both pass.\n+                let _ = Self::do_lint(parts[0], digit_info.suffix, in_macro)\n+                    .map(|integral_group_size| {\n+                        if parts.len() > 1 {\n+                            // Lint the fractional part of literal just like integral part, but reversed.\n+                            let fractional_part = &parts[1].chars().rev().collect::<String>();\n+                            let _ = Self::do_lint(fractional_part, None, in_macro)\n+                                .map(|fractional_group_size| {\n+                                    let consistent = Self::parts_consistent(integral_group_size,\n+                                                                            fractional_group_size,\n+                                                                            parts[0].len(),\n+                                                                            parts[1].len());\n+                                        if !consistent {\n+                                            WarningType::InconsistentDigitGrouping.display(\n+                                                &digit_info.grouping_hint(),\n+                                                cx,\n+                                                lit.span,\n+                                            );\n+                                        }\n+                                })\n+                            .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(),\n+                            cx,\n+                            lit.span));\n+                        }\n+                    })\n+                .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, lit.span));\n             },\n             _ => (),\n         }\n+            }\n+        }\n     }\n \n     /// Given the sizes of the digit groups of both integral and fractional"}]}