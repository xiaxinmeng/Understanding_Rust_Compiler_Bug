{"sha": "301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMWZmMGMyZGYzZDI2YTViMjg3YWI2MWQ4MGY1Y2E3ODQ1ZTgyN2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-11T00:13:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-14T04:31:17Z"}, "message": "Remove two allocations from spawning a green task\n\nTwo unfortunate allocations were wrapping a proc() in a proc() with\nGreenTask::build_start_wrapper, and then boxing this proc in a ~proc() inside of\nContext::new(). Both of these allocations were a direct result from two\nconditions:\n\n1. The Context::new() function has a nice api of taking a procedure argument to\n   start up a new context with. This inherently required an allocation by\n   build_start_wrapper because extra code needed to be run around the edges of a\n   user-provided proc() for a new task.\n\n2. The initial bootstrap code only understood how to pass one argument to the\n   next function. By modifying the assembly and entry points to understand more\n   than one argument, more information is passed through in registers instead of\n   allocating a pointer-sized context.\n\nThis is sadly where I end up throwing mips under a bus because I have no idea\nwhat's going on in the mips context switching code and don't know how to modify\nit.\n\nCloses #7767\ncc #11389", "tree": {"sha": "a051d9b5683c6a522b4900abfad65356f6d73a50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a051d9b5683c6a522b4900abfad65356f6d73a50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "html_url": "https://github.com/rust-lang/rust/commit/301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21a064d5a340a00042c81745cc7d2a65691e84be", "url": "https://api.github.com/repos/rust-lang/rust/commits/21a064d5a340a00042c81745cc7d2a65691e84be", "html_url": "https://github.com/rust-lang/rust/commit/21a064d5a340a00042c81745cc7d2a65691e84be"}], "stats": {"total": 295, "additions": 175, "deletions": 120}, "files": [{"sha": "80231ad2ba4bca60b487649f6367c1668dd4a36b", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "patch": "@@ -57,7 +57,7 @@ TOOLS := compiletest rustdoc rustc\n \n DEPS_std := native:rustrt native:compiler-rt\n DEPS_extra := std term sync serialize getopts collections\n-DEPS_green := std\n+DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n DEPS_syntax := std extra term serialize collections"}, {"sha": "10b73c6b39533feebf171478d231cd3eefd55f57", "filename": "mk/rt.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "patch": "@@ -35,7 +35,7 @@\n # that's per-target so you're allowed to conditionally add files based on the\n # target.\n ################################################################################\n-NATIVE_LIBS := rustrt sundown uv_support morestack miniz\n+NATIVE_LIBS := rustrt sundown uv_support morestack miniz context_switch\n \n # $(1) is the target triple\n define NATIVE_LIBRARIES\n@@ -54,9 +54,10 @@ NATIVE_DEPS_rustrt_$(1) := rust_builtin.c \\\n \t\t\trust_android_dummy.c \\\n \t\t\trust_test_helpers.c \\\n \t\t\trust_try.ll \\\n-\t\t\tarch/$$(HOST_$(1))/_context.S \\\n \t\t\tarch/$$(HOST_$(1))/record_sp.S\n NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n+NATIVE_DEPS_context_switch_$(1) := \\\n+\t\t\tarch/$$(HOST_$(1))/_context.S\n \n ################################################################################\n # You shouldn't find it that necessary to edit anything below this line."}, {"sha": "58188ede13cb6a8e559a276f9effee05589f54b6", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 60, "deletions": 53, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::libc::c_void;\n use std::uint;\n use std::cast::{transmute, transmute_mut_unsafe,\n                 transmute_region, transmute_mut_region};\n use stack::Stack;\n use std::unstable::stack;\n+use std::unstable::raw;\n \n // FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n@@ -22,47 +22,33 @@ use std::unstable::stack;\n // the registers are sometimes empty, but the discriminant would\n // then misalign the regs again.\n pub struct Context {\n-    /// The context entry point, saved here for later destruction\n-    priv start: Option<~proc()>,\n     /// Hold the registers while the task or scheduler is suspended\n     priv regs: ~Registers,\n     /// Lower bound and upper bound for the stack\n     priv stack_bounds: Option<(uint, uint)>,\n }\n \n+pub type InitFn = extern \"C\" fn(uint, *(), *()) -> !;\n+\n impl Context {\n     pub fn empty() -> Context {\n         Context {\n-            start: None,\n             regs: new_regs(),\n             stack_bounds: None,\n         }\n     }\n \n     /// Create a new context that will resume execution by running proc()\n-    pub fn new(start: proc(), stack: &mut Stack) -> Context {\n-        // The C-ABI function that is the task entry point\n-        //\n-        // Note that this function is a little sketchy. We're taking a\n-        // procedure, transmuting it to a stack-closure, and then calling to\n-        // closure. This leverages the fact that the representation of these two\n-        // types is the same.\n-        //\n-        // The reason that we're doing this is that this procedure is expected\n-        // to never return. The codegen which frees the environment of the\n-        // procedure occurs *after* the procedure has completed, and this means\n-        // that we'll never actually free the procedure.\n-        //\n-        // To solve this, we use this transmute (to not trigger the procedure\n-        // deallocation here), and then store a copy of the procedure in the\n-        // `Context` structure returned. When the `Context` is deallocated, then\n-        // the entire procedure box will be deallocated as well.\n-        extern fn task_start_wrapper(f: &proc()) {\n-            unsafe {\n-                let f: &|| = transmute(f);\n-                (*f)()\n-            }\n-        }\n+    ///\n+    /// The `init` function will be run with `arg` and the `start` procedure\n+    /// split up into code and env pointers. It is required that the `init`\n+    /// function never return.\n+    ///\n+    /// FIXME: this is basically an awful the interface. The main reason for\n+    ///        this is to reduce the number of allocations made when a green\n+    ///        task is spawned as much as possible\n+    pub fn new(init: InitFn, arg: uint, start: proc(),\n+               stack: &mut Stack) -> Context {\n \n         let sp: *uint = stack.end();\n         let sp: *mut uint = unsafe { transmute_mut_unsafe(sp) };\n@@ -74,14 +60,10 @@ impl Context {\n                                 transmute_region(&*regs));\n         };\n \n-        // FIXME #7767: Putting main into a ~ so it's a thin pointer and can\n-        // be passed to the spawn function.  Another unfortunate\n-        // allocation\n-        let start = ~start;\n-\n         initialize_call_frame(&mut *regs,\n-                              task_start_wrapper as *c_void,\n-                              unsafe { transmute(&*start) },\n+                              init,\n+                              arg,\n+                              unsafe { transmute(start) },\n                               sp);\n \n         // Scheduler tasks don't have a stack in the \"we allocated it\" sense,\n@@ -96,7 +78,6 @@ impl Context {\n             Some((stack_base as uint, sp as uint))\n         };\n         return Context {\n-            start: Some(start),\n             regs: regs,\n             stack_bounds: bounds,\n         }\n@@ -138,7 +119,7 @@ impl Context {\n     }\n }\n \n-#[link(name = \"rustrt\", kind = \"static\")]\n+#[link(name = \"context_switch\", kind = \"static\")]\n extern {\n     fn rust_swap_registers(out_regs: *mut Registers, in_regs: *Registers);\n }\n@@ -185,13 +166,17 @@ fn new_regs() -> ~Registers {\n }\n \n #[cfg(target_arch = \"x86\")]\n-fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n+                         procedure: raw::Procedure, sp: *mut uint) {\n \n+    // x86 has interesting stack alignment requirements, so do some alignment\n+    // plus some offsetting to figure out what the actual stack should be.\n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -4);\n \n-    unsafe { *sp = arg as uint };\n+    unsafe { *mut_offset(sp, 2) = procedure.env as uint };\n+    unsafe { *mut_offset(sp, 1) = procedure.code as uint };\n+    unsafe { *mut_offset(sp, 0) = arg as uint };\n     let sp = mut_offset(sp, -1);\n     unsafe { *sp = 0 }; // The final return address\n \n@@ -215,14 +200,18 @@ fn new_regs() -> ~Registers { ~([0, .. 34]) }\n fn new_regs() -> ~Registers { ~([0, .. 22]) }\n \n #[cfg(target_arch = \"x86_64\")]\n-fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n+                         procedure: raw::Procedure, sp: *mut uint) {\n+    extern { fn rust_bootstrap_green_task(); }\n \n     // Redefinitions from rt/arch/x86_64/regs.h\n-    static RUSTRT_ARG0: uint = 3;\n     static RUSTRT_RSP: uint = 1;\n     static RUSTRT_IP: uint = 8;\n     static RUSTRT_RBP: uint = 2;\n+    static RUSTRT_R12: uint = 4;\n+    static RUSTRT_R13: uint = 5;\n+    static RUSTRT_R14: uint = 6;\n+    static RUSTRT_R15: uint = 7;\n \n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -1);\n@@ -231,13 +220,23 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n     unsafe { *sp = 0; }\n \n     rtdebug!(\"creating call frame\");\n-    rtdebug!(\"fptr {}\", fptr);\n-    rtdebug!(\"arg {}\", arg);\n+    rtdebug!(\"fptr {:#x}\", fptr as uint);\n+    rtdebug!(\"arg {:#x}\", arg);\n     rtdebug!(\"sp {}\", sp);\n \n-    regs[RUSTRT_ARG0] = arg as uint;\n+    // These registers are frobbed by rust_bootstrap_green_task into the right\n+    // location so we can invoke the \"real init function\", `fptr`.\n+    regs[RUSTRT_R12] = arg as uint;\n+    regs[RUSTRT_R13] = procedure.code as uint;\n+    regs[RUSTRT_R14] = procedure.env as uint;\n+    regs[RUSTRT_R15] = fptr as uint;\n+\n+    // These registers are picked up by the regulard context switch paths. These\n+    // will put us in \"mostly the right context\" except for frobbing all the\n+    // arguments to the right place. We have the small trampoline code inside of\n+    // rust_bootstrap_green_task to do that.\n     regs[RUSTRT_RSP] = sp as uint;\n-    regs[RUSTRT_IP] = fptr as uint;\n+    regs[RUSTRT_IP] = rust_bootstrap_green_task as uint;\n \n     // Last base pointer on the stack should be 0\n     regs[RUSTRT_RBP] = 0;\n@@ -250,18 +249,26 @@ type Registers = [uint, ..32];\n fn new_regs() -> ~Registers { ~([0, .. 32]) }\n \n #[cfg(target_arch = \"arm\")]\n-fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n+                         procedure: raw::Procedure, sp: *mut uint) {\n+    extern { fn rust_bootstrap_green_task(); }\n+\n     let sp = align_down(sp);\n     // sp of arm eabi is 8-byte aligned\n     let sp = mut_offset(sp, -2);\n \n     // The final return address. 0 indicates the bottom of the stack\n     unsafe { *sp = 0; }\n \n-    regs[0] = arg as uint;   // r0\n-    regs[13] = sp as uint;   // #53 sp, r13\n-    regs[14] = fptr as uint; // #60 pc, r15 --> lr\n+    // ARM uses the same technique as x86_64 to have a landing pad for the start\n+    // of all new green tasks. Neither r1/r2 are saved on a context switch, so\n+    // the shim will copy r3/r4 into r1/r2 and then execute the function in r5\n+    regs[0] = arg as uint;              // r0\n+    regs[3] = procedure.code as uint;   // r3\n+    regs[4] = procedure.env as uint;    // r4\n+    regs[5] = fptr as uint;             // r5\n+    regs[13] = sp as uint;                          // #52 sp, r13\n+    regs[14] = rust_bootstrap_green_task as uint;   // #56 pc, r14 --> lr\n }\n \n #[cfg(target_arch = \"mips\")]\n@@ -271,8 +278,8 @@ type Registers = [uint, ..32];\n fn new_regs() -> ~Registers { ~([0, .. 32]) }\n \n #[cfg(target_arch = \"mips\")]\n-fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n+                         procedure: raw::Procedure, sp: *mut uint) {\n     let sp = align_down(sp);\n     // sp of mips o32 is 8-byte aligned\n     let sp = mut_offset(sp, -2);"}, {"sha": "b20892886c6dacd450d4f08256f9f37cf390e146", "filename": "src/libgreen/coroutine.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Flibgreen%2Fcoroutine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Flibgreen%2Fcoroutine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcoroutine.rs?ref=301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "patch": "@@ -11,8 +11,6 @@\n // Coroutines represent nothing more than a context and a stack\n // segment.\n \n-use std::rt::env;\n-\n use context::Context;\n use stack::{StackPool, Stack};\n \n@@ -31,22 +29,6 @@ pub struct Coroutine {\n }\n \n impl Coroutine {\n-    pub fn new(stack_pool: &mut StackPool,\n-               stack_size: Option<uint>,\n-               start: proc())\n-               -> Coroutine {\n-        let stack_size = match stack_size {\n-            Some(size) => size,\n-            None => env::min_stack()\n-        };\n-        let mut stack = stack_pool.take_stack(stack_size);\n-        let initial_context = Context::new(start, &mut stack);\n-        Coroutine {\n-            current_stack_segment: stack,\n-            saved_context: initial_context\n-        }\n-    }\n-\n     pub fn empty() -> Coroutine {\n         Coroutine {\n             current_stack_segment: unsafe { Stack::dummy_stack() },"}, {"sha": "b224b0cabf365414df028e817d3686fac4094198", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "patch": "@@ -756,7 +756,7 @@ impl Scheduler {\n \n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n-    pub fn terminate_current_task(mut ~self, cur: ~GreenTask) {\n+    pub fn terminate_current_task(mut ~self, cur: ~GreenTask) -> ! {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n         let stask = self.sched_task.take_unwrap();"}, {"sha": "2aca72e35f19dd22ec45e2a651a7d09bf137b20f", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 63, "deletions": 45, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "patch": "@@ -19,13 +19,16 @@\n //! values.\n \n use std::cast;\n+use std::rt::env;\n use std::rt::Runtime;\n-use std::rt::rtio;\n use std::rt::local::Local;\n+use std::rt::rtio;\n use std::rt::task::{Task, BlockedTask, SendMessage};\n use std::task::TaskOpts;\n use std::unstable::mutex::Mutex;\n+use std::unstable::raw;\n \n+use context::Context;\n use coroutine::Coroutine;\n use sched::{Scheduler, SchedHandle, RunOnce};\n use stack::StackPool;\n@@ -75,6 +78,50 @@ pub enum Home {\n     HomeSched(SchedHandle),\n }\n \n+/// Trampoline code for all new green tasks which are running around. This\n+/// function is passed through to Context::new as the initial rust landing pad\n+/// for all green tasks. This code is actually called after the initial context\n+/// switch onto a green thread.\n+///\n+/// The first argument to this function is the `~GreenTask` pointer, and the\n+/// next two arguments are the user-provided procedure for running code.\n+///\n+/// The goal for having this weird-looking function is to reduce the number of\n+/// allocations done on a green-task startup as much as possible.\n+extern fn bootstrap_green_task(task: uint, code: *(), env: *()) -> ! {\n+    // Acquire ownership of the `proc()`\n+    let start: proc() = unsafe {\n+        cast::transmute(raw::Procedure { code: code, env: env })\n+    };\n+\n+    // Acquire ownership of the `~GreenTask`\n+    let mut task: ~GreenTask = unsafe { cast::transmute(task) };\n+\n+    // First code after swap to this new context. Run our cleanup job\n+    task.pool_id = {\n+        let sched = task.sched.get_mut_ref();\n+        sched.run_cleanup_job();\n+        sched.task_state.increment();\n+        sched.pool_id\n+    };\n+\n+    // Convert our green task to a libstd task and then execute the code\n+    // requested. This is the \"try/catch\" block for this green task and\n+    // is the wrapper for *all* code run in the task.\n+    let mut start = Some(start);\n+    let task = task.swap().run(|| start.take_unwrap()());\n+\n+    // Once the function has exited, it's time to run the termination\n+    // routine. This means we need to context switch one more time but\n+    // clean ourselves up on the other end. Since we have no way of\n+    // preserving a handle to the GreenTask down to this point, this\n+    // unfortunately must call `GreenTask::convert`. In order to avoid\n+    // this we could add a `terminate` function to the `Runtime` trait\n+    // in libstd, but that seems less appropriate since the coversion\n+    // method exists.\n+    GreenTask::convert(task).terminate()\n+}\n+\n impl GreenTask {\n     /// Creates a new green task which is not homed to any particular scheduler\n     /// and will not have any contained Task structure.\n@@ -89,9 +136,20 @@ impl GreenTask {\n                      stack_size: Option<uint>,\n                      home: Home,\n                      start: proc()) -> ~GreenTask {\n+        // Allocate ourselves a GreenTask structure\n         let mut ops = GreenTask::new_typed(None, TypeGreen(Some(home)));\n-        let start = GreenTask::build_start_wrapper(start, ops.as_uint());\n-        ops.coroutine = Some(Coroutine::new(stack_pool, stack_size, start));\n+\n+        // Allocate a stack for us to run on\n+        let stack_size = stack_size.unwrap_or_else(|| env::min_stack());\n+        let mut stack = stack_pool.take_stack(stack_size);\n+        let context = Context::new(bootstrap_green_task, ops.as_uint(), start,\n+                                   &mut stack);\n+\n+        // Package everything up in a coroutine and return\n+        ops.coroutine = Some(Coroutine {\n+            current_stack_segment: stack,\n+            saved_context: context,\n+        });\n         return ops;\n     }\n \n@@ -156,46 +214,6 @@ impl GreenTask {\n         }\n     }\n \n-    /// Builds a function which is the actual starting execution point for a\n-    /// rust task. This function is the glue necessary to execute the libstd\n-    /// task and then clean up the green thread after it exits.\n-    ///\n-    /// The second argument to this function is actually a transmuted copy of\n-    /// the `GreenTask` pointer. Context switches in the scheduler silently\n-    /// transfer ownership of the `GreenTask` to the other end of the context\n-    /// switch, so because this is the first code that is running in this task,\n-    /// it must first re-acquire ownership of the green task.\n-    pub fn build_start_wrapper(start: proc(), ops: uint) -> proc() {\n-        proc() {\n-            // First code after swap to this new context. Run our\n-            // cleanup job after we have re-acquired ownership of the green\n-            // task.\n-            let mut task: ~GreenTask = unsafe { GreenTask::from_uint(ops) };\n-            task.pool_id = {\n-                let sched = task.sched.get_mut_ref();\n-                sched.run_cleanup_job();\n-                sched.task_state.increment();\n-                sched.pool_id\n-            };\n-\n-            // Convert our green task to a libstd task and then execute the code\n-            // requested. This is the \"try/catch\" block for this green task and\n-            // is the wrapper for *all* code run in the task.\n-            let mut start = Some(start);\n-            let task = task.swap().run(|| start.take_unwrap()());\n-\n-            // Once the function has exited, it's time to run the termination\n-            // routine. This means we need to context switch one more time but\n-            // clean ourselves up on the other end. Since we have no way of\n-            // preserving a handle to the GreenTask down to this point, this\n-            // unfortunately must call `GreenTask::convert`. In order to avoid\n-            // this we could add a `terminate` function to the `Runtime` trait\n-            // in libstd, but that seems less appropriate since the coversion\n-            // method exists.\n-            GreenTask::convert(task).terminate();\n-        }\n-    }\n-\n     pub fn give_home(&mut self, new_home: Home) {\n         match self.task_type {\n             TypeGreen(ref mut home) => { *home = Some(new_home); }\n@@ -278,9 +296,9 @@ impl GreenTask {\n         Local::put(self.swap());\n     }\n \n-    fn terminate(mut ~self) {\n+    fn terminate(mut ~self) -> ! {\n         let sched = self.sched.take_unwrap();\n-        sched.terminate_current_task(self);\n+        sched.terminate_current_task(self)\n     }\n \n     // This function is used to remotely wakeup this green task back on to its"}, {"sha": "c25422d24e91164fe9ab24a9944c3d208f67c0de", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "patch": "@@ -41,6 +41,12 @@ pub struct Closure {\n     env: *(),\n }\n \n+/// The representation of a Rust procedure (`proc()`)\n+pub struct Procedure {\n+    code: *(),\n+    env: *(),\n+}\n+\n /// This trait is meant to map equivalences between raw structs and their\n /// corresponding rust values.\n pub trait Repr<T> {"}, {"sha": "fb6db57414a564ac7894835a6100674dd7617e78", "filename": "src/rt/arch/arm/_context.S", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Frt%2Farch%2Farm%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Frt%2Farch%2Farm%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2F_context.S?ref=301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "patch": "@@ -51,3 +51,11 @@ rust_swap_registers:\n \tmsr cpsr_cxsf, r2\n \n \tmov pc, lr\n+\n+// For reasons of this existence, see the comments in x86_64/_context.S\n+.globl rust_bootstrap_green_task\n+rust_bootstrap_green_task:\n+        mov r0, r0\n+        mov r1, r3\n+        mov r2, r4\n+        mov pc, r5"}, {"sha": "36caf7720c40c5ece1a138bd524c86884fb0364b", "filename": "src/rt/arch/x86_64/_context.S", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Frt%2Farch%2Fx86_64%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/301ff0c2df3d26a5b287ab61d80f5ca7845e827b/src%2Frt%2Farch%2Fx86_64%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2F_context.S?ref=301ff0c2df3d26a5b287ab61d80f5ca7845e827b", "patch": "@@ -157,3 +157,36 @@ SWAP_REGISTERS:\n         // Jump to the instruction pointer\n         // found in regs:\n         jmp *(RUSTRT_IP*8)(ARG1)\n+\n+// This function below, rust_bootstrap_green_task, is used to initialize a green\n+// task. This code is the very first code that is run whenever a green task\n+// starts. The only assumptions that this code makes is that it has a register\n+// context previously set up by Context::new() and some values are in some\n+// special registers.\n+//\n+// In theory the register context could be set up and then the context switching\n+// would plop us directly into some 'extern \"C\" fn', but not all platforms have\n+// the argument registers saved throughout a context switch (linux doesn't save\n+// rdi/rsi, the first two argument registers). Instead of modifying all context\n+// switches, instead the initial data for starting a green thread is shoved into\n+// unrelated registers (r12/13, etc) which always need to be saved on context\n+// switches anyway.\n+//\n+// With this strategy we get the benefit of being able to pass a fair bit of\n+// contextual data from the start of a green task to its init function, as well\n+// as not hindering any context switches.\n+//\n+// If you alter this code in any way, you likely need to update\n+// src/libgreen/context.rs as well.\n+\n+#if defined(__APPLE__)\n+#define BOOTSTRAP _rust_bootstrap_green_task\n+#else\n+#define BOOTSTRAP rust_bootstrap_green_task\n+#endif\n+.globl BOOTSTRAP\n+BOOTSTRAP:\n+    mov %r12, RUSTRT_ARG0_S\n+    mov %r13, RUSTRT_ARG1_S\n+    mov %r14, RUSTRT_ARG2_S\n+    jmpq *%r15"}]}