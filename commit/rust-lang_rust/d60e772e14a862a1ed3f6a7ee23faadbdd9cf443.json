{"sha": "d60e772e14a862a1ed3f6a7ee23faadbdd9cf443", "node_id": "C_kwDOAAsO6NoAKGQ2MGU3NzJlMTRhODYyYTFlZDNmNmE3ZWUyM2ZhYWRiZGQ5Y2Y0NDM", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-09T15:21:08Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-17T07:48:19Z"}, "message": "`rustc_hir_analysis`: some general code improvements", "tree": {"sha": "7858fef1cf1394aaae6c4503213b336be5e7222d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7858fef1cf1394aaae6c4503213b336be5e7222d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443", "html_url": "https://github.com/rust-lang/rust/commit/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "360e9784375e9487172448d4700a1b038d845c99", "url": "https://api.github.com/repos/rust-lang/rust/commits/360e9784375e9487172448d4700a1b038d845c99", "html_url": "https://github.com/rust-lang/rust/commit/360e9784375e9487172448d4700a1b038d845c99"}], "stats": {"total": 206, "additions": 92, "deletions": 114}, "files": [{"sha": "6b47f4f019d35a271a5a4b521c13dac8dad198a5", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 74, "deletions": 88, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=d60e772e14a862a1ed3f6a7ee23faadbdd9cf443", "patch": "@@ -916,16 +916,14 @@ fn report_trait_method_mismatch<'tcx>(\n             // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n             // span points only at the type `Box<Self`>, but we want to cover the whole\n             // argument pattern and type.\n-            let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                ImplItemKind::Fn(ref sig, body) => tcx\n-                    .hir()\n-                    .body_param_names(body)\n-                    .zip(sig.decl.inputs.iter())\n-                    .map(|(param, ty)| param.span.to(ty.span))\n-                    .next()\n-                    .unwrap_or(impl_err_span),\n-                _ => bug!(\"{:?} is not a method\", impl_m),\n-            };\n+            let ImplItemKind::Fn(ref sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{impl_m:?} is not a method\") };\n+            let span = tcx\n+                .hir()\n+                .body_param_names(body)\n+                .zip(sig.decl.inputs.iter())\n+                .map(|(param, ty)| param.span.to(ty.span))\n+                .next()\n+                .unwrap_or(impl_err_span);\n \n             diag.span_suggestion(\n                 span,\n@@ -938,22 +936,21 @@ fn report_trait_method_mismatch<'tcx>(\n             if trait_sig.inputs().len() == *i {\n                 // Suggestion to change output type. We do not suggest in `async` functions\n                 // to avoid complex logic or incorrect output.\n-                match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                    ImplItemKind::Fn(ref sig, _) if !sig.header.asyncness.is_async() => {\n-                        let msg = \"change the output type to match the trait\";\n-                        let ap = Applicability::MachineApplicable;\n-                        match sig.decl.output {\n-                            hir::FnRetTy::DefaultReturn(sp) => {\n-                                let sugg = format!(\"-> {} \", trait_sig.output());\n-                                diag.span_suggestion_verbose(sp, msg, sugg, ap);\n-                            }\n-                            hir::FnRetTy::Return(hir_ty) => {\n-                                let sugg = trait_sig.output();\n-                                diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n-                            }\n-                        };\n-                    }\n-                    _ => {}\n+                if let ImplItemKind::Fn(sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind\n+                    && !sig.header.asyncness.is_async()\n+                {\n+                    let msg = \"change the output type to match the trait\";\n+                    let ap = Applicability::MachineApplicable;\n+                    match sig.decl.output {\n+                        hir::FnRetTy::DefaultReturn(sp) => {\n+                            let sugg = format!(\"-> {} \", trait_sig.output());\n+                            diag.span_suggestion_verbose(sp, msg, sugg, ap);\n+                        }\n+                        hir::FnRetTy::Return(hir_ty) => {\n+                            let sugg = trait_sig.output();\n+                            diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n+                        }\n+                    };\n                 };\n             } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n                 diag.span_suggestion(\n@@ -1080,25 +1077,18 @@ fn extract_spans_for_error_reporting<'tcx>(\n     trait_m: &ty::AssocItem,\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n-    let mut impl_args = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-        ImplItemKind::Fn(ref sig, _) => {\n-            sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n-        }\n-        _ => bug!(\"{:?} is not a method\", impl_m),\n+    let mut impl_args = {\n+        let ImplItemKind::Fn(sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     };\n-    let trait_args =\n-        trait_m.def_id.as_local().map(|def_id| match tcx.hir().expect_trait_item(def_id).kind {\n-            TraitItemKind::Fn(ref sig, _) => {\n-                sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n-            }\n-            _ => bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m),\n-        });\n+\n+    let trait_args = trait_m.def_id.as_local().map(|def_id| {\n+        let TraitItemKind::Fn(sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m) };\n+        sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n+    });\n \n     match terr {\n-        TypeError::ArgumentMutability(i) => {\n-            (impl_args.nth(i).unwrap(), trait_args.and_then(|mut args| args.nth(i)))\n-        }\n-        TypeError::ArgumentSorts(ExpectedFound { .. }, i) => {\n+        TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(ExpectedFound { .. }, i) => {\n             (impl_args.nth(i).unwrap(), trait_args.and_then(|mut args| args.nth(i)))\n         }\n         _ => (cause.span(), tcx.hir().span_if_local(trait_m.def_id)),\n@@ -1158,8 +1148,7 @@ fn compare_self_type<'tcx>(\n             } else {\n                 err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n             }\n-            let reported = err.emit();\n-            return Err(reported);\n+            return Err(err.emit());\n         }\n \n         (true, false) => {\n@@ -1178,8 +1167,8 @@ fn compare_self_type<'tcx>(\n             } else {\n                 err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n             }\n-            let reported = err.emit();\n-            return Err(reported);\n+\n+            return Err(err.emit());\n         }\n     }\n \n@@ -1361,41 +1350,41 @@ fn compare_number_of_method_arguments<'tcx>(\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n+\n     if trait_number_args != impl_number_args {\n-        let trait_span = if let Some(def_id) = trait_m.def_id.as_local() {\n-            match tcx.hir().expect_trait_item(def_id).kind {\n-                TraitItemKind::Fn(ref trait_m_sig, _) => {\n-                    let pos = if trait_number_args > 0 { trait_number_args - 1 } else { 0 };\n-                    if let Some(arg) = trait_m_sig.decl.inputs.get(pos) {\n-                        Some(if pos == 0 {\n-                            arg.span\n-                        } else {\n-                            arg.span.with_lo(trait_m_sig.decl.inputs[0].span.lo())\n-                        })\n+        let trait_span = trait_m\n+            .def_id\n+            .as_local()\n+            .and_then(|def_id| {\n+                let TraitItemKind::Fn(trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+                let pos = trait_number_args.saturating_sub(1);\n+                trait_m_sig.decl.inputs.get(pos).map(|arg| {\n+                    if pos == 0 {\n+                        arg.span\n                     } else {\n-                        trait_item_span\n+                        arg.span.with_lo(trait_m_sig.decl.inputs[0].span.lo())\n                     }\n-                }\n-                _ => bug!(\"{:?} is not a method\", impl_m),\n-            }\n-        } else {\n-            trait_item_span\n-        };\n-        let impl_span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-            ImplItemKind::Fn(ref impl_m_sig, _) => {\n-                let pos = if impl_number_args > 0 { impl_number_args - 1 } else { 0 };\n-                if let Some(arg) = impl_m_sig.decl.inputs.get(pos) {\n+                })\n+            })\n+            .or(trait_item_span);\n+\n+        let impl_span = {\n+            let ImplItemKind::Fn(impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+            let pos = impl_number_args.saturating_sub(1);\n+            impl_m_sig\n+                .decl\n+                .inputs\n+                .get(pos)\n+                .map(|arg| {\n                     if pos == 0 {\n                         arg.span\n                     } else {\n                         arg.span.with_lo(impl_m_sig.decl.inputs[0].span.lo())\n                     }\n-                } else {\n-                    impl_m_span\n-                }\n-            }\n-            _ => bug!(\"{:?} is not a method\", impl_m),\n+                })\n+                .unwrap_or(impl_m_span)\n         };\n+\n         let mut err = struct_span_err!(\n             tcx.sess,\n             impl_span,\n@@ -1406,6 +1395,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             tcx.def_path_str(trait_m.def_id),\n             trait_number_args\n         );\n+\n         if let Some(trait_span) = trait_span {\n             err.span_label(\n                 trait_span,\n@@ -1417,6 +1407,7 @@ fn compare_number_of_method_arguments<'tcx>(\n         } else {\n             err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n         }\n+\n         err.span_label(\n             impl_span,\n             format!(\n@@ -1425,8 +1416,8 @@ fn compare_number_of_method_arguments<'tcx>(\n                 impl_number_args\n             ),\n         );\n-        let reported = err.emit();\n-        return Err(reported);\n+\n+        return Err(err.emit());\n     }\n \n     Ok(())\n@@ -1515,10 +1506,9 @@ fn compare_synthetic_generics<'tcx>(\n                     let _: Option<_> = try {\n                         let impl_m = impl_m.def_id.as_local()?;\n                         let impl_m = tcx.hir().expect_impl_item(impl_m);\n-                        let input_tys = match impl_m.kind {\n-                            hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n-                            _ => unreachable!(),\n-                        };\n+                        let hir::ImplItemKind::Fn(sig, _) = &impl_m.kind else { unreachable!() };\n+                        let input_tys = sig.decl.inputs;\n+\n                         struct Visitor(Option<Span>, hir::def_id::LocalDefId);\n                         impl<'v> intravisit::Visitor<'v> for Visitor {\n                             fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n@@ -1532,6 +1522,7 @@ fn compare_synthetic_generics<'tcx>(\n                                 }\n                             }\n                         }\n+\n                         let mut visitor = Visitor(None, impl_def_id);\n                         for ty in input_tys {\n                             intravisit::Visitor::visit_ty(&mut visitor, ty);\n@@ -1556,8 +1547,7 @@ fn compare_synthetic_generics<'tcx>(\n                 }\n                 _ => unreachable!(),\n             }\n-            let reported = err.emit();\n-            error_found = Some(reported);\n+            error_found = Some(err.emit());\n         }\n     }\n     if let Some(reported) = error_found { Err(reported) } else { Ok(()) }\n@@ -1717,10 +1707,8 @@ pub(super) fn compare_impl_const_raw(\n         );\n \n         // Locate the Span containing just the type of the offending impl\n-        match tcx.hir().expect_impl_item(impl_const_item_def).kind {\n-            ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n-            _ => bug!(\"{:?} is not a impl const\", impl_const_item),\n-        }\n+        let ImplItemKind::Const(ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).kind else { bug!(\"{impl_const_item:?} is not a impl const\") };\n+        cause.span = ty.span;\n \n         let mut diag = struct_span_err!(\n             tcx.sess,\n@@ -1732,10 +1720,8 @@ pub(super) fn compare_impl_const_raw(\n \n         let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n             // Add a label to the Span containing just the type of the const\n-            match tcx.hir().expect_trait_item(trait_c_def_id).kind {\n-                TraitItemKind::Const(ref ty, _) => ty.span,\n-                _ => bug!(\"{:?} is not a trait const\", trait_const_item),\n-            }\n+            let TraitItemKind::Const(ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).kind else { bug!(\"{trait_const_item:?} is not a trait const\") };\n+            ty.span\n         });\n \n         infcx.err_ctxt().note_type_err("}, {"sha": "3e6dafd2c6f3a325e9d435718bcd392f9591c45f", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=d60e772e14a862a1ed3f6a7ee23faadbdd9cf443", "patch": "@@ -54,12 +54,9 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => {}\n     }\n \n-    let sp = match tcx.hir().expect_item(impl_did).kind {\n-        ItemKind::Impl(ref impl_) => impl_.self_ty.span,\n-        _ => bug!(\"expected Drop impl item\"),\n-    };\n+    let ItemKind::Impl(impl_) = tcx.hir().expect_item(impl_did).kind else { bug!(\"expected Drop impl item\") };\n \n-    tcx.sess.emit_err(DropImplOnWrongItem { span: sp });\n+    tcx.sess.emit_err(DropImplOnWrongItem { span: impl_.self_ty.span });\n }\n \n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {"}, {"sha": "093a84160fe3933f1f2201ae7511cb8413b98076", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=d60e772e14a862a1ed3f6a7ee23faadbdd9cf443", "patch": "@@ -1342,21 +1342,19 @@ fn suggest_impl_trait<'tcx>(\n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n     let item = tcx.hir().expect_item(def_id.expect_local());\n-    match item.kind {\n-        hir::ItemKind::Impl(ref impl_) => impl_\n-            .of_trait\n-            .as_ref()\n-            .map(|ast_trait_ref| {\n-                let selfty = tcx.type_of(def_id);\n-                icx.astconv().instantiate_mono_trait_ref(\n-                    ast_trait_ref,\n-                    selfty,\n-                    check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n-                )\n-            })\n-            .map(ty::EarlyBinder),\n-        _ => bug!(),\n-    }\n+    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    impl_\n+        .of_trait\n+        .as_ref()\n+        .map(|ast_trait_ref| {\n+            let selfty = tcx.type_of(def_id);\n+            icx.astconv().instantiate_mono_trait_ref(\n+                ast_trait_ref,\n+                selfty,\n+                check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n+            )\n+        })\n+        .map(ty::EarlyBinder)\n }\n \n fn check_impl_constness("}, {"sha": "97fff85f424c3a9d3175039e61d0197dc578292f", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60e772e14a862a1ed3f6a7ee23faadbdd9cf443/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=d60e772e14a862a1ed3f6a7ee23faadbdd9cf443", "patch": "@@ -114,6 +114,7 @@ use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use std::iter;\n+use std::ops::Not;\n \n use astconv::AstConv;\n use bounds::Bounds;\n@@ -203,12 +204,8 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n-            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, ref generics, _), .. })) => {\n-                if !generics.params.is_empty() {\n-                    Some(generics.span)\n-                } else {\n-                    None\n-                }\n+            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. })) => {\n+                generics.params.is_empty().not().then(|| generics.span)\n             }\n             _ => {\n                 span_bug!(tcx.def_span(def_id), \"main has a non-function type\");"}]}