{"sha": "4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZTFkYWZkMWQ1ODg1MmE4OGYzOGEwZjYzY2IxMTIzNmE3NDcwY2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-23T08:55:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-23T08:55:38Z"}, "message": "Auto merge of #30377 - Wafflespeanut:levenshtein, r=Manishearth\n\nfixes part of #30197", "tree": {"sha": "598e8d4c2d1c5598bd775da8b9e31cfc29d924fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/598e8d4c2d1c5598bd775da8b9e31cfc29d924fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "html_url": "https://github.com/rust-lang/rust/commit/4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38201501dfe193bfa14d792f590effd462a78717", "url": "https://api.github.com/repos/rust-lang/rust/commits/38201501dfe193bfa14d792f590effd462a78717", "html_url": "https://github.com/rust-lang/rust/commit/38201501dfe193bfa14d792f590effd462a78717"}, {"sha": "51ff17194828cfd2715eea2c7c19d38f7b889007", "url": "https://api.github.com/repos/rust-lang/rust/commits/51ff17194828cfd2715eea2c7c19d38f7b889007", "html_url": "https://github.com/rust-lang/rust/commit/51ff17194828cfd2715eea2c7c19d38f7b889007"}], "stats": {"total": 188, "additions": 94, "deletions": 94}, "files": [{"sha": "3647fd5ce190abca72bf3c9ab7f20dab7e359cda", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "patch": "@@ -30,7 +30,6 @@ extern crate syntax;\n #[no_link]\n extern crate rustc_bitflags;\n extern crate rustc_front;\n-\n extern crate rustc;\n \n use self::PatternBindingMode::*;\n@@ -66,7 +65,7 @@ use syntax::ast::{TyUs, TyU8, TyU16, TyU32, TyU64, TyF64, TyF32};\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::{self, special_names, special_idents};\n use syntax::codemap::{self, Span, Pos};\n-use syntax::util::lev_distance::{lev_distance, max_suggestion_distance};\n+use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc_front::intravisit::{self, FnKind, Visitor};\n use rustc_front::hir;\n@@ -91,7 +90,6 @@ use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n use std::rc::{Rc, Weak};\n-use std::usize;\n \n use resolve_imports::{Target, ImportDirective, ImportResolutionPerNamespace};\n use resolve_imports::Shadowable;\n@@ -118,7 +116,7 @@ macro_rules! execute_callback {\n \n enum SuggestionType {\n     Macro(String),\n-    Function(String),\n+    Function(token::InternedString),\n     NotFound,\n }\n \n@@ -3422,39 +3420,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         NoSuggestion\n     }\n \n-    fn find_best_match_for_name(&mut self, name: &str) -> SuggestionType {\n-        let mut maybes: Vec<token::InternedString> = Vec::new();\n-        let mut values: Vec<usize> = Vec::new();\n-\n+    fn find_best_match(&mut self, name: &str) -> SuggestionType {\n         if let Some(macro_name) = self.session.available_macros\n-                                 .borrow().iter().find(|n| n.as_str() == name) {\n+                                  .borrow().iter().find(|n| n.as_str() == name) {\n             return SuggestionType::Macro(format!(\"{}!\", macro_name));\n         }\n \n-        for rib in self.value_ribs.iter().rev() {\n-            for (&k, _) in &rib.bindings {\n-                maybes.push(k.as_str());\n-                values.push(usize::MAX);\n-            }\n-        }\n-\n-        let mut smallest = 0;\n-        for (i, other) in maybes.iter().enumerate() {\n-            values[i] = lev_distance(name, &other);\n+        let names = self.value_ribs\n+                    .iter()\n+                    .rev()\n+                    .flat_map(|rib| rib.bindings.keys());\n \n-            if values[i] <= values[smallest] {\n-                smallest = i;\n+        if let Some(found) = find_best_match_for_name(names, name, None) {\n+            if name != &*found {\n+                return SuggestionType::Function(found);\n             }\n-        }\n-\n-        let max_distance = max_suggestion_distance(name);\n-        if !values.is_empty() && values[smallest] <= max_distance && name != &maybes[smallest][..] {\n-\n-            SuggestionType::Function(maybes[smallest].to_string())\n-\n-        } else {\n-            SuggestionType::NotFound\n-        }\n+        } SuggestionType::NotFound\n     }\n \n     fn resolve_expr(&mut self, expr: &Expr) {\n@@ -3568,7 +3549,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     NoSuggestion => {\n                                         // limit search to 5 to reduce the number\n                                         // of stupid suggestions\n-                                        match self.find_best_match_for_name(&path_name) {\n+                                        match self.find_best_match(&path_name) {\n                                             SuggestionType::Macro(s) => {\n                                                 format!(\"the macro `{}`\", s)\n                                             }"}, {"sha": "8b35f4d68df3bffb478353a3ebbcfcc5a071dce0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "patch": "@@ -33,11 +33,11 @@ use rustc::middle::privacy::*;\n use syntax::ast::{NodeId, Name};\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n+use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::mem::replace;\n use std::rc::Rc;\n \n-\n /// Contains data for specific types of import directives.\n #[derive(Copy, Clone,Debug)]\n pub enum ImportDirectiveSubclass {\n@@ -425,17 +425,22 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n-        //\n \n         let mut value_result = UnknownResult;\n         let mut type_result = UnknownResult;\n+        let mut lev_suggestion = \"\".to_owned();\n \n         // Search for direct children of the containing module.\n         build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n \n         match target_module.children.borrow().get(&source) {\n             None => {\n-                // Continue.\n+                let names = target_module.children.borrow();\n+                if let Some(name) = find_best_match_for_name(names.keys(),\n+                                                             &source.as_str(),\n+                                                             None) {\n+                    lev_suggestion = format!(\". Did you mean to use `{}`?\", name);\n+                }\n             }\n             Some(ref child_name_bindings) => {\n                 // pub_err makes sure we don't give the same error twice.\n@@ -516,6 +521,17 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         // therefore accurately report that the names are\n                         // unbound.\n \n+                        if lev_suggestion.is_empty() {  // skip if we already have a suggestion\n+                            let names = target_module.import_resolutions.borrow();\n+                            if let Some(name) = find_best_match_for_name(names.keys(),\n+                                                                         &source.as_str(),\n+                                                                         None) {\n+                                lev_suggestion =\n+                                    format!(\". Did you mean to use the re-exported import `{}`?\",\n+                                            name);\n+                            }\n+                        }\n+\n                         if value_result.is_unknown() {\n                             value_result = UnboundResult;\n                         }\n@@ -693,9 +709,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                            target);\n \n         if value_result.is_unbound() && type_result.is_unbound() {\n-            let msg = format!(\"There is no `{}` in `{}`\",\n+            let msg = format!(\"There is no `{}` in `{}`{}\",\n                               source,\n-                              module_to_string(&target_module));\n+                              module_to_string(&target_module), lev_suggestion);\n             return ResolveResult::Failed(Some((directive.span, msg)));\n         }\n         let value_used_public = value_used_reexport || value_used_public;"}, {"sha": "72d0e5b53321e243190b1e779033cdd134c41ef4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "patch": "@@ -121,7 +121,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, Spanned};\n use syntax::parse::token::{self, InternedString};\n use syntax::ptr::P;\n-use syntax::util::lev_distance::lev_distance;\n+use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n@@ -2981,28 +2981,22 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  skip : Vec<InternedString>) {\n         let name = field.node.as_str();\n+        let names = variant.fields\n+                    .iter()\n+                    .filter_map(|ref field| {\n+                        // ignore already set fields and private fields from non-local crates\n+                        if skip.iter().any(|x| *x == field.name.as_str()) ||\n+                           (variant.did.krate != LOCAL_CRATE && field.vis != Visibility::Public) {\n+                               None\n+                        } else {\n+                            Some(&field.name)\n+                        }\n+                    });\n+\n         // only find fits with at least one matching letter\n-        let mut best_dist = name.len();\n-        let mut best = None;\n-        for elem in &variant.fields {\n-            let n = elem.name.as_str();\n-            // ignore already set fields\n-            if skip.iter().any(|x| *x == n) {\n-                continue;\n-            }\n-            // ignore private fields from non-local crates\n-            if variant.did.krate != LOCAL_CRATE && elem.vis != Visibility::Public {\n-                continue;\n-            }\n-            let dist = lev_distance(&n, &name);\n-            if dist < best_dist {\n-                best = Some(n);\n-                best_dist = dist;\n-            }\n-        }\n-        if let Some(n) = best {\n+        if let Some(name) = find_best_match_for_name(names, &name, Some(name.len())) {\n             tcx.sess.span_help(field.span,\n-                &format!(\"did you mean `{}`?\", n));\n+                &format!(\"did you mean `{}`?\", name));\n         }\n     }\n "}, {"sha": "f616420218e1aff1427f4d66c2562a251c6338b0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "patch": "@@ -24,7 +24,7 @@ use parse::token;\n use parse::token::{InternedString, intern, str_to_ident};\n use ptr::P;\n use util::small_vector::SmallVector;\n-use util::lev_distance::{lev_distance, max_suggestion_distance};\n+use util::lev_distance::find_best_match_for_name;\n use ext::mtwt;\n use fold::Folder;\n \n@@ -744,15 +744,8 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn suggest_macro_name(&mut self, name: &str, span: Span) {\n-        let mut min: Option<(Name, usize)> = None;\n-        let max_dist = max_suggestion_distance(name);\n-        for macro_name in self.syntax_env.names.iter() {\n-            let dist = lev_distance(name, &macro_name.as_str());\n-            if dist <= max_dist && (min.is_none() || min.unwrap().1 > dist) {\n-                min = Some((*macro_name, dist));\n-            }\n-        }\n-        if let Some((suggestion, _)) = min {\n+        let names = &self.syntax_env.names;\n+        if let Some(suggestion) = find_best_match_for_name(names.iter(), name, None) {\n             self.fileline_help(span, &format!(\"did you mean `{}!`?\", suggestion));\n         }\n     }"}, {"sha": "e0796c34e57efde74e2e0e046780785547279196", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "patch": "@@ -8,50 +8,64 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use ast::Name;\n use std::cmp;\n+use parse::token::InternedString;\n \n-pub fn lev_distance(me: &str, t: &str) -> usize {\n-    if me.is_empty() { return t.chars().count(); }\n-    if t.is_empty() { return me.chars().count(); }\n+/// To find the Levenshtein distance between two strings\n+pub fn lev_distance(a: &str, b: &str) -> usize {\n+    // cases which don't require further computation\n+    if a.is_empty() {\n+        return b.chars().count();\n+    } else if b.is_empty() {\n+        return a.chars().count();\n+    }\n \n-    let mut dcol: Vec<_> = (0..t.len() + 1).collect();\n+    let mut dcol: Vec<_> = (0..b.len() + 1).collect();\n     let mut t_last = 0;\n \n-    for (i, sc) in me.chars().enumerate() {\n-\n+    for (i, sc) in a.chars().enumerate() {\n         let mut current = i;\n         dcol[0] = current + 1;\n \n-        for (j, tc) in t.chars().enumerate() {\n-\n+        for (j, tc) in b.chars().enumerate() {\n             let next = dcol[j + 1];\n-\n             if sc == tc {\n                 dcol[j + 1] = current;\n             } else {\n                 dcol[j + 1] = cmp::min(current, next);\n                 dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n             }\n-\n             current = next;\n             t_last = j;\n         }\n-    }\n-\n-    dcol[t_last + 1]\n+    } dcol[t_last + 1]\n }\n \n-pub fn max_suggestion_distance(name: &str) -> usize {\n-    use std::cmp::max;\n-    // As a loose rule to avoid obviously incorrect suggestions, clamp the\n-    // maximum edit distance we will accept for a suggestion to one third of\n-    // the typo'd name's length.\n-    max(name.len(), 3) / 3\n+/// To find the best match for a given string from an iterator of names\n+/// As a loose rule to avoid the obviously incorrect suggestions, it takes\n+/// an optional limit for the maximum allowable edit distance, which defaults\n+/// to one-third of the given word\n+pub fn find_best_match_for_name<'a, T>(iter_names: T,\n+                                       lookup: &str,\n+                                       dist: Option<usize>) -> Option<InternedString>\n+    where T: Iterator<Item = &'a Name> {\n+    let max_dist = dist.map_or_else(|| cmp::max(lookup.len(), 3) / 3, |d| d);\n+    iter_names\n+    .filter_map(|name| {\n+        let dist = lev_distance(lookup, &name.as_str());\n+        match dist <= max_dist {    // filter the unwanted cases\n+            true => Some((name.as_str(), dist)),\n+            false => None,\n+        }\n+    })\n+    .min_by_key(|&(_, val)| val)    // extract the tuple containing the minimum edit distance\n+    .map(|(s, _)| s)                // and return only the string\n }\n \n #[test]\n fn test_lev_distance() {\n-    use std::char::{ from_u32, MAX };\n+    use std::char::{from_u32, MAX};\n     // Test bytelength agnosticity\n     for c in (0..MAX as u32)\n              .filter_map(|i| from_u32(i))"}, {"sha": "b6207450d983594ffe1c8a4c9127cbe67d2b15d0", "filename": "src/test/compile-fail/unresolved-import.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce1dafd1d58852a88f38a0f63cb11236a7470cb/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs?ref=4ce1dafd1d58852a88f38a0f63cb11236a7470cb", "patch": "@@ -8,24 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n use foo::bar; //~ ERROR unresolved import `foo::bar`. Maybe a missing `extern crate foo`?\n \n-use bar::baz as x; //~ ERROR unresolved import `bar::baz`. There is no `baz` in `bar`\n+use bar::Baz as x; //~ ERROR unresolved import `bar::Baz`. There is no `Baz` in `bar`. Did you mean to use `Bar`?\n \n-use food::baz; //~ ERROR unresolved import `food::baz`. There is no `baz` in `food`\n+use food::baz; //~ ERROR unresolved import `food::baz`. There is no `baz` in `food`. Did you mean to use the re-exported import `bag`?\n \n-use food::{quux as beans}; //~ ERROR unresolved import `food::quux`. There is no `quux` in `food`\n+use food::{beens as Foo}; //~ ERROR unresolved import `food::beens`. There is no `beens` in `food`. Did you mean to use the re-exported import `beans`?\n \n mod bar {\n-    struct bar;\n+    pub struct Bar;\n }\n \n mod food {\n-    pub use self::zug::baz::{self as bag, quux as beans};\n+    pub use self::zug::baz::{self as bag, foobar as beans};\n \n     mod zug {\n         pub mod baz {\n-            pub struct quux;\n+            pub struct foobar;\n         }\n     }\n }"}]}