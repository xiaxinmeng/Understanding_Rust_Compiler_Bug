{"sha": "2011ced333fb800d7101568a3f1588572b77ba19", "node_id": "C_kwDOAAsO6NoAKDIwMTFjZWQzMzNmYjgwMGQ3MTAxNTY4YTNmMTU4ODU3MmI3N2JhMTk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-23T05:18:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-23T05:18:07Z"}, "message": "Rollup merge of #108349 - GuillaumeGomez:fix-duplicated-imports2, r=notriddle\n\nrustdoc: Prevent duplicated imports\n\nFixes #108163.\n\nInterestingly enough, the AST is providing us an import for each corresponding item, even though the `Res` links to multiple ones each time, which leaded to the same import being duplicated.\n\nSo in this PR, I decided to prevent the add of the import before the clean pass. However, I originally took a different path by instead filtering after cleaning the path. You can see it [here](https://github.com/rust-lang/rust/compare/master...GuillaumeGomez:rust:fix-duplicated-imports?expand=1). Only the second commit differs.\n\nI think this approach is better though, but at least we can compare both if we want.\n\nThe first commit adds the check for duplicated items in the rustdoc-json output as asked in #108163.\n\ncc `@aDotInTheVoid`\nr? `@notriddle`", "tree": {"sha": "1d9b9988c74e55b41c3b1438a1e3636215e1f9f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d9b9988c74e55b41c3b1438a1e3636215e1f9f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2011ced333fb800d7101568a3f1588572b77ba19", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj9vcPCRBK7hj4Ov3rIwAAVs8IAA+FR7NqHX8N/5iizzthO2CP\nMFB+KkNfLzFZENAnS4dSHH/BlAzBK6ESxbJzf2PcfhOW9AcRVHyaQlaaSEZWx2c6\n+HDIqEA+BtVyMJ3lF6twi1YYsgm19qo4EIbwY2kjviA9aPZAEODXUqelb0EdbXN4\ndQV5ON93VfcKdL4D6AlvnOIvRAbnHRoR2cSnhnZQzDxdjapYyheJLhpXskfINiWX\nQt3DbCAV/7Geow0wk1FSZi+MO7ClveCrK//jU56bGseMNenghTEiOOed6oOUdU03\nU1pXLNn1756ynS1yCzBzpSJXDlWVtnzqqVb3ZQHLvAWsk7Qd2Qbvv1N0GZepcwM=\n=baRh\n-----END PGP SIGNATURE-----\n", "payload": "tree 1d9b9988c74e55b41c3b1438a1e3636215e1f9f9\nparent c4a4bce6950260045576e9d50014fe0dfe178a1f\nparent 20dd1bd9a8ce947619c294f477a7d9042b0b265e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1677129487 +0100\ncommitter GitHub <noreply@github.com> 1677129487 +0100\n\nRollup merge of #108349 - GuillaumeGomez:fix-duplicated-imports2, r=notriddle\n\nrustdoc: Prevent duplicated imports\n\nFixes #108163.\n\nInterestingly enough, the AST is providing us an import for each corresponding item, even though the `Res` links to multiple ones each time, which leaded to the same import being duplicated.\n\nSo in this PR, I decided to prevent the add of the import before the clean pass. However, I originally took a different path by instead filtering after cleaning the path. You can see it [here](https://github.com/rust-lang/rust/compare/master...GuillaumeGomez:rust:fix-duplicated-imports?expand=1). Only the second commit differs.\n\nI think this approach is better though, but at least we can compare both if we want.\n\nThe first commit adds the check for duplicated items in the rustdoc-json output as asked in #108163.\n\ncc `@aDotInTheVoid`\nr? `@notriddle`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2011ced333fb800d7101568a3f1588572b77ba19", "html_url": "https://github.com/rust-lang/rust/commit/2011ced333fb800d7101568a3f1588572b77ba19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2011ced333fb800d7101568a3f1588572b77ba19/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4a4bce6950260045576e9d50014fe0dfe178a1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4a4bce6950260045576e9d50014fe0dfe178a1f", "html_url": "https://github.com/rust-lang/rust/commit/c4a4bce6950260045576e9d50014fe0dfe178a1f"}, {"sha": "20dd1bd9a8ce947619c294f477a7d9042b0b265e", "url": "https://api.github.com/repos/rust-lang/rust/commits/20dd1bd9a8ce947619c294f477a7d9042b0b265e", "html_url": "https://github.com/rust-lang/rust/commit/20dd1bd9a8ce947619c294f477a7d9042b0b265e"}], "stats": {"total": 78, "additions": 64, "deletions": 14}, "files": [{"sha": "648423e1289b949659e9b0d186b8054383e72127", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2011ced333fb800d7101568a3f1588572b77ba19/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2011ced333fb800d7101568a3f1588572b77ba19/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2011ced333fb800d7101568a3f1588572b77ba19", "patch": "@@ -77,7 +77,7 @@ pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<\n     // This covers the case where somebody does an import which should pull in an item,\n     // but there's already an item with the same namespace and same name. Rust gives\n     // priority to the not-imported one, so we should, too.\n-    items.extend(doc.items.iter().flat_map(|(item, renamed, import_id)| {\n+    items.extend(doc.items.values().flat_map(|(item, renamed, import_id)| {\n         // First, lower everything other than imports.\n         if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n             return Vec::new();\n@@ -90,7 +90,7 @@ pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<\n         }\n         v\n     }));\n-    items.extend(doc.items.iter().flat_map(|(item, renamed, _)| {\n+    items.extend(doc.items.values().flat_map(|(item, renamed, _)| {\n         // Now we actually lower the imports, skipping everything else.\n         if let hir::ItemKind::Use(path, hir::UseKind::Glob) = item.kind {\n             let name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));"}, {"sha": "277201e4de978376955a6e65ecbd35bf2eb10949", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2011ced333fb800d7101568a3f1588572b77ba19/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2011ced333fb800d7101568a3f1588572b77ba19/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=2011ced333fb800d7101568a3f1588572b77ba19", "patch": "@@ -1,7 +1,7 @@\n //! The Rust AST Visitor. Extracts useful information and massages it into a form\n //! usable for `clean`.\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LocalDefIdSet};\n@@ -26,8 +26,12 @@ pub(crate) struct Module<'hir> {\n     pub(crate) where_inner: Span,\n     pub(crate) mods: Vec<Module<'hir>>,\n     pub(crate) def_id: LocalDefId,\n-    // (item, renamed, import_id)\n-    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>, Option<LocalDefId>)>,\n+    /// The key is the item `ItemId` and the value is: (item, renamed, import_id).\n+    /// We use `FxIndexMap` to keep the insert order.\n+    pub(crate) items: FxIndexMap<\n+        (LocalDefId, Option<Symbol>),\n+        (&'hir hir::Item<'hir>, Option<Symbol>, Option<LocalDefId>),\n+    >,\n     pub(crate) foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n }\n \n@@ -38,7 +42,7 @@ impl Module<'_> {\n             def_id,\n             where_inner,\n             mods: Vec::new(),\n-            items: Vec::new(),\n+            items: FxIndexMap::default(),\n             foreigns: Vec::new(),\n         }\n     }\n@@ -136,7 +140,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 inserted.insert(def_id)\n             {\n                     let item = self.cx.tcx.hir().expect_item(local_def_id);\n-                    top_level_module.items.push((item, None, None));\n+                    top_level_module.items.insert((local_def_id, Some(item.ident.name)), (item, None, None));\n             }\n         }\n \n@@ -294,7 +298,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         renamed: Option<Symbol>,\n         parent_id: Option<LocalDefId>,\n     ) {\n-        self.modules.last_mut().unwrap().items.push((item, renamed, parent_id))\n+        self.modules\n+            .last_mut()\n+            .unwrap()\n+            .items\n+            .insert((item.owner_id.def_id, renamed), (item, renamed, parent_id));\n     }\n \n     fn visit_item_inner("}, {"sha": "a1f675a3b40f650af97bcafd8f48a684196b18d9", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2011ced333fb800d7101568a3f1588572b77ba19/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2011ced333fb800d7101568a3f1588572b77ba19/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=2011ced333fb800d7101568a3f1588572b77ba19", "patch": "@@ -71,6 +71,19 @@ impl<'a> Validator<'a> {\n         }\n     }\n \n+    fn check_items(&mut self, id: &Id, items: &[Id]) {\n+        let mut visited_ids = HashSet::with_capacity(items.len());\n+\n+        for item in items {\n+            if !visited_ids.insert(item) {\n+                self.fail(\n+                    id,\n+                    ErrorKind::Custom(format!(\"Duplicated entry in `items` field: `{item:?}`\")),\n+                );\n+            }\n+        }\n+    }\n+\n     fn check_item(&mut self, id: &'a Id) {\n         if let Some(item) = &self.krate.index.get(id) {\n             item.links.values().for_each(|id| self.add_any_id(id));\n@@ -83,9 +96,9 @@ impl<'a> Validator<'a> {\n                 ItemEnum::Enum(x) => self.check_enum(x),\n                 ItemEnum::Variant(x) => self.check_variant(x, id),\n                 ItemEnum::Function(x) => self.check_function(x),\n-                ItemEnum::Trait(x) => self.check_trait(x),\n+                ItemEnum::Trait(x) => self.check_trait(x, id),\n                 ItemEnum::TraitAlias(x) => self.check_trait_alias(x),\n-                ItemEnum::Impl(x) => self.check_impl(x),\n+                ItemEnum::Impl(x) => self.check_impl(x, id),\n                 ItemEnum::Typedef(x) => self.check_typedef(x),\n                 ItemEnum::OpaqueTy(x) => self.check_opaque_ty(x),\n                 ItemEnum::Constant(x) => self.check_constant(x),\n@@ -94,7 +107,7 @@ impl<'a> Validator<'a> {\n                 ItemEnum::Macro(x) => self.check_macro(x),\n                 ItemEnum::ProcMacro(x) => self.check_proc_macro(x),\n                 ItemEnum::Primitive(x) => self.check_primitive_type(x),\n-                ItemEnum::Module(x) => self.check_module(x),\n+                ItemEnum::Module(x) => self.check_module(x, id),\n                 // FIXME: Why don't these have their own structs?\n                 ItemEnum::ExternCrate { .. } => {}\n                 ItemEnum::AssocConst { type_, default: _ } => self.check_type(type_),\n@@ -112,7 +125,8 @@ impl<'a> Validator<'a> {\n     }\n \n     // Core checkers\n-    fn check_module(&mut self, module: &'a Module) {\n+    fn check_module(&mut self, module: &'a Module, id: &Id) {\n+        self.check_items(id, &module.items);\n         module.items.iter().for_each(|i| self.add_mod_item_id(i));\n     }\n \n@@ -181,7 +195,8 @@ impl<'a> Validator<'a> {\n         self.check_fn_decl(&x.decl);\n     }\n \n-    fn check_trait(&mut self, x: &'a Trait) {\n+    fn check_trait(&mut self, x: &'a Trait, id: &Id) {\n+        self.check_items(id, &x.items);\n         self.check_generics(&x.generics);\n         x.items.iter().for_each(|i| self.add_trait_item_id(i));\n         x.bounds.iter().for_each(|i| self.check_generic_bound(i));\n@@ -193,7 +208,8 @@ impl<'a> Validator<'a> {\n         x.params.iter().for_each(|i| self.check_generic_bound(i));\n     }\n \n-    fn check_impl(&mut self, x: &'a Impl) {\n+    fn check_impl(&mut self, x: &'a Impl, id: &Id) {\n+        self.check_items(id, &x.items);\n         self.check_generics(&x.generics);\n         if let Some(path) = &x.trait_ {\n             self.check_path(path, PathKind::Trait);"}, {"sha": "fe6f1b38ca620d46234e9957b06da2dfb37f2a96", "filename": "tests/rustdoc/reexports-of-same-name.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2011ced333fb800d7101568a3f1588572b77ba19/tests%2Frustdoc%2Freexports-of-same-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2011ced333fb800d7101568a3f1588572b77ba19/tests%2Frustdoc%2Freexports-of-same-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexports-of-same-name.rs?ref=2011ced333fb800d7101568a3f1588572b77ba19", "patch": "@@ -0,0 +1,26 @@\n+// This test ensures that there are 4 imports as expected:\n+// * 2 for `Foo`\n+// * 2 for `Bar`\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+\n+pub mod nested {\n+    /// Foo the struct\n+    pub struct Foo {}\n+\n+    #[allow(non_snake_case)]\n+    /// Foo the function\n+    pub fn Foo() {}\n+}\n+\n+// @count - '//*[@id=\"main-content\"]//code' 'pub use nested::Foo;' 2\n+// @has - '//*[@id=\"reexport.Foo\"]//a[@href=\"nested/struct.Foo.html\"]' 'Foo'\n+// @has - '//*[@id=\"reexport.Foo-1\"]//a[@href=\"nested/fn.Foo.html\"]' 'Foo'\n+pub use nested::Foo;\n+\n+// @count - '//*[@id=\"main-content\"]//code' 'pub use Foo as Bar;' 2\n+// @has - '//*[@id=\"reexport.Bar\"]//a[@href=\"nested/struct.Foo.html\"]' 'Foo'\n+// @has - '//*[@id=\"reexport.Bar-1\"]//a[@href=\"nested/fn.Foo.html\"]' 'Foo'\n+pub use Foo as Bar;"}]}