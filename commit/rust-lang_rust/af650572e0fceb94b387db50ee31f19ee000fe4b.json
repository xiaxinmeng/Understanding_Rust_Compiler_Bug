{"sha": "af650572e0fceb94b387db50ee31f19ee000fe4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNjUwNTcyZTBmY2ViOTRiMzg3ZGI1MGVlMzFmMTllZTAwMGZlNGI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-26T14:24:10Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-17T06:17:46Z"}, "message": "std/rt: in-progress file io work\n\nstd: remove unneeded field from RequestData struct\n\nstd: rt::uv::file - map us_fs_stat & start refactoring calls into FsRequest\n\nstd: stubbing out stat calls from the top-down into uvio\n\nstd: us_fs_* operations are now by-val self methods on FsRequest\n\nstd: post-rebase cleanup\n\nstd: add uv_fs_mkdir|rmdir + tests & minor test cleanup in rt::uv::file\n\nWORKING: fleshing out FileStat and FileInfo + tests\n\nstd: reverting test files..\n\nrefactoring back and cleanup...", "tree": {"sha": "e50fea65e834311dcd3a1ee9728bb68b33f42532", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e50fea65e834311dcd3a1ee9728bb68b33f42532"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af650572e0fceb94b387db50ee31f19ee000fe4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af650572e0fceb94b387db50ee31f19ee000fe4b", "html_url": "https://github.com/rust-lang/rust/commit/af650572e0fceb94b387db50ee31f19ee000fe4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af650572e0fceb94b387db50ee31f19ee000fe4b/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b75e07501b8a68bc2acf61d506d5b21498448c0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75e07501b8a68bc2acf61d506d5b21498448c0c", "html_url": "https://github.com/rust-lang/rust/commit/b75e07501b8a68bc2acf61d506d5b21498448c0c"}], "stats": {"total": 911, "additions": 708, "deletions": 203}, "files": [{"sha": "ee102c3a97ff8e291309cc526b1f17d79d0ba01e", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 156, "deletions": 6, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=af650572e0fceb94b387db50ee31f19ee000fe4b", "patch": "@@ -11,12 +11,15 @@\n use prelude::*;\n use super::support::PathLike;\n use super::{Reader, Writer, Seek};\n-use super::{SeekSet, SeekCur, SeekEnd, SeekStyle};\n+use super::{SeekStyle,SeekSet, SeekCur, SeekEnd,\n+            Open, Read, Create, ReadWrite};\n use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n use rt::io::{io_error, read_error, EndOfFile,\n-             FileMode, FileAccess, Open, Read, Create, ReadWrite};\n+            FileMode, FileAccess, FileStat};\n use rt::local::Local;\n-use rt::test::*;\n+use option::{Some, None};\n+use path::Path;\n+use super::super::test::*;\n \n /// Open a file for reading/writing, as indicated by `path`.\n pub fn open<P: PathLike>(path: &P,\n@@ -145,6 +148,123 @@ impl Seek for FileStream {\n     }\n }\n \n+pub struct FileInfo(Path);\n+\n+/// FIXME: DOCS\n+impl<'self> FileInfo {\n+    pub fn new<P: PathLike>(path: &P) -> FileInfo {\n+        do path.path_as_str |p| {\n+            FileInfo(Path(p))\n+        }\n+    }\n+    // FIXME #8873 can't put this in FileSystemInfo\n+    pub fn get_path(&'self self) -> &'self Path {\n+        &(**self)\n+    }\n+    pub fn stat(&self) -> Option<FileStat> {\n+        do io_error::cond.trap(|_| {\n+            // FIXME: can we do something more useful here?\n+        }).inside {\n+            stat(self.get_path())\n+        }\n+    }\n+    pub fn exists(&self) -> bool {\n+        match self.stat() {\n+            Some(s) => {\n+                match s.is_file {\n+                    true => {\n+                        true\n+                    },\n+                    false => {\n+                        // FIXME: raise condition?\n+                        false\n+                    }\n+                }\n+            },\n+            None => false\n+        }\n+    }\n+    pub fn is_file(&self) -> bool {\n+        match self.stat() {\n+            Some(s) => s.is_file,\n+            None => {\n+                // FIXME: raise condition\n+                false\n+            }\n+        }\n+    }\n+    pub fn open(&self, mode: FileMode, access: FileAccess) -> Option<FileStream> {\n+        match self.is_file() {\n+            true => {\n+                open(self.get_path(), mode, access)\n+            },\n+            false => {\n+                // FIXME: raise condition\n+                None\n+            }\n+        }\n+    }\n+    //fn open_read(&self) -> FileStream;\n+    //fn open_write(&self) -> FileStream;\n+    //fn create(&self) -> FileStream;\n+    //fn truncate(&self) -> FileStream;\n+    //fn open_or_create(&self) -> FileStream;\n+    //fn create_or_truncate(&self) -> FileStream;\n+    //fn unlink(&self);\n+}\n+\n+/*\n+/// FIXME: DOCS\n+impl DirectoryInfo<'self> {\n+    fn new<P: PathLike>(path: &P) -> FileInfo {\n+        FileInfo(Path(path.path_as_str()))\n+    }\n+    // FIXME #8873 can't put this in FileSystemInfo\n+    fn get_path(&'self self) -> &'self Path {\n+        &*self\n+    }\n+    fn stat(&self) -> Option<FileStat> {\n+        file::stat(self.get_path())\n+    }\n+    fn exists(&self) -> bool {\n+        do io_error::cond.trap(|_| {\n+        }).inside {\n+            match self.stat() {\n+                Some(_) => true,\n+                None => false\n+            }\n+        }\n+    }\n+    fn is_dir(&self) -> bool {\n+        \n+    }\n+    fn create(&self);\n+    fn get_subdirs(&self, filter: &str) -> ~[Path];\n+    fn get_files(&self, filter: &str) -> ~[Path];\n+}\n+*/\n+\n+/// Given a `rt::io::support::PathLike`, query the file system to get\n+/// information about a file, directory, etc.\n+///\n+/// Returns a `Some(PathInfo)` on success, and raises a `rt::io::IoError` condition\n+/// on failure and returns `None`.\n+pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n+    let open_result = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_stat(path)\n+    };\n+    match open_result {\n+        Ok(p) => {\n+            Some(p)\n+        },\n+        Err(ioerr) => {\n+            read_error::cond.raise(ioerr);\n+            None\n+        }\n+    }\n+}\n+\n fn file_test_smoke_test_impl() {\n     do run_in_mt_newsched_task {\n         let message = \"it's alright. have a good time\";\n@@ -273,7 +393,6 @@ fn file_test_io_seek_and_tell_smoke_test() {\n }\n \n fn file_test_io_seek_and_write_impl() {\n-    use io;\n     do run_in_mt_newsched_task {\n         use str;\n         let initial_msg =   \"food-is-yummy\";\n@@ -293,8 +412,7 @@ fn file_test_io_seek_and_write_impl() {\n             read_stream.read(read_mem);\n         }\n         unlink(filename);\n-        let read_str = str::from_utf8(read_mem);\n-        io::println(fmt!(\"read_str: '%?' final_msg: '%?'\", read_str, final_msg));\n+        let read_str = str::from_bytes(read_mem);\n         assert!(read_str == final_msg.to_owned());\n     }\n }\n@@ -343,3 +461,35 @@ fn file_test_io_seek_shakedown_impl() {\n fn file_test_io_seek_shakedown() {\n     file_test_io_seek_shakedown_impl();\n }\n+\n+#[test]\n+fn file_test_stat_is_correct_on_is_file() {\n+    do run_in_newsched_task {\n+        let filename = &Path(\"./tmp/file_stat_correct_on_is_file.txt\");\n+        {\n+            let mut fs = open(filename, Create, ReadWrite).unwrap();\n+            let msg = \"hw\";\n+            fs.write(msg.as_bytes());\n+        }\n+        let stat_res = match stat(filename) {\n+            Some(s) => s,\n+            None => fail!(\"shouldn't happen\")\n+        };\n+        assert!(stat_res.is_file);\n+    }\n+}\n+\n+#[test]\n+fn file_test_stat_is_correct_on_is_dir() {\n+    //assert!(false);\n+}\n+\n+#[test]\n+fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n+    //assert!(false);\n+}\n+\n+#[test]\n+fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n+    //assert!(false);\n+}"}, {"sha": "55c7cfd8285bc93c79bc31138a097d4a05b33cf8", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=af650572e0fceb94b387db50ee31f19ee000fe4b", "patch": "@@ -245,6 +245,7 @@ Out of scope\n use prelude::*;\n use to_str::ToStr;\n use str::{StrSlice, OwnedStr};\n+use path::Path;\n \n // Reexports\n pub use self::stdio::stdin;\n@@ -596,3 +597,26 @@ pub enum FileAccess {\n     Write,\n     ReadWrite\n }\n+\n+pub struct FileStat {\n+    /// A `Path` object containing information about the `PathInfo`'s location\n+    path: Path,\n+    /// `true` if the file pointed at by the `PathInfo` is a regular file\n+    is_file: bool,\n+    /// `true` if the file pointed at by the `PathInfo` is a directory\n+    is_dir: bool\n+    // `true` if the file pointed at by the `PathInfo` is a link (what this means\n+    // is platform dependant)\n+    /*\n+    /// The file pointed at by the `PathInfo`'s size in bytes\n+    size: u64,\n+    /// The file pointed at by the `PathInfo`'s time date in platform-dependent msecs\n+    created: u64,\n+    /// The file pointed at by the `PathInfo`'s last-modification time in\n+    /// platform-dependent msecs\n+    modified: u64,\n+    /// The file pointed at by the `PathInfo`'s last-accessd time (e.g. read) in\n+    /// platform-dependent msecs\n+    accessed: u64,\n+    */\n+}"}, {"sha": "f08949e9165862cfa5871d310bbc6c4e163d3c19", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=af650572e0fceb94b387db50ee31f19ee000fe4b", "patch": "@@ -18,7 +18,7 @@ use rt::uv::uvio;\n use path::Path;\n use super::io::support::PathLike;\n use super::io::{SeekStyle};\n-use super::io::{FileMode, FileAccess};\n+use super::io::{FileMode, FileAccess, FileStat};\n \n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n@@ -74,6 +74,13 @@ pub trait IoFactory {\n         -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n     fn get_host_addresses(&mut self, host: &str) -> Result<~[IpAddr], IoError>;\n+    fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError>;\n+    //fn fs_fstat(&mut self, fd: c_int) -> Result<FileStat, IoError>;\n+}\n+\n+pub trait RtioStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {"}, {"sha": "32e248254f4dbb01309565dbd7b8300baf4cbb55", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 327, "deletions": 183, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=af650572e0fceb94b387db50ee31f19ee000fe4b", "patch": "@@ -24,77 +24,186 @@ pub struct FsRequest(*uvll::uv_fs_t);\n impl Request for FsRequest;\n \n pub struct RequestData {\n-    complete_cb: Option<FsCallback>,\n-    raw_fd: Option<c_int>\n+    complete_cb: Option<FsCallback>\n }\n \n impl FsRequest {\n-    pub fn new(cb: Option<FsCallback>) -> FsRequest {\n+    pub fn new_REFACTOR_ME(cb: Option<FsCallback>) -> FsRequest {\n         let fs_req = unsafe { malloc_req(UV_FS) };\n         assert!(fs_req.is_not_null());\n         let fs_req: FsRequest = NativeHandle::from_native_handle(fs_req);\n         fs_req.install_req_data(cb);\n         fs_req\n     }\n \n-    fn open_common<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int,\n-               cb: Option<FsCallback>) -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb as *u8,\n-            None => 0 as *u8\n-        };\n-        let is_sync = cb.is_none();\n-        let req = FsRequest::new(cb);\n-        let result = path.path_as_str(|p| {\n+    pub fn new() -> FsRequest {\n+        let fs_req = unsafe { malloc_req(UV_FS) };\n+        assert!(fs_req.is_not_null());\n+        let fs_req: FsRequest = NativeHandle::from_native_handle(fs_req);\n+        fs_req\n+    }\n+\n+    pub fn open<P: PathLike>(self, loop_: &Loop, path: &P, flags: int, mode: int,\n+               cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        path.path_as_str(|p| {\n             p.to_c_str().with_ref(|p| unsafe {\n             uvll::fs_open(loop_.native_handle(),\n-                          req.native_handle(), p, flags, mode, complete_cb_ptr) as int\n+                          self.native_handle(), p, flags, mode, complete_cb_ptr)\n             })\n         });\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n     }\n-    pub fn open<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int,\n-               cb: FsCallback) {\n-        FsRequest::open_common(loop_, path, flags, mode, Some(cb));\n+\n+    pub fn open_sync<P: PathLike>(self, loop_: &Loop, path: &P,\n+                                  flags: int, mode: int) -> Result<c_int, UvError> {\n+        let complete_cb_ptr = self.req_boilerplate(None);\n+        let result = path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_open(loop_.native_handle(),\n+                    self.native_handle(), p, flags, mode, complete_cb_ptr)\n+            })\n+        });\n+        self.sync_cleanup(result)\n     }\n \n-    pub fn open_sync<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int)\n-          -> Result<int, UvError> {\n-        let result = FsRequest::open_common(loop_, path, flags, mode, None);\n-        sync_cleanup(result)\n+    pub fn unlink<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+                uvll::fs_unlink(loop_.native_handle(),\n+                              self.native_handle(), p, complete_cb_ptr)\n+            })\n+        });\n     }\n \n-    fn unlink_common<P: PathLike>(loop_: &Loop, path: &P, cb: Option<FsCallback>) -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb as *u8,\n-            None => 0 as *u8\n-        };\n-        let is_sync = cb.is_none();\n-        let req = FsRequest::new(cb);\n+    pub fn unlink_sync<P: PathLike>(self, loop_: &Loop, path: &P)\n+      -> Result<c_int, UvError> {\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let result = path.path_as_str(|p| {\n             p.to_c_str().with_ref(|p| unsafe {\n                 uvll::fs_unlink(loop_.native_handle(),\n-                              req.native_handle(), p, complete_cb_ptr) as int\n+                              self.native_handle(), p, complete_cb_ptr)\n             })\n         });\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn stat<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+                uvll::fs_stat(loop_.native_handle(),\n+                              self.native_handle(), p, complete_cb_ptr)\n+            })\n+        });\n+    }\n+\n+    pub fn write(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        let base_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        unsafe {\n+            uvll::fs_write(loop_.native_handle(), self.native_handle(),\n+                           fd, base_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n+    }\n+    pub fn write_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n+          -> Result<c_int, UvError> {\n+        let complete_cb_ptr = self.req_boilerplate(None);\n+        let base_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        let result = unsafe {\n+            uvll::fs_write(loop_.native_handle(), self.native_handle(),\n+                           fd, base_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn read(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        let buf_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        unsafe {\n+            uvll::fs_read(loop_.native_handle(), self.native_handle(),\n+                           fd, buf_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n+    }\n+    pub fn read_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n+          -> Result<c_int, UvError> {\n+        let complete_cb_ptr = self.req_boilerplate(None);\n+        let buf_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        let result = unsafe {\n+            uvll::fs_read(loop_.native_handle(), self.native_handle(),\n+                           fd, buf_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn close(self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        unsafe {\n+            uvll::fs_close(loop_.native_handle(), self.native_handle(),\n+                           fd, complete_cb_ptr)\n+        };\n+    }\n+    pub fn close_sync(self, loop_: &Loop, fd: c_int) -> Result<c_int, UvError> {\n+        let complete_cb_ptr = self.req_boilerplate(None);\n+        let result = unsafe {\n+            uvll::fs_close(loop_.native_handle(), self.native_handle(),\n+                           fd, complete_cb_ptr)\n+        };\n+        self.sync_cleanup(result)\n     }\n-    pub fn unlink<P: PathLike>(loop_: &Loop, path: &P, cb: FsCallback) {\n-        let result = FsRequest::unlink_common(loop_, path, Some(cb));\n-        sync_cleanup(result);\n+\n+    pub fn mkdir<P: PathLike>(self, loop_: &Loop, path: &P, mode: int, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_mkdir(loop_.native_handle(),\n+                          self.native_handle(), p, mode, complete_cb_ptr)\n+            })\n+        });\n     }\n-    pub fn unlink_sync<P: PathLike>(loop_: &Loop, path: &P) -> Result<int, UvError> {\n-        let result = FsRequest::unlink_common(loop_, path, None);\n-        sync_cleanup(result)\n+\n+    pub fn rmdir<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_rmdir(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n+            })\n+        });\n     }\n \n+    // accessors/utility funcs\n+    fn sync_cleanup(self, result: c_int)\n+          -> Result<c_int, UvError> {\n+        self.cleanup_and_delete();\n+        match status_to_maybe_uv_error(result as i32) {\n+            Some(err) => Err(err),\n+            None => Ok(result)\n+        }\n+    }\n+    fn req_boilerplate(&self, cb: Option<FsCallback>) -> *u8 {\n+        // XXX: this is unsafe/mutable\n+        let result = match cb {\n+            Some(_) => {\n+                compl_cb as *u8\n+            },\n+            None => 0 as *u8\n+        };\n+        self.install_req_data(cb);\n+        result\n+    }\n     pub fn install_req_data(&self, cb: Option<FsCallback>) {\n         let fs_req = (self.native_handle()) as *uvll::uv_write_t;\n         let data = ~RequestData {\n-            complete_cb: cb,\n-            raw_fd: None\n+            complete_cb: cb\n         };\n         unsafe {\n             let data = transmute::<~RequestData, *c_void>(data);\n@@ -106,7 +215,7 @@ impl FsRequest {\n         unsafe {\n             let data = uvll::get_data_for_req((self.native_handle()));\n             let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n-            return &mut **data;\n+            &mut **data\n         }\n     }\n \n@@ -120,6 +229,12 @@ impl FsRequest {\n         unsafe { Loop{handle:uvll::get_loop_from_fs_req(self.native_handle())} }\n     }\n \n+    pub fn get_stat(&self) -> uv_stat_t {\n+        let stat = uv_stat_t::new();\n+        unsafe { uvll::populate_stat(self.native_handle(), &stat); }\n+        stat\n+    }\n+\n     fn cleanup_and_delete(self) {\n         unsafe {\n             let data = uvll::get_data_for_req(self.native_handle());\n@@ -145,100 +260,7 @@ fn sync_cleanup(result: int)\n     match status_to_maybe_uv_error(result as i32) {\n         Some(err) => Err(err),\n         None => Ok(result)\n-    }\n-}\n-\n-pub struct FileDescriptor(c_int);\n-\n-impl FileDescriptor {\n-    fn new(fd: c_int) -> FileDescriptor {\n-        FileDescriptor(fd)\n-    }\n-\n-\n-    pub fn from_open_req(req: &mut FsRequest) -> FileDescriptor {\n-        FileDescriptor::new(req.get_result())\n-    }\n-\n-    // as per bnoordhuis in #libuv: offset >= 0 uses prwrite instead of write\n-    fn write_common(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: Option<FsCallback>)\n-          -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb as *u8,\n-            None => 0 as *u8\n-        };\n-        let is_sync = cb.is_none();\n-        let mut req = FsRequest::new(cb);\n-        let base_ptr = buf.base as *c_void;\n-        let len = buf.len as uint;\n-        req.get_req_data().raw_fd = Some(self.native_handle());\n-        let result = unsafe {\n-            uvll::fs_write(loop_.native_handle(), req.native_handle(),\n-                           self.native_handle(), base_ptr,\n-                           len, offset, complete_cb_ptr) as int\n-        };\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n-    }\n-    pub fn write(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: FsCallback) {\n-        self.write_common(loop_, buf, offset, Some(cb));\n-    }\n-    pub fn write_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n-          -> Result<int, UvError> {\n-        let result = self.write_common(loop_, buf, offset, None);\n-        sync_cleanup(result)\n-    }\n-\n-    fn read_common(&mut self, loop_: &Loop, buf: Buf,\n-                   offset: i64, cb: Option<FsCallback>)\n-          -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb as *u8,\n-            None => 0 as *u8\n-        };\n-        let is_sync = cb.is_none();\n-        let mut req = FsRequest::new(cb);\n-        req.get_req_data().raw_fd = Some(self.native_handle());\n-        let buf_ptr = buf.base as *c_void;\n-        let result = unsafe {\n-            uvll::fs_read(loop_.native_handle(), req.native_handle(),\n-                           self.native_handle(), buf_ptr,\n-                           buf.len as uint, offset, complete_cb_ptr) as int\n-        };\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n-    }\n-    pub fn read(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: FsCallback) {\n-        self.read_common(loop_, buf, offset, Some(cb));\n-    }\n-    pub fn read_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n-          -> Result<int, UvError> {\n-        let result = self.read_common(loop_, buf, offset, None);\n-        sync_cleanup(result)\n-    }\n \n-    fn close_common(self, loop_: &Loop, cb: Option<FsCallback>) -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb as *u8,\n-            None => 0 as *u8\n-        };\n-        let is_sync = cb.is_none();\n-        let req = FsRequest::new(cb);\n-        let result = unsafe {\n-            uvll::fs_close(loop_.native_handle(), req.native_handle(),\n-                           self.native_handle(), complete_cb_ptr) as int\n-        };\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n-    }\n-    pub fn close(self, loop_: &Loop, cb: FsCallback) {\n-        self.close_common(loop_, Some(cb));\n-    }\n-    pub fn close_sync(self, loop_: &Loop) -> Result<int, UvError> {\n-        let result = self.close_common(loop_, None);\n-        sync_cleanup(result)\n-    }\n-}\n extern fn compl_cb(req: *uv_fs_t) {\n     let mut req: FsRequest = NativeHandle::from_native_handle(req);\n     // pull the user cb out of the req data\n@@ -261,15 +283,7 @@ extern fn compl_cb(req: *uv_fs_t) {\n     req.cleanup_and_delete();\n }\n \n-impl NativeHandle<c_int> for FileDescriptor {\n-    fn from_native_handle(handle: c_int) -> FileDescriptor {\n-        FileDescriptor(handle)\n-    }\n-    fn native_handle(&self) -> c_int {\n-        match self { &FileDescriptor(ptr) => ptr }\n-    }\n-}\n-\n+#[cfg(test)]\n mod test {\n     use super::*;\n     //use rt::test::*;\n@@ -279,11 +293,12 @@ mod test {\n     use unstable::run_in_bare_thread;\n     use path::Path;\n     use rt::uv::{Loop, Buf, slice_to_uv_buf};\n-    use libc::{O_CREAT, O_RDWR, O_RDONLY,\n-               S_IWUSR, S_IRUSR}; //NOTE: need defs for S_**GRP|S_**OTH in libc:: ...\n-               //S_IRGRP, S_IROTH};\n+    use libc::{c_int, O_CREAT, O_RDWR, O_RDONLY,\n+               S_IWUSR, S_IRUSR};\n \n-    fn file_test_full_simple_impl() {\n+    #[test]\n+    #[ignore(cfg(windows))] // FIXME #8814\n+    fn file_test_full_simple() {\n         do run_in_bare_thread {\n             let mut loop_ = Loop::new();\n             let create_flags = O_RDWR | O_CREAT;\n@@ -302,25 +317,27 @@ mod test {\n             let read_buf = slice_to_uv_buf(read_mem);\n             let read_buf_ptr: *Buf = &read_buf;\n             let p = Path(path_str);\n-            do FsRequest::open(&loop_, &p, create_flags as int, mode as int)\n+            let open_req = FsRequest::new();\n+            do open_req.open(&loop_, &p, create_flags as int, mode as int)\n             |req, uverr| {\n                 assert!(uverr.is_none());\n-                let mut fd = FileDescriptor::from_open_req(req);\n-                let raw_fd = fd.native_handle();\n+                let fd = req.get_result();\n                 let buf = unsafe { *write_buf_ptr };\n-                do fd.write(&req.get_loop(), buf, -1) |req, uverr| {\n-                    let fd = FileDescriptor(raw_fd);\n-                    do fd.close(&req.get_loop()) |req, _| {\n-                        let loop_ = req.get_loop();\n+                let write_req = FsRequest::new();\n+                do write_req.write(&req.get_loop(), fd, buf, -1) |req, uverr| {\n+                    let close_req = FsRequest::new();\n+                    do close_req.close(&req.get_loop(), fd) |req, _| {\n                         assert!(uverr.is_none());\n-                        do FsRequest::open(&loop_, &Path(path_str), read_flags as int,0)\n+                        let loop_ = req.get_loop();\n+                        let open_req = FsRequest::new();\n+                        do open_req.open(&loop_, &Path(path_str), read_flags as int,0)\n                             |req, uverr| {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n-                            let mut fd = FileDescriptor::from_open_req(req);\n-                            let raw_fd = fd.native_handle();\n+                            let fd = req.get_result();\n                             let read_buf = unsafe { *read_buf_ptr };\n-                            do fd.read(&loop_, read_buf, 0) |req, uverr| {\n+                            let read_req = FsRequest::new();\n+                            do read_req.read(&loop_, fd, read_buf, 0) |req, uverr| {\n                                 assert!(uverr.is_none());\n                                 let loop_ = req.get_loop();\n                                 // we know nread >=0 because uverr is none..\n@@ -334,15 +351,17 @@ mod test {\n                                                 read_buf.base, nread))\n                                     };\n                                     assert!(read_str == ~\"hello\");\n-                                    do FileDescriptor(raw_fd).close(&loop_) |req,uverr| {\n+                                    let close_req = FsRequest::new();\n+                                    do close_req.close(&loop_, fd) |req,uverr| {\n                                         assert!(uverr.is_none());\n                                         let loop_ = &req.get_loop();\n-                                        do FsRequest::unlink(loop_, &Path(path_str))\n+                                        let unlink_req = FsRequest::new();\n+                                        do unlink_req.unlink(loop_, &Path(path_str))\n                                         |_,uverr| {\n                                             assert!(uverr.is_none());\n                                         };\n                                     };\n-                                }\n+                                };\n                             };\n                         };\n                     };\n@@ -352,7 +371,10 @@ mod test {\n             loop_.close();\n         }\n     }\n-    fn file_test_full_simple_impl_sync() {\n+\n+    #[test]\n+    #[ignore(cfg(windows))] // FIXME #8814\n+    fn file_test_full_simple_sync() {\n         do run_in_bare_thread {\n             // setup\n             let mut loop_ = Loop::new();\n@@ -368,26 +390,31 @@ mod test {\n             let write_val = \"hello\".as_bytes().to_owned();\n             let write_buf = slice_to_uv_buf(write_val);\n             // open/create\n-            let result = FsRequest::open_sync(&loop_, &Path(path_str),\n+            let open_req = FsRequest::new();\n+            let result = open_req.open_sync(&loop_, &Path(path_str),\n                                                    create_flags as int, mode as int);\n             assert!(result.is_ok());\n-            let mut fd = FileDescriptor(result.unwrap() as i32);\n+            let fd = result.unwrap();\n             // write\n-            let result = fd.write_sync(&loop_, write_buf, -1);\n+            let write_req = FsRequest::new();\n+            let result = write_req.write_sync(&loop_, fd, write_buf, -1);\n             assert!(result.is_ok());\n             // close\n-            let result = fd.close_sync(&loop_);\n+            let close_req = FsRequest::new();\n+            let result = close_req.close_sync(&loop_, fd);\n             assert!(result.is_ok());\n             // re-open\n-            let result = FsRequest::open_sync(&loop_, &Path(path_str),\n+            let open_req = FsRequest::new();\n+            let result = open_req.open_sync(&loop_, &Path(path_str),\n                                                    read_flags as int,0);\n             assert!(result.is_ok());\n             let len = 1028;\n-            let mut fd = FileDescriptor(result.unwrap() as i32);\n+            let fd = result.unwrap();\n             // read\n             let read_mem: ~[u8] = vec::from_elem(len, 0u8);\n             let buf = slice_to_uv_buf(read_mem);\n-            let result = fd.read_sync(&loop_, buf, 0);\n+            let read_req = FsRequest::new();\n+            let result = read_req.read_sync(&loop_, fd, buf, 0);\n             assert!(result.is_ok());\n             let nread = result.unwrap();\n             // nread == 0 would be EOF.. we know it's >= zero because otherwise\n@@ -397,31 +424,23 @@ mod test {\n                     read_mem.slice(0, nread as uint));\n                 assert!(read_str == ~\"hello\");\n                 // close\n-                let result = fd.close_sync(&loop_);\n+                let close_req = FsRequest::new();\n+                let result = close_req.close_sync(&loop_, fd);\n                 assert!(result.is_ok());\n                 // unlink\n-                let result = FsRequest::unlink_sync(&loop_, &Path(path_str));\n+                let unlink_req = FsRequest::new();\n+                let result = unlink_req.unlink_sync(&loop_, &Path(path_str));\n                 assert!(result.is_ok());\n             } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();\n         }\n     }\n \n-    #[test]\n-    fn file_test_full_simple() {\n-        file_test_full_simple_impl();\n-    }\n-\n-    #[test]\n-    fn file_test_full_simple_sync() {\n-        file_test_full_simple_impl_sync();\n-    }\n-\n     fn naive_print(loop_: &Loop, input: &str) {\n-        let mut stdout = FileDescriptor(STDOUT_FILENO);\n         let write_val = input.as_bytes();\n         let write_buf = slice_to_uv_buf(write_val);\n-        stdout.write_sync(loop_, write_buf, -1);\n+        let write_req = FsRequest::new();\n+        write_req.write_sync(loop_, stdout, write_buf, -1);\n     }\n \n     #[test]\n@@ -433,4 +452,129 @@ mod test {\n             loop_.close();\n         };\n     }\n+    #[test]\n+    fn file_test_stat_simple() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/file_test_stat_simple.txt\";\n+            let create_flags = O_RDWR |\n+                O_CREAT;\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+            let write_val = \"hello\".as_bytes().to_owned();\n+            let write_buf  = slice_to_uv_buf(write_val);\n+            let write_buf_ptr: *Buf = &write_buf;\n+            let open_req = FsRequest::new();\n+            do open_req.open(&loop_, &path, create_flags as int, mode as int)\n+            |req, uverr| {\n+                assert!(uverr.is_none());\n+                let fd = req.get_result();\n+                let buf = unsafe { *write_buf_ptr };\n+                let write_req = FsRequest::new();\n+                do write_req.write(&req.get_loop(), fd, buf, 0) |req, uverr| {\n+                    assert!(uverr.is_none());\n+                    let loop_ = req.get_loop();\n+                    let stat_req = FsRequest::new();\n+                    do stat_req.stat(&loop_, &path) |req, uverr| {\n+                        assert!(uverr.is_none());\n+                        let loop_ = req.get_loop();\n+                        let stat = req.get_stat();\n+                        let sz: uint = stat.st_size as uint;\n+                        assert!(sz > 0);\n+                        let close_req = FsRequest::new();\n+                        do close_req.close(&loop_, fd) |req, uverr| {\n+                            assert!(uverr.is_none());\n+                            let loop_ = req.get_loop();\n+                            let unlink_req = FsRequest::new();\n+                            do unlink_req.unlink(&loop_, &path) |req,uverr| {\n+                                assert!(uverr.is_none());\n+                                let loop_ = req.get_loop();\n+                                let stat_req = FsRequest::new();\n+                                do stat_req.stat(&loop_, &path) |_, uverr| {\n+                                    // should cause an error because the\n+                                    // file doesn't exist anymore\n+                                    assert!(uverr.is_some());\n+                                };\n+                            };\n+                        };\n+                    };\n+                };\n+            };\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn file_test_mk_rm_dir() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/mk_rm_dir\";\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+            let mkdir_req = FsRequest::new();\n+            do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+                assert!(uverr.is_none());\n+                let loop_ = req.get_loop();\n+                let stat_req = FsRequest::new();\n+                do stat_req.stat(&loop_, &path) |req, uverr| {\n+                    assert!(uverr.is_none());\n+                    let loop_ = req.get_loop();\n+                    let stat = req.get_stat();\n+                    assert!(stat.is_dir());\n+                    let rmdir_req = FsRequest::new();\n+                    do rmdir_req.rmdir(&loop_, &path) |req,uverr| {\n+                        assert!(uverr.is_none());\n+                        let loop_ = req.get_loop();\n+                        let stat_req = FsRequest::new();\n+                        do stat_req.stat(&loop_, &path) |req, uverr| {\n+                            assert!(uverr.is_some());\n+                        }\n+                    }\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+    #[test]\n+    fn file_test_mkdir_chokes_on_double_create() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/double_create_dir\";\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+            let mkdir_req = FsRequest::new();\n+            do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+                assert!(uverr.is_none());\n+                let loop_ = req.get_loop();\n+                let mkdir_req = FsRequest::new();\n+                do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+                    assert!(uverr.is_some());\n+                    let loop_ = req.get_loop();\n+                    let stat = req.get_stat();\n+                    let rmdir_req = FsRequest::new();\n+                    do rmdir_req.rmdir(&loop_, &path) |req,uverr| {\n+                        assert!(uverr.is_none());\n+                        let loop_ = req.get_loop();\n+                    }\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+    #[test]\n+    fn file_test_rmdir_chokes_on_nonexistant_path() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/never_existed_dir\";\n+            let rmdir_req = FsRequest::new();\n+            do rmdir_req.rmdir(&loop_, &path) |req,uverr| {\n+                assert!(uverr.is_some());\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n }"}, {"sha": "4307c57529b5ff0919c24c872039c3d3eecb385c", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=af650572e0fceb94b387db50ee31f19ee000fe4b", "patch": "@@ -32,11 +32,13 @@ use rt::uv::idle::IdleWatcher;\n use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr, accum_sockaddrs};\n use rt::uv::addrinfo::GetAddrInfoRequest;\n use unstable::sync::Exclusive;\n+use path::Path;\n use super::super::io::support::PathLike;\n use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n           S_IRUSR, S_IWUSR};\n use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n-            CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite};\n+             CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n+             FileStat};\n use task;\n \n #[cfg(test)] use container::Container;\n@@ -516,7 +518,6 @@ impl IoFactory for UvIoFactory {\n \n     fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream {\n         let loop_ = Loop {handle: self.uv_loop().native_handle()};\n-        let fd = file::FileDescriptor(fd);\n         let home = get_handle_to_current_scheduler!();\n         ~UvFileStream::new(loop_, fd, close_on_drop, home) as ~RtioFileStream\n     }\n@@ -547,15 +548,16 @@ impl IoFactory for UvIoFactory {\n         let path_cell = Cell::new(path);\n         do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n+            let open_req = file::FsRequest::new();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n-                do file::FsRequest::open(self.uv_loop(), path, flags as int, create_mode as int)\n+                do open_req.open(self.uv_loop(), path, flags as int, create_mode as int)\n                       |req,err| {\n                     if err.is_none() {\n                         let loop_ = Loop {handle: req.get_loop().native_handle()};\n                         let home = get_handle_to_current_scheduler!();\n-                        let fd = file::FileDescriptor(req.get_result());\n+                        let fd = req.get_result() as c_int;\n                         let fs = ~UvFileStream::new(\n                             loop_, fd, true, home) as ~RtioFileStream;\n                         let res = Ok(fs);\n@@ -570,7 +572,7 @@ impl IoFactory for UvIoFactory {\n                     }\n                 };\n             };\n-        }\n+        };\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n@@ -581,10 +583,11 @@ impl IoFactory for UvIoFactory {\n         let path_cell = Cell::new(path);\n         do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n+            let unlink_req = FsRequest::new();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n-                do file::FsRequest::unlink(self.uv_loop(), path) |_, err| {\n+                do unlink_req.unlink(self.uv_loop(), path) |_, err| {\n                     let res = match err {\n                         None => Ok(()),\n                         Some(err) => Err(uv_error_to_io_error(err))\n@@ -593,11 +596,48 @@ impl IoFactory for UvIoFactory {\n                     let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 };\n-            };\n+            }\n         }\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+    fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError> {\n+        use str::StrSlice;\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<FileStat,\n+                                           IoError>> = &result_cell;\n+        let path_cell = Cell::new(path);\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            let stat_req = file::FsRequest::new();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let path = path_cell.take();\n+                let path_str = path.path_as_str(|p| p.to_owned());\n+                do stat_req.stat(self.uv_loop(), path)\n+                      |req,err| {\n+                    if err.is_none() {\n+                        let stat = req.get_stat();\n+                        let res = Ok(FileStat {\n+                            path: Path(path_str),\n+                            is_file: stat.is_file(),\n+                            is_dir: stat.is_dir()\n+                        });\n+                        unsafe { (*result_cell_ptr).put_back(res); }\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    } else {\n+                        let res = Err(uv_error_to_io_error(err.unwrap()));\n+                        unsafe { (*result_cell_ptr).put_back(res); }\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    }\n+                };\n+            };\n+        };\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n \n     fn get_host_addresses(&mut self, host: &str) -> Result<~[IpAddr], IoError> {\n         let result_cell = Cell::new_empty();\n@@ -629,6 +669,9 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+    //fn fs_fstat(&mut self, _fd: c_int) -> Result<FileStat, IoError> {\n+    //    Ok(FileStat)\n+    //}\n }\n \n pub struct UvTcpListener {\n@@ -1173,7 +1216,7 @@ impl RtioTimer for UvTimer {\n \n pub struct UvFileStream {\n     loop_: Loop,\n-    fd: file::FileDescriptor,\n+    fd: c_int,\n     close_on_drop: bool,\n     home: SchedHandle\n }\n@@ -1183,7 +1226,7 @@ impl HomingIO for UvFileStream {\n }\n \n impl UvFileStream {\n-    fn new(loop_: Loop, fd: file::FileDescriptor, close_on_drop: bool,\n+    fn new(loop_: Loop, fd: c_int, close_on_drop: bool,\n            home: SchedHandle) -> UvFileStream {\n         UvFileStream {\n             loop_: loop_,\n@@ -1200,7 +1243,8 @@ impl UvFileStream {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n                 let task_cell = Cell::new(task);\n-                do self_.fd.read(&self_.loop_, buf, offset) |req, uverr| {\n+                let read_req = file::FsRequest::new();\n+                do read_req.read(&self_.loop_, self_.fd, buf, offset) |req, uverr| {\n                     let res = match uverr  {\n                         None => Ok(req.get_result() as int),\n                         Some(err) => Err(uv_error_to_io_error(err))\n@@ -1221,7 +1265,8 @@ impl UvFileStream {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n                 let task_cell = Cell::new(task);\n-                do self_.fd.write(&self_.loop_, buf, offset) |_, uverr| {\n+                let write_req = file::FsRequest::new();\n+                do write_req.write(&self_.loop_, self_.fd, buf, offset) |_, uverr| {\n                     let res = match uverr  {\n                         None => Ok(()),\n                         Some(err) => Err(uv_error_to_io_error(err))\n@@ -1238,7 +1283,7 @@ impl UvFileStream {\n         Result<u64, IoError>{\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n-            match lseek((*self.fd), pos as off_t, whence) {\n+            match lseek(self.fd, pos as off_t, whence) {\n                 -1 => {\n                     Err(IoError {\n                         kind: OtherIoError,\n@@ -1259,7 +1304,8 @@ impl Drop for UvFileStream {\n             do self_.home_for_io_with_sched |self_, scheduler| {\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     let task_cell = Cell::new(task);\n-                    do self_.fd.close(&self.loop_) |_,_| {\n+                    let close_req = file::FsRequest::new();\n+                    do close_req.close(&self.loop_, self_.fd) |_,_| {\n                         let scheduler: ~Scheduler = Local::take();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());\n                     };"}, {"sha": "89ee54be349ad0cfff8c62a548377f88774667a4", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=af650572e0fceb94b387db50ee31f19ee000fe4b", "patch": "@@ -96,6 +96,59 @@ pub type uv_fs_t = c_void;\n pub type uv_udp_send_t = c_void;\n pub type uv_getaddrinfo_t = c_void;\n \n+pub struct uv_timespec_t {\n+    tv_sec: libc::c_long,\n+    tv_nsec: libc::c_long\n+}\n+\n+pub struct uv_stat_t {\n+    st_dev: libc::uint64_t,\n+    st_mode: libc::uint64_t,\n+    st_nlink: libc::uint64_t,\n+    st_uid: libc::uint64_t,\n+    st_gid: libc::uint64_t,\n+    st_rdev: libc::uint64_t,\n+    st_ino: libc::uint64_t,\n+    st_size: libc::uint64_t,\n+    st_blksize: libc::uint64_t,\n+    st_blocks: libc::uint64_t,\n+    st_flags: libc::uint64_t,\n+    st_gen: libc::uint64_t,\n+    st_atim: uv_timespec_t,\n+    st_mtim: uv_timespec_t,\n+    st_ctim: uv_timespec_t,\n+    st_birthtim: uv_timespec_t\n+}\n+\n+impl uv_stat_t {\n+    pub fn new() -> uv_stat_t {\n+        uv_stat_t {\n+            st_dev: 0,\n+            st_mode: 0,\n+            st_nlink: 0,\n+            st_uid: 0,\n+            st_gid: 0,\n+            st_rdev: 0,\n+            st_ino: 0,\n+            st_size: 0,\n+            st_blksize: 0,\n+            st_blocks: 0,\n+            st_flags: 0,\n+            st_gen: 0,\n+            st_atim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n+            st_mtim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n+            st_ctim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n+            st_birthtim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 }\n+        }\n+    }\n+    pub fn is_file(&self) -> bool {\n+        ((self.st_mode as c_int) & libc::S_IFMT) == libc::S_IFREG\n+    }\n+    pub fn is_dir(&self) -> bool {\n+        ((self.st_mode as c_int) & libc::S_IFMT) == libc::S_IFDIR\n+    }\n+}\n+\n #[cfg(stage0)]\n pub type uv_idle_cb = *u8;\n #[cfg(stage0)]\n@@ -736,6 +789,33 @@ pub unsafe fn fs_close(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n \n     rust_uv_fs_close(loop_ptr, req, fd, cb)\n }\n+pub unsafe fn fs_stat(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_stat(loop_ptr, req, path, cb)\n+}\n+pub unsafe fn fs_fstat(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_fstat(loop_ptr, req, fd, cb)\n+}\n+pub unsafe fn fs_mkdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, mode: int,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_mkdir(loop_ptr, req, path, mode as c_int, cb)\n+}\n+pub unsafe fn fs_rmdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_rmdir(loop_ptr, req, path, cb)\n+}\n+pub unsafe fn populate_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_populate_uv_stat(req_in, stat_out)\n+}\n pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -928,7 +1008,14 @@ extern {\n                        buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n     fn rust_uv_fs_close(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n                         cb: *u8) -> c_int;\n+    fn rust_uv_fs_stat(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char, cb: *u8) -> c_int;\n+    fn rust_uv_fs_fstat(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_mkdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        mode: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_rmdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        cb: *u8) -> c_int;\n     fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n+    fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n     fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n     fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;"}, {"sha": "ebc76c84ec9ffdba8d630a11d5a4451763531980", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=af650572e0fceb94b387db50ee31f19ee000fe4b", "patch": "@@ -551,3 +551,45 @@ extern \"C\" uv_loop_t*\n rust_uv_get_loop_from_getaddrinfo_req(uv_getaddrinfo_t* req) {\n   return req->loop;\n }\n+\n+extern \"C\" int\n+rust_uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  return uv_fs_stat(loop, req, path, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n+  return uv_fs_fstat(loop, req, file, cb);\n+}\n+\n+extern \"C\" void\n+rust_uv_populate_uv_stat(uv_fs_t* req_in, uv_stat_t* stat_out) {\n+  stat_out->st_dev = req_in->statbuf.st_dev;\n+  stat_out->st_mode = req_in->statbuf.st_mode;\n+  stat_out->st_nlink = req_in->statbuf.st_nlink;\n+  stat_out->st_uid = req_in->statbuf.st_uid;\n+  stat_out->st_gid = req_in->statbuf.st_gid;\n+  stat_out->st_rdev = req_in->statbuf.st_rdev;\n+  stat_out->st_ino = req_in->statbuf.st_ino;\n+  stat_out->st_size = req_in->statbuf.st_size;\n+  stat_out->st_blksize = req_in->statbuf.st_blksize;\n+  stat_out->st_blocks = req_in->statbuf.st_blocks;\n+  stat_out->st_flags = req_in->statbuf.st_flags;\n+  stat_out->st_gen = req_in->statbuf.st_gen;\n+  stat_out->st_atim.tv_sec = req_in->statbuf.st_atim.tv_sec;\n+  stat_out->st_atim.tv_nsec = req_in->statbuf.st_atim.tv_nsec;\n+  stat_out->st_mtim.tv_sec = req_in->statbuf.st_mtim.tv_sec;\n+  stat_out->st_mtim.tv_nsec = req_in->statbuf.st_mtim.tv_nsec;\n+  stat_out->st_ctim.tv_sec = req_in->statbuf.st_ctim.tv_sec;\n+  stat_out->st_ctim.tv_nsec = req_in->statbuf.st_ctim.tv_nsec;\n+  stat_out->st_birthtim.tv_sec = req_in->statbuf.st_birthtim.tv_sec;\n+  stat_out->st_birthtim.tv_nsec = req_in->statbuf.st_birthtim.tv_nsec;\n+}\n+\n+extern \"C\" int\n+rust_uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {\n+  return uv_fs_mkdir(loop, req, path, mode, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  return uv_fs_rmdir(loop, req, path, cb);\n+}"}, {"sha": "d6b0d7c7a9dee644ee08cb506d187f2a268f4ddd", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/af650572e0fceb94b387db50ee31f19ee000fe4b/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=af650572e0fceb94b387db50ee31f19ee000fe4b", "patch": "@@ -114,7 +114,12 @@ rust_uv_fs_read\n rust_uv_fs_close\n rust_uv_get_result_from_fs_req\n rust_uv_get_loop_from_fs_req\n+rust_uv_fs_stat\n+rust_uv_fs_fstat\n rust_uv_fs_req_cleanup\n+rust_uv_populate_uv_stat\n+rust_uv_fs_mkdir\n+rust_uv_fs_rmdir\n rust_dbg_lock_create\n rust_dbg_lock_destroy\n rust_dbg_lock_lock"}]}