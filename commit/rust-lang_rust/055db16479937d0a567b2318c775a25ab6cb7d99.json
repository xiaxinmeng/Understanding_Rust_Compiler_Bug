{"sha": "055db16479937d0a567b2318c775a25ab6cb7d99", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NWRiMTY0Nzk5MzdkMGE1NjdiMjMxOGM3NzVhMjVhYjZjYjdkOTk=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-01-13T18:39:25Z"}, "committer": {"name": "Ryan Levick", "email": "me@ryanlevick.com", "date": "2021-03-03T10:22:57Z"}, "message": "Clean up code rightward drift", "tree": {"sha": "1be7a15887c082d4dc6666174fbacc81082d7154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1be7a15887c082d4dc6666174fbacc81082d7154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/055db16479937d0a567b2318c775a25ab6cb7d99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/055db16479937d0a567b2318c775a25ab6cb7d99", "html_url": "https://github.com/rust-lang/rust/commit/055db16479937d0a567b2318c775a25ab6cb7d99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/055db16479937d0a567b2318c775a25ab6cb7d99/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e48670c34a3f5ab3fe9defcc61861999f3f14e93", "url": "https://api.github.com/repos/rust-lang/rust/commits/e48670c34a3f5ab3fe9defcc61861999f3f14e93", "html_url": "https://github.com/rust-lang/rust/commit/e48670c34a3f5ab3fe9defcc61861999f3f14e93"}], "stats": {"total": 144, "additions": 79, "deletions": 65}, "files": [{"sha": "b4ee1f9157c82595a4bde2f97c5cd1f6dccf00fe", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 79, "deletions": 65, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/055db16479937d0a567b2318c775a25ab6cb7d99/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055db16479937d0a567b2318c775a25ab6cb7d99/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=055db16479937d0a567b2318c775a25ab6cb7d99", "patch": "@@ -38,73 +38,87 @@ declare_lint_pass!(NoopMethodCall => [NOOP_METHOD_CALL]);\n \n impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        // We only care about method calls\n-        if let ExprKind::MethodCall(call, _, elements, _) = expr.kind {\n-            // Get the `DefId` only when dealing with an `AssocFn`\n-            if let Some((DefKind::AssocFn, did)) =\n-                cx.typeck_results().type_dependent_def(expr.hir_id)\n-            {\n-                // Check that we're dealing with a trait method\n-                if let Some(trait_id) = cx.tcx.trait_of_item(did) {\n-                    // Check we're dealing with one of the traits we care about\n-                    if ![sym::Clone, sym::Deref, sym::Borrow]\n+        // We only care about method calls.\n+        let (call, elements) = match expr.kind {\n+            ExprKind::MethodCall(call, _, elements, _) => (call, elements),\n+            _ => return,\n+        };\n+        // We only care about method calls corresponding to the `Clone`, `Deref` and `Borrow`\n+        // traits and ignore any other method call.\n+        let (trait_id, did) = match cx.typeck_results().type_dependent_def(expr.hir_id) {\n+            // Verify we are dealing with a method/associated function.\n+            Some((DefKind::AssocFn, did)) => match cx.tcx.trait_of_item(did) {\n+                // Check that we're dealing with a trait method for one of the traits we care about.\n+                Some(trait_id)\n+                    if [sym::Clone, sym::Deref, sym::Borrow]\n                         .iter()\n-                        .any(|s| cx.tcx.is_diagnostic_item(*s, trait_id))\n-                    {\n-                        return;\n-                    }\n-\n-                    let substs = cx.typeck_results().node_substs(expr.hir_id);\n-                    // We can't resolve on types that require monomorphization,\n-                    // so check that we don't need to perfom substitution\n-                    if !substs.needs_subst() {\n-                        let param_env = cx.tcx.param_env(trait_id);\n-                        // Resolve the trait method instance\n-                        if let Ok(Some(i)) = ty::Instance::resolve(cx.tcx, param_env, did, substs) {\n-                            // Check that it implements the noop diagnostic\n-                            for (s, peel_ref) in [\n-                                (sym::noop_method_borrow, true),\n-                                (sym::noop_method_clone, false),\n-                                (sym::noop_method_deref, true),\n-                            ]\n-                            .iter()\n-                            {\n-                                if cx.tcx.is_diagnostic_item(*s, i.def_id()) {\n-                                    let method = &call.ident.name;\n-                                    let receiver = &elements[0];\n-                                    let receiver_ty = cx.typeck_results().expr_ty(receiver);\n-                                    let receiver_ty = match receiver_ty.kind() {\n-                                        // Remove one borrow from the receiver as all the trait methods\n-                                        // we care about here have a `&self` receiver.\n-                                        ty::Ref(_, ty, _) if *peel_ref => ty,\n-                                        _ => receiver_ty,\n-                                    };\n-                                    let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n-                                    if receiver_ty != expr_ty {\n-                                        return;\n-                                    }\n-                                    let expr_span = expr.span;\n-                                    let note = format!(\n-                                        \"the type `{:?}` which `{}` is being called on is the same as \\\n-                                        the type returned from `{}`, so the method call does not do \\\n-                                        anything and can be removed\",\n-                                        receiver_ty, method, method,\n-                                    );\n-\n-                                    let span = expr_span.with_lo(receiver.span.hi());\n-                                    cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n-                                        let method = &call.ident.name;\n-                                        let message = format!(\"call to `.{}()` on a reference in this situation does nothing\", &method);\n-                                        lint.build(&message)\n-                                            .span_label(span, \"unnecessary method call\")\n-                                            .note(&note)\n-                                            .emit()\n-                                     });\n-                                }\n-                            }\n-                        }\n-                    }\n+                        .any(|s| cx.tcx.is_diagnostic_item(*s, trait_id)) =>\n+                {\n+                    (trait_id, did)\n                 }\n+                _ => return,\n+            },\n+            _ => return,\n+        };\n+        let substs = cx.typeck_results().node_substs(expr.hir_id);\n+        if substs.needs_subst() {\n+            // We can't resolve on types that require monomorphization, so we don't handle them if\n+            // we need to perfom substitution.\n+            return;\n+        }\n+        let param_env = cx.tcx.param_env(trait_id);\n+        // Resolve the trait method instance.\n+        let i = match ty::Instance::resolve(cx.tcx, param_env, did, substs) {\n+            Ok(Some(i)) => i,\n+            _ => return,\n+        };\n+        // (Re)check that it implements the noop diagnostic.\n+        for (s, peel_ref) in [\n+            (sym::noop_method_borrow, true),\n+            (sym::noop_method_clone, false),\n+            (sym::noop_method_deref, true),\n+        ]\n+        .iter()\n+        {\n+            if cx.tcx.is_diagnostic_item(*s, i.def_id()) {\n+                let method = &call.ident.name;\n+                let receiver = &elements[0];\n+                let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+                let receiver_ty = match receiver_ty.kind() {\n+                    // Remove one borrow from the receiver if appropriate to positively verify that\n+                    // the receiver `&self` type and the return type are the same, depending on the\n+                    // involved trait being checked.\n+                    ty::Ref(_, ty, _) if *peel_ref => ty,\n+                    // When it comes to `Clone` we need to check the `receiver_ty` directly.\n+                    // FIXME: we must come up with a better strategy for this.\n+                    _ => receiver_ty,\n+                };\n+                let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n+                if receiver_ty != expr_ty {\n+                    // This lint will only trigger if the receiver type and resulting expression \\\n+                    // type are the same, implying that the method call is unnecessary.\n+                    return;\n+                }\n+                let expr_span = expr.span;\n+                let note = format!(\n+                    \"the type `{:?}` which `{}` is being called on is the same as \\\n+                     the type returned from `{}`, so the method call does not do \\\n+                     anything and can be removed\",\n+                    receiver_ty, method, method,\n+                );\n+\n+                let span = expr_span.with_lo(receiver.span.hi());\n+                cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n+                    let method = &call.ident.name;\n+                    let message = format!(\n+                        \"call to `.{}()` on a reference in this situation does nothing\",\n+                        &method,\n+                    );\n+                    lint.build(&message)\n+                        .span_label(span, \"unnecessary method call\")\n+                        .note(&note)\n+                        .emit()\n+                });\n             }\n         }\n     }"}]}