{"sha": "d00d42d079236893f0a8b2cd726c6957d96ec296", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMGQ0MmQwNzkyMzY4OTNmMGE4YjJjZDcyNmM2OTU3ZDk2ZWMyOTY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-03T20:57:53Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-04T18:33:57Z"}, "message": "rustc_target: pass contexts by reference, not value.", "tree": {"sha": "2f239aed2009e385798d2d85117132c058244c71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f239aed2009e385798d2d85117132c058244c71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d00d42d079236893f0a8b2cd726c6957d96ec296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d00d42d079236893f0a8b2cd726c6957d96ec296", "html_url": "https://github.com/rust-lang/rust/commit/d00d42d079236893f0a8b2cd726c6957d96ec296", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d00d42d079236893f0a8b2cd726c6957d96ec296/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca4fa6f567b5d8a01f7db864539a43457119a45c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4fa6f567b5d8a01f7db864539a43457119a45c", "html_url": "https://github.com/rust-lang/rust/commit/ca4fa6f567b5d8a01f7db864539a43457119a45c"}], "stats": {"total": 389, "additions": 175, "deletions": 214}, "files": [{"sha": "5470aff77f8a43abac0cca195716e28665c3e246", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -783,11 +783,11 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf for &'a LateContext<'a, 'tcx> {\n+impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n }"}, {"sha": "0a5b1e184deec4ff98f7ecbd8210cd3643f3cac7", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n             // `Option<typeof(function)>` to present a clearer error.\n             let from = unpack_option_like(self.tcx.global_tcx(), from);\n             if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (&from.sty, sk_to) {\n-                if size_to == Pointer.size(self.tcx) {\n+                if size_to == Pointer.size(&self.tcx) {\n                     struct_span_err!(self.tcx.sess, span, E0591,\n                                      \"can't transmute zero-sized type\")\n                         .note(&format!(\"source type: {}\", from))"}, {"sha": "f8a5dbc6905ca9be31429b042d183fe26926a95e", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -86,18 +86,18 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     // These are not supposed to be overridden.\n \n     #[inline(always)]\n-    fn pointer_size(self) -> Size {\n+    fn pointer_size(&self) -> Size {\n         self.data_layout().pointer_size\n     }\n \n     //// Trunace the given value to the pointer size; also return whether there was an overflow\n-    fn truncate_to_ptr(self, val: u128) -> (u64, bool) {\n+    fn truncate_to_ptr(&self, val: u128) -> (u64, bool) {\n         let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n         ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n     }\n \n     // Overflow checking only works properly on the range from -u64 to +u64.\n-    fn overflowing_signed_offset(self, val: u64, i: i128) -> (u64, bool) {\n+    fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n         // FIXME: is it possible to over/underflow here?\n         if i < 0 {\n             // trickery to ensure that i64::min_value() works fine\n@@ -109,23 +109,23 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n         }\n     }\n \n-    fn overflowing_offset(self, val: u64, i: u64) -> (u64, bool) {\n+    fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n         let (res, over1) = val.overflowing_add(i);\n         let (res, over2) = self.truncate_to_ptr(res as u128);\n         (res, over1 || over2)\n     }\n \n-    fn signed_offset<'tcx>(self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n+    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i as i128);\n         if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n-    fn offset<'tcx>(self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n         if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n-    fn wrapping_signed_offset(self, val: u64, i: i64) -> u64 {\n+    fn wrapping_signed_offset(&self, val: u64, i: i64) -> u64 {\n         self.overflowing_signed_offset(val, i as i128).0\n     }\n }\n@@ -176,33 +176,33 @@ impl<'tcx, Tag> Pointer<Tag> {\n         Pointer { alloc_id, offset, tag }\n     }\n \n-    pub fn wrapping_signed_offset(self, i: i64, cx: impl HasDataLayout) -> Self {\n+    pub fn wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n         Pointer::new_with_tag(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().wrapping_signed_offset(self.offset.bytes(), i)),\n             self.tag,\n         )\n     }\n \n-    pub fn overflowing_signed_offset(self, i: i128, cx: impl HasDataLayout) -> (Self, bool) {\n+    pub fn overflowing_signed_offset(self, i: i128, cx: &impl HasDataLayout) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n         (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n     }\n \n-    pub fn signed_offset(self, i: i64, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+    pub fn signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new_with_tag(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n             self.tag,\n         ))\n     }\n \n-    pub fn overflowing_offset(self, i: Size, cx: impl HasDataLayout) -> (Self, bool) {\n+    pub fn overflowing_offset(self, i: Size, cx: &impl HasDataLayout) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n         (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n     }\n \n-    pub fn offset(self, i: Size, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+    pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new_with_tag(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),"}, {"sha": "3b8e19c6ecaa9b4c1c7b272da17ddc95a1757a5f", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -65,7 +65,7 @@ impl<'tcx> ConstValue<'tcx> {\n     pub fn new_slice(\n         val: Scalar,\n         len: u64,\n-        cx: impl HasDataLayout\n+        cx: &impl HasDataLayout\n     ) -> Self {\n         ConstValue::ScalarPair(val, Scalar::Bits {\n             bits: len as u128,\n@@ -121,7 +121,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn ptr_null(cx: impl HasDataLayout) -> Self {\n+    pub fn ptr_null(cx: &impl HasDataLayout) -> Self {\n         Scalar::Bits {\n             bits: 0,\n             size: cx.data_layout().pointer_size.bytes() as u8,\n@@ -134,52 +134,52 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn ptr_signed_offset(self, i: i64, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n-        let layout = cx.data_layout();\n+    pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+        let dl = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, layout.pointer_size.bytes());\n+                assert_eq!(size as u64, dl.pointer_size.bytes());\n                 Ok(Scalar::Bits {\n-                    bits: layout.signed_offset(bits as u64, i)? as u128,\n+                    bits: dl.signed_offset(bits as u64, i)? as u128,\n                     size,\n                 })\n             }\n-            Scalar::Ptr(ptr) => ptr.signed_offset(i, layout).map(Scalar::Ptr),\n+            Scalar::Ptr(ptr) => ptr.signed_offset(i, dl).map(Scalar::Ptr),\n         }\n     }\n \n     #[inline]\n-    pub fn ptr_offset(self, i: Size, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n-        let layout = cx.data_layout();\n+    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+        let dl = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, layout.pointer_size.bytes());\n+                assert_eq!(size as u64, dl.pointer_size.bytes());\n                 Ok(Scalar::Bits {\n-                    bits: layout.offset(bits as u64, i.bytes())? as u128,\n+                    bits: dl.offset(bits as u64, i.bytes())? as u128,\n                     size,\n                 })\n             }\n-            Scalar::Ptr(ptr) => ptr.offset(i, layout).map(Scalar::Ptr),\n+            Scalar::Ptr(ptr) => ptr.offset(i, dl).map(Scalar::Ptr),\n         }\n     }\n \n     #[inline]\n-    pub fn ptr_wrapping_signed_offset(self, i: i64, cx: impl HasDataLayout) -> Self {\n-        let layout = cx.data_layout();\n+    pub fn ptr_wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n+        let dl = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, layout.pointer_size.bytes());\n+                assert_eq!(size as u64, dl.pointer_size.bytes());\n                 Scalar::Bits {\n-                    bits: layout.wrapping_signed_offset(bits as u64, i) as u128,\n+                    bits: dl.wrapping_signed_offset(bits as u64, i) as u128,\n                     size,\n                 }\n             }\n-            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_signed_offset(i, layout)),\n+            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_signed_offset(i, dl)),\n         }\n     }\n \n     #[inline]\n-    pub fn is_null_ptr(self, cx: impl HasDataLayout) -> bool {\n+    pub fn is_null_ptr(self, cx: &impl HasDataLayout) -> bool {\n         match self {\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, cx.data_layout().pointer_size.bytes());\n@@ -301,7 +301,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Ok(b as u64)\n     }\n \n-    pub fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'static, u64> {\n+    pub fn to_usize(self, cx: &impl HasDataLayout) -> EvalResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         assert_eq!(b as u64 as u128, b);\n         Ok(b as u64)\n@@ -331,7 +331,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Ok(b as i64)\n     }\n \n-    pub fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'static, i64> {\n+    pub fn to_isize(self, cx: &impl HasDataLayout) -> EvalResult<'static, i64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         let b = sign_extend(b, cx.data_layout().pointer_size) as i128;\n         assert_eq!(b as i64 as i128, b);"}, {"sha": "fbada789956be660c0e10ae04b213cc81993e45d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -428,7 +428,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ));\n                 let tcx = self.tcx;\n                 if let Some(len) = len.val.try_to_scalar().and_then(|scalar| {\n-                    scalar.to_usize(tcx).ok()\n+                    scalar.to_usize(&tcx).ok()\n                 }) {\n                     flags.push((\n                         \"_Self\".to_owned(),"}, {"sha": "5aeba652f3228e9988abd367b72adc80440eb691", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -30,7 +30,7 @@ pub use rustc_target::abi::*;\n \n pub trait IntegerExt {\n     fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n-    fn from_attr<C: HasDataLayout>(cx: C, ity: attr::IntType) -> Integer;\n+    fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer;\n     fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             ty: Ty<'tcx>,\n                             repr: &ReprOptions,\n@@ -56,7 +56,7 @@ impl IntegerExt for Integer {\n     }\n \n     /// Get the Integer type from an attr::IntType.\n-    fn from_attr<C: HasDataLayout>(cx: C, ity: attr::IntType) -> Integer {\n+    fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer {\n         let dl = cx.data_layout();\n \n         match ity {\n@@ -92,7 +92,7 @@ impl IntegerExt for Integer {\n         let min_default = I8;\n \n         if let Some(ity) = repr.int {\n-            let discr = Integer::from_attr(tcx, ity);\n+            let discr = Integer::from_attr(&tcx, ity);\n             let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n             if discr < fit {\n                 bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n@@ -202,14 +202,13 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n }\n \n-#[derive(Copy, Clone)]\n pub struct LayoutCx<'tcx, C> {\n     pub tcx: C,\n     pub param_env: ty::ParamEnv<'tcx>\n }\n \n impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n-    fn layout_raw_uncached(self, ty: Ty<'tcx>)\n+    fn layout_raw_uncached(&self, ty: Ty<'tcx>)\n                            -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n         let tcx = self.tcx;\n         let param_env = self.param_env;\n@@ -899,7 +898,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                 let (mut min, mut max) = (i128::max_value(), i128::min_value());\n                 let discr_type = def.repr.discr_type();\n-                let bits = Integer::from_attr(tcx, discr_type).size().bits();\n+                let bits = Integer::from_attr(self, discr_type).size().bits();\n                 for (i, discr) in def.discriminants(tcx).enumerate() {\n                     if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n                         continue;\n@@ -1141,7 +1140,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n     #[inline]\n-    fn record_layout_for_printing(self, layout: TyLayout<'tcx>) {\n+    fn record_layout_for_printing(&self, layout: TyLayout<'tcx>) {\n         // If we are running with `-Zprint-type-sizes`, record layouts for\n         // dumping later. Ignore layouts that are done with non-empty\n         // environments or non-monomorphic layouts, as the user only wants\n@@ -1158,7 +1157,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         self.record_layout_for_printing_outlined(layout)\n     }\n \n-    fn record_layout_for_printing_outlined(self, layout: TyLayout<'tcx>) {\n+    fn record_layout_for_printing_outlined(&self, layout: TyLayout<'tcx>) {\n         // (delay format until we actually need it)\n         let record = |kind, packed, opt_discr_size, variants| {\n             let type_desc = format!(\"{:?}\", layout.ty);\n@@ -1478,7 +1477,7 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n         let param_env = self.param_env.with_reveal_all();\n         let ty = self.tcx.normalize_erasing_regions(param_env, ty);\n         let details = self.tcx.layout_raw(param_env.and(ty))?;\n@@ -1505,7 +1504,7 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'a, 'tcx, 'tcx>>\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n         let param_env = self.param_env.with_reveal_all();\n         let ty = self.tcx.normalize_erasing_regions(param_env, ty);\n         let details = self.tcx.layout_raw(param_env.and(ty))?;\n@@ -1563,7 +1562,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n     where C: LayoutOf<Ty = Ty<'tcx>> + HasTyCtxt<'tcx>,\n           C::TyLayout: MaybeResult<TyLayout<'tcx>>\n {\n-    fn for_variant(this: TyLayout<'tcx>, cx: C, variant_index: usize) -> TyLayout<'tcx> {\n+    fn for_variant(this: TyLayout<'tcx>, cx: &C, variant_index: usize) -> TyLayout<'tcx> {\n         let details = match this.variants {\n             Variants::Single { index } if index == variant_index => this.details,\n \n@@ -1602,7 +1601,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n         }\n     }\n \n-    fn field(this: TyLayout<'tcx>, cx: C, i: usize) -> C::TyLayout {\n+    fn field(this: TyLayout<'tcx>, cx: &C, i: usize) -> C::TyLayout {\n         let tcx = cx.tcx();\n         cx.layout_of(match this.ty.sty {\n             ty::Bool |\n@@ -1699,7 +1698,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                     Variants::Tagged { tag: ref discr, .. } |\n                     Variants::NicheFilling { niche: ref discr, .. } => {\n                         assert_eq!(i, 0);\n-                        let layout = LayoutDetails::scalar(tcx, discr.clone());\n+                        let layout = LayoutDetails::scalar(cx, discr.clone());\n                         return MaybeResult::from_ok(TyLayout {\n                             details: tcx.intern_layout(layout),\n                             ty: discr.value.to_ty(tcx)\n@@ -1725,7 +1724,7 @@ struct Niche {\n impl Niche {\n     fn reserve<'a, 'tcx>(\n         &self,\n-        cx: LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>>,\n+        cx: &LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>>,\n         count: u128,\n     ) -> Option<(u128, Scalar)> {\n         if count > self.available {\n@@ -1745,7 +1744,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     /// Find the offset of a niche leaf field, starting from\n     /// the given type and recursing through aggregates.\n     // FIXME(eddyb) traverse already optimized enums.\n-    fn find_niche(self, layout: TyLayout<'tcx>) -> Result<Option<Niche>, LayoutError<'tcx>> {\n+    fn find_niche(&self, layout: TyLayout<'tcx>) -> Result<Option<Niche>, LayoutError<'tcx>> {\n         let scalar_niche = |scalar: &Scalar, offset| {\n             let Scalar { value, valid_range: ref v } = *scalar;\n "}, {"sha": "3d0c54d6b0a5b44f5165c4ce7ff9c8e9d9b35097", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n         match self.ty.sty {\n             ty::Int(ity) => {\n                 let bits = ty::tls::with(|tcx| {\n-                    Integer::from_attr(tcx, SignedInt(ity)).size().bits()\n+                    Integer::from_attr(&tcx, SignedInt(ity)).size().bits()\n                 });\n                 let x = self.val as i128;\n                 // sign extend the raw representation to be an i128\n@@ -62,8 +62,8 @@ impl<'tcx> Discr<'tcx> {\n     }\n     pub fn checked_add<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, n: u128) -> (Self, bool) {\n         let (int, signed) = match self.ty.sty {\n-            Int(ity) => (Integer::from_attr(tcx, SignedInt(ity)), true),\n-            Uint(uty) => (Integer::from_attr(tcx, UnsignedInt(uty)), false),\n+            Int(ity) => (Integer::from_attr(&tcx, SignedInt(ity)), true),\n+            Uint(uty) => (Integer::from_attr(&tcx, UnsignedInt(uty)), false),\n             _ => bug!(\"non integer discriminant\"),\n         };\n "}, {"sha": "120449ae2af4c2518294656eaac3aa6fb68370d5", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -446,29 +446,29 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n     }\n }\n \n-impl ty::layout::HasDataLayout for &'a CodegenCx<'ll, 'tcx> {\n+impl ty::layout::HasDataLayout for CodegenCx<'ll, 'tcx> {\n     fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl HasTargetSpec for &'a CodegenCx<'ll, 'tcx> {\n+impl HasTargetSpec for CodegenCx<'ll, 'tcx> {\n     fn target_spec(&self) -> &Target {\n         &self.tcx.sess.target.target\n     }\n }\n \n-impl ty::layout::HasTyCtxt<'tcx> for &'a CodegenCx<'ll, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+impl ty::layout::HasTyCtxt<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }\n }\n \n-impl LayoutOf for &'a CodegenCx<'ll, 'tcx> {\n+impl LayoutOf for CodegenCx<'ll, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = TyLayout<'tcx>;\n \n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty))\n             .unwrap_or_else(|e| if let LayoutError::SizeOverflow(_) = e {\n                 self.sess().fatal(&e.to_string())"}, {"sha": "586a490774023f9f000a68b8c63da9eb2b4636c1", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -87,8 +87,8 @@ pub fn scalar_to_llvm(\n \n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n     let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n-    let layout = cx.data_layout();\n-    let pointer_size = layout.pointer_size.bytes() as usize;\n+    let dl = cx.data_layout();\n+    let pointer_size = dl.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n     for &(offset, ((), alloc_id)) in alloc.relocations.iter() {\n@@ -99,7 +99,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n             llvals.push(C_bytes(cx, &alloc.bytes[next_offset..offset]));\n         }\n         let ptr_offset = read_target_uint(\n-            layout.endian,\n+            dl.endian,\n             &alloc.bytes[offset..(offset + pointer_size)],\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n         llvals.push(scalar_to_llvm("}, {"sha": "0b788a8fd97630523487e41bc6a172a52500169d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -377,13 +377,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             let (t, actually) = match ty {\n                 ty::Int(t) => {\n                     let ity = attr::IntType::SignedInt(t);\n-                    let bits = layout::Integer::from_attr(cx.tcx, ity).size().bits();\n+                    let bits = layout::Integer::from_attr(&cx.tcx, ity).size().bits();\n                     let actually = (val << (128 - bits)) as i128 >> (128 - bits);\n                     (format!(\"{:?}\", t), actually.to_string())\n                 }\n                 ty::Uint(t) => {\n                     let ity = attr::IntType::UnsignedInt(t);\n-                    let bits = layout::Integer::from_attr(cx.tcx, ity).size().bits();\n+                    let bits = layout::Integer::from_attr(&cx.tcx, ity).size().bits();\n                     let actually = (val << (128 - bits)) >> (128 - bits);\n                     (format!(\"{:?}\", t), actually.to_string())\n                 }\n@@ -829,7 +829,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 Ok(layout) => {\n                     let variants = &layout.variants;\n                     if let layout::Variants::Tagged { ref variants, ref tag, .. } = variants {\n-                        let discr_size = tag.value.size(cx.tcx).bytes();\n+                        let discr_size = tag.value.size(&cx.tcx).bytes();\n \n                         debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n                                t, layout.size.bytes(), layout);"}, {"sha": "3a56d261111eee4ec0e46de7883944dc5358fde3", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             LitKind::Str(ref s, _) => {\n                 let s = s.as_str();\n                 let id = self.tcx.allocate_bytes(s.as_bytes());\n-                ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, self.tcx)\n+                ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, &self.tcx)\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);"}, {"sha": "69ca21c56242f954a76cca7bd849d21f593bd41c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -669,14 +669,14 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         }\n         ty::Int(ity) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n-            let bits = Integer::from_attr(cx.tcx, SignedInt(ity)).size().bits() as u128;\n+            let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = (1u128 << (bits - 1)) - 1;\n             vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included)]\n         }\n         ty::Uint(uty) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n-            let bits = Integer::from_attr(cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n+            let bits = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n             let max = !0u128 >> (128 - bits);\n             vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included)]\n         }\n@@ -862,7 +862,7 @@ impl<'tcx> IntRange<'tcx> {\n     fn signed_bias(tcx: TyCtxt<'_, 'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n         match ty.sty {\n             ty::Int(ity) => {\n-                let bits = Integer::from_attr(tcx, SignedInt(ity)).size().bits() as u128;\n+                let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n                 1u128 << (bits - 1)\n             }\n             _ => 0"}, {"sha": "0e1f8d1d32816ace04d2eb9e3189d9d4bfd49af9", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -1313,7 +1313,7 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n             let id = tcx.allocate_bytes(s.as_bytes());\n-            ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, tcx)\n+            ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, &tcx)\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);"}, {"sha": "06748d60e45837233da8c75aaf4760f905b7ab83", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let val = Immediate::new_slice(\n                     ptr,\n                     length.unwrap_usize(self.tcx.tcx),\n-                    self.tcx.tcx,\n+                    self,\n                 );\n                 self.write_immediate(val, dest)\n             }\n@@ -394,7 +394,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             src_field.into()\n                         }\n                         Err(..) => {\n-                            let src_field_layout = src.layout.field(&self, i)?;\n+                            let src_field_layout = src.layout.field(self, i)?;\n                             // this must be a field covering the entire thing\n                             assert_eq!(src.layout.fields.offset(i).bytes(), 0);\n                             assert_eq!(src_field_layout.size, src.layout.size);"}, {"sha": "fc13c5fef2dda2a599fd5b5835348a0aacd91cb7", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 37, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -139,25 +139,16 @@ impl<'tcx, Tag> LocalValue<Tag> {\n     }\n }\n \n-impl<'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n-    for &'b EvalContext<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n+    for EvalContext<'a, 'mir, 'tcx, M>\n {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n-    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n-{\n-    #[inline]\n-    fn data_layout(&self) -> &layout::TargetDataLayout {\n-        &self.tcx.data_layout\n-    }\n-}\n-\n-impl<'b, 'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for &'b EvalContext<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for EvalContext<'a, 'mir, 'tcx, M>\n     where M: Machine<'a, 'mir, 'tcx>\n {\n     #[inline]\n@@ -166,40 +157,19 @@ impl<'b, 'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for &'b EvalContext<'a, 'mir\n     }\n }\n \n-impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> layout::HasTyCtxt<'tcx>\n-    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n-{\n-    #[inline]\n-    fn tcx<'d>(&'d self) -> TyCtxt<'d, 'tcx, 'tcx> {\n-        *self.tcx\n-    }\n-}\n-\n-impl<'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n-    for &'b EvalContext<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n+    for EvalContext<'a, 'mir, 'tcx, M>\n {\n     type Ty = Ty<'tcx>;\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n     #[inline]\n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n             .map_err(|layout| EvalErrorKind::Layout(layout).into())\n     }\n }\n \n-impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n-    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n-{\n-    type Ty = Ty<'tcx>;\n-    type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n-\n-    #[inline]\n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        (&**self).layout_of(ty)\n-    }\n-}\n-\n impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n@@ -335,7 +305,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n \n     pub fn str_to_immediate(&mut self, s: &str) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n         let ptr = self.memory.allocate_static_bytes(s.as_bytes()).with_default_tag();\n-        Ok(Immediate::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n+        Ok(Immediate::new_slice(Scalar::Ptr(ptr), s.len() as u64, self))\n     }\n \n     /// Return the actual dynamic size and alignment of the place at the given type."}, {"sha": "a0231f3feb13a409f04bf9d9c2d4d0e59fb7c639", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -77,16 +77,8 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     pub(super) tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n-    for &'b Memory<'a, 'mir, 'tcx, M>\n-{\n-    #[inline]\n-    fn data_layout(&self) -> &TargetDataLayout {\n-        &self.tcx.data_layout\n-    }\n-}\n-impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n-    for &'b &'c mut Memory<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n+    for Memory<'a, 'mir, 'tcx, M>\n {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {"}, {"sha": "6f66dd1e70a55bc0b53d75a5473fe38b0739ea3f", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -112,7 +112,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     }\n \n     #[inline(always)]\n-    pub fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'tcx, u64> {\n+    pub fn to_usize(self, cx: &impl HasDataLayout) -> EvalResult<'tcx, u64> {\n         self.not_undef()?.to_usize(cx)\n     }\n \n@@ -132,7 +132,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     }\n \n     #[inline(always)]\n-    pub fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'tcx, i64> {\n+    pub fn to_isize(self, cx: &impl HasDataLayout) -> EvalResult<'tcx, i64> {\n         self.not_undef()?.to_isize(cx)\n     }\n }\n@@ -178,7 +178,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n     pub fn new_slice(\n         val: Scalar<Tag>,\n         len: u64,\n-        cx: impl HasDataLayout\n+        cx: &impl HasDataLayout\n     ) -> Self {\n         Immediate::ScalarPair(\n             val.into(),\n@@ -743,7 +743,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         .ty_adt_def().expect(\"tagged layout corresponds to adt\")\n                         .repr\n                         .discr_type();\n-                    let discr_ty = layout::Integer::from_attr(self.tcx.tcx, discr_ty);\n+                    let discr_ty = layout::Integer::from_attr(self, discr_ty);\n                     let shift = 128 - discr_ty.size().bits();\n                     let truncatee = sexted as u128;\n                     (truncatee << shift) >> shift"}, {"sha": "fa4d31846df4a3de276c2fa8799a248c5c09e316", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -128,7 +128,7 @@ impl<Tag> MemPlace<Tag> {\n \n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline(always)]\n-    pub fn null(cx: impl HasDataLayout) -> Self {\n+    pub fn null(cx: &impl HasDataLayout) -> Self {\n         Self::from_scalar_ptr(Scalar::ptr_null(cx), Align::from_bytes(1, 1).unwrap())\n     }\n \n@@ -156,7 +156,7 @@ impl<Tag> MemPlace<Tag> {\n impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n-    pub fn dangling(layout: TyLayout<'tcx>, cx: impl HasDataLayout) -> Self {\n+    pub fn dangling(layout: TyLayout<'tcx>, cx: &impl HasDataLayout) -> Self {\n         MPlaceTy {\n             mplace: MemPlace::from_scalar_ptr(\n                 Scalar::from_uint(layout.align.abi(), cx.pointer_size()),\n@@ -172,7 +172,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn len(self, cx: impl HasDataLayout) -> EvalResult<'tcx, u64> {\n+    pub(super) fn len(self, cx: &impl HasDataLayout) -> EvalResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.sty {\n@@ -217,7 +217,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> OpTy<'tcx, Tag> {\n impl<'tcx, Tag: ::std::fmt::Debug> Place<Tag> {\n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline(always)]\n-    pub fn null(cx: impl HasDataLayout) -> Self {\n+    pub fn null(cx: &impl HasDataLayout) -> Self {\n         Place::Ptr(MemPlace::null(cx))\n     }\n \n@@ -510,7 +510,7 @@ where\n             Place::Ptr(mplace) =>\n                 self.mplace_downcast(MPlaceTy { mplace, layout: base.layout }, variant)?.into(),\n             Place::Local { .. } => {\n-                let layout = base.layout.for_variant(&self, variant);\n+                let layout = base.layout.for_variant(self, variant);\n                 PlaceTy { layout, ..base }\n             }\n         })\n@@ -738,10 +738,10 @@ where\n                     _ => bug!(\"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n                               dest.layout)\n                 };\n-                let (a_size, b_size) = (a.size(&self), b.size(&self));\n-                let (a_align, b_align) = (a.align(&self), b.align(&self));\n+                let (a_size, b_size) = (a.size(self), b.size(self));\n+                let (a_align, b_align) = (a.align(self), b.align(self));\n                 let b_offset = a_size.abi_align(b_align);\n-                let b_ptr = ptr.offset(b_offset, &self)?.into();\n+                let b_ptr = ptr.offset(b_offset, self)?.into();\n \n                 // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n                 // but that does not work: We could be a newtype around a pair, then the\n@@ -896,7 +896,7 @@ where\n         if layout.is_unsized() {\n             assert!(self.tcx.features().unsized_locals, \"cannot alloc memory for unsized type\");\n             // FIXME: What should we do here? We should definitely also tag!\n-            Ok(MPlaceTy::dangling(layout, &self))\n+            Ok(MPlaceTy::dangling(layout, self))\n         } else {\n             let ptr = self.memory.allocate(layout.size, layout.align, kind)?;\n             let ptr = M::tag_new_allocation(self, ptr, kind)?;\n@@ -923,7 +923,7 @@ where\n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n-                let size = tag.value.size(self.tcx.tcx);\n+                let size = tag.value.size(self);\n                 let shift = 128 - size.bits();\n                 let discr_val = (discr_val << shift) >> shift;\n "}, {"sha": "db055204c0a1986600a83cc1a42b4b0f296d1bc4", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             Repeat(ref operand, _) => {\n                 let op = self.eval_operand(operand, None)?;\n                 let dest = self.force_allocation(dest)?;\n-                let length = dest.len(&self)?;\n+                let length = dest.len(self)?;\n \n                 if length > 0 {\n                     // write the first\n@@ -227,7 +227,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     if length > 1 {\n                         // copy the rest\n                         let (dest, dest_align) = first.to_scalar_ptr_align();\n-                        let rest = dest.ptr_offset(first.layout.size, &self)?;\n+                        let rest = dest.ptr_offset(first.layout.size, self)?;\n                         self.memory.copy_repeatedly(\n                             dest, dest_align, rest, dest_align, first.layout.size, length - 1, true\n                         )?;\n@@ -239,7 +239,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_place(place)?;\n                 let mplace = self.force_allocation(src)?;\n-                let len = mplace.len(&self)?;\n+                let len = mplace.len(self)?;\n                 let size = self.pointer_size();\n                 self.write_scalar(\n                     Scalar::from_uint(len, size),"}, {"sha": "b5df625b3028bb33d1a411384003db85d7680280", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -405,7 +405,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 let vtable = ptr.vtable()?;\n                 let fn_ptr = self.memory.read_ptr_sized(\n-                    vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n+                    vtable.offset(ptr_size * (idx as u64 + 3), self)?,\n                     ptr_align\n                 )?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n@@ -416,7 +416,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let mut args = args.to_vec();\n                 let pointee = args[0].layout.ty.builtin_deref(true).unwrap().ty;\n                 let fake_fat_ptr_ty = self.tcx.mk_mut_ptr(pointee);\n-                args[0].layout = self.layout_of(fake_fat_ptr_ty)?.field(&self, 0)?;\n+                args[0].layout = self.layout_of(fake_fat_ptr_ty)?.field(self, 0)?;\n                 args[0].op = Operand::Immediate(Immediate::Scalar(ptr.ptr.into())); // strip vtable\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n@@ -455,7 +455,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         };\n \n         let ty = self.tcx.mk_unit(); // return type is ()\n-        let dest = MPlaceTy::dangling(self.layout_of(ty)?, &self);\n+        let dest = MPlaceTy::dangling(self.layout_of(ty)?, self);\n \n         self.eval_fn_call(\n             instance,"}, {"sha": "c5366a5ce6a4d472fca82937378a7cae20b00c4e", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -60,17 +60,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         let drop = self.memory.create_fn_alloc(drop).with_default_tag();\n         self.memory.write_ptr_sized(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n \n-        let size_ptr = vtable.offset(ptr_size, &self)?;\n+        let size_ptr = vtable.offset(ptr_size, self)?;\n         self.memory.write_ptr_sized(size_ptr, ptr_align, Scalar::from_uint(size, ptr_size).into())?;\n-        let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n+        let align_ptr = vtable.offset(ptr_size * 2, self)?;\n         self.memory.write_ptr_sized(align_ptr, ptr_align,\n             Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n-                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n+                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n                 self.memory.write_ptr_sized(method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n             }\n         }"}, {"sha": "52ef37ab40e57d8ee07f7487a2a312ba6fd79e48", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -87,23 +87,23 @@ struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n     param_env: ParamEnv<'tcx>,\n }\n \n-impl<'a, 'b, 'tcx> LayoutOf for &'a ConstPropagator<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> LayoutOf for ConstPropagator<'a, 'b, 'tcx> {\n     type Ty = ty::Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n-    fn layout_of(self, ty: ty::Ty<'tcx>) -> Self::TyLayout {\n+    fn layout_of(&self, ty: ty::Ty<'tcx>) -> Self::TyLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n }\n \n-impl<'a, 'b, 'tcx> HasDataLayout for &'a ConstPropagator<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> HasDataLayout for ConstPropagator<'a, 'b, 'tcx> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'b, 'tcx> HasTyCtxt<'tcx> for &'a ConstPropagator<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'a, 'b, 'tcx> {\n     #[inline]\n     fn tcx<'c>(&'c self) -> TyCtxt<'c, 'tcx, 'tcx> {\n         self.tcx"}, {"sha": "b4d393749c4869173e689ff7fd5f734e7248b137", "filename": "src/librustc_target/abi/call/aarch64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -11,7 +11,7 @@\n use abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n                                      -> Option<Uniform>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n@@ -41,7 +41,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n     })\n }\n \n-fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>)\n+fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -75,7 +75,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -109,7 +109,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n     arg.make_indirect();\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {"}, {"sha": "85789d7d4d7454d1d4c01c7c5f35629ce2abcb2b", "filename": "src/librustc_target/abi/call/amdgpu.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -11,21 +11,21 @@\n use abi::call::{ArgType, FnType, };\n use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, Ty, C>(_tuncx: C, ret: &mut ArgType<'a, Ty>)\n+fn classify_ret_ty<'a, Ty, C>(_cx: &C, ret: &mut ArgType<'a, Ty>)\n   where Ty: TyLayoutMethods<'a, C> + Copy,\n         C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n   ret.extend_integer_width_to(32);\n }\n \n-fn classify_arg_ty<'a, Ty, C>(_cx: C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg_ty<'a, Ty, C>(_cx: &C, arg: &mut ArgType<'a, Ty>)\n   where Ty: TyLayoutMethods<'a, C> + Copy,\n         C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n   arg.extend_integer_width_to(32);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n   where Ty: TyLayoutMethods<'a, C> + Copy,\n         C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {"}, {"sha": "b4ffae7385aa78b00a4f269a58901319336290d8", "filename": "src/librustc_target/abi/call/arm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -12,7 +12,7 @@ use abi::call::{Conv, FnType, ArgType, Reg, RegKind, Uniform};\n use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n use spec::HasTargetSpec;\n \n-fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n                                      -> Option<Uniform>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n@@ -42,7 +42,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n     })\n }\n \n-fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>, vfp: bool)\n+fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>, vfp: bool)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -77,7 +77,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>, vfp: bool)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>, vfp: bool)\n+fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, vfp: bool)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -101,7 +101,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>, vfp: bool)\n     });\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n {"}, {"sha": "3bd2594bdb97220b801cb9f3d1b22984b79c0f02", "filename": "src/librustc_target/abi/call/asmjs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -16,7 +16,7 @@ use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n // See the https://github.com/kripken/emscripten-fastcomp-clang repository.\n // The class `EmscriptenABIInfo` in `/lib/CodeGen/TargetInfo.cpp` contains the ABI definitions.\n \n-fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>)\n+fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -42,7 +42,7 @@ fn classify_arg_ty<Ty>(arg: &mut ArgType<Ty>) {\n     }\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {"}, {"sha": "a40cb6c76f0cd3fc67b04faf20f56acedae71c6f", "filename": "src/librustc_target/abi/call/mips.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -11,7 +11,7 @@\n use abi::call::{ArgType, FnType, Reg, Uniform};\n use abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size)\n+fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     if !ret.layout.is_aggregate() {\n@@ -22,7 +22,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size)\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n+fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let dl = cx.data_layout();\n@@ -44,7 +44,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let mut offset = Size::ZERO;"}, {"sha": "adf5a3c94ea013267608d1f078216e966811e6c0", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -27,7 +27,7 @@ fn extend_integer_width_mips<Ty>(arg: &mut ArgType<Ty>, bits: u64) {\n     arg.extend_integer_width_to(bits);\n }\n \n-fn float_reg<'a, Ty, C>(cx: C, ret: &ArgType<'a, Ty>, i: usize) -> Option<Reg>\n+fn float_reg<'a, Ty, C>(cx: &C, ret: &ArgType<'a, Ty>, i: usize) -> Option<Reg>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -41,7 +41,7 @@ fn float_reg<'a, Ty, C>(cx: C, ret: &ArgType<'a, Ty>, i: usize) -> Option<Reg>\n     }\n }\n \n-fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>)\n+fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -83,7 +83,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>)\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -151,7 +151,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n     });\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {"}, {"sha": "8f9ef2544e6020fb1d0873aba4f3c56eb6736820", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -137,7 +137,7 @@ impl Reg {\n }\n \n impl Reg {\n-    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+    pub fn align<C: HasDataLayout>(&self, cx: &C) -> Align {\n         let dl = cx.data_layout();\n         match self.kind {\n             RegKind::Integer => {\n@@ -188,7 +188,7 @@ impl From<Reg> for Uniform {\n }\n \n impl Uniform {\n-    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+    pub fn align<C: HasDataLayout>(&self, cx: &C) -> Align {\n         self.unit.align(cx)\n     }\n }\n@@ -225,12 +225,12 @@ impl CastTarget {\n         }\n     }\n \n-    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n+    pub fn size<C: HasDataLayout>(&self, cx: &C) -> Size {\n         (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n              .abi_align(self.rest.align(cx)) + self.rest.total\n     }\n \n-    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+    pub fn align<C: HasDataLayout>(&self, cx: &C) -> Align {\n         self.prefix.iter()\n             .filter_map(|x| x.map(|kind| Reg { kind, size: self.prefix_chunk }.align(cx)))\n             .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),\n@@ -249,8 +249,8 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n         }\n     }\n \n-    fn homogeneous_aggregate<C>(&self, cx: C) -> Option<Reg>\n-        where Ty: TyLayoutMethods<'a, C> + Copy, C: LayoutOf<Ty = Ty, TyLayout = Self> + Copy\n+    fn homogeneous_aggregate<C>(&self, cx: &C) -> Option<Reg>\n+        where Ty: TyLayoutMethods<'a, C> + Copy, C: LayoutOf<Ty = Ty, TyLayout = Self>\n     {\n         match self.abi {\n             Abi::Uninhabited => None,\n@@ -483,7 +483,7 @@ pub struct FnType<'a, Ty> {\n }\n \n impl<'a, Ty> FnType<'a, Ty> {\n-    pub fn adjust_for_cabi<C>(&mut self, cx: C, abi: ::spec::abi::Abi) -> Result<(), String>\n+    pub fn adjust_for_cabi<C>(&mut self, cx: &C, abi: ::spec::abi::Abi) -> Result<(), String>\n         where Ty: TyLayoutMethods<'a, C> + Copy,\n               C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n     {"}, {"sha": "b9b012020b7f4b6914324e49d69c220f4038c0ed", "filename": "src/librustc_target/abi/call/powerpc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -11,7 +11,7 @@\n use abi::call::{ArgType, FnType, Reg, Uniform};\n use abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size)\n+fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     if !ret.layout.is_aggregate() {\n@@ -22,7 +22,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size)\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n+fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let dl = cx.data_layout();\n@@ -44,7 +44,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let mut offset = Size::ZERO;"}, {"sha": "80a4d693dc36bb248f9f17b849ac49eab56272fc", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -22,7 +22,7 @@ enum ABI {\n }\n use self::ABI::*;\n \n-fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n                                        -> Option<Uniform>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n@@ -52,7 +52,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>, abi: AB\n     })\n }\n \n-fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>, abi: ABI)\n+fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>, abi: ABI)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -95,7 +95,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>, abi: ABI)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n+fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -134,7 +134,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n     });\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {"}, {"sha": "d6d8ea719180a20722cfaf405b21fe36ae297bf5", "filename": "src/librustc_target/abi/call/s390x.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -24,7 +24,7 @@ fn classify_ret_ty<'a, Ty, C>(ret: &mut ArgType<Ty>)\n     }\n }\n \n-fn is_single_fp_element<'a, Ty, C>(cx: C, layout: TyLayout<'a, Ty>) -> bool\n+fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyLayout<'a, Ty>) -> bool\n     where Ty: TyLayoutMethods<'a, C>,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -41,7 +41,7 @@ fn is_single_fp_element<'a, Ty, C>(cx: C, layout: TyLayout<'a, Ty>) -> bool\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -67,7 +67,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n     }\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {"}, {"sha": "a40cb6c76f0cd3fc67b04faf20f56acedae71c6f", "filename": "src/librustc_target/abi/call/sparc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -11,7 +11,7 @@\n use abi::call::{ArgType, FnType, Reg, Uniform};\n use abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n \n-fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size)\n+fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     if !ret.layout.is_aggregate() {\n@@ -22,7 +22,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<Ty>, offset: &mut Size)\n     }\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n+fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<Ty>, offset: &mut Size)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let dl = cx.data_layout();\n@@ -44,7 +44,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n     let mut offset = Size::ZERO;"}, {"sha": "a609feb3f57ec8f273b69f7778f2c80e0b23db11", "filename": "src/librustc_target/abi/call/sparc64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -13,7 +13,7 @@\n use abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n \n-fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n+fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n                                      -> Option<Uniform>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n@@ -41,7 +41,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n     })\n }\n \n-fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>)\n+fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -69,7 +69,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: C, ret: &mut ArgType<'a, Ty>)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n+fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -95,7 +95,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n     });\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {"}, {"sha": "9a95e5b192b2135b109a2f446240d440ea5ce2aa", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -18,7 +18,7 @@ pub enum Flavor {\n     Fastcall\n }\n \n-fn is_single_fp_element<'a, Ty, C>(cx: C, layout: TyLayout<'a, Ty>) -> bool\n+fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyLayout<'a, Ty>) -> bool\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n@@ -35,7 +35,7 @@ fn is_single_fp_element<'a, Ty, C>(cx: C, layout: TyLayout<'a, Ty>) -> bool\n     }\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>, flavor: Flavor)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>, flavor: Flavor)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n {"}, {"sha": "4c9446508939e21082bbacb0f310b77ccecfb03a", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -31,12 +31,12 @@ struct Memory;\n const LARGEST_VECTOR_SIZE: usize = 512;\n const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n \n-fn classify_arg<'a, Ty, C>(cx: C, arg: &ArgType<'a, Ty>)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &ArgType<'a, Ty>)\n                           -> Result<[Option<Class>; MAX_EIGHTBYTES], Memory>\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    fn classify<'a, Ty, C>(cx: C, layout: TyLayout<'a, Ty>,\n+    fn classify<'a, Ty, C>(cx: &C, layout: TyLayout<'a, Ty>,\n                           cls: &mut [Option<Class>], off: Size) -> Result<(), Memory>\n         where Ty: TyLayoutMethods<'a, C> + Copy,\n             C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n@@ -178,7 +178,7 @@ fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n     target\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {"}, {"sha": "c7d0469e556a75cf15127c71c153ff21d414d94a", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -203,11 +203,11 @@ impl TargetDataLayout {\n     }\n }\n \n-pub trait HasDataLayout: Copy {\n+pub trait HasDataLayout {\n     fn data_layout(&self) -> &TargetDataLayout;\n }\n \n-impl<'a> HasDataLayout for &'a TargetDataLayout {\n+impl HasDataLayout for TargetDataLayout {\n     fn data_layout(&self) -> &TargetDataLayout {\n         self\n     }\n@@ -267,7 +267,7 @@ impl Size {\n     }\n \n     #[inline]\n-    pub fn checked_add<C: HasDataLayout>(self, offset: Size, cx: C) -> Option<Size> {\n+    pub fn checked_add<C: HasDataLayout>(self, offset: Size, cx: &C) -> Option<Size> {\n         let dl = cx.data_layout();\n \n         let bytes = self.bytes().checked_add(offset.bytes())?;\n@@ -280,7 +280,7 @@ impl Size {\n     }\n \n     #[inline]\n-    pub fn checked_mul<C: HasDataLayout>(self, count: u64, cx: C) -> Option<Size> {\n+    pub fn checked_mul<C: HasDataLayout>(self, count: u64, cx: &C) -> Option<Size> {\n         let dl = cx.data_layout();\n \n         let bytes = self.bytes().checked_mul(count)?;\n@@ -457,7 +457,7 @@ impl Integer {\n         }\n     }\n \n-    pub fn align<C: HasDataLayout>(self, cx: C) -> Align {\n+    pub fn align<C: HasDataLayout>(self, cx: &C) -> Align {\n         let dl = cx.data_layout();\n \n         match self {\n@@ -492,7 +492,7 @@ impl Integer {\n     }\n \n     /// Find the smallest integer with the given alignment.\n-    pub fn for_abi_align<C: HasDataLayout>(cx: C, align: Align) -> Option<Integer> {\n+    pub fn for_abi_align<C: HasDataLayout>(cx: &C, align: Align) -> Option<Integer> {\n         let dl = cx.data_layout();\n \n         let wanted = align.abi();\n@@ -505,7 +505,7 @@ impl Integer {\n     }\n \n     /// Find the largest integer with the given alignment or less.\n-    pub fn approximate_abi_align<C: HasDataLayout>(cx: C, align: Align) -> Integer {\n+    pub fn approximate_abi_align<C: HasDataLayout>(cx: &C, align: Align) -> Integer {\n         let dl = cx.data_layout();\n \n         let wanted = align.abi();\n@@ -571,7 +571,7 @@ pub enum Primitive {\n }\n \n impl<'a, 'tcx> Primitive {\n-    pub fn size<C: HasDataLayout>(self, cx: C) -> Size {\n+    pub fn size<C: HasDataLayout>(self, cx: &C) -> Size {\n         let dl = cx.data_layout();\n \n         match self {\n@@ -582,7 +582,7 @@ impl<'a, 'tcx> Primitive {\n         }\n     }\n \n-    pub fn align<C: HasDataLayout>(self, cx: C) -> Align {\n+    pub fn align<C: HasDataLayout>(self, cx: &C) -> Align {\n         let dl = cx.data_layout();\n \n         match self {\n@@ -642,7 +642,7 @@ impl Scalar {\n     /// Returns the valid range as a `x..y` range.\n     ///\n     /// If `x` and `y` are equal, the range is full, not empty.\n-    pub fn valid_range_exclusive<C: HasDataLayout>(&self, cx: C) -> Range<u128> {\n+    pub fn valid_range_exclusive<C: HasDataLayout>(&self, cx: &C) -> Range<u128> {\n         // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n         // However, that is fine here (it would still represent the full range),\n         // i.e., if the range is everything.\n@@ -854,7 +854,7 @@ pub struct LayoutDetails {\n }\n \n impl LayoutDetails {\n-    pub fn scalar<C: HasDataLayout>(cx: C, scalar: Scalar) -> Self {\n+    pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n         let size = scalar.value.size(cx);\n         let align = scalar.value.align(cx);\n         LayoutDetails {\n@@ -891,20 +891,20 @@ pub trait LayoutOf {\n     type Ty;\n     type TyLayout;\n \n-    fn layout_of(self, ty: Self::Ty) -> Self::TyLayout;\n+    fn layout_of(&self, ty: Self::Ty) -> Self::TyLayout;\n }\n \n pub trait TyLayoutMethods<'a, C: LayoutOf<Ty = Self>>: Sized {\n-    fn for_variant(this: TyLayout<'a, Self>, cx: C, variant_index: usize) -> TyLayout<'a, Self>;\n-    fn field(this: TyLayout<'a, Self>, cx: C, i: usize) -> C::TyLayout;\n+    fn for_variant(this: TyLayout<'a, Self>, cx: &C, variant_index: usize) -> TyLayout<'a, Self>;\n+    fn field(this: TyLayout<'a, Self>, cx: &C, i: usize) -> C::TyLayout;\n }\n \n impl<'a, Ty> TyLayout<'a, Ty> {\n-    pub fn for_variant<C>(self, cx: C, variant_index: usize) -> Self\n+    pub fn for_variant<C>(self, cx: &C, variant_index: usize) -> Self\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> {\n         Ty::for_variant(self, cx, variant_index)\n     }\n-    pub fn field<C>(self, cx: C, i: usize) -> C::TyLayout\n+    pub fn field<C>(self, cx: &C, i: usize) -> C::TyLayout\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> {\n         Ty::field(self, cx, i)\n     }"}, {"sha": "c8af81c02ea4a48b5a8a72cd7e1307272532fd63", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d00d42d079236893f0a8b2cd726c6957d96ec296/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=d00d42d079236893f0a8b2cd726c6957d96ec296", "patch": "@@ -444,11 +444,11 @@ pub struct Target {\n     pub options: TargetOptions,\n }\n \n-pub trait HasTargetSpec: Copy {\n+pub trait HasTargetSpec {\n     fn target_spec(&self) -> &Target;\n }\n \n-impl<'a> HasTargetSpec for &'a Target {\n+impl HasTargetSpec for Target {\n     fn target_spec(&self) -> &Target {\n         self\n     }"}]}