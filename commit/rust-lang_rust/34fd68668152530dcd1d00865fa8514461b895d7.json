{"sha": "34fd68668152530dcd1d00865fa8514461b895d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZmQ2ODY2ODE1MjUzMGRjZDFkMDA4NjVmYTg1MTQ0NjFiODk1ZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-25T19:34:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-25T19:34:39Z"}, "message": "Auto merge of #33667 - pnkfelix:fixes-to-mir-dataflow, r=arielb1\n\nFixes to mir dataflow\n\nFixes to mir dataflow\n\nThis collects a bunch of changes to `rustc_borrowck::borrowck::dataflow` (which others have pointed out should probably migrate to some crate that isn't tied to the borrow-checker -- but I have not attempted that here, especially since there are competing approaches to dataflow that we should also evaluate).\n\nThese changes:\n 1. Provide a family of related analyses: MovingOutStatements (which is what the old AST-based dataflo computed), as well as MaybeInitialized, MaybeUninitalized, and DefinitelyInitialized.\n   * (The last two are actually inverses of each other; we should pick one and drop the other.)\n 2. Fix bugs in the pre-existing analysis implementation, which was untested and thus some obvious bugs went unnoticed, which brings us to the third point:\n 3. Add a unit test infrastructure for the MIR dataflow analysis.\n   * The tests work by adding a new intrinsic that is able to query the analysis state for a particular expression (technically, a particular L-value).\n   * See the examples in compile-fail/mir-dataflow/inits-1.rs and compile-fail/mir-dataflow/uninits-1.rs\n   * These tests are only checking the results for MaybeInitialized, MaybeUninitalized, and DefinitelyInitialized; I am not sure if it will be feasible to generalize this testing strategy to the MovingOutStatements dataflow operator.", "tree": {"sha": "19b2508db4e9e9f4bc21e8adfef2214c0f021bf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19b2508db4e9e9f4bc21e8adfef2214c0f021bf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34fd68668152530dcd1d00865fa8514461b895d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34fd68668152530dcd1d00865fa8514461b895d7", "html_url": "https://github.com/rust-lang/rust/commit/34fd68668152530dcd1d00865fa8514461b895d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34fd68668152530dcd1d00865fa8514461b895d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da66f2fd8cab261911163ece04d5c15a13cf5e58", "url": "https://api.github.com/repos/rust-lang/rust/commits/da66f2fd8cab261911163ece04d5c15a13cf5e58", "html_url": "https://github.com/rust-lang/rust/commit/da66f2fd8cab261911163ece04d5c15a13cf5e58"}, {"sha": "df5c116250657daa98da84eebe1b44a495abf5c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/df5c116250657daa98da84eebe1b44a495abf5c0", "html_url": "https://github.com/rust-lang/rust/commit/df5c116250657daa98da84eebe1b44a495abf5c0"}], "stats": {"total": 3301, "additions": 2464, "deletions": 837}, "files": [{"sha": "0350824ee359d7ec7d4b46d103e1413025553d9c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -168,6 +168,16 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_singlethreadfence_rel();\n     pub fn atomic_singlethreadfence_acqrel();\n \n+    /// Magic intrinsic that derives its meaning from attributes\n+    /// attached to the function.\n+    ///\n+    /// For example, dataflow uses this to inject static assertions so\n+    /// that `rustc_peek(potentially_uninitialized)` would actually\n+    /// double-check that dataflow did indeed compute that it is\n+    /// uninitialized at that point in the control flow.\n+    #[cfg(not(stage0))]\n+    pub fn rustc_peek<T>(_: T) -> T;\n+\n     /// Aborts the execution of the process.\n     pub fn abort() -> !;\n "}, {"sha": "4d01b59001c5daf167ce709612d63f334bd9bae7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -660,8 +660,8 @@ fn set_bit(words: &mut [usize], bit: usize) -> bool {\n }\n \n fn bit_str(bit: usize) -> String {\n-    let byte = bit >> 8;\n-    let lobits = 1 << (bit & 0xFF);\n+    let byte = bit >> 3;\n+    let lobits = 1 << (bit & 0b111);\n     format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n "}, {"sha": "f9a671435ffdb3327506c4b5286088517035efe6", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -226,7 +226,8 @@ pub struct UpvarDecl {\n /// list of the `Mir`.\n ///\n /// (We use a `u32` internally just to save memory.)\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,\n+         RustcEncodable, RustcDecodable)]\n pub struct BasicBlock(u32);\n \n impl BasicBlock {"}, {"sha": "828a48532a2fc1b7c2de1f475a60b593befdccda", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -18,7 +18,7 @@ use ty::TyCtxt;\n use syntax::ast::NodeId;\n \n /// Where a specific Mir comes from.\n-#[derive(Copy, Clone)]\n+#[derive(Debug, Copy, Clone)]\n pub enum MirSource {\n     /// Functions and methods.\n     Fn(NodeId),"}, {"sha": "80fa86a007ed3381180e582ae14bfc9407c9884e", "filename": "src/librustc_borrowck/bitslice.rs", "status": "modified", "additions": 60, "deletions": 22, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fbitslice.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -8,22 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME: move this to `rustc_data_structures` and potentially merge\n+// with `bitvec` there.\n+\n use std::mem;\n \n-/// `BitSlice` provides helper methods for treating a `[usize]`\n+pub type Word = usize;\n+\n+/// `BitSlice` provides helper methods for treating a `[Word]`\n /// as a bitvector.\n pub trait BitSlice {\n     fn clear_bit(&mut self, idx: usize) -> bool;\n     fn set_bit(&mut self, idx: usize) -> bool;\n     fn get_bit(&self, idx: usize) -> bool;\n }\n \n-impl BitSlice for [usize] {\n+impl BitSlice for [Word] {\n     /// Clears bit at `idx` to 0; returns true iff this changed `self.`\n     fn clear_bit(&mut self, idx: usize) -> bool {\n         let words = self;\n         debug!(\"clear_bit: words={} idx={}\",\n-               bits_to_string(words, words.len() * mem::size_of::<usize>()), bit_str(idx));\n+               bits_to_string(words, words.len() * mem::size_of::<Word>()), bit_str(idx));\n         let BitLookup { word, bit_in_word, bit_mask } = bit_lookup(idx);\n         debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n         let oldv = words[word];\n@@ -36,7 +41,7 @@ impl BitSlice for [usize] {\n     fn set_bit(&mut self, idx: usize) -> bool {\n         let words = self;\n         debug!(\"set_bit: words={} idx={}\",\n-               bits_to_string(words, words.len() * mem::size_of::<usize>()), bit_str(idx));\n+               bits_to_string(words, words.len() * mem::size_of::<Word>()), bit_str(idx));\n         let BitLookup { word, bit_in_word, bit_mask } = bit_lookup(idx);\n         debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n         let oldv = words[word];\n@@ -54,52 +59,85 @@ impl BitSlice for [usize] {\n }\n \n struct BitLookup {\n-    /// An index of the word holding the bit in original `[usize]` of query.\n+    /// An index of the word holding the bit in original `[Word]` of query.\n     word: usize,\n     /// Index of the particular bit within the word holding the bit.\n     bit_in_word: usize,\n     /// Word with single 1-bit set corresponding to where the bit is located.\n-    bit_mask: usize,\n+    bit_mask: Word,\n }\n \n #[inline]\n fn bit_lookup(bit: usize) -> BitLookup {\n-    let usize_bits = mem::size_of::<usize>() * 8;\n-    let word = bit / usize_bits;\n-    let bit_in_word = bit % usize_bits;\n+    let word_bits = mem::size_of::<Word>() * 8;\n+    let word = bit / word_bits;\n+    let bit_in_word = bit % word_bits;\n     let bit_mask = 1 << bit_in_word;\n     BitLookup { word: word, bit_in_word: bit_in_word, bit_mask: bit_mask }\n }\n \n \n-fn bit_str(bit: usize) -> String {\n-    let byte = bit >> 8;\n-    let lobits = 1 << (bit & 0xFF);\n+fn bit_str(bit: Word) -> String {\n+    let byte = bit >> 3;\n+    let lobits = 1 << (bit & 0b111);\n     format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n \n-pub fn bits_to_string(words: &[usize], bytes: usize) -> String {\n+pub fn bits_to_string(words: &[Word], bits: usize) -> String {\n     let mut result = String::new();\n     let mut sep = '[';\n \n     // Note: this is a little endian printout of bytes.\n \n+    // i tracks how many bits we have printed so far.\n     let mut i = 0;\n     for &word in words.iter() {\n         let mut v = word;\n-        for _ in 0..mem::size_of::<usize>() {\n-            let byte = v & 0xFF;\n-            if i >= bytes {\n-                assert!(byte == 0);\n-            } else {\n-                result.push(sep);\n-                result.push_str(&format!(\"{:02x}\", byte));\n-            }\n+        loop { // for each byte in `v`:\n+            let remain = bits - i;\n+            // If less than a byte remains, then mask just that many bits.\n+            let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n+            assert!(mask <= 0xFF);\n+            let byte = v & mask;\n+\n+            result.push(sep);\n+            result.push_str(&format!(\"{:02x}\", byte));\n+\n+            if remain <= 8 { break; }\n             v >>= 8;\n-            i += 1;\n+            i += 8;\n             sep = '-';\n         }\n     }\n     result.push(']');\n     return result\n }\n+\n+#[inline]\n+pub fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n+                                   in_vec: &[usize],\n+                                   op: &Op) -> bool {\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    let mut changed = false;\n+    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n+        let old_val = *out_elt;\n+        let new_val = op.join(old_val, *in_elt);\n+        *out_elt = new_val;\n+        changed |= old_val != new_val;\n+    }\n+    changed\n+}\n+\n+pub trait BitwiseOperator {\n+    /// Applies some bit-operation pointwise to each of the bits in the two inputs.\n+    fn join(&self, pred1: usize, pred2: usize) -> usize;\n+}\n+\n+pub struct Union;\n+impl BitwiseOperator for Union {\n+    fn join(&self, a: usize, b: usize) -> usize { a | b }\n+}\n+pub struct Subtract;\n+impl BitwiseOperator for Subtract {\n+    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n+}"}, {"sha": "d6dd176e3ba288b4cabf600c5723621f69b79ff3", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "removed", "additions": 0, "deletions": 504, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=da66f2fd8cab261911163ece04d5c15a13cf5e58", "patch": "@@ -1,504 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::attr::AttrMetaMethods;\n-\n-use rustc::ty::TyCtxt;\n-use rustc::mir::repr::{self, Mir};\n-\n-use std::io;\n-use std::mem;\n-use std::usize;\n-\n-use super::MirBorrowckCtxt;\n-use super::gather_moves::{Location, MoveData, MovePathData, MovePathIndex, MoveOutIndex, PathMap};\n-use super::graphviz;\n-use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n-\n-pub trait Dataflow {\n-    fn dataflow(&mut self);\n-}\n-\n-impl<'b, 'a: 'b, 'tcx: 'a> Dataflow for MirBorrowckCtxt<'b, 'a, 'tcx> {\n-    fn dataflow(&mut self) {\n-        self.build_gen_and_kill_sets();\n-        self.pre_dataflow_instrumentation().unwrap();\n-        self.propagate();\n-        self.post_dataflow_instrumentation().unwrap();\n-    }\n-}\n-\n-struct PropagationContext<'c, 'b: 'c, 'a: 'b, 'tcx: 'a, OnReturn>\n-    where OnReturn: Fn(&MoveData, &mut [usize], &repr::Lvalue)\n-{\n-    mbcx: &'c mut MirBorrowckCtxt<'b, 'a, 'tcx>,\n-    changed: bool,\n-    on_return: OnReturn\n-}\n-\n-impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n-    fn propagate(&mut self) {\n-        let mut temp = vec![0; self.flow_state.sets.words_per_block];\n-        let mut propcx = PropagationContext {\n-            mbcx: &mut *self,\n-            changed: true,\n-            on_return: |move_data, in_out, dest_lval| {\n-                let move_path_index = move_data.rev_lookup.find(dest_lval);\n-                on_all_children_bits(in_out,\n-                                     &move_data.path_map,\n-                                     &move_data.move_paths,\n-                                     move_path_index,\n-                                     &|in_out, mpi| {\n-                                         in_out.clear_bit(mpi.idx());\n-                                     });\n-            },\n-        };\n-        while propcx.changed {\n-            propcx.changed = false;\n-            propcx.reset(&mut temp);\n-            propcx.walk_cfg(&mut temp);\n-        }\n-    }\n-\n-    fn build_gen_and_kill_sets(&mut self) {\n-        // First we need to build the gen- and kill-sets. The\n-        // gather_moves information provides a high-level mapping from\n-        // mir-locations to the MoveOuts (and those correspond\n-        // directly to gen-sets here). But we still need to figure out\n-        // the kill-sets.\n-\n-        let move_data = &self.flow_state.operator;\n-        let move_paths = &move_data.move_paths;\n-        let loc_map = &move_data.loc_map;\n-        let path_map = &move_data.path_map;\n-        let rev_lookup = &move_data.rev_lookup;\n-\n-        for bb in self.mir.all_basic_blocks() {\n-            let &repr::BasicBlockData { ref statements,\n-                                        ref terminator,\n-                                        is_cleanup: _ } =\n-                self.mir.basic_block_data(bb);\n-\n-            let mut sets = self.flow_state.sets.for_block(bb.index());\n-            for (j, stmt) in statements.iter().enumerate() {\n-                let loc = Location { block: bb, index: j };\n-                debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n-                       stmt, loc, &loc_map[loc]);\n-                for move_index in &loc_map[loc] {\n-                    // Every path deinitialized by a *particular move*\n-                    // has corresponding bit, \"gen'ed\" (i.e. set)\n-                    // here, in dataflow vector\n-                    zero_to_one(&mut sets.gen_set, *move_index);\n-                }\n-                match stmt.kind {\n-                    repr::StatementKind::Assign(ref lvalue, _) => {\n-                        // assigning into this `lvalue` kills all\n-                        // MoveOuts from it, and *also* all MoveOuts\n-                        // for children and associated fragment sets.\n-                        let move_path_index = rev_lookup.find(lvalue);\n-\n-                        on_all_children_bits(sets.kill_set,\n-                                             path_map,\n-                                             move_paths,\n-                                             move_path_index,\n-                                             &|kill_set, mpi| {\n-                                                 kill_set.set_bit(mpi.idx());\n-                                             });\n-                    }\n-                }\n-            }\n-\n-            let loc = Location { block: bb, index: statements.len() };\n-            debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n-                   terminator, loc, &loc_map[loc]);\n-            for move_index in &loc_map[loc] {\n-                zero_to_one(&mut sets.gen_set, *move_index);\n-            }\n-        }\n-\n-        fn zero_to_one(gen_set: &mut [usize], move_index: MoveOutIndex) {\n-            let retval = gen_set.set_bit(move_index.idx());\n-            assert!(retval);\n-        }\n-    }\n-}\n-\n-fn on_all_children_bits<Each>(set: &mut [usize],\n-                              path_map: &PathMap,\n-                              move_paths: &MovePathData,\n-                              move_path_index: MovePathIndex,\n-                              each_child: &Each)\n-    where Each: Fn(&mut [usize], MoveOutIndex)\n-{\n-    // 1. invoke `each_child` callback for all moves that directly\n-    //    influence path for `move_path_index`\n-    for move_index in &path_map[move_path_index] {\n-        each_child(set, *move_index);\n-    }\n-\n-    // 2. for each child of the path (that is named in this\n-    //    function), recur.\n-    //\n-    // (Unnamed children are irrelevant to dataflow; by\n-    // definition they have no associated moves.)\n-    let mut next_child_index = move_paths[move_path_index].first_child;\n-    while let Some(child_index) = next_child_index {\n-        on_all_children_bits(set, path_map, move_paths, child_index, each_child);\n-        next_child_index = move_paths[child_index].next_sibling;\n-    }\n-}\n-\n-impl<'c, 'b: 'c, 'a: 'b, 'tcx: 'a, OnReturn> PropagationContext<'c, 'b, 'a, 'tcx, OnReturn>\n-    where OnReturn: Fn(&MoveData, &mut [usize], &repr::Lvalue)\n-{\n-    fn reset(&mut self, bits: &mut [usize]) {\n-        let e = if self.mbcx.flow_state.operator.initial_value() {usize::MAX} else {0};\n-        for b in bits {\n-            *b = e;\n-        }\n-    }\n-\n-    fn walk_cfg(&mut self, in_out: &mut [usize]) {\n-        let &mut MirBorrowckCtxt { ref mir, ref mut flow_state, .. } = self.mbcx;\n-        for (idx, bb) in mir.basic_blocks.iter().enumerate() {\n-            {\n-                let sets = flow_state.sets.for_block(idx);\n-                debug_assert!(in_out.len() == sets.on_entry.len());\n-                in_out.clone_from_slice(sets.on_entry);\n-                bitwise(in_out, sets.gen_set, &Union);\n-                bitwise(in_out, sets.kill_set, &Subtract);\n-            }\n-            flow_state.propagate_bits_into_graph_successors_of(in_out,\n-                                                               &mut self.changed,\n-                                                               bb,\n-                                                               &self.on_return);\n-        }\n-    }\n-}\n-\n-impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n-    fn pre_dataflow_instrumentation(&self) -> io::Result<()> {\n-        self.if_attr_meta_name_found(\n-            \"borrowck_graphviz_preflow\",\n-            |this, path: &str| {\n-                graphviz::print_borrowck_graph_to(this, \"preflow\", path)\n-            })\n-    }\n-\n-    fn post_dataflow_instrumentation(&self) -> io::Result<()> {\n-        self.if_attr_meta_name_found(\n-            \"borrowck_graphviz_postflow\",\n-            |this, path: &str| {\n-                graphviz::print_borrowck_graph_to(this, \"postflow\", path)\n-            })\n-    }\n-\n-    fn if_attr_meta_name_found<F>(&self,\n-                                  name: &str,\n-                                  callback: F) -> io::Result<()>\n-        where F: for <'aa, 'bb> FnOnce(&'aa Self, &'bb str) -> io::Result<()>\n-    {\n-        for attr in self.attributes {\n-            if attr.check_name(\"rustc_mir\") {\n-                let items = attr.meta_item_list();\n-                for item in items.iter().flat_map(|l| l.iter()) {\n-                    if item.check_name(name) {\n-                        if let Some(s) = item.value_str() {\n-                            return callback(self, &s);\n-                        } else {\n-                            self.bcx.tcx.sess.span_err(\n-                                item.span,\n-                                &format!(\"{} attribute requires a path\", item.name()));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n-/// Maps each block to a set of bits\n-#[derive(Clone, Debug)]\n-struct Bits {\n-    bits: Vec<usize>,\n-}\n-\n-impl Bits {\n-    fn new(init_word: usize, num_words: usize) -> Self {\n-        Bits { bits: vec![init_word; num_words] }\n-    }\n-}\n-\n-pub struct DataflowState<O: BitDenotation>\n-{\n-    /// All the sets for the analysis. (Factored into its\n-    /// own structure so that we can borrow it mutably\n-    /// on its own separate from other fields.)\n-    pub sets: AllSets,\n-\n-    /// operator used to initialize, combine, and interpret bits.\n-    operator: O,\n-}\n-\n-pub struct AllSets {\n-    /// Analysis bitwidth for each block.\n-    bits_per_block: usize,\n-\n-    /// Number of words associated with each block entry\n-    /// equal to bits_per_block / usize::BITS, rounded up.\n-    words_per_block: usize,\n-\n-    /// For each block, bits generated by executing the statements in\n-    /// the block. (For comparison, the Terminator for each block is\n-    /// handled in a flow-specific manner during propagation.)\n-    gen_sets: Bits,\n-\n-    /// For each block, bits killed by executing the statements in the\n-    /// block. (For comparison, the Terminator for each block is\n-    /// handled in a flow-specific manner during propagation.)\n-    kill_sets: Bits,\n-\n-    /// For each block, bits valid on entry to the block.\n-    on_entry_sets: Bits,\n-}\n-\n-pub struct BlockSets<'a> {\n-    on_entry: &'a mut [usize],\n-    gen_set: &'a mut [usize],\n-    kill_set: &'a mut [usize],\n-}\n-\n-impl AllSets {\n-    pub fn bits_per_block(&self) -> usize { self.bits_per_block }\n-    pub fn bytes_per_block(&self) -> usize { (self.bits_per_block + 7) / 8 }\n-    pub fn for_block(&mut self, block_idx: usize) -> BlockSets {\n-        let offset = self.words_per_block * block_idx;\n-        let range = offset..(offset + self.words_per_block);\n-        BlockSets {\n-            on_entry: &mut self.on_entry_sets.bits[range.clone()],\n-            gen_set: &mut self.gen_sets.bits[range.clone()],\n-            kill_set: &mut self.kill_sets.bits[range],\n-        }\n-    }\n-\n-    fn lookup_set_for<'a>(&self, sets: &'a Bits, block_idx: usize) -> &'a [usize] {\n-        let offset = self.words_per_block * block_idx;\n-        &sets.bits[offset..(offset + self.words_per_block)]\n-    }\n-    pub fn gen_set_for(&self, block_idx: usize) -> &[usize] {\n-        self.lookup_set_for(&self.gen_sets, block_idx)\n-    }\n-    pub fn kill_set_for(&self, block_idx: usize) -> &[usize] {\n-        self.lookup_set_for(&self.kill_sets, block_idx)\n-    }\n-    pub fn on_entry_set_for(&self, block_idx: usize) -> &[usize] {\n-        self.lookup_set_for(&self.on_entry_sets, block_idx)\n-    }\n-}\n-\n-impl<O: BitDenotation> DataflowState<O> {\n-    fn each_bit<F>(&self, words: &[usize], mut f: F)\n-        where F: FnMut(usize) {\n-        //! Helper for iterating over the bits in a bitvector.\n-\n-        for (word_index, &word) in words.iter().enumerate() {\n-            if word != 0 {\n-                let usize_bits: usize = mem::size_of::<usize>();\n-                let base_index = word_index * usize_bits;\n-                for offset in 0..usize_bits {\n-                    let bit = 1 << offset;\n-                    if (word & bit) != 0 {\n-                        // NB: we round up the total number of bits\n-                        // that we store in any given bit set so that\n-                        // it is an even multiple of usize::BITS. This\n-                        // means that there may be some stray bits at\n-                        // the end that do not correspond to any\n-                        // actual value; that's why we first check\n-                        // that we are in range of bits_per_block.\n-                        let bit_index = base_index + offset as usize;\n-                        if bit_index >= self.sets.bits_per_block() {\n-                            return;\n-                        } else {\n-                            f(bit_index);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn interpret_set(&self, words: &[usize]) -> Vec<&O::Bit> {\n-        let mut v = Vec::new();\n-        self.each_bit(words, |i| {\n-            v.push(self.operator.interpret(i));\n-        });\n-        v\n-    }\n-}\n-\n-pub trait BitwiseOperator {\n-    /// Joins two predecessor bits together, typically either `|` or `&`\n-    fn join(&self, pred1: usize, pred2: usize) -> usize;\n-}\n-\n-/// Parameterization for the precise form of data flow that is used.\n-pub trait DataflowOperator : BitwiseOperator {\n-    /// Specifies the initial value for each bit in the `on_entry` set\n-    fn initial_value(&self) -> bool;\n-}\n-\n-pub trait BitDenotation: DataflowOperator {\n-    /// Specifies what is represented by each bit in the dataflow bitvector.\n-    type Bit;\n-    /// Size of each bivector allocated for each block in the analysis.\n-    fn bits_per_block(&self) -> usize;\n-    /// Provides the meaning of each entry in the dataflow bitvector.\n-    /// (Mostly intended for use for better debug instrumentation.)\n-    fn interpret(&self, idx: usize) -> &Self::Bit;\n-}\n-\n-impl<D: BitDenotation> DataflowState<D> {\n-    pub fn new(mir: &Mir, denotation: D) -> Self {\n-        let bits_per_block = denotation.bits_per_block();\n-        let usize_bits = mem::size_of::<usize>() * 8;\n-        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n-        let num_blocks = mir.basic_blocks.len();\n-        let num_words = num_blocks * words_per_block;\n-\n-        let entry = if denotation.initial_value() { usize::MAX } else {0};\n-\n-        let zeroes = Bits::new(0, num_words);\n-        let on_entry = Bits::new(entry, num_words);\n-\n-        DataflowState {\n-            sets: AllSets {\n-                bits_per_block: bits_per_block,\n-                words_per_block: words_per_block,\n-                gen_sets: zeroes.clone(),\n-                kill_sets: zeroes,\n-                on_entry_sets: on_entry,\n-            },\n-            operator: denotation,\n-        }\n-    }\n-}\n-\n-impl<D: BitDenotation> DataflowState<D> {\n-    /// Propagates the bits of `in_out` into all the successors of `bb`,\n-    /// using bitwise operator denoted by `self.operator`.\n-    ///\n-    /// For most blocks, this is entirely uniform. However, for blocks\n-    /// that end with a call terminator, the effect of the call on the\n-    /// dataflow state may depend on whether the call returned\n-    /// successfully or unwound. To reflect this, the `on_return`\n-    /// callback mutates `in_out` when propagating `in_out` via a call\n-    /// terminator; such mutation is performed *last*, to ensure its\n-    /// side-effects do not leak elsewhere (e.g. into unwind target).\n-    fn propagate_bits_into_graph_successors_of<OnReturn>(\n-        &mut self,\n-        in_out: &mut [usize],\n-        changed: &mut bool,\n-        bb: &repr::BasicBlockData,\n-        on_return: OnReturn) where OnReturn: Fn(&D, &mut [usize], &repr::Lvalue)\n-    {\n-        match bb.terminator().kind {\n-            repr::TerminatorKind::Return |\n-            repr::TerminatorKind::Resume => {}\n-            repr::TerminatorKind::Goto { ref target } |\n-            repr::TerminatorKind::Drop { ref target, value: _, unwind: None } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n-            }\n-            repr::TerminatorKind::Drop { ref target, value: _, unwind: Some(ref unwind) } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n-                self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n-            }\n-            repr::TerminatorKind::If { ref targets, .. } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.0);\n-                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.1);\n-            }\n-            repr::TerminatorKind::Switch { ref targets, .. } |\n-            repr::TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, target);\n-                }\n-            }\n-            repr::TerminatorKind::Call { ref cleanup, ref destination, func: _, args: _ } => {\n-                if let Some(ref unwind) = *cleanup {\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n-                }\n-                if let Some((ref dest_lval, ref dest_bb)) = *destination {\n-                    // N.B.: This must be done *last*, after all other\n-                    // propagation, as documented in comment above.\n-                    on_return(&self.operator, in_out, dest_lval);\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, dest_bb);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(&mut self,\n-                                         in_out: &[usize],\n-                                         changed: &mut bool,\n-                                         bb: &repr::BasicBlock) {\n-        let entry_set = self.sets.for_block(bb.index()).on_entry;\n-        let set_changed = bitwise(entry_set, in_out, &self.operator);\n-        if set_changed {\n-            *changed = true;\n-        }\n-    }\n-}\n-\n-\n-impl<'a, 'tcx> DataflowState<MoveData<'tcx>> {\n-    pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        let move_data = MoveData::gather_moves(mir, tcx);\n-        DataflowState::new(mir, move_data)\n-    }\n-}\n-\n-impl<'tcx> BitwiseOperator for MoveData<'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // moves from both preds are in scope\n-    }\n-}\n-\n-impl<'tcx> DataflowOperator for MoveData<'tcx> {\n-    #[inline]\n-    fn initial_value(&self) -> bool {\n-        false // no loans in scope by default\n-    }\n-}\n-\n-#[inline]\n-fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n-                               in_vec: &[usize],\n-                               op: &Op) -> bool {\n-    assert_eq!(out_vec.len(), in_vec.len());\n-    let mut changed = false;\n-    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n-        let old_val = *out_elt;\n-        let new_val = op.join(old_val, *in_elt);\n-        *out_elt = new_val;\n-        changed |= old_val != new_val;\n-    }\n-    changed\n-}\n-\n-struct Union;\n-impl BitwiseOperator for Union {\n-    fn join(&self, a: usize, b: usize) -> usize { a | b }\n-}\n-struct Subtract;\n-impl BitwiseOperator for Subtract {\n-    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n-}"}, {"sha": "63c11fb3545b016fbed578ab8506916842d7f2cd", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -0,0 +1,340 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Hook into libgraphviz for rendering dataflow graphs for MIR.\n+\n+use syntax::ast::NodeId;\n+use rustc::mir::repr::{BasicBlock, Mir};\n+\n+use dot;\n+use dot::IntoCow;\n+\n+use std::fmt::Debug;\n+use std::fs::File;\n+use std::io;\n+use std::io::prelude::*;\n+use std::marker::PhantomData;\n+use std::mem;\n+use std::path::Path;\n+\n+use super::super::MoveDataParamEnv;\n+use super::super::MirBorrowckCtxtPreDataflow;\n+use bitslice::bits_to_string;\n+use indexed_set::{Idx, IdxSet};\n+use super::{BitDenotation, DataflowState};\n+\n+impl<O: BitDenotation> DataflowState<O> {\n+    fn each_bit<F>(&self, ctxt: &O::Ctxt, words: &IdxSet<O::Idx>, mut f: F)\n+        where F: FnMut(O::Idx) {\n+        //! Helper for iterating over the bits in a bitvector.\n+\n+        let bits_per_block = self.operator.bits_per_block(ctxt);\n+        let usize_bits: usize = mem::size_of::<usize>() * 8;\n+\n+        for (word_index, &word) in words.words().iter().enumerate() {\n+            if word != 0 {\n+                let base_index = word_index * usize_bits;\n+                for offset in 0..usize_bits {\n+                    let bit = 1 << offset;\n+                    if (word & bit) != 0 {\n+                        // NB: we round up the total number of bits\n+                        // that we store in any given bit set so that\n+                        // it is an even multiple of usize::BITS. This\n+                        // means that there may be some stray bits at\n+                        // the end that do not correspond to any\n+                        // actual value; that's why we first check\n+                        // that we are in range of bits_per_block.\n+                        let bit_index = base_index + offset as usize;\n+                        if bit_index >= bits_per_block {\n+                            return;\n+                        } else {\n+                            f(O::Idx::new(bit_index));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn interpret_set<'c, P>(&self,\n+                                ctxt: &'c O::Ctxt,\n+                                words: &IdxSet<O::Idx>,\n+                                render_idx: &P)\n+                                -> Vec<&'c Debug>\n+        where P: for <'b> Fn(&'b O::Ctxt, O::Idx) -> &'b Debug\n+    {\n+        let mut v = Vec::new();\n+        self.each_bit(ctxt, words, |i| {\n+            v.push(render_idx(ctxt, i));\n+        });\n+        v\n+    }\n+}\n+\n+pub trait MirWithFlowState<'tcx> {\n+    type BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>>;\n+    fn node_id(&self) -> NodeId;\n+    fn mir(&self) -> &Mir<'tcx>;\n+    fn analysis_ctxt(&self) -> &<Self::BD as BitDenotation>::Ctxt;\n+    fn flow_state(&self) -> &DataflowState<Self::BD>;\n+}\n+\n+impl<'a, 'tcx: 'a, BD> MirWithFlowState<'tcx> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n+    where 'a, 'tcx: 'a, BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>>\n+{\n+    type BD = BD;\n+    fn node_id(&self) -> NodeId { self.node_id }\n+    fn mir(&self) -> &Mir<'tcx> { self.flow_state.mir() }\n+    fn analysis_ctxt(&self) -> &BD::Ctxt { &self.flow_state.ctxt }\n+    fn flow_state(&self) -> &DataflowState<Self::BD> { &self.flow_state.flow_state }\n+}\n+\n+struct Graph<'a, 'tcx, MWF:'a, P> where\n+    MWF: MirWithFlowState<'tcx>\n+{\n+    mbcx: &'a MWF,\n+    phantom: PhantomData<&'tcx ()>,\n+    render_idx: P,\n+}\n+\n+pub fn print_borrowck_graph_to<'a, 'tcx, BD, P>(\n+    mbcx: &MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>,\n+    path: &Path,\n+    render_idx: P)\n+    -> io::Result<()>\n+    where BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>>,\n+          P: for <'b> Fn(&'b BD::Ctxt, BD::Idx) -> &'b Debug\n+{\n+    let g = Graph { mbcx: mbcx, phantom: PhantomData, render_idx: render_idx };\n+    let mut v = Vec::new();\n+    dot::render(&g, &mut v)?;\n+    debug!(\"print_borrowck_graph_to path: {} node_id: {}\",\n+           path.display(), mbcx.node_id);\n+    File::create(path).and_then(|mut f| f.write_all(&v))\n+}\n+\n+pub type Node = BasicBlock;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct Edge { source: BasicBlock, index: usize }\n+\n+fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n+    let succ_len = mir.basic_block_data(bb).terminator().successors().len();\n+    (0..succ_len).map(|index| Edge { source: bb, index: index}).collect()\n+}\n+\n+impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n+    where MWF: MirWithFlowState<'tcx>,\n+          P: for <'b> Fn(&'b <MWF::BD as BitDenotation>::Ctxt,\n+                         <MWF::BD as BitDenotation>::Idx)\n+                         -> &'b Debug,\n+{\n+    type Node = Node;\n+    type Edge = Edge;\n+    fn graph_id(&self) -> dot::Id {\n+        dot::Id::new(format!(\"graph_for_node_{}\",\n+                             self.mbcx.node_id()))\n+            .unwrap()\n+    }\n+\n+    fn node_id(&self, n: &Node) -> dot::Id {\n+        dot::Id::new(format!(\"bb_{}\", n.index()))\n+            .unwrap()\n+    }\n+\n+    fn node_label(&self, n: &Node) -> dot::LabelText {\n+        // A standard MIR label, as generated by write_node_label, is\n+        // presented in a single column in a table.\n+        //\n+        // The code below does a bunch of formatting work to format a\n+        // node (i.e. MIR basic-block) label with extra\n+        // dataflow-enriched information.  In particular, the goal is\n+        // to add extra columns that present the three dataflow\n+        // bitvectors, and the data those bitvectors represent.\n+        //\n+        // It presents it in the following format (where I am\n+        // presenting the table rendering via ASCII art, one line per\n+        // row of the table, and a chunk size of 3 rather than 5):\n+        //\n+        // ------  -----------------------  ------------  --------------------\n+        //                    [e1, e3, e4]\n+        //             [e8, e9] \"= ENTRY:\"  <ENTRY-BITS>\n+        // ------  -----------------------  ------------  --------------------\n+        // Left\n+        // Most\n+        // Column\n+        // Is\n+        // Just\n+        // Normal\n+        // Series\n+        // Of\n+        // MIR\n+        // Stmts\n+        // ------  -----------------------  ------------  --------------------\n+        //           [g1, g4, g5] \"= GEN:\"  <GEN-BITS>\n+        // ------  -----------------------  ------------  --------------------\n+        //                         \"KILL:\"  <KILL-BITS>   \"=\" [k1, k3, k8]\n+        //                                                [k9]\n+        // ------  -----------------------  ------------  --------------------\n+        //\n+        // (In addition, the added dataflow is rendered with a colored\n+        // background just so it will stand out compared to the\n+        // statements.)\n+        let mut v = Vec::new();\n+        let i = n.index();\n+        let chunk_size = 5;\n+        const BG_FLOWCONTENT: &'static str = r#\"bgcolor=\"pink\"\"#;\n+        const ALIGN_RIGHT: &'static str = r#\"align=\"right\"\"#;\n+        const FACE_MONOSPACE: &'static str = r#\"FACE=\"Courier\"\"#;\n+        fn chunked_present_left<W:io::Write>(w: &mut W,\n+                                             interpreted: &[&Debug],\n+                                             chunk_size: usize)\n+                                             -> io::Result<()>\n+        {\n+            // This function may emit a sequence of <tr>'s, but it\n+            // always finishes with an (unfinished)\n+            // <tr><td></td><td>\n+            //\n+            // Thus, after being called, one should finish both the\n+            // pending <td> as well as the <tr> itself.\n+            let mut seen_one = false;\n+            for c in interpreted.chunks(chunk_size) {\n+                if seen_one {\n+                    // if not the first row, finish off the previous row\n+                    write!(w, \"</td><td></td><td></td></tr>\")?;\n+                }\n+                write!(w, \"<tr><td></td><td {bg} {align}>{objs:?}\",\n+                       bg = BG_FLOWCONTENT,\n+                       align = ALIGN_RIGHT,\n+                       objs = c)?;\n+                seen_one = true;\n+            }\n+            if !seen_one {\n+                write!(w, \"<tr><td></td><td {bg} {align}>[]\",\n+                       bg = BG_FLOWCONTENT,\n+                       align = ALIGN_RIGHT)?;\n+            }\n+            Ok(())\n+        }\n+        ::rustc_mir::graphviz::write_node_label(\n+            *n, self.mbcx.mir(), &mut v, 4,\n+            |w| {\n+                let ctxt = self.mbcx.analysis_ctxt();\n+                let flow = self.mbcx.flow_state();\n+                let entry_interp = flow.interpret_set(ctxt,\n+                                                      flow.sets.on_entry_set_for(i),\n+                                                      &self.render_idx);\n+                chunked_present_left(w, &entry_interp[..], chunk_size)?;\n+                let bits_per_block = flow.sets.bits_per_block();\n+                let entry = flow.sets.on_entry_set_for(i);\n+                debug!(\"entry set for i={i} bits_per_block: {bpb} entry: {e:?} interp: {ei:?}\",\n+                       i=i, e=entry, bpb=bits_per_block, ei=entry_interp);\n+                write!(w, \"= ENTRY:</td><td {bg}><FONT {face}>{entrybits:?}</FONT></td>\\\n+                                        <td></td></tr>\",\n+                       bg = BG_FLOWCONTENT,\n+                       face = FACE_MONOSPACE,\n+                       entrybits=bits_to_string(entry.words(), bits_per_block))\n+            },\n+            |w| {\n+                let ctxt = self.mbcx.analysis_ctxt();\n+                let flow = self.mbcx.flow_state();\n+                let gen_interp =\n+                    flow.interpret_set(ctxt, flow.sets.gen_set_for(i), &self.render_idx);\n+                let kill_interp =\n+                    flow.interpret_set(ctxt, flow.sets.kill_set_for(i), &self.render_idx);\n+                chunked_present_left(w, &gen_interp[..], chunk_size)?;\n+                let bits_per_block = flow.sets.bits_per_block();\n+                {\n+                    let gen = flow.sets.gen_set_for(i);\n+                    debug!(\"gen set for i={i} bits_per_block: {bpb} gen: {g:?} interp: {gi:?}\",\n+                           i=i, g=gen, bpb=bits_per_block, gi=gen_interp);\n+                    write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n+                                           <td></td></tr>\",\n+                           bg = BG_FLOWCONTENT,\n+                           face = FACE_MONOSPACE,\n+                           genbits=bits_to_string(gen.words(), bits_per_block))?;\n+                }\n+\n+                {\n+                    let kill = flow.sets.kill_set_for(i);\n+                    debug!(\"kill set for i={i} bits_per_block: {bpb} kill: {k:?} interp: {ki:?}\",\n+                           i=i, k=kill, bpb=bits_per_block, ki=kill_interp);\n+                    write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n+                                            <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n+                           bg = BG_FLOWCONTENT,\n+                           align = ALIGN_RIGHT,\n+                           face = FACE_MONOSPACE,\n+                           killbits=bits_to_string(kill.words(), bits_per_block))?;\n+                }\n+\n+                // (chunked_present_right)\n+                let mut seen_one = false;\n+                for k in kill_interp.chunks(chunk_size) {\n+                    if !seen_one {\n+                        // continuation of row; this is fourth <td>\n+                        write!(w, \"<td {bg}>= {kill:?}</td></tr>\",\n+                               bg = BG_FLOWCONTENT,\n+                               kill=k)?;\n+                    } else {\n+                        // new row, with indent of three <td>'s\n+                        write!(w, \"<tr><td></td><td></td><td></td><td {bg}>{kill:?}</td></tr>\",\n+                               bg = BG_FLOWCONTENT,\n+                               kill=k)?;\n+                    }\n+                    seen_one = true;\n+                }\n+                if !seen_one {\n+                    write!(w, \"<td {bg}>= []</td></tr>\",\n+                           bg = BG_FLOWCONTENT)?;\n+                }\n+\n+                Ok(())\n+            })\n+            .unwrap();\n+        dot::LabelText::html(String::from_utf8(v).unwrap())\n+    }\n+\n+    fn node_shape(&self, _n: &Node) -> Option<dot::LabelText> {\n+        Some(dot::LabelText::label(\"none\"))\n+    }\n+}\n+\n+impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n+    where MWF: MirWithFlowState<'tcx>\n+{\n+    type Node = Node;\n+    type Edge = Edge;\n+    fn nodes(&self) -> dot::Nodes<Node> {\n+        self.mbcx.mir().all_basic_blocks().into_cow()\n+    }\n+\n+    fn edges(&self) -> dot::Edges<Edge> {\n+        let mir = self.mbcx.mir();\n+        let blocks = mir.all_basic_blocks();\n+        // base initial capacity on assumption every block has at\n+        // least one outgoing edge (Which should be true for all\n+        // blocks but one, the exit-block).\n+        let mut edges = Vec::with_capacity(blocks.len());\n+        for bb in blocks {\n+            let outgoing = outgoing(mir, bb);\n+            edges.extend(outgoing.into_iter());\n+        }\n+        edges.into_cow()\n+    }\n+\n+    fn source(&self, edge: &Edge) -> Node {\n+        edge.source\n+    }\n+\n+    fn target(&self, edge: &Edge) -> Node {\n+        let mir = self.mbcx.mir();\n+        mir.basic_block_data(edge.source).terminator().successors()[edge.index]\n+    }\n+}"}, {"sha": "e3435ed990506e1238631f97ad3597f2443b553f", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "added", "additions": 571, "deletions": 0, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -0,0 +1,571 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::mir::repr::{self, Mir};\n+\n+use super::super::gather_moves::{Location};\n+use super::super::gather_moves::{MoveOutIndex, MovePathIndex};\n+use super::super::MoveDataParamEnv;\n+use super::super::DropFlagState;\n+use super::super::drop_flag_effects_for_function_entry;\n+use super::super::drop_flag_effects_for_location;\n+use super::super::on_all_children_bits;\n+\n+use super::{BitDenotation, BlockSets, DataflowOperator};\n+\n+use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n+use bitslice::{BitwiseOperator};\n+use indexed_set::{Idx, IdxSet};\n+\n+// Dataflow analyses are built upon some interpretation of the\n+// bitvectors attached to each basic block, represented via a\n+// zero-sized structure.\n+\n+/// `MaybeInitializedLvals` tracks all l-values that might be\n+/// initialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // maybe-init:\n+///                                            // {}\n+///     let a = S; let b = S; let c; let d;    // {a, b}\n+///\n+///     if pred {\n+///         drop(a);                           // {   b}\n+///         b = S;                             // {   b}\n+///\n+///     } else {\n+///         drop(b);                           // {a}\n+///         d = S;                             // {a,       d}\n+///\n+///     }                                      // {a, b,    d}\n+///\n+///     c = S;                                 // {a, b, c, d}\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *must* be initialized at a\n+/// particular control-flow point, one can take the set-difference\n+/// between this data and the data from `MaybeUninitializedLvals` at the\n+/// corresponding control-flow point.\n+///\n+/// Similarly, at a given `drop` statement, the set-intersection\n+/// between this data and `MaybeUninitializedLvals` yields the set of\n+/// l-values that would require a dynamic drop-flag at that statement.\n+pub struct MaybeInitializedLvals<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx: 'a> MaybeInitializedLvals<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        MaybeInitializedLvals { tcx: tcx, mir: mir }\n+    }\n+}\n+\n+/// `MaybeUninitializedLvals` tracks all l-values that might be\n+/// uninitialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // maybe-uninit:\n+///                                            // {a, b, c, d}\n+///     let a = S; let b = S; let c; let d;    // {      c, d}\n+///\n+///     if pred {\n+///         drop(a);                           // {a,    c, d}\n+///         b = S;                             // {a,    c, d}\n+///\n+///     } else {\n+///         drop(b);                           // {   b, c, d}\n+///         d = S;                             // {   b, c   }\n+///\n+///     }                                      // {a, b, c, d}\n+///\n+///     c = S;                                 // {a, b,    d}\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *must* be uninitialized at a\n+/// particular control-flow point, one can take the set-difference\n+/// between this data and the data from `MaybeInitializedLvals` at the\n+/// corresponding control-flow point.\n+///\n+/// Similarly, at a given `drop` statement, the set-intersection\n+/// between this data and `MaybeInitializedLvals` yields the set of\n+/// l-values that would require a dynamic drop-flag at that statement.\n+pub struct MaybeUninitializedLvals<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx: 'a> MaybeUninitializedLvals<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        MaybeUninitializedLvals { tcx: tcx, mir: mir }\n+    }\n+}\n+\n+/// `DefinitelyInitializedLvals` tracks all l-values that are definitely\n+/// initialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// FIXME: Note that once flow-analysis is complete, this should be\n+/// the set-complement of MaybeUninitializedLvals; thus we can get rid\n+/// of one or the other of these two. I'm inclined to get rid of\n+/// MaybeUninitializedLvals, simply because the sets will tend to be\n+/// smaller in this analysis and thus easier for humans to process\n+/// when debugging.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // definite-init:\n+///                                            // {          }\n+///     let a = S; let b = S; let c; let d;    // {a, b      }\n+///\n+///     if pred {\n+///         drop(a);                           // {   b,     }\n+///         b = S;                             // {   b,     }\n+///\n+///     } else {\n+///         drop(b);                           // {a,        }\n+///         d = S;                             // {a,       d}\n+///\n+///     }                                      // {          }\n+///\n+///     c = S;                                 // {       c  }\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *may* be uninitialized at a\n+/// particular control-flow point, one can take the set-complement\n+/// of this data.\n+///\n+/// Similarly, at a given `drop` statement, the set-difference between\n+/// this data and `MaybeInitializedLvals` yields the set of l-values\n+/// that would require a dynamic drop-flag at that statement.\n+pub struct DefinitelyInitializedLvals<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx: 'a> DefinitelyInitializedLvals<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        DefinitelyInitializedLvals { tcx: tcx, mir: mir }\n+    }\n+}\n+\n+/// `MovingOutStatements` tracks the statements that perform moves out\n+/// of particular l-values. More precisely, it tracks whether the\n+/// *effect* of such moves (namely, the uninitialization of the\n+/// l-value in question) can reach some point in the control-flow of\n+/// the function, or if that effect is \"killed\" by some intervening\n+/// operation reinitializing that l-value.\n+///\n+/// The resulting dataflow is a more enriched version of\n+/// `MaybeUninitializedLvals`. Both structures on their own only tell\n+/// you if an l-value *might* be uninitialized at a given point in the\n+/// control flow. But `MovingOutStatements` also includes the added\n+/// data of *which* particular statement causing the deinitialization\n+/// that the borrow checker's error meessage may need to report.\n+#[allow(dead_code)]\n+pub struct MovingOutStatements<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n+    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n+                   state: DropFlagState)\n+    {\n+        match state {\n+            DropFlagState::Absent => sets.kill(&path),\n+            DropFlagState::Present => sets.gen(&path),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MaybeUninitializedLvals<'a, 'tcx> {\n+    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n+                   state: DropFlagState)\n+    {\n+        match state {\n+            DropFlagState::Absent => sets.gen(&path),\n+            DropFlagState::Present => sets.kill(&path),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n+    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n+                   state: DropFlagState)\n+    {\n+        match state {\n+            DropFlagState::Absent => sets.kill(&path),\n+            DropFlagState::Present => sets.gen(&path),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n+    type Idx = MovePathIndex;\n+    type Ctxt = MoveDataParamEnv<'tcx>;\n+    fn name() -> &'static str { \"maybe_init\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.move_data.move_paths.len()\n+    }\n+\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>)\n+    {\n+        drop_flag_effects_for_function_entry(\n+            self.tcx, self.mir, ctxt,\n+            |path, s| {\n+                assert!(s == DropFlagState::Present);\n+                sets.on_entry.add(&path);\n+            });\n+    }\n+\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets<MovePathIndex>,\n+                        bb: repr::BasicBlock,\n+                        idx: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            self.tcx, self.mir, ctxt,\n+            Location { block: bb, index: idx },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets<MovePathIndex>,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            self.tcx, self.mir, ctxt,\n+            Location { block: bb, index: statements_len },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut IdxSet<MovePathIndex>,\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        // when a call returns successfully, that means we need to set\n+        // the bits for that dest_lval to 1 (initialized).\n+        let move_path_index = ctxt.move_data.rev_lookup.find(dest_lval);\n+        on_all_children_bits(self.tcx, self.mir, &ctxt.move_data,\n+                             move_path_index,\n+                             |mpi| { in_out.add(&mpi); });\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n+    type Idx = MovePathIndex;\n+    type Ctxt = MoveDataParamEnv<'tcx>;\n+    fn name() -> &'static str { \"maybe_uninit\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.move_data.move_paths.len()\n+    }\n+\n+    // sets on_entry bits for Arg lvalues\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n+        // set all bits to 1 (uninit) before gathering counterevidence\n+        for e in sets.on_entry.words_mut() { *e = !0; }\n+\n+        drop_flag_effects_for_function_entry(\n+            self.tcx, self.mir, ctxt,\n+            |path, s| {\n+                assert!(s == DropFlagState::Present);\n+                sets.on_entry.remove(&path);\n+            });\n+    }\n+\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets<MovePathIndex>,\n+                        bb: repr::BasicBlock,\n+                        idx: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            self.tcx, self.mir, ctxt,\n+            Location { block: bb, index: idx },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets<MovePathIndex>,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            self.tcx, self.mir, ctxt,\n+            Location { block: bb, index: statements_len },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut IdxSet<MovePathIndex>,\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        // when a call returns successfully, that means we need to set\n+        // the bits for that dest_lval to 1 (initialized).\n+        let move_path_index = ctxt.move_data.rev_lookup.find(dest_lval);\n+        on_all_children_bits(self.tcx, self.mir, &ctxt.move_data,\n+                             move_path_index,\n+                             |mpi| { in_out.remove(&mpi); });\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n+    type Idx = MovePathIndex;\n+    type Ctxt = MoveDataParamEnv<'tcx>;\n+    fn name() -> &'static str { \"definite_init\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.move_data.move_paths.len()\n+    }\n+\n+    // sets on_entry bits for Arg lvalues\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n+        for e in sets.on_entry.words_mut() { *e = 0; }\n+\n+        drop_flag_effects_for_function_entry(\n+            self.tcx, self.mir, ctxt,\n+            |path, s| {\n+                assert!(s == DropFlagState::Present);\n+                sets.on_entry.add(&path);\n+            });\n+    }\n+\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets<MovePathIndex>,\n+                        bb: repr::BasicBlock,\n+                        idx: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            self.tcx, self.mir, ctxt,\n+            Location { block: bb, index: idx },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets<MovePathIndex>,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            self.tcx, self.mir, ctxt,\n+            Location { block: bb, index: statements_len },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut IdxSet<MovePathIndex>,\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        // when a call returns successfully, that means we need to set\n+        // the bits for that dest_lval to 1 (initialized).\n+        let move_path_index = ctxt.move_data.rev_lookup.find(dest_lval);\n+        on_all_children_bits(self.tcx, self.mir, &ctxt.move_data,\n+                             move_path_index,\n+                             |mpi| { in_out.add(&mpi); });\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n+    type Idx = MoveOutIndex;\n+    type Ctxt = MoveDataParamEnv<'tcx>;\n+    fn name() -> &'static str { \"moving_out\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.move_data.moves.len()\n+    }\n+\n+    fn start_block_effect(&self,_move_data: &Self::Ctxt, _sets: &mut BlockSets<MoveOutIndex>) {\n+        // no move-statements have been executed prior to function\n+        // execution, so this method has no effect on `_sets`.\n+    }\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets<MoveOutIndex>,\n+                        bb: repr::BasicBlock,\n+                        idx: usize) {\n+        let (tcx, mir, move_data) = (self.tcx, self.mir, &ctxt.move_data);\n+        let stmt = &mir.basic_block_data(bb).statements[idx];\n+        let loc_map = &move_data.loc_map;\n+        let path_map = &move_data.path_map;\n+        let rev_lookup = &move_data.rev_lookup;\n+\n+        let loc = Location { block: bb, index: idx };\n+        debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n+               stmt, loc, &loc_map[loc]);\n+        for move_index in &loc_map[loc] {\n+            // Every path deinitialized by a *particular move*\n+            // has corresponding bit, \"gen'ed\" (i.e. set)\n+            // here, in dataflow vector\n+            zero_to_one(sets.gen_set.words_mut(), *move_index);\n+        }\n+        let bits_per_block = self.bits_per_block(ctxt);\n+        match stmt.kind {\n+            repr::StatementKind::Assign(ref lvalue, _) => {\n+                // assigning into this `lvalue` kills all\n+                // MoveOuts from it, and *also* all MoveOuts\n+                // for children and associated fragment sets.\n+                let move_path_index = rev_lookup.find(lvalue);\n+                on_all_children_bits(tcx,\n+                                     mir,\n+                                     move_data,\n+                                     move_path_index,\n+                                     |mpi| for moi in &path_map[mpi] {\n+                                         assert!(moi.idx() < bits_per_block);\n+                                         sets.kill_set.add(&moi);\n+                                     });\n+            }\n+        }\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets<MoveOutIndex>,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        let (mir, move_data) = (self.mir, &ctxt.move_data);\n+        let term = mir.basic_block_data(bb).terminator.as_ref().unwrap();\n+        let loc_map = &move_data.loc_map;\n+        let loc = Location { block: bb, index: statements_len };\n+        debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n+               term, loc, &loc_map[loc]);\n+        let bits_per_block = self.bits_per_block(ctxt);\n+        for move_index in &loc_map[loc] {\n+            assert!(move_index.idx() < bits_per_block);\n+            zero_to_one(sets.gen_set.words_mut(), *move_index);\n+        }\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut IdxSet<MoveOutIndex>,\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        let move_data = &ctxt.move_data;\n+        let move_path_index = move_data.rev_lookup.find(dest_lval);\n+        let bits_per_block = self.bits_per_block(ctxt);\n+\n+        let path_map = &move_data.path_map;\n+        on_all_children_bits(self.tcx,\n+                             self.mir,\n+                             move_data,\n+                             move_path_index,\n+                             |mpi| for moi in &path_map[mpi] {\n+                                 assert!(moi.idx() < bits_per_block);\n+                                 in_out.remove(&moi);\n+                             });\n+    }\n+}\n+\n+fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n+    let retval = bitvec.set_bit(move_index.idx());\n+    assert!(retval);\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // moves from both preds are in scope\n+    }\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    }\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    }\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 & pred2 // \"definitely\" means we intersect effects of both preds\n+    }\n+}\n+\n+// The way that dataflow fixed point iteration works, you want to\n+// start at bottom and work your way to a fixed point. Control-flow\n+// merges will apply the `join` operator to each block entry's current\n+// state (which starts at that bottom value).\n+//\n+// This means, for propagation across the graph, that you either want\n+// to start at all-zeroes and then use Union as your merge when\n+// propagating, or you start at all-ones and then use Intersect as\n+// your merge when propagating.\n+\n+impl<'a, 'tcx> DataflowOperator for MovingOutStatements<'a, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = no loans in scope by default\n+    }\n+}\n+\n+impl<'a, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = uninitialized\n+    }\n+}\n+\n+impl<'a, 'tcx> DataflowOperator for MaybeUninitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = initialized (start_block_effect counters this at outset)\n+    }\n+}\n+\n+impl<'a, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        true // bottom = initialized (start_block_effect counters this at outset)\n+    }\n+}"}, {"sha": "b46b6c368a05338ae0e7b0a47e94dbb663ebf94e", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -0,0 +1,491 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::mir::repr::{self, Mir};\n+\n+use std::fmt::Debug;\n+use std::io;\n+use std::mem;\n+use std::path::PathBuf;\n+use std::usize;\n+\n+use super::MirBorrowckCtxtPreDataflow;\n+use super::MoveDataParamEnv;\n+\n+use bitslice::{bitwise, BitwiseOperator};\n+use indexed_set::{Idx, IdxSet, IdxSetBuf};\n+\n+pub use self::sanity_check::sanity_check_via_rustc_peek;\n+pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n+\n+mod graphviz;\n+mod sanity_check;\n+mod impls;\n+\n+pub trait Dataflow<BD: BitDenotation> {\n+    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug;\n+}\n+\n+impl<'a, 'tcx: 'a, BD> Dataflow<BD> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n+    where BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>> + DataflowOperator\n+{\n+    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug {\n+        self.flow_state.build_sets();\n+        self.pre_dataflow_instrumentation(|c,i| p(c,i)).unwrap();\n+        self.flow_state.propagate();\n+        self.post_dataflow_instrumentation(|c,i| p(c,i)).unwrap();\n+    }\n+}\n+\n+struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O>\n+    where O: 'b + BitDenotation, O::Ctxt: 'a\n+{\n+    builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n+    changed: bool,\n+}\n+\n+impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n+    where BD: BitDenotation + DataflowOperator\n+{\n+    fn propagate(&mut self) {\n+        let mut temp = IdxSetBuf::new_empty(self.flow_state.sets.bits_per_block);\n+        let mut propcx = PropagationContext {\n+            builder: self,\n+            changed: true,\n+        };\n+        while propcx.changed {\n+            propcx.changed = false;\n+            propcx.reset(&mut temp);\n+            propcx.walk_cfg(&mut temp);\n+        }\n+    }\n+\n+    fn build_sets(&mut self) {\n+        // First we need to build the entry-, gen- and kill-sets. The\n+        // gather_moves information provides a high-level mapping from\n+        // mir-locations to the MoveOuts (and those correspond\n+        // directly to gen-sets here). But we still need to figure out\n+        // the kill-sets.\n+\n+        {\n+            let sets = &mut self.flow_state.sets.for_block(repr::START_BLOCK.index());\n+            self.flow_state.operator.start_block_effect(&self.ctxt, sets);\n+        }\n+\n+        for bb in self.mir.all_basic_blocks() {\n+            let &repr::BasicBlockData { ref statements,\n+                                        ref terminator,\n+                                        is_cleanup: _ } =\n+                self.mir.basic_block_data(bb);\n+\n+            let sets = &mut self.flow_state.sets.for_block(bb.index());\n+            for j_stmt in 0..statements.len() {\n+                self.flow_state.operator.statement_effect(&self.ctxt, sets, bb, j_stmt);\n+            }\n+\n+            if terminator.is_some() {\n+                let stmts_len = statements.len();\n+                self.flow_state.operator.terminator_effect(&self.ctxt, sets, bb, stmts_len);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD>\n+    where BD: BitDenotation + DataflowOperator\n+{\n+    fn reset(&mut self, bits: &mut IdxSet<BD::Idx>) {\n+        let e = if BD::bottom_value() {!0} else {0};\n+        for b in bits.words_mut() {\n+            *b = e;\n+        }\n+    }\n+\n+    fn walk_cfg(&mut self, in_out: &mut IdxSet<BD::Idx>) {\n+        let mir = self.builder.mir;\n+        for (bb_idx, bb_data) in mir.basic_blocks.iter().enumerate() {\n+            let builder = &mut self.builder;\n+            {\n+                let sets = builder.flow_state.sets.for_block(bb_idx);\n+                debug_assert!(in_out.words().len() == sets.on_entry.words().len());\n+                in_out.clone_from(sets.on_entry);\n+                in_out.union(sets.gen_set);\n+                in_out.subtract(sets.kill_set);\n+            }\n+            builder.propagate_bits_into_graph_successors_of(\n+                in_out, &mut self.changed, (repr::BasicBlock::new(bb_idx), bb_data));\n+        }\n+    }\n+}\n+\n+fn dataflow_path(context: &str, prepost: &str, path: &str) -> PathBuf {\n+    format!(\"{}_{}\", context, prepost);\n+    let mut path = PathBuf::from(path);\n+    let new_file_name = {\n+        let orig_file_name = path.file_name().unwrap().to_str().unwrap();\n+        format!(\"{}_{}\", context, orig_file_name)\n+    };\n+    path.set_file_name(new_file_name);\n+    path\n+}\n+\n+impl<'a, 'tcx: 'a, BD> MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n+    where BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>>\n+{\n+    fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n+        where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug\n+    {\n+        if let Some(ref path_str) = self.print_preflow_to {\n+            let path = dataflow_path(BD::name(), \"preflow\", path_str);\n+            graphviz::print_borrowck_graph_to(self, &path, p)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    fn post_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n+        where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug\n+    {\n+        if let Some(ref path_str) = self.print_postflow_to {\n+            let path = dataflow_path(BD::name(), \"postflow\", path_str);\n+            graphviz::print_borrowck_graph_to(self, &path, p)\n+        } else{\n+            Ok(())\n+        }\n+    }\n+}\n+\n+/// Maps each block to a set of bits\n+#[derive(Debug)]\n+struct Bits<E:Idx> {\n+    bits: IdxSetBuf<E>,\n+}\n+\n+impl<E:Idx> Clone for Bits<E> {\n+    fn clone(&self) -> Self { Bits { bits: self.bits.clone() } }\n+}\n+\n+impl<E:Idx> Bits<E> {\n+    fn new(bits: IdxSetBuf<E>) -> Self {\n+        Bits { bits: bits }\n+    }\n+}\n+\n+pub struct DataflowAnalysis<'a, 'tcx: 'a, O>\n+    where O: BitDenotation, O::Ctxt: 'a\n+{\n+    flow_state: DataflowState<O>,\n+    mir: &'a Mir<'tcx>,\n+    ctxt: &'a O::Ctxt,\n+}\n+\n+impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n+    where O: BitDenotation\n+{\n+    pub fn results(self) -> DataflowResults<O> {\n+        DataflowResults(self.flow_state)\n+    }\n+\n+    pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n+}\n+\n+pub struct DataflowResults<O>(DataflowState<O>) where O: BitDenotation;\n+\n+// FIXME: This type shouldn't be public, but the graphviz::MirWithFlowState trait\n+// references it in a method signature. Look into using `pub(crate)` to address this.\n+pub struct DataflowState<O: BitDenotation>\n+{\n+    /// All the sets for the analysis. (Factored into its\n+    /// own structure so that we can borrow it mutably\n+    /// on its own separate from other fields.)\n+    pub sets: AllSets<O::Idx>,\n+\n+    /// operator used to initialize, combine, and interpret bits.\n+    operator: O,\n+}\n+\n+#[derive(Debug)]\n+pub struct AllSets<E: Idx> {\n+    /// Analysis bitwidth for each block.\n+    bits_per_block: usize,\n+\n+    /// Number of words associated with each block entry\n+    /// equal to bits_per_block / usize::BITS, rounded up.\n+    words_per_block: usize,\n+\n+    /// For each block, bits generated by executing the statements in\n+    /// the block. (For comparison, the Terminator for each block is\n+    /// handled in a flow-specific manner during propagation.)\n+    gen_sets: Bits<E>,\n+\n+    /// For each block, bits killed by executing the statements in the\n+    /// block. (For comparison, the Terminator for each block is\n+    /// handled in a flow-specific manner during propagation.)\n+    kill_sets: Bits<E>,\n+\n+    /// For each block, bits valid on entry to the block.\n+    on_entry_sets: Bits<E>,\n+}\n+\n+pub struct BlockSets<'a, E: Idx> {\n+    on_entry: &'a mut IdxSet<E>,\n+    gen_set: &'a mut IdxSet<E>,\n+    kill_set: &'a mut IdxSet<E>,\n+}\n+\n+impl<'a, E:Idx> BlockSets<'a, E> {\n+    fn gen(&mut self, e: &E) {\n+        self.gen_set.add(e);\n+        self.kill_set.remove(e);\n+    }\n+    fn kill(&mut self, e: &E) {\n+        self.gen_set.remove(e);\n+        self.kill_set.add(e);\n+    }\n+}\n+\n+impl<E:Idx> AllSets<E> {\n+    pub fn bits_per_block(&self) -> usize { self.bits_per_block }\n+    pub fn for_block(&mut self, block_idx: usize) -> BlockSets<E> {\n+        let offset = self.words_per_block * block_idx;\n+        let range = E::new(offset)..E::new(offset + self.words_per_block);\n+        BlockSets {\n+            on_entry: self.on_entry_sets.bits.range_mut(&range),\n+            gen_set: self.gen_sets.bits.range_mut(&range),\n+            kill_set: self.kill_sets.bits.range_mut(&range),\n+        }\n+    }\n+\n+    fn lookup_set_for<'a>(&self, sets: &'a Bits<E>, block_idx: usize) -> &'a IdxSet<E> {\n+        let offset = self.words_per_block * block_idx;\n+        let range = E::new(offset)..E::new(offset + self.words_per_block);\n+        sets.bits.range(&range)\n+    }\n+    pub fn gen_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n+        self.lookup_set_for(&self.gen_sets, block_idx)\n+    }\n+    pub fn kill_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n+        self.lookup_set_for(&self.kill_sets, block_idx)\n+    }\n+    pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n+        self.lookup_set_for(&self.on_entry_sets, block_idx)\n+    }\n+}\n+\n+/// Parameterization for the precise form of data flow that is used.\n+pub trait DataflowOperator: BitwiseOperator {\n+    /// Specifies the initial value for each bit in the `on_entry` set\n+    fn bottom_value() -> bool;\n+}\n+\n+pub trait BitDenotation {\n+    /// Specifies what index type is used to access the bitvector.\n+    type Idx: Idx;\n+\n+    /// Specifies what, if any, separate context needs to be supplied for methods below.\n+    type Ctxt;\n+\n+    /// A name describing the dataflow analysis that this\n+    /// BitDenotation is supporting.  The name should be something\n+    /// suitable for plugging in as part of a filename e.g. avoid\n+    /// space-characters or other things that tend to look bad on a\n+    /// file system, like slashes or periods. It is also better for\n+    /// the name to be reasonably short, again because it will be\n+    /// plugged into a filename.\n+    fn name() -> &'static str;\n+\n+    /// Size of each bitvector allocated for each block in the analysis.\n+    fn bits_per_block(&self, &Self::Ctxt) -> usize;\n+\n+    /// Mutates the block-sets (the flow sets for the given\n+    /// basic block) according to the effects that have been\n+    /// established *prior* to entering the start block.\n+    ///\n+    /// (For example, establishing the call arguments.)\n+    ///\n+    /// (Typically this should only modify `sets.on_entry`, since the\n+    /// gen and kill sets should reflect the effects of *executing*\n+    /// the start block itself.)\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<Self::Idx>);\n+\n+    /// Mutates the block-sets (the flow sets for the given\n+    /// basic block) according to the effects of evaluating statement.\n+    ///\n+    /// This is used, in particular, for building up the\n+    /// \"transfer-function\" represnting the overall-effect of the\n+    /// block, represented via GEN and KILL sets.\n+    ///\n+    /// The statement is identified as `bb_data[idx_stmt]`, where\n+    /// `bb_data` is the sequence of statements identifed by `bb` in\n+    /// the MIR.\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets<Self::Idx>,\n+                        bb: repr::BasicBlock,\n+                        idx_stmt: usize);\n+\n+    /// Mutates the block-sets (the flow sets for the given\n+    /// basic block) according to the effects of evaluating\n+    /// the terminator.\n+    ///\n+    /// This is used, in particular, for building up the\n+    /// \"transfer-function\" represnting the overall-effect of the\n+    /// block, represented via GEN and KILL sets.\n+    ///\n+    /// The effects applied here cannot depend on which branch the\n+    /// terminator took.\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets<Self::Idx>,\n+                         bb: repr::BasicBlock,\n+                         idx_term: usize);\n+\n+    /// Mutates the block-sets according to the (flow-dependent)\n+    /// effect of a successful return from a Call terminator.\n+    ///\n+    /// If basic-block BB_x ends with a call-instruction that, upon\n+    /// successful return, flows to BB_y, then this method will be\n+    /// called on the exit flow-state of BB_x in order to set up the\n+    /// entry flow-state of BB_y.\n+    ///\n+    /// This is used, in particular, as a special case during the\n+    /// \"propagate\" loop where all of the basic blocks are repeatedly\n+    /// visited. Since the effects of a Call terminator are\n+    /// flow-dependent, the current MIR cannot encode them via just\n+    /// GEN and KILL sets attached to the block, and so instead we add\n+    /// this extra machinery to represent the flow-dependent effect.\n+    ///\n+    /// FIXME: Right now this is a bit of a wart in the API. It might\n+    /// be better to represent this as an additional gen- and\n+    /// kill-sets associated with each edge coming out of the basic\n+    /// block.\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut IdxSet<Self::Idx>,\n+                             call_bb: repr::BasicBlock,\n+                             dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue);\n+}\n+\n+impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n+    where D: BitDenotation + DataflowOperator\n+{\n+    pub fn new(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               mir: &'a Mir<'tcx>,\n+               ctxt: &'a D::Ctxt,\n+               denotation: D) -> Self {\n+        let bits_per_block = denotation.bits_per_block(&ctxt);\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n+\n+        // (now rounded up to multiple of word size)\n+        let bits_per_block = words_per_block * usize_bits;\n+\n+        let num_blocks = mir.basic_blocks.len();\n+        let num_overall = num_blocks * bits_per_block;\n+\n+        let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n+        let on_entry = Bits::new(if D::bottom_value() {\n+            IdxSetBuf::new_filled(num_overall)\n+        } else {\n+            IdxSetBuf::new_empty(num_overall)\n+        });\n+\n+        DataflowAnalysis {\n+            ctxt: ctxt,\n+            mir: mir,\n+            flow_state: DataflowState {\n+                sets: AllSets {\n+                    bits_per_block: bits_per_block,\n+                    words_per_block: words_per_block,\n+                    gen_sets: zeroes.clone(),\n+                    kill_sets: zeroes,\n+                    on_entry_sets: on_entry,\n+                },\n+                operator: denotation,\n+            },\n+        }\n+\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n+    where D: BitDenotation + DataflowOperator\n+{\n+    /// Propagates the bits of `in_out` into all the successors of `bb`,\n+    /// using bitwise operator denoted by `self.operator`.\n+    ///\n+    /// For most blocks, this is entirely uniform. However, for blocks\n+    /// that end with a call terminator, the effect of the call on the\n+    /// dataflow state may depend on whether the call returned\n+    /// successfully or unwound.\n+    ///\n+    /// To reflect this, the `propagate_call_return` method of the\n+    /// `BitDenotation` mutates `in_out` when propagating `in_out` via\n+    /// a call terminator; such mutation is performed *last*, to\n+    /// ensure its side-effects do not leak elsewhere (e.g. into\n+    /// unwind target).\n+    fn propagate_bits_into_graph_successors_of(\n+        &mut self,\n+        in_out: &mut IdxSet<D::Idx>,\n+        changed: &mut bool,\n+        (bb, bb_data): (repr::BasicBlock, &repr::BasicBlockData))\n+    {\n+        match bb_data.terminator().kind {\n+            repr::TerminatorKind::Return |\n+            repr::TerminatorKind::Resume => {}\n+            repr::TerminatorKind::Goto { ref target } |\n+            repr::TerminatorKind::Drop { ref target, value: _, unwind: None } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+            }\n+            repr::TerminatorKind::Drop { ref target, value: _, unwind: Some(ref unwind) } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+            }\n+            repr::TerminatorKind::If { ref targets, .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.0);\n+                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.1);\n+            }\n+            repr::TerminatorKind::Switch { ref targets, .. } |\n+            repr::TerminatorKind::SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                }\n+            }\n+            repr::TerminatorKind::Call { ref cleanup, ref destination, func: _, args: _ } => {\n+                if let Some(ref unwind) = *cleanup {\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+                }\n+                if let Some((ref dest_lval, ref dest_bb)) = *destination {\n+                    // N.B.: This must be done *last*, after all other\n+                    // propagation, as documented in comment above.\n+                    self.flow_state.operator.propagate_call_return(\n+                        &self.ctxt, in_out, bb, *dest_bb, dest_lval);\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, dest_bb);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate_bits_into_entry_set_for(&mut self,\n+                                         in_out: &IdxSet<D::Idx>,\n+                                         changed: &mut bool,\n+                                         bb: &repr::BasicBlock) {\n+        let entry_set = self.flow_state.sets.for_block(bb.index()).on_entry;\n+        let set_changed = bitwise(entry_set.words_mut(),\n+                                  in_out.words(),\n+                                  &self.flow_state.operator);\n+        if set_changed {\n+            *changed = true;\n+        }\n+    }\n+}"}, {"sha": "74dc921b0bba55909c9901c3c098c3d5badf535f", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -0,0 +1,172 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::abi::{Abi};\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+use rustc::ty::{self, TyCtxt};\n+use rustc::mir::repr::{self, Mir};\n+\n+use super::super::gather_moves::{MovePathIndex};\n+use super::super::MoveDataParamEnv;\n+use super::BitDenotation;\n+use super::DataflowResults;\n+\n+/// This function scans `mir` for all calls to the intrinsic\n+/// `rustc_peek` that have the expression form `rustc_peek(&expr)`.\n+///\n+/// For each such call, determines what the dataflow bit-state is for\n+/// the L-value corresponding to `expr`; if the bit-state is a 1, then\n+/// that call to `rustc_peek` is ignored by the sanity check. If the\n+/// bit-state is a 0, then this pass emits a error message saying\n+/// \"rustc_peek: bit not set\".\n+///\n+/// The intention is that one can write unit tests for dataflow by\n+/// putting code into a compile-fail test and using `rustc_peek` to\n+/// make observations about the results of dataflow static analyses.\n+///\n+/// (If there are any calls to `rustc_peek` that do not match the\n+/// expression form above, then that emits an error as well, but those\n+/// errors are not intended to be used for unit tests.)\n+pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                mir: &Mir<'tcx>,\n+                                                id: ast::NodeId,\n+                                                _attributes: &[ast::Attribute],\n+                                                flow_ctxt: &O::Ctxt,\n+                                                results: &DataflowResults<O>)\n+    where O: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>, Idx=MovePathIndex>\n+{\n+    debug!(\"sanity_check_via_rustc_peek id: {:?}\", id);\n+    // FIXME: this is not DRY. Figure out way to abstract this and\n+    // `dataflow::build_sets`. (But note it is doing non-standard\n+    // stuff, so such generalization may not be realistic.)\n+\n+    let blocks = mir.all_basic_blocks();\n+    'next_block: for bb in blocks {\n+        each_block(tcx, mir, flow_ctxt, results, bb);\n+    }\n+}\n+\n+fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           mir: &Mir<'tcx>,\n+                           ctxt: &O::Ctxt,\n+                           results: &DataflowResults<O>,\n+                           bb: repr::BasicBlock) where\n+    O: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>, Idx=MovePathIndex>\n+{\n+    let move_data = &ctxt.move_data;\n+    let bb_data = mir.basic_block_data(bb);\n+    let &repr::BasicBlockData { ref statements,\n+                                ref terminator,\n+                                is_cleanup: _ } = bb_data;\n+\n+    let (args, span) = match is_rustc_peek(tcx, terminator) {\n+        Some(args_and_span) => args_and_span,\n+        None => return,\n+    };\n+    assert!(args.len() == 1);\n+    let peek_arg_lval = match args[0] {\n+        repr::Operand::Consume(ref lval @ repr::Lvalue::Temp(_)) => {\n+            lval\n+        }\n+        repr::Operand::Consume(_) |\n+        repr::Operand::Constant(_) => {\n+            tcx.sess.diagnostic().span_err(\n+                span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n+            return;\n+        }\n+    };\n+\n+    let mut entry = results.0.sets.on_entry_set_for(bb.index()).to_owned();\n+    let mut gen = results.0.sets.gen_set_for(bb.index()).to_owned();\n+    let mut kill = results.0.sets.kill_set_for(bb.index()).to_owned();\n+\n+    // Emulate effect of all statements in the block up to (but not\n+    // including) the borrow within `peek_arg_lval`. Do *not* include\n+    // call to `peek_arg_lval` itself (since we are peeking the state\n+    // of the argument at time immediate preceding Call to\n+    // `rustc_peek`).\n+\n+    let mut sets = super::BlockSets { on_entry: &mut entry,\n+                                      gen_set: &mut gen,\n+                                      kill_set: &mut kill };\n+\n+    for (j, stmt) in statements.iter().enumerate() {\n+        debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n+        let (lvalue, rvalue) = match stmt.kind {\n+            repr::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                (lvalue, rvalue)\n+            }\n+        };\n+\n+        if lvalue == peek_arg_lval {\n+            if let repr::Rvalue::Ref(_,\n+                                     repr::BorrowKind::Shared,\n+                                     ref peeking_at_lval) = *rvalue {\n+                // Okay, our search is over.\n+                let peek_mpi = move_data.rev_lookup.find(peeking_at_lval);\n+                let bit_state = sets.on_entry.contains(&peek_mpi);\n+                debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n+                       lvalue, peeking_at_lval, bit_state);\n+                if !bit_state {\n+                    tcx.sess.span_err(span, &format!(\"rustc_peek: bit not set\"));\n+                }\n+                return;\n+            } else {\n+                // Our search should have been over, but the input\n+                // does not match expectations of `rustc_peek` for\n+                // this sanity_check.\n+                let msg = &format!(\"rustc_peek: argument expression \\\n+                                    must be immediate borrow of form `&expr`\");\n+                tcx.sess.span_err(span, msg);\n+            }\n+        }\n+\n+        let lhs_mpi = move_data.rev_lookup.find(lvalue);\n+\n+        debug!(\"rustc_peek: computing effect on lvalue: {:?} ({:?}) in stmt: {:?}\",\n+               lvalue, lhs_mpi, stmt);\n+        // reset GEN and KILL sets before emulating their effect.\n+        for e in sets.gen_set.words_mut() { *e = 0; }\n+        for e in sets.kill_set.words_mut() { *e = 0; }\n+        results.0.operator.statement_effect(ctxt, &mut sets, bb, j);\n+        sets.on_entry.union(sets.gen_set);\n+        sets.on_entry.subtract(sets.kill_set);\n+    }\n+\n+    tcx.sess.span_err(span, &format!(\"rustc_peek: MIR did not match \\\n+                                      anticipated pattern; note that \\\n+                                      rustc_peek expects input of \\\n+                                      form `&expr`\"));\n+}\n+\n+fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           terminator: &'a Option<repr::Terminator<'tcx>>)\n+                           -> Option<(&'a [repr::Operand<'tcx>], Span)> {\n+    if let Some(repr::Terminator { ref kind, span, .. }) = *terminator {\n+        if let repr::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind\n+        {\n+            if let repr::Operand::Constant(ref func) = *oper\n+            {\n+                if let ty::TyFnDef(def_id, _, &ty::BareFnTy { abi, .. }) = func.ty.sty\n+                {\n+                    let name = tcx.item_name(def_id);\n+                    if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+                        if name.as_str() == \"rustc_peek\" {\n+                            return Some((args, span));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    return None;\n+}"}, {"sha": "48511cd5ebc912a04620cd22390c9122540a3cf1", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 96, "deletions": 51, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{FnOutput, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::util::nodemap::FnvHashMap;\n \n@@ -19,8 +19,8 @@ use std::fmt;\n use std::iter;\n use std::ops::Index;\n \n-use super::dataflow::BitDenotation;\n use super::abs_domain::{AbstractElem, Lift};\n+use indexed_set::{Idx};\n \n // This submodule holds some newtype'd Index wrappers that are using\n // NonZero to ensure that Option<Index> occupies only a single word.\n@@ -29,17 +29,21 @@ use super::abs_domain::{AbstractElem, Lift};\n // (which is likely to yield a subtle off-by-one error).\n mod indexes {\n     use core::nonzero::NonZero;\n+    use indexed_set::Idx;\n \n     macro_rules! new_index {\n         ($Index:ident) => {\n-            #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+            #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n             pub struct $Index(NonZero<usize>);\n \n             impl $Index {\n-                pub fn new(idx: usize) -> Self {\n+            }\n+\n+            impl Idx for $Index {\n+                fn new(idx: usize) -> Self {\n                     unsafe { $Index(NonZero::new(idx + 1)) }\n                 }\n-                pub fn idx(&self) -> usize {\n+                fn idx(&self) -> usize {\n                     *self.0 - 1\n                 }\n             }\n@@ -56,6 +60,12 @@ mod indexes {\n pub use self::indexes::MovePathIndex;\n pub use self::indexes::MoveOutIndex;\n \n+impl self::indexes::MoveOutIndex {\n+    pub fn move_path_index(&self, move_data: &MoveData) -> MovePathIndex {\n+        move_data.moves[self.idx()].path\n+    }\n+}\n+\n /// `MovePath` is a canonicalized representation of a path that is\n /// moved or assigned to.\n ///\n@@ -125,6 +135,7 @@ impl<'tcx> fmt::Debug for MovePath<'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n pub struct MoveData<'tcx> {\n     pub move_paths: MovePathData<'tcx>,\n     pub moves: Vec<MoveOut>,\n@@ -133,6 +144,7 @@ pub struct MoveData<'tcx> {\n     pub rev_lookup: MovePathLookup<'tcx>,\n }\n \n+#[derive(Debug)]\n pub struct LocMap {\n     /// Location-indexed (BasicBlock for outer index, index within BB\n     /// for inner index) map to list of MoveOutIndex's.\n@@ -153,6 +165,7 @@ impl Index<Location> for LocMap {\n     }\n }\n \n+#[derive(Debug)]\n pub struct PathMap {\n     /// Path-indexed map to list of MoveOutIndex's.\n     ///\n@@ -187,7 +200,7 @@ impl fmt::Debug for MoveOut {\n     }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct Location {\n     /// block where action is located\n     pub block: BasicBlock,\n@@ -202,10 +215,15 @@ impl fmt::Debug for Location {\n     }\n }\n \n+#[derive(Debug)]\n pub struct MovePathData<'tcx> {\n     move_paths: Vec<MovePath<'tcx>>,\n }\n \n+impl<'tcx> MovePathData<'tcx> {\n+    pub fn len(&self) -> usize { self.move_paths.len() }\n+}\n+\n impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n     type Output = MovePath<'tcx>;\n     fn index(&self, i: MovePathIndex) -> &MovePath<'tcx> {\n@@ -224,6 +242,7 @@ struct MovePathDataBuilder<'a, 'tcx: 'a> {\n }\n \n /// Tables mapping from an l-value to its MovePathIndex.\n+#[derive(Debug)]\n pub struct MovePathLookup<'tcx> {\n     vars: MovePathInverseMap,\n     temps: MovePathInverseMap,\n@@ -272,6 +291,7 @@ impl<T:Clone> FillTo for Vec<T> {\n \n #[derive(Clone, Debug)]\n enum LookupKind { Generate, Reuse }\n+#[derive(Clone, Debug)]\n struct Lookup<T>(LookupKind, T);\n \n impl Lookup<MovePathIndex> {\n@@ -419,7 +439,14 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n         self.rev_lookup.lookup_proj(proj, base_index)\n     }\n \n+    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n+        // Create MovePath for `lval`, discarding returned index.\n+        self.move_path_for(lval);\n+    }\n+\n     fn move_path_for(&mut self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n+        debug!(\"move_path_for({:?})\", lval);\n+\n         let lookup: Lookup<MovePathIndex> = self.lookup(lval);\n \n         // `lookup` is either the previously assigned index or a\n@@ -491,7 +518,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n #[derive(Debug)]\n enum StmtKind {\n     Use, Repeat, Cast, BinaryOp, UnaryOp, Box,\n-    Aggregate, Drop, CallFn, CallArg, Return,\n+    Aggregate, Drop, CallFn, CallArg, Return, If,\n }\n \n fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveData<'tcx> {\n@@ -511,6 +538,27 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n         rev_lookup: MovePathLookup::new(),\n     };\n \n+    // Before we analyze the program text, we create the MovePath's\n+    // for all of the vars, args, and temps. (This enforces a basic\n+    // property that even if the MIR body doesn't contain any\n+    // references to a var/arg/temp, it will still be a valid\n+    // operation to lookup the MovePath associated with it.)\n+    assert!(mir.var_decls.len() <= ::std::u32::MAX as usize);\n+    assert!(mir.arg_decls.len() <= ::std::u32::MAX as usize);\n+    assert!(mir.temp_decls.len() <= ::std::u32::MAX as usize);\n+    for var_idx in 0..mir.var_decls.len() {\n+        let path_idx = builder.move_path_for(&Lvalue::Var(var_idx as u32));\n+        path_map.fill_to(path_idx.idx());\n+    }\n+    for arg_idx in 0..mir.arg_decls.len() {\n+        let path_idx = builder.move_path_for(&Lvalue::Arg(arg_idx as u32));\n+        path_map.fill_to(path_idx.idx());\n+    }\n+    for temp_idx in 0..mir.temp_decls.len() {\n+        let path_idx = builder.move_path_for(&Lvalue::Temp(temp_idx as u32));\n+        path_map.fill_to(path_idx.idx());\n+    }\n+\n     for bb in bbs {\n         let loc_map_bb = &mut loc_map[bb.index()];\n         let bb_data = mir.basic_block_data(bb);\n@@ -521,7 +569,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n         debug_assert!(loc_map_bb.len() == len + 1);\n \n         let mut bb_ctxt = BlockContext {\n-            tcx: tcx,\n+            _tcx: tcx,\n             moves: &mut moves,\n             builder: builder,\n             path_map: &mut path_map,\n@@ -532,8 +580,12 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n             let source = Location { block: bb, index: i };\n             match stmt.kind {\n                 StatementKind::Assign(ref lval, ref rval) => {\n-                    // ensure MovePath created for `lval`.\n-                    bb_ctxt.builder.move_path_for(lval);\n+                    bb_ctxt.builder.create_move_path(lval);\n+\n+                    // Ensure that the path_map contains entries even\n+                    // if the lvalue is assigned and never read.\n+                    let assigned_path = bb_ctxt.builder.move_path_for(lval);\n+                    bb_ctxt.path_map.fill_to(assigned_path.idx());\n \n                     match *rval {\n                         Rvalue::Use(ref operand) => {\n@@ -569,27 +621,45 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                         Rvalue::InlineAsm { .. } => {}\n \n                         Rvalue::Slice {..} => {\n-                            bug!(\"cannot move out of slice\");\n+                            // A slice pattern `x..` binds `x` to a\n+                            // reference; thus no move occurs.\n+                            //\n+                            // FIXME: I recall arielb1 questioning\n+                            // whether this is even a legal thing to\n+                            // have as an R-value. The particular\n+                            // example where I am seeing this arise is\n+                            // `TargetDataLayout::parse(&Session)` in\n+                            // `rustc::ty::layout`.\n+                            //\n+                            // this should be removed soon.\n+                            debug!(\"encountered Rvalue::Slice as RHS of Assign, source: {:?}\",\n+                                   source);\n                         }\n                     }\n                 }\n             }\n         }\n \n+        debug!(\"gather_moves({:?})\", bb_data.terminator());\n         match bb_data.terminator().kind {\n             TerminatorKind::Goto { target: _ } | TerminatorKind::Resume => { }\n \n             TerminatorKind::Return => {\n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n-                let lval = &Lvalue::ReturnPointer.deref();\n-                bb_ctxt.on_move_out_lval(SK::Return, lval, source);\n+                if let FnOutput::FnConverging(_) = bb_ctxt.builder.mir.return_ty {\n+                    debug!(\"gather_moves Return on_move_out_lval return {:?}\", source);\n+                    bb_ctxt.on_move_out_lval(SK::Return, &Lvalue::ReturnPointer, source);\n+                } else {\n+                    debug!(\"gather_moves Return on_move_out_lval \\\n+                            assuming unreachable return {:?}\", source);\n+                }\n             }\n \n             TerminatorKind::If { ref cond, targets: _ } => {\n-                // The `cond` is always of (copyable) type `bool`,\n-                // so there will never be anything to move.\n-                let _ = cond;\n+                let source = Location { block: bb,\n+                                        index: bb_data.statements.len() };\n+                bb_ctxt.on_operand(SK::If, cond, source);\n             }\n \n             TerminatorKind::SwitchInt { switch_ty: _, values: _, targets: _, ref discr } |\n@@ -606,18 +676,23 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                                         index: bb_data.statements.len() };\n                 bb_ctxt.on_move_out_lval(SK::Drop, lval, source);\n             }\n-\n             TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n                 bb_ctxt.on_operand(SK::CallFn, func, source);\n                 for arg in args {\n+                    debug!(\"gather_moves Call on_operand {:?} {:?}\", arg, source);\n                     bb_ctxt.on_operand(SK::CallArg, arg, source);\n                 }\n                 if let Some((ref destination, _bb)) = *destination {\n-                    // Create MovePath for `destination`, then\n-                    // discard returned index.\n-                    bb_ctxt.builder.move_path_for(destination);\n+                    debug!(\"gather_moves Call create_move_path {:?} {:?}\", destination, source);\n+\n+                    // Ensure that the path_map contains entries even\n+                    // if the lvalue is assigned and never read.\n+                    let assigned_path = bb_ctxt.builder.move_path_for(destination);\n+                    bb_ctxt.path_map.fill_to(assigned_path.idx());\n+\n+                    bb_ctxt.builder.create_move_path(destination);\n                 }\n             }\n         }\n@@ -635,7 +710,6 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     //\n     // well you know, lets actually try just asserting that the path map *is* complete.\n     assert_eq!(path_map.len(), builder.pre_move_paths.len());\n-    path_map.fill_to(builder.pre_move_paths.len() - 1);\n \n     let pre_move_paths = builder.pre_move_paths;\n     let move_paths: Vec<_> = pre_move_paths.into_iter()\n@@ -667,7 +741,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n }\n \n struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n-    tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+    _tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     moves: &'b mut Vec<MoveOut>,\n     builder: MovePathDataBuilder<'a, 'tcx>,\n     path_map: &'b mut Vec<Vec<MoveOutIndex>>,\n@@ -679,25 +753,6 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n                         stmt_kind: StmtKind,\n                         lval: &Lvalue<'tcx>,\n                         source: Location) {\n-        let tcx = self.tcx;\n-        let lval_ty = self.builder.mir.lvalue_ty(tcx, lval);\n-\n-        // FIXME: does lvalue_ty ever return TyError, or is it\n-        // guaranteed to always return non-Infer/non-Error values?\n-\n-        // This code is just trying to avoid creating a MoveOut\n-        // entry for values that do not need move semantics.\n-        //\n-        // type_contents is imprecise (may claim needs drop for\n-        // types that in fact have no destructor). But that is\n-        // still usable for our purposes here.\n-        let consumed = lval_ty.to_ty(tcx).type_contents(tcx).needs_drop(tcx);\n-\n-        if !consumed {\n-            debug!(\"ctxt: {:?} no consume of lval: {:?} of type {:?}\",\n-                   stmt_kind, lval, lval_ty);\n-            return;\n-        }\n         let i = source.index;\n         let index = MoveOutIndex::new(self.moves.len());\n \n@@ -732,13 +787,3 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n         }\n     }\n }\n-\n-impl<'tcx> BitDenotation for MoveData<'tcx>{\n-    type Bit = MoveOut;\n-    fn bits_per_block(&self) -> usize {\n-        self.moves.len()\n-    }\n-    fn interpret(&self, idx: usize) -> &Self::Bit {\n-        &self.moves[idx]\n-    }\n-}"}, {"sha": "460c71dee3d721e6f00b1d0cc125ccda7a3ad2c8", "filename": "src/librustc_borrowck/borrowck/mir/graphviz.rs", "status": "removed", "additions": 0, "deletions": 232, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs?ref=da66f2fd8cab261911163ece04d5c15a13cf5e58", "patch": "@@ -1,232 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Hook into libgraphviz for rendering dataflow graphs for MIR.\n-\n-use rustc::mir::repr::{BasicBlock, Mir};\n-\n-use dot;\n-use dot::IntoCow;\n-\n-use std::fs::File;\n-use std::io;\n-use std::io::prelude::*;\n-\n-use super::MirBorrowckCtxt;\n-use bitslice::bits_to_string;\n-use super::gather_moves::MoveOut;\n-\n-struct Graph<'c, 'b:'c, 'a:'b, 'tcx:'a> { mbcx: &'c MirBorrowckCtxt<'b, 'a, 'tcx>,\n-                                          context: &'b str }\n-\n-pub fn print_borrowck_graph_to(mbcx: &MirBorrowckCtxt,\n-                               context: &str,\n-                               path: &str) -> io::Result<()> {\n-    let g = Graph { mbcx: mbcx, context: context };\n-    let mut v = Vec::new();\n-    dot::render(&g, &mut v)?;\n-    println!(\"print_borrowck_graph_to path: {} context: {} node_id: {}\",\n-             path, context, mbcx.node_id);\n-    File::create(path).and_then(|mut f| f.write_all(&v))\n-}\n-\n-pub type Node = BasicBlock;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub struct Edge { source: BasicBlock, index: usize }\n-\n-fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n-    let succ_len = mir.basic_block_data(bb).terminator().successors().len();\n-    (0..succ_len).map(|index| Edge { source: bb, index: index}).collect()\n-}\n-\n-impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n-    type Node = Node;\n-    type Edge = Edge;\n-    fn graph_id(&self) -> dot::Id {\n-        dot::Id::new(format!(\"graph_for_node_{}_{}\",\n-                             self.mbcx.node_id,\n-                             self.context))\n-            .unwrap()\n-    }\n-\n-    fn node_id(&self, n: &Node) -> dot::Id {\n-        dot::Id::new(format!(\"bb_{}\", n.index()))\n-            .unwrap()\n-    }\n-\n-    fn node_label(&self, n: &Node) -> dot::LabelText {\n-        // A standard MIR label, as generated by write_node_label, is\n-        // presented in a single column in a table.\n-        //\n-        // The code below does a bunch of formatting work to format a\n-        // node (i.e. MIR basic-block) label with extra\n-        // dataflow-enriched information.  In particular, the goal is\n-        // to add extra columns that present the three dataflow\n-        // bitvectors, and the data those bitvectors represent.\n-        //\n-        // It presents it in the following format (where I am\n-        // presenting the table rendering via ASCII art, one line per\n-        // row of the table, and a chunk size of 3 rather than 5):\n-        //\n-        // ------  -----------------------  ------------  --------------------\n-        //                    [e1, e3, e4]\n-        //             [e8, e9] \"= ENTRY:\"  <ENTRY-BITS>\n-        // ------  -----------------------  ------------  --------------------\n-        // Left\n-        // Most\n-        // Column\n-        // Is\n-        // Just\n-        // Normal\n-        // Series\n-        // Of\n-        // MIR\n-        // Stmts\n-        // ------  -----------------------  ------------  --------------------\n-        //           [g1, g4, g5] \"= GEN:\"  <GEN-BITS>\n-        // ------  -----------------------  ------------  --------------------\n-        //                         \"KILL:\"  <KILL-BITS>   \"=\" [k1, k3, k8]\n-        //                                                [k9]\n-        // ------  -----------------------  ------------  --------------------\n-        //\n-        // (In addition, the added dataflow is rendered with a colored\n-        // background just so it will stand out compared to the\n-        // statements.)\n-        let mut v = Vec::new();\n-        let i = n.index();\n-        let chunk_size = 5;\n-        const BG_FLOWCONTENT: &'static str = r#\"bgcolor=\"pink\"\"#;\n-        const ALIGN_RIGHT: &'static str = r#\"align=\"right\"\"#;\n-        const FACE_MONOSPACE: &'static str = r#\"FACE=\"Courier\"\"#;\n-        fn chunked_present_left<W:io::Write>(w: &mut W,\n-                                             interpreted: &[&MoveOut],\n-                                             chunk_size: usize)\n-                                             -> io::Result<()>\n-        {\n-            // This function may emit a sequence of <tr>'s, but it\n-            // always finishes with an (unfinished)\n-            // <tr><td></td><td>\n-            //\n-            // Thus, after being called, one should finish both the\n-            // pending <td> as well as the <tr> itself.\n-            let mut seen_one = false;\n-            for c in interpreted.chunks(chunk_size) {\n-                if seen_one {\n-                    // if not the first row, finish off the previous row\n-                    write!(w, \"</td><td></td><td></td></tr>\")?;\n-                }\n-                write!(w, \"<tr><td></td><td {bg} {align}>{objs:?}\",\n-                       bg = BG_FLOWCONTENT,\n-                       align = ALIGN_RIGHT,\n-                       objs = c)?;\n-                seen_one = true;\n-            }\n-            if !seen_one {\n-                write!(w, \"<tr><td></td><td {bg} {align}>[]\",\n-                       bg = BG_FLOWCONTENT,\n-                       align = ALIGN_RIGHT)?;\n-            }\n-            Ok(())\n-        }\n-        ::rustc_mir::graphviz::write_node_label(\n-            *n, self.mbcx.mir, &mut v, 4,\n-            |w| {\n-                let flow = &self.mbcx.flow_state;\n-                let entry = flow.interpret_set(flow.sets.on_entry_set_for(i));\n-                chunked_present_left(w, &entry[..], chunk_size)?;\n-                write!(w, \"= ENTRY:</td><td {bg}><FONT {face}>{entrybits:?}</FONT></td>\\\n-                                        <td></td></tr>\",\n-                       bg = BG_FLOWCONTENT,\n-                       face = FACE_MONOSPACE,\n-                       entrybits=bits_to_string(flow.sets.on_entry_set_for(i),\n-                                                flow.sets.bytes_per_block()))\n-            },\n-            |w| {\n-                let flow = &self.mbcx.flow_state;\n-                let gen = flow.interpret_set( flow.sets.gen_set_for(i));\n-                let kill = flow.interpret_set(flow.sets.kill_set_for(i));\n-                chunked_present_left(w, &gen[..], chunk_size)?;\n-                write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n-                                       <td></td></tr>\",\n-                       bg = BG_FLOWCONTENT,\n-                       face = FACE_MONOSPACE,\n-                       genbits=bits_to_string( flow.sets.gen_set_for(i),\n-                                               flow.sets.bytes_per_block()))?;\n-                write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n-                                        <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n-                       bg = BG_FLOWCONTENT,\n-                       align = ALIGN_RIGHT,\n-                       face = FACE_MONOSPACE,\n-                       killbits=bits_to_string(flow.sets.kill_set_for(i),\n-                                               flow.sets.bytes_per_block()))?;\n-\n-                // (chunked_present_right)\n-                let mut seen_one = false;\n-                for k in kill.chunks(chunk_size) {\n-                    if !seen_one {\n-                        // continuation of row; this is fourth <td>\n-                        write!(w, \"<td {bg}>= {kill:?}</td></tr>\",\n-                               bg = BG_FLOWCONTENT,\n-                               kill=k)?;\n-                    } else {\n-                        // new row, with indent of three <td>'s\n-                        write!(w, \"<tr><td></td><td></td><td></td><td {bg}>{kill:?}</td></tr>\",\n-                               bg = BG_FLOWCONTENT,\n-                               kill=k)?;\n-                    }\n-                    seen_one = true;\n-                }\n-                if !seen_one {\n-                    write!(w, \"<td {bg}>= []</td></tr>\",\n-                           bg = BG_FLOWCONTENT)?;\n-                }\n-\n-                Ok(())\n-            })\n-            .unwrap();\n-        dot::LabelText::html(String::from_utf8(v).unwrap())\n-    }\n-\n-    fn node_shape(&self, _n: &Node) -> Option<dot::LabelText> {\n-        Some(dot::LabelText::label(\"none\"))\n-    }\n-}\n-\n-impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::GraphWalk<'c> for Graph<'c,'b,'a,'tcx> {\n-    type Node = Node;\n-    type Edge = Edge;\n-    fn nodes(&self) -> dot::Nodes<Node> {\n-        self.mbcx.mir.all_basic_blocks().into_cow()\n-    }\n-\n-    fn edges(&self) -> dot::Edges<Edge> {\n-        let mir = self.mbcx.mir;\n-        let blocks = self.mbcx.mir.all_basic_blocks();\n-        // base initial capacity on assumption every block has at\n-        // least one outgoing edge (Which should be true for all\n-        // blocks but one, the exit-block).\n-        let mut edges = Vec::with_capacity(blocks.len());\n-        for bb in blocks {\n-            let outgoing = outgoing(mir, bb);\n-            edges.extend(outgoing.into_iter());\n-        }\n-        edges.into_cow()\n-    }\n-\n-    fn source(&self, edge: &Edge) -> Node {\n-        edge.source\n-    }\n-\n-    fn target(&self, edge: &Edge) -> Node {\n-        let mir = self.mbcx.mir;\n-        mir.basic_block_data(edge.source).terminator().successors()[edge.index]\n-    }\n-}"}, {"sha": "1b9d08bade7c4a798652627ceccf0db9ba977061", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 245, "deletions": 13, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -10,24 +10,53 @@\n \n use borrowck::BorrowckCtxt;\n \n-use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::ast::{self, MetaItem};\n+use syntax::attr::AttrMetaMethods;\n+use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::ptr::P;\n \n use rustc::hir;\n use rustc::hir::intravisit::{FnKind};\n \n+use rustc::mir::repr;\n use rustc::mir::repr::{BasicBlock, BasicBlockData, Mir, Statement, Terminator};\n+use rustc::session::Session;\n+use rustc::ty::{self, TyCtxt};\n \n mod abs_domain;\n mod dataflow;\n mod gather_moves;\n-mod graphviz;\n+// mod graphviz;\n \n-use self::dataflow::{Dataflow, DataflowState};\n-use self::gather_moves::{MoveData};\n+use self::dataflow::{BitDenotation};\n+use self::dataflow::{DataflowOperator};\n+use self::dataflow::{Dataflow, DataflowAnalysis, DataflowResults};\n+use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use self::dataflow::{DefinitelyInitializedLvals};\n+use self::gather_moves::{MoveData, MovePathIndex, Location};\n+use self::gather_moves::{MovePathContent};\n \n-pub fn borrowck_mir<'b, 'a: 'b, 'tcx: 'a>(\n-    bcx: &'b mut BorrowckCtxt<'a, 'tcx>,\n+fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem>> {\n+    for attr in attrs {\n+        if attr.check_name(\"rustc_mir\") {\n+            let items = attr.meta_item_list();\n+            for item in items.iter().flat_map(|l| l.iter()) {\n+                if item.check_name(name) {\n+                    return Some(item.clone())\n+                }\n+            }\n+        }\n+    }\n+    return None;\n+}\n+\n+pub struct MoveDataParamEnv<'tcx> {\n+    move_data: MoveData<'tcx>,\n+    param_env: ty::ParameterEnvironment<'tcx>,\n+}\n+\n+pub fn borrowck_mir<'a, 'tcx: 'a>(\n+    bcx: &mut BorrowckCtxt<'a, 'tcx>,\n     fk: FnKind,\n     _decl: &hir::FnDecl,\n     mir: &'a Mir<'tcx>,\n@@ -45,29 +74,106 @@ pub fn borrowck_mir<'b, 'a: 'b, 'tcx: 'a>(\n         }\n     }\n \n+    let tcx = bcx.tcx;\n+\n+    let move_data = MoveData::gather_moves(mir, tcx);\n+    let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+    let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n+    let flow_inits =\n+        do_dataflow(tcx, mir, id, attributes, &mdpe, MaybeInitializedLvals::new(tcx, mir));\n+    let flow_uninits =\n+        do_dataflow(tcx, mir, id, attributes, &mdpe, MaybeUninitializedLvals::new(tcx, mir));\n+    let flow_def_inits =\n+        do_dataflow(tcx, mir, id, attributes, &mdpe, DefinitelyInitializedLvals::new(tcx, mir));\n+\n+    if has_rustc_mir_with(attributes, \"rustc_peek_maybe_init\").is_some() {\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &mdpe, &flow_inits);\n+    }\n+    if has_rustc_mir_with(attributes, \"rustc_peek_maybe_uninit\").is_some() {\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &mdpe, &flow_uninits);\n+    }\n+    if has_rustc_mir_with(attributes, \"rustc_peek_definite_init\").is_some() {\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &mdpe, &flow_def_inits);\n+    }\n+\n+    if has_rustc_mir_with(attributes, \"stop_after_dataflow\").is_some() {\n+        bcx.tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n+    }\n+\n     let mut mbcx = MirBorrowckCtxt {\n-        flow_state: DataflowState::new_move_analysis(mir, bcx.tcx),\n         bcx: bcx,\n         mir: mir,\n         node_id: id,\n-        attributes: attributes,\n+        move_data: mdpe.move_data,\n+        flow_inits: flow_inits,\n+        flow_uninits: flow_uninits,\n     };\n \n     for bb in mir.all_basic_blocks() {\n         mbcx.process_basic_block(bb);\n     }\n \n-    mbcx.dataflow();\n-\n     debug!(\"borrowck_mir done\");\n }\n \n+fn do_dataflow<'a, 'tcx, BD>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             mir: &Mir<'tcx>,\n+                             node_id: ast::NodeId,\n+                             attributes: &[ast::Attribute],\n+                             ctxt: &BD::Ctxt,\n+                             bd: BD) -> DataflowResults<BD>\n+    where BD: BitDenotation<Idx=MovePathIndex, Ctxt=MoveDataParamEnv<'tcx>> + DataflowOperator\n+{\n+    use syntax::attr::AttrMetaMethods;\n+\n+    let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n+        if let Some(item) = has_rustc_mir_with(attrs, name) {\n+            if let Some(s) = item.value_str() {\n+                return Some(s.to_string())\n+            } else {\n+                sess.span_err(\n+                    item.span,\n+                    &format!(\"{} attribute requires a path\", item.name()));\n+                return None;\n+            }\n+        }\n+        return None;\n+    };\n+\n+    let print_preflow_to =\n+        name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n+    let print_postflow_to =\n+        name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n+\n+    let mut mbcx = MirBorrowckCtxtPreDataflow {\n+        node_id: node_id,\n+        print_preflow_to: print_preflow_to,\n+        print_postflow_to: print_postflow_to,\n+        flow_state: DataflowAnalysis::new(tcx, mir, ctxt, bd),\n+    };\n+\n+    mbcx.dataflow(|ctxt, i| &ctxt.move_data.move_paths[i]);\n+    mbcx.flow_state.results()\n+}\n+\n+\n+pub struct MirBorrowckCtxtPreDataflow<'a, 'tcx: 'a, BD>\n+    where BD: BitDenotation, BD::Ctxt: 'a\n+{\n+    node_id: ast::NodeId,\n+    flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n+    print_preflow_to: Option<String>,\n+    print_postflow_to: Option<String>,\n+}\n+\n+#[allow(dead_code)]\n pub struct MirBorrowckCtxt<'b, 'a: 'b, 'tcx: 'a> {\n     bcx: &'b mut BorrowckCtxt<'a, 'tcx>,\n     mir: &'b Mir<'tcx>,\n     node_id: ast::NodeId,\n-    attributes: &'b [ast::Attribute],\n-    flow_state: DataflowState<MoveData<'tcx>>,\n+    move_data: MoveData<'tcx>,\n+    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n+    flow_uninits: DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>\n }\n \n impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n@@ -89,3 +195,129 @@ impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n         debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?})\", bb, term);\n     }\n }\n+\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+enum DropFlagState {\n+    Present, // i.e. initialized\n+    Absent, // i.e. deinitialized or \"moved\"\n+}\n+\n+fn on_all_children_bits<'a, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    move_data: &MoveData<'tcx>,\n+    move_path_index: MovePathIndex,\n+    mut each_child: F)\n+    where F: FnMut(MovePathIndex)\n+{\n+    fn is_terminal_path<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        move_data: &MoveData<'tcx>,\n+        path: MovePathIndex) -> bool\n+    {\n+        match move_data.move_paths[path].content {\n+            MovePathContent::Lvalue(ref lvalue) => {\n+                match mir.lvalue_ty(tcx, lvalue).to_ty(tcx).sty {\n+                    // don't trace paths past arrays, slices, and\n+                    // pointers. They can only be accessed while\n+                    // their parents are initialized.\n+                    //\n+                    // FIXME: we have to do something for moving\n+                    // slice patterns.\n+                    ty::TyArray(..) | ty::TySlice(..) |\n+                    ty::TyRef(..) | ty::TyRawPtr(..) => true,\n+                    _ => false\n+                }\n+            }\n+            _ => true\n+        }\n+    }\n+\n+    fn on_all_children_bits<'a, 'tcx, F>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        move_data: &MoveData<'tcx>,\n+        move_path_index: MovePathIndex,\n+        each_child: &mut F)\n+        where F: FnMut(MovePathIndex)\n+    {\n+        each_child(move_path_index);\n+\n+        if is_terminal_path(tcx, mir, move_data, move_path_index) {\n+            return\n+        }\n+\n+        let mut next_child_index = move_data.move_paths[move_path_index].first_child;\n+        while let Some(child_index) = next_child_index {\n+            on_all_children_bits(tcx, mir, move_data, child_index, each_child);\n+            next_child_index = move_data.move_paths[child_index].next_sibling;\n+        }\n+    }\n+    on_all_children_bits(tcx, mir, move_data, move_path_index, &mut each_child);\n+}\n+\n+fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    ctxt: &MoveDataParamEnv<'tcx>,\n+    mut callback: F)\n+    where F: FnMut(MovePathIndex, DropFlagState)\n+{\n+    let move_data = &ctxt.move_data;\n+    for i in 0..(mir.arg_decls.len() as u32) {\n+        let lvalue = repr::Lvalue::Arg(i);\n+        let move_path_index = move_data.rev_lookup.find(&lvalue);\n+        on_all_children_bits(tcx, mir, move_data,\n+                             move_path_index,\n+                             |moi| callback(moi, DropFlagState::Present));\n+    }\n+}\n+\n+fn drop_flag_effects_for_location<'a, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    ctxt: &MoveDataParamEnv<'tcx>,\n+    loc: Location,\n+    mut callback: F)\n+    where F: FnMut(MovePathIndex, DropFlagState)\n+{\n+    let move_data = &ctxt.move_data;\n+    let param_env = &ctxt.param_env;\n+    debug!(\"drop_flag_effects_for_location({:?})\", loc);\n+\n+    // first, move out of the RHS\n+    for mi in &move_data.loc_map[loc] {\n+        let path = mi.move_path_index(move_data);\n+        debug!(\"moving out of path {:?}\", move_data.move_paths[path]);\n+\n+        // don't move out of non-Copy things\n+        if let MovePathContent::Lvalue(ref lvalue) = move_data.move_paths[path].content {\n+            let ty = mir.lvalue_ty(tcx, lvalue).to_ty(tcx);\n+            if !ty.moves_by_default(tcx, param_env, DUMMY_SP) {\n+                continue;\n+            }\n+        }\n+\n+        on_all_children_bits(tcx, mir, move_data,\n+                             path,\n+                             |moi| callback(moi, DropFlagState::Absent))\n+    }\n+\n+    let bb = mir.basic_block_data(loc.block);\n+    match bb.statements.get(loc.index) {\n+        Some(stmt) => match stmt.kind {\n+            repr::StatementKind::Assign(ref lvalue, _) => {\n+                debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n+                on_all_children_bits(tcx, mir, move_data,\n+                                     move_data.rev_lookup.find(lvalue),\n+                                     |moi| callback(moi, DropFlagState::Present))\n+            }\n+        },\n+        None => {\n+            // terminator - no move-ins except for function return edge\n+            let term = bb.terminator();\n+            debug!(\"drop_flag_effects: terminator {:?}\", term);\n+        }\n+    }\n+}"}, {"sha": "3fee1dbc0566011314ada3fd0f5e9fc80ea20f90", "filename": "src/librustc_borrowck/indexed_set.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Findexed_set.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -0,0 +1,165 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME: move this to `rustc_data_structures`\n+\n+use std::fmt;\n+use std::marker::PhantomData;\n+use std::mem;\n+use std::ops::{Deref, DerefMut, Range};\n+use bitslice::{BitSlice, Word};\n+use bitslice::{bitwise, Union, Subtract};\n+\n+/// Represents some newtyped `usize` wrapper.\n+///\n+/// (purpose: avoid mixing indexes for different bitvector domains.)\n+pub trait Idx: 'static {\n+    fn new(usize) -> Self;\n+    fn idx(&self) -> usize;\n+}\n+\n+/// Represents a set (or packed family of sets), of some element type\n+/// E, where each E is identified by some unique index type `T`.\n+///\n+/// In other words, `T` is the type used to index into the bitvector\n+/// this type uses to represent the set of object it holds.\n+pub struct IdxSetBuf<T: Idx> {\n+    _pd: PhantomData<fn(&T)>,\n+    bits: Vec<Word>,\n+}\n+\n+impl<T: Idx> Clone for IdxSetBuf<T> {\n+    fn clone(&self) -> Self {\n+        IdxSetBuf { _pd: PhantomData, bits: self.bits.clone() }\n+    }\n+}\n+\n+// pnkfelix wants to have this be `IdxSet<T>([Word]) and then pass\n+// around `&mut IdxSet<T>` or `&IdxSet<T>`.\n+//\n+// WARNING: Mapping a `&IdxSetBuf<T>` to `&IdxSet<T>` (at least today)\n+// requires a transmute relying on representation guarantees that may\n+// not hold in the future.\n+\n+/// Represents a set (or packed family of sets), of some element type\n+/// E, where each E is identified by some unique index type `T`.\n+///\n+/// In other words, `T` is the type used to index into the bitslice\n+/// this type uses to represent the set of object it holds.\n+pub struct IdxSet<T: Idx> {\n+    _pd: PhantomData<fn(&T)>,\n+    bits: [Word],\n+}\n+\n+impl<T: Idx> fmt::Debug for IdxSetBuf<T> {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result { self.bits.fmt(w) }\n+}\n+\n+impl<T: Idx> fmt::Debug for IdxSet<T> {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result { self.bits.fmt(w) }\n+}\n+\n+impl<T: Idx> IdxSetBuf<T> {\n+    fn new(init: Word, universe_size: usize) -> Self {\n+        let bits_per_word = mem::size_of::<Word>() * 8;\n+        let num_words = (universe_size + (bits_per_word - 1)) / bits_per_word;\n+        IdxSetBuf {\n+            _pd: Default::default(),\n+            bits: vec![init; num_words],\n+        }\n+    }\n+\n+    /// Creates set holding every element whose index falls in range 0..universe_size.\n+    pub fn new_filled(universe_size: usize) -> Self {\n+        Self::new(!0, universe_size)\n+    }\n+\n+    /// Creates set holding no elements.\n+    pub fn new_empty(universe_size: usize) -> Self {\n+        Self::new(0, universe_size)\n+    }\n+}\n+\n+impl<T: Idx> IdxSet<T> {\n+    unsafe fn from_slice(s: &[Word]) -> &Self {\n+        mem::transmute(s) // (see above WARNING)\n+    }\n+\n+    unsafe fn from_slice_mut(s: &mut [Word]) -> &mut Self {\n+        mem::transmute(s) // (see above WARNING)\n+    }\n+}\n+\n+impl<T: Idx> Deref for IdxSetBuf<T> {\n+    type Target = IdxSet<T>;\n+    fn deref(&self) -> &IdxSet<T> {\n+        unsafe { IdxSet::from_slice(&self.bits[..]) }\n+    }\n+}\n+\n+impl<T: Idx> DerefMut for IdxSetBuf<T> {\n+    fn deref_mut(&mut self) -> &mut IdxSet<T> {\n+        unsafe { IdxSet::from_slice_mut(&mut self.bits[..]) }\n+    }\n+}\n+\n+impl<T: Idx> IdxSet<T> {\n+    pub fn to_owned(&self) -> IdxSetBuf<T> {\n+        IdxSetBuf {\n+            _pd: Default::default(),\n+            bits: self.bits.to_owned(),\n+        }\n+    }\n+\n+    /// Removes `elem` from the set `self`; returns true iff this changed `self`.\n+    pub fn remove(&mut self, elem: &T) -> bool {\n+        self.bits.clear_bit(elem.idx())\n+    }\n+\n+    /// Adds `elem` to the set `self`; returns true iff this changed `self`.\n+    pub fn add(&mut self, elem: &T) -> bool {\n+        self.bits.set_bit(elem.idx())\n+    }\n+\n+    pub fn range(&self, elems: &Range<T>) -> &Self {\n+        let elems = elems.start.idx()..elems.end.idx();\n+        unsafe { Self::from_slice(&self.bits[elems]) }\n+    }\n+\n+    pub fn range_mut(&mut self, elems: &Range<T>) -> &mut Self {\n+        let elems = elems.start.idx()..elems.end.idx();\n+        unsafe { Self::from_slice_mut(&mut self.bits[elems]) }\n+    }\n+\n+    /// Returns true iff set `self` contains `elem`.\n+    pub fn contains(&self, elem: &T) -> bool {\n+        self.bits.get_bit(elem.idx())\n+    }\n+\n+    pub fn words(&self) -> &[Word] {\n+        &self.bits[..]\n+    }\n+\n+    pub fn words_mut(&mut self) -> &mut [Word] {\n+        &mut self.bits[..]\n+    }\n+\n+    pub fn clone_from(&mut self, other: &IdxSet<T>) {\n+        self.words_mut().clone_from_slice(other.words());\n+    }\n+\n+    pub fn union(&mut self, other: &IdxSet<T>) -> bool {\n+        bitwise(self.words_mut(), other.words(), &Union)\n+    }\n+\n+    pub fn subtract(&mut self, other: &IdxSet<T>) -> bool {\n+        bitwise(self.words_mut(), other.words(), &Subtract)\n+    }\n+}"}, {"sha": "9d7e05ed9fa864d3b4ec48bee6a2a43a6b3ebcd3", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -47,6 +47,7 @@ pub mod diagnostics;\n \n mod borrowck;\n mod bitslice;\n+mod indexed_set;\n \n pub mod graphviz;\n "}, {"sha": "a6bbd55ffa7a4480a85035c87bcf9804e151f36c", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -106,12 +106,9 @@ enum Annotation {\n     ExitScope(ScopeId),\n }\n \n-pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              src: MirSource,\n-                              mir: &Mir<'tcx>,\n-                              w: &mut Write,\n-                              auxiliary: Option<&ScopeAuxiliaryVec>)\n-                              -> io::Result<()> {\n+fn scope_entry_exit_annotations(auxiliary: Option<&ScopeAuxiliaryVec>)\n+                                -> FnvHashMap<Location, Vec<Annotation>>\n+{\n     // compute scope/entry exit annotations\n     let mut annotations = FnvHashMap();\n     if let Some(auxiliary) = auxiliary {\n@@ -129,7 +126,16 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n     }\n+    return annotations;\n+}\n \n+pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              src: MirSource,\n+                              mir: &Mir<'tcx>,\n+                              w: &mut Write,\n+                              auxiliary: Option<&ScopeAuxiliaryVec>)\n+                              -> io::Result<()> {\n+    let annotations = scope_entry_exit_annotations(auxiliary);\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.all_basic_blocks() {\n         write_basic_block(tcx, block, mir, w, &annotations)?;\n@@ -270,6 +276,14 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              mir: &Mir,\n                              w: &mut Write)\n                              -> io::Result<()> {\n+    write_mir_sig(tcx, src, mir, w)?;\n+    writeln!(w, \" {{\")?;\n+    write_mir_decls(tcx, mir, w)\n+}\n+\n+fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n+                 -> io::Result<()>\n+{\n     match src {\n         MirSource::Fn(_) => write!(w, \"fn\")?,\n         MirSource::Const(_) => write!(w, \"const\")?,\n@@ -295,16 +309,18 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // fn return type.\n         match mir.return_ty {\n-            ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", ty)?,\n-            ty::FnOutput::FnDiverging => write!(w, \"!\")?,\n+            ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", ty),\n+            ty::FnOutput::FnDiverging => write!(w, \"!\"),\n         }\n     } else {\n         assert!(mir.arg_decls.is_empty());\n-        write!(w, \": {} =\", mir.return_ty.unwrap())?;\n+        write!(w, \": {} =\", mir.return_ty.unwrap())\n     }\n+}\n \n-    writeln!(w, \" {{\")?;\n-\n+fn write_mir_decls(tcx: TyCtxt, mir: &Mir, w: &mut Write)\n+                   -> io::Result<()>\n+{\n     // User variable types (including the user's name in a comment).\n     for (i, var) in mir.var_decls.iter().enumerate() {\n         let mut_str = if var.mutability == Mutability::Mut {"}, {"sha": "f120e38630b8a4ba486bc855d5df4d3d30bf1000", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -117,6 +117,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                                     param(ccx, 0))\n                  ], ccx.tcx.types.usize)\n             }\n+            \"rustc_peek\" => (1, vec![param(ccx, 0)], param(ccx, 0)),\n             \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1, vec!( param(ccx, 0) ), tcx.mk_nil()),"}, {"sha": "a3ab14b23c7db69edafc5652b919dcb298c77063", "filename": "src/test/compile-fail/mir-dataflow/README.md", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2FREADME.md?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -0,0 +1,53 @@\n+This directory contains unit tests for the MIR-based dataflow\n+analysis.\n+\n+These unit tests check the dataflow analysis by embedding calls to a\n+special `rustc_peek` intrinsic within the code, in tandem with an\n+attribute `#[rustc_mir(rustc_peek_maybe_init)]` (\\*). With that\n+attribute in place, `rustc_peek` calls are a signal to the compiler to\n+lookup the computed dataflow state for the Lvalue corresponding to the\n+argument expression being fed to `rustc_peek`. If the dataflow state\n+for that Lvalue is a 1-bit at that point in the control flow, then no\n+error is emitted by the compiler at that point; if it is a 0-bit, then\n+that invocation of `rustc_peek` will emit an error with the message\n+\"rustc_peek: bit not set\".\n+\n+(\\*): Or `#[rustc_mir(rustc_peek_maybe_uninit)]`, and perhaps other\n+variants in the future.\n+\n+The end effect is that one can write unit tests for MIR dataflow that\n+perform simple-queries of the computed dataflow state, and the tests\n+should be able to be robust in the face of changes to how MIR is\n+represented or constructed.\n+\n+----\n+\n+Sometimes understanding the dataflow results is difficult without\n+looking at the actual MIR control-flow graph being processed with the\n+corresponding GEN and KILL sets.\n+\n+For a graphviz-rendering with dataflow annotations, add the attribute\n+`#[rustc_mir(borrowck_graphviz_postflow=\"/path/to/suffix.dot\")]` to\n+the function in question. (You can change the content of\n+`\"suffix.dot\"` to control the filenames used for the output). This\n+will generate a separate file for each dataflow analysis, adding a\n+prefix (corresponding to the name of the analysis) to the filename in\n+each generated output path.\n+\n+ * For example, the above attribute will currently cause two files to\n+   be generated: `/path/to/maybe_init_suffix.dot` and\n+   `/path/to/maybe_uninit_suffix.dot`.\n+\n+ * The generated `.dot` file shows both the computed dataflow results\n+   on *entry* to each block, as well as the gen- and kill-sets that\n+   were so-called \"transfer functions\" summarizing the effect of each\n+   basic block.\n+\n+ * (In addition to the `borrowck_graphviz_postflow` attribute-key\n+   noted above, there is also `borrowck_graphviz_preflow`; it has the\n+   same interface and generates the same set of files, but it renders\n+   the dataflow state after building the gen- and kill-sets but\n+   *before* running the dataflow analysis itself, so each entry-set is\n+   just the initial default state for that dataflow analysis. This is\n+   less useful for understanding the error message output in these\n+   tests.)"}, {"sha": "a133ddc15f1acb1993177df243055c40ff8fd2cd", "filename": "src/test/compile-fail/mir-dataflow/def-inits-1.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// General test of maybe_uninits state computed by MIR dataflow.\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+\n+use std::intrinsics::rustc_peek;\n+use std::mem::{drop, replace};\n+\n+struct S(i32);\n+\n+#[rustc_mir_borrowck]\n+#[rustc_mir(rustc_peek_definite_init,stop_after_dataflow)]\n+fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n+    let ret;\n+    // `ret` starts off uninitialized\n+    unsafe { rustc_peek(&ret); }  //~ ERROR rustc_peek: bit not set\n+\n+    // All function formal parameters start off initialized.\n+\n+    unsafe { rustc_peek(&x) };\n+    unsafe { rustc_peek(&y) };\n+    unsafe { rustc_peek(&z) };\n+\n+    ret = if test {\n+        ::std::mem::replace(x, y)\n+    } else {\n+        z = y;\n+        z\n+    };\n+\n+    // `z` may be uninitialized here.\n+    unsafe { rustc_peek(&z); } //~ ERROR rustc_peek: bit not set\n+\n+    // `y` is definitely uninitialized here.\n+    unsafe { rustc_peek(&y); } //~ ERROR rustc_peek: bit not set\n+\n+    // `x` is still (definitely) initialized (replace above is a reborrow).\n+    unsafe { rustc_peek(&x); }\n+\n+    ::std::mem::drop(x);\n+\n+    // `x` is *definitely* uninitialized here\n+    unsafe { rustc_peek(&x); } //~ ERROR rustc_peek: bit not set\n+\n+    // `ret` is now definitely initialized (via `if` above).\n+    unsafe { rustc_peek(&ret); }\n+\n+    ret\n+}\n+fn main() {\n+    foo(true, &mut S(13), S(14), S(15));\n+    foo(false, &mut S(13), S(14), S(15));\n+}"}, {"sha": "949688098f62234b856636dea2bf8f4a8e09fd66", "filename": "src/test/compile-fail/mir-dataflow/inits-1.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// General test of maybe_inits state computed by MIR dataflow.\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+\n+use std::intrinsics::rustc_peek;\n+use std::mem::{drop, replace};\n+\n+struct S(i32);\n+\n+#[rustc_mir_borrowck]\n+#[rustc_mir(rustc_peek_maybe_init,stop_after_dataflow)]\n+fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n+    let ret;\n+    // `ret` starts off uninitialized, so we get an error report here.\n+    unsafe { rustc_peek(&ret); }  //~ ERROR rustc_peek: bit not set\n+\n+    // All function formal parameters start off initialized.\n+\n+    unsafe { rustc_peek(&x) };\n+    unsafe { rustc_peek(&y) };\n+    unsafe { rustc_peek(&z) };\n+\n+    ret = if test {\n+        ::std::mem::replace(x, y)\n+    } else {\n+        z = y;\n+        z\n+    };\n+\n+\n+    // `z` may be initialized here.\n+    unsafe { rustc_peek(&z); }\n+\n+    // `y` is definitely uninitialized here.\n+    unsafe { rustc_peek(&y); }  //~ ERROR rustc_peek: bit not set\n+\n+    // `x` is still (definitely) initialized (replace above is a reborrow).\n+    unsafe { rustc_peek(&x); }\n+\n+    ::std::mem::drop(x);\n+\n+    // `x` is *definitely* uninitialized here\n+    unsafe { rustc_peek(&x); } //~ ERROR rustc_peek: bit not set\n+\n+    // `ret` is now definitely initialized (via `if` above).\n+    unsafe { rustc_peek(&ret); }\n+\n+    ret\n+}\n+\n+fn main() {\n+    foo(true, &mut S(13), S(14), S(15));\n+    foo(false, &mut S(13), S(14), S(15));\n+}"}, {"sha": "c13daae24f35dfe33d0d562de6f2b441c55275d5", "filename": "src/test/compile-fail/mir-dataflow/uninits-1.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// General test of maybe_uninits state computed by MIR dataflow.\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+\n+use std::intrinsics::rustc_peek;\n+use std::mem::{drop, replace};\n+\n+struct S(i32);\n+\n+#[rustc_mir_borrowck]\n+#[rustc_mir(rustc_peek_maybe_uninit,stop_after_dataflow)]\n+fn foo(test: bool, x: &mut S, y: S, mut z: S) -> S {\n+    let ret;\n+    // `ret` starts off uninitialized\n+    unsafe { rustc_peek(&ret); }\n+\n+    // All function formal parameters start off initialized.\n+\n+    unsafe { rustc_peek(&x) }; //~ ERROR rustc_peek: bit not set\n+    unsafe { rustc_peek(&y) }; //~ ERROR rustc_peek: bit not set\n+    unsafe { rustc_peek(&z) }; //~ ERROR rustc_peek: bit not set\n+\n+    ret = if test {\n+        ::std::mem::replace(x, y)\n+    } else {\n+        z = y;\n+        z\n+    };\n+\n+    // `z` may be uninitialized here.\n+    unsafe { rustc_peek(&z); }\n+\n+    // `y` is definitely uninitialized here.\n+    unsafe { rustc_peek(&y); }\n+\n+    // `x` is still (definitely) initialized (replace above is a reborrow).\n+    unsafe { rustc_peek(&x); } //~ ERROR rustc_peek: bit not set\n+\n+    ::std::mem::drop(x);\n+\n+    // `x` is *definitely* uninitialized here\n+    unsafe { rustc_peek(&x); }\n+\n+    // `ret` is now definitely initialized (via `if` above).\n+    unsafe { rustc_peek(&ret); } //~ ERROR rustc_peek: bit not set\n+\n+    ret\n+}\n+fn main() {\n+    foo(true, &mut S(13), S(14), S(15));\n+    foo(false, &mut S(13), S(14), S(15));\n+}"}, {"sha": "e0bf42534499ca22d385487e771f24e9994c0414", "filename": "src/test/compile-fail/mir-dataflow/uninits-2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/34fd68668152530dcd1d00865fa8514461b895d7/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34fd68668152530dcd1d00865fa8514461b895d7/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs?ref=34fd68668152530dcd1d00865fa8514461b895d7", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// General test of maybe_uninits state computed by MIR dataflow.\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+\n+use std::intrinsics::rustc_peek;\n+use std::mem::{drop, replace};\n+\n+struct S(i32);\n+\n+#[rustc_mir_borrowck]\n+#[rustc_mir(rustc_peek_maybe_uninit,stop_after_dataflow)]\n+fn foo(x: &mut S) {\n+    // `x` is initialized here, so maybe-uninit bit is 0.\n+\n+    unsafe { *rustc_peek(&x) }; //~ ERROR rustc_peek: bit not set\n+\n+    ::std::mem::drop(x);\n+\n+    // `x` definitely uninitialized here, so maybe-uninit bit is 1.\n+    unsafe { rustc_peek(&x) };\n+}\n+fn main() {\n+    foo(&mut S(13));\n+    foo(&mut S(13));\n+}"}]}