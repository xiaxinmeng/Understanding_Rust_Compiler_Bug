{"sha": "bd04658eb65f0ba78ef2b275312f3311d88017cd", "node_id": "C_kwDOAAsO6NoAKGJkMDQ2NThlYjY1ZjBiYTc4ZWYyYjI3NTMxMmYzMzExZDg4MDE3Y2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-06T06:48:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-06T06:48:15Z"}, "message": "Auto merge of #99743 - compiler-errors:fulfillment-context-cleanups, r=jackh726\n\nSome `FulfillmentContext`-related cleanups\n\nUse `ObligationCtxt` in some places, remove some `FulfillmentContext`s in others...\n\nr? types", "tree": {"sha": "1810260a2769071d271ad8b3b20f5daa5f75b73a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1810260a2769071d271ad8b3b20f5daa5f75b73a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd04658eb65f0ba78ef2b275312f3311d88017cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd04658eb65f0ba78ef2b275312f3311d88017cd", "html_url": "https://github.com/rust-lang/rust/commit/bd04658eb65f0ba78ef2b275312f3311d88017cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd04658eb65f0ba78ef2b275312f3311d88017cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55f46419afd2e49acfc6be176ad4aeadaa5686d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/55f46419afd2e49acfc6be176ad4aeadaa5686d7", "html_url": "https://github.com/rust-lang/rust/commit/55f46419afd2e49acfc6be176ad4aeadaa5686d7"}, {"sha": "f5af266b6d707da0f6a6cf388a93e14e38a8a1ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5af266b6d707da0f6a6cf388a93e14e38a8a1ef", "html_url": "https://github.com/rust-lang/rust/commit/f5af266b6d707da0f6a6cf388a93e14e38a8a1ef"}], "stats": {"total": 290, "additions": 127, "deletions": 163}, "files": [{"sha": "45dadcfff2e5b9a5ebafdeba23b8574ce29eee1c", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -5,12 +5,11 @@\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::LangItem;\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngine;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::{\n-    self, ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngineExt,\n+    self, ImplSource, Obligation, ObligationCause, SelectionContext,\n };\n \n use super::ConstCx;\n@@ -189,15 +188,8 @@ impl Qualif for NeedsNonConstDrop {\n                 return false;\n             }\n \n-            // If we successfully found one, then select all of the predicates\n-            // implied by our const drop impl.\n-            let mut fcx = <dyn TraitEngine<'tcx>>::new(cx.tcx);\n-            for nested in impl_src.nested_obligations() {\n-                fcx.register_predicate_obligation(&infcx, nested);\n-            }\n-\n             // If we had any errors, then it's bad\n-            !fcx.select_all_or_error(&infcx).is_empty()\n+            !traits::fully_solve_obligations(&infcx, impl_src.nested_obligations()).is_empty()\n         })\n     }\n "}, {"sha": "6b230210888503d1c34412684eff79fbacd4f186", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -205,10 +205,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             // At this point, we already have all of the bounds we need. FulfillmentContext is used\n             // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n             // an additional sanity check.\n-            let mut fulfill = <dyn TraitEngine<'tcx>>::new(tcx);\n-            fulfill.register_bound(&infcx, full_env, ty, trait_did, ObligationCause::dummy());\n-            let errors = fulfill.select_all_or_error(&infcx);\n-\n+            let errors =\n+                super::fully_solve_bound(&infcx, ObligationCause::dummy(), full_env, ty, trait_did);\n             if !errors.is_empty() {\n                 panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n             }"}, {"sha": "8ab1aa65d3a9f43dccd5460bbdc5f3dce4af1a1e", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -10,14 +10,14 @@ use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::util::impl_subject_and_oblig;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{\n-    self, FulfillmentContext, Normalized, Obligation, ObligationCause, PredicateObligation,\n-    PredicateObligations, SelectionContext, TraitEngineExt,\n+    self, Normalized, Obligation, ObligationCause, PredicateObligation, PredicateObligations,\n+    SelectionContext,\n };\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::{util, TraitEngine};\n+use rustc_infer::traits::util;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::subst::Subst;\n@@ -302,7 +302,6 @@ fn negative_impl<'cx, 'tcx>(\n         let impl_env = tcx.param_env(impl1_def_id);\n         let subject1 = match traits::fully_normalize(\n             &infcx,\n-            FulfillmentContext::new(),\n             ObligationCause::dummy(),\n             impl_env,\n             tcx.impl_subject(impl1_def_id),\n@@ -385,16 +384,11 @@ fn resolve_negative_obligation<'cx, 'tcx>(\n         return false;\n     };\n \n-    let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-    fulfillment_cx.register_predicate_obligation(infcx, o);\n-\n-    let errors = fulfillment_cx.select_all_or_error(infcx);\n-\n+    let errors = super::fully_solve_obligation(infcx, o);\n     if !errors.is_empty() {\n         return false;\n     }\n \n-    // FIXME -- also add \"assumed to be well formed\" types into the `outlives_env`\n     let outlives_env = OutlivesEnvironment::new(param_env);\n     infcx.process_registered_region_obligations(outlives_env.region_bound_pairs(), param_env);\n "}, {"sha": "e1bd48ba8aca81f5df0702327299483080a72216", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -63,8 +63,7 @@ pub fn can_type_implement_copy<'tcx>(\n                 } else {\n                     ObligationCause::dummy_with_span(span)\n                 };\n-                let ctx = traits::FulfillmentContext::new();\n-                match traits::fully_normalize(&infcx, ctx, cause, param_env, ty) {\n+                match traits::fully_normalize(&infcx, cause, param_env, ty) {\n                     Ok(ty) => {\n                         if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n                             infringing.push((field, ty));"}, {"sha": "2e5400c42d0f840e7f2516ad4adcc315097e1def", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -30,6 +30,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::visit::TypeVisitable;\n@@ -161,22 +162,20 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n         // this function's result remains infallible, we must confirm\n         // that guess. While imperfect, I believe this is sound.\n \n-        // The handling of regions in this area of the code is terrible,\n-        // see issue #29149. We should be able to improve on this with\n-        // NLL.\n-        let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-\n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n         // anyhow).\n         let cause = ObligationCause::misc(span, hir::CRATE_HIR_ID);\n \n-        fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n+        // The handling of regions in this area of the code is terrible,\n+        // see issue #29149. We should be able to improve on this with\n+        // NLL.\n+        let errors = fully_solve_bound(infcx, cause, param_env, ty, def_id);\n \n         // Note: we only assume something is `Copy` if we can\n         // *definitively* show that it implements `Copy`. Otherwise,\n         // assume it is move; linear is always ok.\n-        match fulfill_cx.select_all_or_error(infcx).as_slice() {\n+        match &errors[..] {\n             [] => {\n                 debug!(\n                     \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n@@ -222,15 +221,13 @@ fn do_normalize_predicates<'tcx>(\n     // them here too, and we will remove this function when\n     // we move over to lazy normalization *anyway*.\n     tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n-        let fulfill_cx = FulfillmentContext::new();\n-        let predicates =\n-            match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, predicates) {\n-                Ok(predicates) => predicates,\n-                Err(errors) => {\n-                    let reported = infcx.report_fulfillment_errors(&errors, None, false);\n-                    return Err(reported);\n-                }\n-            };\n+        let predicates = match fully_normalize(&infcx, cause, elaborated_env, predicates) {\n+            Ok(predicates) => predicates,\n+            Err(errors) => {\n+                let reported = infcx.report_fulfillment_errors(&errors, None, false);\n+                return Err(reported);\n+            }\n+        };\n \n         debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n \n@@ -381,9 +378,9 @@ pub fn normalize_param_env_or_error<'tcx>(\n     )\n }\n \n+/// Normalize a type and process all resulting obligations, returning any errors\n pub fn fully_normalize<'a, 'tcx, T>(\n     infcx: &InferCtxt<'a, 'tcx>,\n-    mut fulfill_cx: FulfillmentContext<'tcx>,\n     cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     value: T,\n@@ -399,8 +396,10 @@ where\n         \"fully_normalize: normalized_value={:?} obligations={:?}\",\n         normalized_value, obligations\n     );\n+\n+    let mut fulfill_cx = FulfillmentContext::new();\n     for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n+        fulfill_cx.register_predicate_obligation(infcx, obligation);\n     }\n \n     debug!(\"fully_normalize: select_all_or_error start\");\n@@ -414,6 +413,43 @@ where\n     Ok(resolved_value)\n }\n \n+/// Process an obligation (and any nested obligations that come from it) to\n+/// completion, returning any errors\n+pub fn fully_solve_obligation<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    obligation: PredicateObligation<'tcx>,\n+) -> Vec<FulfillmentError<'tcx>> {\n+    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+    engine.register_predicate_obligation(infcx, obligation);\n+    engine.select_all_or_error(infcx)\n+}\n+\n+/// Process a set of obligations (and any nested obligations that come from them)\n+/// to completion\n+pub fn fully_solve_obligations<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n+) -> Vec<FulfillmentError<'tcx>> {\n+    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+    engine.register_predicate_obligations(infcx, obligations);\n+    engine.select_all_or_error(infcx)\n+}\n+\n+/// Process a bound (and any nested obligations that come from it) to completion.\n+/// This is a convenience function for traits that have no generic arguments, such\n+/// as auto traits, and builtin traits like Copy or Sized.\n+pub fn fully_solve_bound<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    bound: DefId,\n+) -> Vec<FulfillmentError<'tcx>> {\n+    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+    engine.register_bound(infcx, param_env, ty, bound, cause);\n+    engine.select_all_or_error(infcx)\n+}\n+\n /// Normalizes the predicates and checks whether they hold in an empty environment. If this\n /// returns true, then either normalize encountered an error or one of the predicates did not\n /// hold. Used when creating vtables to check for unsatisfiable methods.\n@@ -428,20 +464,13 @@ pub fn impossible_predicates<'tcx>(\n         infcx.set_tainted_by_errors();\n \n         let param_env = ty::ParamEnv::reveal_all();\n-        let mut selcx = SelectionContext::new(&infcx);\n-        let mut fulfill_cx = FulfillmentContext::new();\n-        let cause = ObligationCause::dummy();\n-        let Normalized { value: predicates, obligations } =\n-            normalize(&mut selcx, param_env, cause.clone(), predicates);\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-        }\n+        let ocx = ObligationCtxt::new(&infcx);\n+        let predicates = ocx.normalize(ObligationCause::dummy(), param_env, predicates);\n         for predicate in predicates {\n-            let obligation = Obligation::new(cause.clone(), param_env, predicate);\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+            let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n+            ocx.register_obligation(obligation);\n         }\n-\n-        let errors = fulfill_cx.select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n \n         // Clean up after ourselves\n         let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();"}, {"sha": "f6e196e31414ccc64f54044256fcc90e64108328", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -1,11 +1,9 @@\n use crate::infer::canonical::query_response;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::engine::TraitEngineExt as _;\n+use crate::traits;\n use crate::traits::query::type_op::TypeOpOutput;\n use crate::traits::query::Fallible;\n-use crate::traits::TraitEngine;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n \n use std::fmt;\n@@ -62,8 +60,6 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n ) -> Fallible<(TypeOpOutput<'tcx, Op>, RegionConstraintData<'tcx>)> {\n-    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n     // During NLL, we expect that nobody will register region\n     // obligations **except** as part of a custom type op (and, at the\n     // end of each custom type op, we scrape out the region\n@@ -77,8 +73,7 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     );\n \n     let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n-    fulfill_cx.register_predicate_obligations(infcx, obligations);\n-    let errors = fulfill_cx.select_all_or_error(infcx);\n+    let errors = traits::fully_solve_obligations(infcx, obligations);\n     if !errors.is_empty() {\n         infcx.tcx.sess.diagnostic().delay_span_bug(\n             DUMMY_SP,"}, {"sha": "50e9b95a445fd7e340caf5b697c0c52737c77797", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -8,7 +8,7 @@\n use hir::LangItem;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_infer::traits::TraitEngine;\n+use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n use rustc_lint_defs::builtin::DEREF_INTO_DYN_SUPERTRAIT;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -706,8 +706,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn need_migrate_deref_output_trait_object(\n         &mut self,\n         ty: Ty<'tcx>,\n-        cause: &traits::ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n     ) -> Option<(Ty<'tcx>, DefId)> {\n         let tcx = self.tcx();\n         if tcx.features().trait_upcasting {\n@@ -729,24 +729,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return None;\n         }\n \n-        let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n-        let normalized_ty = fulfillcx.normalize_projection_type(\n-            &self.infcx,\n+        let ty = traits::normalize_projection_type(\n+            self,\n             param_env,\n             ty::ProjectionTy {\n                 item_def_id: tcx.lang_items().deref_target()?,\n                 substs: trait_ref.substs,\n             },\n             cause.clone(),\n-        );\n-\n-        let ty::Dynamic(data, ..) = normalized_ty.kind() else {\n-            return None;\n-        };\n-\n-        let def_id = data.principal_def_id()?;\n-\n-        return Some((normalized_ty, def_id));\n+            0,\n+            // We're *intentionally* throwing these away,\n+            // since we don't actually use them.\n+            &mut vec![],\n+        )\n+        .ty()\n+        .unwrap();\n+\n+        if let ty::Dynamic(data, ..) = ty.kind() {\n+            Some((ty, data.principal_def_id()?))\n+        } else {\n+            None\n+        }\n     }\n \n     /// Searches for unsizing that might apply to `obligation`.\n@@ -809,8 +812,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let Some((deref_output_ty, deref_output_trait_did)) = self\n                             .need_migrate_deref_output_trait_object(\n                                 source,\n-                                &obligation.cause,\n                                 obligation.param_env,\n+                                &obligation.cause,\n                             )\n                         {\n                             if deref_output_trait_did == target_trait_did {"}, {"sha": "0f76fef0eee228168c49a3d5128776dd1338574f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -14,9 +14,7 @@ use specialization_graph::GraphExt;\n \n use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use crate::traits::select::IntercrateAmbiguityCause;\n-use crate::traits::{\n-    self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine, TraitEngineExt,\n-};\n+use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause};\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::{struct_span_err, EmissionGuarantee, LintDiagnosticBuilder};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -26,8 +24,8 @@ use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n use rustc_span::{Span, DUMMY_SP};\n \n+use super::util;\n use super::SelectionContext;\n-use super::{util, FulfillmentContext};\n \n /// Information pertinent to an overlapping impl error.\n #[derive(Debug)]\n@@ -153,7 +151,6 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n     tcx.infer_ctxt().enter(|infcx| {\n         let impl1_trait_ref = match traits::fully_normalize(\n             &infcx,\n-            FulfillmentContext::new(),\n             ObligationCause::dummy(),\n             penv,\n             impl1_trait_ref,\n@@ -211,11 +208,8 @@ fn fulfill_implication<'a, 'tcx>(\n     // (which are packed up in penv)\n \n     infcx.save_and_restore_in_snapshot_flag(|infcx| {\n-        let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-        for oblig in obligations.chain(more_obligations) {\n-            fulfill_cx.register_predicate_obligation(&infcx, oblig);\n-        }\n-        match fulfill_cx.select_all_or_error(infcx).as_slice() {\n+        let errors = traits::fully_solve_obligations(&infcx, obligations.chain(more_obligations));\n+        match &errors[..] {\n             [] => {\n                 debug!(\n                     \"fulfill_implication: an impl for {:?} specializes {:?}\","}, {"sha": "043e21fc1e32b320728035a9963ed879046a1123", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeV\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::misc::{can_type_implement_copy, CopyImplementationError};\n use rustc_trait_selection::traits::predicate_for_trait_def;\n-use rustc_trait_selection::traits::{self, ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::{self, ObligationCause};\n use std::collections::BTreeMap;\n \n pub fn check_trait(tcx: TyCtxt<'_>, trait_def_id: DefId) {\n@@ -109,15 +109,13 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                 // it is not immediately clear why Copy is not implemented for a field, since\n                 // all we point at is the field itself.\n                 tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n-                    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n-                    fulfill_cx.register_bound(\n+                    for error in traits::fully_solve_bound(\n                         &infcx,\n+                        traits::ObligationCause::dummy_with_span(field_ty_span),\n                         param_env,\n                         ty,\n                         tcx.lang_items().copy_trait().unwrap(),\n-                        traits::ObligationCause::dummy_with_span(field_ty_span),\n-                    );\n-                    for error in fulfill_cx.select_all_or_error(&infcx) {\n+                    ) {\n                         let error_predicate = error.obligation.predicate;\n                         // Only note if it's not the root obligation, otherwise it's trivial and\n                         // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n@@ -315,24 +313,20 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                     ))\n                     .emit();\n                 } else {\n-                    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-                    for field in coerced_fields {\n-                        let predicate = predicate_for_trait_def(\n-                            tcx,\n-                            param_env,\n-                            cause.clone(),\n-                            dispatch_from_dyn_trait,\n-                            0,\n-                            field.ty(tcx, substs_a),\n-                            &[field.ty(tcx, substs_b).into()],\n-                        );\n-\n-                        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-                    }\n-\n-                    // Check that all transitive obligations are satisfied.\n-                    let errors = fulfill_cx.select_all_or_error(&infcx);\n+                    let errors = traits::fully_solve_obligations(\n+                        &infcx,\n+                        coerced_fields.into_iter().map(|field| {\n+                            predicate_for_trait_def(\n+                                tcx,\n+                                param_env,\n+                                cause.clone(),\n+                                dispatch_from_dyn_trait,\n+                                0,\n+                                field.ty(tcx, substs_a),\n+                                &[field.ty(tcx, substs_b).into()],\n+                            )\n+                        }),\n+                    );\n                     if !errors.is_empty() {\n                         infcx.report_fulfillment_errors(&errors, None, false);\n                     }\n@@ -573,8 +567,6 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             }\n         };\n \n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_hir_id);\n         let predicate = predicate_for_trait_def(\n@@ -586,10 +578,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             source,\n             &[target.into()],\n         );\n-        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-\n-        // Check that all transitive obligations are satisfied.\n-        let errors = fulfill_cx.select_all_or_error(&infcx);\n+        let errors = traits::fully_solve_obligation(&infcx, predicate);\n         if !errors.is_empty() {\n             infcx.report_fulfillment_errors(&errors, None, false);\n         }"}, {"sha": "fd9715e6ca37481b7f6b038a5838a2ba465abec8", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -3,11 +3,10 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{ForeignItem, ForeignItemKind, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngine;\n use rustc_infer::traits::{ObligationCause, WellFormedLoc};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Region, ToPredicate, TyCtxt, TypeFoldable, TypeFolder};\n-use rustc_trait_selection::traits::{self, TraitEngineExt};\n+use rustc_trait_selection::traits;\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers { diagnostic_hir_wf_check, ..*providers };\n@@ -66,15 +65,14 @@ fn diagnostic_hir_wf_check<'tcx>(\n     impl<'tcx> Visitor<'tcx> for HirWfCheck<'tcx> {\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n             self.tcx.infer_ctxt().enter(|infcx| {\n-                let mut fulfill = <dyn TraitEngine<'tcx>>::new(self.tcx);\n                 let tcx_ty =\n                     self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n                 let cause = traits::ObligationCause::new(\n                     ty.span,\n                     self.hir_id,\n                     traits::ObligationCauseCode::WellFormed(None),\n                 );\n-                fulfill.register_predicate_obligation(\n+                let errors = traits::fully_solve_obligation(\n                     &infcx,\n                     traits::Obligation::new(\n                         cause,\n@@ -83,8 +81,6 @@ fn diagnostic_hir_wf_check<'tcx>(\n                             .to_predicate(self.tcx),\n                     ),\n                 );\n-\n-                let errors = fulfill.select_all_or_error(&infcx);\n                 if !errors.is_empty() {\n                     debug!(\"Wf-check got errors for {:?}: {:?}\", ty, errors);\n                     for error in errors {"}, {"sha": "1563f3552c54133457088b77ce526b58e8fc8139", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 12, "deletions": 35, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -104,19 +104,15 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Node, CRATE_HIR_ID};\n use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util;\n use rustc_session::config::EntryFnType;\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt as _,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use std::iter;\n \n@@ -148,18 +144,15 @@ fn require_same_types<'tcx>(\n ) -> bool {\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty();\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        match infcx.at(cause, param_env).eq(expected, actual) {\n-            Ok(InferOk { obligations, .. }) => {\n-                fulfill_cx.register_predicate_obligations(infcx, obligations);\n-            }\n+        let errors = match infcx.at(cause, param_env).eq(expected, actual) {\n+            Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n             Err(err) => {\n                 infcx.report_mismatched_types(cause, expected, actual, err).emit();\n                 return false;\n             }\n-        }\n+        };\n \n-        match fulfill_cx.select_all_or_error(infcx).as_slice() {\n+        match &errors[..] {\n             [] => true,\n             errors => {\n                 infcx.report_fulfillment_errors(errors, None, false);\n@@ -303,7 +296,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     }\n \n     let expected_return_type;\n-    if let Some(term_id) = tcx.lang_items().termination() {\n+    if let Some(term_did) = tcx.lang_items().termination() {\n         let return_ty = main_fnsig.output();\n         let return_ty_span = main_fn_return_type_span(tcx, main_def_id).unwrap_or(main_span);\n         if !return_ty.bound_vars().is_empty() {\n@@ -314,33 +307,17 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let return_ty = return_ty.skip_binder();\n         tcx.infer_ctxt().enter(|infcx| {\n+            // Main should have no WC, so empty param env is OK here.\n+            let param_env = ty::ParamEnv::empty();\n             let cause = traits::ObligationCause::new(\n                 return_ty_span,\n                 main_diagnostics_hir_id,\n                 ObligationCauseCode::MainFunctionType,\n             );\n-            let mut fulfillment_cx = traits::FulfillmentContext::new();\n-            // normalize any potential projections in the return type, then add\n-            // any possible obligations to the fulfillment context.\n-            // HACK(ThePuzzlemaker) this feels symptomatic of a problem within\n-            // checking trait fulfillment, not this here. I'm not sure why it\n-            // works in the example in `fn test()` given in #88609? This also\n-            // probably isn't the best way to do this.\n-            let InferOk { value: norm_return_ty, obligations } = infcx\n-                .partially_normalize_associated_types_in(\n-                    cause.clone(),\n-                    ty::ParamEnv::empty(),\n-                    return_ty,\n-                );\n-            fulfillment_cx.register_predicate_obligations(&infcx, obligations);\n-            fulfillment_cx.register_bound(\n-                &infcx,\n-                ty::ParamEnv::empty(),\n-                norm_return_ty,\n-                term_id,\n-                cause,\n-            );\n-            let errors = fulfillment_cx.select_all_or_error(&infcx);\n+            let ocx = traits::ObligationCtxt::new(&infcx);\n+            let norm_return_ty = ocx.normalize(cause.clone(), param_env, return_ty);\n+            ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n+            let errors = ocx.select_all_or_error();\n             if !errors.is_empty() {\n                 infcx.report_fulfillment_errors(&errors, None, false);\n                 error = true;"}, {"sha": "ef7d75aa8ed9b56a264ace501e0e36e21426d9e5", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd04658eb65f0ba78ef2b275312f3311d88017cd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd04658eb65f0ba78ef2b275312f3311d88017cd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=bd04658eb65f0ba78ef2b275312f3311d88017cd", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::{EarlyBinder, Opaque, PredicateKind::Trait};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n-use rustc_trait_selection::traits::{self, FulfillmentError, TraitEngine};\n+use rustc_trait_selection::traits::{self, FulfillmentError};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -80,9 +80,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                 let span = decl.output.span();\n                 let send_errors = cx.tcx.infer_ctxt().enter(|infcx| {\n                     let cause = traits::ObligationCause::misc(span, hir_id);\n-                    let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                    fulfillment_cx.register_bound(&infcx, cx.param_env, ret_ty, send_trait, cause);\n-                    fulfillment_cx.select_all_or_error(&infcx)\n+                    traits::fully_solve_bound(&infcx, cause, cx.param_env, ret_ty, send_trait)\n                 });\n                 if !send_errors.is_empty() {\n                     span_lint_and_then("}]}