{"sha": "9c15de4fd59bee290848b5443c7e194fd5afb02c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMTVkZTRmZDU5YmVlMjkwODQ4YjU0NDNjN2UxOTRmZDVhZmIwMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-19T10:56:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-19T10:56:08Z"}, "message": "Auto merge of #40346 - jseyfried:path_and_tokenstream_attr, r=nrc\n\n`TokenStream`-based attributes, paths in attribute and derive macro invocations\n\nThis PR\n - refactors `Attribute` to use  `Path` and `TokenStream` instead of `MetaItem`.\n - supports macro invocation paths for attribute procedural macros.\n   - e.g. `#[::foo::attr_macro] struct S;`, `#[cfg_attr(all(), foo::attr_macro)] struct S;`\n - supports macro invocation paths for derive procedural macros.\n   - e.g. `#[derive(foo::Bar, super::Baz)] struct S;`\n - supports arbitrary tokens as arguments to attribute procedural macros.\n   - e.g. `#[foo::attr_macro arbitrary + tokens] struct S;`\n - supports using arbitrary tokens in \"inert attributes\" with derive procedural macros.\n   - e.g. `#[derive(Foo)] struct S(#[inert arbitrary + tokens] i32);`\nwhere `#[proc_macro_derive(Foo, attributes(inert))]`\n\nr? @nrc", "tree": {"sha": "fb3ddd382a56f1f6ce7fcecdb9c45fcc6032b352", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb3ddd382a56f1f6ce7fcecdb9c45fcc6032b352"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c15de4fd59bee290848b5443c7e194fd5afb02c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c15de4fd59bee290848b5443c7e194fd5afb02c", "html_url": "https://github.com/rust-lang/rust/commit/9c15de4fd59bee290848b5443c7e194fd5afb02c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c15de4fd59bee290848b5443c7e194fd5afb02c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfc49b1092512aee4fe3d1348c3250fcdc8978d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfc49b1092512aee4fe3d1348c3250fcdc8978d3", "html_url": "https://github.com/rust-lang/rust/commit/bfc49b1092512aee4fe3d1348c3250fcdc8978d3"}, {"sha": "85e02bdbfcfd0e38def7656a8295a5260640fd4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/85e02bdbfcfd0e38def7656a8295a5260640fd4a", "html_url": "https://github.com/rust-lang/rust/commit/85e02bdbfcfd0e38def7656a8295a5260640fd4a"}], "stats": {"total": 1422, "additions": 883, "deletions": 539}, "files": [{"sha": "54ae947214091653c329807a603495f7992ea099", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -120,11 +120,12 @@ impl<'a> CheckAttrVisitor<'a> {\n     }\n \n     fn check_attribute(&self, attr: &ast::Attribute, target: Target) {\n-        let name: &str = &attr.name().as_str();\n-        match name {\n-            \"inline\" => self.check_inline(attr, target),\n-            \"repr\" => self.check_repr(attr, target),\n-            _ => (),\n+        if let Some(name) = attr.name() {\n+            match &*name.as_str() {\n+                \"inline\" => self.check_inline(attr, target),\n+                \"repr\" => self.check_repr(attr, target),\n+                _ => (),\n+            }\n         }\n     }\n }"}, {"sha": "d966f4899e50fc9c0556d1dd93f7751fc97644d1", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -1296,7 +1296,7 @@ impl<'a> LoweringContext<'a> {\n         let attrs = self.lower_attrs(&i.attrs);\n         let mut vis = self.lower_visibility(&i.vis);\n         if let ItemKind::MacroDef(ref tts) = i.node {\n-            if i.attrs.iter().any(|attr| attr.name() == \"macro_export\") {\n+            if i.attrs.iter().any(|attr| attr.path == \"macro_export\") {\n                 self.exported_macros.push(hir::MacroDef {\n                     name: name, attrs: attrs, id: i.id, span: i.span, body: tts.clone().into(),\n                 });"}, {"sha": "843f3a53f33e5c9500b9244563a13d138c605a78", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -408,14 +408,14 @@ pub fn gather_attrs(attrs: &[ast::Attribute]) -> Vec<Result<(ast::Name, Level, S\n pub fn gather_attr(attr: &ast::Attribute) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n     let mut out = vec![];\n \n-    let level = match Level::from_str(&attr.name().as_str()) {\n+    let level = match attr.name().and_then(|name| Level::from_str(&name.as_str())) {\n         None => return out,\n         Some(lvl) => lvl,\n     };\n \n+    let meta = unwrap_or!(attr.meta(), return out);\n     attr::mark_used(attr);\n \n-    let meta = &attr.value;\n     let metas = if let Some(metas) = meta.meta_item_list() {\n         metas\n     } else {"}, {"sha": "1fb537140257465eae43371f32b7b78eead2c4bf", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n         } else {\n             // Emit errors for non-staged-api crates.\n             for attr in attrs {\n-                let tag = attr.name();\n+                let tag = unwrap_or!(attr.name(), continue);\n                 if tag == \"unstable\" || tag == \"stable\" || tag == \"rustc_deprecated\" {\n                     attr::mark_used(attr);\n                     self.tcx.sess.span_err(attr.span(), \"stability attributes may not be used \\\n@@ -402,7 +402,7 @@ impl<'a, 'tcx> Index<'tcx> {\n \n         let mut is_staged_api = false;\n         for attr in &krate.attrs {\n-            if attr.name() == \"stable\" || attr.name() == \"unstable\" {\n+            if attr.path == \"stable\" || attr.path == \"unstable\" {\n                 is_staged_api = true;\n                 break\n             }"}, {"sha": "27525d550ff209e9e2f86354d31d7efa02e95461", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .filter(|a| a.check_name(\"rustc_on_unimplemented\"))\n             .next()\n         {\n-            let err_sp = item.meta().span.substitute_dummy(span);\n+            let err_sp = item.span.substitute_dummy(span);\n             let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n             if let Some(istring) = item.value_str() {\n                 let istring = &*istring.as_str();"}, {"sha": "fac49b29598aa0cb31feb4370f989e1f69e3b2fb", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 14, "deletions": 41, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -18,16 +18,15 @@ use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::parse::token;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::InternedString;\n use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::tokenstream;\n use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit as visit;\n+use rustc::hir::intravisit::{self as visit, Visitor};\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv;\n use std::hash::{Hash, Hasher};\n \n use super::def_path_hash::DefPathHashes;\n@@ -559,7 +558,7 @@ macro_rules! hash_span {\n     });\n }\n \n-impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n+impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> visit::NestedVisitorMap<'this, 'tcx> {\n         if self.hash_bodies {\n             visit::NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n@@ -960,50 +959,24 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         }\n     }\n \n-    fn hash_meta_item(&mut self, meta_item: &ast::MetaItem) {\n-        debug!(\"hash_meta_item: st={:?}\", self.st);\n-\n-        // ignoring span information, it doesn't matter here\n-        self.hash_discriminant(&meta_item.node);\n-        meta_item.name.as_str().len().hash(self.st);\n-        meta_item.name.as_str().hash(self.st);\n-\n-        match meta_item.node {\n-            ast::MetaItemKind::Word => {}\n-            ast::MetaItemKind::NameValue(ref lit) => saw_lit(lit).hash(self.st),\n-            ast::MetaItemKind::List(ref items) => {\n-                // Sort subitems so the hash does not depend on their order\n-                let indices = self.indices_sorted_by(&items, |p| {\n-                    (p.name().map(Symbol::as_str), fnv::hash(&p.literal().map(saw_lit)))\n-                });\n-                items.len().hash(self.st);\n-                for (index, &item_index) in indices.iter().enumerate() {\n-                    index.hash(self.st);\n-                    let nested_meta_item: &ast::NestedMetaItemKind = &items[item_index].node;\n-                    self.hash_discriminant(nested_meta_item);\n-                    match *nested_meta_item {\n-                        ast::NestedMetaItemKind::MetaItem(ref meta_item) => {\n-                            self.hash_meta_item(meta_item);\n-                        }\n-                        ast::NestedMetaItemKind::Literal(ref lit) => {\n-                            saw_lit(lit).hash(self.st);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn hash_attributes(&mut self, attributes: &[ast::Attribute]) {\n         debug!(\"hash_attributes: st={:?}\", self.st);\n         let indices = self.indices_sorted_by(attributes, |attr| attr.name());\n \n         for i in indices {\n             let attr = &attributes[i];\n-            if !attr.is_sugared_doc &&\n-               !IGNORED_ATTRIBUTES.contains(&&*attr.value.name().as_str()) {\n+            match attr.name() {\n+                Some(name) if IGNORED_ATTRIBUTES.contains(&&*name.as_str()) => continue,\n+                _ => {}\n+            };\n+            if !attr.is_sugared_doc {\n                 SawAttribute(attr.style).hash(self.st);\n-                self.hash_meta_item(&attr.value);\n+                for segment in &attr.path.segments {\n+                    SawIdent(segment.identifier.name.as_str()).hash(self.st);\n+                }\n+                for tt in attr.tokens.trees() {\n+                    self.hash_token_tree(&tt);\n+                }\n             }\n         }\n     }"}, {"sha": "929249df0b173a15a544b7c417f77635e409c39d", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -104,9 +104,9 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n-        for item in attr.meta_item_list().unwrap_or(&[]) {\n+        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(LABEL) {\n-                let value = expect_associated_value(self.tcx, item);\n+                let value = expect_associated_value(self.tcx, &item);\n                 match DepNode::from_label_string(&value.as_str(), def_id) {\n                     Ok(def_id) => return def_id,\n                     Err(()) => {\n@@ -331,9 +331,9 @@ fn check_config(tcx: TyCtxt, attr: &Attribute) -> bool {\n     debug!(\"check_config(attr={:?})\", attr);\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n-    for item in attr.meta_item_list().unwrap_or(&[]) {\n+    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n         if item.check_name(CFG) {\n-            let value = expect_associated_value(tcx, item);\n+            let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n             return config.contains(&(value, None));\n         }"}, {"sha": "f0276f90f274d6d99ffa2f37b88512c1481a2b37", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -312,7 +312,7 @@ impl MissingDoc {\n             }\n         }\n \n-        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n+        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.check_name(\"doc\"));\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS,\n                          sp,\n@@ -635,7 +635,7 @@ impl LintPass for DeprecatedAttr {\n \n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext, attr: &ast::Attribute) {\n-        let name = attr.name();\n+        let name = unwrap_or!(attr.name(), return);\n         for &&(n, _, ref g) in &self.depr_attrs {\n             if name == n {\n                 if let &AttributeGate::Gated(Stability::Deprecated(link),\n@@ -1121,8 +1121,8 @@ impl LintPass for UnstableFeatures {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     fn check_attribute(&mut self, ctx: &LateContext, attr: &ast::Attribute) {\n-        if attr.meta().check_name(\"feature\") {\n-            if let Some(items) = attr.meta().meta_item_list() {\n+        if attr.check_name(\"feature\") {\n+            if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n                     ctx.span_lint(UNSTABLE_FEATURES, item.span(), \"unstable feature\");\n                 }"}, {"sha": "05dbbc09870252abaa963e49025a924c7fe81861", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -38,6 +38,7 @@\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n \n+#[macro_use]\n extern crate syntax;\n #[macro_use]\n extern crate rustc;"}, {"sha": "abba8afd9da8699f33f5a4691fd4ede7a5477619", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -269,6 +269,7 @@ impl LintPass for UnusedAttributes {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n     fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n         debug!(\"checking attribute: {:?}\", attr);\n+        let name = unwrap_or!(attr.name(), return);\n \n         // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty, _) in BUILTIN_ATTRIBUTES {\n@@ -294,13 +295,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n             let known_crate = BUILTIN_ATTRIBUTES.iter()\n-                .find(|&&(name, ty, _)| attr.name() == name && ty == AttributeType::CrateLevel)\n+                .find(|&&(builtin, ty, _)| name == builtin && ty == AttributeType::CrateLevel)\n                 .is_some();\n \n             // Has a plugin registered this attribute as one which must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                .find(|&&(ref x, t)| attr.name() == &**x && AttributeType::CrateLevel == t)\n+                .find(|&&(ref x, t)| name == &**x && AttributeType::CrateLevel == t)\n                 .is_some();\n             if known_crate || plugin_crate {\n                 let msg = match attr.style {"}, {"sha": "5af4db6041115b8bba881e6e6b6d9cdacc9c02a8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -973,9 +973,11 @@ impl<'a> CrateLoader<'a> {\n \n impl<'a> CrateLoader<'a> {\n     pub fn preprocess(&mut self, krate: &ast::Crate) {\n-        for attr in krate.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-            if let Some(linkarg) = attr.value_str() {\n-                self.cstore.add_used_link_args(&linkarg.as_str());\n+        for attr in &krate.attrs {\n+            if attr.path == \"link_args\" {\n+                if let Some(linkarg) = attr.value_str() {\n+                    self.cstore.add_used_link_args(&linkarg.as_str());\n+                }\n             }\n         }\n     }"}, {"sha": "17a6a706e0aaa1be559afd5d05406d9b0a1fc6bc", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -269,9 +269,12 @@ impl CrateMetadata {\n     }\n \n     pub fn is_staged_api(&self) -> bool {\n-        self.get_item_attrs(CRATE_DEF_INDEX)\n-            .iter()\n-            .any(|attr| attr.name() == \"stable\" || attr.name() == \"unstable\")\n+        for attr in self.get_item_attrs(CRATE_DEF_INDEX) {\n+            if attr.path == \"stable\" || attr.path == \"unstable\" {\n+                return true;\n+            }\n+        }\n+        false\n     }\n \n     pub fn is_allocator(&self) -> bool {"}, {"sha": "8c45a6669453354fdfcbe5b9202502f2f9a7d545", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -241,12 +241,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n                 attr::first_attr_value_str_by_name(&item.attrs, \"path\");\n-                if let Some(attr) =\n-                        item.attrs.iter().find(|attr| attr.name() == \"warn_directory_ownership\") {\n+                if item.attrs.iter().any(|attr| attr.check_name(\"warn_directory_ownership\")) {\n                     let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n                     let msg = \"cannot declare a new module at this location\";\n                     self.session.add_lint(lint, item.id, item.span, msg.to_string());\n-                    attr::mark_used(attr);\n                 }\n             }\n             ItemKind::Union(ref vdata, _) => {"}, {"sha": "f832e0f9a4811146e7f83cb2e57b1396b29b2de2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -1165,6 +1165,7 @@ pub struct Resolver<'a> {\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n     ambiguity_errors: Vec<AmbiguityError<'a>>,\n+    gated_errors: FxHashSet<Span>,\n     disallowed_shadowing: Vec<&'a LegacyBinding<'a>>,\n \n     arenas: &'a ResolverArenas<'a>,\n@@ -1355,6 +1356,7 @@ impl<'a> Resolver<'a> {\n \n             privacy_errors: Vec::new(),\n             ambiguity_errors: Vec::new(),\n+            gated_errors: FxHashSet(),\n             disallowed_shadowing: Vec::new(),\n \n             arenas: arenas,\n@@ -3359,8 +3361,9 @@ impl<'a> Resolver<'a> {\n         if self.proc_macro_enabled { return; }\n \n         for attr in attrs {\n-            let maybe_binding = self.builtin_macros.get(&attr.name()).cloned().or_else(|| {\n-                let ident = Ident::with_empty_ctxt(attr.name());\n+            let name = unwrap_or!(attr.name(), continue);\n+            let maybe_binding = self.builtin_macros.get(&name).cloned().or_else(|| {\n+                let ident = Ident::with_empty_ctxt(name);\n                 self.resolve_lexical_macro_path_segment(ident, MacroNS, None).ok()\n             });\n "}, {"sha": "df3be8fa0f810cb22bc639830b0f88776a0a1295", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -28,8 +28,11 @@ use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n use syntax::fold::{self, Folder};\n+use syntax::parse::parser::PathStyle;\n+use syntax::parse::token::{self, Token};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n+use syntax::tokenstream::{TokenStream, TokenTree, Delimited};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -179,12 +182,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>)\n                               -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n+            let name = unwrap_or!(attrs[i].name(), continue);\n+\n             if self.session.plugin_attributes.borrow().iter()\n-                    .any(|&(ref attr_nm, _)| attrs[i].name() == &**attr_nm) {\n+                    .any(|&(ref attr_nm, _)| name == &**attr_nm) {\n                 attr::mark_known(&attrs[i]);\n             }\n \n-            match self.builtin_macros.get(&attrs[i].name()).cloned() {\n+            match self.builtin_macros.get(&name).cloned() {\n                 Some(binding) => match *binding.get_macro(self) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n@@ -197,17 +202,25 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         // Check for legacy derives\n         for i in 0..attrs.len() {\n-            if attrs[i].name() == \"derive\" {\n-                let mut traits = match attrs[i].meta_item_list() {\n-                    Some(traits) if !traits.is_empty() => traits.to_owned(),\n-                    _ => continue,\n+            let name = unwrap_or!(attrs[i].name(), continue);\n+\n+            if name == \"derive\" {\n+                let result = attrs[i].parse_list(&self.session.parse_sess,\n+                                                 |parser| parser.parse_path(PathStyle::Mod));\n+                let mut traits = match result {\n+                    Ok(traits) => traits,\n+                    Err(mut e) => {\n+                        e.cancel();\n+                        continue\n+                    }\n                 };\n \n                 for j in 0..traits.len() {\n-                    let legacy_name = Symbol::intern(&match traits[j].word() {\n-                        Some(..) => format!(\"derive_{}\", traits[j].name().unwrap()),\n-                        None => continue,\n-                    });\n+                    if traits[j].segments.len() > 1 {\n+                        continue\n+                    }\n+                    let trait_name = traits[j].segments[0].identifier.name;\n+                    let legacy_name = Symbol::intern(&format!(\"derive_{}\", trait_name));\n                     if !self.builtin_macros.contains_key(&legacy_name) {\n                         continue\n                     }\n@@ -216,18 +229,27 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     if traits.is_empty() {\n                         attrs.remove(i);\n                     } else {\n-                        attrs[i].value = ast::MetaItem {\n-                            name: attrs[i].name(),\n-                            span: attrs[i].span,\n-                            node: ast::MetaItemKind::List(traits),\n-                        };\n+                        let mut tokens = Vec::new();\n+                        for (i, path) in traits.iter().enumerate() {\n+                            if i > 0 {\n+                                tokens.push(TokenTree::Token(attrs[i].span, Token::Comma).into());\n+                            }\n+                            for (j, segment) in path.segments.iter().enumerate() {\n+                                if j > 0 {\n+                                    tokens.push(TokenTree::Token(path.span, Token::ModSep).into());\n+                                }\n+                                let tok = Token::Ident(segment.identifier);\n+                                tokens.push(TokenTree::Token(path.span, tok).into());\n+                            }\n+                        }\n+                        attrs[i].tokens = TokenTree::Delimited(attrs[i].span, Delimited {\n+                            delim: token::Paren,\n+                            tts: TokenStream::concat(tokens).into(),\n+                        }).into();\n                     }\n                     return Some(ast::Attribute {\n-                        value: ast::MetaItem {\n-                            name: legacy_name,\n-                            span: span,\n-                            node: ast::MetaItemKind::Word,\n-                        },\n+                        path: ast::Path::from_ident(span, Ident::with_empty_ctxt(legacy_name)),\n+                        tokens: TokenStream::empty(),\n                         id: attr::mk_attr_id(),\n                         style: ast::AttrStyle::Outer,\n                         is_sugared_doc: false,\n@@ -267,28 +289,27 @@ impl<'a> Resolver<'a> {\n             InvocationKind::Bang { ref mac, .. } => {\n                 return self.resolve_macro_to_def(scope, &mac.node.path, MacroKind::Bang, force);\n             }\n-            InvocationKind::Derive { name, span, .. } => {\n-                let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-                return self.resolve_macro_to_def(scope, &path, MacroKind::Derive, force);\n+            InvocationKind::Derive { ref path, .. } => {\n+                return self.resolve_macro_to_def(scope, path, MacroKind::Derive, force);\n             }\n         };\n \n-        let (attr_name, path) = {\n-            let attr = attr.as_ref().unwrap();\n-            (attr.name(), ast::Path::from_ident(attr.span, Ident::with_empty_ctxt(attr.name())))\n-        };\n \n-        let mut determined = true;\n+        let path = attr.as_ref().unwrap().path.clone();\n+        let mut determinacy = Determinacy::Determined;\n         match self.resolve_macro_to_def(scope, &path, MacroKind::Attr, force) {\n             Ok(def) => return Ok(def),\n-            Err(Determinacy::Undetermined) => determined = false,\n+            Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n             Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n             Err(Determinacy::Determined) => {}\n         }\n \n-        for &(name, span) in traits {\n-            let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-            match self.resolve_macro(scope, &path, MacroKind::Derive, force) {\n+        let attr_name = match path.segments.len() {\n+            1 => path.segments[0].identifier.name,\n+            _ => return Err(determinacy),\n+        };\n+        for path in traits {\n+            match self.resolve_macro(scope, path, MacroKind::Derive, force) {\n                 Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs) = *ext {\n                     if inert_attrs.contains(&attr_name) {\n                         // FIXME(jseyfried) Avoid `mem::replace` here.\n@@ -307,12 +328,12 @@ impl<'a> Resolver<'a> {\n                     }\n                     return Err(Determinacy::Undetermined);\n                 },\n-                Err(Determinacy::Undetermined) => determined = false,\n+                Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n                 Err(Determinacy::Determined) => {}\n             }\n         }\n \n-        Err(if determined { Determinacy::Determined } else { Determinacy::Undetermined })\n+        Err(determinacy)\n     }\n \n     fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n@@ -331,7 +352,7 @@ impl<'a> Resolver<'a> {\n         self.current_module = invocation.module.get();\n \n         if path.len() > 1 {\n-            if !self.use_extern_macros {\n+            if !self.use_extern_macros && self.gated_errors.insert(span) {\n                 let msg = \"non-ident macro paths are experimental\";\n                 let feature = \"use_extern_macros\";\n                 emit_feature_err(&self.session.parse_sess, feature, span, GateIssue::Language, msg);"}, {"sha": "f038c2dc298ad1fdce8b0bc97905239b19f2f38b", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -14,7 +14,6 @@ use rustc::ty::TyCtxt;\n use syntax::ast::{self, NodeId};\n use syntax::codemap::CodeMap;\n use syntax::print::pprust;\n-use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use data::{self, Visibility, SigElement};\n@@ -77,10 +76,9 @@ impl Lower for Vec<ast::Attribute> {\n     type Target = Vec<Attribute>;\n \n     fn lower(self, tcx: TyCtxt) -> Vec<Attribute> {\n-        let doc = Symbol::intern(\"doc\");\n         self.into_iter()\n         // Only retain real attributes. Doc comments are lowered separately.\n-        .filter(|attr| attr.name() != doc)\n+        .filter(|attr| attr.path != \"doc\")\n         .map(|mut attr| {\n             // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n             // attribute. First normalize all inner attribute (#![..]) to outer"}, {"sha": "90ee19198c93984314330a19925a297ac9da6e1a", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -54,7 +54,7 @@ use std::path::{Path, PathBuf};\n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{ty_to_string, arg_to_string};\n use syntax::codemap::MacroAttribute;\n@@ -829,11 +829,10 @@ impl<'a> Visitor<'a> for PathCollector {\n }\n \n fn docs_for_attrs(attrs: &[Attribute]) -> String {\n-    let doc = Symbol::intern(\"doc\");\n     let mut result = String::new();\n \n     for attr in attrs {\n-        if attr.name() == doc {\n+        if attr.check_name(\"doc\") {\n             if let Some(val) = attr.value_str() {\n                 if attr.is_sugared_doc {\n                     result.push_str(&strip_doc_comment_decoration(&val.as_str()));"}, {"sha": "8528482c7856cfe5c56120e42369f37c08df4d8e", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n     }\n \n     fn field(&self, attr: &ast::Attribute, name: &str) -> ast::Name {\n-        for item in attr.meta_item_list().unwrap_or(&[]) {\n+        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {\n                     return value;"}, {"sha": "660fa647882aa1cbf5e20d6cf35edfd80c725ae3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -39,12 +39,11 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use rustc::hir;\n \n+use std::{mem, slice, vec};\n use std::path::PathBuf;\n use std::rc::Rc;\n-use std::slice;\n use std::sync::Arc;\n use std::u32;\n-use std::mem;\n \n use core::DocContext;\n use doctree;\n@@ -472,22 +471,22 @@ impl Clean<Item> for doctree::Module {\n \n pub struct ListAttributesIter<'a> {\n     attrs: slice::Iter<'a, ast::Attribute>,\n-    current_list: slice::Iter<'a, ast::NestedMetaItem>,\n+    current_list: vec::IntoIter<ast::NestedMetaItem>,\n     name: &'a str\n }\n \n impl<'a> Iterator for ListAttributesIter<'a> {\n-    type Item = &'a ast::NestedMetaItem;\n+    type Item = ast::NestedMetaItem;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(nested) = self.current_list.next() {\n             return Some(nested);\n         }\n \n         for attr in &mut self.attrs {\n-            if let Some(ref list) = attr.meta_item_list() {\n+            if let Some(list) = attr.meta_item_list() {\n                 if attr.check_name(self.name) {\n-                    self.current_list = list.iter();\n+                    self.current_list = list.into_iter();\n                     if let Some(nested) = self.current_list.next() {\n                         return Some(nested);\n                     }\n@@ -508,7 +507,7 @@ impl AttributesExt for [ast::Attribute] {\n     fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n         ListAttributesIter {\n             attrs: self.iter(),\n-            current_list: [].iter(),\n+            current_list: Vec::new().into_iter(),\n             name: name\n         }\n     }\n@@ -519,7 +518,7 @@ pub trait NestedAttributesExt {\n     fn has_word(self, &str) -> bool;\n }\n \n-impl<'a, I: IntoIterator<Item=&'a ast::NestedMetaItem>> NestedAttributesExt for I {\n+impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n     fn has_word(self, word: &str) -> bool {\n         self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n     }\n@@ -2596,9 +2595,9 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n-            a.name() == \"doc\" && match a.meta_item_list() {\n-                Some(l) => attr::list_contains_name(l, \"no_inline\") ||\n-                           attr::list_contains_name(l, \"hidden\"),\n+            a.name().unwrap() == \"doc\" && match a.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n+                           attr::list_contains_name(&l, \"hidden\"),\n                 None => false,\n             }\n         });"}, {"sha": "a9da8edc379fc3c123d4b6255c84f30a6d298bdb", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -2620,11 +2620,11 @@ fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n-        let name = attr.name();\n+        let name = attr.name().unwrap();\n         if !ATTRIBUTE_WHITELIST.contains(&&name.as_str()[..]) {\n             continue;\n         }\n-        if let Some(s) = render_attribute(attr.meta()) {\n+        if let Some(s) = render_attribute(&attr.meta().unwrap()) {\n             attrs.push_str(&format!(\"#[{}]\\n\", s));\n         }\n     }"}, {"sha": "f6b7a07bdae01dafd7222e269b73f51876551173", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -137,13 +137,13 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n         attrs: Vec::new(),\n     };\n \n-    let attrs = krate.attrs.iter()\n-                     .filter(|a| a.check_name(\"doc\"))\n-                     .filter_map(|a| a.meta_item_list())\n-                     .flat_map(|l| l)\n-                     .filter(|a| a.check_name(\"test\"))\n-                     .filter_map(|a| a.meta_item_list())\n-                     .flat_map(|l| l);\n+    let test_attrs: Vec<_> = krate.attrs.iter()\n+        .filter(|a| a.check_name(\"doc\"))\n+        .flat_map(|a| a.meta_item_list().unwrap_or_else(Vec::new))\n+        .filter(|a| a.check_name(\"test\"))\n+        .collect();\n+    let attrs = test_attrs.iter().flat_map(|a| a.meta_item_list().unwrap_or(&[]));\n+\n     for attr in attrs {\n         if attr.check_name(\"no_crate_inject\") {\n             opts.no_crate_inject = true;"}, {"sha": "4a909f8e2a9728c8117919d6cedc84104246e737", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 if item.vis == hir::Public && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n-                            Some(list) if item.check_name(\"doc\") => {\n+                            Some(ref list) if item.check_name(\"doc\") => {\n                                 list.iter().any(|i| i.check_name(\"inline\"))\n                             }\n                             _ => false,"}, {"sha": "84fb69a7f1094e46dc51c5fa3b2be8c0e514e289", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -116,6 +116,12 @@ pub struct Path {\n     pub segments: Vec<PathSegment>,\n }\n \n+impl<'a> PartialEq<&'a str> for Path {\n+    fn eq(&self, string: &&'a str) -> bool {\n+        self.segments.len() == 1 && self.segments[0].identifier.name == *string\n+    }\n+}\n+\n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"path({})\", pprust::path_to_string(self))\n@@ -1681,7 +1687,8 @@ pub struct AttrId(pub usize);\n pub struct Attribute {\n     pub id: AttrId,\n     pub style: AttrStyle,\n-    pub value: MetaItem,\n+    pub path: Path,\n+    pub tokens: TokenStream,\n     pub is_sugared_doc: bool,\n     pub span: Span,\n }"}, {"sha": "2f1efd6ad00ee07672483cb8a7139de0ee714304", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 311, "deletions": 37, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -15,20 +15,24 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute, Name};\n+use ast::{AttrId, Attribute, Name, Ident};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n-use ast::{Lit, Expr, Item, Local, Stmt, StmtKind};\n+use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind};\n use codemap::{Spanned, spanned, dummy_spanned, mk_sp};\n use syntax_pos::{Span, BytePos, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use parse::ParseSess;\n+use parse::parser::Parser;\n+use parse::{self, ParseSess, PResult};\n+use parse::token::{self, Token};\n use ptr::P;\n use symbol::Symbol;\n+use tokenstream::{TokenStream, TokenTree, Delimited};\n use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n+use std::iter;\n \n thread_local! {\n     static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new());\n@@ -185,26 +189,38 @@ impl NestedMetaItem {\n \n impl Attribute {\n     pub fn check_name(&self, name: &str) -> bool {\n-        let matches = self.name() == name;\n+        let matches = self.path == name;\n         if matches {\n             mark_used(self);\n         }\n         matches\n     }\n \n-    pub fn name(&self) -> Name { self.meta().name() }\n+    pub fn name(&self) -> Option<Name> {\n+        match self.path.segments.len() {\n+            1 => Some(self.path.segments[0].identifier.name),\n+            _ => None,\n+        }\n+    }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n-        self.meta().value_str()\n+        self.meta().and_then(|meta| meta.value_str())\n     }\n \n-    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n-        self.meta().meta_item_list()\n+    pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+        match self.meta() {\n+            Some(MetaItem { node: MetaItemKind::List(list), .. }) => Some(list),\n+            _ => None\n+        }\n     }\n \n-    pub fn is_word(&self) -> bool { self.meta().is_word() }\n+    pub fn is_word(&self) -> bool {\n+        self.path.segments.len() == 1 && self.tokens.is_empty()\n+    }\n \n-    pub fn span(&self) -> Span { self.meta().span }\n+    pub fn span(&self) -> Span {\n+        self.span\n+    }\n \n     pub fn is_meta_item_list(&self) -> bool {\n         self.meta_item_list().is_some()\n@@ -225,7 +241,7 @@ impl MetaItem {\n         match self.node {\n             MetaItemKind::NameValue(ref v) => {\n                 match v.node {\n-                    ast::LitKind::Str(ref s, _) => Some((*s).clone()),\n+                    LitKind::Str(ref s, _) => Some((*s).clone()),\n                     _ => None,\n                 }\n             },\n@@ -264,8 +280,66 @@ impl MetaItem {\n \n impl Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n-    pub fn meta(&self) -> &MetaItem {\n-        &self.value\n+    pub fn meta(&self) -> Option<MetaItem> {\n+        let mut tokens = self.tokens.trees().peekable();\n+        Some(MetaItem {\n+            name: match self.path.segments.len() {\n+                1 => self.path.segments[0].identifier.name,\n+                _ => return None,\n+            },\n+            node: if let Some(node) = MetaItemKind::from_tokens(&mut tokens) {\n+                if tokens.peek().is_some() {\n+                    return None;\n+                }\n+                node\n+            } else {\n+                return None;\n+            },\n+            span: self.span,\n+        })\n+    }\n+\n+    pub fn parse<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, T>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    {\n+        let mut parser = Parser::new(sess, self.tokens.clone(), None, false);\n+        let result = f(&mut parser)?;\n+        if parser.token != token::Eof {\n+            parser.unexpected()?;\n+        }\n+        Ok(result)\n+    }\n+\n+    pub fn parse_list<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, Vec<T>>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    {\n+        if self.tokens.is_empty() {\n+            return Ok(Vec::new());\n+        }\n+        self.parse(sess, |parser| {\n+            parser.expect(&token::OpenDelim(token::Paren))?;\n+            let mut list = Vec::new();\n+            while !parser.eat(&token::CloseDelim(token::Paren)) {\n+                list.push(f(parser)?);\n+                if !parser.eat(&token::Comma) {\n+                   parser.expect(&token::CloseDelim(token::Paren))?;\n+                    break\n+                }\n+            }\n+            Ok(list)\n+        })\n+    }\n+\n+    pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n+        if self.path.segments.len() > 1 {\n+            sess.span_diagnostic.span_err(self.path.span, \"expected ident, found path\");\n+        }\n+\n+        Ok(MetaItem {\n+            name: self.path.segments.last().unwrap().identifier.name,\n+            node: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n+            span: self.span,\n+        })\n     }\n \n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n@@ -293,7 +367,7 @@ impl Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(name: Name, value: Symbol) -> MetaItem {\n-    let value_lit = dummy_spanned(ast::LitKind::Str(value, ast::StrStyle::Cooked));\n+    let value_lit = dummy_spanned(LitKind::Str(value, ast::StrStyle::Cooked));\n     mk_spanned_name_value_item(DUMMY_SP, name, value_lit)\n }\n \n@@ -348,7 +422,8 @@ pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id: id,\n         style: ast::AttrStyle::Inner,\n-        value: item,\n+        path: ast::Path::from_ident(item.span, ast::Ident::with_empty_ctxt(item.name)),\n+        tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n     }\n@@ -365,7 +440,8 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id: id,\n         style: ast::AttrStyle::Outer,\n-        value: item,\n+        path: ast::Path::from_ident(item.span, ast::Ident::with_empty_ctxt(item.name)),\n+        tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n     }\n@@ -374,32 +450,25 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, lo: BytePos, hi: BytePos)\n                            -> Attribute {\n     let style = doc_comment_style(&text.as_str());\n-    let lit = spanned(lo, hi, ast::LitKind::Str(text, ast::StrStyle::Cooked));\n+    let lit = spanned(lo, hi, LitKind::Str(text, ast::StrStyle::Cooked));\n     Attribute {\n         id: id,\n         style: style,\n-        value: MetaItem {\n-            span: mk_sp(lo, hi),\n-            name: Symbol::intern(\"doc\"),\n-            node: MetaItemKind::NameValue(lit),\n-        },\n+        path: ast::Path::from_ident(mk_sp(lo, hi), ast::Ident::from_str(\"doc\")),\n+        tokens: MetaItemKind::NameValue(lit).tokens(mk_sp(lo, hi)),\n         is_sugared_doc: true,\n         span: mk_sp(lo, hi),\n     }\n }\n \n pub fn list_contains_name(items: &[NestedMetaItem], name: &str) -> bool {\n-    debug!(\"attr::list_contains_name (name={})\", name);\n     items.iter().any(|item| {\n-        debug!(\"  testing: {:?}\", item.name());\n         item.check_name(name)\n     })\n }\n \n pub fn contains_name(attrs: &[Attribute], name: &str) -> bool {\n-    debug!(\"attr::contains_name (name={})\", name);\n     attrs.iter().any(|item| {\n-        debug!(\"  testing: {}\", item.name());\n         item.check_name(name)\n     })\n }\n@@ -452,8 +521,14 @@ pub enum InlineAttr {\n /// Determine what `#[inline]` attribute is present in `attrs`, if any.\n pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n     attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        match attr.value.node {\n-            _ if attr.value.name != \"inline\" => ia,\n+        if attr.path != \"inline\" {\n+            return ia;\n+        }\n+        let meta = match attr.meta() {\n+            Some(meta) => meta.node,\n+            None => return ia,\n+        };\n+        match meta {\n             MetaItemKind::Word => {\n                 mark_used(attr);\n                 InlineAttr::Hint\n@@ -574,14 +649,15 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n     let mut rustc_depr: Option<RustcDeprecation> = None;\n \n     'outer: for attr in attrs_iter {\n-        let tag = attr.name();\n-        if tag != \"rustc_deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n+        if attr.path != \"rustc_deprecated\" && attr.path != \"unstable\" && attr.path != \"stable\" {\n             continue // not a stability level\n         }\n \n         mark_used(attr);\n \n-        if let Some(metas) = attr.meta_item_list() {\n+        let meta = attr.meta();\n+        if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta {\n+            let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n@@ -596,7 +672,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n             };\n \n-            match &*tag.as_str() {\n+            match &*meta.name.as_str() {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -772,7 +848,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n     let mut depr: Option<Deprecation> = None;\n \n     'outer: for attr in attrs_iter {\n-        if attr.name() != \"deprecated\" {\n+        if attr.path != \"deprecated\" {\n             continue\n         }\n \n@@ -847,8 +923,8 @@ pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n /// structure layout, and `packed` to remove padding.\n pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n-    match attr.value.node {\n-        ast::MetaItemKind::List(ref items) if attr.value.name == \"repr\" => {\n+    if attr.path == \"repr\" {\n+        if let Some(items) = attr.meta_item_list() {\n             mark_used(attr);\n             for item in items {\n                 if !item.is_meta_item() {\n@@ -883,8 +959,6 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                 }\n             }\n         }\n-        // Not a \"repr\" hint: ignore.\n-        _ => { }\n     }\n     acc\n }\n@@ -931,6 +1005,206 @@ impl IntType {\n     }\n }\n \n+impl MetaItem {\n+    fn tokens(&self) -> TokenStream {\n+        let ident = TokenTree::Token(self.span, Token::Ident(Ident::with_empty_ctxt(self.name)));\n+        TokenStream::concat(vec![ident.into(), self.node.tokens(self.span)])\n+    }\n+\n+    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n+        where I: Iterator<Item = TokenTree>,\n+    {\n+        let (mut span, name) = match tokens.next() {\n+            Some(TokenTree::Token(span, Token::Ident(ident))) => (span, ident.name),\n+            Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => return match **nt {\n+                token::Nonterminal::NtMeta(ref meta) => Some(meta.clone()),\n+                _ => None,\n+            },\n+            _ => return None,\n+        };\n+        let node = match MetaItemKind::from_tokens(tokens) {\n+            Some(node) => node,\n+            _ => return None,\n+        };\n+        if let Some(last_span) = node.last_span() {\n+            span.hi = last_span.hi;\n+        }\n+        Some(MetaItem { name: name, span: span, node: node })\n+    }\n+}\n+\n+impl MetaItemKind {\n+    fn last_span(&self) -> Option<Span> {\n+        match *self {\n+            MetaItemKind::Word => None,\n+            MetaItemKind::List(ref list) => list.last().map(NestedMetaItem::span),\n+            MetaItemKind::NameValue(ref lit) => Some(lit.span),\n+        }\n+    }\n+\n+    pub fn tokens(&self, span: Span) -> TokenStream {\n+        match *self {\n+            MetaItemKind::Word => TokenStream::empty(),\n+            MetaItemKind::NameValue(ref lit) => {\n+                TokenStream::concat(vec![TokenTree::Token(span, Token::Eq).into(), lit.tokens()])\n+            }\n+            MetaItemKind::List(ref list) => {\n+                let mut tokens = Vec::new();\n+                for (i, item) in list.iter().enumerate() {\n+                    if i > 0 {\n+                        tokens.push(TokenTree::Token(span, Token::Comma).into());\n+                    }\n+                    tokens.push(item.node.tokens());\n+                }\n+                TokenTree::Delimited(span, Delimited {\n+                    delim: token::Paren,\n+                    tts: TokenStream::concat(tokens).into(),\n+                }).into()\n+            }\n+        }\n+    }\n+\n+    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItemKind>\n+        where I: Iterator<Item = TokenTree>,\n+    {\n+        let delimited = match tokens.peek().cloned() {\n+            Some(TokenTree::Token(_, token::Eq)) => {\n+                tokens.next();\n+                return if let Some(TokenTree::Token(span, token)) = tokens.next() {\n+                    LitKind::from_token(token)\n+                        .map(|lit| MetaItemKind::NameValue(Spanned { node: lit, span: span }))\n+                } else {\n+                    None\n+                };\n+            }\n+            Some(TokenTree::Delimited(_, ref delimited)) if delimited.delim == token::Paren => {\n+                tokens.next();\n+                delimited.stream()\n+            }\n+            _ => return Some(MetaItemKind::Word),\n+        };\n+\n+        let mut tokens = delimited.into_trees().peekable();\n+        let mut result = Vec::new();\n+        while let Some(..) = tokens.peek() {\n+            match NestedMetaItemKind::from_tokens(&mut tokens) {\n+                Some(item) => result.push(Spanned { span: item.span(), node: item }),\n+                None => return None,\n+            }\n+            match tokens.next() {\n+                None | Some(TokenTree::Token(_, Token::Comma)) => {}\n+                _ => return None,\n+            }\n+        }\n+        Some(MetaItemKind::List(result))\n+    }\n+}\n+\n+impl NestedMetaItemKind {\n+    fn span(&self) -> Span {\n+        match *self {\n+            NestedMetaItemKind::MetaItem(ref item) => item.span,\n+            NestedMetaItemKind::Literal(ref lit) => lit.span,\n+        }\n+    }\n+\n+    fn tokens(&self) -> TokenStream {\n+        match *self {\n+            NestedMetaItemKind::MetaItem(ref item) => item.tokens(),\n+            NestedMetaItemKind::Literal(ref lit) => lit.tokens(),\n+        }\n+    }\n+\n+    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItemKind>\n+        where I: Iterator<Item = TokenTree>,\n+    {\n+        if let Some(TokenTree::Token(span, token)) = tokens.peek().cloned() {\n+            if let Some(node) = LitKind::from_token(token) {\n+                tokens.next();\n+                return Some(NestedMetaItemKind::Literal(Spanned { node: node, span: span }));\n+            }\n+        }\n+\n+        MetaItem::from_tokens(tokens).map(NestedMetaItemKind::MetaItem)\n+    }\n+}\n+\n+impl Lit {\n+    fn tokens(&self) -> TokenStream {\n+        TokenTree::Token(self.span, self.node.token()).into()\n+    }\n+}\n+\n+impl LitKind {\n+    fn token(&self) -> Token {\n+        use std::ascii;\n+\n+        match *self {\n+            LitKind::Str(string, ast::StrStyle::Cooked) => {\n+                let mut escaped = String::new();\n+                for ch in string.as_str().chars() {\n+                    escaped.extend(ch.escape_unicode());\n+                }\n+                Token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None)\n+            }\n+            LitKind::Str(string, ast::StrStyle::Raw(n)) => {\n+                Token::Literal(token::Lit::StrRaw(string, n), None)\n+            }\n+            LitKind::ByteStr(ref bytes) => {\n+                let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n+                    .map(Into::<char>::into).collect::<String>();\n+                Token::Literal(token::Lit::ByteStr(Symbol::intern(&string)), None)\n+            }\n+            LitKind::Byte(byte) => {\n+                let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n+                Token::Literal(token::Lit::Byte(Symbol::intern(&string)), None)\n+            }\n+            LitKind::Char(ch) => {\n+                let string: String = ch.escape_default().map(Into::<char>::into).collect();\n+                Token::Literal(token::Lit::Char(Symbol::intern(&string)), None)\n+            }\n+            LitKind::Int(n, ty) => {\n+                let suffix = match ty {\n+                    ast::LitIntType::Unsigned(ty) => Some(Symbol::intern(ty.ty_to_string())),\n+                    ast::LitIntType::Signed(ty) => Some(Symbol::intern(ty.ty_to_string())),\n+                    ast::LitIntType::Unsuffixed => None,\n+                };\n+                Token::Literal(token::Lit::Integer(Symbol::intern(&n.to_string())), suffix)\n+            }\n+            LitKind::Float(symbol, ty) => {\n+                Token::Literal(token::Lit::Float(symbol), Some(Symbol::intern(ty.ty_to_string())))\n+            }\n+            LitKind::FloatUnsuffixed(symbol) => Token::Literal(token::Lit::Float(symbol), None),\n+            LitKind::Bool(value) => Token::Ident(Ident::with_empty_ctxt(Symbol::intern(match value {\n+                true => \"true\",\n+                false => \"false\",\n+            }))),\n+        }\n+    }\n+\n+    fn from_token(token: Token) -> Option<LitKind> {\n+        match token {\n+            Token::Ident(ident) if ident.name == \"true\" => Some(LitKind::Bool(true)),\n+            Token::Ident(ident) if ident.name == \"false\" => Some(LitKind::Bool(false)),\n+            Token::Interpolated(ref nt) => match **nt {\n+                token::NtExpr(ref v) => match v.node {\n+                    ExprKind::Lit(ref lit) => Some(lit.node.clone()),\n+                    _ => None,\n+                },\n+                _ => None,\n+            },\n+            Token::Literal(lit, suf) => {\n+                let (suffix_illegal, result) = parse::lit_token(lit, suf, None);\n+                if suffix_illegal && suf.is_some() {\n+                    return None;\n+                }\n+                result\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n pub trait HasAttrs: Sized {\n     fn attrs(&self) -> &[ast::Attribute];\n     fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self;"}, {"sha": "ede8a33df6546db821b3681f93758aa362e43a29", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -13,9 +13,10 @@ use feature_gate::{feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features\n use {fold, attr};\n use ast;\n use codemap::Spanned;\n-use parse::ParseSess;\n-use ptr::P;\n+use parse::{token, ParseSess};\n+use syntax_pos::Span;\n \n+use ptr::P;\n use util::small_vector::SmallVector;\n \n /// A folder that strips out items that do not belong in the current configuration.\n@@ -84,43 +85,33 @@ impl<'a> StripUnconfigured<'a> {\n             return Some(attr);\n         }\n \n-        let attr_list = match attr.meta_item_list() {\n-            Some(attr_list) => attr_list,\n-            None => {\n-                let msg = \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n-                self.sess.span_diagnostic.span_err(attr.span, msg);\n-                return None;\n-            }\n-        };\n-\n-        let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n-            (2, Some(cfg), Some(mi)) => (cfg, mi),\n-            _ => {\n-                let msg = \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n-                self.sess.span_diagnostic.span_err(attr.span, msg);\n+        let (cfg, path, tokens, span) = match attr.parse(self.sess, |parser| {\n+            parser.expect(&token::OpenDelim(token::Paren))?;\n+            let cfg = parser.parse_meta_item()?;\n+            parser.expect(&token::Comma)?;\n+            let lo = parser.span.lo;\n+            let (path, tokens) = parser.parse_path_and_tokens()?;\n+            parser.expect(&token::CloseDelim(token::Paren))?;\n+            Ok((cfg, path, tokens, Span { lo: lo, ..parser.prev_span }))\n+        }) {\n+            Ok(result) => result,\n+            Err(mut e) => {\n+                e.emit();\n                 return None;\n             }\n         };\n \n-        use attr::cfg_matches;\n-        match (cfg.meta_item(), mi.meta_item()) {\n-            (Some(cfg), Some(mi)) =>\n-                if cfg_matches(&cfg, self.sess, self.features) {\n-                    self.process_cfg_attr(ast::Attribute {\n-                        id: attr::mk_attr_id(),\n-                        style: attr.style,\n-                        value: mi.clone(),\n-                        is_sugared_doc: false,\n-                        span: mi.span,\n-                    })\n-                } else {\n-                    None\n-                },\n-            _ => {\n-                let msg = \"unexpected literal(s) in `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n-                self.sess.span_diagnostic.span_err(attr.span, msg);\n-                None\n-            }\n+        if attr::cfg_matches(&cfg, self.sess, self.features) {\n+            self.process_cfg_attr(ast::Attribute {\n+                id: attr::mk_attr_id(),\n+                style: attr.style,\n+                path: path,\n+                tokens: tokens,\n+                is_sugared_doc: false,\n+                span: span,\n+            })\n+        } else {\n+            None\n         }\n     }\n \n@@ -132,9 +123,12 @@ impl<'a> StripUnconfigured<'a> {\n                 return false;\n             }\n \n-            let mis = match attr.value.node {\n-                ast::MetaItemKind::List(ref mis) if is_cfg(&attr) => mis,\n-                _ => return true\n+            let mis = if !is_cfg(&attr) {\n+                return true;\n+            } else if let Some(mis) = attr.meta_item_list() {\n+                mis\n+            } else {\n+                return true;\n             };\n \n             if mis.len() != 1 {"}, {"sha": "1569d9f540b8ebf679eb69b92f14d750d77545f3", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -12,36 +12,31 @@ use attr::HasAttrs;\n use {ast, codemap};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n+use parse::parser::PathStyle;\n use symbol::Symbol;\n use syntax_pos::Span;\n \n-pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec<(Symbol, Span)> {\n+pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n     let mut result = Vec::new();\n     attrs.retain(|attr| {\n-        if attr.name() != \"derive\" {\n+        if attr.path != \"derive\" {\n             return true;\n         }\n \n-        if attr.value_str().is_some() {\n-            cx.span_err(attr.span, \"unexpected value in `derive`\");\n-            return false;\n-        }\n-\n-        let traits = attr.meta_item_list().unwrap_or(&[]).to_owned();\n-        if traits.is_empty() {\n-            cx.span_warn(attr.span, \"empty trait list in `derive`\");\n-            return false;\n-        }\n-\n-        for titem in traits {\n-            if titem.word().is_none() {\n-                cx.span_err(titem.span, \"malformed `derive` entry\");\n-                return false;\n+        match attr.parse_list(cx.parse_sess, |parser| parser.parse_path(PathStyle::Mod)) {\n+            Ok(ref traits) if traits.is_empty() => {\n+                cx.span_warn(attr.span, \"empty trait list in `derive`\");\n+                false\n+            }\n+            Ok(traits) => {\n+                result.extend(traits);\n+                true\n+            }\n+            Err(mut e) => {\n+                e.emit();\n+                false\n             }\n-            result.push((titem.name().unwrap(), titem.span));\n         }\n-\n-        true\n     });\n     result\n }\n@@ -60,21 +55,21 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n     }\n }\n \n-pub fn add_derived_markers<T: HasAttrs>(cx: &mut ExtCtxt, traits: &[(Symbol, Span)], item: T) -> T {\n+pub fn add_derived_markers<T: HasAttrs>(cx: &mut ExtCtxt, traits: &[ast::Path], item: T) -> T {\n     let span = match traits.get(0) {\n-        Some(&(_, span)) => span,\n+        Some(path) => path.span,\n         None => return item,\n     };\n \n     item.map_attrs(|mut attrs| {\n-        if traits.iter().any(|&(name, _)| name == \"PartialEq\") &&\n-           traits.iter().any(|&(name, _)| name == \"Eq\") {\n+        if traits.iter().any(|path| *path == \"PartialEq\") &&\n+           traits.iter().any(|path| *path == \"Eq\") {\n             let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n             let meta = cx.meta_word(span, Symbol::intern(\"structural_match\"));\n             attrs.push(cx.attribute(span, meta));\n         }\n-        if traits.iter().any(|&(name, _)| name == \"Copy\") &&\n-           traits.iter().any(|&(name, _)| name == \"Clone\") {\n+        if traits.iter().any(|path| *path == \"Copy\") &&\n+           traits.iter().any(|path| *path == \"Clone\") {\n             let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n             let meta = cx.meta_word(span, Symbol::intern(\"rustc_copy_clone_marker\"));\n             attrs.push(cx.attribute(span, meta));"}, {"sha": "c1816582bc6ca2418c8bc361f841d4c77b35a17a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 56, "deletions": 78, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{self, Block, Ident, PatKind};\n-use ast::{Name, MacStmtStyle, StmtKind, ItemKind};\n+use ast::{self, Block, Ident, PatKind, Path};\n+use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use config::{is_test_or_bench, StripUnconfigured};\n@@ -27,7 +27,7 @@ use ptr::P;\n use std_inject;\n use symbol::Symbol;\n use symbol::keywords;\n-use syntax_pos::{self, Span, ExpnId};\n+use syntax_pos::{Span, ExpnId, DUMMY_SP};\n use tokenstream::TokenStream;\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -165,12 +165,11 @@ pub enum InvocationKind {\n     },\n     Attr {\n         attr: Option<ast::Attribute>,\n-        traits: Vec<(Symbol, Span)>,\n+        traits: Vec<Path>,\n         item: Annotatable,\n     },\n     Derive {\n-        name: Symbol,\n-        span: Span,\n+        path: Path,\n         item: Annotatable,\n     },\n }\n@@ -180,8 +179,8 @@ impl Invocation {\n         match self.kind {\n             InvocationKind::Bang { span, .. } => span,\n             InvocationKind::Attr { attr: Some(ref attr), .. } => attr.span,\n-            InvocationKind::Attr { attr: None, .. } => syntax_pos::DUMMY_SP,\n-            InvocationKind::Derive { span, .. } => span,\n+            InvocationKind::Attr { attr: None, .. } => DUMMY_SP,\n+            InvocationKind::Derive { ref path, .. } => path.span,\n         }\n     }\n }\n@@ -272,25 +271,24 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.collect_invocations(expansion, &[])\n                 } else if let InvocationKind::Attr { attr: None, traits, item } = invoc.kind {\n                     let item = item\n-                        .map_attrs(|mut attrs| { attrs.retain(|a| a.name() != \"derive\"); attrs });\n+                        .map_attrs(|mut attrs| { attrs.retain(|a| a.path != \"derive\"); attrs });\n                     let item_with_markers =\n                         add_derived_markers(&mut self.cx, &traits, item.clone());\n                     let derives = derives.entry(invoc.expansion_data.mark).or_insert_with(Vec::new);\n \n-                    for &(name, span) in &traits {\n+                    for path in &traits {\n                         let mark = Mark::fresh();\n                         derives.push(mark);\n-                        let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n                         let item = match self.cx.resolver.resolve_macro(\n-                                Mark::root(), &path, MacroKind::Derive, false) {\n+                                Mark::root(), path, MacroKind::Derive, false) {\n                             Ok(ext) => match *ext {\n                                 SyntaxExtension::BuiltinDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),\n                             },\n                             _ => item.clone(),\n                         };\n                         invocations.push(Invocation {\n-                            kind: InvocationKind::Derive { name: name, span: span, item: item },\n+                            kind: InvocationKind::Derive { path: path.clone(), item: item },\n                             expansion_kind: invoc.expansion_kind,\n                             expansion_data: ExpansionData {\n                                 mark: mark,\n@@ -380,53 +378,52 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         attr::mark_used(&attr);\n-        let name = attr.name();\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n             callee: NameAndSpan {\n-                format: MacroAttribute(name),\n+                format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n                 span: Some(attr.span),\n                 allow_internal_unstable: false,\n             }\n         });\n \n         match *ext {\n             MultiModifier(ref mac) => {\n-                let item = mac.expand(self.cx, attr.span, &attr.value, item);\n+                let meta = panictry!(attr.parse_meta(&self.cx.parse_sess));\n+                let item = mac.expand(self.cx, attr.span, &meta, item);\n                 kind.expect_from_annotatables(item)\n             }\n             MultiDecorator(ref mac) => {\n                 let mut items = Vec::new();\n-                mac.expand(self.cx, attr.span, &attr.value, &item,\n-                           &mut |item| items.push(item));\n+                let meta = panictry!(attr.parse_meta(&self.cx.parse_sess));\n+                mac.expand(self.cx, attr.span, &meta, &item, &mut |item| items.push(item));\n                 items.push(item);\n                 kind.expect_from_annotatables(items)\n             }\n             SyntaxExtension::AttrProcMacro(ref mac) => {\n-                let attr_toks = stream_for_attr_args(&attr, &self.cx.parse_sess);\n                 let item_toks = stream_for_item(&item, &self.cx.parse_sess);\n \n                 let span = Span {\n                     expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            format: MacroAttribute(name),\n+                            format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n                             span: None,\n                             allow_internal_unstable: false,\n                         },\n                     }),\n                     ..attr.span\n                 };\n \n-                let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n-                self.parse_expansion(tok_result, kind, name, span)\n+                let tok_result = mac.expand(self.cx, attr.span, attr.tokens.clone(), item_toks);\n+                self.parse_expansion(tok_result, kind, &attr.path, span)\n             }\n             SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n-                self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", name));\n+                self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", attr.path));\n                 kind.dummy(attr.span)\n             }\n             _ => {\n-                let msg = &format!(\"macro `{}` may not be used in attributes\", name);\n+                let msg = &format!(\"macro `{}` may not be used in attributes\", attr.path);\n                 self.cx.span_err(attr.span, &msg);\n                 kind.dummy(attr.span)\n             }\n@@ -442,23 +439,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n         let path = &mac.node.path;\n \n-        let extname = path.segments.last().unwrap().identifier.name;\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n         let marked_tts =\n             noop_fold_tts(mac.node.stream(), &mut Marker { mark: mark, expn_id: None });\n         let opt_expanded = match *ext {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n-                        format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n+                        format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n                     self.cx.span_err(path.span, &msg);\n                     return kind.dummy(span);\n                 }\n \n                 self.cx.bt_push(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n-                        format: MacroBang(extname),\n+                        format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n                         span: exp_span,\n                         allow_internal_unstable: allow_internal_unstable,\n                     },\n@@ -470,14 +466,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n                 if ident.name == keywords::Invalid.name() {\n                     self.cx.span_err(path.span,\n-                                    &format!(\"macro {}! expects an ident argument\", extname));\n+                                    &format!(\"macro {}! expects an ident argument\", path));\n                     return kind.dummy(span);\n                 };\n \n                 self.cx.bt_push(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n-                        format: MacroBang(extname),\n+                        format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n                         span: tt_span,\n                         allow_internal_unstable: allow_internal_unstable,\n                     }\n@@ -489,27 +485,27 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             MultiDecorator(..) | MultiModifier(..) | SyntaxExtension::AttrProcMacro(..) => {\n                 self.cx.span_err(path.span,\n-                                 &format!(\"`{}` can only be used in attributes\", extname));\n+                                 &format!(\"`{}` can only be used in attributes\", path));\n                 return kind.dummy(span);\n             }\n \n             SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n-                self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", extname));\n+                self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", path));\n                 return kind.dummy(span);\n             }\n \n             SyntaxExtension::ProcMacro(ref expandfun) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n-                        format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n+                        format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n                     self.cx.span_err(path.span, &msg);\n                     return kind.dummy(span);\n                 }\n \n                 self.cx.bt_push(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n-                        format: MacroBang(extname),\n+                        format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n                         // FIXME procedural macros do not have proper span info\n                         // yet, when they do, we should use it here.\n                         span: None,\n@@ -519,7 +515,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 });\n \n                 let tok_result = expandfun.expand(self.cx, span, marked_tts);\n-                Some(self.parse_expansion(tok_result, kind, extname, span))\n+                Some(self.parse_expansion(tok_result, kind, path, span))\n             }\n         };\n \n@@ -541,19 +537,24 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// Expand a derive invocation. Returns the result of expansion.\n     fn expand_derive_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n-        let (name, span, item) = match invoc.kind {\n-            InvocationKind::Derive { name, span, item } => (name, span, item),\n+        let (path, item) = match invoc.kind {\n+            InvocationKind::Derive { path, item } => (path, item),\n             _ => unreachable!(),\n         };\n \n-        let mitem = ast::MetaItem { name: name, span: span, node: ast::MetaItemKind::Word };\n-        let pretty_name = Symbol::intern(&format!(\"derive({})\", name));\n+        let pretty_name = Symbol::intern(&format!(\"derive({})\", path));\n+        let span = path.span;\n+        let attr = ast::Attribute {\n+            path: path, tokens: TokenStream::empty(), span: span,\n+            // irrelevant:\n+            id: ast::AttrId(0), style: ast::AttrStyle::Outer, is_sugared_doc: false,\n+        };\n \n         self.cx.bt_push(ExpnInfo {\n             call_site: span,\n             callee: NameAndSpan {\n                 format: MacroAttribute(pretty_name),\n-                span: Some(span),\n+                span: None,\n                 allow_internal_unstable: false,\n             }\n         });\n@@ -571,7 +572,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     }),\n                     ..span\n                 };\n-                return kind.expect_from_annotatables(ext.expand(self.cx, span, &mitem, item));\n+                let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n+                    name: keywords::Invalid.name(),\n+                    span: DUMMY_SP,\n+                    node: ast::MetaItemKind::Word,\n+                };\n+                return kind.expect_from_annotatables(ext.expand(self.cx, span, &dummy, item));\n             }\n             SyntaxExtension::BuiltinDerive(func) => {\n                 let span = Span {\n@@ -586,20 +592,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     ..span\n                 };\n                 let mut items = Vec::new();\n-                func(self.cx, span, &mitem, &item, &mut |a| {\n-                    items.push(a)\n-                });\n+                func(self.cx, span, &attr.meta().unwrap(), &item, &mut |a| items.push(a));\n                 return kind.expect_from_annotatables(items);\n             }\n             _ => {\n-                let msg = &format!(\"macro `{}` may not be used for derive attributes\", name);\n+                let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n                 self.cx.span_err(span, &msg);\n                 kind.dummy(span)\n             }\n         }\n     }\n \n-    fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, name: Name, span: Span)\n+    fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, path: &Path, span: Span)\n                        -> Expansion {\n         let mut parser = self.cx.new_parser_from_tts(&toks.into_trees().collect::<Vec<_>>());\n         let expansion = match parser.parse_expansion(kind, false) {\n@@ -609,7 +613,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 return kind.dummy(span);\n             }\n         };\n-        parser.ensure_complete_parse(name, kind.name(), span);\n+        parser.ensure_complete_parse(path, kind.name(), span);\n         // FIXME better span info\n         expansion.fold_with(&mut ChangeSpan { span: span })\n     }\n@@ -658,14 +662,14 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn ensure_complete_parse(&mut self, macro_name: ast::Name, kind_name: &str, span: Span) {\n+    pub fn ensure_complete_parse(&mut self, macro_path: &Path, kind_name: &str, span: Span) {\n         if self.token != token::Eof {\n             let msg = format!(\"macro expansion ignores token `{}` and any following\",\n                               self.this_token_to_string());\n             let mut err = self.diagnostic().struct_span_err(self.span, &msg);\n             let msg = format!(\"caused by the macro expansion here; the usage \\\n                                of `{}!` is likely invalid in {} context\",\n-                               macro_name, kind_name);\n+                               macro_path, kind_name);\n             err.span_note(span, &msg).emit();\n         }\n     }\n@@ -708,20 +712,20 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(&mut self,\n                     attr: Option<ast::Attribute>,\n-                    traits: Vec<(Symbol, Span)>,\n+                    traits: Vec<Path>,\n                     item: Annotatable,\n                     kind: ExpansionKind)\n                     -> Expansion {\n         if !traits.is_empty() &&\n            (kind == ExpansionKind::TraitItems || kind == ExpansionKind::ImplItems) {\n-            self.cx.span_err(traits[0].1, \"`derive` can be only be applied to items\");\n+            self.cx.span_err(traits[0].span, \"`derive` can be only be applied to items\");\n             return kind.expect_from_annotatables(::std::iter::once(item));\n         }\n         self.collect(kind, InvocationKind::Attr { attr: attr, traits: traits, item: item })\n     }\n \n     // If `item` is an attr invocation, remove and return the macro attribute.\n-    fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<(Symbol, Span)>, T)\n+    fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<Path>, T)\n         where T: HasAttrs,\n     {\n         let (mut attr, mut traits) = (None, Vec::new());\n@@ -784,32 +788,6 @@ fn stream_for_item(item: &Annotatable, parse_sess: &ParseSess) -> TokenStream {\n     string_to_stream(text, parse_sess)\n }\n \n-fn stream_for_attr_args(attr: &ast::Attribute, parse_sess: &ParseSess) -> TokenStream {\n-    use ast::MetaItemKind::*;\n-    use print::pp::Breaks;\n-    use print::pprust::PrintState;\n-\n-    let token_string = match attr.value.node {\n-        // For `#[foo]`, an empty token\n-        Word => return TokenStream::empty(),\n-        // For `#[foo(bar, baz)]`, returns `(bar, baz)`\n-        List(ref items) => pprust::to_string(|s| {\n-            s.popen()?;\n-            s.commasep(Breaks::Consistent,\n-                       &items[..],\n-                       |s, i| s.print_meta_list_item(&i))?;\n-            s.pclose()\n-        }),\n-        // For `#[foo = \"bar\"]`, returns `= \"bar\"`\n-        NameValue(ref lit) => pprust::to_string(|s| {\n-            s.word_space(\"=\")?;\n-            s.print_literal(lit)\n-        }),\n-    };\n-\n-    string_to_stream(token_string, parse_sess)\n-}\n-\n fn string_to_stream(text: String, parse_sess: &ParseSess) -> TokenStream {\n     let filename = String::from(\"<macro expansion>\");\n     filemap_to_stream(parse_sess, parse_sess.codemap().new_filemap(filename, None, text))\n@@ -926,7 +904,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 // Detect if this is an inline module (`mod m { ... }` as opposed to `mod m;`).\n                 // In the non-inline case, `inner` is never the dummy span (c.f. `parse_item_mod`).\n                 // Thus, if `inner` is the dummy span, we know the module is inline.\n-                let inline_module = item.span.contains(inner) || inner == syntax_pos::DUMMY_SP;\n+                let inline_module = item.span.contains(inner) || inner == DUMMY_SP;\n \n                 if inline_module {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {"}, {"sha": "10b7249743b8c49762cf2cc38d9dd672a0a8a618", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -220,16 +220,24 @@ pub mod rt {\n     }\n \n     impl ToTokens for ast::Attribute {\n-        fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n+        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n             let mut r = vec![];\n             // FIXME: The spans could be better\n             r.push(TokenTree::Token(self.span, token::Pound));\n             if self.style == ast::AttrStyle::Inner {\n                 r.push(TokenTree::Token(self.span, token::Not));\n             }\n+            let mut inner = Vec::new();\n+            for (i, segment) in self.path.segments.iter().enumerate() {\n+                if i > 0 {\n+                    inner.push(TokenTree::Token(self.span, token::Colon).into());\n+                }\n+                inner.push(TokenTree::Token(self.span, token::Ident(segment.identifier)).into());\n+            }\n+            inner.push(self.tokens.clone());\n+\n             r.push(TokenTree::Delimited(self.span, tokenstream::Delimited {\n-                delim: token::Bracket,\n-                tts: self.value.to_tokens(cx).into_iter().collect::<TokenStream>().into(),\n+                delim: token::Bracket, tts: TokenStream::concat(inner).into()\n             }));\n             r\n         }"}, {"sha": "6385d206a0cb90bacbf863a2f97a1405be614fc4", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -488,7 +488,7 @@ pub fn parse(sess: &ParseSess, tts: TokenStream, ms: &[TokenTree], directory: Op\n fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n     match name {\n         \"tt\" => {\n-            return token::NtTT(panictry!(p.parse_token_tree()));\n+            return token::NtTT(p.parse_token_tree());\n         }\n         _ => {}\n     }"}, {"sha": "021c5398a4200459218a8f94d78df25ed77b6502", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -51,7 +51,8 @@ impl<'a> ParserAnyMacro<'a> {\n         }\n \n         // Make sure we don't have any tokens left to parse so we don't silently drop anything.\n-        parser.ensure_complete_parse(macro_ident.name, kind.name(), site_span);\n+        let path = ast::Path::from_ident(site_span, macro_ident);\n+        parser.ensure_complete_parse(&path, kind.name(), site_span);\n         expansion\n     }\n }"}, {"sha": "1e06ee97e0bc757eda8057995ac2a870c10ba073", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -862,35 +862,34 @@ macro_rules! gate_feature {\n impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n-        let name = &*attr.name().as_str();\n+        let name = unwrap_or!(attr.name(), return);\n+\n         for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n-            if n == name {\n+            if name == n {\n                 if let &Gated(_, ref name, ref desc, ref has_feature) = gateage {\n                     gate_feature_fn!(self, has_feature, attr.span, name, desc);\n                 }\n-                debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", name, ty, gateage);\n+                debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n                 return;\n             }\n         }\n         for &(ref n, ref ty) in self.plugin_attributes {\n-            if n == name {\n+            if attr.path == &**n {\n                 // Plugins can't gate attributes, so we don't check for it\n                 // unlike the code above; we only use this loop to\n                 // short-circuit to avoid the checks below\n-                debug!(\"check_attribute: {:?} is registered by a plugin, {:?}\", name, ty);\n+                debug!(\"check_attribute: {:?} is registered by a plugin, {:?}\", attr.path, ty);\n                 return;\n             }\n         }\n-        if name.starts_with(\"rustc_\") {\n+        if name.as_str().starts_with(\"rustc_\") {\n             gate_feature!(self, rustc_attrs, attr.span,\n                           \"unless otherwise specified, attributes \\\n                            with the prefix `rustc_` \\\n                            are reserved for internal compiler diagnostics\");\n-        } else if name.starts_with(\"derive_\") {\n+        } else if name.as_str().starts_with(\"derive_\") {\n             gate_feature!(self, custom_derive, attr.span, EXPLAIN_DERIVE_UNDERSCORE);\n-        } else if attr::is_known(attr) {\n-            debug!(\"check_attribute: {:?} is known\", name);\n-        } else {\n+        } else if !attr::is_known(attr) {\n             // Only run the custom attribute lint during regular\n             // feature gate checking. Macro gating runs\n             // before the plugin attributes are registered\n@@ -901,7 +900,7 @@ impl<'a> Context<'a> {\n                                         unknown to the compiler and \\\n                                         may have meaning \\\n                                         added to it in the future\",\n-                                       name));\n+                                       attr.path));\n             }\n         }\n     }\n@@ -1100,7 +1099,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             self.context.check_attribute(attr, false);\n         }\n \n-        if contains_novel_literal(&attr.value) {\n+        if self.context.features.proc_macro && attr::is_known(attr) {\n+            return\n+        }\n+\n+        let meta = panictry!(attr.parse_meta(&self.context.parse_sess));\n+        if contains_novel_literal(&meta) {\n             gate_feature_post!(&self, attr_literals, attr.span,\n                                \"non-string literals in attributes, or string \\\n                                literals in top-level positions, are experimental\");\n@@ -1163,8 +1167,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                                                        `#[repr(simd)]` instead\");\n                 }\n                 for attr in &i.attrs {\n-                    if attr.name() == \"repr\" {\n-                        for item in attr.meta_item_list().unwrap_or(&[]) {\n+                    if attr.path == \"repr\" {\n+                        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n                             if item.check_name(\"simd\") {\n                                 gate_feature_post!(&self, repr_simd, i.span,\n                                                    \"SIMD types are experimental \\"}, {"sha": "1a4e196ac557778e3b39ec6760495ebbadbd79c6", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -489,7 +489,8 @@ pub fn noop_fold_attribute<T: Folder>(attr: Attribute, fld: &mut T) -> Option<At\n     Some(Attribute {\n         id: attr.id,\n         style: attr.style,\n-        value: fld.fold_meta_item(attr.value),\n+        path: fld.fold_path(attr.path),\n+        tokens: fld.fold_tts(attr.tokens),\n         is_sugared_doc: attr.is_sugared_doc,\n         span: fld.new_span(attr.span),\n     })\n@@ -612,7 +613,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n         token::NtIdent(id) => token::NtIdent(Spanned::<Ident>{node: fld.fold_ident(id.node), ..id}),\n-        token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n+        token::NtMeta(meta) => token::NtMeta(fld.fold_meta_item(meta)),\n         token::NtPath(path) => token::NtPath(fld.fold_path(path)),\n         token::NtTT(tt) => token::NtTT(fld.fold_tt(tt)),\n         token::NtArm(arm) => token::NtArm(fld.fold_arm(arm)),\n@@ -1371,7 +1372,7 @@ mod tests {\n             matches_codepattern,\n             \"matches_codepattern\",\n             pprust::to_string(|s| fake_print_crate(s, &folded_crate)),\n-            \"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string());\n+            \"#[zz]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string());\n     }\n \n     // even inside macro defs...."}, {"sha": "4c9a5d512af0236d13e73f27e70ae9fecd5dff58", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -65,6 +65,16 @@ macro_rules! panictry {\n     })\n }\n \n+#[macro_export]\n+macro_rules! unwrap_or {\n+    ($opt:expr, $default:expr) => {\n+        match $opt {\n+            Some(x) => x,\n+            None => $default,\n+        }\n+    }\n+}\n+\n #[macro_use]\n pub mod diagnostics {\n     #[macro_use]"}, {"sha": "53106214fa3107f53fef6b85d608e895ca1eba39", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -14,8 +14,9 @@ use syntax_pos::{mk_sp, Span};\n use codemap::spanned;\n use parse::common::SeqSep;\n use parse::PResult;\n-use parse::token;\n-use parse::parser::{Parser, TokenType};\n+use parse::token::{self, Nonterminal};\n+use parse::parser::{Parser, TokenType, PathStyle};\n+use tokenstream::TokenStream;\n \n #[derive(PartialEq, Eq, Debug)]\n enum InnerAttributeParsePolicy<'a> {\n@@ -91,7 +92,7 @@ impl<'a> Parser<'a> {\n         debug!(\"parse_attribute_with_inner_parse_policy: inner_parse_policy={:?} self.token={:?}\",\n                inner_parse_policy,\n                self.token);\n-        let (span, value, mut style) = match self.token {\n+        let (span, path, tokens, mut style) = match self.token {\n             token::Pound => {\n                 let lo = self.span.lo;\n                 self.bump();\n@@ -119,11 +120,11 @@ impl<'a> Parser<'a> {\n                 };\n \n                 self.expect(&token::OpenDelim(token::Bracket))?;\n-                let meta_item = self.parse_meta_item()?;\n+                let (path, tokens) = self.parse_path_and_tokens()?;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n                 let hi = self.prev_span.hi;\n \n-                (mk_sp(lo, hi), meta_item, style)\n+                (mk_sp(lo, hi), path, tokens, style)\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n@@ -143,12 +144,30 @@ impl<'a> Parser<'a> {\n         Ok(ast::Attribute {\n             id: attr::mk_attr_id(),\n             style: style,\n-            value: value,\n+            path: path,\n+            tokens: tokens,\n             is_sugared_doc: false,\n             span: span,\n         })\n     }\n \n+    pub fn parse_path_and_tokens(&mut self) -> PResult<'a, (ast::Path, TokenStream)> {\n+        let meta = match self.token {\n+            token::Interpolated(ref nt) => match **nt {\n+                Nonterminal::NtMeta(ref meta) => Some(meta.clone()),\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        Ok(if let Some(meta) = meta {\n+            self.bump();\n+            (ast::Path::from_ident(meta.span, ast::Ident::with_empty_ctxt(meta.name)),\n+             meta.node.tokens(meta.span))\n+        } else {\n+            (self.parse_path(PathStyle::Mod)?, self.parse_tokens())\n+        })\n+    }\n+\n     /// Parse attributes that appear after the opening of an item. These should\n     /// be preceded by an exclamation mark, but we accept and warn about one\n     /// terminated by a semicolon.\n@@ -221,15 +240,20 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         let ident = self.parse_ident()?;\n-        let node = if self.eat(&token::Eq) {\n+        let node = self.parse_meta_item_kind()?;\n+        let hi = self.prev_span.hi;\n+        Ok(ast::MetaItem { name: ident.name, node: node, span: mk_sp(lo, hi) })\n+    }\n+\n+    pub fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n+        Ok(if self.eat(&token::Eq) {\n             ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n         } else if self.token == token::OpenDelim(token::Paren) {\n             ast::MetaItemKind::List(self.parse_meta_seq()?)\n         } else {\n+            self.eat(&token::OpenDelim(token::Paren));\n             ast::MetaItemKind::Word\n-        };\n-        let hi = self.prev_span.hi;\n-        Ok(ast::MetaItem { name: ident.name, node: node, span: mk_sp(lo, hi) })\n+        })\n     }\n \n     /// matches meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;"}, {"sha": "e188bcaf105f2680f4f9453977b1670f4499df46", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 91, "deletions": 40, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -374,38 +374,80 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n         s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n-fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, sd: &Handler, sp: Span)\n-                      -> ast::LitKind {\n+macro_rules! err {\n+    ($opt_diag:expr, |$span:ident, $diag:ident| $($body:tt)*) => {\n+        match $opt_diag {\n+            Some(($span, $diag)) => { $($body)* }\n+            None => return None,\n+        }\n+    }\n+}\n+\n+pub fn lit_token(lit: token::Lit, suf: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                 -> (bool /* suffix illegal? */, Option<ast::LitKind>) {\n+    use ast::LitKind;\n+\n+    match lit {\n+       token::Byte(i) => (true, Some(LitKind::Byte(byte_lit(&i.as_str()).0))),\n+       token::Char(i) => (true, Some(LitKind::Char(char_lit(&i.as_str()).0))),\n+\n+        // There are some valid suffixes for integer and float literals,\n+        // so all the handling is done internally.\n+        token::Integer(s) => (false, integer_lit(&s.as_str(), suf, diag)),\n+        token::Float(s) => (false, float_lit(&s.as_str(), suf, diag)),\n+\n+        token::Str_(s) => {\n+            let s = Symbol::intern(&str_lit(&s.as_str()));\n+            (true, Some(LitKind::Str(s, ast::StrStyle::Cooked)))\n+        }\n+        token::StrRaw(s, n) => {\n+            let s = Symbol::intern(&raw_str_lit(&s.as_str()));\n+            (true, Some(LitKind::Str(s, ast::StrStyle::Raw(n))))\n+        }\n+        token::ByteStr(i) => {\n+            (true, Some(LitKind::ByteStr(byte_str_lit(&i.as_str()))))\n+        }\n+        token::ByteStrRaw(i, _) => {\n+            (true, Some(LitKind::ByteStr(Rc::new(i.to_string().into_bytes()))))\n+        }\n+    }\n+}\n+\n+fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                      -> Option<ast::LitKind> {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n     let suffix = match suffix {\n         Some(suffix) => suffix,\n-        None => return ast::LitKind::FloatUnsuffixed(data),\n+        None => return Some(ast::LitKind::FloatUnsuffixed(data)),\n     };\n \n-    match &*suffix.as_str() {\n+    Some(match &*suffix.as_str() {\n         \"f32\" => ast::LitKind::Float(data, ast::FloatTy::F32),\n         \"f64\" => ast::LitKind::Float(data, ast::FloatTy::F64),\n         suf => {\n-            if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n-                // if it looks like a width, lets try to be helpful.\n-                sd.struct_span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]))\n-                 .help(\"valid widths are 32 and 64\")\n-                 .emit();\n-            } else {\n-                sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for float literal\", suf))\n-                  .help(\"valid suffixes are `f32` and `f64`\")\n-                  .emit();\n-            }\n+            err!(diag, |span, diag| {\n+                if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n+                    // if it looks like a width, lets try to be helpful.\n+                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n+                    diag.struct_span_err(span, &msg).help(\"valid widths are 32 and 64\").emit()\n+                } else {\n+                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n+                    diag.struct_span_err(span, &msg)\n+                        .help(\"valid suffixes are `f32` and `f64`\")\n+                        .emit();\n+                }\n+            });\n \n             ast::LitKind::FloatUnsuffixed(data)\n         }\n-    }\n+    })\n }\n-pub fn float_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> ast::LitKind {\n+pub fn float_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                 -> Option<ast::LitKind> {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n-    filtered_float_lit(Symbol::intern(&s), suffix, sd, sp)\n+    filtered_float_lit(Symbol::intern(&s), suffix, diag)\n }\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n@@ -500,7 +542,8 @@ pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n     Rc::new(res)\n }\n \n-pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> ast::LitKind {\n+pub fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                   -> Option<ast::LitKind> {\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -524,13 +567,16 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n     // 1f64 and 2f32 etc. are valid float literals.\n     if let Some(suf) = suffix {\n         if looks_like_width_suffix(&['f'], &suf.as_str()) {\n-            match base {\n-                16 => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n-                8 => sd.span_err(sp, \"octal float literal is not supported\"),\n-                2 => sd.span_err(sp, \"binary float literal is not supported\"),\n-                _ => ()\n+            let err = match base {\n+                16 => Some(\"hexadecimal float literal is not supported\"),\n+                8 => Some(\"octal float literal is not supported\"),\n+                2 => Some(\"binary float literal is not supported\"),\n+                _ => None,\n+            };\n+            if let Some(err) = err {\n+                err!(diag, |span, diag| diag.span_err(span, err));\n             }\n-            return filtered_float_lit(Symbol::intern(&s), Some(suf), sd, sp)\n+            return filtered_float_lit(Symbol::intern(&s), Some(suf), diag)\n         }\n     }\n \n@@ -539,7 +585,9 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n     }\n \n     if let Some(suf) = suffix {\n-        if suf.as_str().is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n+        if suf.as_str().is_empty() {\n+            err!(diag, |span, diag| diag.span_bug(span, \"found empty literal suffix in Some\"));\n+        }\n         ty = match &*suf.as_str() {\n             \"isize\" => ast::LitIntType::Signed(ast::IntTy::Is),\n             \"i8\"  => ast::LitIntType::Signed(ast::IntTy::I8),\n@@ -556,17 +604,20 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n             suf => {\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n-                if looks_like_width_suffix(&['i', 'u'], suf) {\n-                    sd.struct_span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n-                                             &suf[1..]))\n-                      .help(\"valid widths are 8, 16, 32, 64 and 128\")\n-                      .emit();\n-                } else {\n-                    sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf))\n-                      .help(\"the suffix must be one of the integral types \\\n-                             (`u32`, `isize`, etc)\")\n-                      .emit();\n-                }\n+                err!(diag, |span, diag| {\n+                    if looks_like_width_suffix(&['i', 'u'], suf) {\n+                        let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n+                        diag.struct_span_err(span, &msg)\n+                            .help(\"valid widths are 8, 16, 32, 64 and 128\")\n+                            .emit();\n+                    } else {\n+                        let msg = format!(\"invalid suffix `{}` for numeric literal\", suf);\n+                        diag.struct_span_err(span, &msg)\n+                            .help(\"the suffix must be one of the integral types \\\n+                                   (`u32`, `isize`, etc)\")\n+                            .emit();\n+                    }\n+                });\n \n                 ty\n             }\n@@ -576,7 +627,7 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n     debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n            string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n-    match u128::from_str_radix(s, base) {\n+    Some(match u128::from_str_radix(s, base) {\n         Ok(r) => ast::LitKind::Int(r, ty),\n         Err(_) => {\n             // small bases are lexed as if they were base 10, e.g, the string\n@@ -588,11 +639,11 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n                 s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n \n             if !already_errored {\n-                sd.span_err(sp, \"int literal is too large\");\n+                err!(diag, |span, diag| diag.span_err(span, \"int literal is too large\"));\n             }\n             ast::LitKind::Int(0, ty)\n         }\n-    }\n+    })\n }\n \n #[cfg(test)]\n@@ -961,7 +1012,7 @@ mod tests {\n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n-        let docs = item.attrs.iter().filter(|a| a.name() == \"doc\")\n+        let docs = item.attrs.iter().filter(|a| a.path == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);"}, {"sha": "0a97accead6a2a0684de30a0a71c81afda1e30c2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 27, "deletions": 49, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -60,7 +60,6 @@ use util::ThinVec;\n use std::collections::HashSet;\n use std::{cmp, mem, slice};\n use std::path::{Path, PathBuf};\n-use std::rc::Rc;\n \n bitflags! {\n     flags Restrictions: u8 {\n@@ -891,7 +890,7 @@ impl<'a> Parser<'a> {\n \n         self.parse_seq_to_before_tokens(kets,\n                                         SeqSep::none(),\n-                                        |p| p.parse_token_tree(),\n+                                        |p| Ok(p.parse_token_tree()),\n                                         |mut e| handler.cancel(&mut e));\n     }\n \n@@ -1267,7 +1266,7 @@ impl<'a> Parser<'a> {\n                                 break;\n                             }\n                             token::OpenDelim(token::Brace) => {\n-                                self.parse_token_tree()?;\n+                                self.parse_token_tree();\n                                 break;\n                             }\n                             _ => self.bump(),\n@@ -1643,44 +1642,15 @@ impl<'a> Parser<'a> {\n                 _ => { return self.unexpected_last(&self.token); }\n             },\n             token::Literal(lit, suf) => {\n-                let (suffix_illegal, out) = match lit {\n-                    token::Byte(i) => (true, LitKind::Byte(parse::byte_lit(&i.as_str()).0)),\n-                    token::Char(i) => (true, LitKind::Char(parse::char_lit(&i.as_str()).0)),\n-\n-                    // there are some valid suffixes for integer and\n-                    // float literals, so all the handling is done\n-                    // internally.\n-                    token::Integer(s) => {\n-                        let diag = &self.sess.span_diagnostic;\n-                        (false, parse::integer_lit(&s.as_str(), suf, diag, self.span))\n-                    }\n-                    token::Float(s) => {\n-                        let diag = &self.sess.span_diagnostic;\n-                        (false, parse::float_lit(&s.as_str(), suf, diag, self.span))\n-                    }\n-\n-                    token::Str_(s) => {\n-                        let s = Symbol::intern(&parse::str_lit(&s.as_str()));\n-                        (true, LitKind::Str(s, ast::StrStyle::Cooked))\n-                    }\n-                    token::StrRaw(s, n) => {\n-                        let s = Symbol::intern(&parse::raw_str_lit(&s.as_str()));\n-                        (true, LitKind::Str(s, ast::StrStyle::Raw(n)))\n-                    }\n-                    token::ByteStr(i) => {\n-                        (true, LitKind::ByteStr(parse::byte_str_lit(&i.as_str())))\n-                    }\n-                    token::ByteStrRaw(i, _) => {\n-                        (true, LitKind::ByteStr(Rc::new(i.to_string().into_bytes())))\n-                    }\n-                };\n+                let diag = Some((self.span, &self.sess.span_diagnostic));\n+                let (suffix_illegal, result) = parse::lit_token(lit, suf, diag);\n \n                 if suffix_illegal {\n                     let sp = self.span;\n                     self.expect_no_suffix(sp, &format!(\"{} literal\", lit.short_name()), suf)\n                 }\n \n-                out\n+                result.unwrap()\n             }\n             _ => { return self.unexpected_last(&self.token); }\n         };\n@@ -2108,10 +2078,10 @@ impl<'a> Parser<'a> {\n \n     fn expect_delimited_token_tree(&mut self) -> PResult<'a, (token::DelimToken, ThinTokenStream)> {\n         match self.token {\n-            token::OpenDelim(delim) => self.parse_token_tree().map(|tree| match tree {\n-                TokenTree::Delimited(_, delimited) => (delim, delimited.stream().into()),\n+            token::OpenDelim(delim) => match self.parse_token_tree() {\n+                TokenTree::Delimited(_, delimited) => Ok((delim, delimited.stream().into())),\n                 _ => unreachable!(),\n-            }),\n+            },\n             _ => Err(self.fatal(\"expected open delimiter\")),\n         }\n     }\n@@ -2656,24 +2626,23 @@ impl<'a> Parser<'a> {\n     }\n \n     /// parse a single token tree from the input.\n-    pub fn parse_token_tree(&mut self) -> PResult<'a, TokenTree> {\n+    pub fn parse_token_tree(&mut self) -> TokenTree {\n         match self.token {\n             token::OpenDelim(..) => {\n                 let frame = mem::replace(&mut self.token_cursor.frame,\n                                          self.token_cursor.stack.pop().unwrap());\n                 self.span = frame.span;\n                 self.bump();\n-                return Ok(TokenTree::Delimited(frame.span, Delimited {\n+                TokenTree::Delimited(frame.span, Delimited {\n                     delim: frame.delim,\n                     tts: frame.tree_cursor.original_stream().into(),\n-                }));\n+                })\n             },\n             token::CloseDelim(_) | token::Eof => unreachable!(),\n             _ => {\n                 let token = mem::replace(&mut self.token, token::Underscore);\n-                let res = Ok(TokenTree::Token(self.span, token));\n                 self.bump();\n-                res\n+                TokenTree::Token(self.prev_span, token)\n             }\n         }\n     }\n@@ -2683,11 +2652,22 @@ impl<'a> Parser<'a> {\n     pub fn parse_all_token_trees(&mut self) -> PResult<'a, Vec<TokenTree>> {\n         let mut tts = Vec::new();\n         while self.token != token::Eof {\n-            tts.push(self.parse_token_tree()?);\n+            tts.push(self.parse_token_tree());\n         }\n         Ok(tts)\n     }\n \n+    pub fn parse_tokens(&mut self) -> TokenStream {\n+        let mut result = Vec::new();\n+        loop {\n+            match self.token {\n+                token::Eof | token::CloseDelim(..) => break,\n+                _ => result.push(self.parse_token_tree().into()),\n+            }\n+        }\n+        TokenStream::concat(result)\n+    }\n+\n     /// Parse a prefix-unary-operator expr\n     pub fn parse_prefix_expr(&mut self,\n                              already_parsed_attrs: Option<ThinVec<Attribute>>)\n@@ -5181,11 +5161,9 @@ impl<'a> Parser<'a> {\n                     let attr = ast::Attribute {\n                         id: attr::mk_attr_id(),\n                         style: ast::AttrStyle::Outer,\n-                        value: ast::MetaItem {\n-                            name: Symbol::intern(\"warn_directory_ownership\"),\n-                            node: ast::MetaItemKind::Word,\n-                            span: syntax_pos::DUMMY_SP,\n-                        },\n+                        path: ast::Path::from_ident(syntax_pos::DUMMY_SP,\n+                                                    Ident::from_str(\"warn_directory_ownership\")),\n+                        tokens: TokenStream::empty(),\n                         is_sugared_doc: false,\n                         span: syntax_pos::DUMMY_SP,\n                     };"}, {"sha": "75852629ce131817bfd5e00f5ce3bc3398cabeb2", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -17,7 +17,7 @@ pub use self::Token::*;\n use ast::{self};\n use ptr::P;\n use symbol::keywords;\n-use tokenstream;\n+use tokenstream::TokenTree;\n \n use std::fmt;\n use std::rc::Rc;\n@@ -349,7 +349,7 @@ pub enum Nonterminal {\n     /// Stuff inside brackets for attributes\n     NtMeta(ast::MetaItem),\n     NtPath(ast::Path),\n-    NtTT(tokenstream::TokenTree),\n+    NtTT(TokenTree),\n     // These are not exposed to macros, but are used by quasiquote.\n     NtArm(ast::Arm),\n     NtImplItem(ast::ImplItem),"}, {"sha": "f042a18d610360b1184c306d95117706de49056d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 59, "deletions": 41, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -28,7 +28,7 @@ use ptr::P;\n use std_inject;\n use symbol::{Symbol, keywords};\n use syntax_pos::DUMMY_SP;\n-use tokenstream::{self, TokenTree};\n+use tokenstream::{self, TokenStream, TokenTree};\n \n use std::ascii;\n use std::io::{self, Write, Read};\n@@ -329,6 +329,10 @@ pub fn tts_to_string(tts: &[tokenstream::TokenTree]) -> String {\n     to_string(|s| s.print_tts(tts.iter().cloned().collect()))\n }\n \n+pub fn tokens_to_string(tokens: TokenStream) -> String {\n+    to_string(|s| s.print_tts(tokens))\n+}\n+\n pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n     to_string(|s| s.print_stmt(stmt))\n }\n@@ -750,7 +754,21 @@ pub trait PrintState<'a> {\n                 ast::AttrStyle::Inner => word(self.writer(), \"#![\")?,\n                 ast::AttrStyle::Outer => word(self.writer(), \"#[\")?,\n             }\n-            self.print_meta_item(&attr.meta())?;\n+            if let Some(mi) = attr.meta() {\n+                self.print_meta_item(&mi)?\n+            } else {\n+                for (i, segment) in attr.path.segments.iter().enumerate() {\n+                    if i > 0 {\n+                        word(self.writer(), \"::\")?\n+                    }\n+                    if segment.identifier.name != keywords::CrateRoot.name() &&\n+                       segment.identifier.name != \"$crate\" {\n+                        word(self.writer(), &segment.identifier.name.as_str())?;\n+                    }\n+                }\n+                space(self.writer())?;\n+                self.print_tts(attr.tokens.clone())?;\n+            }\n             word(self.writer(), \"]\")\n         }\n     }\n@@ -789,6 +807,45 @@ pub trait PrintState<'a> {\n         self.end()\n     }\n \n+    /// This doesn't deserve to be called \"pretty\" printing, but it should be\n+    /// meaning-preserving. A quick hack that might help would be to look at the\n+    /// spans embedded in the TTs to decide where to put spaces and newlines.\n+    /// But it'd be better to parse these according to the grammar of the\n+    /// appropriate macro, transcribe back into the grammar we just parsed from,\n+    /// and then pretty-print the resulting AST nodes (so, e.g., we print\n+    /// expression arguments as expressions). It can be done! I think.\n+    fn print_tt(&mut self, tt: tokenstream::TokenTree) -> io::Result<()> {\n+        match tt {\n+            TokenTree::Token(_, ref tk) => {\n+                word(self.writer(), &token_to_string(tk))?;\n+                match *tk {\n+                    parse::token::DocComment(..) => {\n+                        hardbreak(self.writer())\n+                    }\n+                    _ => Ok(())\n+                }\n+            }\n+            TokenTree::Delimited(_, ref delimed) => {\n+                word(self.writer(), &token_to_string(&delimed.open_token()))?;\n+                space(self.writer())?;\n+                self.print_tts(delimed.stream())?;\n+                space(self.writer())?;\n+                word(self.writer(), &token_to_string(&delimed.close_token()))\n+            },\n+        }\n+    }\n+\n+    fn print_tts(&mut self, tts: tokenstream::TokenStream) -> io::Result<()> {\n+        self.ibox(0)?;\n+        for (i, tt) in tts.into_trees().enumerate() {\n+            if i != 0 {\n+                space(self.writer())?;\n+            }\n+            self.print_tt(tt)?;\n+        }\n+        self.end()\n+    }\n+\n     fn space_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() { space(self.writer())?; }\n         Ok(())\n@@ -1458,45 +1515,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    /// This doesn't deserve to be called \"pretty\" printing, but it should be\n-    /// meaning-preserving. A quick hack that might help would be to look at the\n-    /// spans embedded in the TTs to decide where to put spaces and newlines.\n-    /// But it'd be better to parse these according to the grammar of the\n-    /// appropriate macro, transcribe back into the grammar we just parsed from,\n-    /// and then pretty-print the resulting AST nodes (so, e.g., we print\n-    /// expression arguments as expressions). It can be done! I think.\n-    pub fn print_tt(&mut self, tt: tokenstream::TokenTree) -> io::Result<()> {\n-        match tt {\n-            TokenTree::Token(_, ref tk) => {\n-                word(&mut self.s, &token_to_string(tk))?;\n-                match *tk {\n-                    parse::token::DocComment(..) => {\n-                        hardbreak(&mut self.s)\n-                    }\n-                    _ => Ok(())\n-                }\n-            }\n-            TokenTree::Delimited(_, ref delimed) => {\n-                word(&mut self.s, &token_to_string(&delimed.open_token()))?;\n-                space(&mut self.s)?;\n-                self.print_tts(delimed.stream())?;\n-                space(&mut self.s)?;\n-                word(&mut self.s, &token_to_string(&delimed.close_token()))\n-            },\n-        }\n-    }\n-\n-    pub fn print_tts(&mut self, tts: tokenstream::TokenStream) -> io::Result<()> {\n-        self.ibox(0)?;\n-        for (i, tt) in tts.into_trees().enumerate() {\n-            if i != 0 {\n-                space(&mut self.s)?;\n-            }\n-            self.print_tt(tt)?;\n-        }\n-        self.end()\n-    }\n-\n     pub fn print_variant(&mut self, v: &ast::Variant) -> io::Result<()> {\n         self.head(\"\")?;\n         let generics = ast::Generics::default();"}, {"sha": "c541df9230a642ae80feeac75c1fbe70e406e20b", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -15,6 +15,7 @@ use syntax_pos::{DUMMY_SP, Span};\n use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n use parse::ParseSess;\n use ptr::P;\n+use tokenstream::TokenStream;\n \n /// Craft a span that will be ignored by the stability lint's\n /// call to codemap's is_internal check.\n@@ -70,11 +71,8 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,\n-            value: ast::MetaItem {\n-                name: Symbol::intern(\"prelude_import\"),\n-                node: ast::MetaItemKind::Word,\n-                span: span,\n-            },\n+            path: ast::Path::from_ident(span, ast::Ident::from_str(\"prelude_import\")),\n+            tokens: TokenStream::empty(),\n             id: attr::mk_attr_id(),\n             is_sugared_doc: false,\n             span: span,"}, {"sha": "35e4d9eb68aeaa4d9c992dde123854ce4d6de1bd", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -360,7 +360,7 @@ impl PartialEq<ThinTokenStream> for ThinTokenStream {\n \n impl fmt::Display for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(&pprust::tts_to_string(&self.trees().collect::<Vec<_>>()))\n+        f.write_str(&pprust::tokens_to_string(self.clone()))\n     }\n }\n "}, {"sha": "b01ef65e5fe5ed41611cce78fe34c554b6d135c7", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -23,9 +23,11 @@ struct MarkAttrs<'a>(&'a [ast::Name]);\n \n impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n-        if self.0.contains(&attr.name()) {\n-            mark_used(attr);\n-            mark_known(attr);\n+        if let Some(name) = attr.name() {\n+            if self.0.contains(&name) {\n+                mark_used(attr);\n+                mark_known(attr);\n+            }\n         }\n     }\n "}, {"sha": "48e7ff0d24370a9bb3bbbb0330a21e47f4a3b598", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -439,7 +439,7 @@ impl<'a> TraitDef<'a> {\n                 attrs.extend(item.attrs\n                     .iter()\n                     .filter(|a| {\n-                        match &*a.name().as_str() {\n+                        a.name().is_some() && match &*a.name().unwrap().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" | \"stable\" | \"unstable\" => true,\n                             _ => false,\n                         }"}, {"sha": "2d815b3f1bb7d9957afa1e9f2cbcd28acf9f07ac", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -248,7 +248,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.node {\n             if self.is_proc_macro_crate &&\n-               item.attrs.iter().any(|attr| attr.name() == \"macro_export\") {\n+               item.attrs.iter().any(|attr| attr.path == \"macro_export\") {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(item.span, msg);\n@@ -270,12 +270,12 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         for attr in &item.attrs {\n             if is_proc_macro_attr(&attr) {\n                 if let Some(prev_attr) = found_attr {\n-                    let msg = if attr.name() == prev_attr.name() {\n+                    let msg = if attr.path == prev_attr.path {\n                         format!(\"Only one `#[{}]` attribute is allowed on any given function\",\n-                                attr.name())\n+                                attr.path)\n                     } else {\n                         format!(\"`#[{}]` and `#[{}]` attributes cannot both be applied \\\n-                                to the same function\", attr.name(), prev_attr.name())\n+                                to the same function\", attr.path, prev_attr.path)\n                     };\n \n                     self.handler.struct_span_err(attr.span(), &msg)\n@@ -299,7 +299,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n \n         if !is_fn {\n             let msg = format!(\"the `#[{}]` attribute may only be used on bare functions\",\n-                              attr.name());\n+                              attr.path);\n \n             self.handler.span_err(attr.span(), &msg);\n             return;\n@@ -311,7 +311,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n \n         if !self.is_proc_macro_crate {\n             let msg = format!(\"the `#[{}]` attribute is only usable with crates of the \\\n-                              `proc-macro` crate type\", attr.name());\n+                              `proc-macro` crate type\", attr.path);\n \n             self.handler.span_err(attr.span(), &msg);\n             return;"}, {"sha": "df881bedec1bbf5202dfd618eefe913c658c13fc", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-attributes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -20,6 +20,7 @@ extern crate derive_b;\n #[C] //~ ERROR: The attribute `C` is currently unknown to the compiler\n #[B(D)]\n #[B(E = \"foo\")]\n+#[B arbitrary tokens] //~ expected one of `(` or `=`, found `arbitrary`\n struct B;\n \n fn main() {}"}, {"sha": "52f867fe913b8af0a3de2bcc19a46ecfcf443b66", "filename": "src/test/compile-fail/macro-attribute.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fcompile-fail%2Fmacro-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fcompile-fail%2Fmacro-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-attribute.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -8,7 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n #[doc = $not_there] //~ error: unexpected token: `$`\n fn main() { }", "previous_filename": "src/test/parse-fail/macro-attribute.rs"}, {"sha": "c28e22d58f9db8f6adc2f1a104903e9a47112cac", "filename": "src/test/compile-fail/macro-with-seps-err-msg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fcompile-fail%2Fmacro-with-seps-err-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fcompile-fail%2Fmacro-with-seps-err-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-with-seps-err-msg.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -14,4 +14,5 @@ fn main() {\n     globnar::brotz!(); //~ ERROR non-ident macro paths are experimental\n     ::foo!(); //~ ERROR non-ident macro paths are experimental\n     foo::<T>!(); //~ ERROR type parameters are not allowed on macros\n+    #[derive(foo::Bar)] struct T; //~ ERROR non-ident macro paths are experimental\n }"}, {"sha": "ac000628f2b0498331d4ceb729fe3e40cdaa4f60", "filename": "src/test/compile-fail/malformed-derive-entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fcompile-fail%2Fmalformed-derive-entry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fcompile-fail%2Fmalformed-derive-entry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmalformed-derive-entry.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n #[derive(Copy(Bad))]\n-//~^ ERROR malformed `derive` entry\n+//~^ ERROR expected one of `)`, `,`, or `::`, found `(`\n struct Test1;\n \n #[derive(Copy=\"bad\")]\n-//~^ ERROR malformed `derive` entry\n+//~^ ERROR expected one of `)`, `,`, or `::`, found `=`\n struct Test2;\n \n #[derive()]"}, {"sha": "bf55b7bdcb1def55da516ae84240abe19d0b3876", "filename": "src/test/compile-fail/suffixed-literal-meta.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fcompile-fail%2Fsuffixed-literal-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fcompile-fail%2Fsuffixed-literal-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuffixed-literal-meta.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(attr_literals)]\n+\n+#[path = 1usize] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1u8] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1u16] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1u32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1u64] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1isize] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1i8] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1i16] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1i32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1i64] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1.0f32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1.0f64] //~ ERROR: suffixed literals are not allowed in attributes\n+fn main() { }"}, {"sha": "d57a813311b5ab509f35fe980da31c47624fbdf2", "filename": "src/test/parse-fail/attr-bad-meta.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n-// error-pattern:expected one of `=` or `]`\n-\n // asterisk is bogus\n-#[attr*]\n+#[path*] //~ ERROR expected one of `(` or `=`\n mod m {}"}, {"sha": "0e2840c69d3643eee7e58f2f646b59b1448a1e2f", "filename": "src/test/parse-fail/suffixed-literal-meta.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bfc49b1092512aee4fe3d1348c3250fcdc8978d3/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc49b1092512aee4fe3d1348c3250fcdc8978d3/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs?ref=bfc49b1092512aee4fe3d1348c3250fcdc8978d3", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-#[foo = 1usize] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1u8] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1u16] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1u32] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1u64] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1isize] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1i8] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1i16] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1i32] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1i64] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1.0f32] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1.0f64] //~ ERROR: suffixed literals are not allowed in attributes\n-fn main() { }"}, {"sha": "8a9fdd7536770dc07fdd3357f63e0893e08654c9", "filename": "src/test/run-pass-fulldeps/proc-macro/attr-args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -19,6 +19,6 @@ use attr_args::attr_with_args;\n #[attr_with_args(text = \"Hello, world!\")]\n fn foo() {}\n \n-fn main() {\n-    assert_eq!(foo(), \"Hello, world!\");\n-}\n+#[::attr_args::identity\n+  fn main() { assert_eq!(foo(), \"Hello, world!\"); }]\n+struct Dummy;"}, {"sha": "989c77f1089cfbe913b11adb77663bc3d194c429", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/attr-args.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -30,3 +30,8 @@ pub fn attr_with_args(args: TokenStream, input: TokenStream) -> TokenStream {\n         fn foo() -> &'static str { \"Hello, world!\" }\n     \"#.parse().unwrap()\n }\n+\n+#[proc_macro_attribute]\n+pub fn identity(attr_args: TokenStream, _: TokenStream) -> TokenStream {\n+    attr_args\n+}"}, {"sha": "7b521f2b9138a21bb01c40d2ae9ea1d7ff0ebdb5", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -19,7 +19,7 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(B, attributes(B, C))]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert!(input.contains(\"#[B]\"));\n+    assert!(input.contains(\"#[B arbitrary tokens]\"));\n     assert!(input.contains(\"struct B {\"));\n     assert!(input.contains(\"#[C]\"));\n     \"\".parse().unwrap()"}, {"sha": "995dc65729a5059f8719c88ee9b3f7380886cc02", "filename": "src/test/run-pass-fulldeps/proc-macro/derive-b.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -11,11 +11,12 @@\n // aux-build:derive-b.rs\n // ignore-stage1\n \n-#[macro_use]\n+#![feature(proc_macro)]\n+\n extern crate derive_b;\n \n-#[derive(Debug, PartialEq, B, Eq, Copy, Clone)]\n-#[B]\n+#[derive(Debug, PartialEq, derive_b::B, Eq, Copy, Clone)]\n+#[cfg_attr(all(), B arbitrary tokens)]\n struct B {\n     #[C]\n     a: u64"}, {"sha": "b2da0c6a296d8fc5119d4f68560f799f9947408d", "filename": "src/test/ui/span/E0536.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fui%2Fspan%2FE0536.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fui%2Fspan%2FE0536.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0536.stderr?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -2,7 +2,7 @@ error[E0536]: expected 1 cfg-pattern\n   --> $DIR/E0536.rs:11:7\n    |\n 11 | #[cfg(not())] //~ ERROR E0536\n-   |       ^^^^^\n+   |       ^^^\n \n error: aborting due to previous error\n "}, {"sha": "29873943f444d8e65a7fc59f27af530744919307", "filename": "src/test/ui/span/E0537.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fui%2Fspan%2FE0537.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c15de4fd59bee290848b5443c7e194fd5afb02c/src%2Ftest%2Fui%2Fspan%2FE0537.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0537.stderr?ref=9c15de4fd59bee290848b5443c7e194fd5afb02c", "patch": "@@ -2,7 +2,7 @@ error[E0537]: invalid predicate `unknown`\n   --> $DIR/E0537.rs:11:7\n    |\n 11 | #[cfg(unknown())] //~ ERROR E0537\n-   |       ^^^^^^^^^\n+   |       ^^^^^^^\n \n error: aborting due to previous error\n "}]}