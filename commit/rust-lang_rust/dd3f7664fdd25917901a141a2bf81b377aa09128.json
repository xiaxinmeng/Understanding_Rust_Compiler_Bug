{"sha": "dd3f7664fdd25917901a141a2bf81b377aa09128", "node_id": "C_kwDOAAsO6NoAKGRkM2Y3NjY0ZmRkMjU5MTc5MDFhMTQxYTJiZjgxYjM3N2FhMDkxMjg", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-04-03T13:11:04Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-04-03T13:18:05Z"}, "message": "fix: Add missing fields diagnostic fix for patterns", "tree": {"sha": "afc2a343e5f038d2a9e7a19aa6cdc30d4bac555f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afc2a343e5f038d2a9e7a19aa6cdc30d4bac555f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd3f7664fdd25917901a141a2bf81b377aa09128", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd3f7664fdd25917901a141a2bf81b377aa09128", "html_url": "https://github.com/rust-lang/rust/commit/dd3f7664fdd25917901a141a2bf81b377aa09128", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd3f7664fdd25917901a141a2bf81b377aa09128/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1da2d82f5825797670cc8103aaae83d34f53d021", "url": "https://api.github.com/repos/rust-lang/rust/commits/1da2d82f5825797670cc8103aaae83d34f53d021", "html_url": "https://github.com/rust-lang/rust/commit/1da2d82f5825797670cc8103aaae83d34f53d021"}], "stats": {"total": 246, "additions": 184, "deletions": 62}, "files": [{"sha": "6b70db9bfda3b80aa77410b40e41a4f6a0a41c96", "filename": "crates/ide_diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 135, "deletions": 60, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f7664fdd25917901a141a2bf81b377aa09128/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f7664fdd25917901a141a2bf81b377aa09128/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=dd3f7664fdd25917901a141a2bf81b377aa09128", "patch": "@@ -9,7 +9,7 @@ use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, make},\n-    AstNode, SyntaxNodePtr,\n+    AstNode, SyntaxNode, SyntaxNodePtr,\n };\n use text_edit::TextEdit;\n \n@@ -55,70 +55,95 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n     }\n \n     let root = ctx.sema.db.parse_or_expand(d.file)?;\n-    let field_list_parent = match &d.field_list_parent {\n-        Either::Left(record_expr) => record_expr.to_node(&root),\n-        // FIXE: patterns should be fixable as well.\n-        Either::Right(_) => return None,\n-    };\n-    let old_field_list = field_list_parent.record_expr_field_list()?;\n \n-    let new_field_list = old_field_list.clone_for_update();\n-    let mut locals = FxHashMap::default();\n-    ctx.sema.scope(field_list_parent.syntax())?.process_all_names(&mut |name, def| {\n-        if let hir::ScopeDef::Local(local) = def {\n-            locals.insert(name, local);\n-        }\n-    });\n-    let missing_fields = ctx.sema.record_literal_missing_fields(&field_list_parent);\n-\n-    let generate_fill_expr = |ty: &Type| match ctx.config.expr_fill_default {\n-        crate::ExprFillDefaultMode::Todo => Some(make::ext::expr_todo()),\n-        crate::ExprFillDefaultMode::Default => {\n-            let default_constr = get_default_constructor(ctx, d, ty);\n-            match default_constr {\n-                Some(default_constr) => Some(default_constr),\n-                _ => Some(make::ext::expr_todo()),\n+    let build_text_edit = |parent_syntax, new_syntax: &SyntaxNode, old_syntax| {\n+        let edit = {\n+            let mut builder = TextEdit::builder();\n+            if d.file.is_macro() {\n+                // we can't map the diff up into the macro input unfortunately, as the macro loses all\n+                // whitespace information so the diff wouldn't be applicable no matter what\n+                // This has the downside that the cursor will be moved in macros by doing it without a diff\n+                // but that is a trade off we can make.\n+                // FIXME: this also currently discards a lot of whitespace in the input... we really need a formatter here\n+                let range = ctx.sema.original_range_opt(old_syntax)?;\n+                builder.replace(range.range, new_syntax.to_string());\n+            } else {\n+                algo::diff(old_syntax, new_syntax).into_text_edit(&mut builder);\n             }\n-        }\n+            builder.finish()\n+        };\n+        Some(vec![fix(\n+            \"fill_missing_fields\",\n+            \"Fill struct fields\",\n+            SourceChange::from_text_edit(d.file.original_file(ctx.sema.db), edit),\n+            ctx.sema.original_range(parent_syntax).range,\n+        )])\n     };\n \n-    for (f, ty) in missing_fields.iter() {\n-        let field_expr = if let Some(local_candidate) = locals.get(&f.name(ctx.sema.db)) {\n-            cov_mark::hit!(field_shorthand);\n-            let candidate_ty = local_candidate.ty(ctx.sema.db);\n-            if ty.could_unify_with(ctx.sema.db, &candidate_ty) {\n-                None\n-            } else {\n-                generate_fill_expr(ty)\n+    match &d.field_list_parent {\n+        Either::Left(record_expr) => {\n+            let field_list_parent = record_expr.to_node(&root);\n+            let missing_fields = ctx.sema.record_literal_missing_fields(&field_list_parent);\n+\n+            let mut locals = FxHashMap::default();\n+            ctx.sema.scope(field_list_parent.syntax())?.process_all_names(&mut |name, def| {\n+                if let hir::ScopeDef::Local(local) = def {\n+                    locals.insert(name, local);\n+                }\n+            });\n+\n+            let generate_fill_expr = |ty: &Type| match ctx.config.expr_fill_default {\n+                crate::ExprFillDefaultMode::Todo => make::ext::expr_todo(),\n+                crate::ExprFillDefaultMode::Default => {\n+                    get_default_constructor(ctx, d, ty).unwrap_or_else(|| make::ext::expr_todo())\n+                }\n+            };\n+\n+            let old_field_list = field_list_parent.record_expr_field_list()?;\n+            let new_field_list = old_field_list.clone_for_update();\n+            for (f, ty) in missing_fields.iter() {\n+                let field_expr = if let Some(local_candidate) = locals.get(&f.name(ctx.sema.db)) {\n+                    cov_mark::hit!(field_shorthand);\n+                    let candidate_ty = local_candidate.ty(ctx.sema.db);\n+                    if ty.could_unify_with(ctx.sema.db, &candidate_ty) {\n+                        None\n+                    } else {\n+                        Some(generate_fill_expr(ty))\n+                    }\n+                } else {\n+                    Some(generate_fill_expr(ty))\n+                };\n+                let field = make::record_expr_field(\n+                    make::name_ref(&f.name(ctx.sema.db).to_smol_str()),\n+                    field_expr,\n+                );\n+                new_field_list.add_field(field.clone_for_update());\n             }\n-        } else {\n-            generate_fill_expr(ty)\n-        };\n-        let field =\n-            make::record_expr_field(make::name_ref(&f.name(ctx.sema.db).to_smol_str()), field_expr)\n-                .clone_for_update();\n-        new_field_list.add_field(field);\n-    }\n-\n-    let mut builder = TextEdit::builder();\n-    if d.file.is_macro() {\n-        // we can't map the diff up into the macro input unfortunately, as the macro loses all\n-        // whitespace information so the diff wouldn't be applicable no matter what\n-        // This has the downside that the cursor will be moved in macros by doing it without a diff\n-        // but that is a trade off we can make.\n-        // FIXE: this also currently discards a lot of whitespace in the input... we really need a formatter here\n-        let range = ctx.sema.original_range_opt(old_field_list.syntax())?;\n-        builder.replace(range.range, new_field_list.to_string());\n-    } else {\n-        algo::diff(old_field_list.syntax(), new_field_list.syntax()).into_text_edit(&mut builder);\n+            build_text_edit(\n+                field_list_parent.syntax(),\n+                new_field_list.syntax(),\n+                old_field_list.syntax(),\n+            )\n+        }\n+        Either::Right(record_pat) => {\n+            let field_list_parent = record_pat.to_node(&root);\n+            let missing_fields = ctx.sema.record_pattern_missing_fields(&field_list_parent);\n+\n+            let old_field_list = field_list_parent.record_pat_field_list()?;\n+            let new_field_list = old_field_list.clone_for_update();\n+            for (f, _) in missing_fields.iter() {\n+                let field = make::record_pat_field_shorthand(make::name_ref(\n+                    &f.name(ctx.sema.db).to_smol_str(),\n+                ));\n+                new_field_list.add_field(field.clone_for_update());\n+            }\n+            build_text_edit(\n+                field_list_parent.syntax(),\n+                new_field_list.syntax(),\n+                old_field_list.syntax(),\n+            )\n+        }\n     }\n-    let edit = builder.finish();\n-    Some(vec![fix(\n-        \"fill_missing_fields\",\n-        \"Fill struct fields\",\n-        SourceChange::from_text_edit(d.file.original_file(ctx.sema.db), edit),\n-        ctx.sema.original_range(field_list_parent.syntax()).range,\n-    )])\n }\n \n fn make_ty(ty: &hir::Type, db: &dyn HirDatabase, module: hir::Module) -> ast::Type {\n@@ -190,7 +215,7 @@ mod tests {\n struct S { foo: i32, bar: () }\n fn baz(s: S) {\n     let S { foo: _ } = s;\n-      //^ error: missing structure fields:\n+      //^ \ud83d\udca1 error: missing structure fields:\n       //| - bar\n }\n \"#,\n@@ -581,6 +606,56 @@ fn f() {\n         );\n     }\n \n+    #[test]\n+    fn test_fill_struct_pat_fields() {\n+        check_fix(\n+            r#\"\n+struct S { a: &'static str, b: i32 }\n+\n+fn f() {\n+    let S {\n+        $0\n+    };\n+}\n+\"#,\n+            r#\"\n+struct S { a: &'static str, b: i32 }\n+\n+fn f() {\n+    let S {\n+        a,\n+        b,\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_pat_fields_partial() {\n+        check_fix(\n+            r#\"\n+struct S { a: &'static str, b: i32 }\n+\n+fn f() {\n+    let S {\n+        a,$0\n+    };\n+}\n+\"#,\n+            r#\"\n+struct S { a: &'static str, b: i32 }\n+\n+fn f() {\n+    let S {\n+        a,\n+        b,\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn import_extern_crate_clash_with_inner_item() {\n         // This is more of a resolver test, but doesn't really work with the hir_def testsuite."}, {"sha": "3fb84c9f3c292758534fa0b9a9166b6ad585c3b4", "filename": "crates/ide_diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f7664fdd25917901a141a2bf81b377aa09128/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f7664fdd25917901a141a2bf81b377aa09128/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=dd3f7664fdd25917901a141a2bf81b377aa09128", "patch": "@@ -396,14 +396,14 @@ fn main() {\n         //^ error: missing match arm\n     match a {\n         Either::A { } => (),\n-      //^^^^^^^^^ error: missing structure fields:\n+      //^^^^^^^^^ \ud83d\udca1 error: missing structure fields:\n       //        | - foo\n         Either::B => (),\n     }\n     match a {\n         //^ error: missing match arm\n         Either::A { } => (),\n-    } //^^^^^^^^^ error: missing structure fields:\n+    } //^^^^^^^^^ \ud83d\udca1 error: missing structure fields:\n       //        | - foo\n \n     match a {"}, {"sha": "7945252636a7568ae04ec1dfb9b2fed973b36da3", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f7664fdd25917901a141a2bf81b377aa09128/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f7664fdd25917901a141a2bf81b377aa09128/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=dd3f7664fdd25917901a141a2bf81b377aa09128", "patch": "@@ -546,6 +546,49 @@ impl ast::RecordExprField {\n     }\n }\n \n+impl ast::RecordPatFieldList {\n+    pub fn add_field(&self, field: ast::RecordPatField) {\n+        let is_multiline = self.syntax().text().contains_char('\\n');\n+        let whitespace = if is_multiline {\n+            let indent = IndentLevel::from_node(self.syntax()) + 1;\n+            make::tokens::whitespace(&format!(\"\\n{}\", indent))\n+        } else {\n+            make::tokens::single_space()\n+        };\n+\n+        if is_multiline {\n+            normalize_ws_between_braces(self.syntax());\n+        }\n+\n+        let position = match self.fields().last() {\n+            Some(last_field) => {\n+                let comma = match last_field\n+                    .syntax()\n+                    .siblings_with_tokens(Direction::Next)\n+                    .filter_map(|it| it.into_token())\n+                    .find(|it| it.kind() == T![,])\n+                {\n+                    Some(it) => it,\n+                    None => {\n+                        let comma = ast::make::token(T![,]);\n+                        ted::insert(Position::after(last_field.syntax()), &comma);\n+                        comma\n+                    }\n+                };\n+                Position::after(comma)\n+            }\n+            None => match self.l_curly_token() {\n+                Some(it) => Position::after(it),\n+                None => Position::last_child_of(self.syntax()),\n+            },\n+        };\n+\n+        ted::insert_all(position, vec![whitespace.into(), field.syntax().clone().into()]);\n+        if is_multiline {\n+            ted::insert(Position::after(field.syntax()), ast::make::token(T![,]));\n+        }\n+    }\n+}\n impl ast::StmtList {\n     pub fn push_front(&self, statement: ast::Stmt) {\n         ted::insert(Position::after(self.l_curly_token().unwrap()), statement.syntax());"}, {"sha": "d7a7d2d32a5b00f839fb95f007b545201ccb01e1", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f7664fdd25917901a141a2bf81b377aa09128/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f7664fdd25917901a141a2bf81b377aa09128/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=dd3f7664fdd25917901a141a2bf81b377aa09128", "patch": "@@ -555,6 +555,10 @@ pub fn record_pat_field(name_ref: ast::NameRef, pat: ast::Pat) -> ast::RecordPat\n     ast_from_text(&format!(\"fn f(S {{ {}: {} }}: ()))\", name_ref, pat))\n }\n \n+pub fn record_pat_field_shorthand(name_ref: ast::NameRef) -> ast::RecordPatField {\n+    ast_from_text(&format!(\"fn f(S {{ {} }}: ()))\", name_ref))\n+}\n+\n /// Returns a `BindPat` if the path has just one segment, a `PathPat` otherwise.\n pub fn path_pat(path: ast::Path) -> ast::Pat {\n     return from_text(&path.to_string());"}]}