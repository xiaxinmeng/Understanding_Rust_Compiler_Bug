{"sha": "413a12909f3b149af17d75268ed4a136afb82c36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxM2ExMjkwOWYzYjE0OWFmMTdkNzUyNjhlZDRhMTM2YWZiODJjMzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-23T14:40:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-23T14:40:20Z"}, "message": "Auto merge of #71467 - Dylan-DPC:rollup-d1os8ug, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #71005 (Reading from the return place is fine)\n - #71198 (Const check/promotion cleanup and sanity assertion)\n - #71396 (Improve E0308 error message wording again)\n - #71452 (Remove outdated reference to interpreter snapshotting)\n - #71454 (Inline some function docs in `core::ptr`)\n - #71461 (Improve E0567 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8e0197c08f480cf9e67e32e05b25afa61fe043c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e0197c08f480cf9e67e32e05b25afa61fe043c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/413a12909f3b149af17d75268ed4a136afb82c36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/413a12909f3b149af17d75268ed4a136afb82c36", "html_url": "https://github.com/rust-lang/rust/commit/413a12909f3b149af17d75268ed4a136afb82c36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/413a12909f3b149af17d75268ed4a136afb82c36/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66f7a5d92f5adb9053bf66e0bf8f6d31d404870d", "url": "https://api.github.com/repos/rust-lang/rust/commits/66f7a5d92f5adb9053bf66e0bf8f6d31d404870d", "html_url": "https://github.com/rust-lang/rust/commit/66f7a5d92f5adb9053bf66e0bf8f6d31d404870d"}, {"sha": "47e2687a4eaf190ebd7eebdee7c32e839a6f14cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/47e2687a4eaf190ebd7eebdee7c32e839a6f14cf", "html_url": "https://github.com/rust-lang/rust/commit/47e2687a4eaf190ebd7eebdee7c32e839a6f14cf"}], "stats": {"total": 670, "additions": 307, "deletions": 363}, "files": [{"sha": "84f28488c74b678c8e28f5adf179a392478a3076", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -76,12 +76,15 @@ use crate::intrinsics::{self, is_aligned_and_not_null, is_nonoverlapping};\n use crate::mem::{self, MaybeUninit};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(inline)]\n pub use crate::intrinsics::copy_nonoverlapping;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(inline)]\n pub use crate::intrinsics::copy;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(inline)]\n pub use crate::intrinsics::write_bytes;\n \n mod non_null;"}, {"sha": "e2c40f03019c1e52db80b89a3aebc0084cf1ede1", "filename": "src/librustc_error_codes/error_codes/E0308.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -12,8 +12,7 @@ let x: i32 = \"I am not a number!\";\n //    type `i32` assigned to variable `x`\n ```\n \n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can happen in several cases, the most common being a mismatch\n-between the type that the compiler inferred for a variable based on its\n-initializing expression, on the one hand, and the type the author explicitly\n-assigned to the variable, on the other hand.\n+This error occurs when the compiler is unable to infer the concrete type of a\n+variable. It can occur in several cases, the most common being a mismatch\n+between two types: the type the author explicitly assigned, and the type the\n+compiler inferred."}, {"sha": "05cf8fed031609a3d87ba37edf7cebf4ea893019", "filename": "src/librustc_error_codes/error_codes/E0567.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_error_codes%2Ferror_codes%2FE0567.md", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_error_codes%2Ferror_codes%2FE0567.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0567.md?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -6,8 +6,7 @@ Erroneous code example:\n #![feature(optin_builtin_traits)]\n \n auto trait Generic<T> {} // error!\n-\n-fn main() {}\n+# fn main() {}\n ```\n \n Since an auto trait is implemented on all existing types, the\n@@ -20,6 +19,5 @@ To fix this issue, just remove the generics:\n #![feature(optin_builtin_traits)]\n \n auto trait Generic {} // ok!\n-\n-fn main() {}\n+# fn main() {}\n ```"}, {"sha": "afc6a958296fc623eacdb612d57cf89f81cd22f9", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -13,8 +13,6 @@ use super::{\n     read_target_uint, write_target_uint, AllocId, InterpResult, Pointer, Scalar, ScalarMaybeUndef,\n };\n \n-// NOTE: When adding new fields, make sure to adjust the `Snapshot` impl in\n-// `src/librustc_mir/interpret/snapshot.rs`.\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n #[derive(HashStable)]\n pub struct Allocation<Tag = (), Extra = ()> {"}, {"sha": "2510dbcea0bdc1f40570f5221d1860d3d3e81073", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -361,8 +361,6 @@ pub enum UndefinedBehaviorInfo {\n     InvalidUndefBytes(Option<Pointer>),\n     /// Working with a local that is not currently live.\n     DeadLocal,\n-    /// Trying to read from the return place of a function.\n-    ReadFromReturnPlace,\n }\n \n impl fmt::Debug for UndefinedBehaviorInfo {\n@@ -424,7 +422,6 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n                 \"using uninitialized data, but this operation requires initialized memory\"\n             ),\n             DeadLocal => write!(f, \"accessing a dead local variable\"),\n-            ReadFromReturnPlace => write!(f, \"reading from return place\"),\n         }\n     }\n }"}, {"sha": "25fa3e5e8e0e350453ae068900801d3cab23047e", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -188,11 +188,6 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n-    #[inline]\n-    pub fn null_ptr(cx: &impl HasDataLayout) -> Self {\n-        Scalar::Raw { data: 0, size: cx.data_layout().pointer_size.bytes() as u8 }\n-    }\n-\n     #[inline]\n     pub fn zst() -> Self {\n         Scalar::Raw { data: 0, size: 0 }"}, {"sha": "179641ec7c03ad1b007ae9f571bf39b1b60e8b18", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -42,7 +42,10 @@ use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations}\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::dataflow::ResultsCursor;\n-use crate::transform::promote_consts::should_suggest_const_in_array_repeat_expressions_attribute;\n+use crate::transform::{\n+    check_consts::ConstCx,\n+    promote_consts::should_suggest_const_in_array_repeat_expressions_attribute,\n+};\n \n use crate::borrow_check::{\n     borrow_set::BorrowSet,\n@@ -1984,14 +1987,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let span = body.source_info(location).span;\n                         let ty = operand.ty(body, tcx);\n                         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n+                            let ccx = ConstCx::new_with_param_env(\n+                                tcx,\n+                                self.mir_def_id,\n+                                body,\n+                                self.param_env,\n+                            );\n                             // To determine if `const_in_array_repeat_expressions` feature gate should\n                             // be mentioned, need to check if the rvalue is promotable.\n                             let should_suggest =\n                                 should_suggest_const_in_array_repeat_expressions_attribute(\n-                                    tcx,\n-                                    self.mir_def_id,\n-                                    body,\n-                                    operand,\n+                                    &ccx, operand,\n                                 );\n                             debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n "}, {"sha": "0e06f5162f8cecbafab5f0b9ac8d2aa61eb085cd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 31, "deletions": 45, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -628,35 +628,30 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let frame = M::init_frame_extra(self, pre_frame)?;\n         self.stack_mut().push(frame);\n \n-        // don't allocate at all for trivial constants\n-        if body.local_decls.len() > 1 {\n-            // Locals are initially uninitialized.\n-            let dummy = LocalState { value: LocalValue::Uninitialized, layout: Cell::new(None) };\n-            let mut locals = IndexVec::from_elem(dummy, &body.local_decls);\n-            // Return place is handled specially by the `eval_place` functions, and the\n-            // entry in `locals` should never be used. Make it dead, to be sure.\n-            locals[mir::RETURN_PLACE].value = LocalValue::Dead;\n-            // Now mark those locals as dead that we do not want to initialize\n-            match self.tcx.def_kind(instance.def_id()) {\n-                // statics and constants don't have `Storage*` statements, no need to look for them\n-                //\n-                // FIXME: The above is likely untrue. See\n-                // <https://github.com/rust-lang/rust/pull/70004#issuecomment-602022110>. Is it\n-                // okay to ignore `StorageDead`/`StorageLive` annotations during CTFE?\n-                Some(DefKind::Static | DefKind::Const | DefKind::AssocConst) => {}\n-                _ => {\n-                    // Mark locals that use `Storage*` annotations as dead on function entry.\n-                    let always_live = AlwaysLiveLocals::new(self.body());\n-                    for local in locals.indices() {\n-                        if !always_live.contains(local) {\n-                            locals[local].value = LocalValue::Dead;\n-                        }\n+        // Locals are initially uninitialized.\n+        let dummy = LocalState { value: LocalValue::Uninitialized, layout: Cell::new(None) };\n+        let mut locals = IndexVec::from_elem(dummy, &body.local_decls);\n+\n+        // Now mark those locals as dead that we do not want to initialize\n+        match self.tcx.def_kind(instance.def_id()) {\n+            // statics and constants don't have `Storage*` statements, no need to look for them\n+            //\n+            // FIXME: The above is likely untrue. See\n+            // <https://github.com/rust-lang/rust/pull/70004#issuecomment-602022110>. Is it\n+            // okay to ignore `StorageDead`/`StorageLive` annotations during CTFE?\n+            Some(DefKind::Static | DefKind::Const | DefKind::AssocConst) => {}\n+            _ => {\n+                // Mark locals that use `Storage*` annotations as dead on function entry.\n+                let always_live = AlwaysLiveLocals::new(self.body());\n+                for local in locals.indices() {\n+                    if !always_live.contains(local) {\n+                        locals[local].value = LocalValue::Dead;\n                     }\n                 }\n             }\n-            // done\n-            self.frame_mut().locals = locals;\n         }\n+        // done\n+        self.frame_mut().locals = locals;\n \n         M::after_stack_push(self)?;\n         info!(\"ENTERING({}) {}\", self.frame_idx(), self.frame().instance);\n@@ -734,6 +729,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let frame =\n             self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n \n+        if !unwinding {\n+            // Copy the return value to the caller's stack frame.\n+            if let Some(return_place) = frame.return_place {\n+                let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n+                self.copy_op_transmute(op, return_place)?;\n+                self.dump_place(*return_place);\n+            } else {\n+                throw_ub!(Unreachable);\n+            }\n+        }\n+\n         // Now where do we jump next?\n \n         // Usually we want to clean up (deallocate locals), but in a few rare cases we don't.\n@@ -759,7 +765,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.deallocate_local(local.value)?;\n         }\n \n-        let return_place = frame.return_place;\n         if M::after_stack_pop(self, frame, unwinding)? == StackPopJump::NoJump {\n             // The hook already did everything.\n             // We want to skip the `info!` below, hence early return.\n@@ -772,25 +777,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.unwind_to_block(unwind);\n         } else {\n             // Follow the normal return edge.\n-            // Validate the return value. Do this after deallocating so that we catch dangling\n-            // references.\n-            if let Some(return_place) = return_place {\n-                if M::enforce_validity(self) {\n-                    // Data got changed, better make sure it matches the type!\n-                    // It is still possible that the return place held invalid data while\n-                    // the function is running, but that's okay because nobody could have\n-                    // accessed that same data from the \"outside\" to observe any broken\n-                    // invariant -- that is, unless a function somehow has a ptr to\n-                    // its return place... but the way MIR is currently generated, the\n-                    // return place is always a local and then this cannot happen.\n-                    self.validate_operand(self.place_to_op(return_place)?)?;\n-                }\n-            } else {\n-                // Uh, that shouldn't happen... the function did not intend to return\n-                throw_ub!(Unreachable);\n-            }\n-\n-            // Jump to new block -- *after* validation so that the spans make more sense.\n             if let Some(ret) = next_block {\n                 self.return_to_block(ret)?;\n             }"}, {"sha": "8188106b5f1876234e4d54dfabe42a290d00c9b0", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -419,7 +419,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         local: mir::Local,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        assert_ne!(local, mir::RETURN_PLACE);\n         let layout = self.layout_of_local(frame, local, layout)?;\n         let op = if layout.is_zst() {\n             // Do not read from ZST, they might not be initialized\n@@ -454,16 +453,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         place: mir::Place<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let base_op = match place.local {\n-            mir::RETURN_PLACE => throw_ub!(ReadFromReturnPlace),\n-            local => {\n-                // Do not use the layout passed in as argument if the base we are looking at\n-                // here is not the entire place.\n-                let layout = if place.projection.is_empty() { layout } else { None };\n-\n-                self.access_local(self.frame(), local, layout)?\n-            }\n-        };\n+        // Do not use the layout passed in as argument if the base we are looking at\n+        // here is not the entire place.\n+        let layout = if place.projection.is_empty() { layout } else { None };\n+\n+        let base_op = self.access_local(self.frame(), place.local, layout)?;\n \n         let op = place\n             .projection"}, {"sha": "ba17a0b482afc79e7c74179f817c0f22401fee8c", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -135,12 +135,6 @@ impl<Tag> MemPlace<Tag> {\n         MemPlace { ptr, align, meta: MemPlaceMeta::None }\n     }\n \n-    /// Produces a Place that will error if attempted to be read from or written to\n-    #[inline(always)]\n-    fn null(cx: &impl HasDataLayout) -> Self {\n-        Self::from_scalar_ptr(Scalar::null_ptr(cx), Align::from_bytes(1).unwrap())\n-    }\n-\n     #[inline(always)]\n     pub fn from_ptr(ptr: Pointer<Tag>, align: Align) -> Self {\n         Self::from_scalar_ptr(ptr.into(), align)\n@@ -260,12 +254,6 @@ impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n }\n \n impl<Tag: ::std::fmt::Debug> Place<Tag> {\n-    /// Produces a Place that will error if attempted to be read from or written to\n-    #[inline(always)]\n-    fn null(cx: &impl HasDataLayout) -> Self {\n-        Place::Ptr(MemPlace::null(cx))\n-    }\n-\n     #[inline]\n     pub fn assert_mem_place(self) -> MemPlace<Tag> {\n         match self {\n@@ -641,35 +629,10 @@ where\n         &mut self,\n         place: mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n-        let mut place_ty = match place.local {\n-            mir::RETURN_PLACE => {\n-                // `return_place` has the *caller* layout, but we want to use our\n-                // `layout to verify our assumption. The caller will validate\n-                // their layout on return.\n-                PlaceTy {\n-                    place: match self.frame().return_place {\n-                        Some(p) => *p,\n-                        // Even if we don't have a return place, we sometimes need to\n-                        // create this place, but any attempt to read from / write to it\n-                        // (even a ZST read/write) needs to error, so let us make this\n-                        // a NULL place.\n-                        //\n-                        // FIXME: Ideally we'd make sure that the place projections also\n-                        // bail out.\n-                        None => Place::null(&*self),\n-                    },\n-                    layout: self.layout_of(\n-                        self.subst_from_current_frame_and_normalize_erasing_regions(\n-                            self.frame().body.return_ty(),\n-                        ),\n-                    )?,\n-                }\n-            }\n-            local => PlaceTy {\n-                // This works even for dead/uninitialized locals; we check further when writing\n-                place: Place::Local { frame: self.frame_idx(), local },\n-                layout: self.layout_of_local(self.frame(), local, None)?,\n-            },\n+        let mut place_ty = PlaceTy {\n+            // This works even for dead/uninitialized locals; we check further when writing\n+            place: Place::Local { frame: self.frame_idx(), local: place.local },\n+            layout: self.layout_of_local(self.frame(), place.local, None)?,\n         };\n \n         for elem in place.projection.iter() {"}, {"sha": "777a4381cda720d125635af6f9137891cad8c6a2", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -19,7 +19,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::TerminatorKind::*;\n         match terminator.kind {\n             Return => {\n-                self.frame().return_place.map(|r| self.dump_place(*r));\n                 self.pop_stack_frame(/* unwinding */ false)?\n             }\n "}, {"sha": "a630c56ee977f773eadad2be2cc89aee40ee6596", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -20,20 +20,29 @@ pub mod validation;\n \n /// Information about the item currently being const-checked, as well as a reference to the global\n /// context.\n-pub struct Item<'mir, 'tcx> {\n+pub struct ConstCx<'mir, 'tcx> {\n     pub body: &'mir mir::Body<'tcx>,\n     pub tcx: TyCtxt<'tcx>,\n     pub def_id: DefId,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub const_kind: Option<ConstKind>,\n }\n \n-impl Item<'mir, 'tcx> {\n+impl ConstCx<'mir, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'mir mir::Body<'tcx>) -> Self {\n         let param_env = tcx.param_env(def_id);\n+        Self::new_with_param_env(tcx, def_id, body, param_env)\n+    }\n+\n+    pub fn new_with_param_env(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        body: &'mir mir::Body<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n         let const_kind = ConstKind::for_item(tcx, def_id);\n \n-        Item { body, tcx, def_id, param_env, const_kind }\n+        ConstCx { body, tcx, def_id, param_env, const_kind }\n     }\n \n     /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.)."}, {"sha": "60eb51f7ccabf03be4ef8261c14c11db87c92e5c", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -7,7 +7,7 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n \n-use super::{ConstKind, Item};\n+use super::{ConstCx, ConstKind};\n \n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n@@ -27,19 +27,19 @@ pub trait NonConstOp: std::fmt::Debug {\n     ///\n     /// By default, it returns `true` if and only if this operation has a corresponding feature\n     /// gate and that gate is enabled.\n-    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-        Self::feature_gate().map_or(false, |gate| item.tcx.features().enabled(gate))\n+    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n+        Self::feature_gate().map_or(false, |gate| ccx.tcx.features().enabled(gate))\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0019,\n             \"{} contains unimplemented expression type\",\n-            item.const_kind()\n+            ccx.const_kind()\n         );\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"A function call isn't allowed in the const's initialization expression \\\n                       because the expression's value must be known at compile-time.\",\n@@ -66,9 +66,9 @@ impl NonConstOp for Downcast {\n #[derive(Debug)]\n pub struct FnCallIndirect;\n impl NonConstOp for FnCallIndirect {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err =\n-            item.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\");\n+            ccx.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\");\n         err.emit();\n     }\n }\n@@ -77,14 +77,14 @@ impl NonConstOp for FnCallIndirect {\n #[derive(Debug)]\n pub struct FnCallNonConst(pub DefId);\n impl NonConstOp for FnCallNonConst {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0015,\n             \"calls in {}s are limited to constant functions, \\\n              tuple structs and tuple variants\",\n-            item.const_kind(),\n+            ccx.const_kind(),\n         );\n         err.emit();\n     }\n@@ -96,12 +96,12 @@ impl NonConstOp for FnCallNonConst {\n #[derive(Debug)]\n pub struct FnCallUnstable(pub DefId, pub Symbol);\n impl NonConstOp for FnCallUnstable {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let FnCallUnstable(def_id, feature) = *self;\n \n-        let mut err = item.tcx.sess.struct_span_err(\n+        let mut err = ccx.tcx.sess.struct_span_err(\n             span,\n-            &format!(\"`{}` is not yet stable as a const fn\", item.tcx.def_path_str(def_id)),\n+            &format!(\"`{}` is not yet stable as a const fn\", ccx.tcx.def_path_str(def_id)),\n         );\n         if nightly_options::is_nightly_build() {\n             err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feature));\n@@ -113,16 +113,16 @@ impl NonConstOp for FnCallUnstable {\n #[derive(Debug)]\n pub struct HeapAllocation;\n impl NonConstOp for HeapAllocation {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0010,\n             \"allocations are not allowed in {}s\",\n-            item.const_kind()\n+            ccx.const_kind()\n         );\n-        err.span_label(span, format!(\"allocation not allowed in {}s\", item.const_kind()));\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        err.span_label(span, format!(\"allocation not allowed in {}s\", ccx.const_kind()));\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"The value of statics and constants must be known at compile time, \\\n                  and they live for the entire lifetime of a program. Creating a boxed \\\n@@ -141,9 +141,9 @@ impl NonConstOp for IfOrMatch {\n         Some(sym::const_if_match)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         // This should be caught by the HIR const-checker.\n-        item.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n+        ccx.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n     }\n }\n \n@@ -154,14 +154,14 @@ impl NonConstOp for InlineAsm {}\n #[derive(Debug)]\n pub struct LiveDrop;\n impl NonConstOp for LiveDrop {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0493,\n             \"destructors cannot be evaluated at compile-time\"\n         )\n-        .span_label(span, format!(\"{}s cannot evaluate destructors\", item.const_kind()))\n+        .span_label(span, format!(\"{}s cannot evaluate destructors\", ccx.const_kind()))\n         .emit();\n     }\n }\n@@ -173,18 +173,18 @@ impl NonConstOp for Loop {\n         Some(sym::const_loop)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         // This should be caught by the HIR const-checker.\n-        item.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n+        ccx.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n     }\n }\n \n #[derive(Debug)]\n pub struct CellBorrow;\n impl NonConstOp for CellBorrow {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0492,\n             \"cannot borrow a constant which may contain \\\n@@ -201,19 +201,19 @@ impl NonConstOp for MutBorrow {\n         Some(sym::const_mut_refs)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n             span,\n             &format!(\n                 \"references in {}s may only refer \\\n                       to immutable values\",\n-                item.const_kind()\n+                ccx.const_kind()\n             ),\n         );\n-        err.span_label(span, format!(\"{}s require immutable values\", item.const_kind()));\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        err.span_label(span, format!(\"{}s require immutable values\", ccx.const_kind()));\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"References in statics and constants may only refer \\\n                       to immutable values.\\n\\n\\\n@@ -236,12 +236,12 @@ impl NonConstOp for MutAddressOf {\n         Some(sym::const_mut_refs)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n             span,\n-            &format!(\"`&raw mut` is not allowed in {}s\", item.const_kind()),\n+            &format!(\"`&raw mut` is not allowed in {}s\", ccx.const_kind()),\n         )\n         .emit();\n     }\n@@ -262,12 +262,12 @@ impl NonConstOp for Panic {\n         Some(sym::const_panic)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_panic,\n             span,\n-            &format!(\"panicking in {}s is unstable\", item.const_kind()),\n+            &format!(\"panicking in {}s is unstable\", ccx.const_kind()),\n         )\n         .emit();\n     }\n@@ -280,12 +280,12 @@ impl NonConstOp for RawPtrComparison {\n         Some(sym::const_compare_raw_pointers)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_compare_raw_pointers,\n             span,\n-            &format!(\"comparing raw pointers inside {}\", item.const_kind()),\n+            &format!(\"comparing raw pointers inside {}\", ccx.const_kind()),\n         )\n         .emit();\n     }\n@@ -298,12 +298,12 @@ impl NonConstOp for RawPtrDeref {\n         Some(sym::const_raw_ptr_deref)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_raw_ptr_deref,\n             span,\n-            &format!(\"dereferencing raw pointers in {}s is unstable\", item.const_kind(),),\n+            &format!(\"dereferencing raw pointers in {}s is unstable\", ccx.const_kind(),),\n         )\n         .emit();\n     }\n@@ -316,12 +316,12 @@ impl NonConstOp for RawPtrToIntCast {\n         Some(sym::const_raw_ptr_to_usize_cast)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_raw_ptr_to_usize_cast,\n             span,\n-            &format!(\"casting pointers to integers in {}s is unstable\", item.const_kind(),),\n+            &format!(\"casting pointers to integers in {}s is unstable\", ccx.const_kind(),),\n         )\n         .emit();\n     }\n@@ -331,22 +331,22 @@ impl NonConstOp for RawPtrToIntCast {\n #[derive(Debug)]\n pub struct StaticAccess;\n impl NonConstOp for StaticAccess {\n-    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-        item.const_kind().is_static()\n+    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n+        ccx.const_kind().is_static()\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0013,\n             \"{}s cannot refer to statics\",\n-            item.const_kind()\n+            ccx.const_kind()\n         );\n         err.help(\n             \"consider extracting the value of the `static` to a `const`, and referring to that\",\n         );\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"`static` and `const` variables can refer to other `const` variables. \\\n                     A `const` variable, however, cannot refer to a `static` variable.\",\n@@ -363,9 +363,9 @@ pub struct ThreadLocalAccess;\n impl NonConstOp for ThreadLocalAccess {\n     const IS_SUPPORTED_IN_MIRI: bool = false;\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0625,\n             \"thread-local statics cannot be \\\n@@ -378,19 +378,19 @@ impl NonConstOp for ThreadLocalAccess {\n #[derive(Debug)]\n pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n-    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n         // Union accesses are stable in all contexts except `const fn`.\n-        item.const_kind() != ConstKind::ConstFn\n-            || item.tcx.features().enabled(Self::feature_gate().unwrap())\n+        ccx.const_kind() != ConstKind::ConstFn\n+            || ccx.tcx.features().enabled(Self::feature_gate().unwrap())\n     }\n \n     fn feature_gate() -> Option<Symbol> {\n         Some(sym::const_fn_union)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_fn_union,\n             span,\n             \"unions in const fn are unstable\","}, {"sha": "f82f06599b74a0f0d5703d555f7592b4952a68b2", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{self, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n \n-use super::Item as ConstCx;\n+use super::ConstCx;\n \n pub fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> ConstQualifs {\n     ConstQualifs {"}, {"sha": "a81d7a23be2fb640c0a60a58396770aa81e437fb", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir::{self, BasicBlock, Local, Location};\n \n use std::marker::PhantomData;\n \n-use super::{qualifs, Item, Qualif};\n+use super::{qualifs, ConstCx, Qualif};\n use crate::dataflow;\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n@@ -18,7 +18,7 @@ use crate::dataflow;\n /// the `MaybeMutBorrowedLocals` dataflow pass to see if a `Local` may have become qualified via\n /// an indirect assignment or function call.\n struct TransferFunction<'a, 'mir, 'tcx, Q> {\n-    item: &'a Item<'mir, 'tcx>,\n+    ccx: &'a ConstCx<'mir, 'tcx>,\n     qualifs_per_local: &'a mut BitSet<Local>,\n \n     _qualif: PhantomData<Q>,\n@@ -28,16 +28,16 @@ impl<Q> TransferFunction<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n-    fn new(item: &'a Item<'mir, 'tcx>, qualifs_per_local: &'a mut BitSet<Local>) -> Self {\n-        TransferFunction { item, qualifs_per_local, _qualif: PhantomData }\n+    fn new(ccx: &'a ConstCx<'mir, 'tcx>, qualifs_per_local: &'a mut BitSet<Local>) -> Self {\n+        TransferFunction { ccx, qualifs_per_local, _qualif: PhantomData }\n     }\n \n     fn initialize_state(&mut self) {\n         self.qualifs_per_local.clear();\n \n-        for arg in self.item.body.args_iter() {\n-            let arg_ty = self.item.body.local_decls[arg].ty;\n-            if Q::in_any_value_of_ty(self.item, arg_ty) {\n+        for arg in self.ccx.body.args_iter() {\n+            let arg_ty = self.ccx.body.local_decls[arg].ty;\n+            if Q::in_any_value_of_ty(self.ccx, arg_ty) {\n                 self.qualifs_per_local.insert(arg);\n             }\n         }\n@@ -72,8 +72,8 @@ where\n     ) {\n         // We cannot reason about another function's internals, so use conservative type-based\n         // qualification for the result of a function call.\n-        let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n-        let qualif = Q::in_any_value_of_ty(self.item, return_ty);\n+        let return_ty = return_place.ty(self.ccx.body, self.ccx.tcx).ty;\n+        let qualif = Q::in_any_value_of_ty(self.ccx, return_ty);\n \n         if !return_place.is_indirect() {\n             self.assign_qualif_direct(&return_place, qualif);\n@@ -108,7 +108,7 @@ where\n         location: Location,\n     ) {\n         let qualif = qualifs::in_rvalue::<Q, _>(\n-            self.item,\n+            self.ccx,\n             &mut |l| self.qualifs_per_local.contains(l),\n             rvalue,\n         );\n@@ -127,7 +127,7 @@ where\n \n         if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n             let qualif = qualifs::in_operand::<Q, _>(\n-                self.item,\n+                self.ccx,\n                 &mut |l| self.qualifs_per_local.contains(l),\n                 value,\n             );\n@@ -145,23 +145,23 @@ where\n \n /// The dataflow analysis used to propagate qualifs on arbitrary CFGs.\n pub(super) struct FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q> {\n-    item: &'a Item<'mir, 'tcx>,\n+    ccx: &'a ConstCx<'mir, 'tcx>,\n     _qualif: PhantomData<Q>,\n }\n \n impl<'a, 'mir, 'tcx, Q> FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n-    pub(super) fn new(_: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n-        FlowSensitiveAnalysis { item, _qualif: PhantomData }\n+    pub(super) fn new(_: Q, ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n+        FlowSensitiveAnalysis { ccx, _qualif: PhantomData }\n     }\n \n     fn transfer_function(\n         &self,\n         state: &'a mut BitSet<Local>,\n     ) -> TransferFunction<'a, 'mir, 'tcx, Q> {\n-        TransferFunction::<Q>::new(self.item, state)\n+        TransferFunction::<Q>::new(self.ccx, state)\n     }\n }\n "}, {"sha": "45d8e1d08b7219ded92ce987a9d020c96c9ec65a", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -20,7 +20,7 @@ use std::ops::Deref;\n use super::ops::{self, NonConstOp};\n use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n-use super::{is_lang_panic_fn, ConstKind, Item, Qualif};\n+use super::{is_lang_panic_fn, ConstCx, ConstKind, Qualif};\n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::dataflow::MaybeMutBorrowedLocals;\n use crate::dataflow::{self, Analysis};\n@@ -37,15 +37,15 @@ struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n }\n \n impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n-    pub fn new(q: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n-        let cursor = FlowSensitiveAnalysis::new(q, item)\n-            .into_engine(item.tcx, item.body, item.def_id)\n+    pub fn new(q: Q, ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n+        let cursor = FlowSensitiveAnalysis::new(q, ccx)\n+            .into_engine(ccx.tcx, ccx.body, ccx.def_id)\n             .iterate_to_fixpoint()\n-            .into_results_cursor(item.body);\n+            .into_results_cursor(ccx.body);\n \n-        let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n-        for (local, decl) in item.body.local_decls.iter_enumerated() {\n-            if Q::in_any_value_of_ty(item, decl.ty) {\n+        let mut in_any_value_of_ty = BitSet::new_empty(ccx.body.local_decls.len());\n+        for (local, decl) in ccx.body.local_decls.iter_enumerated() {\n+            if Q::in_any_value_of_ty(ccx, decl.ty) {\n                 in_any_value_of_ty.insert(local);\n             }\n         }\n@@ -91,12 +91,12 @@ impl Qualifs<'a, 'mir, 'tcx> {\n             || self.indirectly_mutable(local, location)\n     }\n \n-    fn in_return_place(&mut self, item: &Item<'_, 'tcx>) -> ConstQualifs {\n+    fn in_return_place(&mut self, ccx: &ConstCx<'_, 'tcx>) -> ConstQualifs {\n         // Find the `Return` terminator if one exists.\n         //\n         // If no `Return` terminator exists, this MIR is divergent. Just return the conservative\n         // qualifs for the return type.\n-        let return_block = item\n+        let return_block = ccx\n             .body\n             .basic_blocks()\n             .iter_enumerated()\n@@ -107,11 +107,11 @@ impl Qualifs<'a, 'mir, 'tcx> {\n             .map(|(bb, _)| bb);\n \n         let return_block = match return_block {\n-            None => return qualifs::in_any_value_of_ty(item, item.body.return_ty()),\n+            None => return qualifs::in_any_value_of_ty(ccx, ccx.body.return_ty()),\n             Some(bb) => bb,\n         };\n \n-        let return_loc = item.body.terminator_loc(return_block);\n+        let return_loc = ccx.body.terminator_loc(return_block);\n \n         ConstQualifs {\n             needs_drop: self.needs_drop(RETURN_PLACE, return_loc),\n@@ -121,27 +121,27 @@ impl Qualifs<'a, 'mir, 'tcx> {\n }\n \n pub struct Validator<'a, 'mir, 'tcx> {\n-    item: &'a Item<'mir, 'tcx>,\n+    ccx: &'a ConstCx<'mir, 'tcx>,\n     qualifs: Qualifs<'a, 'mir, 'tcx>,\n \n     /// The span of the current statement.\n     span: Span,\n }\n \n impl Deref for Validator<'_, 'mir, 'tcx> {\n-    type Target = Item<'mir, 'tcx>;\n+    type Target = ConstCx<'mir, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        &self.item\n+        &self.ccx\n     }\n }\n \n impl Validator<'a, 'mir, 'tcx> {\n-    pub fn new(item: &'a Item<'mir, 'tcx>) -> Self {\n-        let Item { tcx, body, def_id, param_env, .. } = *item;\n+    pub fn new(ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n+        let ConstCx { tcx, body, def_id, param_env, .. } = *ccx;\n \n-        let needs_drop = QualifCursor::new(NeedsDrop, item);\n-        let has_mut_interior = QualifCursor::new(HasMutInterior, item);\n+        let needs_drop = QualifCursor::new(NeedsDrop, ccx);\n+        let has_mut_interior = QualifCursor::new(HasMutInterior, ccx);\n \n         // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n         // allowed in a const.\n@@ -156,11 +156,11 @@ impl Validator<'a, 'mir, 'tcx> {\n \n         let qualifs = Qualifs { needs_drop, has_mut_interior, indirectly_mutable };\n \n-        Validator { span: item.body.span, item, qualifs }\n+        Validator { span: ccx.body.span, ccx, qualifs }\n     }\n \n     pub fn check_body(&mut self) {\n-        let Item { tcx, body, def_id, const_kind, .. } = *self.item;\n+        let ConstCx { tcx, body, def_id, const_kind, .. } = *self.ccx;\n \n         let use_min_const_fn_checks = (const_kind == Some(ConstKind::ConstFn)\n             && crate::const_eval::is_min_const_fn(tcx, def_id))\n@@ -175,7 +175,7 @@ impl Validator<'a, 'mir, 'tcx> {\n             }\n         }\n \n-        check_short_circuiting_in_const_local(self.item);\n+        check_short_circuiting_in_const_local(self.ccx);\n \n         if body.is_cfg_cyclic() {\n             // We can't provide a good span for the error here, but this should be caught by the\n@@ -196,7 +196,7 @@ impl Validator<'a, 'mir, 'tcx> {\n     }\n \n     pub fn qualifs_in_return_place(&mut self) -> ConstQualifs {\n-        self.qualifs.in_return_place(self.item)\n+        self.qualifs.in_return_place(self.ccx)\n     }\n \n     /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n@@ -344,7 +344,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, ref place)\n             | Rvalue::AddressOf(Mutability::Not, ref place) => {\n                 let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n-                    &self.item,\n+                    &self.ccx,\n                     &mut |local| self.qualifs.has_mut_interior(local, location),\n                     place.as_ref(),\n                 );\n@@ -608,8 +608,8 @@ fn error_min_const_fn_violation(tcx: TyCtxt<'_>, span: Span, msg: Cow<'_, str>)\n         .emit();\n }\n \n-fn check_short_circuiting_in_const_local(item: &Item<'_, 'tcx>) {\n-    let body = item.body;\n+fn check_short_circuiting_in_const_local(ccx: &ConstCx<'_, 'tcx>) {\n+    let body = ccx.body;\n \n     if body.control_flow_destroyed.is_empty() {\n         return;\n@@ -618,12 +618,12 @@ fn check_short_circuiting_in_const_local(item: &Item<'_, 'tcx>) {\n     let mut locals = body.vars_iter();\n     if let Some(local) = locals.next() {\n         let span = body.local_decls[local].source_info.span;\n-        let mut error = item.tcx.sess.struct_span_err(\n+        let mut error = ccx.tcx.sess.struct_span_err(\n             span,\n             &format!(\n                 \"new features like let bindings are not permitted in {}s \\\n                 which also use short circuiting operators\",\n-                item.const_kind(),\n+                ccx.const_kind(),\n             ),\n         );\n         for (span, kind) in body.control_flow_destroyed.iter() {"}, {"sha": "beabdf7f784f8d086544fb79046210066f23998a", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -330,7 +330,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     // by accessing them through `ecx` instead.\n     source_scopes: IndexVec<SourceScope, SourceScopeData>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n-    ret: Option<OpTy<'tcx, ()>>,\n     // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n     // the last known `SourceInfo` here and just keep revisiting it.\n     source_info: Option<SourceInfo>,\n@@ -402,22 +401,19 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             source_scopes: body.source_scopes.clone(),\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n-            ret: ret.map(Into::into),\n             source_info: None,\n         }\n     }\n \n     fn get_const(&self, local: Local) -> Option<OpTy<'tcx>> {\n-        if local == RETURN_PLACE {\n-            // Try to read the return place as an immediate so that if it is representable as a\n-            // scalar, we can handle it as such, but otherwise, just return the value as is.\n-            return match self.ret.map(|ret| self.ecx.try_read_immediate(ret)) {\n-                Some(Ok(Ok(imm))) => Some(imm.into()),\n-                _ => self.ret,\n-            };\n-        }\n+        let op = self.ecx.access_local(self.ecx.frame(), local, None).ok();\n \n-        self.ecx.access_local(self.ecx.frame(), local, None).ok()\n+        // Try to read the local as an immediate so that if it is representable as a scalar, we can\n+        // handle it as such, but otherwise, just return the value as is.\n+        match op.map(|ret| self.ecx.try_read_immediate(ret)) {\n+            Some(Ok(Ok(imm))) => Some(imm.into()),\n+            _ => op,\n+        }\n     }\n \n     fn remove_const(&mut self, local: Local) {"}, {"sha": "a87955274a779c790fad76c083ff0dfcc0aaf49d", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -194,10 +194,10 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n         return Default::default();\n     }\n \n-    let item =\n-        check_consts::Item { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n+    let ccx =\n+        check_consts::ConstCx { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n \n-    let mut validator = check_consts::validation::Validator::new(&item);\n+    let mut validator = check_consts::validation::Validator::new(&ccx);\n     validator.check_body();\n \n     // We return the qualifs in the return place for every MIR body, even though it is only used"}, {"sha": "998af4ba39006d6f356cd02110be6505922d1498", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -30,7 +30,7 @@ use std::cell::Cell;\n use std::{cmp, iter, mem};\n \n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n-use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstKind, Item};\n+use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstCx, ConstKind};\n use crate::transform::{MirPass, MirSource};\n \n /// A `MirPass` for promotion.\n@@ -62,9 +62,10 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n         let def_id = src.def_id();\n \n         let mut rpo = traversal::reverse_postorder(body);\n-        let (temps, all_candidates) = collect_temps_and_candidates(tcx, body, &mut rpo);\n+        let ccx = ConstCx::new(tcx, def_id, body);\n+        let (temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n \n-        let promotable_candidates = validate_candidates(tcx, body, def_id, &temps, &all_candidates);\n+        let promotable_candidates = validate_candidates(&ccx, &temps, &all_candidates);\n \n         let promoted = promote_candidates(def_id, body, tcx, temps, promotable_candidates);\n         self.promoted_fragments.set(promoted);\n@@ -139,8 +140,7 @@ fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<usize>> {\n }\n \n struct Collector<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a Body<'tcx>,\n+    ccx: &'a ConstCx<'a, 'tcx>,\n     temps: IndexVec<Local, TempState>,\n     candidates: Vec<Candidate>,\n     span: Span,\n@@ -150,7 +150,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n     fn visit_local(&mut self, &index: &Local, context: PlaceContext, location: Location) {\n         debug!(\"visit_local: index={:?} context={:?} location={:?}\", index, context, location);\n         // We're only interested in temporaries and the return place\n-        match self.body.local_kind(index) {\n+        match self.ccx.body.local_kind(index) {\n             LocalKind::Temp | LocalKind::ReturnPointer => {}\n             LocalKind::Arg | LocalKind::Var => return,\n         }\n@@ -203,7 +203,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n             Rvalue::Ref(..) => {\n                 self.candidates.push(Candidate::Ref(location));\n             }\n-            Rvalue::Repeat(..) if self.tcx.features().const_in_array_repeat_expressions => {\n+            Rvalue::Repeat(..) if self.ccx.tcx.features().const_in_array_repeat_expressions => {\n                 // FIXME(#49147) only promote the element when it isn't `Copy`\n                 // (so that code that can copy it at runtime is unaffected).\n                 self.candidates.push(Candidate::Repeat(location));\n@@ -216,10 +216,10 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n         self.super_terminator_kind(kind, location);\n \n         if let TerminatorKind::Call { ref func, .. } = *kind {\n-            if let ty::FnDef(def_id, _) = func.ty(self.body, self.tcx).kind {\n-                let fn_sig = self.tcx.fn_sig(def_id);\n+            if let ty::FnDef(def_id, _) = func.ty(self.ccx.body, self.ccx.tcx).kind {\n+                let fn_sig = self.ccx.tcx.fn_sig(def_id);\n                 if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = fn_sig.abi() {\n-                    let name = self.tcx.item_name(def_id);\n+                    let name = self.ccx.tcx.item_name(def_id);\n                     // FIXME(eddyb) use `#[rustc_args_required_const(2)]` for shuffles.\n                     if name.as_str().starts_with(\"simd_shuffle\") {\n                         self.candidates.push(Candidate::Argument { bb: location.block, index: 2 });\n@@ -228,7 +228,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n                     }\n                 }\n \n-                if let Some(constant_args) = args_required_const(self.tcx, def_id) {\n+                if let Some(constant_args) = args_required_const(self.ccx.tcx, def_id) {\n                     for index in constant_args {\n                         self.candidates.push(Candidate::Argument { bb: location.block, index });\n                     }\n@@ -243,16 +243,14 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n }\n \n pub fn collect_temps_and_candidates(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n+    ccx: &ConstCx<'mir, 'tcx>,\n     rpo: &mut ReversePostorder<'_, 'tcx>,\n ) -> (IndexVec<Local, TempState>, Vec<Candidate>) {\n     let mut collector = Collector {\n-        tcx,\n-        body,\n-        temps: IndexVec::from_elem(TempState::Undefined, &body.local_decls),\n+        temps: IndexVec::from_elem(TempState::Undefined, &ccx.body.local_decls),\n         candidates: vec![],\n-        span: body.span,\n+        span: ccx.body.span,\n+        ccx,\n     };\n     for (bb, data) in rpo {\n         collector.visit_basic_block_data(bb, data);\n@@ -264,7 +262,7 @@ pub fn collect_temps_and_candidates(\n ///\n /// This wraps an `Item`, and has access to all fields of that `Item` via `Deref` coercion.\n struct Validator<'a, 'tcx> {\n-    item: Item<'a, 'tcx>,\n+    ccx: &'a ConstCx<'a, 'tcx>,\n     temps: &'a IndexVec<Local, TempState>,\n \n     /// Explicit promotion happens e.g. for constant arguments declared via\n@@ -277,10 +275,10 @@ struct Validator<'a, 'tcx> {\n }\n \n impl std::ops::Deref for Validator<'a, 'tcx> {\n-    type Target = Item<'a, 'tcx>;\n+    type Target = ConstCx<'a, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        &self.item\n+        &self.ccx\n     }\n }\n \n@@ -413,7 +411,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box (_, rhs)) => qualifs::in_rvalue::<Q, _>(\n-                        &self.item,\n+                        &self.ccx,\n                         &mut |l| self.qualif_local::<Q>(l),\n                         rhs,\n                     ),\n@@ -430,7 +428,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 match &terminator.kind {\n                     TerminatorKind::Call { .. } => {\n                         let return_ty = self.body.local_decls[local].ty;\n-                        Q::in_any_value_of_ty(&self.item, return_ty)\n+                        Q::in_any_value_of_ty(&self.ccx, return_ty)\n                     }\n                     kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n@@ -717,13 +715,11 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n // FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    def_id: DefId,\n+    ccx: &ConstCx<'_, '_>,\n     temps: &IndexVec<Local, TempState>,\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n-    let mut validator = Validator { item: Item::new(tcx, def_id, body), temps, explicit: false };\n+    let mut validator = Validator { ccx, temps, explicit: false };\n \n     candidates\n         .iter()\n@@ -735,11 +731,23 @@ pub fn validate_candidates(\n             // and `#[rustc_args_required_const]` arguments here.\n \n             let is_promotable = validator.validate_candidate(candidate).is_ok();\n+\n+            // If we use explicit validation, we carry the risk of turning a legitimate run-time\n+            // operation into a failing compile-time operation. Make sure that does not happen\n+            // by asserting that there is no possible run-time behavior here in case promotion\n+            // fails.\n+            if validator.explicit && !is_promotable {\n+                ccx.tcx.sess.delay_span_bug(\n+                    ccx.body.span,\n+                    \"Explicit promotion requested, but failed to promote\",\n+                );\n+            }\n+\n             match candidate {\n                 Candidate::Argument { bb, index } if !is_promotable => {\n-                    let span = body[bb].terminator().source_info.span;\n+                    let span = ccx.body[bb].terminator().source_info.span;\n                     let msg = format!(\"argument {} is required to be a constant\", index + 1);\n-                    tcx.sess.span_err(span, &msg);\n+                    ccx.tcx.sess.span_err(span, &msg);\n                 }\n                 _ => (),\n             }\n@@ -1147,22 +1155,19 @@ pub fn promote_candidates<'tcx>(\n /// Feature attribute should be suggested if `operand` can be promoted and the feature is not\n /// enabled.\n crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mir_def_id: DefId,\n-    body: &Body<'tcx>,\n+    ccx: &ConstCx<'_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> bool {\n-    let mut rpo = traversal::reverse_postorder(&body);\n-    let (temps, _) = collect_temps_and_candidates(tcx, &body, &mut rpo);\n-    let validator =\n-        Validator { item: Item::new(tcx, mir_def_id, body), temps: &temps, explicit: false };\n+    let mut rpo = traversal::reverse_postorder(&ccx.body);\n+    let (temps, _) = collect_temps_and_candidates(&ccx, &mut rpo);\n+    let validator = Validator { ccx, temps: &temps, explicit: false };\n \n     let should_promote = validator.validate_operand(operand).is_ok();\n-    let feature_flag = tcx.features().const_in_array_repeat_expressions;\n+    let feature_flag = validator.ccx.tcx.features().const_in_array_repeat_expressions;\n     debug!(\n-        \"should_suggest_const_in_array_repeat_expressions_flag: mir_def_id={:?} \\\n+        \"should_suggest_const_in_array_repeat_expressions_flag: def_id={:?} \\\n             should_promote={:?} feature_flag={:?}\",\n-        mir_def_id, should_promote, feature_flag\n+        validator.ccx.def_id, should_promote, feature_flag\n     );\n     should_promote && !feature_flag\n }"}, {"sha": "ed93af2f993d3bc7bee7b7dae1ca99b363671a5a", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -10,11 +10,11 @@\n // CHECK: @STATIC = {{.*}}, align 4\n \n // This checks the constants from inline_enum_const\n-// CHECK: @alloc5 = {{.*}}, align 2\n+// CHECK: @alloc7 = {{.*}}, align 2\n \n // This checks the constants from {low,high}_align_const, they share the same\n // constant, but the alignment differs, so the higher one should be used\n-// CHECK: [[LOW_HIGH:@[0-9]+]] = {{.*}} getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* @alloc15, i32 0, i32 0, i32 0), {{.*}}\n+// CHECK: [[LOW_HIGH:@[0-9]+]] = {{.*}} getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* @alloc19, i32 0, i32 0, i32 0), {{.*}}\n \n #[derive(Copy, Clone)]\n // repr(i16) is required for the {low,high}_align_const test"}, {"sha": "2c07cbcb2054b711f55bd91f8e0f7c337aa0183f", "filename": "src/test/incremental/hashes/enum_constructors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -274,29 +274,29 @@ pub enum Clike2 {\n // Change constructor path (C-like) --------------------------------------\n #[cfg(cfail1)]\n pub fn change_constructor_path_c_like() {\n-    let _ = Clike::B;\n+    let _x = Clike::B;\n }\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,mir_built,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_c_like() {\n-    let _ = Clike2::B;\n+    let _x = Clike2::B;\n }\n \n \n \n // Change constructor variant (C-like) --------------------------------------\n #[cfg(cfail1)]\n pub fn change_constructor_variant_c_like() {\n-    let _ = Clike::A;\n+    let _x = Clike::A;\n }\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_variant_c_like() {\n-    let _ = Clike::C;\n+    let _x = Clike::C;\n }\n \n "}, {"sha": "efd14ea140fe8e85ae48fbe61d44e0ed9fe5026f", "filename": "src/test/mir-opt/const_allocation2/32bit/rustc.main.ConstProp.after.mir", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F32bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F32bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F32bit%2Frustc.main.ConstProp.after.mir?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -30,41 +30,41 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 8, align: 4) {\n-    \u257ealloc24+0\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257ealloc25+0\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc24 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257ealloc9+0\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257ealloc14+0\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257ealloc22+0\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+alloc25 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257ealloc10+0\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257ealloc15+0\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257ealloc23+0\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n-alloc9 (size: 0, align: 4) {}\n+alloc10 (size: 0, align: 4) {}\n \n-alloc14 (size: 8, align: 4) {\n-    \u257ealloc12+0\u257c \u257ealloc13+0\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc15 (size: 8, align: 4) {\n+    \u257ealloc13+0\u257c \u257ealloc14+0\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc12 (size: 1, align: 1) {\n+alloc13 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc13 (size: 1, align: 1) {\n+alloc14 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc22 (size: 12, align: 4) {\n-    \u257ealloc18+3\u257c \u257ealloc19+0\u257c \u257ealloc21+2\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc23 (size: 12, align: 4) {\n+    \u257ealloc19+3\u257c \u257ealloc20+0\u257c \u257ealloc22+2\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc18 (size: 4, align: 1) {\n+alloc19 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc19 (size: 1, align: 1) {\n+alloc20 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc21 (size: 4, align: 1) {\n+alloc22 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "3b649ee7a24bd90dbedd40621248584057849a4e", "filename": "src/test/mir-opt/const_allocation2/64bit/rustc.main.ConstProp.after.mir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F64bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F64bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F64bit%2Frustc.main.ConstProp.after.mir?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -30,44 +30,44 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc24+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc25+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc24 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc9+0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc25 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc10+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc14+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc22+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc15+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc23+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc9 (size: 0, align: 8) {}\n+alloc10 (size: 0, align: 8) {}\n \n-alloc14 (size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc12+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc13+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc15 (size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc13+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc14+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc12 (size: 1, align: 1) {\n+alloc13 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc13 (size: 1, align: 1) {\n+alloc14 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc22 (size: 24, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc18+3\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc19+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc21+2\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc23 (size: 24, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc19+3\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc20+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc22+2\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc18 (size: 4, align: 1) {\n+alloc19 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc19 (size: 1, align: 1) {\n+alloc20 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc21 (size: 4, align: 1) {\n+alloc22 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "b6c2572cb8dc3108db1c08e629b94f72802870ac", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -13,7 +13,7 @@ LL | / const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n LL | |     let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n LL | |     // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n LL | |     let out_of_bounds_ptr = &ptr[255];\n-   | |                             ^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of alloc8 which has size 1\n+   | |                             ^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of alloc11 which has size 1\n LL | |     mem::transmute(out_of_bounds_ptr)\n LL | | } };\n    | |____-"}, {"sha": "54a9eda21466088c75433b179020984d54f9955e", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -11,7 +11,7 @@ LL | / const MUTATING_BEHIND_RAW: () = {\n LL | |     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n LL | |     unsafe {\n LL | |         *MUTABLE_BEHIND_RAW = 99\n-   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ writing to alloc1 which is read-only\n+   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ writing to alloc2 which is read-only\n LL | |     }\n LL | | };\n    | |__-"}, {"sha": "8d3c316e467bddd5183f18057086c890878ce470", "filename": "src/test/ui/json-bom-plus-crlf-multifile.stderr", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -12,11 +12,10 @@ let x: i32 = \\\"I am not a number!\\\";\n //    type `i32` assigned to variable `x`\n ```\n \n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can happen in several cases, the most common being a mismatch\n-between the type that the compiler inferred for a variable based on its\n-initializing expression, on the one hand, and the type the author explicitly\n-assigned to the variable, on the other hand.\n+This error occurs when the compiler is unable to infer the concrete type of a\n+variable. It can occur in several cases, the most common being a mismatch\n+between two types: the type the author explicitly assigned, and the type the\n+compiler inferred.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":612,\"byte_end\":618,\"line_start\":17,\"line_end\":17,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:17:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -33,11 +32,10 @@ let x: i32 = \\\"I am not a number!\\\";\n //    type `i32` assigned to variable `x`\n ```\n \n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can happen in several cases, the most common being a mismatch\n-between the type that the compiler inferred for a variable based on its\n-initializing expression, on the one hand, and the type the author explicitly\n-assigned to the variable, on the other hand.\n+This error occurs when the compiler is unable to infer the concrete type of a\n+variable. It can occur in several cases, the most common being a mismatch\n+between two types: the type the author explicitly assigned, and the type the\n+compiler inferred.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":672,\"byte_end\":678,\"line_start\":19,\"line_end\":19,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:19:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -54,11 +52,10 @@ let x: i32 = \\\"I am not a number!\\\";\n //    type `i32` assigned to variable `x`\n ```\n \n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can happen in several cases, the most common being a mismatch\n-between the type that the compiler inferred for a variable based on its\n-initializing expression, on the one hand, and the type the author explicitly\n-assigned to the variable, on the other hand.\n+This error occurs when the compiler is unable to infer the concrete type of a\n+variable. It can occur in several cases, the most common being a mismatch\n+between two types: the type the author explicitly assigned, and the type the\n+compiler inferred.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":735,\"byte_end\":741,\"line_start\":22,\"line_end\":22,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String =\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:23:1: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -75,11 +72,10 @@ let x: i32 = \\\"I am not a number!\\\";\n //    type `i32` assigned to variable `x`\n ```\n \n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can happen in several cases, the most common being a mismatch\n-between the type that the compiler inferred for a variable based on its\n-initializing expression, on the one hand, and the type the author explicitly\n-assigned to the variable, on the other hand.\n+This error occurs when the compiler is unable to infer the concrete type of a\n+variable. It can occur in several cases, the most common being a mismatch\n+between two types: the type the author explicitly assigned, and the type the\n+compiler inferred.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":801,\"byte_end\":809,\"line_start\":25,\"line_end\":26,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found `()`\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":792,\"byte_end\":798,\"line_start\":25,\"line_end\":25,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:25:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors"}, {"sha": "ed6b583f329d6bef89040819e2ba7af48eb11d22", "filename": "src/test/ui/json-bom-plus-crlf.stderr", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -12,11 +12,10 @@ let x: i32 = \\\"I am not a number!\\\";\n //    type `i32` assigned to variable `x`\n ```\n \n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can happen in several cases, the most common being a mismatch\n-between the type that the compiler inferred for a variable based on its\n-initializing expression, on the one hand, and the type the author explicitly\n-assigned to the variable, on the other hand.\n+This error occurs when the compiler is unable to infer the concrete type of a\n+variable. It can occur in several cases, the most common being a mismatch\n+between two types: the type the author explicitly assigned, and the type the\n+compiler inferred.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":606,\"byte_end\":607,\"line_start\":16,\"line_end\":16,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":597,\"byte_end\":603,\"line_start\":16,\"line_end\":16,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":606,\"byte_end\":607,\"line_start\":16,\"line_end\":16,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:16:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -33,11 +32,10 @@ let x: i32 = \\\"I am not a number!\\\";\n //    type `i32` assigned to variable `x`\n ```\n \n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can happen in several cases, the most common being a mismatch\n-between the type that the compiler inferred for a variable based on its\n-initializing expression, on the one hand, and the type the author explicitly\n-assigned to the variable, on the other hand.\n+This error occurs when the compiler is unable to infer the concrete type of a\n+variable. It can occur in several cases, the most common being a mismatch\n+between two types: the type the author explicitly assigned, and the type the\n+compiler inferred.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":666,\"byte_end\":667,\"line_start\":18,\"line_end\":18,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":657,\"byte_end\":663,\"line_start\":18,\"line_end\":18,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":666,\"byte_end\":667,\"line_start\":18,\"line_end\":18,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:18:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -54,11 +52,10 @@ let x: i32 = \\\"I am not a number!\\\";\n //    type `i32` assigned to variable `x`\n ```\n \n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can happen in several cases, the most common being a mismatch\n-between the type that the compiler inferred for a variable based on its\n-initializing expression, on the one hand, and the type the author explicitly\n-assigned to the variable, on the other hand.\n+This error occurs when the compiler is unable to infer the concrete type of a\n+variable. It can occur in several cases, the most common being a mismatch\n+between two types: the type the author explicitly assigned, and the type the\n+compiler inferred.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":730,\"byte_end\":731,\"line_start\":22,\"line_end\":22,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":720,\"byte_end\":726,\"line_start\":21,\"line_end\":21,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String =\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":730,\"byte_end\":731,\"line_start\":22,\"line_end\":22,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:22:1: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -75,11 +72,10 @@ let x: i32 = \\\"I am not a number!\\\";\n //    type `i32` assigned to variable `x`\n ```\n \n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can happen in several cases, the most common being a mismatch\n-between the type that the compiler inferred for a variable based on its\n-initializing expression, on the one hand, and the type the author explicitly\n-assigned to the variable, on the other hand.\n+This error occurs when the compiler is unable to infer the concrete type of a\n+variable. It can occur in several cases, the most common being a mismatch\n+between two types: the type the author explicitly assigned, and the type the\n+compiler inferred.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":786,\"byte_end\":794,\"line_start\":24,\"line_end\":25,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found `()`\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":777,\"byte_end\":783,\"line_start\":24,\"line_end\":24,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:24:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors"}, {"sha": "1dd5adb2209ef43b9f700117587fe3fe29632f15", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413a12909f3b149af17d75268ed4a136afb82c36/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=413a12909f3b149af17d75268ed4a136afb82c36", "patch": "@@ -3338,6 +3338,10 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn delete_file(&self, file: &PathBuf) {\n+        if !file.exists() {\n+            // Deleting a nonexistant file would error.\n+            return;\n+        }\n         if let Err(e) = fs::remove_file(file) {\n             self.fatal(&format!(\"failed to delete `{}`: {}\", file.display(), e,));\n         }\n@@ -3400,7 +3404,7 @@ impl<'test> TestCx<'test> {\n         let examined_content =\n             self.load_expected_output_from_path(&examined_path).unwrap_or_else(|_| String::new());\n \n-        if examined_path.exists() && canon_content == &examined_content {\n+        if canon_content == &examined_content {\n             self.delete_file(&examined_path);\n         }\n     }"}]}