{"sha": "028159ead403c09efcaa2b0bb0738d33209c3950", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyODE1OWVhZDQwM2MwOWVmY2FhMmIwYmIwNzM4ZDMzMjA5YzM5NTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-04T21:21:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-04T21:21:52Z"}, "message": "auto merge of #13676 : mdinger/rust/tutorial_doc, r=pnkfelix\n\nImprove tutorial discussion of closures, e.g. with respect to type inference and variable capture.\r\n\r\nFix #13621 \r\n\r\n---- original description follows\r\n\r\nI'd like this pulled to master if possible but if not I'd appreciate comments on what I need to change.  I found the closures difficult to understand as they were so I tried to explain it so I would've had an easier time understanding it.  I think it's better at least, somewhat.\r\n\r\nI don't know that everyone liked the `-> ()` I included but I thought explicit is best to aid understanding.  I thought it was much harder to understand than it should have been.\r\n\r\n[EDIT] - Clicked too early.\r\nThis doesn't `make check` without errors on my Xubuntu on Virtualbox machine.  Not sure why.  I don't think I changed anything problematic.  I'll try `make check` on master tomorrow.\r\n\r\nOpened https://github.com/mozilla/rust/issues/13621 regarding this.", "tree": {"sha": "68e88ef840173435a8b532e936ff8288ce8935b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68e88ef840173435a8b532e936ff8288ce8935b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/028159ead403c09efcaa2b0bb0738d33209c3950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/028159ead403c09efcaa2b0bb0738d33209c3950", "html_url": "https://github.com/rust-lang/rust/commit/028159ead403c09efcaa2b0bb0738d33209c3950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/028159ead403c09efcaa2b0bb0738d33209c3950/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59569397fbcd0a9b7b3649cd9957cace2d6889d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/59569397fbcd0a9b7b3649cd9957cace2d6889d8", "html_url": "https://github.com/rust-lang/rust/commit/59569397fbcd0a9b7b3649cd9957cace2d6889d8"}, {"sha": "b3d7aa39240f17ca8b496b31908da4c08a639555", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d7aa39240f17ca8b496b31908da4c08a639555", "html_url": "https://github.com/rust-lang/rust/commit/b3d7aa39240f17ca8b496b31908da4c08a639555"}], "stats": {"total": 101, "additions": 84, "deletions": 17}, "files": [{"sha": "1ce2cd39fd6a0e06c947b213d8b8f41c248cdf25", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028159ead403c09efcaa2b0bb0738d33209c3950/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/028159ead403c09efcaa2b0bb0738d33209c3950/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=028159ead403c09efcaa2b0bb0738d33209c3950", "patch": "@@ -101,6 +101,8 @@ fn print_message() { println!(\"I am running in a different task!\"); }\n spawn(print_message);\n \n // Print something more profound in a different task using a lambda expression\n+// This uses the proc() keyword to assign to spawn a function with no name\n+// That function will call println!(...) as requested\n spawn(proc() println!(\"I am also running in a different task!\") );\n ~~~~\n "}, {"sha": "6abfa21962fac1035d5638f13819bfdb493b27a7", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 82, "deletions": 17, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/028159ead403c09efcaa2b0bb0738d33209c3950/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/028159ead403c09efcaa2b0bb0738d33209c3950/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=028159ead403c09efcaa2b0bb0738d33209c3950", "patch": "@@ -1720,38 +1720,103 @@ environment (sometimes referred to as \"capturing\" variables in their\n environment). For example, you couldn't write the following:\n \n ~~~~ {.ignore}\n-let foo = 10;\n+let x = 3;\n \n-fn bar() -> int {\n-   return foo; // `bar` cannot refer to `foo`\n-}\n+// `fun` cannot refer to `x`\n+fn fun() -> () { println!(\"{}\", x); }\n ~~~~\n \n-Rust also supports _closures_, functions that can access variables in\n-the enclosing scope.\n+A _closure_ does support accessing the enclosing scope; below we will create\n+2 _closures_ (nameless functions). Compare how `||` replaces `()` and how\n+they try to access `x`:\n \n-~~~~\n-fn call_closure_with_ten(b: |int|) { b(10); }\n+~~~~ {.ignore}\n+let x = 3;\n \n-let captured_var = 20;\n-let closure = |arg| println!(\"captured_var={}, arg={}\", captured_var, arg);\n+// `fun` is an invalid definition\n+fn  fun       () -> () { println!(\"{}\", x) }  // cannot capture from enclosing scope\n+let closure = || -> () { println!(\"{}\", x) }; // can capture from enclosing scope\n \n-call_closure_with_ten(closure);\n+// `fun_arg` is an invalid definition\n+fn  fun_arg       (arg: int) -> () { println!(\"{}\", arg + x) }  // cannot capture\n+let closure_arg = |arg: int| -> () { println!(\"{}\", arg + x) }; // can capture\n+//                      ^\n+// Requires a type because the implementation needs to know which `+` to use.\n+// In the future, the implementation may not need the help.\n+\n+fun();          // Still won't work\n+closure();      // Prints: 3\n+\n+fun_arg(7);     // Still won't work\n+closure_arg(7); // Prints: 10\n ~~~~\n \n Closures begin with the argument list between vertical bars and are followed by\n a single expression. Remember that a block, `{ <expr1>; <expr2>; ... }`, is\n considered a single expression: it evaluates to the result of the last\n expression it contains if that expression is not followed by a semicolon,\n-otherwise the block evaluates to `()`.\n+otherwise the block evaluates to `()`, the unit value.\n+\n+In general, return types and all argument types must be specified\n+explicitly for function definitions.  (As previously mentioned in the\n+[Functions section](#functions), omitting the return type from a\n+function declaration is synonymous with an explicit declaration of\n+return type unit, `()`.)\n+\n+~~~~ {.ignore}\n+fn  fun   (x: int)         { println!(\"{}\", x) } // this is same as saying `-> ()`\n+fn  square(x: int) -> uint { (x * x) as uint }   // other return types are explicit\n+\n+// Error: mismatched types: expected `()` but found `uint`\n+fn  badfun(x: int)         { (x * x) as uint }\n+~~~~\n+\n+On the other hand, the compiler can usually infer both the argument\n+and return types for a closure expression; therefore they are often\n+omitted, since both a human reader and the compiler can deduce the\n+types from the immediate context.  This is in contrast to function\n+declarations, which require types to be specified and are not subject\n+to type inference. Compare:\n \n-The types of the arguments are generally omitted, as is the return type,\n-because the compiler can almost always infer them. In the rare case where the\n-compiler needs assistance, though, the arguments and return types may be\n-annotated.\n+~~~~ {.ignore}\n+// `fun` as a function declaration cannot infer the type of `x`, so it must be provided\n+fn  fun       (x: int) { println!(\"{}\", x) }\n+let closure = |x     | { println!(\"{}\", x) }; // infers `x: int`, return type `()`\n+\n+// For closures, omitting a return type is *not* synonymous with `-> ()`\n+let add_3   = |y     | { 3i + y }; // infers `y: int`, return type `int`.\n+\n+fun(10);            // Prints 10\n+closure(20);        // Prints 20\n+closure(add_3(30)); // Prints 33\n \n+fun(\"String\"); // Error: mismatched types\n+\n+// Error: mismatched types\n+// inference already assigned `closure` the type `|int| -> ()`\n+closure(\"String\");\n ~~~~\n-let square = |x: int| -> uint { (x * x) as uint };\n+\n+In cases where the compiler needs assistance, the arguments and return\n+types may be annotated on closures, using the same notation as shown\n+earlier.  In the example below, since different types provide an\n+implementation for the operator `*`, the argument type for the `x`\n+parameter must be explicitly provided.\n+\n+~~~~{.ignore}\n+// Error: the type of `x` must be known to be used with `x * x`\n+let square = |x     | -> uint { (x * x) as uint };\n+~~~~\n+\n+In the corrected version, the argument type is explicitly annotated,\n+while the return type can still be inferred.\n+\n+~~~~\n+let square_explicit = |x: int| -> uint { (x * x) as uint };\n+let square_infer    = |x: int|         { (x * x) as uint };\n+\n+println!(\"{}\", square_explicit(20));  // 400\n+println!(\"{}\", square_infer(-20));    // 400\n ~~~~\n \n There are several forms of closure, each with its own role. The most"}]}