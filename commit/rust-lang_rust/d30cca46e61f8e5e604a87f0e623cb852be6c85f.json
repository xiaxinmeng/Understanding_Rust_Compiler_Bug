{"sha": "d30cca46e61f8e5e604a87f0e623cb852be6c85f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMGNjYTQ2ZTYxZjhlNWU2MDRhODdmMGU2MjNjYjg1MmJlNmM4NWY=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-02T20:06:13Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-02T21:31:45Z"}, "message": "Fix embarrassing bug where 'unkillable' would unwind improperly when it receives a kill signal.", "tree": {"sha": "e42f180c70df6dc196d91c1e85f6324f470fa4b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e42f180c70df6dc196d91c1e85f6324f470fa4b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d30cca46e61f8e5e604a87f0e623cb852be6c85f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d30cca46e61f8e5e604a87f0e623cb852be6c85f", "html_url": "https://github.com/rust-lang/rust/commit/d30cca46e61f8e5e604a87f0e623cb852be6c85f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d30cca46e61f8e5e604a87f0e623cb852be6c85f/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cde6ad39920ddadd7c70921232ae92adff258367", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde6ad39920ddadd7c70921232ae92adff258367", "html_url": "https://github.com/rust-lang/rust/commit/cde6ad39920ddadd7c70921232ae92adff258367"}], "stats": {"total": 46, "additions": 44, "deletions": 2}, "files": [{"sha": "6c450971cdc6325e857b3061414df3ee6e81a83f", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d30cca46e61f8e5e604a87f0e623cb852be6c85f/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d30cca46e61f8e5e604a87f0e623cb852be6c85f/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=d30cca46e61f8e5e604a87f0e623cb852be6c85f", "patch": "@@ -548,11 +548,12 @@ impl Death {\n     /// All calls must be paired with a subsequent call to allow_kill.\n     #[inline]\n     pub fn inhibit_kill(&mut self, already_failing: bool) {\n-        if self.unkillable == 0 {\n+        self.unkillable += 1;\n+        // May fail, hence must happen *after* incrementing the counter\n+        if self.unkillable == 1 {\n             rtassert!(self.kill_handle.is_some());\n             self.kill_handle.get_mut_ref().inhibit_kill(already_failing);\n         }\n-        self.unkillable += 1;\n     }\n \n     /// Exit a possibly-nested unkillable section of code."}, {"sha": "e08297a142516cb968d6610854c0768b3cf98b6c", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d30cca46e61f8e5e604a87f0e623cb852be6c85f/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d30cca46e61f8e5e604a87f0e623cb852be6c85f/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=d30cca46e61f8e5e604a87f0e623cb852be6c85f", "patch": "@@ -655,6 +655,47 @@ pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n     }\n }\n \n+#[test] #[ignore(cfg(windows))]\n+fn test_kill_unkillable_task() {\n+    use rt::test::*;\n+\n+    // Attempt to test that when a kill signal is received at the start of an\n+    // unkillable section, 'unkillable' unwinds correctly. This is actually\n+    // quite a difficult race to expose, as the kill has to happen on a second\n+    // CPU, *after* the spawner is already switched-back-to (and passes the\n+    // killed check at the start of its timeslice). As far as I know, it's not\n+    // possible to make this race deterministic, or even more likely to happen.\n+    do run_in_newsched_task {\n+        do task::try {\n+            do task::spawn {\n+                fail!();\n+            }\n+            do task::unkillable { }\n+        };\n+    }\n+}\n+\n+#[test] #[ignore(cfg(windows))]\n+fn test_kill_rekillable_task() {\n+    use rt::test::*;\n+\n+    // Tests that when a kill signal is received, 'rekillable' and\n+    // 'unkillable' unwind correctly in conjunction with each other.\n+    do run_in_newsched_task {\n+        do task::try {\n+            do task::unkillable {\n+                unsafe {\n+                    do task::rekillable {\n+                        do task::spawn {\n+                            fail!();\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+    }\n+}\n+\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_cant_dup_task_builder() {\n     let mut builder = task();"}]}