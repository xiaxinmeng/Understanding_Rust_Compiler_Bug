{"sha": "41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZmZjOTBlOTgzYTBkMWExYzdjZGUwZTUzMDM3N2QyZjI5Y2Y3ZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-01T05:26:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-01T05:26:24Z"}, "message": "auto merge of #10187 : pcwalton/rust/remove-mocks, r=pcwalton\n\nr? @alexcrichton", "tree": {"sha": "90a6c01f48aa39ab5b5a4eb87b5ee2fd9f665327", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90a6c01f48aa39ab5b5a4eb87b5ee2fd9f665327"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "html_url": "https://github.com/rust-lang/rust/commit/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bbd4afb4ae5503bc04a7f500bc8ade6e1db0854", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bbd4afb4ae5503bc04a7f500bc8ade6e1db0854", "html_url": "https://github.com/rust-lang/rust/commit/1bbd4afb4ae5503bc04a7f500bc8ade6e1db0854"}, {"sha": "a6f776d2dc22a998c6dbeb4216816489b7c4fdbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6f776d2dc22a998c6dbeb4216816489b7c4fdbe", "html_url": "https://github.com/rust-lang/rust/commit/a6f776d2dc22a998c6dbeb4216816489b7c4fdbe"}], "stats": {"total": 689, "additions": 451, "deletions": 238}, "files": [{"sha": "ab1ca420afab15b850f6ee0bf9353688864f7de6", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -308,10 +308,11 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                       ident: Option<ast::Ident>,\n                       sig: &ty::FnSig)\n                       -> ~str {\n-        let mut s = ~\"extern \";\n-\n-        s.push_str(abis.to_str());\n-        s.push_char(' ');\n+        let mut s = if abis.is_rust() {\n+            ~\"\"\n+        } else {\n+            format!(\"extern {} \", abis.to_str())\n+        };\n \n         match purity {\n             ast::impure_fn => {}\n@@ -331,16 +332,16 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n           _ => { }\n         }\n \n-        push_sig_to_str(cx, &mut s, sig);\n+        push_sig_to_str(cx, &mut s, '(', ')', sig);\n \n         return s;\n     }\n-    fn closure_to_str(cx: ctxt, cty: &ty::ClosureTy) -> ~str\n-    {\n+    fn closure_to_str(cx: ctxt, cty: &ty::ClosureTy) -> ~str {\n         let is_proc =\n             (cty.sigil, cty.onceness) == (ast::OwnedSigil, ast::Once);\n+        let is_borrowed_closure = cty.sigil == ast::BorrowedSigil;\n \n-        let mut s = if is_proc {\n+        let mut s = if is_proc || is_borrowed_closure {\n             ~\"\"\n         } else {\n             cty.sigil.to_str()\n@@ -374,23 +375,42 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                 }\n             };\n \n-            s.push_str(\"fn\");\n+            if !is_borrowed_closure {\n+                s.push_str(\"fn\");\n+            }\n         }\n \n-        if !cty.bounds.is_empty() {\n-            s.push_str(\":\");\n-        }\n-        s.push_str(cty.bounds.repr(cx));\n+        if !is_borrowed_closure {\n+            // Print bounds before `fn` if this is not a borrowed closure.\n+            if !cty.bounds.is_empty() {\n+                s.push_str(\":\");\n+                s.push_str(cty.bounds.repr(cx));\n+            }\n+\n+            push_sig_to_str(cx, &mut s, '(', ')', &cty.sig);\n+        } else {\n+            // Print bounds after the signature if this is a borrowed closure.\n+            push_sig_to_str(cx, &mut s, '|', '|', &cty.sig);\n \n-        push_sig_to_str(cx, &mut s, &cty.sig);\n+            if is_borrowed_closure {\n+                if !cty.bounds.is_empty() {\n+                    s.push_str(\":\");\n+                    s.push_str(cty.bounds.repr(cx));\n+                }\n+            }\n+        }\n \n         return s;\n     }\n-    fn push_sig_to_str(cx: ctxt, s: &mut ~str, sig: &ty::FnSig) {\n-        s.push_char('(');\n+    fn push_sig_to_str(cx: ctxt,\n+                       s: &mut ~str,\n+                       bra: char,\n+                       ket: char,\n+                       sig: &ty::FnSig) {\n+        s.push_char(bra);\n         let strs = sig.inputs.map(|a| fn_input_to_str(cx, *a));\n         s.push_str(strs.connect(\", \"));\n-        s.push_char(')');\n+        s.push_char(ket);\n         if ty::get(sig.output).sty != ty_nil {\n             s.push_str(\" -> \");\n             if ty::type_is_bot(sig.output) {"}, {"sha": "261792977b3a9da2118661824026e1005a5ae7bd", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 131, "deletions": 131, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -138,11 +138,118 @@ pub fn u64_from_be_bytes(data: &[u8],\n \n #[cfg(test)]\n mod test {\n-    use option::{Some, None};\n-    use cell::Cell;\n+    use option::{None, Option, Some};\n     use rt::io::mem::{MemReader, MemWriter};\n-    use rt::io::mock::MockReader;\n-    use rt::io::{io_error, placeholder_error};\n+    use rt::io::{Reader, io_error, placeholder_error};\n+\n+    struct InitialZeroByteReader {\n+        count: int,\n+    }\n+\n+    impl Reader for InitialZeroByteReader {\n+        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+            if self.count == 0 {\n+                self.count = 1;\n+                Some(0)\n+            } else {\n+                buf[0] = 10;\n+                Some(1)\n+            }\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n+\n+    struct EofReader;\n+\n+    impl Reader for EofReader {\n+        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n+            None\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n+\n+    struct ErroringReader;\n+\n+    impl Reader for ErroringReader {\n+        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n+            io_error::cond.raise(placeholder_error());\n+            None\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n+\n+    struct PartialReader {\n+        count: int,\n+    }\n+\n+    impl Reader for PartialReader {\n+        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+            if self.count == 0 {\n+                self.count = 1;\n+                buf[0] = 10;\n+                buf[1] = 11;\n+                Some(2)\n+            } else {\n+                buf[0] = 12;\n+                buf[1] = 13;\n+                Some(2)\n+            }\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n+\n+    struct ErroringLaterReader {\n+        count: int,\n+    }\n+\n+    impl Reader for ErroringLaterReader {\n+        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+            if self.count == 0 {\n+                self.count = 1;\n+                buf[0] = 10;\n+                Some(1)\n+            } else {\n+                io_error::cond.raise(placeholder_error());\n+                None\n+            }\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n+\n+    struct ThreeChunkReader {\n+        count: int,\n+    }\n+\n+    impl Reader for ThreeChunkReader {\n+        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+            if self.count == 0 {\n+                self.count = 1;\n+                buf[0] = 10;\n+                buf[1] = 11;\n+                Some(2)\n+            } else if self.count == 1 {\n+                self.count = 2;\n+                buf[0] = 12;\n+                buf[1] = 13;\n+                Some(2)\n+            } else {\n+                None\n+            }\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n \n     #[test]\n     fn read_byte() {\n@@ -153,38 +260,23 @@ mod test {\n \n     #[test]\n     fn read_byte_0_bytes() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    Some(0)\n-                } else {\n-                    buf[0] = 10;\n-                    Some(1)\n-                }\n-            }\n+        let mut reader = InitialZeroByteReader {\n+            count: 0,\n         };\n         let byte = reader.read_byte();\n         assert!(byte == Some(10));\n     }\n \n     #[test]\n     fn read_byte_eof() {\n-        let mut reader = MockReader::new();\n-        reader.read = |_| None;\n+        let mut reader = EofReader;\n         let byte = reader.read_byte();\n         assert!(byte == None);\n     }\n \n     #[test]\n     fn read_byte_error() {\n-        let mut reader = MockReader::new();\n-        reader.read = |_| {\n-            io_error::cond.raise(placeholder_error());\n-            None\n-        };\n+        let mut reader = ErroringReader;\n         do io_error::cond.trap(|_| {\n         }).inside {\n             let byte = reader.read_byte();\n@@ -194,46 +286,30 @@ mod test {\n \n     #[test]\n     fn bytes_0_bytes() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    Some(0)\n-                } else {\n-                    buf[0] = 10;\n-                    Some(1)\n-                }\n-            }\n+        let reader = InitialZeroByteReader {\n+            count: 0,\n         };\n         let byte = reader.bytes().next();\n         assert!(byte == Some(10));\n     }\n \n     #[test]\n     fn bytes_eof() {\n-        let mut reader = MockReader::new();\n-        reader.read = |_| None;\n+        let reader = EofReader;\n         let byte = reader.bytes().next();\n         assert!(byte == None);\n     }\n \n     #[test]\n     fn bytes_error() {\n-        let mut reader = MockReader::new();\n-        reader.read = |_| {\n-            io_error::cond.raise(placeholder_error());\n-            None\n-        };\n+        let reader = ErroringReader;\n         let mut it = reader.bytes();\n         do io_error::cond.trap(|_| ()).inside {\n             let byte = it.next();\n             assert!(byte == None);\n         }\n     }\n \n-\n     #[test]\n     fn read_bytes() {\n         let mut reader = MemReader::new(~[10, 11, 12, 13]);\n@@ -243,21 +319,8 @@ mod test {\n \n     #[test]\n     fn read_bytes_partial() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    buf[1] = 11;\n-                    Some(2)\n-                } else {\n-                    buf[0] = 12;\n-                    buf[1] = 13;\n-                    Some(2)\n-                }\n-            }\n+        let mut reader = PartialReader {\n+            count: 0,\n         };\n         let bytes = reader.read_bytes(4);\n         assert!(bytes == ~[10, 11, 12, 13]);\n@@ -282,21 +345,8 @@ mod test {\n \n     #[test]\n     fn push_bytes_partial() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    buf[1] = 11;\n-                    Some(2)\n-                } else {\n-                    buf[0] = 12;\n-                    buf[1] = 13;\n-                    Some(2)\n-                }\n-            }\n+        let mut reader = PartialReader {\n+            count: 0,\n         };\n         let mut buf = ~[8, 9];\n         reader.push_bytes(&mut buf, 4);\n@@ -316,19 +366,8 @@ mod test {\n \n     #[test]\n     fn push_bytes_error() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    Some(1)\n-                } else {\n-                    io_error::cond.raise(placeholder_error());\n-                    None\n-                }\n-            }\n+        let mut reader = ErroringLaterReader {\n+            count: 0,\n         };\n         let mut buf = ~[8, 9];\n         do io_error::cond.trap(|_| { } ).inside {\n@@ -342,19 +381,8 @@ mod test {\n     fn push_bytes_fail_reset_len() {\n         // push_bytes unsafely sets the vector length. This is testing that\n         // upon failure the length is reset correctly.\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    Some(1)\n-                } else {\n-                    io_error::cond.raise(placeholder_error());\n-                    None\n-                }\n-            }\n+        let mut reader = ErroringLaterReader {\n+            count: 0,\n         };\n         let buf = @mut ~[8, 9];\n         do (|| {\n@@ -368,24 +396,8 @@ mod test {\n \n     #[test]\n     fn read_to_end() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    buf[1] = 11;\n-                    Some(2)\n-                } else if *count == 1 {\n-                    *count = 2;\n-                    buf[0] = 12;\n-                    buf[1] = 13;\n-                    Some(2)\n-                } else {\n-                    None\n-                }\n-            }\n+        let mut reader = ThreeChunkReader {\n+            count: 0,\n         };\n         let buf = reader.read_to_end();\n         assert!(buf == ~[10, 11, 12, 13]);\n@@ -394,20 +406,8 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn read_to_end_error() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    buf[1] = 11;\n-                    Some(2)\n-                } else {\n-                    io_error::cond.raise(placeholder_error());\n-                    None\n-                }\n-            }\n+        let mut reader = ThreeChunkReader {\n+            count: 0,\n         };\n         let buf = reader.read_to_end();\n         assert!(buf == ~[10, 11]);"}, {"sha": "a0fd6846ce9b4ed830c5313441e5514d362cfdf4", "filename": "src/libstd/rt/io/mock.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1bbd4afb4ae5503bc04a7f500bc8ade6e1db0854/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbd4afb4ae5503bc04a7f500bc8ade6e1db0854/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmock.rs?ref=1bbd4afb4ae5503bc04a7f500bc8ade6e1db0854", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use option::{Option, None};\n-use rt::io::{Reader, Writer};\n-\n-pub struct MockReader {\n-    read: ~fn(buf: &mut [u8]) -> Option<uint>,\n-    priv eof: ~fn() -> bool\n-}\n-\n-impl MockReader {\n-    pub fn new() -> MockReader {\n-        MockReader {\n-            read: |_| None,\n-            eof: || false\n-        }\n-    }\n-}\n-\n-impl Reader for MockReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { (self.read)(buf) }\n-    fn eof(&mut self) -> bool { (self.eof)() }\n-}\n-\n-pub struct MockWriter {\n-    priv write: ~fn(buf: &[u8]),\n-}\n-\n-impl MockWriter {\n-    pub fn new() -> MockWriter {\n-        MockWriter {\n-            write: |_| (),\n-        }\n-    }\n-}\n-\n-impl Writer for MockWriter {\n-    fn write(&mut self, buf: &[u8]) { (self.write)(buf) }\n-}"}, {"sha": "be205749186fb42ad33ec1b7318f22a1596aac40", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -323,9 +323,6 @@ pub mod native {\n     }\n }\n \n-/// Mock implementations for testing\n-mod mock;\n-\n /// Signal handling\n pub mod signal;\n "}, {"sha": "56254704e28d566fb7c37eccfb36267468747c59", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 155, "deletions": 31, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -561,6 +561,45 @@ impl Parser {\n         }\n     }\n \n+    // Expect and consume a `|`. If `||` is seen, replace it with a single\n+    // `|` and continue. If a `|` is not seen, signal an error.\n+    fn expect_or(&self) {\n+        match *self.token {\n+            token::BINOP(token::OR) => self.bump(),\n+            token::OROR => {\n+                self.replace_token(token::BINOP(token::OR),\n+                                   self.span.lo + BytePos(1),\n+                                   self.span.hi)\n+            }\n+            _ => {\n+                let found_token = self.token_to_str(&token::BINOP(token::OR));\n+                self.fatal(format!(\"expected `{}`, found `{}`\",\n+                                   found_token,\n+                                   self.this_token_to_str()))\n+            }\n+        }\n+    }\n+\n+    // Parse a sequence bracketed by `|` and `|`, stopping before the `|`.\n+    fn parse_seq_to_before_or<T>(&self,\n+                                 sep: &token::Token,\n+                                 f: &fn(&Parser) -> T)\n+                                 -> ~[T] {\n+        let mut first = true;\n+        let mut vector = ~[];\n+        while *self.token != token::BINOP(token::OR) &&\n+                *self.token != token::OROR {\n+            if first {\n+                first = false\n+            } else {\n+                self.expect(sep)\n+            }\n+\n+            vector.push(f(self))\n+        }\n+        vector\n+    }\n+\n     // expect and consume a GT. if a >> is seen, replace it\n     // with a single > and continue. If a GT is not seen,\n     // signal an error.\n@@ -761,11 +800,33 @@ impl Parser {\n         get_ident_interner().get(id.name)\n     }\n \n-    // is this one of the keywords that signals a closure type?\n-    pub fn token_is_closure_keyword(&self, tok: &token::Token) -> bool {\n-        token::is_keyword(keywords::Unsafe, tok) ||\n-            token::is_keyword(keywords::Once, tok) ||\n-            token::is_keyword(keywords::Fn, tok)\n+    // Is the current token one of the keywords that signals a bare function\n+    // type?\n+    pub fn token_is_bare_fn_keyword(&self) -> bool {\n+        if token::is_keyword(keywords::Fn, self.token) {\n+            return true\n+        }\n+\n+        if token::is_keyword(keywords::Unsafe, self.token) ||\n+            token::is_keyword(keywords::Once, self.token) {\n+            return self.look_ahead(1, |t| token::is_keyword(keywords::Fn, t))\n+        }\n+\n+        false\n+    }\n+\n+    // Is the current token one of the keywords that signals a closure type?\n+    pub fn token_is_closure_keyword(&self) -> bool {\n+        token::is_keyword(keywords::Unsafe, self.token) ||\n+            token::is_keyword(keywords::Once, self.token)\n+    }\n+\n+    // Is the current token one of the keywords that signals an old-style\n+    // closure type (with explicit sigil)?\n+    pub fn token_is_old_style_closure_keyword(&self) -> bool {\n+        token::is_keyword(keywords::Unsafe, self.token) ||\n+            token::is_keyword(keywords::Once, self.token) ||\n+            token::is_keyword(keywords::Fn, self.token)\n     }\n \n     pub fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n@@ -786,15 +847,15 @@ impl Parser {\n     pub fn parse_ty_bare_fn(&self) -> ty_ {\n         /*\n \n-        extern \"ABI\" [unsafe] fn <'lt> (S) -> T\n-               ^~~~^ ^~~~~~~^    ^~~~^ ^~^    ^\n-                 |     |           |    |     |\n-                 |     |           |    |   Return type\n-                 |     |           |  Argument types\n-                 |     |       Lifetimes\n-                 |     |\n-                 |   Purity\n-                ABI\n+        [extern \"ABI\"] [unsafe] fn <'lt> (S) -> T\n+                ^~~~^  ^~~~~~~^    ^~~~^ ^~^    ^\n+                  |      |           |    |     |\n+                  |      |           |    |   Return type\n+                  |      |           |  Argument types\n+                  |      |       Lifetimes\n+                  |      |\n+                  |    Purity\n+                 ABI\n \n         */\n \n@@ -828,8 +889,8 @@ impl Parser {\n \n     // parse a ty_closure type\n     pub fn parse_ty_closure(&self,\n-                            sigil: ast::Sigil,\n-                            region: Option<ast::Lifetime>)\n+                            opt_sigil: Option<ast::Sigil>,\n+                            mut region: Option<ast::Lifetime>)\n                             -> ty_ {\n         /*\n \n@@ -852,10 +913,58 @@ impl Parser {\n \n         let purity = self.parse_unsafety();\n         let onceness = parse_onceness(self);\n-        self.expect_keyword(keywords::Fn);\n-        let bounds = self.parse_optional_ty_param_bounds();\n \n-        let (decl, lifetimes) = self.parse_ty_fn_decl();\n+        let (sigil, decl, lifetimes, bounds) = match opt_sigil {\n+            Some(sigil) => {\n+                // Old-style closure syntax (`fn(A)->B`).\n+                self.expect_keyword(keywords::Fn);\n+                let bounds = self.parse_optional_ty_param_bounds();\n+                let (decl, lifetimes) = self.parse_ty_fn_decl();\n+                (sigil, decl, lifetimes, bounds)\n+            }\n+            None => {\n+                // New-style closure syntax (`<'lt>|A|:K -> B`).\n+                let lifetimes = if self.eat(&token::LT) {\n+                    let lifetimes = self.parse_lifetimes();\n+                    self.expect_gt();\n+\n+                    // Re-parse the region here. What a hack.\n+                    if region.is_some() {\n+                        self.span_err(*self.last_span,\n+                                      \"lifetime declarations must precede \\\n+                                       the lifetime associated with a \\\n+                                       closure\");\n+                    }\n+                    region = self.parse_opt_lifetime();\n+\n+                    lifetimes\n+                } else {\n+                    opt_vec::Empty\n+                };\n+\n+                let inputs = if self.eat(&token::OROR) {\n+                    ~[]\n+                } else {\n+                    self.expect_or();\n+                    let inputs = self.parse_seq_to_before_or(\n+                        &token::COMMA,\n+                        |p| p.parse_arg_general(false));\n+                    self.expect_or();\n+                    inputs\n+                };\n+\n+                let bounds = self.parse_optional_ty_param_bounds();\n+\n+                let (return_style, output) = self.parse_ret_ty();\n+                let decl = ast::fn_decl {\n+                    inputs: inputs,\n+                    output: output,\n+                    cf: return_style,\n+                };\n+\n+                (BorrowedSigil, decl, lifetimes, bounds)\n+            }\n+        };\n \n         return ty_closure(@TyClosure {\n             sigil: sigil,\n@@ -1120,13 +1229,23 @@ impl Parser {\n             // BORROWED POINTER\n             self.bump();\n             self.parse_borrowed_pointee()\n-        } else if self.eat_keyword(keywords::Extern) {\n-            // EXTERN FUNCTION\n+        } else if self.is_keyword(keywords::Extern) ||\n+                self.token_is_bare_fn_keyword() {\n+            // BARE FUNCTION\n             self.parse_ty_bare_fn()\n-        } else if self.token_is_closure_keyword(self.token) {\n+        } else if self.token_is_closure_keyword() ||\n+                *self.token == token::BINOP(token::OR) ||\n+                *self.token == token::OROR ||\n+                *self.token == token::LT ||\n+                self.token_is_lifetime(self.token) {\n             // CLOSURE\n-            let result = self.parse_ty_closure(ast::BorrowedSigil, None);\n-            self.obsolete(*self.last_span, ObsoleteBareFnType);\n+            //\n+            // XXX(pcwalton): Eventually `token::LT` will not unambiguously\n+            // introduce a closure, once procs can have lifetime bounds. We\n+            // will need to refactor the grammar a little bit at that point.\n+\n+            let lifetime = self.parse_opt_lifetime();\n+            let result = self.parse_ty_closure(None, lifetime);\n             result\n         } else if self.eat_keyword(keywords::Typeof) {\n             // TYPEOF\n@@ -1161,12 +1280,12 @@ impl Parser {\n         match *self.token {\n             token::LIFETIME(*) => {\n                 let lifetime = self.parse_lifetime();\n-                return self.parse_ty_closure(sigil, Some(lifetime));\n+                return self.parse_ty_closure(Some(sigil), Some(lifetime));\n             }\n \n             token::IDENT(*) => {\n-                if self.token_is_closure_keyword(self.token) {\n-                    return self.parse_ty_closure(sigil, None);\n+                if self.token_is_old_style_closure_keyword() {\n+                    return self.parse_ty_closure(Some(sigil), None);\n                 }\n             }\n             _ => {}\n@@ -1187,8 +1306,8 @@ impl Parser {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = self.parse_opt_lifetime();\n \n-        if self.token_is_closure_keyword(self.token) {\n-            return self.parse_ty_closure(BorrowedSigil, opt_lifetime);\n+        if self.token_is_old_style_closure_keyword() {\n+            return self.parse_ty_closure(Some(BorrowedSigil), opt_lifetime);\n         }\n \n         let mt = self.parse_mt();\n@@ -4390,8 +4509,13 @@ impl Parser {\n         }\n     }\n \n-    // parse a string as an ABI spec on an extern type or module\n+    // Parses a string as an ABI spec on an extern type or module. Consumes\n+    // the `extern` keyword, if one is found.\n     fn parse_opt_abis(&self) -> Option<AbiSet> {\n+        if !self.eat_keyword(keywords::Extern) {\n+            return None\n+        }\n+\n         match *self.token {\n             token::LIT_STR(s)\n             | token::LIT_STR_RAW(s, _) => {\n@@ -4467,7 +4591,7 @@ impl Parser {\n             });\n         }\n         // either a view item or an item:\n-        if self.eat_keyword(keywords::Extern) {\n+        if self.is_keyword(keywords::Extern) {\n             let opt_abis = self.parse_opt_abis();\n \n             if self.eat_keyword(keywords::Fn) {"}, {"sha": "0eb1045efe95fd1464816db9d680e65b4f52da9d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -2015,20 +2015,39 @@ pub fn print_ty_fn(s: @ps,\n     // function prints the sigil in the wrong place.  That should be fixed.\n     if opt_sigil == Some(ast::OwnedSigil) && onceness == ast::Once {\n         word(s.s, \"proc\");\n-    } else {\n+    } else if opt_sigil == Some(ast::BorrowedSigil) {\n         print_extern_opt_abis(s, opt_abis);\n+        for lifetime in opt_region.iter() {\n+            print_lifetime(s, lifetime);\n+        }\n+        print_purity(s, purity);\n+        print_onceness(s, onceness);\n+    } else {\n+        print_opt_abis_and_extern_if_nondefault(s, opt_abis);\n         print_opt_sigil(s, opt_sigil);\n         print_opt_lifetime(s, opt_region);\n         print_purity(s, purity);\n         print_onceness(s, onceness);\n         word(s.s, \"fn\");\n     }\n+\n     match id { Some(id) => { word(s.s, \" \"); print_ident(s, id); } _ => () }\n-    do opt_bounds.as_ref().map |bounds| { print_bounds(s, bounds, true); };\n+\n+    if opt_sigil != Some(ast::BorrowedSigil) {\n+        do opt_bounds.as_ref().map |bounds| {\n+            print_bounds(s, bounds, true);\n+        };\n+    }\n+\n     match generics { Some(g) => print_generics(s, g), _ => () }\n     zerobreak(s.s);\n \n-    popen(s);\n+    if opt_sigil == Some(ast::BorrowedSigil) {\n+        word(s.s, \"|\");\n+    } else {\n+        popen(s);\n+    }\n+\n     // It is unfortunate to duplicate the commasep logic, but we want the\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n@@ -2041,7 +2060,14 @@ pub fn print_ty_fn(s: @ps,\n         print_arg(s, arg);\n     }\n     end(s);\n-    pclose(s);\n+\n+    if opt_sigil == Some(ast::BorrowedSigil) {\n+        word(s.s, \"|\");\n+\n+        opt_bounds.as_ref().map(|bounds| print_bounds(s, bounds, true));\n+    } else {\n+        pclose(s);\n+    }\n \n     maybe_print_comment(s, decl.output.span.lo);\n \n@@ -2274,6 +2300,17 @@ pub fn print_opt_purity(s: @ps, opt_purity: Option<ast::purity>) {\n     }\n }\n \n+pub fn print_opt_abis_and_extern_if_nondefault(s: @ps,\n+                                               opt_abis: Option<AbiSet>) {\n+    match opt_abis {\n+        Some(abis) if !abis.is_rust() => {\n+            word_nbsp(s, \"extern\");\n+            word_nbsp(s, abis.to_str());\n+        }\n+        Some(_) | None => {}\n+    };\n+}\n+\n pub fn print_extern_opt_abis(s: @ps, opt_abis: Option<AbiSet>) {\n     match opt_abis {\n         Some(abis) => {"}, {"sha": "3e38ce9ab358bef650dce605e5f8ea43dcfefdf5", "filename": "src/test/compile-fail/block-coerce-no-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -19,5 +19,5 @@ fn main() {\n     }\n \n     f(g);\n-    //~^ ERROR mismatched types: expected `extern \"Rust\" fn(extern \"Rust\" fn(extern \"Rust\" fn()))`\n+    //~^ ERROR mismatched types: expected `fn(fn(fn()))`\n }"}, {"sha": "3da709942e0e65724cb0f115914dbc999194a9cd", "filename": "src/test/compile-fail/closure-reform-bad.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -0,0 +1,13 @@\n+/* Any copyright is dedicated to the Public Domain.\n+ * http://creativecommons.org/publicdomain/zero/1.0/ */\n+\n+fn call_bare(f: fn(&str)) {\n+    f(\"Hello \");\n+}\n+\n+fn main() {\n+    let string = \"world!\";\n+    let f: |&str| = |s| println(s + string);\n+    call_bare(f)    //~ ERROR mismatched types\n+}\n+"}, {"sha": "5169652a6c06940c2351525c7c5af988638989d3", "filename": "src/test/pretty/closure-reform-pretty.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -0,0 +1,17 @@\n+// Any copyright is dedicated to the Public Domain.\n+// http://creativecommons.org/publicdomain/zero/1.0/\n+\n+// pp-exact\n+\n+fn call_it(f: proc(~str) -> ~str) { }\n+\n+fn call_this(f: |&str|: Send) { }\n+\n+fn call_that(f: <'a>|&'a int, &'a int|: -> int) { }\n+\n+fn call_extern(f: fn() -> int) { }\n+\n+fn call_abid_extern(f: extern \"C\" fn() -> int) { }\n+\n+pub fn main() { }\n+"}, {"sha": "d3d6f1c0e355b09f1b3309961422bdd68b77f031", "filename": "src/test/pretty/disamb-stmt-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -14,7 +14,7 @@\n // preserved.  They are needed to disambiguate `{return n+1}; - 0` from\n // `({return n+1}-0)`.\n \n-fn id(f: &fn() -> int) -> int { f() }\n+fn id(f: || -> int) -> int { f() }\n \n fn wsucc(_n: int) -> int { (do id || { 1 }) - 0 }\n fn main() { }"}, {"sha": "1fb2359da53acc16a8a4a84f9cde49de9d85ac19", "filename": "src/test/pretty/do1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fpretty%2Fdo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fpretty%2Fdo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdo1.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -10,6 +10,6 @@\n \n // pp-exact\n \n-fn f(f: &fn(int)) { f(10) }\n+fn f(f: |int|) { f(10) }\n \n fn main() { do f |i| { assert!(i == 10) } }"}, {"sha": "27e56fb6074a1a6d62583e3853994e7a24c26dd4", "filename": "src/test/pretty/fn-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fpretty%2Ffn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Fpretty%2Ffn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffn-types.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -10,7 +10,7 @@\n \n // pp-exact\n \n-fn from_foreign_fn(_x: extern \"Rust\" fn()) { }\n-fn from_stack_closure(_x: &fn()) { }\n+fn from_foreign_fn(_x: fn()) { }\n+fn from_stack_closure(_x: ||) { }\n fn from_unique_closure(_x: ~fn()) { }\n fn main() { }"}, {"sha": "18ca64d0f2762c94519eb4da484b91e002584c2d", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=41ffc90e983a0d1a1c7cde0e530377d2f29cf7e2", "patch": "@@ -1,11 +1,42 @@\n /* Any copyright is dedicated to the Public Domain.\n  * http://creativecommons.org/publicdomain/zero/1.0/ */\n \n+use std::cast;\n+\n fn call_it(f: proc(~str) -> ~str) {\n     println(f(~\"Fred\"))\n }\n \n+fn call_a_thunk(f: ||) {\n+    f();\n+}\n+\n+fn call_this(f: |&str|:Send) {\n+    f(\"Hello!\");\n+}\n+\n+fn call_that(f: <'a>|&'a int, &'a int|: -> int) {\n+    let (ten, forty_two) = (10, 42);\n+    println!(\"Your lucky number is {}\", f(&ten, &forty_two));\n+}\n+\n+fn call_cramped(f:||->uint,g:<'a>||->&'a uint) {\n+    let number = f();\n+    let other_number = *g();\n+    println!(\"Ticket {} wins an all-expenses-paid trip to Mountain View\", number + other_number);\n+}\n+\n+fn call_bare(f: fn(&str)) {\n+    f(\"Hello world!\")\n+}\n+\n+fn call_bare_again(f: extern \"Rust\" fn(&str)) {\n+    f(\"Goodbye world!\")\n+}\n+\n pub fn main() {\n+    // Procs\n+\n     let greeting = ~\"Hi \";\n     do call_it |s| {\n         greeting + s\n@@ -23,5 +54,26 @@ pub fn main() {\n     call_it(proc(s: ~str) -> ~str {\n         greeting + s\n     });\n+\n+    // Closures\n+\n+    call_a_thunk(|| println(\"Hello world!\"));\n+\n+    call_this(|s| println(s));\n+\n+    call_that(|x, y| *x + *y);\n+\n+    let z = 100;\n+    call_that(|x, y| *x + *y - z);\n+\n+    call_cramped(|| 1, || unsafe {\n+        cast::transmute(&100)\n+    });\n+\n+    // External functions\n+\n+    call_bare(println);\n+\n+    call_bare_again(println);\n }\n "}]}