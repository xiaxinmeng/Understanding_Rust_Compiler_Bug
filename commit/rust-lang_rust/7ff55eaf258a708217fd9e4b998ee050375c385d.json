{"sha": "7ff55eaf258a708217fd9e4b998ee050375c385d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZjU1ZWFmMjU4YTcwODIxN2ZkOWU0Yjk5OGVlMDUwMzc1YzM4NWQ=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-06-16T18:47:09Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-06-16T18:47:09Z"}, "message": "Fix file!(), line!() and column!() macros\n\nThese used to return wrong results in case they were expanded inside compiler\u2019s\niternal syntax sugar (closures, if-let) expansions\n\nFixes #26322", "tree": {"sha": "75dd220739b075e2c796257fe50ea42dd9808dce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75dd220739b075e2c796257fe50ea42dd9808dce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ff55eaf258a708217fd9e4b998ee050375c385d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ff55eaf258a708217fd9e4b998ee050375c385d", "html_url": "https://github.com/rust-lang/rust/commit/7ff55eaf258a708217fd9e4b998ee050375c385d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ff55eaf258a708217fd9e4b998ee050375c385d/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73fb19c04ac227fe2aad2c618f76b6eb05dd7ec9", "url": "https://api.github.com/repos/rust-lang/rust/commits/73fb19c04ac227fe2aad2c618f76b6eb05dd7ec9", "html_url": "https://github.com/rust-lang/rust/commit/73fb19c04ac227fe2aad2c618f76b6eb05dd7ec9"}], "stats": {"total": 144, "additions": 72, "deletions": 72}, "files": [{"sha": "ea27ed6b3605c21cafb3ad3fba2b4162623b223b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/7ff55eaf258a708217fd9e4b998ee050375c385d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ff55eaf258a708217fd9e4b998ee050375c385d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=7ff55eaf258a708217fd9e4b998ee050375c385d", "patch": "@@ -17,7 +17,7 @@\n //! within the CodeMap, which upon request can be converted to line and column\n //! information, source code snippets, etc.\n \n-pub use self::MacroFormat::*;\n+pub use self::ExpnFormat::*;\n \n use std::cell::RefCell;\n use std::ops::{Add, Sub};\n@@ -228,17 +228,17 @@ pub struct FileMapAndBytePos { pub fm: Rc<FileMap>, pub pos: BytePos }\n \n \n // _____________________________________________________________________________\n-// MacroFormat, NameAndSpan, ExpnInfo, ExpnId\n+// ExpnFormat, NameAndSpan, ExpnInfo, ExpnId\n //\n \n-/// The syntax with which a macro was invoked.\n-#[derive(Clone, Copy, Hash, Debug)]\n-pub enum MacroFormat {\n+/// The source of expansion.\n+#[derive(Clone, Copy, Hash, Debug, PartialEq, Eq)]\n+pub enum ExpnFormat {\n     /// e.g. #[derive(...)] <item>\n     MacroAttribute,\n     /// e.g. `format!()`\n     MacroBang,\n-    /// Expansion performed by the compiler (libsyntax::expand).\n+    /// Syntax sugar expansion performed by the compiler (libsyntax::expand).\n     CompilerExpansion,\n }\n \n@@ -248,7 +248,7 @@ pub struct NameAndSpan {\n     /// with this Span.\n     pub name: String,\n     /// The format with which the macro was invoked.\n-    pub format: MacroFormat,\n+    pub format: ExpnFormat,\n     /// Whether the macro is allowed to use #[unstable]/feature-gated\n     /// features internally without forcing the whole crate to opt-in\n     /// to them.\n@@ -259,11 +259,11 @@ pub struct NameAndSpan {\n     pub span: Option<Span>\n }\n \n-/// Extra information for tracking macro expansion of spans\n+/// Extra information for tracking spans of macro and syntax sugar expansion\n #[derive(Hash, Debug)]\n pub struct ExpnInfo {\n-    /// The location of the actual macro invocation, e.g. `let x =\n-    /// foo!();`\n+    /// The location of the actual macro invocation or syntax sugar , e.g.\n+    /// `let x = foo!();` or `if let Some(y) = x {}`\n     ///\n     /// This may recursively refer to other macro invocations, e.g. if\n     /// `foo!()` invoked `bar!()` internally, and there was an\n@@ -272,12 +272,7 @@ pub struct ExpnInfo {\n     /// call_site span would have its own ExpnInfo, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n-    /// Information about the macro and its definition.\n-    ///\n-    /// The `callee` of the inner expression in the `call_site`\n-    /// example would point to the `macro_rules! bar { ... }` and that\n-    /// of the `bar!()` invocation would point to the `macro_rules!\n-    /// foo { ... }`.\n+    /// Information about the expansion.\n     pub callee: NameAndSpan\n }\n \n@@ -677,7 +672,39 @@ impl CodeMap {\n \n     /// Lookup source information about a BytePos\n     pub fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n-        self.lookup_pos(pos)\n+        let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n+        let line = a + 1; // Line numbers start at 1\n+        let chpos = self.bytepos_to_file_charpos(pos);\n+        let linebpos = (*f.lines.borrow())[a];\n+        let linechpos = self.bytepos_to_file_charpos(linebpos);\n+        debug!(\"byte pos {:?} is on the line at byte pos {:?}\",\n+               pos, linebpos);\n+        debug!(\"char pos {:?} is on the line at char pos {:?}\",\n+               chpos, linechpos);\n+        debug!(\"byte is on line: {}\", line);\n+        assert!(chpos >= linechpos);\n+        Loc {\n+            file: f,\n+            line: line,\n+            col: chpos - linechpos\n+        }\n+    }\n+\n+    fn lookup_line(&self, pos: BytePos) -> FileMapAndLine {\n+        let idx = self.lookup_filemap_idx(pos);\n+\n+        let files = self.files.borrow();\n+        let f = (*files)[idx].clone();\n+        let mut a = 0;\n+        {\n+            let lines = f.lines.borrow();\n+            let mut b = lines.len();\n+            while b - a > 1 {\n+                let m = (a + b) / 2;\n+                if (*lines)[m] > pos { b = m; } else { a = m; }\n+            }\n+        }\n+        FileMapAndLine {fm: f, line: a}\n     }\n \n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n@@ -877,42 +904,6 @@ impl CodeMap {\n         return a;\n     }\n \n-    fn lookup_line(&self, pos: BytePos) -> FileMapAndLine {\n-        let idx = self.lookup_filemap_idx(pos);\n-\n-        let files = self.files.borrow();\n-        let f = (*files)[idx].clone();\n-        let mut a = 0;\n-        {\n-            let lines = f.lines.borrow();\n-            let mut b = lines.len();\n-            while b - a > 1 {\n-                let m = (a + b) / 2;\n-                if (*lines)[m] > pos { b = m; } else { a = m; }\n-            }\n-        }\n-        FileMapAndLine {fm: f, line: a}\n-    }\n-\n-    fn lookup_pos(&self, pos: BytePos) -> Loc {\n-        let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n-        let line = a + 1; // Line numbers start at 1\n-        let chpos = self.bytepos_to_file_charpos(pos);\n-        let linebpos = (*f.lines.borrow())[a];\n-        let linechpos = self.bytepos_to_file_charpos(linebpos);\n-        debug!(\"byte pos {:?} is on the line at byte pos {:?}\",\n-               pos, linebpos);\n-        debug!(\"char pos {:?} is on the line at char pos {:?}\",\n-               chpos, linechpos);\n-        debug!(\"byte is on line: {}\", line);\n-        assert!(chpos >= linechpos);\n-        Loc {\n-            file: f,\n-            line: line,\n-            col: chpos - linechpos\n-        }\n-    }\n-\n     pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n         let mut expansions = self.expansions.borrow_mut();\n         expansions.push(expn_info);"}, {"sha": "ce4ed9f21588fb2c41539747b9faa7992d599a5d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7ff55eaf258a708217fd9e4b998ee050375c385d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ff55eaf258a708217fd9e4b998ee050375c385d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7ff55eaf258a708217fd9e4b998ee050375c385d", "patch": "@@ -13,7 +13,7 @@ pub use self::SyntaxExtension::*;\n use ast;\n use ast::Name;\n use codemap;\n-use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n+use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION, CompilerExpansion};\n use ext;\n use ext::expand;\n use ext::tt::macro_rules;\n@@ -658,6 +658,8 @@ impl<'a> ExtCtxt<'a> {\n         })\n     }\n     pub fn backtrace(&self) -> ExpnId { self.backtrace }\n+\n+    /// Original span that caused the current exapnsion to happen.\n     pub fn original_span(&self) -> Span {\n         let mut expn_id = self.backtrace;\n         let mut call_site = None;\n@@ -672,26 +674,33 @@ impl<'a> ExtCtxt<'a> {\n         }\n         call_site.expect(\"missing expansion backtrace\")\n     }\n-    pub fn original_span_in_file(&self) -> Span {\n+\n+    /// Returns span for the macro which originally caused the current expansion to happen.\n+    ///\n+    /// Stops backtracing at include! boundary.\n+    pub fn expansion_cause(&self) -> Span {\n         let mut expn_id = self.backtrace;\n-        let mut call_site = None;\n+        let mut last_macro = None;\n+        let mut current_expn = None;\n         loop {\n-            let expn_info = self.codemap().with_expn_info(expn_id, |ei| {\n-                ei.map(|ei| (ei.call_site, ei.callee.name == \"include\"))\n-            });\n-            match expn_info {\n-                None => break,\n-                Some((cs, is_include)) => {\n-                    if is_include {\n-                        // Don't recurse into file using \"include!\".\n-                        break;\n+            if self.codemap().with_expn_info(expn_id, |info| {\n+                info.map_or(None, |i| {\n+                    if i.callee.name == \"include\" {\n+                        // Stop going up the backtrace once include! is encountered\n+                        return None;\n                     }\n-                    call_site = Some(cs);\n-                    expn_id = cs.expn_id;\n-                }\n+                    expn_id = i.call_site.expn_id;\n+                    current_expn = Some(i.call_site);\n+                    if i.callee.format != CompilerExpansion {\n+                        last_macro = Some(i.call_site)\n+                    }\n+                    return Some(());\n+                })\n+            }).is_none() {\n+                break\n             }\n         }\n-        call_site.expect(\"missing expansion backtrace\")\n+        last_macro.expect(\"missing expansion backtrace\")\n     }\n \n     pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }"}, {"sha": "3866f5534c2ebb4b10c357b5bf252ce6665f47d2", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ff55eaf258a708217fd9e4b998ee050375c385d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ff55eaf258a708217fd9e4b998ee050375c385d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=7ff55eaf258a708217fd9e4b998ee050375c385d", "patch": "@@ -34,7 +34,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n-    let topmost = cx.original_span_in_file();\n+    let topmost = cx.expansion_cause();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n \n     base::MacEager::expr(cx.expr_u32(topmost, loc.line as u32))\n@@ -45,7 +45,7 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"column!\");\n \n-    let topmost = cx.original_span_in_file();\n+    let topmost = cx.expansion_cause();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n \n     base::MacEager::expr(cx.expr_u32(topmost, loc.col.to_usize() as u32))\n@@ -58,7 +58,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n-    let topmost = cx.original_span_in_file();\n+    let topmost = cx.expansion_cause();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n     let filename = token::intern_and_get_ident(&loc.file.name);\n     base::MacEager::expr(cx.expr_str(topmost, filename))"}]}