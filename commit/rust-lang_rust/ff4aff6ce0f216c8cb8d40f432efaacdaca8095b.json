{"sha": "ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNGFmZjZjZTBmMjE2YzhjYjhkNDBmNDMyZWZhYWNkYWNhODA5NWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-03T08:43:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-03T08:43:11Z"}, "message": "Auto merge of #70107 - lcnr:issue68977, r=eddyb\n\nWF-check all ty::Const's, not just array lengths.\n\nfixes #68977\n\nThis PR removes the special case for array length in `wf::compute` and\nchecks the well formedness of all consts.\n\nChanges `PredicateKind::WellFormed` to take a `GenericArg` and updates `wf::obligations`.", "tree": {"sha": "1097d9453861691c8d3e743b439a15b69f0de4e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1097d9453861691c8d3e743b439a15b69f0de4e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "html_url": "https://github.com/rust-lang/rust/commit/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "680a4b2fbdca0dc6c5ceec826a8dbeabe28f305d", "url": "https://api.github.com/repos/rust-lang/rust/commits/680a4b2fbdca0dc6c5ceec826a8dbeabe28f305d", "html_url": "https://github.com/rust-lang/rust/commit/680a4b2fbdca0dc6c5ceec826a8dbeabe28f305d"}, {"sha": "631ac9c472322077304d9acc4de21220c54c56db", "url": "https://api.github.com/repos/rust-lang/rust/commits/631ac9c472322077304d9acc4de21220c54c56db", "html_url": "https://github.com/rust-lang/rust/commit/631ac9c472322077304d9acc4de21220c54c56db"}], "stats": {"total": 560, "additions": 386, "deletions": 174}, "files": [{"sha": "4ef4ed47cb11a8b20543d907e80c2c5e3275b0e7", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -307,7 +307,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             self.obligations.push(Obligation::new(\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::PredicateKind::WellFormed(b_ty).to_predicate(self.infcx.tcx),\n+                ty::PredicateKind::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n             ));\n         }\n "}, {"sha": "a34cff06bc1cde367018565fec3ff3937134cce0", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -14,7 +14,7 @@ use crate::mir::Body;\n use crate::mir::GeneratorLayout;\n use crate::traits::{self, Reveal};\n use crate::ty;\n-use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n+use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::{Discr, IntTypeExt};\n use rustc_ast::ast;\n use rustc_attr as attr;\n@@ -1061,7 +1061,7 @@ pub enum PredicateKind<'tcx> {\n     Projection(PolyProjectionPredicate<'tcx>),\n \n     /// No syntax: `T` well-formed.\n-    WellFormed(Ty<'tcx>),\n+    WellFormed(GenericArg<'tcx>),\n \n     /// Trait must be object-safe.\n     ObjectSafe(DefId),"}, {"sha": "90fb19816179368ae6843daf7f85e19a5ba545dd", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -2031,7 +2031,7 @@ define_print_and_forward_display! {\n             ty::PredicateKind::RegionOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateKind::TypeOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateKind::Projection(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n+            ty::PredicateKind::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n             &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 p!(write(\"the trait `\"),\n                    print_def_path(trait_def_id, &[]),"}, {"sha": "cee0afacb68f75364ed238d665b3334bc1fb5f61", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -236,7 +236,7 @@ impl fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n             ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n             ty::PredicateKind::Projection(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::WellFormed(ty) => write!(f, \"WellFormed({:?})\", ty),\n+            ty::PredicateKind::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n             ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 write!(f, \"ObjectSafe({:?})\", trait_def_id)\n             }"}, {"sha": "377a0b6f25cab98b7ace7ffc22d88372ffdf564d", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     self.prove_predicate(\n-                        ty::PredicateKind::WellFormed(inferred_ty).to_predicate(self.tcx()),\n+                        ty::PredicateKind::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     obligations.obligations.push(traits::Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        ty::PredicateKind::WellFormed(revealed_ty).to_predicate(infcx.tcx),\n+                        ty::PredicateKind::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n                     ));\n                     obligations.add(\n                         infcx\n@@ -1612,7 +1612,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_call_dest(body, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n-                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty)),\n+                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty.into())),\n                     term_location.to_locations(),\n                     ConstraintCategory::Boring,\n                 );"}, {"sha": "41811bf44b1aff3f48553d983414bfb866b0930d", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -19,6 +19,7 @@ use rustc_hir::Node;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::TypeFolder;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n     self, fast_reject, AdtKind, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt,\n     TypeFoldable, WithConstness,\n@@ -1531,13 +1532,24 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err\n             }\n \n-            ty::PredicateKind::WellFormed(ty) => {\n+            ty::PredicateKind::WellFormed(arg) => {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n-                if ty.references_error() || self.tcx.sess.has_errors() {\n+                if arg.references_error() || self.tcx.sess.has_errors() {\n                     return;\n                 }\n-                self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n+\n+                match arg.unpack() {\n+                    GenericArgKind::Lifetime(lt) => {\n+                        span_bug!(span, \"unexpected well formed predicate: {:?}\", lt)\n+                    }\n+                    GenericArgKind::Type(ty) => {\n+                        self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n+                    }\n+                    GenericArgKind::Const(ct) => {\n+                        self.need_type_info_err_const(body_id, span, ct, ErrorCode::E0282)\n+                    }\n+                }\n             }\n \n             ty::PredicateKind::Subtype(ref data) => {"}, {"sha": "51c62dbb88c845194c00932dd523afeaef062e43", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -459,17 +459,17 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::WellFormed(ty) => {\n+            &ty::PredicateKind::WellFormed(arg) => {\n                 match wf::obligations(\n                     self.selcx.infcx(),\n                     obligation.param_env,\n                     obligation.cause.body_id,\n-                    ty,\n+                    arg,\n                     obligation.cause.span,\n                 ) {\n                     None => {\n                         pending_obligation.stalled_on =\n-                            vec![TyOrConstInferVar::maybe_from_ty(ty).unwrap()];\n+                            vec![TyOrConstInferVar::maybe_from_generic_arg(arg).unwrap()];\n                         ProcessResult::Unchanged\n                     }\n                     Some(os) => ProcessResult::Changed(mk_pending(os)),"}, {"sha": "517433b90ee1221bb681e8ef6ba98ddf5fff1713", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -436,11 +436,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::WellFormed(ty) => match wf::obligations(\n+            &ty::PredicateKind::WellFormed(arg) => match wf::obligations(\n                 self.infcx,\n                 obligation.param_env,\n                 obligation.cause.body_id,\n-                ty,\n+                arg,\n                 obligation.cause.span,\n             ) {\n                 Some(mut obligations) => {"}, {"sha": "5024392a0f98df03a686517f602beba2079009dc", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 122, "deletions": 66, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -4,44 +4,66 @@ use crate::traits;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items;\n-use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_span::Span;\n use std::rc::Rc;\n \n-/// Returns the set of obligations needed to make `ty` well-formed.\n-/// If `ty` contains unresolved inference variables, this may include\n-/// further WF obligations. However, if `ty` IS an unresolved\n+/// Returns the set of obligations needed to make `arg` well-formed.\n+/// If `arg` contains unresolved inference variables, this may include\n+/// further WF obligations. However, if `arg` IS an unresolved\n /// inference variable, returns `None`, because we are not able to\n /// make any progress at all. This is to prevent \"livelock\" where we\n /// say \"$0 is WF if $0 is WF\".\n pub fn obligations<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n-    ty: Ty<'tcx>,\n+    arg: GenericArg<'tcx>,\n     span: Span,\n ) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n     // Handle the \"livelock\" case (see comment above) by bailing out if necessary.\n-    let ty = match ty.kind {\n-        ty::Infer(ty::TyVar(_)) => {\n-            let resolved_ty = infcx.shallow_resolve(ty);\n-            if resolved_ty == ty {\n-                // No progress, bail out to prevent \"livelock\".\n-                return None;\n+    let arg = match arg.unpack() {\n+        GenericArgKind::Type(ty) => {\n+            match ty.kind {\n+                ty::Infer(ty::TyVar(_)) => {\n+                    let resolved_ty = infcx.shallow_resolve(ty);\n+                    if resolved_ty == ty {\n+                        // No progress, bail out to prevent \"livelock\".\n+                        return None;\n+                    }\n+\n+                    resolved_ty\n+                }\n+                _ => ty,\n             }\n+            .into()\n+        }\n+        GenericArgKind::Const(ct) => {\n+            match ct.val {\n+                ty::ConstKind::Infer(infer) => {\n+                    let resolved = infcx.shallow_resolve(infer);\n+                    if resolved == infer {\n+                        // No progress.\n+                        return None;\n+                    }\n \n-            resolved_ty\n+                    infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Infer(resolved), ty: ct.ty })\n+                }\n+                _ => ct,\n+            }\n+            .into()\n         }\n-        _ => ty,\n+        // There is nothing we have to do for lifetimes.\n+        GenericArgKind::Lifetime(..) => return Some(Vec::new()),\n     };\n \n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n-    wf.compute(ty);\n-    debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", ty, body_id, wf.out);\n+    wf.compute(arg);\n+    debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", arg, body_id, wf.out);\n \n     let result = wf.normalize();\n-    debug!(\"wf::obligations({:?}, body_id={:?}) ~~> {:?}\", ty, body_id, result);\n+    debug!(\"wf::obligations({:?}, body_id={:?}) ~~> {:?}\", arg, body_id, result);\n     Some(result)\n }\n \n@@ -78,33 +100,33 @@ pub fn predicate_obligations<'a, 'tcx>(\n         }\n         ty::PredicateKind::RegionOutlives(..) => {}\n         ty::PredicateKind::TypeOutlives(t) => {\n-            wf.compute(t.skip_binder().0);\n+            wf.compute(t.skip_binder().0.into());\n         }\n         ty::PredicateKind::Projection(t) => {\n             let t = t.skip_binder(); // (*)\n             wf.compute_projection(t.projection_ty);\n-            wf.compute(t.ty);\n+            wf.compute(t.ty.into());\n         }\n-        &ty::PredicateKind::WellFormed(t) => {\n-            wf.compute(t);\n+        &ty::PredicateKind::WellFormed(arg) => {\n+            wf.compute(arg);\n         }\n         ty::PredicateKind::ObjectSafe(_) => {}\n         ty::PredicateKind::ClosureKind(..) => {}\n         ty::PredicateKind::Subtype(data) => {\n-            wf.compute(data.skip_binder().a); // (*)\n-            wf.compute(data.skip_binder().b); // (*)\n+            wf.compute(data.skip_binder().a.into()); // (*)\n+            wf.compute(data.skip_binder().b.into()); // (*)\n         }\n         &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n             let obligations = wf.nominal_obligations(def_id, substs);\n             wf.out.extend(obligations);\n \n-            for ty in substs.types() {\n-                wf.compute(ty);\n+            for arg in substs.iter() {\n+                wf.compute(arg);\n             }\n         }\n-        ty::PredicateKind::ConstEquate(c1, c2) => {\n-            wf.compute(c1.ty);\n-            wf.compute(c2.ty);\n+        &ty::PredicateKind::ConstEquate(c1, c2) => {\n+            wf.compute(c1.into());\n+            wf.compute(c2.into());\n         }\n     }\n \n@@ -213,7 +235,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n+    fn cause(&self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n \n@@ -273,15 +295,22 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         }\n \n         let tcx = self.tcx();\n-        self.out.extend(trait_ref.substs.types().filter(|ty| !ty.has_escaping_bound_vars()).map(\n-            |ty| {\n-                traits::Obligation::new(\n-                    cause.clone(),\n-                    param_env,\n-                    ty::PredicateKind::WellFormed(ty).to_predicate(tcx),\n-                )\n-            },\n-        ));\n+        self.out.extend(\n+            trait_ref\n+                .substs\n+                .iter()\n+                .filter(|arg| {\n+                    matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..))\n+                })\n+                .filter(|arg| !arg.has_escaping_bound_vars())\n+                .map(|arg| {\n+                    traits::Obligation::new(\n+                        cause.clone(),\n+                        param_env,\n+                        ty::PredicateKind::WellFormed(arg).to_predicate(tcx),\n+                    )\n+                }),\n+        );\n     }\n \n     /// Pushes the obligations required for `trait_ref::Item` to be WF\n@@ -300,22 +329,6 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         }\n     }\n \n-    /// Pushes the obligations required for an array length to be WF\n-    /// into `self.out`.\n-    fn compute_array_len(&mut self, constant: ty::Const<'tcx>) {\n-        if let ty::ConstKind::Unevaluated(def_id, substs, promoted) = constant.val {\n-            assert!(promoted.is_none());\n-\n-            let obligations = self.nominal_obligations(def_id, substs);\n-            self.out.extend(obligations);\n-\n-            let predicate =\n-                ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(self.tcx());\n-            let cause = self.cause(traits::MiscObligation);\n-            self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n-        }\n-    }\n-\n     fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n         if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n@@ -332,8 +345,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     }\n \n     /// Pushes all the predicates needed to validate that `ty` is WF into `out`.\n-    fn compute(&mut self, ty: Ty<'tcx>) {\n-        let mut walker = ty.walk();\n+    fn compute(&mut self, arg: GenericArg<'tcx>) {\n+        let mut walker = arg.walk();\n         let param_env = self.param_env;\n         while let Some(arg) = walker.next() {\n             let ty = match arg.unpack() {\n@@ -343,9 +356,53 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 // obligations are handled by the parent (e.g. `ty::Ref`).\n                 GenericArgKind::Lifetime(_) => continue,\n \n-                // FIXME(eddyb) this is wrong and needs to be replaced\n-                // (see https://github.com/rust-lang/rust/pull/70107).\n-                GenericArgKind::Const(_) => continue,\n+                GenericArgKind::Const(constant) => {\n+                    match constant.val {\n+                        ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n+                            assert!(promoted.is_none());\n+\n+                            let obligations = self.nominal_obligations(def_id, substs);\n+                            self.out.extend(obligations);\n+\n+                            let predicate = ty::PredicateKind::ConstEvaluatable(def_id, substs)\n+                                .to_predicate(self.tcx());\n+                            let cause = self.cause(traits::MiscObligation);\n+                            self.out.push(traits::Obligation::new(\n+                                cause,\n+                                self.param_env,\n+                                predicate,\n+                            ));\n+                        }\n+                        ty::ConstKind::Infer(infer) => {\n+                            let resolved = self.infcx.shallow_resolve(infer);\n+                            // the `InferConst` changed, meaning that we made progress.\n+                            if resolved != infer {\n+                                let cause = self.cause(traits::MiscObligation);\n+\n+                                let resolved_constant = self.infcx.tcx.mk_const(ty::Const {\n+                                    val: ty::ConstKind::Infer(resolved),\n+                                    ..*constant\n+                                });\n+                                self.out.push(traits::Obligation::new(\n+                                    cause,\n+                                    self.param_env,\n+                                    ty::PredicateKind::WellFormed(resolved_constant.into())\n+                                        .to_predicate(self.tcx()),\n+                                ));\n+                            }\n+                        }\n+                        ty::ConstKind::Error\n+                        | ty::ConstKind::Param(_)\n+                        | ty::ConstKind::Bound(..)\n+                        | ty::ConstKind::Placeholder(..) => {\n+                            // These variants are trivially WF, so nothing to do here.\n+                        }\n+                        ty::ConstKind::Value(..) => {\n+                            // FIXME: Enforce that values are structurally-matchable.\n+                        }\n+                    }\n+                    continue;\n+                }\n             };\n \n             match ty.kind {\n@@ -375,10 +432,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n                 }\n \n-                ty::Array(subty, len) => {\n+                ty::Array(subty, _) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n-                    // FIXME(eddyb) handle `GenericArgKind::Const` above instead.\n-                    self.compute_array_len(*len);\n+                    // Note that we handle the len is implicitly checked while walking `arg`.\n                 }\n \n                 ty::Tuple(ref tys) => {\n@@ -390,11 +446,11 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 }\n \n                 ty::RawPtr(_) => {\n-                    // simple cases that are WF if their type args are WF\n+                    // Simple cases that are WF if their type args are WF.\n                 }\n \n                 ty::Projection(data) => {\n-                    walker.skip_current_subtree(); // subtree handled by compute_projection\n+                    walker.skip_current_subtree(); // Subtree handled by compute_projection.\n                     self.compute_projection(data);\n                 }\n \n@@ -467,7 +523,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     walker.skip_current_subtree(); // subtree handled below\n                     for upvar_ty in substs.as_closure().upvar_tys() {\n                         // FIXME(eddyb) add the type to `walker` instead of recursing.\n-                        self.compute(upvar_ty);\n+                        self.compute(upvar_ty.into());\n                     }\n                 }\n \n@@ -535,12 +591,12 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx()),\n+                            ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()),\n                         ));\n                     } else {\n                         // Yes, resolved, proceed with the result.\n                         // FIXME(eddyb) add the type to `walker` instead of recursing.\n-                        self.compute(ty);\n+                        self.compute(ty.into());\n                     }\n                 }\n             }"}, {"sha": "9530b07e47cdb054ed552c57ad3391ac564d26f2", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -36,7 +36,7 @@ use rustc_middle::traits::{\n     ChalkRustInterner as RustInterner,\n };\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n     self, Binder, BoundRegion, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable, TypeVisitor,\n };\n@@ -77,7 +77,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n     ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n         let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n             ChalkEnvironmentClause::Predicate(predicate) => {\n-                match &predicate.kind() {\n+                match predicate.kind() {\n                     ty::PredicateKind::Trait(predicate, _) => {\n                         let (predicate, binders, _named_regions) =\n                             collect_bound_vars(interner, interner.tcx, predicate);\n@@ -165,24 +165,31 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n             ty::PredicateKind::Projection(predicate) => predicate.lower_into(interner),\n-            ty::PredicateKind::WellFormed(ty) => match ty.kind {\n-                // These types are always WF.\n-                ty::Str | ty::Placeholder(..) | ty::Error | ty::Never => {\n-                    chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n-                }\n+            ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n+                GenericArgKind::Type(ty) => match ty.kind {\n+                    // These types are always WF.\n+                    ty::Str | ty::Placeholder(..) | ty::Error | ty::Never => {\n+                        chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+                    }\n \n-                // FIXME(chalk): Well-formed only if ref lifetime outlives type\n-                ty::Ref(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n+                    // FIXME(chalk): Well-formed only if ref lifetime outlives type\n+                    ty::Ref(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n \n-                ty::Param(..) => panic!(\"No Params expected.\"),\n+                    ty::Param(..) => panic!(\"No Params expected.\"),\n \n-                // FIXME(chalk) -- ultimately I think this is what we\n-                // want to do, and we just have rules for how to prove\n-                // `WellFormed` for everything above, instead of\n-                // inlining a bit the rules of the proof here.\n-                _ => chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n-                    chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n-                )),\n+                    // FIXME(chalk) -- ultimately I think this is what we\n+                    // want to do, and we just have rules for how to prove\n+                    // `WellFormed` for everything above, instead of\n+                    // inlining a bit the rules of the proof here.\n+                    _ => chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n+                        chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n+                    )),\n+                },\n+                // FIXME(chalk): handle well formed consts\n+                GenericArgKind::Const(..) => {\n+                    chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+                }\n+                GenericArgKind::Lifetime(lt) => bug!(\"unexpect well formed predicate: {:?}\", lt),\n             },\n \n             // FIXME(chalk): other predicates"}, {"sha": "651596d0379bb7cbbdc68ab176b56dc3682da5dc", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -47,22 +47,22 @@ fn compute_implied_outlives_bounds<'tcx>(\n     // process it next. Currently (at least) these resulting\n     // predicates are always guaranteed to be a subset of the original\n     // type, so we need not fear non-termination.\n-    let mut wf_types = vec![ty];\n+    let mut wf_args = vec![ty.into()];\n \n     let mut implied_bounds = vec![];\n \n     let mut fulfill_cx = FulfillmentContext::new();\n \n-    while let Some(ty) = wf_types.pop() {\n-        // Compute the obligations for `ty` to be well-formed. If `ty` is\n+    while let Some(arg) = wf_args.pop() {\n+        // Compute the obligations for `arg` to be well-formed. If `arg` is\n         // an unresolved inference variable, just substituted an empty set\n         // -- because the return type here is going to be things we *add*\n         // to the environment, it's always ok for this set to be smaller\n         // than the ultimate set. (Note: normally there won't be\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n         let obligations =\n-            wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n+            wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, arg, DUMMY_SP).unwrap_or(vec![]);\n \n         // N.B., all of these predicates *ought* to be easily proven\n         // true. In fact, their correctness is (mostly) implied by\n@@ -103,8 +103,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => vec![],\n \n-                ty::PredicateKind::WellFormed(subty) => {\n-                    wf_types.push(subty);\n+                &ty::PredicateKind::WellFormed(arg) => {\n+                    wf_args.push(arg);\n                     vec![]\n                 }\n "}, {"sha": "374ef3fc9c783f1ea96c6c180110e03d7dea5bd7", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -140,7 +140,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n             self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n \n             self.prove_predicate(\n-                ty::PredicateKind::WellFormed(impl_self_ty).to_predicate(self.tcx()),\n+                ty::PredicateKind::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n             );\n         }\n \n@@ -155,7 +155,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // them?  This would only be relevant if some input\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n-        self.prove_predicate(ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx()));\n+        self.prove_predicate(ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()));\n         Ok(())\n     }\n }"}, {"sha": "aa316105f7f11be99809a1e6d5ca07e683939591", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // we must check that return type of called functions is WF:\n-        self.register_wf_obligation(output, call_expr.span, traits::MiscObligation);\n+        self.register_wf_obligation(output.into(), call_expr.span, traits::MiscObligation);\n \n         output\n     }"}, {"sha": "007794ce1b7ffff34401b193375b5fbd6752b291", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // the function type must also be well-formed (this is not\n         // implied by the substs being well-formed because of inherent\n         // impls and late-bound regions - see issue #28609).\n-        self.register_wf_obligation(fty, self.span, traits::MiscObligation);\n+        self.register_wf_obligation(fty.into(), self.span, traits::MiscObligation);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "ac3fa15417e9cc3bc02289781ea7dfff5ed1176c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.push(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKind::WellFormed(method_ty).to_predicate(tcx),\n+            ty::PredicateKind::WellFormed(method_ty.into()).to_predicate(tcx),\n         ));\n \n         let callee = MethodCallee { def_id, substs: trait_ref.substs, sig: fn_sig };"}, {"sha": "ba4bca8cd9981cfe85fca2ad5f10705299ccba4f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -121,9 +121,8 @@ use rustc_middle::ty::adjustment::{\n };\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::{\n-    GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSelfTy, UserSubsts,\n-};\n+use rustc_middle::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n+use rustc_middle::ty::subst::{GenericArgKind, UserSelfTy, UserSubsts};\n use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n use rustc_middle::ty::{\n     self, AdtKind, CanonicalUserType, Const, GenericParamDefKind, RegionKind, ToPolyTraitRef,\n@@ -3333,7 +3332,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> Ty<'tcx> {\n         let t = AstConv::ast_ty_to_ty(self, ast_t);\n-        self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n+        self.register_wf_obligation(t.into(), ast_t.span, traits::MiscObligation);\n         t\n     }\n \n@@ -3353,28 +3352,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn to_const(&self, ast_c: &hir::AnonConst) -> &'tcx ty::Const<'tcx> {\n         let const_def_id = self.tcx.hir().local_def_id(ast_c.hir_id);\n         let c = ty::Const::from_anon_const(self.tcx, const_def_id);\n-\n-        // HACK(eddyb) emulate what a `WellFormedConst` obligation would do.\n-        // This code should be replaced with the proper WF handling ASAP.\n-        if let ty::ConstKind::Unevaluated(def_id, substs, promoted) = c.val {\n-            assert!(promoted.is_none());\n-\n-            // HACK(eddyb) let's hope these are always empty.\n-            // let obligations = self.nominal_obligations(def_id, substs);\n-            // self.out.extend(obligations);\n-\n-            let cause = traits::ObligationCause::new(\n-                self.tcx.def_span(const_def_id.to_def_id()),\n-                self.body_id,\n-                traits::MiscObligation,\n-            );\n-            self.register_predicate(traits::Obligation::new(\n-                cause,\n-                self.param_env,\n-                ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(self.tcx),\n-            ));\n-        }\n-\n+        self.register_wf_obligation(\n+            c.into(),\n+            self.tcx.hir().span(ast_c.hir_id),\n+            ObligationCauseCode::MiscObligation,\n+        );\n         c\n     }\n \n@@ -3407,11 +3389,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Registers an obligation for checking later, during regionck, that the type `ty` must\n-    /// outlive the region `r`.\n+    /// Registers an obligation for checking later, during regionck, that `arg` is well-formed.\n     pub fn register_wf_obligation(\n         &self,\n-        ty: Ty<'tcx>,\n+        arg: subst::GenericArg<'tcx>,\n         span: Span,\n         code: traits::ObligationCauseCode<'tcx>,\n     ) {\n@@ -3420,16 +3401,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.register_predicate(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx),\n+            ty::PredicateKind::WellFormed(arg).to_predicate(self.tcx),\n         ));\n     }\n \n-    /// Registers obligations that all types appearing in `substs` are well-formed.\n+    /// Registers obligations that all `substs` are well-formed.\n     pub fn add_wf_bounds(&self, substs: SubstsRef<'tcx>, expr: &hir::Expr<'_>) {\n-        for ty in substs.types() {\n-            if !ty.references_error() {\n-                self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n-            }\n+        for arg in substs.iter().filter(|arg| {\n+            matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..))\n+        }) {\n+            self.register_wf_obligation(arg, expr.span, traits::MiscObligation);\n         }\n     }\n \n@@ -3901,8 +3882,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // All the input types from the fn signature must outlive the call\n         // so as to validate implied bounds.\n-        for (fn_input_ty, arg_expr) in fn_inputs.iter().zip(args.iter()) {\n-            self.register_wf_obligation(fn_input_ty, arg_expr.span, traits::MiscObligation);\n+        for (&fn_input_ty, arg_expr) in fn_inputs.iter().zip(args.iter()) {\n+            self.register_wf_obligation(fn_input_ty.into(), arg_expr.span, traits::MiscObligation);\n         }\n \n         let expected_arg_count = fn_inputs.len();"}, {"sha": "7d9bf975c6913c7d2e87102a9cbac8bb8637bfda", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -292,7 +292,7 @@ fn check_associated_item(\n             ty::AssocKind::Const => {\n                 let ty = fcx.tcx.type_of(item.def_id);\n                 let ty = fcx.normalize_associated_types_in(span, &ty);\n-                fcx.register_wf_obligation(ty, span, code.clone());\n+                fcx.register_wf_obligation(ty.into(), span, code.clone());\n             }\n             ty::AssocKind::Fn => {\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n@@ -313,7 +313,7 @@ fn check_associated_item(\n                 if item.defaultness.has_value() {\n                     let ty = fcx.tcx.type_of(item.def_id);\n                     let ty = fcx.normalize_associated_types_in(span, &ty);\n-                    fcx.register_wf_obligation(ty, span, code.clone());\n+                    fcx.register_wf_obligation(ty.into(), span, code.clone());\n                 }\n             }\n             ty::AssocKind::OpaqueTy => {\n@@ -406,7 +406,7 @@ fn check_type_defn<'tcx, F>(\n             // All field types must be well-formed.\n             for field in &variant.fields {\n                 fcx.register_wf_obligation(\n-                    field.ty,\n+                    field.ty.into(),\n                     field.span,\n                     ObligationCauseCode::MiscObligation,\n                 )\n@@ -601,7 +601,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n             }\n         }\n \n-        fcx.register_wf_obligation(item_ty, ty_span, ObligationCauseCode::MiscObligation);\n+        fcx.register_wf_obligation(item_ty.into(), ty_span, ObligationCauseCode::MiscObligation);\n         if forbid_unsized {\n             fcx.register_bound(\n                 item_ty,\n@@ -650,7 +650,7 @@ fn check_impl<'tcx>(\n                 let self_ty = fcx.tcx.type_of(item_def_id);\n                 let self_ty = fcx.normalize_associated_types_in(item.span, &self_ty);\n                 fcx.register_wf_obligation(\n-                    self_ty,\n+                    self_ty.into(),\n                     ast_self_ty.span,\n                     ObligationCauseCode::MiscObligation,\n                 );\n@@ -698,7 +698,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                 // be sure if it will error or not as user might always specify the other.\n                 if !ty.needs_subst() {\n                     fcx.register_wf_obligation(\n-                        ty,\n+                        ty.into(),\n                         fcx.tcx.def_span(param.def_id),\n                         ObligationCauseCode::MiscObligation,\n                     );\n@@ -841,13 +841,13 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     let sig = fcx.normalize_associated_types_in(span, &sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n \n-    for (input_ty, span) in sig.inputs().iter().zip(hir_sig.decl.inputs.iter().map(|t| t.span)) {\n-        fcx.register_wf_obligation(&input_ty, span, ObligationCauseCode::MiscObligation);\n+    for (&input_ty, span) in sig.inputs().iter().zip(hir_sig.decl.inputs.iter().map(|t| t.span)) {\n+        fcx.register_wf_obligation(input_ty.into(), span, ObligationCauseCode::MiscObligation);\n     }\n     implied_bounds.extend(sig.inputs());\n \n     fcx.register_wf_obligation(\n-        sig.output(),\n+        sig.output().into(),\n         hir_sig.decl.output.span(),\n         ObligationCauseCode::ReturnType,\n     );"}, {"sha": "e4bffedd620b99e2110a533acfb29ba528515a0c", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -332,12 +332,12 @@ fn check_predicates<'tcx>(\n         });\n \n     // Include the well-formed predicates of the type parameters of the impl.\n-    for ty in tcx.impl_trait_ref(impl1_def_id).unwrap().substs.types() {\n+    for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().substs {\n         if let Some(obligations) = wf::obligations(\n             infcx,\n             tcx.param_env(impl1_def_id),\n             tcx.hir().as_local_hir_id(impl1_def_id),\n-            ty,\n+            arg,\n             span,\n         ) {\n             impl2_predicates"}, {"sha": "b29d27e524751dd06023dfec1f09b9de2c7ecb7d", "filename": "src/test/ui/const-generics/cannot-infer-const-args.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -11,7 +11,9 @@ error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-const-args.rs:9:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for fn item `fn() -> usize {foo::<{_: usize}>}`\n+   |     ^^^\n+   |\n+   = note: unable to infer the value of a const parameter\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "cc671163e85a1388e2bf9bf2e07067194163344d", "filename": "src/test/ui/const-generics/issues/issue-61747.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -1,12 +1,11 @@\n-// check-pass\n-\n #![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete\n \n struct Const<const N: usize>;\n \n impl<const C: usize> Const<{C}> {\n     fn successor() -> Const<{C + 1}> {\n+        //~^ ERROR constant expression depends on a generic parameter\n         Const\n     }\n }"}, {"sha": "2685d9fdf167c93f8550745027f762c7982f054b", "filename": "src/test/ui/const-generics/issues/issue-61747.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.stderr?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -1,11 +1,19 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-61747.rs:3:12\n+  --> $DIR/issue-61747.rs:1:12\n    |\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n \n-warning: 1 warning emitted\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-61747.rs:7:23\n+   |\n+LL |     fn successor() -> Const<{C + 1}> {\n+   |                       ^^^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "0d42ff1895cdb109f47329284c4870fe8455e904", "filename": "src/test/ui/const-generics/issues/issue-61935.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -1,5 +1,3 @@\n-// check-pass\n-\n #![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete\n \n@@ -8,6 +6,7 @@ trait Foo {}\n impl<const N: usize> Foo for [(); N]\n     where\n         Self:FooImpl<{N==0}>\n+//~^ERROR constant expression depends on a generic parameter\n {}\n \n trait FooImpl<const IS_ZERO: bool>{}"}, {"sha": "a785af5f008ea739876541dea982df9a1336acd8", "filename": "src/test/ui/const-generics/issues/issue-61935.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.stderr?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -1,11 +1,19 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-61935.rs:3:12\n+  --> $DIR/issue-61935.rs:1:12\n    |\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n \n-warning: 1 warning emitted\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-61935.rs:8:14\n+   |\n+LL |         Self:FooImpl<{N==0}>\n+   |              ^^^^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "5c4a0d31a895d84d43b58a42cd9aebd9e1f7ae49", "filename": "src/test/ui/const-generics/issues/issue-62220.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62220.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62220.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62220.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -1,14 +1,14 @@\n-// build-pass\n #![allow(incomplete_features)]\n-\n #![feature(const_generics)]\n+\n pub struct Vector<T, const N: usize>([T; N]);\n \n pub type TruncatedVector<T, const N: usize> = Vector<T, { N - 1 }>;\n \n impl<T, const N: usize> Vector<T, { N }> {\n     /// Drop the last component and return the vector with one fewer dimension.\n     pub fn trunc(self) -> (TruncatedVector<T, { N }>, T) {\n+        //~^ ERROR constant expression depends on a generic parameter\n         unimplemented!()\n     }\n }"}, {"sha": "d91d2bb326fc57d1b5d8555da64f74bc5707acd6", "filename": "src/test/ui/const-generics/issues/issue-62220.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62220.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62220.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62220.stderr?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -0,0 +1,10 @@\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-62220.rs:10:27\n+   |\n+LL |     pub fn trunc(self) -> (TruncatedVector<T, { N }>, T) {\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to previous error\n+"}, {"sha": "7cedf51ca040493f1e00193f42658724e2d203fd", "filename": "src/test/ui/const-generics/issues/issue-66205.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -1,6 +1,6 @@\n-#![allow(incomplete_features, dead_code, unconditional_recursion)]\n+#![allow(dead_code, unconditional_recursion)]\n #![feature(const_generics)]\n-#![feature(lazy_normalization_consts)]\n+//~^ WARN the feature `const_generics` is incomplete\n \n fn fact<const N: usize>() {\n     fact::<{ N - 1 }>();"}, {"sha": "1e9c0f2f3d9eb175e34479b6936157180decaf88", "filename": "src/test/ui/const-generics/issues/issue-66205.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.stderr?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -1,3 +1,12 @@\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-66205.rs:2:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n error: constant expression depends on a generic parameter\n   --> $DIR/issue-66205.rs:6:12\n    |\n@@ -6,5 +15,5 @@ LL |     fact::<{ N - 1 }>();\n    |\n    = note: this may fail depending on what value the parameter takes\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "346ea3c2042449b040162db87af87a4cd6322081", "filename": "src/test/ui/const-generics/issues/issue-68977.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68977.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68977.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68977.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -0,0 +1,40 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete\n+\n+struct PhantomU8<const X: u8>;\n+\n+trait FxpStorage {\n+    type SInt; // Add arithmetic traits as needed.\n+}\n+\n+macro_rules! fxp_storage_impls {\n+    ($($($n:literal)|+ => $sint:ty),* $(,)?) => {\n+        $($(impl FxpStorage for PhantomU8<$n> {\n+            type SInt = $sint;\n+        })*)*\n+    }\n+}\n+\n+fxp_storage_impls! {\n+    1 => i8,\n+    2 => i16,\n+    3 | 4 => i32,\n+    5 | 6 | 7 | 8 => i64,\n+    9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 => i128,\n+}\n+\n+type FxpStorageHelper<const INT_BITS: u8, const FRAC_BITS: u8> =\n+    PhantomU8<{(INT_BITS + FRAC_BITS + 7) / 8}>;\n+\n+struct Fxp<const INT_BITS: u8, const FRAC_BITS: u8>\n+where\n+    FxpStorageHelper<INT_BITS, FRAC_BITS>: FxpStorage,\n+    //~^ ERROR constant expression depends on a generic parameter\n+{\n+    storage: <FxpStorageHelper<INT_BITS, FRAC_BITS> as FxpStorage>::SInt,\n+}\n+\n+fn main() {\n+    Fxp::<1, 15> { storage: 0i16 };\n+    Fxp::<2, 15> { storage: 0i32 };\n+}"}, {"sha": "e1190d9026da9d70fee5fe87b5b276667b4d936e", "filename": "src/test/ui/const-generics/issues/issue-68977.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68977.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68977.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68977.stderr?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -0,0 +1,19 @@\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-68977.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-68977.rs:31:44\n+   |\n+LL |     FxpStorageHelper<INT_BITS, FRAC_BITS>: FxpStorage,\n+   |                                            ^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "0d392ddcaedcc4f4a109d0b035e34830e605ed5e", "filename": "src/test/ui/const-generics/lazy-normalization/issue-71922.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -1,9 +1,9 @@\n-// run-pass\n #![feature(const_generics)]\n-#![allow(incomplete_features)]\n+//~^ WARN the feature `const_generics` is incomplete\n trait Foo {}\n \n impl<const N: usize> Foo for [(); N] where Self: FooImpl<{ N == 0 }> {}\n+//~^ ERROR constant expression depends on a generic parameter\n \n trait FooImpl<const IS_ZERO: bool> {}\n "}, {"sha": "00917571e716d8bf1bc21c84da6ab89c21f9e37c", "filename": "src/test/ui/const-generics/lazy-normalization/issue-71922.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.stderr?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -0,0 +1,19 @@\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-71922.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-71922.rs:5:50\n+   |\n+LL | impl<const N: usize> Foo for [(); N] where Self: FooImpl<{ N == 0 }> {}\n+   |                                                  ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "4ff1b9e2da5b24a5a4327884538260d1633e032a", "filename": "src/test/ui/const-generics/wf-misc.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fwf-misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fwf-misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fwf-misc.rs?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -0,0 +1,16 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete\n+\n+pub fn arr_len<const N: usize>() {\n+    let _: [u8; N + 1];\n+    //~^ ERROR constant expression depends on a generic parameter\n+}\n+\n+struct Const<const N: usize>;\n+\n+pub fn func_call<const N: usize>() {\n+    let _: Const::<{N + 1}>;\n+    //~^ ERROR constant expression depends on a generic parameter\n+}\n+\n+fn main() {}"}, {"sha": "03f2bf3f526994e57fcb58ec6b51f6ff730b0f92", "filename": "src/test/ui/const-generics/wf-misc.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fwf-misc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff4aff6ce0f216c8cb8d40f432efaacdaca8095b/src%2Ftest%2Fui%2Fconst-generics%2Fwf-misc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fwf-misc.stderr?ref=ff4aff6ce0f216c8cb8d40f432efaacdaca8095b", "patch": "@@ -0,0 +1,27 @@\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/wf-misc.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/wf-misc.rs:5:12\n+   |\n+LL |     let _: [u8; N + 1];\n+   |            ^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/wf-misc.rs:12:12\n+   |\n+LL |     let _: Const::<{N + 1}>;\n+   |            ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+"}]}