{"sha": "c546f1b396f7bfad89f30d9f595baa589a99a4fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NDZmMWIzOTZmN2JmYWQ4OWYzMGQ5ZjU5NWJhYTU4OWE5OWE0ZmU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-05-01T22:40:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-01T22:40:31Z"}, "message": "Merge pull request #1454 from topecongiro/match\n\nFormat nested mathces properly.", "tree": {"sha": "e9a133019228582f6cc5bda456f4f352ae48daeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9a133019228582f6cc5bda456f4f352ae48daeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c546f1b396f7bfad89f30d9f595baa589a99a4fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c546f1b396f7bfad89f30d9f595baa589a99a4fe", "html_url": "https://github.com/rust-lang/rust/commit/c546f1b396f7bfad89f30d9f595baa589a99a4fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c546f1b396f7bfad89f30d9f595baa589a99a4fe/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2223b64f8631898358934197263c692a0d308729", "url": "https://api.github.com/repos/rust-lang/rust/commits/2223b64f8631898358934197263c692a0d308729", "html_url": "https://github.com/rust-lang/rust/commit/2223b64f8631898358934197263c692a0d308729"}, {"sha": "3d2cd681ae76d0c1444238d54384e1d3cb3d35fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d2cd681ae76d0c1444238d54384e1d3cb3d35fc", "html_url": "https://github.com/rust-lang/rust/commit/3d2cd681ae76d0c1444238d54384e1d3cb3d35fc"}], "stats": {"total": 271, "additions": 219, "deletions": 52}, "files": [{"sha": "8e176fce72418432aaa2b763f6e145d371114988", "filename": "src/chains.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=c546f1b396f7bfad89f30d9f595baa589a99a4fe", "patch": "@@ -200,12 +200,18 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         if fits_single_line {\n             fits_single_line = match expr.node {\n                 ref e @ ast::ExprKind::MethodCall(..) => {\n-                    rewrite_method_call_with_overflow(e,\n-                                                      &mut last[0],\n-                                                      almost_total,\n-                                                      total_span,\n-                                                      context,\n-                                                      shape)\n+                    if rewrite_method_call_with_overflow(e,\n+                                                         &mut last[0],\n+                                                         almost_total,\n+                                                         total_span,\n+                                                         context,\n+                                                         shape) {\n+                        // If the first line of the last method does not fit into a single line\n+                        // after the others, allow new lines.\n+                        almost_total + first_line_width(&last[0]) < context.config.max_width\n+                    } else {\n+                        false\n+                    }\n                 }\n                 _ => !last[0].contains('\\n'),\n             }"}, {"sha": "381ab7ca9604fcc76ceefde5f7cc265c150eafb9", "filename": "src/expr.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c546f1b396f7bfad89f30d9f595baa589a99a4fe", "patch": "@@ -176,9 +176,8 @@ fn format_expr(expr: &ast::Expr,\n         ast::ExprKind::Mac(ref mac) => {\n             // Failure to rewrite a marco should not imply failure to\n             // rewrite the expression.\n-            rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n-                wrap_str(context.snippet(expr.span), context.config.max_width, shape)\n-            })\n+            rewrite_macro(mac, None, context, shape, MacroPosition::Expression)\n+                .or_else(|| wrap_str(context.snippet(expr.span), context.config.max_width, shape))\n         }\n         ast::ExprKind::Ret(None) => wrap_str(\"return\".to_owned(), context.config.max_width, shape),\n         ast::ExprKind::Ret(Some(ref expr)) => {\n@@ -582,14 +581,18 @@ fn rewrite_closure(capture: ast::CaptureBy,\n \n         let block_threshold = context.config.closure_block_indent_threshold;\n         if block_threshold < 0 || rewrite.matches('\\n').count() <= block_threshold as usize {\n-            return Some(format!(\"{} {}\", prefix, rewrite));\n+            if let Some(rewrite) = wrap_str(rewrite, context.config.max_width, shape) {\n+                return Some(format!(\"{} {}\", prefix, rewrite));\n+            }\n         }\n \n         // The body of the closure is big enough to be block indented, that\n         // means we must re-format.\n         let block_shape = shape.block();\n         let rewrite = try_opt!(block.rewrite(&context, block_shape));\n-        Some(format!(\"{} {}\", prefix, rewrite))\n+        Some(format!(\"{} {}\",\n+                     prefix,\n+                     try_opt!(wrap_str(rewrite, block_shape.width, block_shape))))\n     }\n }\n \n@@ -1341,11 +1344,10 @@ impl Rewrite for ast::Arm {\n         // 4 = ` => `.len()\n         if shape.width > pat_width + comma.len() + 4 {\n             let arm_shape = shape\n-                .shrink_left(pat_width + 4)\n+                .offset_left(pat_width + 4)\n                 .unwrap()\n                 .sub_width(comma.len())\n-                .unwrap()\n-                .block();\n+                .unwrap();\n             let rewrite = nop_block_collapse(body.rewrite(context, arm_shape), arm_shape.width);\n             let is_block = if let ast::ExprKind::Block(..) = body.node {\n                 true"}, {"sha": "f11a0aaf6e28bda259bd6aedc84f4a04e5233ddd", "filename": "src/file_lines.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=c546f1b396f7bfad89f30d9f595baa589a99a4fe", "patch": "@@ -194,9 +194,8 @@ impl JsonSpan {\n     // To allow `collect()`ing into a `MultiMap`.\n     fn into_tuple(self) -> Result<(String, Range), String> {\n         let (lo, hi) = self.range;\n-        let canonical = try!(canonicalize_path_string(&self.file).map_err(|_| {\n-            format!(\"Can't canonicalize {}\", &self.file)\n-        }));\n+        let canonical = try!(canonicalize_path_string(&self.file)\n+                                 .map_err(|_| format!(\"Can't canonicalize {}\", &self.file)));\n         Ok((canonical, Range::new(lo, hi)))\n     }\n }"}, {"sha": "66040362d52e2894995e67147684db8b7cfd0034", "filename": "src/items.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=c546f1b396f7bfad89f30d9f595baa589a99a4fe", "patch": "@@ -1300,12 +1300,13 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n \n     let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n         let bounds: &[_] = ty_param_bounds;\n-        let bound_str = try_opt!(bounds.iter()\n-            .map(|ty_bound| {\n-                ty_bound.rewrite(context, Shape::legacy(context.config.max_width, indent))\n-            })\n-            .intersperse(Some(\" + \".to_string()))\n-            .collect::<Option<String>>());\n+        let bound_str = try_opt!(bounds\n+                                     .iter()\n+                                     .map(|ty_bound| {\n+            ty_bound.rewrite(context, Shape::legacy(context.config.max_width, indent))\n+        })\n+                                     .intersperse(Some(\" + \".to_string()))\n+                                     .collect::<Option<String>>());\n         if bounds.len() > 0 {\n             format!(\": {}\", bound_str)\n         } else {"}, {"sha": "cd3e638d97cfd2a42c4dea2b6ee624b57eba66d2", "filename": "src/macros.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=c546f1b396f7bfad89f30d9f595baa589a99a4fe", "patch": "@@ -146,12 +146,11 @@ pub fn rewrite_macro(mac: &ast::Mac,\n         MacroStyle::Parens => {\n             // Format macro invocation as function call, forcing no trailing\n             // comma because not all macros support them.\n-            rewrite_call(context, &macro_name, &expr_vec, mac.span, shape, true).map(|rw| {\n-                match position {\n-                    MacroPosition::Item => format!(\"{};\", rw),\n-                    _ => rw,\n-                }\n-            })\n+            rewrite_call(context, &macro_name, &expr_vec, mac.span, shape, true)\n+                .map(|rw| match position {\n+                         MacroPosition::Item => format!(\"{};\", rw),\n+                         _ => rw,\n+                     })\n         }\n         MacroStyle::Brackets => {\n             // Format macro invocation as array literal."}, {"sha": "c0a40720fc3ced9a53742022ff4c5206a90481c7", "filename": "src/types.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c546f1b396f7bfad89f30d9f595baa589a99a4fe/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=c546f1b396f7bfad89f30d9f595baa589a99a4fe", "patch": "@@ -587,31 +587,34 @@ impl Rewrite for ast::Ty {\n                 let mut_len = mut_str.len();\n                 Some(match *lifetime {\n                          Some(ref lifetime) => {\n-                    let lt_budget = try_opt!(shape.width.checked_sub(2 + mut_len));\n-                    let lt_str = try_opt!(lifetime.rewrite(context,\n-                                                           Shape::legacy(lt_budget,\n+                             let lt_budget = try_opt!(shape.width.checked_sub(2 + mut_len));\n+                             let lt_str = try_opt!(lifetime.rewrite(context,\n+                                                                    Shape::legacy(lt_budget,\n+                                                                                  shape.indent +\n+                                                                                  2 +\n+                                                                                  mut_len)));\n+                             let lt_len = lt_str.len();\n+                             let budget = try_opt!(shape.width.checked_sub(2 + mut_len + lt_len));\n+                             format!(\"&{} {}{}\",\n+                                     lt_str,\n+                                     mut_str,\n+                                     try_opt!(mt.ty\n+                                                  .rewrite(context,\n+                                                           Shape::legacy(budget,\n                                                                          shape.indent + 2 +\n-                                                                         mut_len)));\n-                    let lt_len = lt_str.len();\n-                    let budget = try_opt!(shape.width.checked_sub(2 + mut_len + lt_len));\n-                    format!(\"&{} {}{}\",\n-                            lt_str,\n-                            mut_str,\n-                            try_opt!(mt.ty\n-                                         .rewrite(context,\n-                                                  Shape::legacy(budget,\n-                                                                shape.indent + 2 + mut_len +\n-                                                                lt_len))))\n-                }\n+                                                                         mut_len +\n+                                                                         lt_len))))\n+                         }\n                          None => {\n-                    let budget = try_opt!(shape.width.checked_sub(1 + mut_len));\n-                    format!(\"&{}{}\",\n-                            mut_str,\n-                            try_opt!(mt.ty\n-                                         .rewrite(context,\n-                                                  Shape::legacy(budget,\n-                                                                shape.indent + 1 + mut_len))))\n-                }\n+                             let budget = try_opt!(shape.width.checked_sub(1 + mut_len));\n+                             format!(\"&{}{}\",\n+                                     mut_str,\n+                                     try_opt!(mt.ty\n+                                                  .rewrite(context,\n+                                                           Shape::legacy(budget,\n+                                                                         shape.indent + 1 +\n+                                                                         mut_len))))\n+                         }\n                      })\n             }\n             // FIXME: we drop any comments here, even though it's a silly place to put"}, {"sha": "43b0b033ea6d3fbbde9739104eae303beda95319", "filename": "tests/source/match.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c546f1b396f7bfad89f30d9f595baa589a99a4fe/tests%2Fsource%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c546f1b396f7bfad89f30d9f595baa589a99a4fe/tests%2Fsource%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmatch.rs?ref=c546f1b396f7bfad89f30d9f595baa589a99a4fe", "patch": "@@ -295,3 +295,81 @@ fn guards() {\n                (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb || cccccccccccccccccccccccccccccccccccccccc) => {}\n     }\n }\n+\n+fn issue1371() {\n+    Some(match type_ {\n+        sfEvtClosed => Closed,\n+        sfEvtResized => {\n+            let e = unsafe { *event.size.as_ref() };\n+\n+            Resized {\n+                width: e.width,\n+                height: e.height,\n+            }\n+        }\n+        sfEvtLostFocus => LostFocus,\n+        sfEvtGainedFocus => GainedFocus,\n+        sfEvtTextEntered => {\n+            TextEntered {\n+                unicode: unsafe {\n+                    ::std::char::from_u32((*event.text.as_ref()).unicode)\n+                        .expect(\"Invalid unicode encountered on TextEntered event\")\n+                },\n+            }\n+        }\n+        sfEvtKeyPressed => {\n+            let e = unsafe { event.key.as_ref() };\n+\n+            KeyPressed {\n+                code: unsafe { ::std::mem::transmute(e.code) },\n+                alt: e.alt.to_bool(),\n+                ctrl: e.control.to_bool(),\n+                shift: e.shift.to_bool(),\n+                system: e.system.to_bool(),\n+            }\n+        }\n+        sfEvtKeyReleased => {\n+            let e = unsafe { event.key.as_ref() };\n+\n+            KeyReleased {\n+                code: unsafe { ::std::mem::transmute(e.code) },\n+                alt: e.alt.to_bool(),\n+                ctrl: e.control.to_bool(),\n+                shift: e.shift.to_bool(),\n+                system: e.system.to_bool(),\n+            }\n+        }\n+    })\n+}\n+\n+fn issue1395() {\n+    let bar = Some(true);\n+    let foo = Some(true);\n+    let mut x = false;\n+    bar.and_then(|_| {\n+        match foo {\n+            None => None,\n+            Some(b) => {\n+                x = true;\n+                Some(b)\n+            }\n+        }\n+    });\n+}\n+\n+fn issue1456() {\n+    Ok(Recording {\n+        artists: match reader.evaluate(\".//mb:recording/mb:artist-credit/mb:name-credit\")? {\n+            Nodeset(nodeset) => {\n+                let res: Result<Vec<ArtistRef>, ReadError> = nodeset\n+                    .iter()\n+                    .map(|node| {\n+                        XPathNodeReader::new(node, &context).and_then(|r| ArtistRef::from_xml(&r))\n+                    })\n+                    .collect();\n+                res?\n+            }\n+            _ => Vec::new(),\n+        },\n+    })\n+}"}, {"sha": "0da943d28f78d9ba2aa5d40438d1345366b39133", "filename": "tests/target/match.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c546f1b396f7bfad89f30d9f595baa589a99a4fe/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c546f1b396f7bfad89f30d9f595baa589a99a4fe/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=c546f1b396f7bfad89f30d9f595baa589a99a4fe", "patch": "@@ -310,3 +310,82 @@ fn guards() {\n                 cccccccccccccccccccccccccccccccccccccccc) => {}\n     }\n }\n+\n+fn issue1371() {\n+    Some(match type_ {\n+             sfEvtClosed => Closed,\n+             sfEvtResized => {\n+                 let e = unsafe { *event.size.as_ref() };\n+\n+                 Resized {\n+                     width: e.width,\n+                     height: e.height,\n+                 }\n+             }\n+             sfEvtLostFocus => LostFocus,\n+             sfEvtGainedFocus => GainedFocus,\n+             sfEvtTextEntered => {\n+                 TextEntered {\n+                     unicode:\n+                         unsafe {\n+                             ::std::char::from_u32((*event.text.as_ref()).unicode)\n+                                 .expect(\"Invalid unicode encountered on TextEntered event\")\n+                         },\n+                 }\n+             }\n+             sfEvtKeyPressed => {\n+                 let e = unsafe { event.key.as_ref() };\n+\n+                 KeyPressed {\n+                     code: unsafe { ::std::mem::transmute(e.code) },\n+                     alt: e.alt.to_bool(),\n+                     ctrl: e.control.to_bool(),\n+                     shift: e.shift.to_bool(),\n+                     system: e.system.to_bool(),\n+                 }\n+             }\n+             sfEvtKeyReleased => {\n+                 let e = unsafe { event.key.as_ref() };\n+\n+                 KeyReleased {\n+                     code: unsafe { ::std::mem::transmute(e.code) },\n+                     alt: e.alt.to_bool(),\n+                     ctrl: e.control.to_bool(),\n+                     shift: e.shift.to_bool(),\n+                     system: e.system.to_bool(),\n+                 }\n+             }\n+         })\n+}\n+\n+fn issue1395() {\n+    let bar = Some(true);\n+    let foo = Some(true);\n+    let mut x = false;\n+    bar.and_then(|_| match foo {\n+                     None => None,\n+                     Some(b) => {\n+                         x = true;\n+                         Some(b)\n+                     }\n+                 });\n+}\n+\n+fn issue1456() {\n+    Ok(Recording {\n+           artists: match reader\n+                     .evaluate(\".//mb:recording/mb:artist-credit/mb:name-credit\")? {\n+               Nodeset(nodeset) => {\n+                   let res: Result<Vec<ArtistRef>, ReadError> = nodeset\n+                       .iter()\n+                       .map(|node| {\n+                                XPathNodeReader::new(node, &context)\n+                                    .and_then(|r| ArtistRef::from_xml(&r))\n+                            })\n+                       .collect();\n+                   res?\n+               }\n+               _ => Vec::new(),\n+           },\n+       })\n+}"}]}