{"sha": "e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YmFkZmQ0NDlmYTUwMWM0NTY1ZjkzYTFkOGZhZWU5ZDlkNmM4ZGY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-28T09:58:45Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-02T13:45:46Z"}, "message": "incr.comp.: Use red/green tracking for CGU re-use.", "tree": {"sha": "7814a4d75752018e1c34c0088d3370a0a68082da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7814a4d75752018e1c34c0088d3370a0a68082da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "html_url": "https://github.com/rust-lang/rust/commit/e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9a17ef174522ebbc75e7dfa6a50d73d1b610fee", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9a17ef174522ebbc75e7dfa6a50d73d1b610fee", "html_url": "https://github.com/rust-lang/rust/commit/c9a17ef174522ebbc75e7dfa6a50d73d1b610fee"}], "stats": {"total": 452, "additions": 206, "deletions": 246}, "files": [{"sha": "cc15922bc2ea83e20cc57b9fa172cf5ad6ef9461", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 50, "deletions": 19, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -67,6 +67,15 @@ pub enum DepNodeColor {\n     Green(DepNodeIndex)\n }\n \n+impl DepNodeColor {\n+    pub fn is_green(self) -> bool {\n+        match self {\n+            DepNodeColor::Red => false,\n+            DepNodeColor::Green(_) => true,\n+        }\n+    }\n+}\n+\n struct DepGraphData {\n     /// The old, initial encoding of the dependency graph. This will soon go\n     /// away.\n@@ -94,6 +103,9 @@ struct DepGraphData {\n     work_products: RefCell<FxHashMap<WorkProductId, WorkProduct>>,\n \n     dep_node_debug: RefCell<FxHashMap<DepNode, String>>,\n+\n+    // Used for testing, only populated when -Zquery-dep-graph is specified.\n+    loaded_from_cache: RefCell<FxHashMap<DepNodeIndexNew, bool>>,\n }\n \n impl DepGraph {\n@@ -108,6 +120,7 @@ impl DepGraph {\n                 current: RefCell::new(CurrentDepGraph::new()),\n                 previous: prev_graph,\n                 colors: RefCell::new(FxHashMap()),\n+                loaded_from_cache: RefCell::new(FxHashMap()),\n             })),\n             fingerprints: Rc::new(RefCell::new(FxHashMap())),\n         }\n@@ -256,16 +269,9 @@ impl DepGraph {\n             data.current.borrow_mut().push_anon_task();\n             let result = op();\n             let dep_node_index_legacy = data.edges.borrow_mut().pop_anon_task(dep_kind);\n-            let (new_dep_node, dep_node_index_new) = data.current\n-                                                         .borrow_mut()\n-                                                         .pop_anon_task(dep_kind);\n-            if let Some(new_dep_node) = new_dep_node {\n-                assert!(data.colors\n-                            .borrow_mut()\n-                            .insert(new_dep_node, DepNodeColor::Red)\n-                            .is_none());\n-            }\n-\n+            let dep_node_index_new = data.current\n+                                         .borrow_mut()\n+                                         .pop_anon_task(dep_kind);\n             (result, DepNodeIndex {\n                 legacy: dep_node_index_legacy,\n                 new: dep_node_index_new,\n@@ -594,6 +600,25 @@ impl DepGraph {\n             }\n         }).unwrap_or(false)\n     }\n+\n+    pub fn mark_loaded_from_cache(&self, dep_node: DepNodeIndex, state: bool) {\n+        debug!(\"mark_loaded_from_cache({:?}, {})\",\n+               self.data.as_ref().unwrap().current.borrow().nodes[dep_node.new],\n+               state);\n+\n+        self.data\n+            .as_ref()\n+            .unwrap()\n+            .loaded_from_cache\n+            .borrow_mut()\n+            .insert(dep_node.new, state);\n+    }\n+\n+    pub fn was_loaded_from_cache(&self, dep_node: &DepNode) -> Option<bool> {\n+        let data = self.data.as_ref().unwrap();\n+        let dep_node_index = data.current.borrow().node_to_node_index[dep_node];\n+        data.loaded_from_cache.borrow().get(&dep_node_index).cloned()\n+    }\n }\n \n /// A \"work product\" is an intermediate result that we save into the\n@@ -630,11 +655,6 @@ impl DepGraph {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct WorkProduct {\n     pub cgu_name: String,\n-    /// Extra hash used to decide if work-product is still suitable;\n-    /// note that this is *not* a hash of the work-product itself.\n-    /// See documentation on `WorkProduct` type for an example.\n-    pub input_hash: u64,\n-\n     /// Saved files associated with this CGU\n     pub saved_files: Vec<(OutputType, String)>,\n }\n@@ -644,15 +664,26 @@ pub(super) struct CurrentDepGraph {\n     edges: IndexVec<DepNodeIndexNew, Vec<DepNodeIndexNew>>,\n     node_to_node_index: FxHashMap<DepNode, DepNodeIndexNew>,\n \n+    anon_id_seed: Fingerprint,\n+\n     task_stack: Vec<OpenTask>,\n }\n \n impl CurrentDepGraph {\n     fn new() -> CurrentDepGraph {\n+        use std::time::{SystemTime, UNIX_EPOCH};\n+\n+        let duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n+        let nanos = duration.as_secs() * 1_000_000_000 +\n+                    duration.subsec_nanos() as u64;\n+        let mut stable_hasher = StableHasher::new();\n+        nanos.hash(&mut stable_hasher);\n+\n         CurrentDepGraph {\n             nodes: IndexVec::new(),\n             edges: IndexVec::new(),\n             node_to_node_index: FxHashMap(),\n+            anon_id_seed: stable_hasher.finish(),\n             task_stack: Vec::new(),\n         }\n     }\n@@ -696,14 +727,14 @@ impl CurrentDepGraph {\n         });\n     }\n \n-    fn pop_anon_task(&mut self, kind: DepKind) -> (Option<DepNode>, DepNodeIndexNew) {\n+    fn pop_anon_task(&mut self, kind: DepKind) -> DepNodeIndexNew {\n         let popped_node = self.task_stack.pop().unwrap();\n \n         if let OpenTask::Anon {\n             read_set: _,\n             reads\n         } = popped_node {\n-            let mut fingerprint = Fingerprint::zero();\n+            let mut fingerprint = self.anon_id_seed;\n             let mut hasher = StableHasher::new();\n \n             for &read in reads.iter() {\n@@ -725,9 +756,9 @@ impl CurrentDepGraph {\n             };\n \n             if let Some(&index) = self.node_to_node_index.get(&target_dep_node) {\n-                (None, index)\n+                index\n             } else {\n-                (Some(target_dep_node), self.alloc_node(target_dep_node, reads))\n+                self.alloc_node(target_dep_node, reads)\n             }\n         } else {\n             bug!(\"pop_anon_task() - Expected anonymous task to be popped\")"}, {"sha": "d65fbb8f6cfb4550e5d1d1d48e637223f6162a04", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -320,6 +320,10 @@ macro_rules! define_maps {\n                                                                         dep_node_index)\n                     }\n \n+                    debug!(\"ty::queries::{}::try_get_with(key={:?}) - running try_mark_green\",\n+                           stringify!($name),\n+                           key);\n+\n                     if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, &dep_node) {\n                         debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n                         profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n@@ -363,6 +367,10 @@ macro_rules! define_maps {\n                     })\n                 })?;\n \n+                if tcx.sess.opts.debugging_opts.query_dep_graph {\n+                    tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n+                }\n+\n                 let value = QueryValue::new(result, dep_node_index, diagnostics);\n \n                 Ok((&tcx.maps\n@@ -394,6 +402,10 @@ macro_rules! define_maps {\n \n                 let ((result, dep_node_index), diagnostics) = res;\n \n+                if tcx.sess.opts.debugging_opts.query_dep_graph {\n+                    tcx.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n+                }\n+\n                 let value = QueryValue::new(result, dep_node_index, diagnostics);\n \n                 Ok(((&tcx.maps\n@@ -406,8 +418,6 @@ macro_rules! define_maps {\n                    dep_node_index))\n             }\n \n-\n-\n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n                            -> Result<$V, DiagnosticBuilder<'a>> {\n                 match Self::try_get_with(tcx, span, key) {"}, {"sha": "f04b9bd925c0d44f7b7c1e205b677db6acb023bd", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -39,3 +39,4 @@ pub use persist::save_work_products;\n pub use persist::in_incr_comp_dir;\n pub use persist::prepare_session_directory;\n pub use persist::finalize_session_directory;\n+pub use persist::delete_workproduct_files;"}, {"sha": "0388d950cdf324c553930475c19a6260115aa63c", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -99,6 +99,7 @@ fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n /// variants that represent inputs (HIR and imported Metadata).\n fn does_still_exist(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n     match dep_node.kind {\n+        DepKind::Krate |\n         DepKind::Hir |\n         DepKind::HirBody |\n         DepKind::InScopeTraits |\n@@ -258,33 +259,28 @@ fn transitive_dirty_nodes(serialized_dep_graph: &SerializedDepGraph,\n /// otherwise no longer applicable.\n fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      work_products: Vec<SerializedWorkProduct>,\n-                                     clean_work_products: &FxHashSet<WorkProductId>) {\n+                                     _clean_work_products: &FxHashSet<WorkProductId>) {\n     debug!(\"reconcile_work_products({:?})\", work_products);\n     for swp in work_products {\n-        if !clean_work_products.contains(&swp.id) {\n-            debug!(\"reconcile_work_products: dep-node for {:?} is dirty\", swp);\n-            delete_dirty_work_product(tcx, swp);\n-        } else {\n-            let mut all_files_exist = true;\n-            for &(_, ref file_name) in swp.work_product.saved_files.iter() {\n-                let path = in_incr_comp_dir_sess(tcx.sess, file_name);\n-                if !path.exists() {\n-                    all_files_exist = false;\n-\n-                    if tcx.sess.opts.debugging_opts.incremental_info {\n-                        eprintln!(\"incremental: could not find file for \\\n-                                   up-to-date work product: {}\", path.display());\n-                    }\n+        let mut all_files_exist = true;\n+        for &(_, ref file_name) in swp.work_product.saved_files.iter() {\n+            let path = in_incr_comp_dir_sess(tcx.sess, file_name);\n+            if !path.exists() {\n+                all_files_exist = false;\n+\n+                if tcx.sess.opts.debugging_opts.incremental_info {\n+                    eprintln!(\"incremental: could not find file for \\\n+                               up-to-date work product: {}\", path.display());\n                 }\n             }\n+        }\n \n-            if all_files_exist {\n-                debug!(\"reconcile_work_products: all files for {:?} exist\", swp);\n-                tcx.dep_graph.insert_previous_work_product(&swp.id, swp.work_product);\n-            } else {\n-                debug!(\"reconcile_work_products: some file for {:?} does not exist\", swp);\n-                delete_dirty_work_product(tcx, swp);\n-            }\n+        if all_files_exist {\n+            debug!(\"reconcile_work_products: all files for {:?} exist\", swp);\n+            tcx.dep_graph.insert_previous_work_product(&swp.id, swp.work_product);\n+        } else {\n+            debug!(\"reconcile_work_products: some file for {:?} does not exist\", swp);\n+            delete_dirty_work_product(tcx, swp);\n         }\n     }\n }"}, {"sha": "0d81a1865665d5bdf3eb84767f0be1b0c0178529", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -29,3 +29,4 @@ pub use self::load::load_dep_graph_new;\n pub use self::save::save_dep_graph;\n pub use self::save::save_work_products;\n pub use self::work_product::save_trans_partition;\n+pub use self::work_product::delete_workproduct_files;"}, {"sha": "9865e8fb1734a08bd1ce14731709af9e987642bf", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -21,11 +21,9 @@ use std::fs as std_fs;\n pub fn save_trans_partition(sess: &Session,\n                             dep_graph: &DepGraph,\n                             cgu_name: &str,\n-                            partition_hash: u64,\n                             files: &[(OutputType, PathBuf)]) {\n-    debug!(\"save_trans_partition({:?},{},{:?})\",\n+    debug!(\"save_trans_partition({:?},{:?})\",\n            cgu_name,\n-           partition_hash,\n            files);\n     if sess.opts.incremental.is_none() {\n         return;\n@@ -57,7 +55,6 @@ pub fn save_trans_partition(sess: &Session,\n \n     let work_product = WorkProduct {\n         cgu_name: cgu_name.to_string(),\n-        input_hash: partition_hash,\n         saved_files,\n     };\n "}, {"sha": "c891bd8aaf44f06d499dc68bbe2c51e769ad37fd", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 28, "deletions": 44, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -27,47 +27,32 @@\n //! the HIR doesn't change as a result of the annotations, which might\n //! perturb the reuse results.\n \n+use rustc::dep_graph::{DepNode, DepConstructor};\n use rustc::ty::TyCtxt;\n use syntax::ast;\n-\n-use {ModuleSource, ModuleTranslation};\n-\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_TRANSLATED};\n \n const MODULE: &'static str = \"module\";\n const CFG: &'static str = \"cfg\";\n \n #[derive(Debug, PartialEq, Clone, Copy)]\n-pub enum Disposition { Reused, Translated }\n-\n-impl ModuleTranslation {\n-    pub fn disposition(&self) -> (String, Disposition) {\n-        let disposition = match self.source {\n-            ModuleSource::Preexisting(_) => Disposition::Reused,\n-            ModuleSource::Translated(_) => Disposition::Translated,\n-        };\n+enum Disposition { Reused, Translated }\n \n-        (self.name.clone(), disposition)\n-    }\n-}\n-\n-pub(crate) fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                              modules: &[(String, Disposition)]) {\n+pub(crate) fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if tcx.sess.opts.incremental.is_none() {\n         return;\n     }\n \n-    let ams = AssertModuleSource { tcx: tcx, modules: modules };\n+    let ams = AssertModuleSource { tcx };\n     for attr in &tcx.hir.krate().attrs {\n         ams.check_attr(attr);\n     }\n }\n \n struct AssertModuleSource<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    modules: &'a [(String, Disposition)],\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n@@ -86,32 +71,31 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         }\n \n         let mname = self.field(attr, MODULE);\n-        let mtrans = self.modules.iter().find(|&&(ref name, _)| name == mname.as_str());\n-        let mtrans = match mtrans {\n-            Some(m) => m,\n-            None => {\n-                debug!(\"module name `{}` not found amongst:\", mname);\n-                for &(ref name, ref disposition) in self.modules {\n-                    debug!(\"module named `{}` with disposition {:?}\",\n-                           name,\n-                           disposition);\n-                }\n \n-                self.tcx.sess.span_err(\n-                    attr.span,\n-                    &format!(\"no module named `{}`\", mname));\n-                return;\n-            }\n-        };\n+        let dep_node = DepNode::new(self.tcx,\n+                                    DepConstructor::CompileCodegenUnit(mname.as_str()));\n \n-        let mtrans_disposition = mtrans.1;\n-        if disposition != mtrans_disposition {\n-            self.tcx.sess.span_err(\n-                attr.span,\n-                &format!(\"expected module named `{}` to be {:?} but is {:?}\",\n-                         mname,\n-                         disposition,\n-                         mtrans_disposition));\n+        if let Some(loaded_from_cache) = self.tcx.dep_graph.was_loaded_from_cache(&dep_node) {\n+            match (disposition, loaded_from_cache) {\n+                (Disposition::Reused, false) => {\n+                    self.tcx.sess.span_err(\n+                        attr.span,\n+                        &format!(\"expected module named `{}` to be Reused but is Translated\",\n+                                 mname));\n+                }\n+                (Disposition::Translated, true) => {\n+                    self.tcx.sess.span_err(\n+                        attr.span,\n+                        &format!(\"expected module named `{}` to be Translated but is Reused\",\n+                                 mname));\n+                }\n+                (Disposition::Reused, true) |\n+                (Disposition::Translated, false) => {\n+                    // These are what we would expect.\n+                }\n+            }\n+        } else {\n+            self.tcx.sess.span_err(attr.span, &format!(\"no module named `{}`\", mname));\n         }\n     }\n "}, {"sha": "d79fbf77465a363032dffd217f994effe847f5a7", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -79,9 +79,7 @@ pub fn provide_local(providers: &mut Providers) {\n     providers.is_exported_symbol = |tcx, id| {\n         // FIXME(#42293) needs red/green to not break a bunch of incremental\n         // tests\n-        tcx.dep_graph.with_ignore(|| {\n-            tcx.exported_symbol_ids(id.krate).contains(&id)\n-        })\n+        tcx.exported_symbol_ids(id.krate).contains(&id)\n     };\n \n     providers.exported_symbols = |tcx, cnum| {"}, {"sha": "c238c68c4718da604816c152dddf02879fbaca0e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -884,7 +884,6 @@ fn copy_module_artifacts_into_incr_comp_cache(sess: &Session,\n         save_trans_partition(sess,\n                              dep_graph,\n                              &module.name,\n-                             module.symbol_name_hash,\n                              &files);\n     }\n }\n@@ -1134,7 +1133,6 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n             name: module_name,\n             kind: ModuleKind::Regular,\n             pre_existing: true,\n-            symbol_name_hash: mtrans.symbol_name_hash,\n             emit_bc: config.emit_bc,\n             emit_obj: config.emit_obj,\n         }))"}, {"sha": "c9ed17bfaf03b579a5a05a2dba35c8663d766ceb", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 52, "deletions": 73, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -28,7 +28,7 @@ use super::ModuleSource;\n use super::ModuleTranslation;\n use super::ModuleKind;\n \n-use assert_module_sources::{self, Disposition};\n+use assert_module_sources;\n use back::link;\n use back::symbol_export;\n use back::write::{self, OngoingCrateTranslation, create_target_machine};\n@@ -41,7 +41,7 @@ use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::dep_graph::{DepNode, DepKind};\n+use rustc::dep_graph::{DepNode, DepKind, DepConstructor};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n@@ -78,7 +78,6 @@ use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n use std::any::Any;\n-use std::cell::RefCell;\n use std::ffi::{CStr, CString};\n use std::str;\n use std::sync::Arc;\n@@ -904,7 +903,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let metadata_module = ModuleTranslation {\n         name: link::METADATA_MODULE_NAME.to_string(),\n         llmod_id: llmod_id.to_string(),\n-        symbol_name_hash: 0, // we always rebuild metadata, at least for now\n         source: ModuleSource::Translated(ModuleLlvm {\n             llcx: metadata_llcx,\n             llmod: metadata_llmod,\n@@ -985,7 +983,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Some(ModuleTranslation {\n                 name: link::ALLOCATOR_MODULE_NAME.to_string(),\n                 llmod_id: llmod_id.to_string(),\n-                symbol_name_hash: 0, // we always rebuild allocator shims\n                 source: ModuleSource::Translated(modules),\n                 kind: ModuleKind::Allocator,\n             })\n@@ -1017,6 +1014,50 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ongoing_translation.wait_for_signal_to_translate_item();\n         ongoing_translation.check_for_errors(tcx.sess);\n \n+        // First, if incremental compilation is enabled, we try to re-use the\n+        // codegen unit from the cache.\n+        if tcx.dep_graph.is_fully_enabled() {\n+            let cgu_id = cgu.work_product_id();\n+\n+            // Check whether there is a previous work-product we can\n+            // re-use.  Not only must the file exist, and the inputs not\n+            // be dirty, but the hash of the symbols we will generate must\n+            // be the same.\n+            if let Some(buf) = tcx.dep_graph.previous_work_product(&cgu_id) {\n+                let dep_node = &DepNode::new(tcx,\n+                    DepConstructor::CompileCodegenUnit(cgu.name().clone()));\n+\n+                // We try to mark the DepNode::CompileCodegenUnit green. If we\n+                // succeed it means that none of the dependencies has changed\n+                // and we can safely re-use.\n+                if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, dep_node) {\n+                    // Append \".rs\" to LLVM module identifier.\n+                    //\n+                    // LLVM code generator emits a \".file filename\" directive\n+                    // for ELF backends. Value of the \"filename\" is set as the\n+                    // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n+                    // crashes if the module identifier is same as other symbols\n+                    // such as a function name in the module.\n+                    // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n+                    let llmod_id = format!(\"{}.rs\", cgu.name());\n+\n+                    let module = ModuleTranslation {\n+                        name: cgu.name().to_string(),\n+                        source: ModuleSource::Preexisting(buf),\n+                        kind: ModuleKind::Regular,\n+                        llmod_id,\n+                    };\n+                    tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n+                    write::submit_translated_module_to_llvm(tcx, module, 0);\n+                    // Continue to next cgu, this one is done.\n+                    continue\n+                }\n+            } else {\n+                // This can happen if files were  deleted from the cache\n+                // directory for some reason. We just re-compile then.\n+            }\n+        }\n+\n         let _timing_guard = time_graph.as_ref().map(|time_graph| {\n             time_graph.start(write::TRANS_WORKER_TIMELINE,\n                              write::TRANS_WORK_PACKAGE_KIND,\n@@ -1037,9 +1078,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             total_trans_time);\n \n     if tcx.sess.opts.incremental.is_some() {\n-        DISPOSITIONS.with(|d| {\n-            assert_module_sources::assert_module_sources(tcx, &d.borrow());\n-        });\n+        assert_module_sources::assert_module_sources(tcx);\n     }\n \n     symbol_names_test::report_symbol_names(tcx);\n@@ -1074,10 +1113,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ongoing_translation\n }\n \n-// FIXME(#42293) hopefully once red/green is enabled we're testing everything\n-// via a method that doesn't require this!\n-thread_local!(static DISPOSITIONS: RefCell<Vec<(String, Disposition)>> = Default::default());\n-\n fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        metadata_incr_hashes: EncodedMetadataHashes,\n                                        link_meta: LinkMeta) {\n@@ -1301,38 +1336,19 @@ impl CrateInfo {\n }\n \n fn is_translated_function(tcx: TyCtxt, id: DefId) -> bool {\n-    // FIXME(#42293) needs red/green tracking to avoid failing a bunch of\n-    // existing tests\n-    tcx.dep_graph.with_ignore(|| {\n-        let (all_trans_items, _) =\n-            tcx.collect_and_partition_translation_items(LOCAL_CRATE);\n-        all_trans_items.contains(&id)\n-    })\n+    let (all_trans_items, _) =\n+        tcx.collect_and_partition_translation_items(LOCAL_CRATE);\n+    all_trans_items.contains(&id)\n }\n \n fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   cgu: InternedString) -> Stats {\n-    // FIXME(#42293) needs red/green tracking to avoid failing a bunch of\n-    // existing tests\n-    let cgu = tcx.dep_graph.with_ignore(|| {\n-        tcx.codegen_unit(cgu)\n-    });\n+    let cgu = tcx.codegen_unit(cgu);\n \n     let start_time = Instant::now();\n-    let dep_node = cgu.work_product_dep_node();\n-    let ((stats, module), _) =\n-        tcx.dep_graph.with_task(dep_node,\n-                                tcx,\n-                                cgu,\n-                                module_translation);\n+    let (stats, module) = module_translation(tcx, cgu);\n     let time_to_translate = start_time.elapsed();\n \n-    if tcx.sess.opts.incremental.is_some() {\n-        DISPOSITIONS.with(|d| {\n-            d.borrow_mut().push(module.disposition());\n-        });\n-    }\n-\n     // We assume that the cost to run LLVM on a CGU is proportional to\n     // the time we needed for translating it.\n     let cost = time_to_translate.as_secs() * 1_000_000_000 +\n@@ -1349,8 +1365,6 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         -> (Stats, ModuleTranslation)\n     {\n         let cgu_name = cgu.name().to_string();\n-        let cgu_id = cgu.work_product_id();\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(tcx);\n \n         // Append \".rs\" to LLVM module identifier.\n         //\n@@ -1362,40 +1376,6 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n         let llmod_id = format!(\"{}.rs\", cgu.name());\n \n-        // Check whether there is a previous work-product we can\n-        // re-use.  Not only must the file exist, and the inputs not\n-        // be dirty, but the hash of the symbols we will generate must\n-        // be the same.\n-        let previous_work_product =\n-            tcx.dep_graph.previous_work_product(&cgu_id).and_then(|work_product| {\n-                if work_product.input_hash == symbol_name_hash {\n-                    debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n-                    Some(work_product)\n-                } else {\n-                    if tcx.sess.opts.debugging_opts.incremental_info {\n-                        eprintln!(\"incremental: CGU `{}` invalidated because of \\\n-                                   changed partitioning hash.\",\n-                                   cgu.name());\n-                    }\n-                    debug!(\"trans_reuse_previous_work_products: \\\n-                            not reusing {:?} because hash changed to {:?}\",\n-                           work_product, symbol_name_hash);\n-                    None\n-                }\n-            });\n-\n-        if let Some(buf) = previous_work_product {\n-            // Don't need to translate this module.\n-            let module = ModuleTranslation {\n-                llmod_id: llmod_id,\n-                name: cgu_name,\n-                symbol_name_hash,\n-                source: ModuleSource::Preexisting(buf.clone()),\n-                kind: ModuleKind::Regular,\n-            };\n-            return (Stats::default(), module);\n-        }\n-\n         // Instantiate translation items without filling out definitions yet...\n         let scx = SharedCrateContext::new(tcx);\n         let lcx = LocalCrateContext::new(&scx, cgu, &llmod_id);\n@@ -1461,7 +1441,6 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             ModuleTranslation {\n                 name: cgu_name,\n-                symbol_name_hash,\n                 source: ModuleSource::Translated(llvm_module),\n                 kind: ModuleKind::Regular,\n                 llmod_id,"}, {"sha": "3cd26e49818bbb49ca5b07fbbaf38936a5eae93e", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -155,17 +155,14 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n \n-        // FIXME(#42293) we should actually track this, but fails too many tests\n-        // today.\n-        tcx.dep_graph.with_ignore(|| {\n-            if ccx.use_dll_storage_attrs() &&\n-                tcx.is_dllimport_foreign_item(instance_def_id)\n-            {\n-                unsafe {\n-                    llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n-                }\n+        if ccx.use_dll_storage_attrs() &&\n+            tcx.is_dllimport_foreign_item(instance_def_id)\n+        {\n+            unsafe {\n+                llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n             }\n-        });\n+        }\n+\n         llfn\n     };\n "}, {"sha": "4263a553f8b43304a67dbb0e10ea86dc3c9f95e5", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -296,26 +296,22 @@ pub fn collect_crate_translation_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FxHashSet<TransItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n-    // We are not tracking dependencies of this pass as it has to be re-executed\n-    // every time no matter what.\n-    tcx.dep_graph.with_ignore(|| {\n-        let roots = collect_roots(tcx, mode);\n-\n-        debug!(\"Building translation item graph, beginning at roots\");\n-        let mut visited = FxHashSet();\n-        let mut recursion_depths = DefIdMap();\n-        let mut inlining_map = InliningMap::new();\n-\n-        for root in roots {\n-            collect_items_rec(tcx,\n-                              root,\n-                              &mut visited,\n-                              &mut recursion_depths,\n-                              &mut inlining_map);\n-        }\n+    let roots = collect_roots(tcx, mode);\n+\n+    debug!(\"Building translation item graph, beginning at roots\");\n+    let mut visited = FxHashSet();\n+    let mut recursion_depths = DefIdMap();\n+    let mut inlining_map = InliningMap::new();\n+\n+    for root in roots {\n+        collect_items_rec(tcx,\n+                          root,\n+                          &mut visited,\n+                          &mut recursion_depths,\n+                          &mut inlining_map);\n+    }\n \n-        (visited, inlining_map)\n-    })\n+    (visited, inlining_map)\n }\n \n // Find all non-generic items by walking the HIR. These items serve as roots to"}, {"sha": "eaf7392aab5b4f6d95a2ca635c4fb0bd8db8b3e6", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -231,17 +231,13 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         g\n     };\n \n-\n-    // FIXME(#42293) we should actually track this, but fails too many tests\n-    // today.\n-    ccx.tcx().dep_graph.with_ignore(|| {\n-        if ccx.use_dll_storage_attrs() && ccx.tcx().is_dllimport_foreign_item(def_id) {\n-            // For foreign (native) libs we know the exact storage type to use.\n-            unsafe {\n-                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n-            }\n+    if ccx.use_dll_storage_attrs() && ccx.tcx().is_dllimport_foreign_item(def_id) {\n+        // For foreign (native) libs we know the exact storage type to use.\n+        unsafe {\n+            llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n         }\n-    });\n+    }\n+\n     ccx.instances().borrow_mut().insert(instance, g);\n     ccx.statics().borrow_mut().insert(g, def_id);\n     g"}, {"sha": "2b1c62c7f1c768cded788224bb50c96c233cac48", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -204,7 +204,6 @@ pub struct ModuleTranslation {\n     /// as the crate name and disambiguator.\n     name: String,\n     llmod_id: String,\n-    symbol_name_hash: u64,\n     pub source: ModuleSource,\n     pub kind: ModuleKind,\n }\n@@ -238,7 +237,6 @@ impl ModuleTranslation {\n             llmod_id: self.llmod_id,\n             name: self.name.clone(),\n             kind: self.kind,\n-            symbol_name_hash: self.symbol_name_hash,\n             pre_existing,\n             emit_obj,\n             emit_bc,\n@@ -253,7 +251,6 @@ pub struct CompiledModule {\n     pub llmod_id: String,\n     pub object: PathBuf,\n     pub kind: ModuleKind,\n-    pub symbol_name_hash: u64,\n     pub pre_existing: bool,\n     pub emit_obj: bool,\n     pub emit_bc: bool,"}, {"sha": "7b6daa7d13328c9c2f312fdca294674ea9109cae", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -108,14 +108,11 @@ use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::middle::trans::{Linkage, Visibility};\n-use rustc::ich::Fingerprint;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use rustc_data_structures::stable_hasher::StableHasher;\n use std::collections::hash_map::Entry;\n-use std::hash::Hash;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use trans_item::{TransItem, TransItemExt, InstantiationMode};\n@@ -155,19 +152,6 @@ pub trait CodegenUnitExt<'tcx> {\n         self.work_product_id().to_dep_node()\n     }\n \n-    fn compute_symbol_name_hash<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> u64 {\n-        let mut state: StableHasher<Fingerprint> = StableHasher::new();\n-        let all_items = self.items_in_deterministic_order(tcx);\n-        for (item, (linkage, visibility)) in all_items {\n-            let symbol_name = item.symbol_name(tcx);\n-            symbol_name.len().hash(&mut state);\n-            symbol_name.hash(&mut state);\n-            linkage.hash(&mut state);\n-            visibility.hash(&mut state);\n-        }\n-        state.finish().to_smaller_hash()\n-    }\n-\n     fn items_in_deterministic_order<'a>(&self,\n                                         tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                         -> Vec<(TransItem<'tcx>,"}, {"sha": "40067efd57595973a13dc00676ee0347c5681eeb", "filename": "src/test/incremental/add_private_fn_at_krate_root_cc/struct_point.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -15,7 +15,6 @@\n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n // aux-build:point.rs\n-// ignore-test FIXME(#42293) this regressed in #44142 but should get fixed with red/green\n \n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "feecfecd0b85368a137ffb543cd6ccf1a09bf6ab", "filename": "src/test/incremental/cache_file_headers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fcache_file_headers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fcache_file_headers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcache_file_headers.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -20,6 +20,7 @@\n //[rpass1] rustc-env:RUSTC_FORCE_INCR_COMP_ARTIFACT_HEADER=\"l33t haxx0r rustc 2.1 LTS\"\n \n // revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n #![rustc_partition_translated(module=\"cache_file_headers\", cfg=\"rpass2\")]"}, {"sha": "9e56d34636ff0083b4dc53a91809aef0a13c8eb0", "filename": "src/test/incremental/callee_caller_cross_crate/b.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -12,8 +12,6 @@\n // revisions:rpass1 rpass2\n // compile-flags:-Z query-dep-graph\n \n-// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n-\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "a6d029515d74263d23cbeb295eb101fb68618967", "filename": "src/test/incremental/change_private_fn_cc/struct_point.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -15,8 +15,6 @@\n // compile-flags: -Z query-dep-graph\n // aux-build:point.rs\n \n-// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n-\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]"}, {"sha": "05c076b9f4bc3b47dd286d658a3221024fef4ef3", "filename": "src/test/incremental/change_private_impl_method_cc/struct_point.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -15,8 +15,6 @@\n // compile-flags: -Z query-dep-graph\n // aux-build:point.rs\n \n-// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n-\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]"}, {"sha": "ab91a941a1663aa62006a6aefbea4556d60e517f", "filename": "src/test/incremental/change_symbol_export_status.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fchange_symbol_export_status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fchange_symbol_export_status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_symbol_export_status.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n // revisions: rpass1 rpass2\n+// compile-flags: -Zquery-dep-graph\n \n #![feature(rustc_attrs)]\n #![allow(private_no_mangle_fns)]\n \n-#![rustc_partition_reused(module=\"change_symbol_export_status\", cfg=\"rpass2\")]\n #![rustc_partition_translated(module=\"change_symbol_export_status-mod1\", cfg=\"rpass2\")]\n-\n+#![rustc_partition_reused(module=\"change_symbol_export_status-mod2\", cfg=\"rpass2\")]\n \n // This test case makes sure that a change in symbol visibility is detected by\n // our dependency tracking. We do this by changing a module's visibility to\n@@ -37,6 +37,11 @@ mod mod1 {\n     pub fn foo() {}\n }\n \n+pub mod mod2 {\n+    #[no_mangle]\n+    pub fn bar() {}\n+}\n+\n fn main() {\n     mod1::foo();\n }"}, {"sha": "e29f2ec2a1345682a33d3604984c91187c4fff54", "filename": "src/test/incremental/commandline-args.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fcommandline-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fcommandline-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcommandline-args.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -12,6 +12,7 @@\n // the cache while changing an untracked one doesn't.\n \n // revisions:rpass1 rpass2 rpass3\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}, {"sha": "52a601ac1e87bd447afa3cc6745b931437201757", "filename": "src/test/incremental/issue-35593.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fissue-35593.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fissue-35593.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-35593.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -12,6 +12,7 @@\n // equal example.\n \n // revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n #![rustc_partition_reused(module=\"issue_35593\", cfg=\"rpass2\")]"}, {"sha": "410ff69bf69c5391169c13de2c775d876d2847f8", "filename": "src/test/incremental/issue-38222.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fissue-38222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fissue-38222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-38222.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -12,6 +12,8 @@\n // dep-node.\n \n // revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n \n #![feature(rustc_attrs)]\n "}, {"sha": "432d8a1b444f3eb1708b050e7d304c306a4e8c81", "filename": "src/test/incremental/remapped_paths_cc/main.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -11,8 +11,6 @@\n // revisions:rpass1 rpass2 rpass3\n // compile-flags: -Z query-dep-graph -g -Zincremental-cc\n // aux-build:extern_crate.rs\n-// ignore-test FIXME(#42293) this regressed in #44142 but should get fixed with red/green\n-\n \n // This test case makes sure that we detect if paths emitted into debuginfo\n // are changed, even when the change happens in an external crate."}, {"sha": "d94cb403da8a5209c02ad382d0f55f61d882f296", "filename": "src/test/incremental/remove-private-item-cross-crate/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -17,8 +17,7 @@\n #![feature(rustc_attrs)]\n #![crate_type = \"bin\"]\n \n-// FIXME(#42293) this regressed in #44142 but should get fixed with red/green\n-// #![rustc_partition_reused(module=\"main\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"main\", cfg=\"rpass2\")]\n \n extern crate a;\n "}, {"sha": "9849e93d3ff9ef4e0de1eb6aea01f9bd5c9d89a1", "filename": "src/test/incremental/rlib_cross_crate/b.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -18,8 +18,6 @@\n // no-prefer-dynamic\n // compile-flags: -Z query-dep-graph\n \n-// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n-\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "a820471b7d55baf1dfea4d1a54278cbeb9cf5851", "filename": "src/test/incremental/spike.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fspike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fspike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -13,6 +13,7 @@\n // `y` module entirely (but not the `x` module).\n \n // revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}, {"sha": "9660f47da35c1ef6de5ad5a6b3dac243cd563000", "filename": "src/test/incremental/struct_change_field_type_cross_crate/b.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -12,8 +12,6 @@\n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n \n-// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n-\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "ee35a4d9b9c6e9f0c96af2a5ba000fb32168da90", "filename": "src/test/incremental/type_alias_cross_crate/b.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6badfd449fa501c4565f93a1d8faee9d9d6c8df/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs?ref=e6badfd449fa501c4565f93a1d8faee9d9d6c8df", "patch": "@@ -12,8 +12,6 @@\n // revisions:rpass1 rpass2 rpass3\n // compile-flags: -Z query-dep-graph\n \n-// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n-\n #![feature(rustc_attrs)]\n \n extern crate a;"}]}