{"sha": "16a9258797436498a00726e8aea2ee8a85755e15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2YTkyNTg3OTc0MzY0OThhMDA3MjZlOGFlYTJlZThhODU3NTVlMTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-06-30T20:58:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-06-30T22:40:32Z"}, "message": "core: Reorganize slice module.\n\nThis is just moving things around so they are defined in a logical order.", "tree": {"sha": "67dde2487c095bf2f0d87ef42b6f99f8a2b91c2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67dde2487c095bf2f0d87ef42b6f99f8a2b91c2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16a9258797436498a00726e8aea2ee8a85755e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16a9258797436498a00726e8aea2ee8a85755e15", "html_url": "https://github.com/rust-lang/rust/commit/16a9258797436498a00726e8aea2ee8a85755e15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16a9258797436498a00726e8aea2ee8a85755e15/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94343da1bdf4de84d0ece90d920400697ad7e143", "url": "https://api.github.com/repos/rust-lang/rust/commits/94343da1bdf4de84d0ece90d920400697ad7e143", "html_url": "https://github.com/rust-lang/rust/commit/94343da1bdf4de84d0ece90d920400697ad7e143"}], "stats": {"total": 2022, "additions": 1039, "deletions": 983}, "files": [{"sha": "f1a694c974a5fd7e74cf79889945d5b30cf0fb6e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1039, "deletions": 983, "changes": 2022, "blob_url": "https://github.com/rust-lang/rust/blob/16a9258797436498a00726e8aea2ee8a85755e15/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a9258797436498a00726e8aea2ee8a85755e15/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=16a9258797436498a00726e8aea2ee8a85755e15", "patch": "@@ -14,6 +14,25 @@\n \n #![doc(primitive = \"slice\")]\n \n+// How this module is organized.\n+//\n+// The library infrastructure for slices is fairly messy. There's\n+// a lot of stuff defined here. Let's keep it clean.\n+//\n+// Since slices don't support inherent methods; all operations\n+// on them are defined on traits, which are then reexported from\n+// the prelude for convenience. So there are a lot of traits here.\n+//\n+// The layout of this file is thus:\n+//\n+// * Slice-specific 'extension' traits and their implementations. This\n+//   is where most of the slice API resides.\n+// * Implementations of a few common traits with important slice ops.\n+// * Definitions of a bunch of iterators.\n+// * Free functions.\n+// * The `raw` and `bytes` submodules.\n+// * Boilerplate trait implementations.\n+\n use mem::transmute;\n use clone::Clone;\n use collections::Collection;\n@@ -30,627 +49,694 @@ use mem::size_of;\n use kinds::marker;\n use raw::{Repr, Slice};\n \n-/**\n- * Converts a pointer to A into a slice of length 1 (without copying).\n- */\n-pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n-    unsafe {\n-        transmute(Slice { data: s, len: 1 })\n-    }\n+//\n+// Extension traits\n+//\n+\n+/// Extension methods for vectors\n+pub trait ImmutableVector<'a, T> {\n+    /**\n+     * Returns a slice of self spanning the interval [`start`, `end`).\n+     *\n+     * Fails when the slice (or part of it) is outside the bounds of self,\n+     * or when `start` > `end`.\n+     */\n+    fn slice(&self, start: uint, end: uint) -> &'a [T];\n+\n+    /**\n+     * Returns a slice of self from `start` to the end of the vec.\n+     *\n+     * Fails when `start` points outside the bounds of self.\n+     */\n+    fn slice_from(&self, start: uint) -> &'a [T];\n+\n+    /**\n+     * Returns a slice of self from the start of the vec to `end`.\n+     *\n+     * Fails when `end` points outside the bounds of self.\n+     */\n+    fn slice_to(&self, end: uint) -> &'a [T];\n+    /// Returns an iterator over the vector\n+    fn iter(self) -> Items<'a, T>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`.  The matched element\n+    /// is not contained in the subslices.\n+    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`, limited to splitting\n+    /// at most `n` times.  The matched element is not contained in\n+    /// the subslices.\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred` limited to splitting\n+    /// at most `n` times. This starts at the end of the vector and\n+    /// works backwards.  The matched element is not contained in the\n+    /// subslices.\n+    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+\n+    /**\n+     * Returns an iterator over all contiguous windows of length\n+     * `size`. The windows overlap. If the vector is shorter than\n+     * `size`, the iterator returns no values.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n+     * `[3,4]`):\n+     *\n+     * ```rust\n+     * let v = &[1i, 2, 3, 4];\n+     * for win in v.windows(2) {\n+     *     println!(\"{}\", win);\n+     * }\n+     * ```\n+     *\n+     */\n+    fn windows(self, size: uint) -> Windows<'a, T>;\n+    /**\n+     *\n+     * Returns an iterator over `size` elements of the vector at a\n+     * time. The chunks do not overlap. If `size` does not divide the\n+     * length of the vector, then the last chunk will not have length\n+     * `size`.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the vector two elements at a time (i.e. `[1,2]`,\n+     * `[3,4]`, `[5]`):\n+     *\n+     * ```rust\n+     * let v = &[1i, 2, 3, 4, 5];\n+     * for win in v.chunks(2) {\n+     *     println!(\"{}\", win);\n+     * }\n+     * ```\n+     *\n+     */\n+    fn chunks(self, size: uint) -> Chunks<'a, T>;\n+\n+    /// Returns the element of a vector at the given index, or `None` if the\n+    /// index is out of bounds\n+    fn get(&self, index: uint) -> Option<&'a T>;\n+    /// Returns the first element of a vector, or `None` if it is empty\n+    fn head(&self) -> Option<&'a T>;\n+    /// Returns all but the first element of a vector\n+    fn tail(&self) -> &'a [T];\n+    /// Returns all but the first `n' elements of a vector\n+    fn tailn(&self, n: uint) -> &'a [T];\n+    /// Returns all but the last element of a vector\n+    fn init(&self) -> &'a [T];\n+    /// Returns all but the last `n' elements of a vector\n+    fn initn(&self, n: uint) -> &'a [T];\n+    /// Returns the last element of a vector, or `None` if it is empty.\n+    fn last(&self) -> Option<&'a T>;\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n+\n+    /**\n+     * Returns an unsafe pointer to the vector's buffer\n+     *\n+     * The caller must ensure that the vector outlives the pointer this\n+     * function returns, or else it will end up pointing to garbage.\n+     *\n+     * Modifying the vector may cause its buffer to be reallocated, which\n+     * would also make any pointers to it invalid.\n+     */\n+    fn as_ptr(&self) -> *const T;\n+\n+    /**\n+     * Binary search a sorted vector with a comparator function.\n+     *\n+     * The comparator function should implement an order consistent\n+     * with the sort order of the underlying vector, returning an\n+     * order code that indicates whether its argument is `Less`,\n+     * `Equal` or `Greater` the desired target.\n+     *\n+     * Returns the index where the comparator returned `Equal`, or `None` if\n+     * not found.\n+     */\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n+\n+    /**\n+     * Returns an immutable reference to the first element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None }\n+     *     let head = &self[0];\n+     *     *self = self.slice_from(1);\n+     *     Some(head)\n+     * ```\n+     *\n+     * Returns `None` if vector is empty\n+     */\n+    fn shift_ref(&mut self) -> Option<&'a T>;\n+\n+    /**\n+     * Returns an immutable reference to the last element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None; }\n+     *     let tail = &self[self.len() - 1];\n+     *     *self = self.slice_to(self.len() - 1);\n+     *     Some(tail)\n+     * ```\n+     *\n+     * Returns `None` if slice is empty.\n+     */\n+    fn pop_ref(&mut self) -> Option<&'a T>;\n }\n \n-/**\n- * Converts a pointer to A into a slice of length 1 (without copying).\n- */\n-pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n-    unsafe {\n-        let ptr: *const A = transmute(s);\n-        transmute(Slice { data: ptr, len: 1 })\n+impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n+    #[inline]\n+    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(Slice {\n+                    data: self.as_ptr().offset(start as int),\n+                    len: (end - start)\n+                })\n+        }\n     }\n-}\n \n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function.\n-pub struct Splits<'a, T> {\n-    v: &'a [T],\n-    pred: |t: &T|: 'a -> bool,\n-    finished: bool\n-}\n+    #[inline]\n+    fn slice_from(&self, start: uint) -> &'a [T] {\n+        self.slice(start, self.len())\n+    }\n \n-impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.finished { return None; }\n+    fn slice_to(&self, end: uint) -> &'a [T] {\n+        self.slice(0, end)\n+    }\n \n-        match self.v.iter().position(|x| (self.pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.v)\n-            }\n-            Some(idx) => {\n-                let ret = Some(self.v.slice(0, idx));\n-                self.v = self.v.slice(idx + 1, self.v.len());\n-                ret\n+    #[inline]\n+    fn iter(self) -> Items<'a, T> {\n+        unsafe {\n+            let p = self.as_ptr();\n+            if mem::size_of::<T>() == 0 {\n+                Items{ptr: p,\n+                      end: (p as uint + self.len()) as *const T,\n+                      marker: marker::ContravariantLifetime::<'a>}\n+            } else {\n+                Items{ptr: p,\n+                      end: p.offset(self.len() as int),\n+                      marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished {\n-            (0, Some(0))\n-        } else {\n-            (1, Some(self.v.len() + 1))\n+    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n+        Splits {\n+            v: self,\n+            pred: pred,\n+            finished: false\n         }\n     }\n-}\n \n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.finished { return None; }\n-\n-        match self.v.iter().rposition(|x| (self.pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.v)\n-            }\n-            Some(idx) => {\n-                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n-                self.v = self.v.slice(0, idx);\n-                ret\n-            }\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: false\n         }\n     }\n-}\n \n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function, splitting at most a fixed number of times.\n-pub struct SplitsN<'a, T> {\n-    iter: Splits<'a, T>,\n-    count: uint,\n-    invert: bool\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.count == 0 {\n-            if self.iter.finished {\n-                None\n-            } else {\n-                self.iter.finished = true;\n-                Some(self.iter.v)\n-            }\n-        } else {\n-            self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: true\n         }\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.iter.finished {\n-            (0, Some(0))\n-        } else {\n-            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n-        }\n+    fn windows(self, size: uint) -> Windows<'a, T> {\n+        assert!(size != 0);\n+        Windows { v: self, size: size }\n     }\n-}\n-\n-// Functional utilities\n \n-/// An iterator over the (overlapping) slices of length `size` within\n-/// a vector.\n-#[deriving(Clone)]\n-pub struct Windows<'a, T> {\n-    v: &'a [T],\n-    size: uint\n-}\n+    #[inline]\n+    fn chunks(self, size: uint) -> Chunks<'a, T> {\n+        assert!(size != 0);\n+        Chunks { v: self, size: size }\n+    }\n \n-impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.size > self.v.len() {\n-            None\n-        } else {\n-            let ret = Some(self.v.slice(0, self.size));\n-            self.v = self.v.slice(1, self.v.len());\n-            ret\n-        }\n+    fn get(&self, index: uint) -> Option<&'a T> {\n+        if index < self.len() { Some(&self[index]) } else { None }\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.size > self.v.len() {\n-            (0, Some(0))\n-        } else {\n-            let x = self.v.len() - self.size;\n-            (x.saturating_add(1), x.checked_add(&1u))\n-        }\n+    fn head(&self) -> Option<&'a T> {\n+        if self.len() == 0 { None } else { Some(&self[0]) }\n     }\n-}\n \n-/// An iterator over a vector in (non-overlapping) chunks (`size`\n-/// elements at a time).\n-///\n-/// When the vector len is not evenly divided by the chunk size,\n-/// the last slice of the iteration will be the remainder.\n-#[deriving(Clone)]\n-pub struct Chunks<'a, T> {\n-    v: &'a [T],\n-    size: uint\n-}\n+    #[inline]\n+    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n \n-impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let chunksz = cmp::min(self.v.len(), self.size);\n-            let (fst, snd) = (self.v.slice_to(chunksz),\n-                              self.v.slice_from(chunksz));\n-            self.v = snd;\n-            Some(fst)\n-        }\n-    }\n+    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.v.len() == 0 {\n-            (0, Some(0))\n-        } else {\n-            let (n, rem) = div_rem(self.v.len(), self.size);\n-            let n = if rem > 0 { n+1 } else { n };\n-            (n, Some(n))\n-        }\n+    fn init(&self) -> &'a [T] {\n+        self.slice(0, self.len() - 1)\n     }\n-}\n \n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let remainder = self.v.len() % self.size;\n-            let chunksz = if remainder != 0 { remainder } else { self.size };\n-            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n-                              self.v.slice_from(self.v.len() - chunksz));\n-            self.v = fst;\n-            Some(snd)\n-        }\n+    fn initn(&self, n: uint) -> &'a [T] {\n+        self.slice(0, self.len() - n)\n     }\n-}\n \n-impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n-        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n+    fn last(&self) -> Option<&'a T> {\n+            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n-        if index < self.indexable() {\n-            let lo = index * self.size;\n-            let mut hi = lo + self.size;\n-            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n-\n-            Some(self.v.slice(lo, hi))\n-        } else {\n-            None\n-        }\n+    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n+        transmute(self.repr().data.offset(index as int))\n     }\n-}\n \n-// Equality\n+    #[inline]\n+    fn as_ptr(&self) -> *const T {\n+        self.repr().data\n+    }\n \n-#[allow(missing_doc)]\n-pub mod traits {\n-    use super::*;\n \n-    use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Equiv};\n-    use iter::order;\n-    use collections::Collection;\n-    use option::Option;\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n+        let mut base : uint = 0;\n+        let mut lim : uint = self.len();\n \n-    impl<'a,T:PartialEq> PartialEq for &'a [T] {\n-        fn eq(&self, other: & &'a [T]) -> bool {\n-            self.len() == other.len() &&\n-                order::eq(self.iter(), other.iter())\n-        }\n-        fn ne(&self, other: & &'a [T]) -> bool {\n-            self.len() != other.len() ||\n-                order::ne(self.iter(), other.iter())\n+        while lim != 0 {\n+            let ix = base + (lim >> 1);\n+            match f(&self[ix]) {\n+                Equal => return Some(ix),\n+                Less => {\n+                    base = ix + 1;\n+                    lim -= 1;\n+                }\n+                Greater => ()\n+            }\n+            lim >>= 1;\n         }\n+        return None;\n     }\n \n-    impl<'a,T:Eq> Eq for &'a [T] {}\n-\n-    impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for &'a [T] {\n-        #[inline]\n-        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-    }\n-\n-    impl<'a,T:Ord> Ord for &'a [T] {\n-        fn cmp(&self, other: & &'a [T]) -> Ordering {\n-            order::cmp(self.iter(), other.iter())\n+    fn shift_ref(&mut self) -> Option<&'a T> {\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            match raw::shift_ptr(s) {\n+                Some(p) => Some(&*p),\n+                None => None\n+            }\n         }\n     }\n \n-    impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n-        #[inline]\n-        fn partial_cmp(&self, other: &&'a [T]) -> Option<Ordering> {\n-            order::partial_cmp(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn lt(&self, other: & &'a [T]) -> bool {\n-            order::lt(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn le(&self, other: & &'a [T]) -> bool {\n-            order::le(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn ge(&self, other: & &'a [T]) -> bool {\n-            order::ge(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn gt(&self, other: & &'a [T]) -> bool {\n-            order::gt(self.iter(), other.iter())\n+    fn pop_ref(&mut self) -> Option<&'a T> {\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            match raw::pop_ptr(s) {\n+                Some(p) => Some(&*p),\n+                None => None\n+            }\n         }\n     }\n }\n \n-/// Any vector that can be represented as a slice.\n-pub trait Vector<T> {\n-    /// Work with `self` as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a [T];\n-}\n+/// Extension methods for vectors such that their elements are\n+/// mutable.\n+pub trait MutableVector<'a, T> {\n+    /// Returns a mutable reference to the element at the given index,\n+    /// or `None` if the index is out of bounds\n+    fn get_mut(self, index: uint) -> Option<&'a mut T>;\n+    /// Work with `self` as a mut slice.\n+    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n+    fn as_mut_slice(self) -> &'a mut [T];\n \n-impl<'a,T> Vector<T> for &'a [T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n-}\n-\n-impl<'a, T> Collection for &'a [T] {\n-    /// Returns the length of a vector\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.repr().len\n-    }\n-}\n-\n-/// Extension methods for vectors\n-pub trait ImmutableVector<'a, T> {\n-    /**\n-     * Returns a slice of self spanning the interval [`start`, `end`).\n-     *\n-     * Fails when the slice (or part of it) is outside the bounds of self,\n-     * or when `start` > `end`.\n-     */\n-    fn slice(&self, start: uint, end: uint) -> &'a [T];\n+    /// Return a slice that points into another slice.\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];\n \n     /**\n      * Returns a slice of self from `start` to the end of the vec.\n      *\n      * Fails when `start` points outside the bounds of self.\n      */\n-    fn slice_from(&self, start: uint) -> &'a [T];\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T];\n \n     /**\n      * Returns a slice of self from the start of the vec to `end`.\n      *\n      * Fails when `end` points outside the bounds of self.\n      */\n-    fn slice_to(&self, end: uint) -> &'a [T];\n-    /// Returns an iterator over the vector\n-    fn iter(self) -> Items<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`.  The matched element\n-    /// is not contained in the subslices.\n-    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`, limited to splitting\n-    /// at most `n` times.  The matched element is not contained in\n-    /// the subslices.\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred` limited to splitting\n-    /// at most `n` times. This starts at the end of the vector and\n-    /// works backwards.  The matched element is not contained in the\n-    /// subslices.\n-    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T];\n+\n+    /// Returns an iterator that allows modifying each value\n+    fn mut_iter(self) -> MutItems<'a, T>;\n+\n+    /// Returns a mutable pointer to the last item in the vector.\n+    fn mut_last(self) -> Option<&'a mut T>;\n+\n+    /// Returns an iterator over the mutable subslices of the vector\n+    /// which are separated by elements that match `pred`.  The\n+    /// matched element is not contained in the subslices.\n+    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n \n     /**\n-     * Returns an iterator over all contiguous windows of length\n-     * `size`. The windows overlap. If the vector is shorter than\n-     * `size`, the iterator returns no values.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     *\n-     * # Example\n-     *\n-     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n-     * `[3,4]`):\n-     *\n-     * ```rust\n-     * let v = &[1i, 2, 3, 4];\n-     * for win in v.windows(2) {\n-     *     println!(\"{}\", win);\n-     * }\n-     * ```\n-     *\n-     */\n-    fn windows(self, size: uint) -> Windows<'a, T>;\n-    /**\n-     *\n-     * Returns an iterator over `size` elements of the vector at a\n-     * time. The chunks do not overlap. If `size` does not divide the\n+     * Returns an iterator over `size` elements of the vector at a time.\n+     * The chunks are mutable and do not overlap. If `size` does not divide the\n      * length of the vector, then the last chunk will not have length\n      * `size`.\n      *\n      * # Failure\n      *\n      * Fails if `size` is 0.\n-     *\n-     * # Example\n-     *\n-     * Print the vector two elements at a time (i.e. `[1,2]`,\n-     * `[3,4]`, `[5]`):\n-     *\n-     * ```rust\n-     * let v = &[1i, 2, 3, 4, 5];\n-     * for win in v.chunks(2) {\n-     *     println!(\"{}\", win);\n-     * }\n-     * ```\n-     *\n-     */\n-    fn chunks(self, size: uint) -> Chunks<'a, T>;\n-\n-    /// Returns the element of a vector at the given index, or `None` if the\n-    /// index is out of bounds\n-    fn get(&self, index: uint) -> Option<&'a T>;\n-    /// Returns the first element of a vector, or `None` if it is empty\n-    fn head(&self) -> Option<&'a T>;\n-    /// Returns all but the first element of a vector\n-    fn tail(&self) -> &'a [T];\n-    /// Returns all but the first `n' elements of a vector\n-    fn tailn(&self, n: uint) -> &'a [T];\n-    /// Returns all but the last element of a vector\n-    fn init(&self) -> &'a [T];\n-    /// Returns all but the last `n' elements of a vector\n-    fn initn(&self, n: uint) -> &'a [T];\n-    /// Returns the last element of a vector, or `None` if it is empty.\n-    fn last(&self) -> Option<&'a T>;\n-\n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n-\n-    /**\n-     * Returns an unsafe pointer to the vector's buffer\n-     *\n-     * The caller must ensure that the vector outlives the pointer this\n-     * function returns, or else it will end up pointing to garbage.\n-     *\n-     * Modifying the vector may cause its buffer to be reallocated, which\n-     * would also make any pointers to it invalid.\n-     */\n-    fn as_ptr(&self) -> *const T;\n-\n-    /**\n-     * Binary search a sorted vector with a comparator function.\n-     *\n-     * The comparator function should implement an order consistent\n-     * with the sort order of the underlying vector, returning an\n-     * order code that indicates whether its argument is `Less`,\n-     * `Equal` or `Greater` the desired target.\n-     *\n-     * Returns the index where the comparator returned `Equal`, or `None` if\n-     * not found.\n      */\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;\n \n     /**\n-     * Returns an immutable reference to the first element in this slice\n+     * Returns a mutable reference to the first element in this slice\n      * and adjusts the slice in place so that it no longer contains\n      * that element. O(1).\n      *\n      * Equivalent to:\n      *\n      * ```ignore\n-     *     if self.len() == 0 { return None }\n-     *     let head = &self[0];\n-     *     *self = self.slice_from(1);\n+     *     if self.len() == 0 { return None; }\n+     *     let head = &mut self[0];\n+     *     *self = self.mut_slice_from(1);\n      *     Some(head)\n      * ```\n      *\n-     * Returns `None` if vector is empty\n+     * Returns `None` if slice is empty\n      */\n-    fn shift_ref(&mut self) -> Option<&'a T>;\n+    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n \n     /**\n-     * Returns an immutable reference to the last element in this slice\n+     * Returns a mutable reference to the last element in this slice\n      * and adjusts the slice in place so that it no longer contains\n      * that element. O(1).\n      *\n      * Equivalent to:\n      *\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n-     *     let tail = &self[self.len() - 1];\n-     *     *self = self.slice_to(self.len() - 1);\n+     *     let tail = &mut self[self.len() - 1];\n+     *     *self = self.mut_slice_to(self.len() - 1);\n      *     Some(tail)\n      * ```\n      *\n      * Returns `None` if slice is empty.\n      */\n-    fn pop_ref(&mut self) -> Option<&'a T>;\n-}\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n \n-impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n-    #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(Slice {\n-                    data: self.as_ptr().offset(start as int),\n-                    len: (end - start)\n-                })\n-        }\n-    }\n+    /// Swaps two elements in a vector.\n+    ///\n+    /// Fails if `a` or `b` are out of bounds.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    fn swap(self, a: uint, b: uint);\n \n-    #[inline]\n-    fn slice_from(&self, start: uint) -> &'a [T] {\n-        self.slice(start, self.len())\n-    }\n \n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &'a [T] {\n-        self.slice(0, end)\n-    }\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Fails if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.mut_split_at(0);\n+    ///    assert!(left == &mut []);\n+    ///    assert!(right == &mut [1i, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.mut_split_at(2);\n+    ///     assert!(left == &mut [1i, 2]);\n+    ///     assert!(right == &mut [3i, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.mut_split_at(6);\n+    ///     assert!(left == &mut [1i, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == &mut []);\n+    /// }\n+    /// ```\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n \n-    #[inline]\n-    fn iter(self) -> Items<'a, T> {\n-        unsafe {\n-            let p = self.as_ptr();\n-            if mem::size_of::<T>() == 0 {\n-                Items{ptr: p,\n-                      end: (p as uint + self.len()) as *const T,\n-                      marker: marker::ContravariantLifetime::<'a>}\n-            } else {\n-                Items{ptr: p,\n-                      end: p.offset(self.len() as int),\n-                      marker: marker::ContravariantLifetime::<'a>}\n-            }\n-        }\n-    }\n+    /// Reverse the order of elements in a vector, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3i, 2, 1]);\n+    /// ```\n+    fn reverse(self);\n \n-    #[inline]\n-    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n-        Splits {\n-            v: self,\n-            pred: pred,\n-            finished: false\n-        }\n-    }\n+    /// Returns an unsafe mutable pointer to the element in index\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;\n \n+    /// Return an unsafe mutable pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the vector may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n     #[inline]\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: false\n-        }\n-    }\n+    fn as_mut_ptr(self) -> *mut T;\n \n-    #[inline]\n-    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: true\n-        }\n-    }\n+    /// Unsafely sets the element in index to the value.\n+    ///\n+    /// This performs no bounds checks, and it is undefined behaviour\n+    /// if `index` is larger than the length of `self`. However, it\n+    /// does run the destructor at `index`. It is equivalent to\n+    /// `self[index] = val`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"foo\".to_string(), \"bar\".to_string(), \"baz\".to_string()];\n+    ///\n+    /// unsafe {\n+    ///     // `\"baz\".to_string()` is deallocated.\n+    ///     v.unsafe_set(2, \"qux\".to_string());\n+    ///\n+    ///     // Out of bounds: could cause a crash, or overwriting\n+    ///     // other data, or something else.\n+    ///     // v.unsafe_set(10, \"oops\".to_string());\n+    /// }\n+    /// ```\n+    unsafe fn unsafe_set(self, index: uint, val: T);\n \n-    #[inline]\n-    fn windows(self, size: uint) -> Windows<'a, T> {\n-        assert!(size != 0);\n-        Windows { v: self, size: size }\n-    }\n+    /// Unchecked vector index assignment.  Does not drop the\n+    /// old value and hence is only suitable when the vector\n+    /// is newly allocated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"foo\".to_string(), \"bar\".to_string()];\n+    ///\n+    /// // memory leak! `\"bar\".to_string()` is not deallocated.\n+    /// unsafe { v.init_elem(1, \"baz\".to_string()); }\n+    /// ```\n+    unsafe fn init_elem(self, i: uint, val: T);\n \n-    #[inline]\n-    fn chunks(self, size: uint) -> Chunks<'a, T> {\n-        assert!(size != 0);\n-        Chunks { v: self, size: size }\n-    }\n+    /// Copies raw bytes from `src` to `self`.\n+    ///\n+    /// This does not run destructors on the overwritten elements, and\n+    /// ignores move semantics. `self` and `src` must not\n+    /// overlap. Fails if `self` is shorter than `src`.\n+    unsafe fn copy_memory(self, src: &[T]);\n+}\n \n+impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     #[inline]\n-    fn get(&self, index: uint) -> Option<&'a T> {\n-        if index < self.len() { Some(&self[index]) } else { None }\n+    fn get_mut(self, index: uint) -> Option<&'a mut T> {\n+        if index < self.len() { Some(&mut self[index]) } else { None }\n     }\n \n     #[inline]\n-    fn head(&self) -> Option<&'a T> {\n-        if self.len() == 0 { None } else { Some(&self[0]) }\n-    }\n+    fn as_mut_slice(self) -> &'a mut [T] { self }\n \n-    #[inline]\n-    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(Slice {\n+                    data: self.as_mut_ptr().offset(start as int) as *const T,\n+                    len: (end - start)\n+                })\n+        }\n+    }\n \n     #[inline]\n-    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n+        let len = self.len();\n+        self.mut_slice(start, len)\n+    }\n \n     #[inline]\n-    fn init(&self) -> &'a [T] {\n-        self.slice(0, self.len() - 1)\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n+        self.mut_slice(0, end)\n     }\n \n     #[inline]\n-    fn initn(&self, n: uint) -> &'a [T] {\n-        self.slice(0, self.len() - n)\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+        unsafe {\n+            let len = self.len();\n+            let self2: &'a mut [T] = mem::transmute_copy(&self);\n+            (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n+        }\n     }\n \n     #[inline]\n-    fn last(&self) -> Option<&'a T> {\n-            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+    fn mut_iter(self) -> MutItems<'a, T> {\n+        unsafe {\n+            let p = self.as_mut_ptr();\n+            if mem::size_of::<T>() == 0 {\n+                MutItems{ptr: p,\n+                         end: (p as uint + self.len()) as *mut T,\n+                         marker: marker::ContravariantLifetime::<'a>,\n+                         marker2: marker::NoCopy}\n+            } else {\n+                MutItems{ptr: p,\n+                         end: p.offset(self.len() as int),\n+                         marker: marker::ContravariantLifetime::<'a>,\n+                         marker2: marker::NoCopy}\n+            }\n+        }\n     }\n \n     #[inline]\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n-        transmute(self.repr().data.offset(index as int))\n+    fn mut_last(self) -> Option<&'a mut T> {\n+        let len = self.len();\n+        if len == 0 { return None; }\n+        Some(&mut self[len - 1])\n     }\n \n     #[inline]\n-    fn as_ptr(&self) -> *const T {\n-        self.repr().data\n+    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n+        MutSplits { v: self, pred: pred, finished: false }\n     }\n \n-\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n-        let mut base : uint = 0;\n-        let mut lim : uint = self.len();\n-\n-        while lim != 0 {\n-            let ix = base + (lim >> 1);\n-            match f(&self[ix]) {\n-                Equal => return Some(ix),\n-                Less => {\n-                    base = ix + 1;\n-                    lim -= 1;\n-                }\n-                Greater => ()\n-            }\n-            lim >>= 1;\n-        }\n-        return None;\n+    #[inline]\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n+        assert!(chunk_size > 0);\n+        MutChunks { v: self, chunk_size: chunk_size }\n     }\n \n-    fn shift_ref(&mut self) -> Option<&'a T> {\n+    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n         unsafe {\n             let s: &mut Slice<T> = transmute(self);\n             match raw::shift_ptr(s) {\n-                Some(p) => Some(&*p),\n-                None => None\n+                // FIXME #13933: this `&` -> `&mut` cast is a little\n+                // dubious\n+                Some(p) => Some(&mut *(p as *mut _)),\n+                None => None,\n             }\n         }\n     }\n \n-    fn pop_ref(&mut self) -> Option<&'a T> {\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n         unsafe {\n             let s: &mut Slice<T> = transmute(self);\n             match raw::pop_ptr(s) {\n-                Some(p) => Some(&*p),\n-                None => None\n+                // FIXME #13933: this `&` -> `&mut` cast is a little\n+                // dubious\n+                Some(p) => Some(&mut *(p as *mut _)),\n+                None => None,\n             }\n         }\n     }\n+\n+    fn swap(self, a: uint, b: uint) {\n+        unsafe {\n+            // Can't take two mutable loans from one vector, so instead just cast\n+            // them to their raw pointers to do the swap\n+            let pa: *mut T = &mut self[a];\n+            let pb: *mut T = &mut self[b];\n+            ptr::swap(pa, pb);\n+        }\n+    }\n+\n+    fn reverse(self) {\n+        let mut i: uint = 0;\n+        let ln = self.len();\n+        while i < ln / 2 {\n+            self.swap(i, ln - i - 1);\n+            i += 1;\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n+        transmute((self.repr().data as *mut T).offset(index as int))\n+    }\n+\n+    #[inline]\n+    fn as_mut_ptr(self) -> *mut T {\n+        self.repr().data as *mut T\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_set(self, index: uint, val: T) {\n+        *self.unsafe_mut_ref(index) = val;\n+    }\n+\n+    #[inline]\n+    unsafe fn init_elem(self, i: uint, val: T) {\n+        ptr::write(&mut (*self.as_mut_ptr().offset(i as int)), val);\n+    }\n+\n+    #[inline]\n+    unsafe fn copy_memory(self, src: &[T]) {\n+        let len_src = src.len();\n+        assert!(self.len() >= len_src);\n+        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n+    }\n }\n \n /// Extension methods for vectors contain `PartialEq` elements.\n@@ -716,395 +802,523 @@ impl<'a, T: Ord> ImmutableOrdVector<T> for &'a [T] {\n     }\n }\n \n-/// Extension methods for vectors such that their elements are\n-/// mutable.\n-pub trait MutableVector<'a, T> {\n-    /// Returns a mutable reference to the element at the given index,\n-    /// or `None` if the index is out of bounds\n-    fn get_mut(self, index: uint) -> Option<&'a mut T>;\n-    /// Work with `self` as a mut slice.\n-    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n-    fn as_mut_slice(self) -> &'a mut [T];\n-\n-    /// Return a slice that points into another slice.\n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];\n-\n-    /**\n-     * Returns a slice of self from `start` to the end of the vec.\n-     *\n-     * Fails when `start` points outside the bounds of self.\n-     */\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T];\n-\n-    /**\n-     * Returns a slice of self from the start of the vec to `end`.\n-     *\n-     * Fails when `end` points outside the bounds of self.\n-     */\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T];\n-\n-    /// Returns an iterator that allows modifying each value\n-    fn mut_iter(self) -> MutItems<'a, T>;\n-\n-    /// Returns a mutable pointer to the last item in the vector.\n-    fn mut_last(self) -> Option<&'a mut T>;\n-\n-    /// Returns an iterator over the mutable subslices of the vector\n-    /// which are separated by elements that match `pred`.  The\n-    /// matched element is not contained in the subslices.\n-    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n-\n-    /**\n-     * Returns an iterator over `size` elements of the vector at a time.\n-     * The chunks are mutable and do not overlap. If `size` does not divide the\n-     * length of the vector, then the last chunk will not have length\n-     * `size`.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     */\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;\n-\n-    /**\n-     * Returns a mutable reference to the first element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let head = &mut self[0];\n-     *     *self = self.mut_slice_from(1);\n-     *     Some(head)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty\n-     */\n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n-\n-    /**\n-     * Returns a mutable reference to the last element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let tail = &mut self[self.len() - 1];\n-     *     *self = self.mut_slice_to(self.len() - 1);\n-     *     Some(tail)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty.\n-     */\n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n-\n-    /// Swaps two elements in a vector.\n-    ///\n-    /// Fails if `a` or `b` are out of bounds.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n-    /// ```\n-    fn swap(self, a: uint, b: uint);\n-\n-\n-    /// Divides one `&mut` into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Fails if `mid > len`.\n+/// Trait for &[T] where T is Cloneable\n+pub trait MutableCloneableVector<T> {\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1i, 2, 3, 4, 5, 6];\n+    /// use std::slice::MutableCloneableVector;\n     ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = v.mut_split_at(0);\n-    ///    assert!(left == &mut []);\n-    ///    assert!(right == &mut [1i, 2, 3, 4, 5, 6]);\n-    /// }\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n     ///\n-    /// {\n-    ///     let (left, right) = v.mut_split_at(2);\n-    ///     assert!(left == &mut [1i, 2]);\n-    ///     assert!(right == &mut [3i, 4, 5, 6]);\n-    /// }\n+    /// assert!(dst.copy_from(src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n     ///\n-    /// {\n-    ///     let (left, right) = v.mut_split_at(6);\n-    ///     assert!(left == &mut [1i, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == &mut []);\n-    /// }\n+    /// let src2 = [3i, 4, 5, 6];\n+    /// assert!(dst.copy_from(src2) == 3);\n+    /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n+    fn copy_from(self, &[T]) -> uint;\n+}\n \n-    /// Reverse the order of elements in a vector, in place.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [1i, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3i, 2, 1]);\n-    /// ```\n-    fn reverse(self);\n+impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n+    #[inline]\n+    fn copy_from(self, src: &[T]) -> uint {\n+        for (a, b) in self.mut_iter().zip(src.iter()) {\n+            a.clone_from(b);\n+        }\n+        cmp::min(self.len(), src.len())\n+    }\n+}\n \n-    /// Returns an unsafe mutable pointer to the element in index\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;\n \n-    /// Return an unsafe mutable pointer to the vector's buffer.\n-    ///\n-    /// The caller must ensure that the vector outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the vector may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[inline]\n-    fn as_mut_ptr(self) -> *mut T;\n \n-    /// Unsafely sets the element in index to the value.\n-    ///\n-    /// This performs no bounds checks, and it is undefined behaviour\n-    /// if `index` is larger than the length of `self`. However, it\n-    /// does run the destructor at `index`. It is equivalent to\n-    /// `self[index] = val`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"foo\".to_string(), \"bar\".to_string(), \"baz\".to_string()];\n-    ///\n-    /// unsafe {\n-    ///     // `\"baz\".to_string()` is deallocated.\n-    ///     v.unsafe_set(2, \"qux\".to_string());\n-    ///\n-    ///     // Out of bounds: could cause a crash, or overwriting\n-    ///     // other data, or something else.\n-    ///     // v.unsafe_set(10, \"oops\".to_string());\n-    /// }\n-    /// ```\n-    unsafe fn unsafe_set(self, index: uint, val: T);\n \n-    /// Unchecked vector index assignment.  Does not drop the\n-    /// old value and hence is only suitable when the vector\n-    /// is newly allocated.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"foo\".to_string(), \"bar\".to_string()];\n-    ///\n-    /// // memory leak! `\"bar\".to_string()` is not deallocated.\n-    /// unsafe { v.init_elem(1, \"baz\".to_string()); }\n-    /// ```\n-    unsafe fn init_elem(self, i: uint, val: T);\n+//\n+// Common traits\n+//\n \n-    /// Copies raw bytes from `src` to `self`.\n-    ///\n-    /// This does not run destructors on the overwritten elements, and\n-    /// ignores move semantics. `self` and `src` must not\n-    /// overlap. Fails if `self` is shorter than `src`.\n-    unsafe fn copy_memory(self, src: &[T]);\n+/// Any vector that can be represented as a slice.\n+pub trait Vector<T> {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n+impl<'a,T> Vector<T> for &'a [T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n+}\n+\n+impl<'a, T> Collection for &'a [T] {\n+    /// Returns the length of a vector\n     #[inline]\n-    fn get_mut(self, index: uint) -> Option<&'a mut T> {\n-        if index < self.len() { Some(&mut self[index]) } else { None }\n+    fn len(&self) -> uint {\n+        self.repr().len\n     }\n+}\n+\n+impl<'a, T> Default for &'a [T] {\n+    fn default() -> &'a [T] { &[] }\n+}\n+\n \n+\n+\n+//\n+// Iterators\n+//\n+\n+// The shared definition of the `Item` and `MutItems` iterators\n+macro_rules! iterator {\n+    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n+            #[inline]\n+            fn next(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+                unsafe {\n+                    if self.ptr == self.end {\n+                        None\n+                    } else {\n+                        let old = self.ptr;\n+                        self.ptr = if mem::size_of::<T>() == 0 {\n+                            // purposefully don't use 'ptr.offset' because for\n+                            // vectors with 0-size elements this would return the\n+                            // same pointer.\n+                            transmute(self.ptr as uint + 1)\n+                        } else {\n+                            self.ptr.offset(1)\n+                        };\n+\n+                        Some(transmute(old))\n+                    }\n+                }\n+            }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                let diff = (self.end as uint) - (self.ptr as uint);\n+                let size = mem::size_of::<T>();\n+                let exact = diff / (if size == 0 {1} else {size});\n+                (exact, Some(exact))\n+            }\n+        }\n+\n+        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+                unsafe {\n+                    if self.end == self.ptr {\n+                        None\n+                    } else {\n+                        self.end = if mem::size_of::<T>() == 0 {\n+                            // See above for why 'ptr.offset' isn't used\n+                            transmute(self.end as uint - 1)\n+                        } else {\n+                            self.end.offset(-1)\n+                        };\n+                        Some(transmute(self.end))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Immutable slice iterator\n+pub struct Items<'a, T> {\n+    ptr: *const T,\n+    end: *const T,\n+    marker: marker::ContravariantLifetime<'a>\n+}\n+\n+iterator!{struct Items -> *const T, &'a T}\n+\n+impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n+\n+impl<'a, T> Clone for Items<'a, T> {\n+    fn clone(&self) -> Items<'a, T> { *self }\n+}\n+\n+impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     #[inline]\n-    fn as_mut_slice(self) -> &'a mut [T] { self }\n+    fn indexable(&self) -> uint {\n+        let (exact, _) = self.size_hint();\n+        exact\n+    }\n \n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n+    #[inline]\n+    fn idx(&mut self, index: uint) -> Option<&'a T> {\n         unsafe {\n-            transmute(Slice {\n-                    data: self.as_mut_ptr().offset(start as int) as *const T,\n-                    len: (end - start)\n-                })\n+            if index < self.indexable() {\n+                transmute(self.ptr.offset(index as int))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+/// Mutable slice iterator\n+pub struct MutItems<'a, T> {\n+    ptr: *mut T,\n+    end: *mut T,\n+    marker: marker::ContravariantLifetime<'a>,\n+    marker2: marker::NoCopy\n+}\n+\n+iterator!{struct MutItems -> *mut T, &'a mut T}\n+\n+impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n+\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function.\n+pub struct Splits<'a, T> {\n+    v: &'a [T],\n+    pred: |t: &T|: 'a -> bool,\n+    finished: bool\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.finished { return None; }\n+\n+        match self.v.iter().position(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(0, idx));\n+                self.v = self.v.slice(idx + 1, self.v.len());\n+                ret\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.finished { return None; }\n+\n+        match self.v.iter().rposition(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n+                self.v = self.v.slice(0, idx);\n+                ret\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator over the subslices of the vector which are separated\n+/// by elements that match `pred`.\n+pub struct MutSplits<'a, T> {\n+    v: &'a mut [T],\n+    pred: |t: &T|: 'a -> bool,\n+    finished: bool\n+}\n+\n+impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished { return None; }\n+\n+        let pred = &mut self.pred;\n+        match self.v.iter().position(|x| (*pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let len = tmp.len();\n+                let (head, tail) = tmp.mut_split_at(len);\n+                self.v = tail;\n+                Some(head)\n+            }\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.mut_split_at(idx);\n+                self.v = tail.mut_slice_from(1);\n+                Some(head)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // if the predicate doesn't match anything, we yield one slice\n+            // if it matches every element, we yield len+1 empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished { return None; }\n+\n+        let pred = &mut self.pred;\n+        match self.v.iter().rposition(|x| (*pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                Some(tmp)\n+            }\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.mut_split_at(idx);\n+                self.v = head;\n+                Some(tail.mut_slice_from(1))\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function, splitting at most a fixed number of times.\n+pub struct SplitsN<'a, T> {\n+    iter: Splits<'a, T>,\n+    count: uint,\n+    invert: bool\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.count == 0 {\n+            if self.iter.finished {\n+                None\n+            } else {\n+                self.iter.finished = true;\n+                Some(self.iter.v)\n+            }\n+        } else {\n+            self.count -= 1;\n+            if self.invert { self.iter.next_back() } else { self.iter.next() }\n         }\n     }\n \n     #[inline]\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n-        let len = self.len();\n-        self.mut_slice(start, len)\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.iter.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n+        }\n     }\n+}\n+\n+/// An iterator over the (overlapping) slices of length `size` within\n+/// a vector.\n+#[deriving(Clone)]\n+pub struct Windows<'a, T> {\n+    v: &'a [T],\n+    size: uint\n+}\n \n+impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n     #[inline]\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n-        self.mut_slice(0, end)\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let ret = Some(self.v.slice(0, self.size));\n+            self.v = self.v.slice(1, self.v.len());\n+            ret\n+        }\n     }\n \n     #[inline]\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        unsafe {\n-            let len = self.len();\n-            let self2: &'a mut [T] = mem::transmute_copy(&self);\n-            (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.size > self.v.len() {\n+            (0, Some(0))\n+        } else {\n+            let x = self.v.len() - self.size;\n+            (x.saturating_add(1), x.checked_add(&1u))\n         }\n     }\n+}\n+\n+/// An iterator over a vector in (non-overlapping) chunks (`size`\n+/// elements at a time).\n+///\n+/// When the vector len is not evenly divided by the chunk size,\n+/// the last slice of the iteration will be the remainder.\n+#[deriving(Clone)]\n+pub struct Chunks<'a, T> {\n+    v: &'a [T],\n+    size: uint\n+}\n \n+impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n-    fn mut_iter(self) -> MutItems<'a, T> {\n-        unsafe {\n-            let p = self.as_mut_ptr();\n-            if mem::size_of::<T>() == 0 {\n-                MutItems{ptr: p,\n-                         end: (p as uint + self.len()) as *mut T,\n-                         marker: marker::ContravariantLifetime::<'a>,\n-                         marker2: marker::NoCopy}\n-            } else {\n-                MutItems{ptr: p,\n-                         end: p.offset(self.len() as int),\n-                         marker: marker::ContravariantLifetime::<'a>,\n-                         marker2: marker::NoCopy}\n-            }\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let chunksz = cmp::min(self.v.len(), self.size);\n+            let (fst, snd) = (self.v.slice_to(chunksz),\n+                              self.v.slice_from(chunksz));\n+            self.v = snd;\n+            Some(fst)\n         }\n     }\n \n     #[inline]\n-    fn mut_last(self) -> Option<&'a mut T> {\n-        let len = self.len();\n-        if len == 0 { return None; }\n-        Some(&mut self[len - 1])\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.v.len() == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = div_rem(self.v.len(), self.size);\n+            let n = if rem > 0 { n+1 } else { n };\n+            (n, Some(n))\n+        }\n     }\n+}\n \n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n-    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n-        MutSplits { v: self, pred: pred, finished: false }\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.size;\n+            let chunksz = if remainder != 0 { remainder } else { self.size };\n+            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n+                              self.v.slice_from(self.v.len() - chunksz));\n+            self.v = fst;\n+            Some(snd)\n+        }\n     }\n+}\n \n+impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n-        assert!(chunk_size > 0);\n-        MutChunks { v: self, chunk_size: chunk_size }\n+    fn indexable(&self) -> uint {\n+        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n     }\n \n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            match raw::shift_ptr(s) {\n-                // FIXME #13933: this `&` -> `&mut` cast is a little\n-                // dubious\n-                Some(p) => Some(&mut *(p as *mut _)),\n-                None => None,\n-            }\n-        }\n-    }\n+    #[inline]\n+    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n+        if index < self.indexable() {\n+            let lo = index * self.size;\n+            let mut hi = lo + self.size;\n+            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n \n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            match raw::pop_ptr(s) {\n-                // FIXME #13933: this `&` -> `&mut` cast is a little\n-                // dubious\n-                Some(p) => Some(&mut *(p as *mut _)),\n-                None => None,\n-            }\n+            Some(self.v.slice(lo, hi))\n+        } else {\n+            None\n         }\n     }\n+}\n \n-    fn swap(self, a: uint, b: uint) {\n-        unsafe {\n-            // Can't take two mutable loans from one vector, so instead just cast\n-            // them to their raw pointers to do the swap\n-            let pa: *mut T = &mut self[a];\n-            let pb: *mut T = &mut self[b];\n-            ptr::swap(pa, pb);\n-        }\n-    }\n+/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n+/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n+/// the remainder.\n+pub struct MutChunks<'a, T> {\n+    v: &'a mut [T],\n+    chunk_size: uint\n+}\n \n-    fn reverse(self) {\n-        let mut i: uint = 0;\n-        let ln = self.len();\n-        while i < ln / 2 {\n-            self.swap(i, ln - i - 1);\n-            i += 1;\n+impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let sz = cmp::min(self.v.len(), self.chunk_size);\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.mut_split_at(sz);\n+            self.v = tail;\n+            Some(head)\n         }\n     }\n \n     #[inline]\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n-        transmute((self.repr().data as *mut T).offset(index as int))\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.v.len() == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = div_rem(self.v.len(), self.chunk_size);\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n     }\n+}\n \n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n-    fn as_mut_ptr(self) -> *mut T {\n-        self.repr().data as *mut T\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.chunk_size;\n+            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.mut_split_at(tmp_len - sz);\n+            self.v = head;\n+            Some(tail)\n+        }\n     }\n+}\n \n-    #[inline]\n-    unsafe fn unsafe_set(self, index: uint, val: T) {\n-        *self.unsafe_mut_ref(index) = val;\n-    }\n \n-    #[inline]\n-    unsafe fn init_elem(self, i: uint, val: T) {\n-        ptr::write(&mut (*self.as_mut_ptr().offset(i as int)), val);\n-    }\n \n-    #[inline]\n-    unsafe fn copy_memory(self, src: &[T]) {\n-        let len_src = src.len();\n-        assert!(self.len() >= len_src);\n-        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n-    }\n-}\n \n-/// Trait for &[T] where T is Cloneable\n-pub trait MutableCloneableVector<T> {\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::slice::MutableCloneableVector;\n-    ///\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n-    ///\n-    /// assert!(dst.copy_from(src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.copy_from(src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n-    /// ```\n-    fn copy_from(self, &[T]) -> uint;\n-}\n+//\n+// Free functions\n+//\n \n-impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n-    #[inline]\n-    fn copy_from(self, src: &[T]) -> uint {\n-        for (a, b) in self.mut_iter().zip(src.iter()) {\n-            a.clone_from(b);\n-        }\n-        cmp::min(self.len(), src.len())\n+/**\n+ * Converts a pointer to A into a slice of length 1 (without copying).\n+ */\n+pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n+    unsafe {\n+        transmute(Slice { data: s, len: 1 })\n+    }\n+}\n+\n+/**\n+ * Converts a pointer to A into a slice of length 1 (without copying).\n+ */\n+pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n+    unsafe {\n+        let ptr: *const A = transmute(s);\n+        transmute(Slice { data: ptr, len: 1 })\n     }\n }\n \n+\n+\n+\n+//\n+// Submodules\n+//\n+\n /// Unsafe operations\n pub mod raw {\n     use mem::transmute;\n@@ -1201,224 +1415,66 @@ pub mod bytes {\n     }\n }\n \n-/// Immutable slice iterator\n-pub struct Items<'a, T> {\n-    ptr: *const T,\n-    end: *const T,\n-    marker: marker::ContravariantLifetime<'a>\n-}\n-\n-/// Mutable slice iterator\n-pub struct MutItems<'a, T> {\n-    ptr: *mut T,\n-    end: *mut T,\n-    marker: marker::ContravariantLifetime<'a>,\n-    marker2: marker::NoCopy\n-}\n \n-macro_rules! iterator {\n-    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n-            #[inline]\n-            fn next(&mut self) -> Option<$elem> {\n-                // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    if self.ptr == self.end {\n-                        None\n-                    } else {\n-                        let old = self.ptr;\n-                        self.ptr = if mem::size_of::<T>() == 0 {\n-                            // purposefully don't use 'ptr.offset' because for\n-                            // vectors with 0-size elements this would return the\n-                            // same pointer.\n-                            transmute(self.ptr as uint + 1)\n-                        } else {\n-                            self.ptr.offset(1)\n-                        };\n \n-                        Some(transmute(old))\n-                    }\n-                }\n-            }\n \n-            #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n-                let diff = (self.end as uint) - (self.ptr as uint);\n-                let size = mem::size_of::<T>();\n-                let exact = diff / (if size == 0 {1} else {size});\n-                (exact, Some(exact))\n-            }\n-        }\n+//\n+// Boilerplate traits\n+//\n \n-        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$elem> {\n-                // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    if self.end == self.ptr {\n-                        None\n-                    } else {\n-                        self.end = if mem::size_of::<T>() == 0 {\n-                            // See above for why 'ptr.offset' isn't used\n-                            transmute(self.end as uint - 1)\n-                        } else {\n-                            self.end.offset(-1)\n-                        };\n-                        Some(transmute(self.end))\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n+#[allow(missing_doc)]\n+pub mod traits {\n+    use super::*;\n \n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n-    #[inline]\n-    fn indexable(&self) -> uint {\n-        let (exact, _) = self.size_hint();\n-        exact\n-    }\n+    use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Equiv};\n+    use iter::order;\n+    use collections::Collection;\n+    use option::Option;\n \n-    #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a T> {\n-        unsafe {\n-            if index < self.indexable() {\n-                transmute(self.ptr.offset(index as int))\n-            } else {\n-                None\n-            }\n+    impl<'a,T:PartialEq> PartialEq for &'a [T] {\n+        fn eq(&self, other: & &'a [T]) -> bool {\n+            self.len() == other.len() &&\n+                order::eq(self.iter(), other.iter())\n+        }\n+        fn ne(&self, other: & &'a [T]) -> bool {\n+            self.len() != other.len() ||\n+                order::ne(self.iter(), other.iter())\n         }\n     }\n-}\n-\n-iterator!{struct Items -> *const T, &'a T}\n-\n-impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n-impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n-\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n-}\n-\n-iterator!{struct MutItems -> *mut T, &'a mut T}\n-\n-/// An iterator over the subslices of the vector which are separated\n-/// by elements that match `pred`.\n-pub struct MutSplits<'a, T> {\n-    v: &'a mut [T],\n-    pred: |t: &T|: 'a -> bool,\n-    finished: bool\n-}\n \n-impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished { return None; }\n+    impl<'a,T:Eq> Eq for &'a [T] {}\n \n-        let pred = &mut self.pred;\n-        match self.v.iter().position(|x| (*pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let len = tmp.len();\n-                let (head, tail) = tmp.mut_split_at(len);\n-                self.v = tail;\n-                Some(head)\n-            }\n-            Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.mut_split_at(idx);\n-                self.v = tail.mut_slice_from(1);\n-                Some(head)\n-            }\n-        }\n+    impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for &'a [T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n     }\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished {\n-            (0, Some(0))\n-        } else {\n-            // if the predicate doesn't match anything, we yield one slice\n-            // if it matches every element, we yield len+1 empty slices.\n-            (1, Some(self.v.len() + 1))\n+    impl<'a,T:Ord> Ord for &'a [T] {\n+        fn cmp(&self, other: & &'a [T]) -> Ordering {\n+            order::cmp(self.iter(), other.iter())\n         }\n     }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished { return None; }\n \n-        let pred = &mut self.pred;\n-        match self.v.iter().rposition(|x| (*pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                Some(tmp)\n-            }\n-            Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.mut_split_at(idx);\n-                self.v = head;\n-                Some(tail.mut_slice_from(1))\n-            }\n+    impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n+        #[inline]\n+        fn partial_cmp(&self, other: &&'a [T]) -> Option<Ordering> {\n+            order::partial_cmp(self.iter(), other.iter())\n         }\n-    }\n-}\n-\n-/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n-/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n-/// the remainder.\n-pub struct MutChunks<'a, T> {\n-    v: &'a mut [T],\n-    chunk_size: uint\n-}\n-\n-impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let sz = cmp::min(self.v.len(), self.chunk_size);\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.mut_split_at(sz);\n-            self.v = tail;\n-            Some(head)\n+        #[inline]\n+        fn lt(&self, other: & &'a [T]) -> bool {\n+            order::lt(self.iter(), other.iter())\n         }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.v.len() == 0 {\n-            (0, Some(0))\n-        } else {\n-            let (n, rem) = div_rem(self.v.len(), self.chunk_size);\n-            let n = if rem > 0 { n + 1 } else { n };\n-            (n, Some(n))\n+        #[inline]\n+        fn le(&self, other: & &'a [T]) -> bool {\n+            order::le(self.iter(), other.iter())\n         }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let remainder = self.v.len() % self.chunk_size;\n-            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (head, tail) = tmp.mut_split_at(tmp_len - sz);\n-            self.v = head;\n-            Some(tail)\n+        #[inline]\n+        fn ge(&self, other: & &'a [T]) -> bool {\n+            order::ge(self.iter(), other.iter())\n+        }\n+        #[inline]\n+        fn gt(&self, other: & &'a [T]) -> bool {\n+            order::gt(self.iter(), other.iter())\n         }\n     }\n }\n-\n-impl<'a, T> Default for &'a [T] {\n-    fn default() -> &'a [T] { &[] }\n-}"}]}