{"sha": "4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmYmU0MzRjNWMxMGQ5YTA1NTBkYjRhZTkzYWFhYzNhMGVkOTgxNmU=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-26T23:38:10Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-01-07T14:41:48Z"}, "message": "Poison any `MemPlace` created from a zst Operand (or otherwise via `MPlaceTy::dangling`) so you can't get the address back out.", "tree": {"sha": "cd038c133057361ae1ebe55556318693cd948f80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd038c133057361ae1ebe55556318693cd948f80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e", "html_url": "https://github.com/rust-lang/rust/commit/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cac6f4c12db5fadff650267a8456d5835d19b136", "url": "https://api.github.com/repos/rust-lang/rust/commits/cac6f4c12db5fadff650267a8456d5835d19b136", "html_url": "https://github.com/rust-lang/rust/commit/cac6f4c12db5fadff650267a8456d5835d19b136"}], "stats": {"total": 145, "additions": 102, "deletions": 43}, "files": [{"sha": "c5c2a6769e44ae6d2d62b07d556a5be151ca0bcd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e", "patch": "@@ -20,7 +20,7 @@ use rustc_macros::HashStable;\n use rustc_span::source_map::{self, Span, DUMMY_SP};\n \n use super::{\n-    Immediate, MPlaceTy, Machine, MemPlace, Memory, OpTy, Operand, Place, PlaceTy,\n+    Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n     ScalarMaybeUndef, StackPopInfo,\n };\n \n@@ -393,7 +393,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This can fail to provide an answer for extern types.\n     pub(super) fn size_and_align_of(\n         &self,\n-        metadata: Option<Scalar<M::PointerTag>>,\n+        metadata: MemPlaceMeta<M::PointerTag>,\n         layout: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n         if !layout.is_unsized() {\n@@ -465,14 +465,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Ok(Some((size, align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\");\n+                let vtable = metadata.unwrap_unsized();\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }\n \n             ty::Slice(_) | ty::Str => {\n-                let len =\n-                    metadata.expect(\"slice fat ptr must have length\").to_machine_usize(self)?;\n+                let len = metadata.unwrap_unsized().to_machine_usize(self)?;\n                 let elem = layout.field(self, 0)?;\n \n                 // Make sure the slice is not too big.\n@@ -818,8 +817,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                 \" by align({}){} ref:\",\n                                 mplace.align.bytes(),\n                                 match mplace.meta {\n-                                    Some(meta) => format!(\" meta({:?})\", meta),\n-                                    None => String::new(),\n+                                    MemPlaceMeta::Unsized(meta) => format!(\" meta({:?})\", meta),\n+                                    MemPlaceMeta::Poison | MemPlaceMeta::None => String::new(),\n                                 }\n                             )\n                             .unwrap();"}, {"sha": "56e489d0bd59070cc566d446a19fe96ef6c14cc1", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e", "patch": "@@ -193,7 +193,7 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n             {\n                 // Validation has already errored on an invalid vtable pointer so we can safely not\n                 // do anything if this is not a real pointer.\n-                if let Scalar::Ptr(vtable) = mplace.meta.unwrap() {\n+                if let Scalar::Ptr(vtable) = mplace.meta.unwrap_unsized() {\n                     // Explicitly choose `Immutable` here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n                     self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n@@ -226,7 +226,8 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n                     | (InternMode::Const, hir::Mutability::Mut) => match referenced_ty.kind {\n                         ty::Array(_, n)\n                             if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n-                        ty::Slice(_) if mplace.meta.unwrap().to_machine_usize(self.ecx)? == 0 => {}\n+                        ty::Slice(_)\n+                            if mplace.meta.unwrap_unsized().to_machine_usize(self.ecx)? == 0 => {}\n                         _ => bug!(\"const qualif failed to prevent mutable references\"),\n                     },\n                 }"}, {"sha": "2e8fbb95ca2e58d143982323811de6817f27d678", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e", "patch": "@@ -20,7 +20,7 @@ pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one pla\n \n pub use self::eval_context::{Frame, InterpCx, LocalState, LocalValue, StackPopCleanup};\n \n-pub use self::place::{MPlaceTy, MemPlace, Place, PlaceTy};\n+pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n \n pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n "}, {"sha": "6d848092defe535c751ea80a63253e3bdd3cdce4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 72, "deletions": 26, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e", "patch": "@@ -20,6 +20,45 @@ use super::{\n     RawConst, Scalar, ScalarMaybeUndef,\n };\n \n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n+pub enum MemPlaceMeta<Tag = (), Id = AllocId> {\n+    Unsized(Scalar<Tag, Id>),\n+    /// `Sized` types or unsized `extern type`\n+    None,\n+    /// The address of this place may not be taken. This protects the `MemPlace` from coming from\n+    /// a ZST Operand with a backing allocation and being converted to an integer address. This\n+    /// should be impossible, because you can't take the address of an operand, but this is a second\n+    /// protection layer ensuring that we don't mess up.\n+    Poison,\n+}\n+\n+impl<Tag, Id> MemPlaceMeta<Tag, Id> {\n+    pub fn unwrap_unsized(self) -> Scalar<Tag, Id> {\n+        match self {\n+            Self::Unsized(s) => s,\n+            Self::None | Self::Poison => {\n+                bug!(\"expected wide pointer extra data (e.g. slice length or trait object vtable)\")\n+            }\n+        }\n+    }\n+    fn is_unsized(self) -> bool {\n+        match self {\n+            Self::Unsized(_) => true,\n+            Self::None | Self::Poison => false,\n+        }\n+    }\n+}\n+\n+impl<Tag> MemPlaceMeta<Tag> {\n+    pub fn erase_tag(self) -> MemPlaceMeta<()> {\n+        match self {\n+            Self::Unsized(s) => MemPlaceMeta::Unsized(s.erase_tag()),\n+            Self::None => MemPlaceMeta::None,\n+            Self::Poison => MemPlaceMeta::Poison,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n pub struct MemPlace<Tag = (), Id = AllocId> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n@@ -30,7 +69,7 @@ pub struct MemPlace<Tag = (), Id = AllocId> {\n     /// Metadata for unsized places. Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g., `extern type`).\n-    pub meta: Option<Scalar<Tag, Id>>,\n+    pub meta: MemPlaceMeta<Tag, Id>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n@@ -88,16 +127,12 @@ impl<Tag> MemPlace<Tag> {\n \n     #[inline]\n     pub fn erase_tag(self) -> MemPlace {\n-        MemPlace {\n-            ptr: self.ptr.erase_tag(),\n-            align: self.align,\n-            meta: self.meta.map(Scalar::erase_tag),\n-        }\n+        MemPlace { ptr: self.ptr.erase_tag(), align: self.align, meta: self.meta.erase_tag() }\n     }\n \n     #[inline(always)]\n     pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n-        MemPlace { ptr, align, meta: None }\n+        MemPlace { ptr, align, meta: MemPlaceMeta::None }\n     }\n \n     /// Produces a Place that will error if attempted to be read from or written to\n@@ -116,15 +151,19 @@ impl<Tag> MemPlace<Tag> {\n     #[inline(always)]\n     pub fn to_ref(self) -> Immediate<Tag> {\n         match self.meta {\n-            None => Immediate::Scalar(self.ptr.into()),\n-            Some(meta) => Immediate::ScalarPair(self.ptr.into(), meta.into()),\n+            MemPlaceMeta::None => Immediate::Scalar(self.ptr.into()),\n+            MemPlaceMeta::Unsized(meta) => Immediate::ScalarPair(self.ptr.into(), meta.into()),\n+            MemPlaceMeta::Poison => bug!(\n+                \"MPlaceTy::dangling may never be used to produce a \\\n+                place that will have the address of its pointee taken\"\n+            ),\n         }\n     }\n \n     pub fn offset(\n         self,\n         offset: Size,\n-        meta: Option<Scalar<Tag>>,\n+        meta: MemPlaceMeta<Tag>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n         Ok(MemPlace {\n@@ -158,7 +197,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     pub fn offset(\n         self,\n         offset: Size,\n-        meta: Option<Scalar<Tag>>,\n+        meta: MemPlaceMeta<Tag>,\n         layout: TyLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n@@ -175,7 +214,9 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind {\n-                ty::Slice(..) | ty::Str => return self.mplace.meta.unwrap().to_machine_usize(cx),\n+                ty::Slice(..) | ty::Str => {\n+                    return self.mplace.meta.unwrap_unsized().to_machine_usize(cx);\n+                }\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n@@ -191,7 +232,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     #[inline]\n     pub(super) fn vtable(self) -> Scalar<Tag> {\n         match self.layout.ty.kind {\n-            ty::Dynamic(..) => self.mplace.meta.unwrap(),\n+            ty::Dynamic(..) => self.mplace.meta.unwrap_unsized(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n         }\n     }\n@@ -276,8 +317,10 @@ where\n             val.layout.ty.builtin_deref(true).expect(\"`ref_to_mplace` called on non-ptr type\").ty;\n         let layout = self.layout_of(pointee_type)?;\n         let (ptr, meta) = match *val {\n-            Immediate::Scalar(ptr) => (ptr.not_undef()?, None),\n-            Immediate::ScalarPair(ptr, meta) => (ptr.not_undef()?, Some(meta.not_undef()?)),\n+            Immediate::Scalar(ptr) => (ptr.not_undef()?, MemPlaceMeta::None),\n+            Immediate::ScalarPair(ptr, meta) => {\n+                (ptr.not_undef()?, MemPlaceMeta::Unsized(meta.not_undef()?))\n+            }\n         };\n \n         let mplace = MemPlace {\n@@ -318,7 +361,7 @@ where\n     ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n         let size = size.unwrap_or_else(|| {\n             assert!(!place.layout.is_unsized());\n-            assert!(place.meta.is_none());\n+            assert!(!place.meta.is_unsized());\n             place.layout.size\n         });\n         self.memory.check_ptr_access(place.ptr, size, place.align)\n@@ -411,7 +454,7 @@ where\n         } else {\n             // base.meta could be present; we might be accessing a sized field of an unsized\n             // struct.\n-            (None, offset)\n+            (MemPlaceMeta::None, offset)\n         };\n \n         // We do not look at `base.layout.align` nor `field_layout.align`, unlike\n@@ -433,7 +476,7 @@ where\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n-        Ok((0..len).map(move |i| base.offset(i * stride, None, layout, dl)))\n+        Ok((0..len).map(move |i| base.offset(i * stride, MemPlaceMeta::None, layout, dl)))\n     }\n \n     fn mplace_subslice(\n@@ -466,10 +509,10 @@ where\n         let (meta, ty) = match base.layout.ty.kind {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n-            ty::Array(inner, _) => (None, self.tcx.mk_array(inner, inner_len)),\n+            ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(inner, inner_len)),\n             ty::Slice(..) => {\n                 let len = Scalar::from_uint(inner_len, self.pointer_size());\n-                (Some(len), base.layout.ty)\n+                (MemPlaceMeta::Unsized(len), base.layout.ty)\n             }\n             _ => bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n         };\n@@ -483,7 +526,7 @@ where\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n-        assert!(base.meta.is_none());\n+        assert!(!base.meta.is_unsized());\n         Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n     }\n \n@@ -977,7 +1020,7 @@ where\n     pub fn force_allocation_maybe_sized(\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n-        meta: Option<Scalar<M::PointerTag>>,\n+        meta: MemPlaceMeta<M::PointerTag>,\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n@@ -1022,7 +1065,7 @@ where\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        Ok(self.force_allocation_maybe_sized(place, None)?.0)\n+        Ok(self.force_allocation_maybe_sized(place, MemPlaceMeta::None)?.0)\n     }\n \n     pub fn allocate(\n@@ -1042,8 +1085,11 @@ where\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate_static_bytes(str.as_bytes(), kind);\n         let meta = Scalar::from_uint(str.len() as u128, self.pointer_size());\n-        let mplace =\n-            MemPlace { ptr: ptr.into(), align: Align::from_bytes(1).unwrap(), meta: Some(meta) };\n+        let mplace = MemPlace {\n+            ptr: ptr.into(),\n+            align: Align::from_bytes(1).unwrap(),\n+            meta: MemPlaceMeta::Unsized(meta),\n+        };\n \n         let layout = self.layout_of(self.tcx.mk_static_str()).unwrap();\n         MPlaceTy { mplace, layout }\n@@ -1151,7 +1197,7 @@ where\n             assert_eq!(align, layout.align.abi);\n         }\n \n-        let mplace = MPlaceTy { mplace: MemPlace { meta: None, ..*mplace }, layout };\n+        let mplace = MPlaceTy { mplace: MemPlace { meta: MemPlaceMeta::None, ..*mplace }, layout };\n         Ok((instance, mplace))\n     }\n }"}, {"sha": "120baaf3be68a9451ea7c4b96000be76349a308f", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e", "patch": "@@ -23,7 +23,9 @@ use rustc_span::source_map::Span;\n use syntax::ast::Mutability;\n \n use super::eval_context::{LocalState, StackPopCleanup};\n-use super::{Frame, Immediate, LocalValue, MemPlace, Memory, Operand, Place, ScalarMaybeUndef};\n+use super::{\n+    Frame, Immediate, LocalValue, MemPlace, MemPlaceMeta, Memory, Operand, Place, ScalarMaybeUndef,\n+};\n use crate::const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n@@ -205,6 +207,14 @@ impl_snapshot_for!(\n     }\n );\n \n+impl_snapshot_for!(\n+    enum MemPlaceMeta {\n+        Unsized(s),\n+        None,\n+        Poison,\n+    }\n+);\n+\n impl_snapshot_for!(struct MemPlace {\n     ptr,\n     meta,"}, {"sha": "7a7f4314020759f89f1dd44395e4484ad64ecbf5", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=4fbe434c5c10d9a0550db4ae93aaac3a0ed9816e", "patch": "@@ -16,7 +16,7 @@ use rustc_span::symbol::{sym, Symbol};\n use std::hash::Hash;\n \n use super::{\n-    CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, Scalar,\n+    CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine, MemPlaceMeta, OpTy,\n     ValueVisitor,\n };\n \n@@ -246,13 +246,13 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n \n     fn check_wide_ptr_meta(\n         &mut self,\n-        meta: Option<Scalar<M::PointerTag>>,\n+        meta: MemPlaceMeta<M::PointerTag>,\n         pointee: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind {\n             ty::Dynamic(..) => {\n-                let vtable = meta.unwrap();\n+                let vtable = meta.unwrap_unsized();\n                 try_validation!(\n                     self.ecx.memory.check_ptr_access(\n                         vtable,\n@@ -276,7 +276,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n             }\n             ty::Slice(..) | ty::Str => {\n                 let _len = try_validation!(\n-                    meta.unwrap().to_machine_usize(self.ecx),\n+                    meta.unwrap_unsized().to_machine_usize(self.ecx),\n                     \"non-integer slice length in wide pointer\",\n                     self.path\n                 );\n@@ -572,8 +572,11 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         match op.layout.ty.kind {\n             ty::Str => {\n                 let mplace = op.assert_mem_place(self.ecx); // strings are never immediate\n-                try_validation!(self.ecx.read_str(mplace),\n-                    \"uninitialized or non-UTF-8 data in str\", self.path);\n+                try_validation!(\n+                    self.ecx.read_str(mplace),\n+                    \"uninitialized or non-UTF-8 data in str\",\n+                    self.path\n+                );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)\n                 if {"}]}