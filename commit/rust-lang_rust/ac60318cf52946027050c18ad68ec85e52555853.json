{"sha": "ac60318cf52946027050c18ad68ec85e52555853", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNjAzMThjZjUyOTQ2MDI3MDUwYzE4YWQ2OGVjODVlNTI1NTU4NTM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-25T08:49:58Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:51Z"}, "message": "trans: Only mutate ArgTy's in C ABI handling, don't create them.", "tree": {"sha": "e27f6d0eee89ab48c0f315e7f1776b4660ac941f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e27f6d0eee89ab48c0f315e7f1776b4660ac941f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac60318cf52946027050c18ad68ec85e52555853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac60318cf52946027050c18ad68ec85e52555853", "html_url": "https://github.com/rust-lang/rust/commit/ac60318cf52946027050c18ad68ec85e52555853", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac60318cf52946027050c18ad68ec85e52555853/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03942056aac826c89a94d47239244277cc360714", "url": "https://api.github.com/repos/rust-lang/rust/commits/03942056aac826c89a94d47239244277cc360714", "html_url": "https://github.com/rust-lang/rust/commit/03942056aac826c89a94d47239244277cc360714"}], "stats": {"total": 359, "additions": 179, "deletions": 180}, "files": [{"sha": "d802a41ed6978b1e54570cff68debe682ac02ea9", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=ac60318cf52946027050c18ad68ec85e52555853", "patch": "@@ -72,44 +72,22 @@ pub struct ArgType {\n }\n \n impl ArgType {\n-    pub fn direct(ty: Type, cast: Option<Type>,\n-                            pad: Option<Type>,\n-                            attr: Option<llvm::Attribute>) -> ArgType {\n+    fn new(ty: Type) -> ArgType {\n         ArgType {\n             kind: Direct,\n             ty: ty,\n-            cast: cast,\n-            pad: pad,\n-            attr: attr\n-        }\n-    }\n-\n-    pub fn indirect(ty: Type, attr: Option<llvm::Attribute>) -> ArgType {\n-        ArgType {\n-            kind: Indirect,\n-            ty: ty,\n-            cast: Option::None,\n-            pad: Option::None,\n-            attr: attr\n-        }\n-    }\n-\n-    pub fn ignore(ty: Type) -> ArgType {\n-        ArgType {\n-            kind: Ignore,\n-            ty: ty,\n             cast: None,\n             pad: None,\n-            attr: None,\n+            attr: None\n         }\n     }\n \n     pub fn is_indirect(&self) -> bool {\n-        return self.kind == Indirect;\n+        self.kind == Indirect\n     }\n \n     pub fn is_ignore(&self) -> bool {\n-        return self.kind == Ignore;\n+        self.kind == Ignore\n     }\n }\n \n@@ -200,17 +178,15 @@ impl FnType {\n         for ty in inputs.iter().chain(extra_args.iter()) {\n             let llty = c_type_of(ccx, ty);\n             if type_is_fat_ptr(ccx.tcx(), ty) {\n-                args.extend(llty.field_types().into_iter().map(|llty| {\n-                    ArgType::direct(llty, None, None, None)\n-                }));\n+                args.extend(llty.field_types().into_iter().map(ArgType::new));\n             } else {\n-                args.push(ArgType::direct(llty, None, None, None));\n+                args.push(ArgType::new(llty));\n             }\n         }\n \n         let mut fty = FnType {\n             args: args,\n-            ret: ArgType::direct(rty, None, None, None),\n+            ret: ArgType::new(rty),\n             variadic: sig.variadic,\n             cconv: cconv\n         };"}, {"sha": "c98c53894cae7fb9746ca92afaa2fa39823cdc8d", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=ac60318cf52946027050c18ad68ec85e52555853", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n-use trans::abi::{FnType, ArgType};\n+use trans::abi::{FnType, ArgType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -161,16 +161,18 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n     })\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        if ret.ty == Type::i1(ccx) {\n+            ret.attr = Some(Attribute::ZExt)\n+        }\n+        return;\n     }\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n-        let llty = Type::array(&base_ty, members);\n-        return ArgType::direct(ty, Some(llty), None, None);\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n+        ret.cast = Some(Type::array(&base_ty, members));\n+        return;\n     }\n-    let size = ty_size(ty);\n+    let size = ty_size(ret.ty);\n     if size <= 16 {\n         let llty = if size <= 1 {\n             Type::i8(ccx)\n@@ -183,21 +185,25 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         } else {\n             Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n         };\n-        return ArgType::direct(ty, Some(llty), None, None);\n+        ret.cast = Some(llty);\n+        return;\n     }\n-    ArgType::indirect(ty, Some(Attribute::StructRet))\n+    ret.kind = Indirect;\n+    ret.attr = Some(Attribute::StructRet);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if is_reg_ty(arg.ty) {\n+        if arg.ty == Type::i1(ccx) {\n+            arg.attr = Some(Attribute::ZExt);\n+        }\n+        return;\n     }\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n-        let llty = Type::array(&base_ty, members);\n-        return ArgType::direct(ty, Some(llty), None, None);\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n+        arg.cast = Some(Type::array(&base_ty, members));\n+        return;\n     }\n-    let size = ty_size(ty);\n+    let size = ty_size(arg.ty);\n     if size <= 16 {\n         let llty = if size == 0 {\n             Type::array(&Type::i64(ccx), 0)\n@@ -212,9 +218,10 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         } else {\n             Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n         };\n-        return ArgType::direct(ty, Some(llty), None, None);\n+        arg.cast = Some(llty);\n+        return;\n     }\n-    ArgType::indirect(ty, None)\n+    arg.kind = Indirect;\n }\n \n fn is_reg_ty(ty: Type) -> bool {\n@@ -230,10 +237,10 @@ fn is_reg_ty(ty: Type) -> bool {\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     if fty.ret.ty != Type::void(ccx) {\n-        fty.ret = classify_ret_ty(ccx, fty.ret.ty);\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n-        *arg = classify_arg_ty(ccx, arg.ty);\n+        classify_arg_ty(ccx, arg);\n     }\n }"}, {"sha": "abdc5bbd79f98f828aeb20c6a594367eda206197", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=ac60318cf52946027050c18ad68ec85e52555853", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n-use trans::abi::{FnType, ArgType};\n+use trans::abi::{FnType, ArgType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -129,12 +129,14 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n     }\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType, align_fn: TyAlignFn) {\n+    if is_reg_ty(ret.ty) {\n+        if ret.ty == Type::i1(ccx) {\n+            ret.attr = Some(Attribute::ZExt);\n+        }\n+        return;\n     }\n-    let size = ty_size(ty, align_fn);\n+    let size = ty_size(ret.ty, align_fn);\n     if size <= 4 {\n         let llty = if size <= 1 {\n             Type::i8(ccx)\n@@ -143,24 +145,28 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType\n         } else {\n             Type::i32(ccx)\n         };\n-        return ArgType::direct(ty, Some(llty), None, None);\n+        ret.cast = Some(llty);\n+        return;\n     }\n-    ArgType::indirect(ty, Some(Attribute::StructRet))\n+    ret.kind = Indirect;\n+    ret.attr = Some(Attribute::StructRet);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, align_fn: TyAlignFn) {\n+    if is_reg_ty(arg.ty) {\n+        if arg.ty == Type::i1(ccx) {\n+            arg.attr = Some(Attribute::ZExt);\n+        }\n+        return;\n     }\n-    let align = align_fn(ty);\n-    let size = ty_size(ty, align_fn);\n+    let align = align_fn(arg.ty);\n+    let size = ty_size(arg.ty, align_fn);\n     let llty = if align <= 4 {\n         Type::array(&Type::i32(ccx), ((size + 3) / 4) as u64)\n     } else {\n         Type::array(&Type::i64(ccx), ((size + 7) / 8) as u64)\n     };\n-    ArgType::direct(ty, Some(llty), None, None)\n+    arg.cast = Some(llty);\n }\n \n fn is_reg_ty(ty: Type) -> bool {\n@@ -181,10 +187,10 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n     };\n \n     if fty.ret.ty != Type::void(ccx) {\n-        fty.ret = classify_ret_ty(ccx, fty.ret.ty, align_fn);\n+        classify_ret_ty(ccx, &mut fty.ret, align_fn);\n     }\n \n     for arg in &mut fty.args {\n-        *arg = classify_arg_ty(ccx, arg.ty, align_fn);\n+        classify_arg_ty(ccx, arg, align_fn);\n     }\n }"}, {"sha": "fd831f0e253c53891dbcc799b965b9178a21c518", "filename": "src/librustc_trans/trans/cabi_asmjs.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs?ref=ac60318cf52946027050c18ad68ec85e52555853", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm::{Struct, Array, Attribute};\n-use trans::abi::{FnType, ArgType};\n+use trans::abi::{FnType, ArgType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -20,41 +20,46 @@ use trans::type_::Type;\n // See the https://github.com/kripken/emscripten-fastcomp-clang repository.\n // The class `EmscriptenABIInfo` in `/lib/CodeGen/TargetInfo.cpp` contains the ABI definitions.\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    match ty.kind() {\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    match ret.ty.kind() {\n         Struct => {\n-            let field_types = ty.field_types();\n+            let field_types = ret.ty.field_types();\n             if field_types.len() == 1 {\n-                ArgType::direct(ty, Some(field_types[0]), None, None)\n+                ret.cast = Some(field_types[0]);\n             } else {\n-                ArgType::indirect(ty, Some(Attribute::StructRet))\n+                ret.kind = Indirect;\n+                ret.attr = Some(Attribute::StructRet);\n             }\n         },\n         Array => {\n-            ArgType::indirect(ty, Some(Attribute::StructRet))\n+            ret.kind = Indirect;\n+            ret.attr = Some(Attribute::StructRet);\n         },\n         _ => {\n-            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-            ArgType::direct(ty, None, None, attr)\n+            if ret.ty == Type::i1(ccx) {\n+                ret.attr = Some(Attribute::ZExt);\n+            }\n         }\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if ty.is_aggregate() {\n-        ArgType::indirect(ty, Some(Attribute::ByVal))\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if arg.ty.is_aggregate() {\n+        arg.kind = Indirect;\n+        arg.attr = Some(Attribute::ByVal);\n     } else {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ArgType::direct(ty, None, None, attr)\n+        if arg.ty == Type::i1(ccx) {\n+            arg.attr = Some(Attribute::ZExt);\n+        }\n     }\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     if fty.ret.ty != Type::void(ccx) {\n-        fty.ret = classify_ret_ty(ccx, fty.ret.ty);\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n-        *arg = classify_arg_ty(ccx, arg.ty);\n+        classify_arg_ty(ccx, arg);\n     }\n }"}, {"sha": "a07f897c122f6797e3b82138fa3ac247bc40427b", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=ac60318cf52946027050c18ad68ec85e52555853", "patch": "@@ -14,7 +14,7 @@ use libc::c_uint;\n use std::cmp;\n use llvm;\n use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n-use trans::abi::{ArgType, FnType};\n+use trans::abi::{ArgType, FnType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -86,34 +86,33 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ArgType::direct(ty, None, None, attr)\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        if ret.ty == Type::i1(ccx) {\n+            ret.attr = Some(Attribute::ZExt);\n+        }\n     } else {\n-        ArgType::indirect(ty, Some(Attribute::StructRet))\n+        ret.kind = Indirect;\n+        ret.attr = Some(Attribute::StructRet);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     let orig_offset = *offset;\n-    let size = ty_size(ty) * 8;\n-    let mut align = ty_align(ty);\n+    let size = ty_size(arg.ty) * 8;\n+    let mut align = ty_align(arg.ty);\n \n     align = cmp::min(cmp::max(align, 4), 8);\n     *offset = align_up_to(*offset, align);\n     *offset += align_up_to(size, align * 8) / 8;\n \n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ArgType::direct(ty, None, None, attr)\n+    if is_reg_ty(arg.ty) {\n+        if arg.ty == Type::i1(ccx) {\n+            arg.attr = Some(Attribute::ZExt);\n+        }\n     } else {\n-        ArgType::direct(\n-            ty,\n-            Some(struct_ty(ccx, ty)),\n-            padding_ty(ccx, align, orig_offset),\n-            None\n-        )\n+        arg.cast = Some(struct_ty(ccx, arg.ty));\n+        arg.pad = padding_ty(ccx, align, orig_offset);\n     }\n }\n \n@@ -163,11 +162,11 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     if fty.ret.ty != Type::void(ccx) {\n-        fty.ret = classify_ret_ty(ccx, fty.ret.ty);\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n     for arg in &mut fty.args {\n-        *arg = classify_arg_ty(ccx, arg.ty, &mut offset);\n+        classify_arg_ty(ccx, arg, &mut offset);\n     }\n }"}, {"sha": "19307cc230f7eca891a9a661d17eba08a52392d7", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=ac60318cf52946027050c18ad68ec85e52555853", "patch": "@@ -11,7 +11,7 @@\n use libc::c_uint;\n use llvm;\n use llvm::{Integer, Pointer, Float, Double, Struct, Array, Attribute};\n-use trans::abi::{FnType, ArgType};\n+use trans::abi::{FnType, ArgType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -82,34 +82,33 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ArgType::direct(ty, None, None, attr)\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        if ret.ty == Type::i1(ccx) {\n+            ret.attr = Some(Attribute::ZExt);\n+        }\n     } else {\n-        ArgType::indirect(ty, Some(Attribute::StructRet))\n+        ret.kind = Indirect;\n+        ret.attr = Some(Attribute::StructRet);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     let orig_offset = *offset;\n-    let size = ty_size(ty) * 8;\n-    let mut align = ty_align(ty);\n+    let size = ty_size(arg.ty) * 8;\n+    let mut align = ty_align(arg.ty);\n \n     align = cmp::min(cmp::max(align, 4), 8);\n     *offset = align_up_to(*offset, align);\n     *offset += align_up_to(size, align * 8) / 8;\n \n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ArgType::direct(ty, None, None, attr)\n+    if is_reg_ty(arg.ty) {\n+        if arg.ty == Type::i1(ccx) {\n+            arg.attr = Some(Attribute::ZExt);\n+        }\n     } else {\n-        ArgType::direct(\n-            ty,\n-            Some(struct_ty(ccx, ty)),\n-            padding_ty(ccx, align, orig_offset),\n-            None\n-        )\n+        arg.cast = Some(struct_ty(ccx, arg.ty));\n+        arg.pad = padding_ty(ccx, align, orig_offset);\n     }\n }\n \n@@ -158,11 +157,11 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     if fty.ret.ty != Type::void(ccx) {\n-        fty.ret = classify_ret_ty(ccx, fty.ret.ty);\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n     for arg in &mut fty.args {\n-        *arg = classify_arg_ty(ccx, arg.ty, &mut offset);\n+        classify_arg_ty(ccx, arg, &mut offset);\n     }\n }"}, {"sha": "ee1e5a39b617c1c6874e5218ef2ed6b5daaad9eb", "filename": "src/librustc_trans/trans/cabi_powerpc64.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs?ref=ac60318cf52946027050c18ad68ec85e52555853", "patch": "@@ -16,7 +16,7 @@\n // need to be fixed when PowerPC vector support is added.\n \n use llvm::{Integer, Pointer, Float, Double, Struct, Array, Attribute};\n-use trans::abi::{FnType, ArgType};\n+use trans::abi::{FnType, ArgType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -151,22 +151,25 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n     })\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        if ret.ty == Type::i1(ccx) {\n+            ret.attr = Some(Attribute::ZExt);\n+        }\n+        return;\n     }\n \n     // The PowerPC64 big endian ABI doesn't return aggregates in registers\n     if ccx.sess().target.target.target_endian == \"big\" {\n-        return ArgType::indirect(ty, Some(Attribute::StructRet))\n+        ret.kind = Indirect;\n+        ret.attr = Some(Attribute::StructRet);\n     }\n \n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n-        let llty = Type::array(&base_ty, members);\n-        return ArgType::direct(ty, Some(llty), None, None);\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n+        ret.cast = Some(Type::array(&base_ty, members));\n+        return;\n     }\n-    let size = ty_size(ty);\n+    let size = ty_size(ret.ty);\n     if size <= 16 {\n         let llty = if size <= 1 {\n             Type::i8(ccx)\n@@ -179,28 +182,28 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         } else {\n             Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n         };\n-        return ArgType::direct(ty, Some(llty), None, None);\n+        ret.cast = Some(llty);\n+        return;\n     }\n \n-    ArgType::indirect(ty, Some(Attribute::StructRet))\n+    ret.kind = Indirect;\n+    ret.attr = Some(Attribute::StructRet);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if is_reg_ty(arg.ty) {\n+        if arg.ty == Type::i1(ccx) {\n+            arg.attr = Some(Attribute::ZExt);\n+        }\n+        return;\n     }\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n-        let llty = Type::array(&base_ty, members);\n-        return ArgType::direct(ty, Some(llty), None, None);\n+\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n+        arg.cast = Some(Type::array(&base_ty, members));\n+        return;\n     }\n \n-    ArgType::direct(\n-        ty,\n-        Some(struct_ty(ccx, ty)),\n-        None,\n-        None\n-    )\n+    arg.cast = Some(struct_ty(ccx, arg.ty));\n }\n \n fn is_reg_ty(ty: Type) -> bool {\n@@ -238,10 +241,10 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     if fty.ret.ty != Type::void(ccx) {\n-        fty.ret = classify_ret_ty(ccx, fty.ret.ty);\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n-        *arg = classify_arg_ty(ccx, arg.ty);\n+        classify_arg_ty(ccx, arg);\n     }\n }"}, {"sha": "b5dd3393ba92348021895f3bd7991e8753ec7c6d", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=ac60318cf52946027050c18ad68ec85e52555853", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::*;\n-use trans::abi::{ArgType, FnType};\n+use trans::abi::{FnType, Indirect, Ignore};\n use trans::type_::Type;\n use super::common::*;\n use super::machine::*;\n@@ -23,31 +23,34 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n         // Some links:\n         // http://www.angelcode.com/dev/callconv/callconv.html\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n-        let indirect = ArgType::indirect(fty.ret.ty, Some(Attribute::StructRet));\n-\n         let t = &ccx.sess().target.target;\n         if t.options.is_like_osx || t.options.is_like_windows {\n             match llsize_of_alloc(ccx, fty.ret.ty) {\n                 1 => fty.ret.cast = Some(Type::i8(ccx)),\n                 2 => fty.ret.cast = Some(Type::i16(ccx)),\n                 4 => fty.ret.cast = Some(Type::i32(ccx)),\n                 8 => fty.ret.cast = Some(Type::i64(ccx)),\n-                _ => fty.ret = indirect\n+                _ => {\n+                    fty.ret.kind = Indirect;\n+                    fty.ret.attr = Some(Attribute::StructRet);\n+                }\n             }\n         } else {\n-            fty.ret = indirect;\n+            fty.ret.kind = Indirect;\n+            fty.ret.attr = Some(Attribute::StructRet);\n         }\n     } else if fty.ret.ty == Type::i1(ccx) {\n         fty.ret.attr = Some(Attribute::ZExt);\n     }\n \n     for arg in &mut fty.args {\n         if arg.ty.kind() == Struct {\n-            *arg = if llsize_of_alloc(ccx, arg.ty) == 0 {\n-                ArgType::ignore(arg.ty)\n+            if llsize_of_alloc(ccx, arg.ty) == 0 {\n+                arg.kind = Ignore;\n             } else {\n-                ArgType::indirect(arg.ty, Some(Attribute::ByVal))\n-            };\n+                arg.kind = Indirect;\n+                arg.attr = Some(Attribute::ByVal);\n+            }\n         } else if arg.ty == Type::i1(ccx) {\n             arg.attr = Some(Attribute::ZExt);\n         }"}, {"sha": "4c6ff6ff9557df353f7f16e9311fc617810452fa", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=ac60318cf52946027050c18ad68ec85e52555853", "patch": "@@ -16,7 +16,7 @@ use self::RegClass::*;\n \n use llvm::{Integer, Pointer, Float, Double};\n use llvm::{Struct, Array, Attribute, Vector};\n-use trans::abi::{ArgType, FnType};\n+use trans::abi::{ArgType, FnType, Indirect};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -385,33 +385,31 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     fn x86_64_ty<F>(ccx: &CrateContext,\n-                    ty: Type,\n+                    arg: &mut ArgType,\n                     is_mem_cls: F,\n                     ind_attr: Attribute)\n-                    -> ArgType where\n-        F: FnOnce(&[RegClass]) -> bool,\n+        where F: FnOnce(&[RegClass]) -> bool\n     {\n-        if !ty.is_reg_ty() {\n-            let cls = classify_ty(ty);\n+        if !arg.ty.is_reg_ty() {\n+            let cls = classify_ty(arg.ty);\n             if is_mem_cls(&cls) {\n-                ArgType::indirect(ty, Some(ind_attr))\n+                arg.kind = Indirect;\n+                arg.attr = Some(ind_attr);\n             } else {\n-                ArgType::direct(ty,\n-                                Some(llreg_ty(ccx, &cls)),\n-                                None,\n-                                None)\n+                arg.cast = Some(llreg_ty(ccx, &cls));\n             }\n         } else {\n-            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-            ArgType::direct(ty, None, None, attr)\n+            if arg.ty == Type::i1(ccx) {\n+                arg.attr = Some(Attribute::ZExt);\n+            }\n         }\n     }\n \n     let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n     let mut sse_regs = 8; // XMM0-7\n \n     if fty.ret.ty != Type::void(ccx) {\n-        fty.ret = x86_64_ty(ccx, fty.ret.ty, |cls| {\n+        x86_64_ty(ccx, &mut fty.ret, |cls| {\n             if cls.is_ret_bysret() {\n                 // `sret` parameter thus one less register available\n                 int_regs -= 1;\n@@ -423,7 +421,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     }\n \n     for arg in &mut fty.args {\n-        *arg = x86_64_ty(ccx, arg.ty, |cls| {\n+        x86_64_ty(ccx, arg, |cls| {\n             let needed_int = cls.iter().filter(|&&c| c == Int).count() as isize;\n             let needed_sse = cls.iter().filter(|c| c.is_sse()).count() as isize;\n             let in_mem = cls.is_pass_byval() ||"}, {"sha": "ab9323dda7b16b4c375b1e6c304cedd7e2309f27", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60318cf52946027050c18ad68ec85e52555853/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=ac60318cf52946027050c18ad68ec85e52555853", "patch": "@@ -11,7 +11,7 @@\n use llvm::*;\n use super::common::*;\n use super::machine::*;\n-use trans::abi::{ArgType, FnType};\n+use trans::abi::{ArgType, FnType, Indirect};\n use trans::type_::Type;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n@@ -24,7 +24,10 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n                 2 => a.cast = Some(Type::i16(ccx)),\n                 4 => a.cast = Some(Type::i32(ccx)),\n                 8 => a.cast = Some(Type::i64(ccx)),\n-                _ => *a = ArgType::indirect(a.ty, indirect_attr)\n+                _ => {\n+                    a.kind = Indirect;\n+                    a.attr = indirect_attr;\n+                }\n             }\n         } else if a.ty == Type::i1(ccx) {\n             a.attr = Some(Attribute::ZExt);"}]}