{"sha": "a294b35060e069007ee46e190a6f0a19fa3eaab8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyOTRiMzUwNjBlMDY5MDA3ZWU0NmUxOTBhNmYwYTE5ZmEzZWFhYjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-02T21:22:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-02T21:22:14Z"}, "message": "auto merge of #18406 : thestinger/rust/oom, r=cmr\n\nThis makes the low-level allocation API suitable for use cases where\r\nout-of-memory conditions need to be handled.\r\n\r\nCloses #18292\r\n\r\n[breaking-change]", "tree": {"sha": "4201a43fec3a750a6fb28e1fa67beddf7a3b249c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4201a43fec3a750a6fb28e1fa67beddf7a3b249c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a294b35060e069007ee46e190a6f0a19fa3eaab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a294b35060e069007ee46e190a6f0a19fa3eaab8", "html_url": "https://github.com/rust-lang/rust/commit/a294b35060e069007ee46e190a6f0a19fa3eaab8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a294b35060e069007ee46e190a6f0a19fa3eaab8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c1268451b1f51fdaa31938707df8c56f08cfb31", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c1268451b1f51fdaa31938707df8c56f08cfb31", "html_url": "https://github.com/rust-lang/rust/commit/0c1268451b1f51fdaa31938707df8c56f08cfb31"}, {"sha": "fea985a0b5008bc2f441866a80c0e3a16592eaab", "url": "https://api.github.com/repos/rust-lang/rust/commits/fea985a0b5008bc2f441866a80c0e3a16592eaab", "html_url": "https://github.com/rust-lang/rust/commit/fea985a0b5008bc2f441866a80c0e3a16592eaab"}], "stats": {"total": 112, "additions": 49, "deletions": 63}, "files": [{"sha": "579f47ee87466bcd3af3513e59e77dd031633198", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 28, "deletions": 56, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::ptr::RawPtr;\n+\n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n \n-/// Returns a pointer to `size` bytes of memory.\n+/// Return a pointer to `size` bytes of memory aligned to `align`.\n+///\n+/// On failure, return a null pointer.\n ///\n /// Behavior is undefined if the requested size is 0 or the alignment is not a\n /// power of 2. The alignment must be no larger than the largest supported page\n@@ -20,8 +24,9 @@ pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n     imp::allocate(size, align)\n }\n \n-/// Extends or shrinks the allocation referenced by `ptr` to `size` bytes of\n-/// memory.\n+/// Resize the allocation referenced by `ptr` to `size` bytes.\n+///\n+/// On failure, return a null pointer and leave the original allocation intact.\n ///\n /// Behavior is undefined if the requested size is 0 or the alignment is not a\n /// power of 2. The alignment must be no larger than the largest supported page\n@@ -35,8 +40,7 @@ pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint)\n     imp::reallocate(ptr, old_size, size, align)\n }\n \n-/// Extends or shrinks the allocation referenced by `ptr` to `size` bytes of\n-/// memory in-place.\n+/// Resize the allocation referenced by `ptr` to `size` bytes.\n ///\n /// If the operation succeeds, it returns `usable_size(size, align)` and if it\n /// fails (or is a no-op) it returns `usable_size(old_size, align)`.\n@@ -95,7 +99,9 @@ unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n     if size == 0 {\n         EMPTY as *mut u8\n     } else {\n-        allocate(size, align)\n+        let ptr = allocate(size, align);\n+        if ptr.is_null() { ::oom() }\n+        ptr\n     }\n }\n \n@@ -120,7 +126,7 @@ const MIN_ALIGN: uint = 16;\n #[cfg(jemalloc)]\n mod imp {\n     use core::option::{None, Option};\n-    use core::ptr::{RawPtr, null_mut, null};\n+    use core::ptr::{null_mut, null};\n     use core::num::Int;\n     use libc::{c_char, c_int, c_void, size_t};\n     use super::MIN_ALIGN;\n@@ -131,10 +137,8 @@ mod imp {\n \n     extern {\n         fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n-        fn je_rallocx(ptr: *mut c_void, size: size_t,\n-                      flags: c_int) -> *mut c_void;\n-        fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t,\n-                      flags: c_int) -> size_t;\n+        fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n+        fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n         fn je_sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n         fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n         fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void,\n@@ -160,21 +164,13 @@ mod imp {\n     #[inline]\n     pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n         let flags = align_to_flags(align);\n-        let ptr = je_mallocx(size as size_t, flags) as *mut u8;\n-        if ptr.is_null() {\n-            ::oom()\n-        }\n-        ptr\n+        je_mallocx(size as size_t, flags) as *mut u8\n     }\n \n     #[inline]\n     pub unsafe fn reallocate(ptr: *mut u8, _old_size: uint, size: uint, align: uint) -> *mut u8 {\n         let flags = align_to_flags(align);\n-        let ptr = je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8;\n-        if ptr.is_null() {\n-            ::oom()\n-        }\n-        ptr\n+        je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8\n     }\n \n     #[inline]\n@@ -207,7 +203,6 @@ mod imp {\n mod imp {\n     use core::cmp;\n     use core::ptr;\n-    use core::ptr::RawPtr;\n     use libc;\n     use super::MIN_ALIGN;\n \n@@ -220,31 +215,24 @@ mod imp {\n     #[inline]\n     pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n         if align <= MIN_ALIGN {\n-            let ptr = libc::malloc(size as libc::size_t);\n-            if ptr.is_null() {\n-                ::oom();\n-            }\n-            ptr as *mut u8\n+            libc::malloc(size as libc::size_t) as *mut u8\n         } else {\n             let mut out = 0 as *mut libc::c_void;\n             let ret = posix_memalign(&mut out,\n                                      align as libc::size_t,\n                                      size as libc::size_t);\n             if ret != 0 {\n-                ::oom();\n+                ptr::null_mut()\n+            } else {\n+                out as *mut u8\n             }\n-            out as *mut u8\n         }\n     }\n \n     #[inline]\n     pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n         if align <= MIN_ALIGN {\n-            let ptr = libc::realloc(ptr as *mut libc::c_void, size as libc::size_t);\n-            if ptr.is_null() {\n-                ::oom();\n-            }\n-            ptr as *mut u8\n+            libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n         } else {\n             let new_ptr = allocate(size, align);\n             ptr::copy_memory(new_ptr, ptr as *const u8, cmp::min(size, old_size));\n@@ -276,7 +264,6 @@ mod imp {\n mod imp {\n     use libc::{c_void, size_t};\n     use libc;\n-    use core::ptr::RawPtr;\n     use super::MIN_ALIGN;\n \n     extern {\n@@ -289,35 +276,18 @@ mod imp {\n     #[inline]\n     pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n         if align <= MIN_ALIGN {\n-            let ptr = libc::malloc(size as size_t);\n-            if ptr.is_null() {\n-                ::oom();\n-            }\n-            ptr as *mut u8\n+            libc::malloc(size as size_t) as *mut u8\n         } else {\n-            let ptr = _aligned_malloc(size as size_t, align as size_t);\n-            if ptr.is_null() {\n-                ::oom();\n-            }\n-            ptr as *mut u8\n+            _aligned_malloc(size as size_t, align as size_t) as *mut u8\n         }\n     }\n \n     #[inline]\n     pub unsafe fn reallocate(ptr: *mut u8, _old_size: uint, size: uint, align: uint) -> *mut u8 {\n         if align <= MIN_ALIGN {\n-            let ptr = libc::realloc(ptr as *mut c_void, size as size_t);\n-            if ptr.is_null() {\n-                ::oom();\n-            }\n-            ptr as *mut u8\n+            libc::realloc(ptr as *mut c_void, size as size_t) as *mut u8\n         } else {\n-            let ptr = _aligned_realloc(ptr as *mut c_void, size as size_t,\n-                                       align as size_t);\n-            if ptr.is_null() {\n-                ::oom();\n-            }\n-            ptr as *mut u8\n+            _aligned_realloc(ptr as *mut c_void, size as size_t, align as size_t) as *mut u8\n         }\n     }\n \n@@ -348,13 +318,15 @@ mod imp {\n mod test {\n     extern crate test;\n     use self::test::Bencher;\n+    use core::ptr::RawPtr;\n     use heap;\n \n     #[test]\n     fn basic_reallocate_inplace_noop() {\n         unsafe {\n             let size = 4000;\n             let ptr = heap::allocate(size, 8);\n+            if ptr.is_null() { ::oom() }\n             let ret = heap::reallocate_inplace(ptr, size, size, 8);\n             heap::deallocate(ptr, size, 8);\n             assert_eq!(ret, heap::usable_size(size, 8));"}, {"sha": "2ff151c1363d79534b4345fc15b987120d1035ed", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -11,8 +11,7 @@\n //! # The Rust core allocation library\n //!\n //! This is the lowest level library through which allocation in Rust can be\n-//! performed where the allocation is assumed to succeed. This library will\n-//! abort the process when allocation fails.\n+//! performed.\n //!\n //! This library, like libcore, is not intended for general usage, but rather as\n //! a building block of other libraries. The types and interfaces in this\n@@ -95,8 +94,10 @@ pub mod boxed;\n pub mod arc;\n pub mod rc;\n \n-/// Common OOM routine used by liballoc\n-fn oom() -> ! {\n+/// Common out-of-memory routine\n+#[cold]\n+#[inline(never)]\n+pub fn oom() -> ! {\n     // FIXME(#14674): This really needs to do something other than just abort\n     //                here, but any printing done must be *guaranteed* to not\n     //                allocate."}, {"sha": "415b12c7d052380a1dfd0f30e415d1bd0ccba246", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -31,6 +31,8 @@\n #![feature(unsafe_destructor)]\n #![allow(missing_docs)]\n \n+extern crate alloc;\n+\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::intrinsics::{TyDesc, get_tydesc};\n@@ -386,6 +388,7 @@ impl<T> TypedArenaChunk<T> {\n         let size = calculate_size::<T>(capacity);\n         let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>())\n                     as *mut TypedArenaChunk<T>;\n+        if chunk.is_null() { alloc::oom() }\n         (*chunk).next = next;\n         (*chunk).capacity = capacity;\n         chunk"}, {"sha": "f9f4ae534c16ee2155a85a2891990e80aeb77e06", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -629,6 +629,7 @@ impl<T> Vec<T> {\n                                .expect(\"capacity overflow\");\n             unsafe {\n                 self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n+                if self.ptr.is_null() { ::alloc::oom() }\n             }\n             self.cap = capacity;\n         }\n@@ -666,6 +667,7 @@ impl<T> Vec<T> {\n                                       self.cap * mem::size_of::<T>(),\n                                       self.len * mem::size_of::<T>(),\n                                       mem::min_align_of::<T>()) as *mut T;\n+                if self.ptr.is_null() { ::alloc::oom() }\n             }\n             self.cap = self.len;\n         }\n@@ -988,6 +990,7 @@ impl<T> Vec<T> {\n             if old_size > size { panic!(\"capacity overflow\") }\n             unsafe {\n                 self.ptr = alloc_or_realloc(self.ptr, old_size, size);\n+                if self.ptr.is_null() { ::alloc::oom() }\n             }\n             self.cap = max(self.cap, 2) * 2;\n         }"}, {"sha": "b15cdb88b67832da2d6f12b8256eada7183a4da7", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -101,7 +101,7 @@ impl Clone for CString {\n     fn clone(&self) -> CString {\n         let len = self.len() + 1;\n         let buf = unsafe { libc::malloc(len as libc::size_t) } as *mut libc::c_char;\n-        if buf.is_null() { panic!(\"out of memory\") }\n+        if buf.is_null() { ::alloc::oom() }\n         unsafe { ptr::copy_nonoverlapping_memory(buf, self.buf, len); }\n         CString { buf: buf as *const libc::c_char, owns_buffer_: true }\n     }\n@@ -388,7 +388,7 @@ impl ToCStr for [u8] {\n     unsafe fn to_c_str_unchecked(&self) -> CString {\n         let self_len = self.len();\n         let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n-        if buf.is_null() { panic!(\"out of memory\") }\n+        if buf.is_null() { ::alloc::oom() }\n \n         ptr::copy_memory(buf, self.as_ptr(), self_len);\n         *buf.offset(self_len as int) = 0;"}, {"sha": "ee69f5f5235dce1ddd0011f09df8089633c5fab8", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -354,6 +354,7 @@ impl TLDValue {\n         let box_ptr = unsafe {\n             let allocation = heap::allocate(mem::size_of::<TLDValueBox<T>>(),\n                                             mem::min_align_of::<TLDValueBox<T>>());\n+            if allocation.is_null() { ::alloc::oom() }\n             let value_box = allocation as *mut TLDValueBox<T>;\n             ptr::write(value_box, TLDValueBox {\n                 value: value,"}, {"sha": "1c448736d3ec1ca794520857cf40278d7af31ca1", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -519,6 +519,7 @@ mod imp {\n     use alloc::heap;\n     use core::atomic;\n     use core::ptr;\n+    use core::ptr::RawPtr;\n     use libc::{HANDLE, BOOL, LPSECURITY_ATTRIBUTES, c_void, DWORD, LPCSTR};\n     use libc;\n \n@@ -608,6 +609,7 @@ mod imp {\n \n     pub unsafe fn init_lock() -> uint {\n         let block = heap::allocate(CRIT_SECTION_SIZE, 8) as *mut c_void;\n+        if block.is_null() { ::alloc::oom() }\n         InitializeCriticalSectionAndSpinCount(block, SPIN_COUNT);\n         return block as uint;\n     }"}, {"sha": "771184df53dd4d8d87d07d26be715e399a15fafe", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -170,7 +170,7 @@ mod tests {\n     fn malloc(n: uint) -> CVec<u8> {\n         unsafe {\n             let mem = libc::malloc(n as libc::size_t);\n-            if mem.is_null() { panic!(\"out of memory\") }\n+            if mem.is_null() { ::alloc::oom() }\n \n             CVec::new_with_dtor(mem as *mut u8, n,\n                 proc() { libc::free(mem as *mut libc::c_void); })"}, {"sha": "4d73029b7b06b50e3101c238d521d35c81bb0e27", "filename": "src/libstd/collections/hashmap/table.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -607,6 +607,7 @@ impl<K, V> RawTable<K, V> {\n                 \"capacity overflow\");\n \n         let buffer = allocate(size, malloc_alignment);\n+        if buffer.is_null() { ::alloc::oom() }\n \n         let hashes = buffer.offset(hash_offset as int) as *mut u64;\n "}, {"sha": "ae55642672d263022d0d2af0301ba187940364dd", "filename": "src/libsync/deque.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -353,6 +353,7 @@ impl<T: Send> Buffer<T> {\n     unsafe fn new(log_size: uint) -> Buffer<T> {\n         let size = buffer_alloc_size::<T>(log_size);\n         let buffer = allocate(size, min_align_of::<T>());\n+        if buffer.is_null() { ::alloc::oom() }\n         Buffer {\n             storage: buffer as *const T,\n             log_size: log_size,"}, {"sha": "bd581dd657f59efcfae4fd5e26cee54ffb3d33fa", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a294b35060e069007ee46e190a6f0a19fa3eaab8/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=a294b35060e069007ee46e190a6f0a19fa3eaab8", "patch": "@@ -49,6 +49,7 @@ unsafe fn test_triangle() -> bool {\n         if PRINT { println!(\"allocate(size={:u} align={:u})\", size, align); }\n \n         let ret = heap::allocate(size, align);\n+        if ret.is_null() { alloc::oom() }\n \n         if PRINT { println!(\"allocate(size={:u} align={:u}) ret: 0x{:010x}\",\n                             size, align, ret as uint);\n@@ -70,6 +71,7 @@ unsafe fn test_triangle() -> bool {\n         }\n \n         let ret = heap::reallocate(ptr, old_size, size, align);\n+        if ret.is_null() { alloc::oom() }\n \n         if PRINT {\n             println!(\"reallocate(ptr=0x{:010x} old_size={:u} size={:u} align={:u}) \\"}]}