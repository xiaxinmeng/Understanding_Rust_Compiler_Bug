{"sha": "20371b94f62daa33c876adafeea266f9e8b8f222", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMzcxYjk0ZjYyZGFhMzNjODc2YWRhZmVlYTI2NmY5ZThiOGYyMjI=", "commit": {"author": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-07-28T18:59:25Z"}, "committer": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-08-06T10:39:08Z"}, "message": "Immediately register new opaque types in the global list.\n\nPreviously each opaque type instantiation would create new inference vars, even for the same opaque type/substs combination. Now there is a global map in InferCtxt that gets filled whenever we encounter an opaque type.", "tree": {"sha": "6744e33dc15832f0b7f55bf193af76efeeaa2f5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6744e33dc15832f0b7f55bf193af76efeeaa2f5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20371b94f62daa33c876adafeea266f9e8b8f222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20371b94f62daa33c876adafeea266f9e8b8f222", "html_url": "https://github.com/rust-lang/rust/commit/20371b94f62daa33c876adafeea266f9e8b8f222", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20371b94f62daa33c876adafeea266f9e8b8f222/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "816b9fc2d1d002824908c37ed043125c3031128d", "url": "https://api.github.com/repos/rust-lang/rust/commits/816b9fc2d1d002824908c37ed043125c3031128d", "html_url": "https://github.com/rust-lang/rust/commit/816b9fc2d1d002824908c37ed043125c3031128d"}], "stats": {"total": 226, "additions": 107, "deletions": 119}, "files": [{"sha": "d4edd8da7cc41759e29b0a6148f48108b1ad3c77", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 58, "deletions": 68, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/20371b94f62daa33c876adafeea266f9e8b8f222/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20371b94f62daa33c876adafeea266f9e8b8f222/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=20371b94f62daa33c876adafeea266f9e8b8f222", "patch": "@@ -179,54 +179,55 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n \n             translate_outlives_facts(&mut cx);\n-            let mut opaque_type_values = cx.opaque_type_values;\n-\n-            for (_, revealed_ty) in &mut opaque_type_values {\n-                *revealed_ty = infcx.resolve_vars_if_possible(*revealed_ty);\n-                if revealed_ty.has_infer_types_or_consts() {\n-                    infcx.tcx.sess.delay_span_bug(\n-                        body.span,\n-                        &format!(\"could not resolve {:#?}\", revealed_ty.kind()),\n-                    );\n-                    *revealed_ty = infcx.tcx.ty_error();\n-                }\n-            }\n+            let opaque_type_values = mem::take(&mut infcx.inner.borrow_mut().opaque_types);\n \n-            opaque_type_values.retain(|(opaque_type_key, resolved_ty)| {\n-                let concrete_is_opaque = if let ty::Opaque(def_id, _) = resolved_ty.kind() {\n-                    *def_id == opaque_type_key.def_id\n-                } else {\n-                    false\n-                };\n-\n-                if concrete_is_opaque {\n-                    // We're using an opaque `impl Trait` type without\n-                    // 'revealing' it. For example, code like this:\n-                    //\n-                    // type Foo = impl Debug;\n-                    // fn foo1() -> Foo { ... }\n-                    // fn foo2() -> Foo { foo1() }\n-                    //\n-                    // In `foo2`, we're not revealing the type of `Foo` - we're\n-                    // just treating it as the opaque type.\n-                    //\n-                    // When this occurs, we do *not* want to try to equate\n-                    // the concrete type with the underlying defining type\n-                    // of the opaque type - this will always fail, since\n-                    // the defining type of an opaque type is always\n-                    // some other type (e.g. not itself)\n-                    // Essentially, none of the normal obligations apply here -\n-                    // we're just passing around some unknown opaque type,\n-                    // without actually looking at the underlying type it\n-                    // gets 'revealed' into\n-                    debug!(\n-                        \"eq_opaque_type_and_type: non-defining use of {:?}\",\n-                        opaque_type_key.def_id,\n-                    );\n-                }\n-                !concrete_is_opaque\n-            });\n             opaque_type_values\n+                .into_iter()\n+                .filter_map(|(opaque_type_key, decl)| {\n+                    let mut revealed_ty = infcx.resolve_vars_if_possible(decl.concrete_ty);\n+                    if revealed_ty.has_infer_types_or_consts() {\n+                        infcx.tcx.sess.delay_span_bug(\n+                            body.span,\n+                            &format!(\"could not resolve {:#?}\", revealed_ty.kind()),\n+                        );\n+                        revealed_ty = infcx.tcx.ty_error();\n+                    }\n+                    let concrete_is_opaque = if let ty::Opaque(def_id, _) = revealed_ty.kind() {\n+                        *def_id == opaque_type_key.def_id\n+                    } else {\n+                        false\n+                    };\n+\n+                    if concrete_is_opaque {\n+                        // We're using an opaque `impl Trait` type without\n+                        // 'revealing' it. For example, code like this:\n+                        //\n+                        // type Foo = impl Debug;\n+                        // fn foo1() -> Foo { ... }\n+                        // fn foo2() -> Foo { foo1() }\n+                        //\n+                        // In `foo2`, we're not revealing the type of `Foo` - we're\n+                        // just treating it as the opaque type.\n+                        //\n+                        // When this occurs, we do *not* want to try to equate\n+                        // the concrete type with the underlying defining type\n+                        // of the opaque type - this will always fail, since\n+                        // the defining type of an opaque type is always\n+                        // some other type (e.g. not itself)\n+                        // Essentially, none of the normal obligations apply here -\n+                        // we're just passing around some unknown opaque type,\n+                        // without actually looking at the underlying type it\n+                        // gets 'revealed' into\n+                        debug!(\n+                            \"eq_opaque_type_and_type: non-defining use of {:?}\",\n+                            opaque_type_key.def_id,\n+                        );\n+                        None\n+                    } else {\n+                        Some((opaque_type_key, revealed_ty))\n+                    }\n+                })\n+                .collect()\n         },\n     );\n \n@@ -865,7 +866,6 @@ struct TypeChecker<'a, 'tcx> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n-    opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx> {\n@@ -1025,7 +1025,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n-            opaque_type_values: VecMap::default(),\n         };\n         checker.check_user_type_annotations();\n         checker\n@@ -1289,10 +1288,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let body = self.body;\n         let mir_def_id = body.source.def_id().expect_local();\n \n-        let mut opaque_type_values = VecMap::new();\n-\n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", mir_def_id);\n-        let opaque_type_map = self.fully_perform_op(\n+        self.fully_perform_op(\n             locations,\n             category,\n             CustomTypeOp::new(\n@@ -1307,20 +1304,18 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // to `Box<?T>`, returning an `opaque_type_map` mapping `{Foo<T> -> ?T}`.\n                     // (Note that the key of the map is both the def-id of `Foo` along with\n                     // any generic parameters.)\n-                    let (output_ty, opaque_type_map) =\n-                        obligations.add(infcx.instantiate_opaque_types(\n-                            mir_def_id,\n-                            dummy_body_id,\n-                            param_env,\n-                            anon_ty,\n-                            locations.span(body),\n-                        ));\n+                    let output_ty = obligations.add(infcx.instantiate_opaque_types(\n+                        mir_def_id,\n+                        dummy_body_id,\n+                        param_env,\n+                        anon_ty,\n+                        locations.span(body),\n+                    ));\n                     debug!(\n                         \"eq_opaque_type_and_type: \\\n                          instantiated output_ty={:?} \\\n-                         opaque_type_map={:#?} \\\n                          revealed_ty={:?}\",\n-                        output_ty, opaque_type_map, revealed_ty\n+                        output_ty, revealed_ty\n                     );\n \n                     // Make sure that the inferred types are well-formed. I'm\n@@ -1338,26 +1333,21 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             .eq(output_ty, revealed_ty)?,\n                     );\n \n-                    for &(opaque_type_key, opaque_decl) in &opaque_type_map {\n-                        opaque_type_values.insert(opaque_type_key, opaque_decl.concrete_ty);\n-                    }\n-\n                     debug!(\"eq_opaque_type_and_type: equated\");\n \n-                    Ok(InferOk { value: opaque_type_map, obligations: obligations.into_vec() })\n+                    Ok(InferOk { value: (), obligations: obligations.into_vec() })\n                 },\n                 || \"input_output\".to_string(),\n             ),\n         )?;\n \n-        self.opaque_type_values.extend(opaque_type_values);\n-\n         let universal_region_relations = self.universal_region_relations;\n \n         // Finally, if we instantiated the anon types successfully, we\n         // have to solve any bounds (e.g., `-> impl Iterator` needs to\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n+        let opaque_type_map = self.infcx.inner.borrow().opaque_types.clone();\n         for (opaque_type_key, opaque_decl) in opaque_type_map {\n             self.fully_perform_op(\n                 locations,"}, {"sha": "70360f176bf6bac0b1dad2d6a1a73d828002866a", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/20371b94f62daa33c876adafeea266f9e8b8f222/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20371b94f62daa33c876adafeea266f9e8b8f222/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=20371b94f62daa33c876adafeea266f9e8b8f222", "patch": "@@ -6,7 +6,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::free_regions::FreeRegionRelations;\n-use rustc_infer::infer::opaque_types::{OpaqueTypeDecl, OpaqueTypeMap};\n+use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n@@ -37,7 +37,7 @@ pub trait InferCtxtExt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         value: T,\n         value_span: Span,\n-    ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)>;\n+    ) -> InferOk<'tcx, T>;\n \n     fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(&self, free_region_relations: &FRR);\n \n@@ -99,7 +99,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         value: T,\n         value_span: Span,\n-    ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n+    ) -> InferOk<'tcx, T> {\n         debug!(\n             \"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n              param_env={:?}, value_span={:?})\",\n@@ -111,11 +111,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             body_id,\n             param_env,\n             value_span,\n-            opaque_types: Default::default(),\n             obligations: vec![],\n         };\n         let value = instantiator.instantiate_opaque_types_in_map(value);\n-        InferOk { value: (value, instantiator.opaque_types), obligations: instantiator.obligations }\n+        InferOk { value, obligations: instantiator.obligations }\n     }\n \n     /// Given the map `opaque_types` containing the opaque\n@@ -862,7 +861,6 @@ struct Instantiator<'a, 'tcx> {\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     value_span: Span,\n-    opaque_types: OpaqueTypeMap<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n \n@@ -972,7 +970,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n-        if let Some(opaque_defn) = self.opaque_types.get(&opaque_type_key) {\n+        if let Some(opaque_defn) = infcx.inner.borrow().opaque_types.get(&opaque_type_key) {\n             debug!(\"instantiate_opaque_types: returning concrete ty {:?}\", opaque_defn.concrete_ty);\n             return opaque_defn.concrete_ty;\n         }\n@@ -994,10 +992,15 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         // Foo, impl Bar)`.\n         let definition_span = self.value_span;\n \n-        self.opaque_types.insert(\n-            OpaqueTypeKey { def_id, substs },\n-            OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n-        );\n+        {\n+            let mut infcx = self.infcx.inner.borrow_mut();\n+            infcx.opaque_types.insert(\n+                OpaqueTypeKey { def_id, substs },\n+                OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n+            );\n+            infcx.opaque_types_vars.insert(ty_var, ty);\n+        }\n+\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n         self.compute_opaque_type_obligations(opaque_type_key, span);\n "}, {"sha": "db881745516798e3ef122c77c76f567c51802354", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20371b94f62daa33c876adafeea266f9e8b8f222/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20371b94f62daa33c876adafeea266f9e8b8f222/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=20371b94f62daa33c876adafeea266f9e8b8f222", "patch": "@@ -598,8 +598,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             {\n                 let impl_trait_ret_ty =\n                     self.infcx.instantiate_opaque_types(id, self.body_id, self.param_env, ty, span);\n-                let mut suggest_box = !impl_trait_ret_ty.obligations.is_empty();\n-                for o in impl_trait_ret_ty.obligations {\n+                assert!(\n+                    impl_trait_ret_ty.obligations.is_empty(),\n+                    \"we should never get new obligations here\"\n+                );\n+                let obligations = self.fulfillment_cx.borrow().pending_obligations();\n+                let mut suggest_box = !obligations.is_empty();\n+                for o in obligations {\n                     match o.predicate.kind().skip_binder() {\n                         ty::PredicateKind::Trait(t, constness) => {\n                             let pred = ty::PredicateKind::Trait("}, {"sha": "2496747c0619d3e87719b3353d7eea396ba82da9", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20371b94f62daa33c876adafeea266f9e8b8f222/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20371b94f62daa33c876adafeea266f9e8b8f222/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=20371b94f62daa33c876adafeea266f9e8b8f222", "patch": "@@ -650,10 +650,11 @@ fn check_opaque_meets_bounds<'tcx>(\n \n         let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-        let (_, opaque_type_map) = inh.register_infer_ok_obligations(\n+        let _ = inh.register_infer_ok_obligations(\n             infcx.instantiate_opaque_types(def_id, hir_id, param_env, opaque_ty, span),\n         );\n \n+        let opaque_type_map = infcx.inner.borrow().opaque_types.clone();\n         for (OpaqueTypeKey { def_id, substs }, opaque_defn) in opaque_type_map {\n             match infcx\n                 .at(&misc_cause, param_env)"}, {"sha": "ba235c142692d389894181fcfbd737086a24424e", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/20371b94f62daa33c876adafeea266f9e8b8f222/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20371b94f62daa33c876adafeea266f9e8b8f222/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=20371b94f62daa33c876adafeea266f9e8b8f222", "patch": "@@ -374,23 +374,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             parent_def_id, value\n         );\n \n-        let (value, opaque_type_map) =\n-            self.register_infer_ok_obligations(self.instantiate_opaque_types(\n-                parent_def_id,\n-                self.body_id,\n-                self.param_env,\n-                value,\n-                value_span,\n-            ));\n-\n-        let mut infcx = self.infcx.inner.borrow_mut();\n-\n-        for (ty, decl) in opaque_type_map {\n-            let _ = infcx.opaque_types.insert(ty, decl);\n-            let _ = infcx.opaque_types_vars.insert(decl.concrete_ty, decl.opaque_type);\n-        }\n-\n-        value\n+        self.register_infer_ok_obligations(self.instantiate_opaque_types(\n+            parent_def_id,\n+            self.body_id,\n+            self.param_env,\n+            value,\n+            value_span,\n+        ))\n     }\n \n     /// Convenience method which tracks extra diagnostic information for normalization"}, {"sha": "875cce4df2390b0d9ad38d7c9d2bab320a5a6986", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20371b94f62daa33c876adafeea266f9e8b8f222/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20371b94f62daa33c876adafeea266f9e8b8f222/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs?ref=20371b94f62daa33c876adafeea266f9e8b8f222", "patch": "@@ -2,10 +2,10 @@\n \n #![feature(type_alias_impl_trait)]\n \n-type Closure = impl FnOnce(); //~ ERROR: type mismatch resolving\n+type Closure = impl FnOnce();\n \n fn c() -> Closure {\n-    || -> Closure { || () }\n+    || -> Closure { || () } //~ ERROR: mismatched types\n }\n \n fn main() {}"}, {"sha": "5fde8c2ef1e1138e896cfa4d3b37d998a9cf3d24", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/20371b94f62daa33c876adafeea266f9e8b8f222/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20371b94f62daa33c876adafeea266f9e8b8f222/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=20371b94f62daa33c876adafeea266f9e8b8f222", "patch": "@@ -1,12 +1,17 @@\n-error[E0271]: type mismatch resolving `<[closure@$DIR/issue-63279.rs:8:5: 8:28] as FnOnce<()>>::Output == ()`\n-  --> $DIR/issue-63279.rs:5:16\n+error[E0308]: mismatched types\n+  --> $DIR/issue-63279.rs:8:5\n    |\n LL | type Closure = impl FnOnce();\n-   |                ^^^^^^^^^^^^^ expected `()`, found opaque type\n+   |                ------------- the found opaque type\n+...\n+LL |     || -> Closure { || () }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n    |\n-   = note: expected unit type `()`\n-            found opaque type `impl FnOnce<()>`\n+   = note: expected type `[closure@$DIR/issue-63279.rs:8:21: 8:26]`\n+           found closure `[closure@$DIR/issue-63279.rs:8:5: 8:28]`\n+   = note: no two closures, even if identical, have the same type\n+   = help: consider boxing your closure and/or using it as a trait object\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "ad641eaa00d38afa4721054eba06d8b81a1e86a2", "filename": "src/test/ui/type-alias-impl-trait/issue-74280.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20371b94f62daa33c876adafeea266f9e8b8f222/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20371b94f62daa33c876adafeea266f9e8b8f222/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.rs?ref=20371b94f62daa33c876adafeea266f9e8b8f222", "patch": "@@ -6,8 +6,7 @@ type Test = impl Copy;\n \n fn test() -> Test {\n     let y = || -> Test { () };\n-    //~^ ERROR: concrete type differs from previous defining opaque type use\n-    7\n+    7 //~ ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "f6b369dd8d51827d0ec572e925405673d318779a", "filename": "src/test/ui/type-alias-impl-trait/issue-74280.stderr", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20371b94f62daa33c876adafeea266f9e8b8f222/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20371b94f62daa33c876adafeea266f9e8b8f222/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr?ref=20371b94f62daa33c876adafeea266f9e8b8f222", "patch": "@@ -1,14 +1,9 @@\n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/issue-74280.rs:8:13\n+error[E0308]: mismatched types\n+  --> $DIR/issue-74280.rs:9:5\n    |\n-LL |     let y = || -> Test { () };\n-   |             ^^^^^^^^^^^^^^^^^ expected `i32`, got `()`\n-   |\n-note: previous use here\n-  --> $DIR/issue-74280.rs:7:1\n-   |\n-LL | fn test() -> Test {\n-   | ^^^^^^^^^^^^^^^^^\n+LL |     7\n+   |     ^ expected `()`, found integer\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}]}