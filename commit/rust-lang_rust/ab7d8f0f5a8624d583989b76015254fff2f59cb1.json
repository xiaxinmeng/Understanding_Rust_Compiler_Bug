{"sha": "ab7d8f0f5a8624d583989b76015254fff2f59cb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiN2Q4ZjBmNWE4NjI0ZDU4Mzk4OWI3NjAxNTI1NGZmZjJmNTljYjE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-10T16:50:45Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-15T20:55:44Z"}, "message": "Deduplicate some code and apply review comments", "tree": {"sha": "0503a313148001ddc157fba72d5621cf8a862ba5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0503a313148001ddc157fba72d5621cf8a862ba5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab7d8f0f5a8624d583989b76015254fff2f59cb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7d8f0f5a8624d583989b76015254fff2f59cb1", "html_url": "https://github.com/rust-lang/rust/commit/ab7d8f0f5a8624d583989b76015254fff2f59cb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab7d8f0f5a8624d583989b76015254fff2f59cb1/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc744bca9063cd9145fceed4ba7ef14cab0ecdd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc744bca9063cd9145fceed4ba7ef14cab0ecdd6", "html_url": "https://github.com/rust-lang/rust/commit/bc744bca9063cd9145fceed4ba7ef14cab0ecdd6"}], "stats": {"total": 242, "additions": 117, "deletions": 125}, "files": [{"sha": "abf265be7c50a5416572b991c43579415229c7b7", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 93, "deletions": 102, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -984,84 +984,66 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         };\n \n+        let mut suggest_restriction = |generics: &hir::Generics, msg| {\n+            err.span_suggestion(\n+                generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n+                &format!(\"consider further restricting {}\", msg),\n+                format!(\n+                    \"{} {} \",\n+                    if !generics.where_clause.predicates.is_empty() {\n+                        \",\"\n+                    } else {\n+                        \" where\"\n+                    },\n+                    trait_ref.to_predicate(),\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        };\n+\n+        // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n+        //        don't suggest `T: Sized + ?Sized`.\n         let mut hir_id = body_id;\n         while let Some(node) = self.tcx.hir().find(hir_id) {\n-            debug!(\"suggest_restricting_param_bound node={:?}\", node);\n             match node {\n                 hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Fn(decl, _, generics, _), ..\n+                    kind: hir::ItemKind::Fn(_, _, generics, _), ..\n                 }) |\n                 hir::Node::TraitItem(hir::TraitItem {\n                     generics,\n-                    kind: hir::TraitItemKind::Method(hir::MethodSig { decl, .. }, _), ..\n+                    kind: hir::TraitItemKind::Method(..), ..\n                 }) |\n                 hir::Node::ImplItem(hir::ImplItem {\n                     generics,\n-                    kind: hir::ImplItemKind::Method(hir::MethodSig { decl, .. }, _), ..\n-                }) if param_ty.map(|p| p.name.as_str() == \"Self\").unwrap_or(false) => {\n-                    if !generics.where_clause.predicates.is_empty() {\n-                        err.span_suggestion(\n-                            generics.where_clause.span().unwrap().shrink_to_hi(),\n-                            \"consider further restricting `Self`\",\n-                            format!(\", {}\", trait_ref.to_predicate()),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        err.span_suggestion(\n-                            decl.output.span().shrink_to_hi(),\n-                            \"consider further restricting `Self`\",\n-                            format!(\" where {}\", trait_ref.to_predicate()),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+                    kind: hir::ImplItemKind::Method(..), ..\n+                }) if param_ty.map_or(false, |p| p.name.as_str() == \"Self\") => {\n+                    // Restricting `Self` for a single method.\n+                    suggest_restriction(&generics, \"`Self`\");\n                     return;\n                 }\n+\n                 hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Fn(decl, _, generics, _), ..\n+                    kind: hir::ItemKind::Fn(_, _, generics, _), ..\n                 }) |\n                 hir::Node::TraitItem(hir::TraitItem {\n                     generics,\n-                    kind: hir::TraitItemKind::Method(hir::MethodSig { decl, .. }, _), ..\n+                    kind: hir::TraitItemKind::Method(..), ..\n                 }) |\n                 hir::Node::ImplItem(hir::ImplItem {\n                     generics,\n-                    kind: hir::ImplItemKind::Method(hir::MethodSig { decl, .. }, _), ..\n-                }) if projection.is_some() => {\n-                    if !generics.where_clause.predicates.is_empty() {\n-                        err.span_suggestion(\n-                            generics.where_clause.span().unwrap().shrink_to_hi(),\n-                            \"consider further restricting the associated type\",\n-                            format!(\", {}\", trait_ref.to_predicate()),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        err.span_suggestion(\n-                            decl.output.span().shrink_to_hi(),\n-                            \"consider further restricting the associated type\",\n-                            format!(\" where {}\", trait_ref.to_predicate()),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                    return;\n-                }\n+                    kind: hir::ImplItemKind::Method(..), ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, _, _), ..\n+                }) |\n                 hir::Node::Item(hir::Item {\n                     kind: hir::ItemKind::Impl(_, _, _, generics, ..), ..\n                 }) if projection.is_some() => {\n-                    err.span_suggestion(\n-                        generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n-                        \"consider further restricting the associated type\",\n-                        format!(\n-                            \"{} {}\", if generics.where_clause.predicates.is_empty() {\n-                                \" where\"\n-                            } else {\n-                                \" ,\"\n-                            },\n-                            trait_ref.to_predicate(),\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n+                    // Missing associated type bound.\n+                    suggest_restriction(&generics, \"the associated type\");\n                     return;\n                 }\n+\n                 hir::Node::Item(hir::Item { kind: hir::ItemKind::Struct(_, generics), span, .. }) |\n                 hir::Node::Item(hir::Item { kind: hir::ItemKind::Enum(_, generics), span, .. }) |\n                 hir::Node::Item(hir::Item { kind: hir::ItemKind::Union(_, generics), span, .. }) |\n@@ -1086,73 +1068,82 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 hir::Node::TraitItem(hir::TraitItem { generics, span, .. }) |\n                 hir::Node::ImplItem(hir::ImplItem { generics, span, .. })\n                 if param_ty.is_some() => {\n+                    // Missing generic type parameter bound.\n                     let restrict_msg = \"consider further restricting this bound\";\n                     let param_name = param_ty.unwrap().name.as_str();\n-                    for param in &generics.params {\n-                        if param_name == param.name.ident().as_str() {\n-                            if param_name.starts_with(\"impl \") {\n+                    for param in generics.params.iter().filter(|p| {\n+                        param_name == p.name.ident().as_str()\n+                    }) {\n+                        if param_name.starts_with(\"impl \") {\n+                            // `impl Trait` in argument: \n+                            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+                            err.span_suggestion(\n+                                param.span,\n+                                restrict_msg,\n+                                // `impl CurrentTrait + MissingTrait`\n+                                format!(\"{} + {}\", param.name.ident(), trait_ref),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            if generics.where_clause.predicates.is_empty() &&\n+                                param.bounds.is_empty()\n+                            {\n+                                // If there are no bounds whatsoever, suggest adding a constraint\n+                                // to the type parameter:\n+                                // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n                                 err.span_suggestion(\n                                     param.span,\n-                                    restrict_msg,\n-                                    // `impl CurrentTrait + MissingTrait`\n-                                    format!(\"{} + {}\", param.name.ident(), trait_ref),\n+                                    \"consider restricting this bound\",\n+                                    format!(\"{}\", trait_ref.to_predicate()),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            } else if !generics.where_clause.predicates.is_empty() {\n+                                // There is a `where` clause, so suggest expanding it:\n+                                // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+                                // `fn foo<T(t: T) where T: Debug, Trait {}`\n+                                err.span_suggestion(\n+                                    generics.where_clause.span().unwrap().shrink_to_hi(),\n+                                    &format!(\n+                                        \"consider further restricting type parameter `{}`\",\n+                                        param_name,\n+                                    ),\n+                                    format!(\", {}\", trait_ref.to_predicate()),\n                                     Applicability::MachineApplicable,\n                                 );\n                             } else {\n-                                if generics.where_clause.predicates.is_empty() &&\n-                                    param.bounds.is_empty()\n-                                {\n-                                    err.span_suggestion(\n-                                        param.span,\n-                                        \"consider restricting this bound\",\n-                                        format!(\"{}\", trait_ref.to_predicate()),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                } else if !generics.where_clause.predicates.is_empty() {\n-                                    err.span_suggestion(\n-                                        generics.where_clause.span().unwrap().shrink_to_hi(),\n-                                        &format!(\n-                                            \"consider further restricting type parameter `{}`\",\n-                                            param_name,\n-                                        ),\n-                                        format!(\", {}\", trait_ref.to_predicate()),\n-                                        Applicability::MachineApplicable,\n-                                    );\n+                                // If there is no `where` clause lean towards constraining to the\n+                                // type parameter:\n+                                // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+                                // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+                                let sp = param.span.with_hi(span.hi());\n+                                let span = self.tcx.sess.source_map()\n+                                    .span_through_char(sp, ':');\n+                                if sp != param.span && sp != span {\n+                                    // Only suggest if we have high certainty that the span\n+                                    // covers the colon in `foo<T: Trait>`.\n+                                    err.span_suggestion(span, restrict_msg, format!(\n+                                        \"{} + \",\n+                                        trait_ref.to_predicate(),\n+                                    ), Applicability::MachineApplicable);\n                                 } else {\n-                                    let sp = param.span.with_hi(span.hi());\n-                                    let span = self.tcx.sess.source_map()\n-                                        .span_through_char(sp, ':');\n-                                    if sp != param.span && sp != span {\n-                                        // Only suggest if we have high certainty that the span\n-                                        // covers the colon in `foo<T: Trait>`.\n-                                        err.span_suggestion(span, restrict_msg, format!(\n-                                            \"{} + \",\n-                                            trait_ref.to_predicate(),\n-                                        ), Applicability::MachineApplicable);\n-                                    } else {\n-                                        err.span_label(param.span, &format!(\n-                                            \"consider adding a `where {}` bound\",\n-                                            trait_ref.to_predicate(),\n-                                        ));\n-                                    }\n+                                    err.span_label(param.span, &format!(\n+                                        \"consider adding a `where {}` bound\",\n+                                        trait_ref.to_predicate(),\n+                                    ));\n                                 }\n                             }\n-                            return;\n                         }\n+                        return;\n                     }\n                 }\n+\n                 hir::Node::Crate => return,\n+\n                 _ => {}\n             }\n \n             hir_id = self.tcx.hir().get_parent_item(hir_id);\n         }\n-        // FIXME: Add special check for `?Sized` so we don't suggest `T: Sized + ?Sized`.\n-\n-        // Fallback in case we didn't find the type argument. Can happen on associated types\n-        // bounds and when `Self` needs to be restricted, like in the ui test\n-        // `associated-types-projection-to-unrelated-trait-in-method-without-default.rs`.\n-        err.help(&format!(\"consider adding a `where {}` bound\", trait_ref.to_predicate()));\n     }\n \n     /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a"}, {"sha": "9f6a73cfe39104f15fe8a5564f00e2747f0dc566", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -10,7 +10,7 @@ error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterato\n   --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n    |\n LL |   fn assume_case1<T: Case1>() {\n-   |   ^                           - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::iter::Iterator`\n+   |   ^                          - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::iter::Iterator`\n    |  _|\n    | |\n LL | |\n@@ -30,7 +30,7 @@ LL |   trait Case1 {\n    |   ----------- required by `Case1`\n ...\n LL |   fn assume_case1<T: Case1>() {\n-   |   ^                           - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Send`\n+   |   ^                          - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Send`\n    |  _|\n    | |\n LL | |\n@@ -50,7 +50,7 @@ LL |   trait Case1 {\n    |   ----------- required by `Case1`\n ...\n LL |   fn assume_case1<T: Case1>() {\n-   |   ^                           - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Sync`\n+   |   ^                          - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Sync`\n    |  _|\n    | |\n LL | |"}, {"sha": "cc47f31d0045687a8a7f38a27756fb1635ba9398", "filename": "src/test/ui/associated-types/associated-types-bound-failure.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.fixed?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -14,7 +14,7 @@ pub trait GetToInt\n }\n \n fn foo<G>(g: G) -> isize\n-    where G : GetToInt, <G as GetToInt>::R: ToInt\n+    where G : GetToInt, <G as GetToInt>::R: ToInt \n {\n     ToInt::to_int(&g.get()) //~ ERROR E0277\n }"}, {"sha": "aa23326506f63e6b2f097a41a5048205104d4739", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.fixed?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -7,7 +7,7 @@ trait Get {\n }\n \n trait Other {\n-    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value)  where Self: Get{}\n+    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get  {}\n     //~^ ERROR the trait bound `Self: Get` is not satisfied\n }\n "}, {"sha": "83d5390417e77c771b336a27c610e6ffa69d0ff4", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -2,9 +2,9 @@ error[E0277]: the trait bound `Self: Get` is not satisfied\n   --> $DIR/associated-types-for-unimpl-trait.rs:10:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^\n-   |     |                                                        |\n-   |     |                                                        help: consider further restricting `Self`: `where Self: Get`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^^\n+   |     |                                                       |\n+   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n    |     the trait `Get` is not implemented for `Self`\n \n error: aborting due to previous error"}, {"sha": "6aa0403088d3c1586facd10853ced9358efacd3e", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -2,9 +2,9 @@ error[E0277]: the trait bound `Self: Get` is not satisfied\n   --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^\n-   |     |                                                        |\n-   |     |                                                        help: consider further restricting `Self`: `where Self: Get`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^^\n+   |     |                                                       |\n+   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n    |     the trait `Get` is not implemented for `Self`\n \n error: aborting due to previous error"}, {"sha": "8c242be979611c32df6c6e44b85592177909c89b", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -2,9 +2,9 @@ error[E0277]: the trait bound `Self: Get` is not satisfied\n   --> $DIR/associated-types-no-suitable-supertrait.rs:17:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^\n-   |     |                                                        |\n-   |     |                                                        help: consider further restricting `Self`: `where Self: Get`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^^\n+   |     |                                                       |\n+   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n    |     the trait `Get` is not implemented for `Self`\n \n error[E0277]: the trait bound `(T, U): Get` is not satisfied"}, {"sha": "f357045a456e604be9652adf46c5e958ed761756", "filename": "src/test/ui/associated-types/associated-types-projection-to-unrelated-trait-in-method-without-default.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.fixed?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -7,7 +7,7 @@ trait Get {\n }\n \n trait Other {\n-    fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get;\n+    fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get ;\n     //~^ ERROR E0277\n }\n "}, {"sha": "f780d171fee8e029030a462fb5a6fd0370af26a1", "filename": "src/test/ui/associated-types/associated-types-unsized.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.fixed?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -6,7 +6,7 @@ trait Get {\n     fn get(&self) -> <Self as Get>::Value;\n }\n \n-fn foo<T:Get>(t: T)  where <T as Get>::Value: std::marker::Sized{\n+fn foo<T:Get>(t: T) where <T as Get>::Value: std::marker::Sized  {\n     let x = t.get(); //~ ERROR the size for values of type\n }\n "}, {"sha": "2352ac4ad3822cdd0770c326b4d4ecf76dfb3815", "filename": "src/test/ui/associated-types/associated-types-unsized.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -2,7 +2,7 @@ error[E0277]: the size for values of type `<T as Get>::Value` cannot be known at\n   --> $DIR/associated-types-unsized.rs:10:9\n    |\n LL | fn foo<T:Get>(t: T) {\n-   |                     - help: consider further restricting the associated type: `where <T as Get>::Value: std::marker::Sized`\n+   |                    - help: consider further restricting the associated type: `where <T as Get>::Value: std::marker::Sized`\n LL |     let x = t.get();\n    |         ^ doesn't have a size known at compile-time\n    |"}, {"sha": "7a108d880bed3df1f4dbc5578c9d5dacc3986608", "filename": "src/test/ui/typeck/typeck-default-trait-impl-assoc-type.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.fixed?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -7,7 +7,7 @@ trait Trait {\n     type AssocType;\n     fn dummy(&self) { }\n }\n-fn bar<T:Trait+Send>()  where <T as Trait>::AssocType: std::marker::Send{\n+fn bar<T:Trait+Send>() where <T as Trait>::AssocType: std::marker::Send  {\n     is_send::<T::AssocType>(); //~ ERROR E0277\n }\n "}, {"sha": "2e54cdf01320d50beb13b6690b35102a2b709a5f", "filename": "src/test/ui/typeck/typeck-default-trait-impl-assoc-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.stderr?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -2,7 +2,7 @@ error[E0277]: `<T as Trait>::AssocType` cannot be sent between threads safely\n   --> $DIR/typeck-default-trait-impl-assoc-type.rs:11:5\n    |\n LL | fn bar<T:Trait+Send>() {\n-   |                        - help: consider further restricting the associated type: `where <T as Trait>::AssocType: std::marker::Send`\n+   |                       - help: consider further restricting the associated type: `where <T as Trait>::AssocType: std::marker::Send`\n LL |     is_send::<T::AssocType>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ `<T as Trait>::AssocType` cannot be sent between threads safely\n ..."}, {"sha": "93cb948cdbfcb0674080e6729f698e8c582110b7", "filename": "src/test/ui/wf/wf-trait-associated-type-trait.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-trait.stderr?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -3,11 +3,12 @@ error[E0277]: the trait bound `<Self as SomeTrait>::Type1: std::marker::Copy` is\n    |\n LL | struct IsCopy<T:Copy> { x: T }\n    | --------------------- required by `IsCopy`\n-...\n+LL | \n+LL | trait SomeTrait {\n+   |                - help: consider further restricting the associated type: `where <Self as SomeTrait>::Type1: std::marker::Copy`\n+LL |     type Type1;\n LL |     type Type2 = IsCopy<Self::Type1>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `<Self as SomeTrait>::Type1`\n-   |\n-   = help: consider adding a `where <Self as SomeTrait>::Type1: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "9f3545b9c6a6b3d10c5fc41c91899c95b38f07e9", "filename": "src/test/ui/wf/wf-trait-default-fn-arg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab7d8f0f5a8624d583989b76015254fff2f59cb1/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-arg.stderr?ref=ab7d8f0f5a8624d583989b76015254fff2f59cb1", "patch": "@@ -5,7 +5,7 @@ LL |   struct Bar<T:Eq+?Sized> { value: Box<T> }\n    |   ----------------------- required by `Bar`\n ...\n LL |       fn bar(&self, x: &Bar<Self>) {\n-   |       ^                            - help: consider further restricting `Self`: `where Self: std::cmp::Eq`\n+   |       ^                           - help: consider further restricting `Self`: `where Self: std::cmp::Eq`\n    |  _____|\n    | |\n LL | |"}]}