{"sha": "343e438f9d1b23aa86cd79f3716ac4711a95c402", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0M2U0MzhmOWQxYjIzYWE4NmNkNzlmMzcxNmFjNDcxMWE5NWM0MDI=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-10-17T13:24:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-17T13:24:20Z"}, "message": "Merge pull request #2120 from sinkuu/implicit_hasher\n\nImplicit hasher lint", "tree": {"sha": "dfcbf6fdbddbe30553b40ae66610def1bfe4a6df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfcbf6fdbddbe30553b40ae66610def1bfe4a6df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/343e438f9d1b23aa86cd79f3716ac4711a95c402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/343e438f9d1b23aa86cd79f3716ac4711a95c402", "html_url": "https://github.com/rust-lang/rust/commit/343e438f9d1b23aa86cd79f3716ac4711a95c402", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/343e438f9d1b23aa86cd79f3716ac4711a95c402/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e4779be5f5cc144157b13e461fc61e609cda98c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e4779be5f5cc144157b13e461fc61e609cda98c", "html_url": "https://github.com/rust-lang/rust/commit/6e4779be5f5cc144157b13e461fc61e609cda98c"}, {"sha": "eea30777ddef56383199ff70fd14b28335afc1e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/eea30777ddef56383199ff70fd14b28335afc1e5", "html_url": "https://github.com/rust-lang/rust/commit/eea30777ddef56383199ff70fd14b28335afc1e5"}], "stats": {"total": 585, "additions": 568, "deletions": 17}, "files": [{"sha": "412d83d8ec899a0f63f61c7d0bb00f0945ed1acc", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/343e438f9d1b23aa86cd79f3716ac4711a95c402/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343e438f9d1b23aa86cd79f3716ac4711a95c402/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=343e438f9d1b23aa86cd79f3716ac4711a95c402", "patch": "@@ -13,6 +13,7 @@\n \n #[macro_use]\n extern crate rustc;\n+extern crate rustc_typeck;\n extern crate syntax;\n extern crate syntax_pos;\n \n@@ -333,6 +334,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box infinite_iter::Pass);\n     reg.register_late_lint_pass(box invalid_ref::InvalidRef);\n     reg.register_late_lint_pass(box identity_conversion::IdentityConversion::default());\n+    reg.register_late_lint_pass(box types::ImplicitHasher);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -555,6 +557,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         types::BOX_VEC,\n         types::CAST_LOSSLESS,\n         types::CHAR_LIT_AS_U8,\n+        types::IMPLICIT_HASHER,\n         types::LET_UNIT_VALUE,\n         types::LINKEDLIST,\n         types::TYPE_COMPLEXITY,"}, {"sha": "a284392bfa0bd773634b5944e520210a093996fa", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 331, "deletions": 16, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/343e438f9d1b23aa86cd79f3716ac4711a95c402/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343e438f9d1b23aa86cd79f3716ac4711a95c402/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=343e438f9d1b23aa86cd79f3716ac4711a95c402", "patch": "@@ -1,16 +1,21 @@\n use reexport::*;\n use rustc::hir;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{walk_ty, FnKind, NestedVisitorMap, Visitor};\n+use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeckTables};\n use rustc::ty::subst::Substs;\n+use rustc_typeck::hir_ty_to_ty;\n use std::cmp::Ordering;\n+use std::collections::BTreeMap;\n+use std::borrow::Cow;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr::IntType;\n use syntax::codemap::Span;\n+use syntax::errors::DiagnosticBuilder;\n use utils::{comparisons, higher, in_external_macro, in_macro, last_path_segment, match_def_path, match_path,\n-            opt_def_id, snippet, snippet_opt, span_help_and_lint, span_lint, span_lint_and_sugg, type_size};\n+            multispan_sugg, opt_def_id, same_tys, snippet, snippet_opt, span_help_and_lint, span_lint,\n+            span_lint_and_sugg, span_lint_and_then, type_size};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -182,21 +187,19 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n             match *qpath {\n                 QPath::Resolved(Some(ref ty), ref p) => {\n                     check_ty(cx, ty, is_local);\n-                    for ty in p.segments\n-                        .iter()\n-                        .flat_map(|seg| seg.parameters.as_ref()\n-                                           .map_or_else(|| [].iter(),\n-                                                        |params| params.types.iter()))\n-                    {\n+                    for ty in p.segments.iter().flat_map(|seg| {\n+                        seg.parameters\n+                            .as_ref()\n+                            .map_or_else(|| [].iter(), |params| params.types.iter())\n+                    }) {\n                         check_ty(cx, ty, is_local);\n                     }\n                 },\n-                QPath::Resolved(None, ref p) => for ty in p.segments\n-                    .iter()\n-                    .flat_map(|seg| seg.parameters.as_ref()\n-                                       .map_or_else(|| [].iter(),\n-                                                    |params| params.types.iter()))\n-                {\n+                QPath::Resolved(None, ref p) => for ty in p.segments.iter().flat_map(|seg| {\n+                    seg.parameters\n+                        .as_ref()\n+                        .map_or_else(|| [].iter(), |params| params.types.iter())\n+                }) {\n                     check_ty(cx, ty, is_local);\n                 },\n                 QPath::TypeRelative(ref ty, ref seg) => {\n@@ -605,7 +608,7 @@ fn span_lossless_lint(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, c\n     let opt = snippet_opt(cx, op.span);\n     let sugg = if let Some(ref snip) = opt {\n         if should_strip_parens(op, snip) {\n-            &snip[1..snip.len()-1]\n+            &snip[1..snip.len() - 1]\n         } else {\n             snip.as_str()\n         }\n@@ -1449,3 +1452,315 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n         }\n     }\n }\n+\n+/// **What it does:** Checks for public `impl` or `fn` missing generalization\n+/// over different hashers and implicitly defaulting to the default hashing\n+/// algorithm (SipHash).\n+///\n+/// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n+/// used with them.\n+///\n+/// **Known problems:** Suggestions for replacing constructors can contain\n+/// false-positives. Also applying suggestions can require modification of other\n+/// pieces of code, possibly including external crates.\n+///\n+/// **Example:**\n+/// ```rust\n+/// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { ... }\n+///\n+/// pub foo(map: &mut HashMap<i32, i32>) { .. }\n+/// ```\n+declare_lint! {\n+    pub IMPLICIT_HASHER,\n+    Warn,\n+    \"missing generalization over different hashers\"\n+}\n+\n+pub struct ImplicitHasher;\n+\n+impl LintPass for ImplicitHasher {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(IMPLICIT_HASHER)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n+    #[allow(cast_possible_truncation)]\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        use syntax_pos::BytePos;\n+\n+        fn suggestion<'a, 'tcx>(\n+            cx: &LateContext<'a, 'tcx>,\n+            db: &mut DiagnosticBuilder,\n+            generics_span: Span,\n+            generics_suggestion_span: Span,\n+            target: &ImplicitHasherType,\n+            vis: ImplicitHasherConstructorVisitor,\n+        ) {\n+            let generics_snip = snippet(cx, generics_span, \"\");\n+            // trim `<` `>`\n+            let generics_snip = if generics_snip.is_empty() {\n+                \"\"\n+            } else {\n+                &generics_snip[1..generics_snip.len() - 1]\n+            };\n+\n+            multispan_sugg(\n+                db,\n+                \"consider adding a type parameter\".to_string(),\n+                vec![\n+                    (\n+                        generics_suggestion_span,\n+                        format!(\n+                            \"<{}{}S: ::std::hash::BuildHasher{}>\",\n+                            generics_snip,\n+                            if generics_snip.is_empty() { \"\" } else { \", \" },\n+                            if vis.suggestions.is_empty() {\n+                                \"\"\n+                            } else {\n+                                // request users to add `Default` bound so that generic constructors can be used\n+                                \" + Default\"\n+                            },\n+                        ),\n+                    ),\n+                    (\n+                        target.span(),\n+                        format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n+                    ),\n+                ],\n+            );\n+\n+            if !vis.suggestions.is_empty() {\n+                multispan_sugg(db, \"...and use generic constructor\".into(), vis.suggestions);\n+            }\n+        }\n+\n+        if !cx.access_levels.is_exported(item.id) {\n+            return;\n+        }\n+\n+        match item.node {\n+            ItemImpl(_, _, _, ref generics, _, ref ty, ref items) => {\n+                let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+                vis.visit_ty(ty);\n+\n+                for target in &vis.found {\n+                    let generics_suggestion_span = generics.span.substitute_dummy({\n+                        let pos = snippet_opt(cx, item.span.until(target.span()))\n+                            .and_then(|snip| Some(item.span.lo() + BytePos(snip.find(\"impl\")? as u32 + 4)))\n+                            .expect(\"failed to create span for type arguments\");\n+                        Span::new(pos, pos, item.span.data().ctxt)\n+                    });\n+\n+                    let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n+                    for item in items.iter().map(|item| cx.tcx.hir.impl_item(item.id)) {\n+                        ctr_vis.visit_impl_item(item);\n+                    }\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        IMPLICIT_HASHER,\n+                        target.span(),\n+                        &format!(\"impl for `{}` should be generarized over different hashers\", target.type_name()),\n+                        move |db| {\n+                            suggestion(cx, db, generics.span, generics_suggestion_span, target, ctr_vis);\n+                        },\n+                    );\n+                }\n+            },\n+            ItemFn(ref decl, .., ref generics, body_id) => {\n+                let body = cx.tcx.hir.body(body_id);\n+\n+                for ty in &decl.inputs {\n+                    let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+                    vis.visit_ty(ty);\n+\n+                    for target in &vis.found {\n+                        let generics_suggestion_span = generics.span.substitute_dummy({\n+                            let pos = snippet_opt(cx, item.span.until(body.arguments[0].pat.span))\n+                                .and_then(|snip| {\n+                                    let i = snip.find(\"fn\")?;\n+                                    Some(item.span.lo() + BytePos((i + (&snip[i..]).find('(')?) as u32))\n+                                })\n+                                .expect(\"failed to create span for type parameters\");\n+                            Span::new(pos, pos, item.span.data().ctxt)\n+                        });\n+\n+                        let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n+                        ctr_vis.visit_body(body);\n+                        assert!(ctr_vis.suggestions.is_empty());\n+\n+                        span_lint_and_then(\n+                            cx,\n+                            IMPLICIT_HASHER,\n+                            target.span(),\n+                            &format!(\n+                                \"parameter of type `{}` should be generarized over different hashers\",\n+                                target.type_name()\n+                            ),\n+                            move |db| {\n+                                suggestion(cx, db, generics.span, generics_suggestion_span, target, ctr_vis);\n+                            },\n+                        );\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+enum ImplicitHasherType<'tcx> {\n+    HashMap(Span, Ty<'tcx>, Cow<'static, str>, Cow<'static, str>),\n+    HashSet(Span, Ty<'tcx>, Cow<'static, str>),\n+}\n+\n+impl<'tcx> ImplicitHasherType<'tcx> {\n+    /// Checks that `ty` is a target type without a BuildHasher.\n+    fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty) -> Option<Self> {\n+        if let TyPath(QPath::Resolved(None, ref path)) = hir_ty.node {\n+            let params = &path.segments.last().as_ref()?.parameters.as_ref()?.types;\n+            let params_len = params.len();\n+\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+\n+            if match_path(path, &paths::HASHMAP) && params_len == 2 {\n+                Some(ImplicitHasherType::HashMap(\n+                    hir_ty.span,\n+                    ty,\n+                    snippet(cx, params[0].span, \"K\"),\n+                    snippet(cx, params[1].span, \"V\"),\n+                ))\n+            } else if match_path(path, &paths::HASHSET) && params_len == 1 {\n+                Some(ImplicitHasherType::HashSet(hir_ty.span, ty, snippet(cx, params[0].span, \"T\")))\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn type_name(&self) -> &'static str {\n+        match *self {\n+            ImplicitHasherType::HashMap(..) => \"HashMap\",\n+            ImplicitHasherType::HashSet(..) => \"HashSet\",\n+        }\n+    }\n+\n+    fn type_arguments(&self) -> String {\n+        match *self {\n+            ImplicitHasherType::HashMap(.., ref k, ref v) => format!(\"{}, {}\", k, v),\n+            ImplicitHasherType::HashSet(.., ref t) => format!(\"{}\", t),\n+        }\n+    }\n+\n+    fn ty(&self) -> Ty<'tcx> {\n+        match *self {\n+            ImplicitHasherType::HashMap(_, ty, ..) | ImplicitHasherType::HashSet(_, ty, ..) => ty,\n+        }\n+    }\n+\n+    fn span(&self) -> Span {\n+        match *self {\n+            ImplicitHasherType::HashMap(span, ..) | ImplicitHasherType::HashSet(span, ..) => span,\n+        }\n+    }\n+}\n+\n+struct ImplicitHasherTypeVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    found: Vec<ImplicitHasherType<'tcx>>,\n+}\n+\n+impl<'a, 'tcx: 'a> ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+        Self { cx, found: vec![] }\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n+        if let Some(target) = ImplicitHasherType::new(self.cx, t) {\n+            self.found.push(target);\n+        }\n+\n+        walk_ty(self, t);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Looks for default-hasher-dependent constructors like `HashMap::new`.\n+struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx: 'a + 'b> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    body: &'a TypeckTables<'tcx>,\n+    target: &'b ImplicitHasherType<'tcx>,\n+    suggestions: BTreeMap<Span, String>,\n+}\n+\n+impl<'a, 'b, 'tcx: 'a + 'b> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n+        Self {\n+            cx,\n+            body: cx.tables,\n+            target,\n+            suggestions: BTreeMap::new(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    fn visit_body(&mut self, body: &'tcx Body) {\n+        self.body = self.cx.tcx.body_tables(body.id());\n+        walk_body(self, body);\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n+        if_let_chain!{[\n+            let ExprCall(ref fun, ref args) = e.node,\n+            let ExprPath(QPath::TypeRelative(ref ty, ref method)) = fun.node,\n+            let TyPath(QPath::Resolved(None, ref ty_path)) = ty.node,\n+        ], {\n+            if !same_tys(self.cx, self.target.ty(), self.body.expr_ty(e)) {\n+                return;\n+            }\n+\n+            if match_path(ty_path, &paths::HASHMAP) {\n+                if method.name == \"new\" {\n+                    self.suggestions\n+                        .insert(e.span, \"HashMap::default()\".to_string());\n+                } else if method.name == \"with_capacity\" {\n+                    self.suggestions.insert(\n+                        e.span,\n+                        format!(\n+                            \"HashMap::with_capacity_and_hasher({}, Default::default())\",\n+                            snippet(self.cx, args[0].span, \"capacity\"),\n+                        ),\n+                    );\n+                }\n+            } else if match_path(ty_path, &paths::HASHSET) {\n+                if method.name == \"new\" {\n+                    self.suggestions\n+                        .insert(e.span, \"HashSet::default()\".to_string());\n+                } else if method.name == \"with_capacity\" {\n+                    self.suggestions.insert(\n+                        e.span,\n+                        format!(\n+                            \"HashSet::with_capacity_and_hasher({}, Default::default())\",\n+                            snippet(self.cx, args[0].span, \"capacity\"),\n+                        ),\n+                    );\n+                }\n+            }\n+        }}\n+\n+        walk_expr(self, e);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.cx.tcx.hir)\n+    }\n+}"}, {"sha": "239370d9811fdfc6c7f2152833956b13d6ba3794", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/343e438f9d1b23aa86cd79f3716ac4711a95c402/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343e438f9d1b23aa86cd79f3716ac4711a95c402/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=343e438f9d1b23aa86cd79f3716ac4711a95c402", "patch": "@@ -664,7 +664,10 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n /// appear once per\n /// replacement. In human-readable format though, it only appears once before\n /// the whole suggestion.\n-pub fn multispan_sugg(db: &mut DiagnosticBuilder, help_msg: String, sugg: Vec<(Span, String)>) {\n+pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder, help_msg: String, sugg: I)\n+where\n+    I: IntoIterator<Item=(Span, String)>,\n+{\n     let sugg = rustc_errors::CodeSuggestion {\n         substitution_parts: sugg.into_iter()\n             .map(|(span, sub)| {"}, {"sha": "32ca0f56d77fb63cec1cf94c402cc323b413d82f", "filename": "tests/ui/implicit_hasher.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/343e438f9d1b23aa86cd79f3716ac4711a95c402/tests%2Fui%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/343e438f9d1b23aa86cd79f3716ac4711a95c402/tests%2Fui%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_hasher.rs?ref=343e438f9d1b23aa86cd79f3716ac4711a95c402", "patch": "@@ -0,0 +1,86 @@\n+#![allow(unused)]\n+//#![feature(plugin)]#![plugin(clippy)]\n+use std::collections::{HashMap, HashSet};\n+use std::cmp::Eq;\n+use std::hash::{Hash, BuildHasher};\n+\n+pub trait Foo<T>: Sized {\n+    fn make() -> (Self, Self);\n+}\n+\n+impl<K: Hash + Eq, V> Foo<i8> for HashMap<K, V> {\n+    fn make() -> (Self, Self) {\n+        // OK, don't suggest to modify these\n+        let _: HashMap<i32, i32> = HashMap::new();\n+        let _: HashSet<i32> = HashSet::new();\n+\n+        (HashMap::new(), HashMap::with_capacity(10))\n+    }\n+}\n+impl<K: Hash + Eq, V> Foo<i8> for (HashMap<K, V>,) {\n+    fn make() -> (Self, Self) {\n+        ((HashMap::new(),), (HashMap::with_capacity(10),))\n+    }\n+}\n+impl Foo<i16> for HashMap<String, String> {\n+    fn make() -> (Self, Self) {\n+        (HashMap::new(), HashMap::with_capacity(10))\n+    }\n+}\n+\n+impl<K: Hash + Eq, V, S: BuildHasher + Default> Foo<i32> for HashMap<K, V, S> {\n+    fn make() -> (Self, Self) {\n+        (HashMap::default(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+    }\n+}\n+impl<S: BuildHasher + Default> Foo<i64> for HashMap<String, String, S> {\n+    fn make() -> (Self, Self) {\n+        (HashMap::default(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+    }\n+}\n+\n+\n+impl<T: Hash + Eq> Foo<i8> for HashSet<T> {\n+    fn make() -> (Self, Self) {\n+        (HashSet::new(), HashSet::with_capacity(10))\n+    }\n+}\n+impl Foo<i16> for HashSet<String> {\n+    fn make() -> (Self, Self) {\n+        (HashSet::new(), HashSet::with_capacity(10))\n+    }\n+}\n+\n+impl<T: Hash + Eq, S: BuildHasher + Default> Foo<i32> for HashSet<T, S> {\n+    fn make() -> (Self, Self) {\n+        (HashSet::default(), HashSet::with_capacity_and_hasher(10, Default::default()))\n+    }\n+}\n+impl<S: BuildHasher + Default> Foo<i64> for HashSet<String, S> {\n+    fn make() -> (Self, Self) {\n+        (HashSet::default(), HashSet::with_capacity_and_hasher(10, Default::default()))\n+    }\n+}\n+\n+pub fn foo(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+}\n+\n+macro_rules! gen {\n+    (impl) => {\n+        impl<K: Hash + Eq, V> Foo<u8> for HashMap<K, V> {\n+            fn make() -> (Self, Self) {\n+                (HashMap::new(), HashMap::with_capacity(10))\n+            }\n+        }\n+    };\n+\n+    (fn $name:ident) => {\n+        pub fn $name(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+        }\n+    }\n+}\n+\n+gen!(impl);\n+gen!(fn bar);\n+\n+fn main() {}"}, {"sha": "cc0bdc327b4afa3ac8234e285f63de47526c65cf", "filename": "tests/ui/implicit_hasher.stderr", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/343e438f9d1b23aa86cd79f3716ac4711a95c402/tests%2Fui%2Fimplicit_hasher.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/343e438f9d1b23aa86cd79f3716ac4711a95c402/tests%2Fui%2Fimplicit_hasher.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_hasher.stderr?ref=343e438f9d1b23aa86cd79f3716ac4711a95c402", "patch": "@@ -0,0 +1,144 @@\n+error: impl for `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:11:35\n+   |\n+11 | impl<K: Hash + Eq, V> Foo<i8> for HashMap<K, V> {\n+   |                                   ^^^^^^^^^^^^^\n+   |\n+   = note: `-D implicit-hasher` implied by `-D warnings`\n+help: consider adding a type parameter\n+   |\n+11 | impl<K: Hash + Eq, V, S: ::std::hash::BuildHasher + Default> Foo<i8> for HashMap<K, V, S> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor\n+   |\n+17 |         (HashMap::default(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+   |          ^^^^^^^^^^^^^^^^^^\n+\n+error: impl for `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:20:36\n+   |\n+20 | impl<K: Hash + Eq, V> Foo<i8> for (HashMap<K, V>,) {\n+   |                                    ^^^^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+20 | impl<K: Hash + Eq, V, S: ::std::hash::BuildHasher + Default> Foo<i8> for (HashMap<K, V, S>,) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor\n+   |\n+22 |         ((HashMap::default(),), (HashMap::with_capacity_and_hasher(10, Default::default()),))\n+   |           ^^^^^^^^^^^^^^^^^^\n+\n+error: impl for `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:25:19\n+   |\n+25 | impl Foo<i16> for HashMap<String, String> {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+25 | impl<S: ::std::hash::BuildHasher + Default> Foo<i16> for HashMap<String, String, S> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor\n+   |\n+27 |         (HashMap::default(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+   |          ^^^^^^^^^^^^^^^^^^\n+\n+error: impl for `HashSet` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:43:32\n+   |\n+43 | impl<T: Hash + Eq> Foo<i8> for HashSet<T> {\n+   |                                ^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+43 | impl<T: Hash + Eq, S: ::std::hash::BuildHasher + Default> Foo<i8> for HashSet<T, S> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor\n+   |\n+45 |         (HashSet::default(), HashSet::with_capacity_and_hasher(10, Default::default()))\n+   |          ^^^^^^^^^^^^^^^^^^\n+\n+error: impl for `HashSet` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:48:19\n+   |\n+48 | impl Foo<i16> for HashSet<String> {\n+   |                   ^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+48 | impl<S: ::std::hash::BuildHasher + Default> Foo<i16> for HashSet<String, S> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor\n+   |\n+50 |         (HashSet::default(), HashSet::with_capacity_and_hasher(10, Default::default()))\n+   |          ^^^^^^^^^^^^^^^^^^\n+\n+error: parameter of type `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:65:23\n+   |\n+65 | pub fn foo(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |                       ^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+65 | pub fn foo<S: ::std::hash::BuildHasher>(_map: &mut HashMap<i32, i32, S>, _set: &mut HashSet<i32>) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: parameter of type `HashSet` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:65:53\n+   |\n+65 | pub fn foo(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |                                                     ^^^^^^^^^^^^\n+   |\n+help: consider adding a type parameter\n+   |\n+65 | pub fn foo<S: ::std::hash::BuildHasher>(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32, S>) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: impl for `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:70:43\n+   |\n+70 |         impl<K: Hash + Eq, V> Foo<u8> for HashMap<K, V> {\n+   |                                           ^^^^^^^^^^^^^\n+...\n+83 | gen!(impl);\n+   | ----------- in this macro invocation\n+   |\n+help: consider adding a type parameter\n+   |\n+70 |         impl<K: Hash + Eq, V, S: ::std::hash::BuildHasher + Default> Foo<u8> for HashMap<K, V, S> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and use generic constructor\n+   |\n+72 |                 (HashMap::default(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+   |                  ^^^^^^^^^^^^^^^^^^\n+\n+error: parameter of type `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:78:33\n+   |\n+78 |         pub fn $name(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |                                 ^^^^^^^^^^^^^^^^^\n+...\n+84 | gen!(fn bar);\n+   | ------------- in this macro invocation\n+   |\n+help: consider adding a type parameter\n+   |\n+78 |         pub fn $name<S: ::std::hash::BuildHasher>(_map: &mut HashMap<i32, i32, S>, _set: &mut HashSet<i32>) {\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: parameter of type `HashSet` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:78:63\n+   |\n+78 |         pub fn $name(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |                                                               ^^^^^^^^^^^^\n+...\n+84 | gen!(fn bar);\n+   | ------------- in this macro invocation\n+   |\n+help: consider adding a type parameter\n+   |\n+78 |         pub fn $name<S: ::std::hash::BuildHasher>(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32, S>) {\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+"}]}