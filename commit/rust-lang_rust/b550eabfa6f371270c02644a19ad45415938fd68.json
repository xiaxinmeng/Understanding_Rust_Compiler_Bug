{"sha": "b550eabfa6f371270c02644a19ad45415938fd68", "node_id": "C_kwDOAAsO6NoAKGI1NTBlYWJmYTZmMzcxMjcwYzAyNjQ0YTE5YWQ0NTQxNTkzOGZkNjg", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-01T21:10:36Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-15T17:53:50Z"}, "message": "Introduce composite debuginfo.", "tree": {"sha": "05e148b1cc37efffb5ee814330d1554a0d3a21f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05e148b1cc37efffb5ee814330d1554a0d3a21f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b550eabfa6f371270c02644a19ad45415938fd68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b550eabfa6f371270c02644a19ad45415938fd68", "html_url": "https://github.com/rust-lang/rust/commit/b550eabfa6f371270c02644a19ad45415938fd68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b550eabfa6f371270c02644a19ad45415938fd68/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d651a295e0e0c331153288b10b78344a4ede20b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d651a295e0e0c331153288b10b78344a4ede20b", "html_url": "https://github.com/rust-lang/rust/commit/6d651a295e0e0c331153288b10b78344a4ede20b"}], "stats": {"total": 215, "additions": 199, "deletions": 16}, "files": [{"sha": "a81585d412846e641c968302f4540944e264ab0b", "filename": "compiler/rustc_codegen_gcc/src/debuginfo.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs?ref=b550eabfa6f371270c02644a19ad45415938fd68", "patch": "@@ -4,16 +4,25 @@ use rustc_codegen_ssa::traits::{DebugInfoBuilderMethods, DebugInfoMethods};\n use rustc_middle::mir;\n use rustc_middle::ty::{Instance, PolyExistentialTraitRef, Ty};\n use rustc_span::{SourceFile, Span, Symbol};\n-use rustc_target::abi::Size;\n use rustc_target::abi::call::FnAbi;\n+use rustc_target::abi::Size;\n+use std::ops::Range;\n \n use crate::builder::Builder;\n use crate::context::CodegenCx;\n \n impl<'a, 'gcc, 'tcx> DebugInfoBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n     // FIXME(eddyb) find a common convention for all of the debuginfo-related\n     // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n-    fn dbg_var_addr(&mut self, _dbg_var: Self::DIVariable, _scope_metadata: Self::DIScope, _variable_alloca: Self::Value, _direct_offset: Size, _indirect_offsets: &[Size]) {\n+    fn dbg_var_addr(\n+        &mut self,\n+        _dbg_var: Self::DIVariable,\n+        _scope_metadata: Self::DIScope,\n+        _variable_alloca: Self::Value,\n+        _direct_offset: Size,\n+        _indirect_offsets: &[Size],\n+        _fragment: Option<Range<Size>>,\n+    ) {\n         unimplemented!();\n     }\n \n@@ -31,32 +40,64 @@ impl<'a, 'gcc, 'tcx> DebugInfoBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n }\n \n impl<'gcc, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n-    fn create_vtable_debuginfo(&self, _ty: Ty<'tcx>, _trait_ref: Option<PolyExistentialTraitRef<'tcx>>, _vtable: Self::Value) {\n+    fn create_vtable_debuginfo(\n+        &self,\n+        _ty: Ty<'tcx>,\n+        _trait_ref: Option<PolyExistentialTraitRef<'tcx>>,\n+        _vtable: Self::Value,\n+    ) {\n         // TODO(antoyo)\n     }\n \n-    fn create_function_debug_context(&self, _instance: Instance<'tcx>, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _llfn: RValue<'gcc>, _mir: &mir::Body<'tcx>) -> Option<FunctionDebugContext<Self::DIScope, Self::DILocation>> {\n+    fn create_function_debug_context(\n+        &self,\n+        _instance: Instance<'tcx>,\n+        _fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+        _llfn: RValue<'gcc>,\n+        _mir: &mir::Body<'tcx>,\n+    ) -> Option<FunctionDebugContext<Self::DIScope, Self::DILocation>> {\n         // TODO(antoyo)\n         None\n     }\n \n-    fn extend_scope_to_file(&self, _scope_metadata: Self::DIScope, _file: &SourceFile) -> Self::DIScope {\n+    fn extend_scope_to_file(\n+        &self,\n+        _scope_metadata: Self::DIScope,\n+        _file: &SourceFile,\n+    ) -> Self::DIScope {\n         unimplemented!();\n     }\n \n     fn debuginfo_finalize(&self) {\n         // TODO(antoyo)\n     }\n \n-    fn create_dbg_var(&self, _variable_name: Symbol, _variable_type: Ty<'tcx>, _scope_metadata: Self::DIScope, _variable_kind: VariableKind, _span: Span) -> Self::DIVariable {\n+    fn create_dbg_var(\n+        &self,\n+        _variable_name: Symbol,\n+        _variable_type: Ty<'tcx>,\n+        _scope_metadata: Self::DIScope,\n+        _variable_kind: VariableKind,\n+        _span: Span,\n+    ) -> Self::DIVariable {\n         unimplemented!();\n     }\n \n-    fn dbg_scope_fn(&self, _instance: Instance<'tcx>, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _maybe_definition_llfn: Option<RValue<'gcc>>) -> Self::DIScope {\n+    fn dbg_scope_fn(\n+        &self,\n+        _instance: Instance<'tcx>,\n+        _fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+        _maybe_definition_llfn: Option<RValue<'gcc>>,\n+    ) -> Self::DIScope {\n         unimplemented!();\n     }\n \n-    fn dbg_loc(&self, _scope: Self::DIScope, _inlined_at: Option<Self::DILocation>, _span: Span) -> Self::DILocation {\n+    fn dbg_loc(\n+        &self,\n+        _scope: Self::DIScope,\n+        _inlined_at: Option<Self::DILocation>,\n+        _span: Span,\n+    ) -> Self::DILocation {\n         unimplemented!();\n     }\n }"}, {"sha": "ca7a07d8391bf4459e71e3b57b007febca600e20", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=b550eabfa6f371270c02644a19ad45415938fd68", "patch": "@@ -39,6 +39,7 @@ use smallvec::SmallVec;\n use std::cell::OnceCell;\n use std::cell::RefCell;\n use std::iter;\n+use std::ops::Range;\n \n mod create_scope_map;\n pub mod gdb;\n@@ -163,12 +164,14 @@ impl<'ll> DebugInfoBuilderMethods for Builder<'_, 'll, '_> {\n         variable_alloca: Self::Value,\n         direct_offset: Size,\n         indirect_offsets: &[Size],\n+        fragment: Option<Range<Size>>,\n     ) {\n-        // Convert the direct and indirect offsets to address ops.\n+        // Convert the direct and indirect offsets and fragment byte range to address ops.\n         // FIXME(eddyb) use `const`s instead of getting the values via FFI,\n         // the values should match the ones in the DWARF standard anyway.\n         let op_deref = || unsafe { llvm::LLVMRustDIBuilderCreateOpDeref() };\n         let op_plus_uconst = || unsafe { llvm::LLVMRustDIBuilderCreateOpPlusUconst() };\n+        let op_llvm_fragment = || unsafe { llvm::LLVMRustDIBuilderCreateOpLLVMFragment() };\n         let mut addr_ops = SmallVec::<[u64; 8]>::new();\n \n         if direct_offset.bytes() > 0 {\n@@ -182,6 +185,13 @@ impl<'ll> DebugInfoBuilderMethods for Builder<'_, 'll, '_> {\n                 addr_ops.push(offset.bytes() as u64);\n             }\n         }\n+        if let Some(fragment) = fragment {\n+            // `DW_OP_LLVM_fragment` takes as arguments the fragment's\n+            // offset and size, both of them in bits.\n+            addr_ops.push(op_llvm_fragment());\n+            addr_ops.push(fragment.start.bits() as u64);\n+            addr_ops.push((fragment.end - fragment.start).bits() as u64);\n+        }\n \n         unsafe {\n             // FIXME(eddyb) replace `llvm.dbg.declare` with `llvm.dbg.addr`."}, {"sha": "8f7728da9dd44b715a51483031ae370b716cd091", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=b550eabfa6f371270c02644a19ad45415938fd68", "patch": "@@ -2210,6 +2210,7 @@ extern \"C\" {\n     ) -> &'a DILocation;\n     pub fn LLVMRustDIBuilderCreateOpDeref() -> u64;\n     pub fn LLVMRustDIBuilderCreateOpPlusUconst() -> u64;\n+    pub fn LLVMRustDIBuilderCreateOpLLVMFragment() -> u64;\n \n     #[allow(improper_ctypes)]\n     pub fn LLVMRustWriteTypeToString(Type: &Type, s: &RustString);"}, {"sha": "99283d3bb29f44735efd789ebbe7e0417bc0c77e", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 64, "deletions": 7, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=b550eabfa6f371270c02644a19ad45415938fd68", "patch": "@@ -14,6 +14,8 @@ use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n use super::{FunctionCx, LocalRef};\n \n+use std::ops::Range;\n+\n pub struct FunctionDebugContext<S, L> {\n     pub scopes: IndexVec<mir::SourceScope, DebugScope<S, L>>,\n }\n@@ -25,14 +27,18 @@ pub enum VariableKind {\n }\n \n /// Like `mir::VarDebugInfo`, but within a `mir::Local`.\n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub struct PerLocalVarDebugInfo<'tcx, D> {\n     pub name: Symbol,\n     pub source_info: mir::SourceInfo,\n \n     /// `DIVariable` returned by `create_dbg_var`.\n     pub dbg_var: Option<D>,\n \n+    /// Byte range in the `dbg_var` covered by this fragment,\n+    /// if this is a fragment of a composite `VarDebugInfo`.\n+    pub fragment: Option<Range<Size>>,\n+\n     /// `.place.projection` from `mir::VarDebugInfo`.\n     pub projection: &'tcx ty::List<mir::PlaceElem<'tcx>>,\n }\n@@ -145,7 +151,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Some(per_local) => &per_local[local],\n             None => return,\n         };\n-        let whole_local_var = vars.iter().find(|var| var.projection.is_empty()).copied();\n+        let whole_local_var = vars.iter().find(|var| var.projection.is_empty()).cloned();\n         let has_proj = || vars.iter().any(|var| !var.projection.is_empty());\n \n         let fallback_var = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n@@ -187,6 +193,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     name,\n                     source_info: decl.source_info,\n                     dbg_var,\n+                    fragment: None,\n                     projection: ty::List::empty(),\n                 })\n             }\n@@ -199,7 +206,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let name = if bx.sess().fewer_names() {\n             None\n         } else {\n-            Some(match whole_local_var.or(fallback_var) {\n+            Some(match whole_local_var.or(fallback_var.clone()) {\n                 Some(var) if var.name != kw::Empty => var.name.to_string(),\n                 _ => format!(\"{:?}\", local),\n             })\n@@ -249,7 +256,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             LocalRef::UnsizedPlace(_) => return,\n         };\n \n-        let vars = vars.iter().copied().chain(fallback_var);\n+        let vars = vars.iter().cloned().chain(fallback_var);\n \n         for var in vars {\n             let Some(dbg_var) = var.dbg_var else { continue };\n@@ -312,9 +319,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx.store(place.llval, alloca.llval, alloca.align);\n \n                 // Point the debug info to `*alloca` for the current variable\n-                bx.dbg_var_addr(dbg_var, dbg_loc, alloca.llval, Size::ZERO, &[Size::ZERO]);\n+                bx.dbg_var_addr(dbg_var, dbg_loc, alloca.llval, Size::ZERO, &[Size::ZERO], None);\n             } else {\n-                bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, direct_offset, &indirect_offsets);\n+                bx.dbg_var_addr(\n+                    dbg_var,\n+                    dbg_loc,\n+                    base.llval,\n+                    direct_offset,\n+                    &indirect_offsets,\n+                    None,\n+                );\n             }\n         }\n     }\n@@ -382,6 +396,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let ty = self.monomorphize(c.ty());\n                         (ty, VariableKind::LocalVariable)\n                     }\n+                    mir::VarDebugInfoContents::Composite { ty, fragments: _ } => {\n+                        let ty = self.monomorphize(ty);\n+                        (ty, VariableKind::LocalVariable)\n+                    }\n                 };\n \n                 self.cx.create_dbg_var(var.name, var_ty, dbg_scope, var_kind, span)\n@@ -393,6 +411,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         name: var.name,\n                         source_info: var.source_info,\n                         dbg_var,\n+                        fragment: None,\n                         projection: place.projection,\n                     });\n                 }\n@@ -407,10 +426,48 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 bx,\n                             );\n \n-                            bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, Size::ZERO, &[]);\n+                            bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, Size::ZERO, &[], None);\n                         }\n                     }\n                 }\n+                mir::VarDebugInfoContents::Composite { ty, ref fragments } => {\n+                    let var_ty = self.monomorphize(ty);\n+                    let var_layout = self.cx.layout_of(var_ty);\n+                    for fragment in fragments {\n+                        let mut fragment_start = Size::ZERO;\n+                        let mut fragment_layout = var_layout;\n+\n+                        for elem in &fragment.projection {\n+                            match *elem {\n+                                mir::ProjectionElem::Field(field, _) => {\n+                                    let i = field.index();\n+                                    fragment_start += fragment_layout.fields.offset(i);\n+                                    fragment_layout = fragment_layout.field(self.cx, i);\n+                                }\n+                                _ => span_bug!(\n+                                    var.source_info.span,\n+                                    \"unsupported fragment projection `{:?}`\",\n+                                    elem,\n+                                ),\n+                            }\n+                        }\n+\n+                        let place = fragment.contents;\n+                        per_local[place.local].push(PerLocalVarDebugInfo {\n+                            name: var.name,\n+                            source_info: var.source_info,\n+                            dbg_var,\n+                            fragment: if fragment_layout.size == var_layout.size {\n+                                // Fragment covers entire variable, so as far as\n+                                // DWARF is concerned, it's not really a fragment.\n+                                None\n+                            } else {\n+                                Some(fragment_start..fragment_start + fragment_layout.size)\n+                            },\n+                            projection: place.projection,\n+                        });\n+                    }\n+                }\n             }\n         }\n         Some(per_local)"}, {"sha": "63fecaf34fd5b6a09aa09bdd326b0c1331d3367c", "filename": "compiler/rustc_codegen_ssa/src/traits/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs?ref=b550eabfa6f371270c02644a19ad45415938fd68", "patch": "@@ -6,6 +6,8 @@ use rustc_span::{SourceFile, Span, Symbol};\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::Size;\n \n+use std::ops::Range;\n+\n pub trait DebugInfoMethods<'tcx>: BackendTypes {\n     fn create_vtable_debuginfo(\n         &self,\n@@ -72,6 +74,9 @@ pub trait DebugInfoBuilderMethods: BackendTypes {\n         direct_offset: Size,\n         // NB: each offset implies a deref (i.e. they're steps in a pointer chain).\n         indirect_offsets: &[Size],\n+        // Byte range in the `dbg_var` covered by this fragment,\n+        // if this is a fragment of a composite `DIVariable`.\n+        fragment: Option<Range<Size>>,\n     );\n     fn set_dbg_loc(&mut self, dbg_loc: Self::DILocation);\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);"}, {"sha": "6f8bb6761043884033f780e9a02dfc21a0addf65", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=b550eabfa6f371270c02644a19ad45415938fd68", "patch": "@@ -1111,6 +1111,10 @@ extern \"C\" uint64_t LLVMRustDIBuilderCreateOpPlusUconst() {\n   return dwarf::DW_OP_plus_uconst;\n }\n \n+extern \"C\" int64_t LLVMRustDIBuilderCreateOpLLVMFragment() {\n+  return dwarf::DW_OP_LLVM_fragment;\n+}\n+\n extern \"C\" void LLVMRustWriteTypeToString(LLVMTypeRef Ty, RustStringRef Str) {\n   RawRustStringOstream OS(Str);\n   unwrap<llvm::Type>(Ty)->print(OS);"}, {"sha": "12e9ebfeaecae32520355bead3d4db46b0ab126c", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=b550eabfa6f371270c02644a19ad45415938fd68", "patch": "@@ -1071,14 +1071,67 @@ pub enum VarDebugInfoContents<'tcx> {\n     /// based on a `Local`, not a `Static`, and contains no indexing.\n     Place(Place<'tcx>),\n     Const(Constant<'tcx>),\n+    /// The user variable's data is split across several fragments,\n+    /// each described by a `VarDebugInfoFragment`.\n+    /// See DWARF 5's \"2.6.1.2 Composite Location Descriptions\"\n+    /// and LLVM's `DW_OP_LLVM_fragment` for more details on\n+    /// the underlying debuginfo feature this relies on.\n+    Composite {\n+        /// Type of the original user variable.\n+        ty: Ty<'tcx>,\n+        /// All the parts of the original user variable, which ended\n+        /// up in disjoint places, due to optimizations.\n+        fragments: Vec<VarDebugInfoFragment<'tcx>>,\n+    },\n }\n \n impl<'tcx> Debug for VarDebugInfoContents<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         match self {\n             VarDebugInfoContents::Const(c) => write!(fmt, \"{}\", c),\n             VarDebugInfoContents::Place(p) => write!(fmt, \"{:?}\", p),\n+            VarDebugInfoContents::Composite { ty, fragments } => {\n+                write!(fmt, \"{:?}{{ \", ty)?;\n+                for f in fragments.iter() {\n+                    write!(fmt, \"{:?}, \", f)?;\n+                }\n+                write!(fmt, \"}}\")\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n+pub struct VarDebugInfoFragment<'tcx> {\n+    /// Where in the composite user variable this fragment is,\n+    /// represented as a \"projection\" into the composite variable.\n+    /// At lower levels, this corresponds to a byte/bit range.\n+    // NOTE(eddyb) there's an unenforced invariant that this contains\n+    // only `Field`s, and not into `enum` variants or `union`s.\n+    // FIXME(eddyb) support this for `enum`s by either using DWARF's\n+    // more advanced control-flow features (unsupported by LLVM?)\n+    // to match on the discriminant, or by using custom type debuginfo\n+    // with non-overlapping variants for the composite variable.\n+    pub projection: Vec<PlaceElem<'tcx>>,\n+\n+    /// Where the data for this fragment can be found.\n+    // NOTE(eddyb) There's an unenforced invariant that this `Place` is\n+    // contains no indexing (with a non-constant index).\n+    pub contents: Place<'tcx>,\n+}\n+\n+impl Debug for VarDebugInfoFragment<'_> {\n+    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n+        for elem in self.projection.iter() {\n+            match elem {\n+                ProjectionElem::Field(field, _) => {\n+                    write!(fmt, \".{:?}\", field.index())?;\n+                }\n+                _ => bug!(\"unsupported fragment projection `{:?}`\", elem),\n+            }\n         }\n+\n+        write!(fmt, \" => {:?}\", self.contents)\n     }\n }\n "}, {"sha": "b21f50ae5eaa95a42689ce9ccbf614c65aced654", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=b550eabfa6f371270c02644a19ad45415938fd68", "patch": "@@ -847,6 +847,17 @@ macro_rules! make_mir_visitor {\n                             PlaceContext::NonUse(NonUseContext::VarDebugInfo),\n                             location\n                         ),\n+                    VarDebugInfoContents::Composite { ty, fragments } => {\n+                        // FIXME(eddyb) use a better `TyContext` here.\n+                        self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n+                        for VarDebugInfoFragment { projection: _, contents } in fragments {\n+                            self.visit_place(\n+                                contents,\n+                                PlaceContext::NonUse(NonUseContext::VarDebugInfo),\n+                                location,\n+                            );\n+                        }\n+                    }\n                 }\n             }\n "}, {"sha": "f56982b6721ad6ffab1bf76cdd1bffd6358b9f93", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b550eabfa6f371270c02644a19ad45415938fd68/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=b550eabfa6f371270c02644a19ad45415938fd68", "patch": "@@ -1,5 +1,6 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n+#![feature(drain_filter)]\n #![feature(let_chains)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]"}]}