{"sha": "bb830558d13a8090988141c90ed49b16895c944a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiODMwNTU4ZDEzYTgwOTA5ODgxNDFjOTBlZDQ5YjE2ODk1Yzk0NGE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-06-26T01:25:27Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-06-28T14:44:17Z"}, "message": "librustc: Fix merge fallout and test cases.", "tree": {"sha": "a9a23d43d368465695ca2e107905e1ef6872970c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9a23d43d368465695ca2e107905e1ef6872970c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb830558d13a8090988141c90ed49b16895c944a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb830558d13a8090988141c90ed49b16895c944a", "html_url": "https://github.com/rust-lang/rust/commit/bb830558d13a8090988141c90ed49b16895c944a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb830558d13a8090988141c90ed49b16895c944a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e015bee2866a802f17c84bd6d3a06212945a9d17", "url": "https://api.github.com/repos/rust-lang/rust/commits/e015bee2866a802f17c84bd6d3a06212945a9d17", "html_url": "https://github.com/rust-lang/rust/commit/e015bee2866a802f17c84bd6d3a06212945a9d17"}], "stats": {"total": 789, "additions": 743, "deletions": 46}, "files": [{"sha": "c4fb03a7a7dea553f247b4dae9a57b70d9349675", "filename": "src/libextra/crypto/digest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -49,9 +49,9 @@ fn to_hex(rr: &[u8]) -> ~str {\n     for rr.iter().advance() |b| {\n         let hex = uint::to_str_radix(*b as uint, 16u);\n         if hex.len() == 1 {\n-            s += \"0\";\n+            s.push_char('0');\n         }\n-        s += hex;\n+        s.push_str(hex);\n     }\n     return s;\n }"}, {"sha": "5180a71939c3ad20117d7bd66530a5faea7228f9", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -470,13 +470,14 @@ priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n                         FormatHex|FormatHEX => 16,\n                         FormatString => util::unreachable()\n                     };\n-                    let mut (s,_) = match op {\n+                    let (s,_) = match op {\n                         FormatDigit => {\n                             let sign = if flags.sign { SignAll } else { SignNeg };\n                             to_str_bytes_common(&d, radix, false, sign, DigAll)\n                         }\n                         _ => to_str_bytes_common(&(d as uint), radix, false, SignNone, DigAll)\n                     };\n+                    let mut s = s;\n                     if flags.precision > s.len() {\n                         let mut s_ = vec::with_capacity(flags.precision);\n                         let n = flags.precision - s.len();"}, {"sha": "ec86b43ffa3c69981b4951a7614eed78bf7ddf09", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -403,8 +403,12 @@ mod test {\n \n     fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n         let mut attrs = ~[];\n-        if with_bin { attrs += [make_crate_type_attr(@\"bin\")]; }\n-        if with_lib { attrs += [make_crate_type_attr(@\"lib\")]; }\n+        if with_bin {\n+            attrs.push(make_crate_type_attr(@\"bin\"));\n+        }\n+        if with_lib {\n+            attrs.push(make_crate_type_attr(@\"lib\"));\n+        }\n         @codemap::respan(codemap::dummy_sp(), ast::crate_ {\n             module: ast::_mod { view_items: ~[], items: ~[] },\n             attrs: attrs,"}, {"sha": "e394c8dcf92f92f48e2959d7038407f492791969", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -484,7 +484,7 @@ fn each_auxiliary_node_id(item: @item, callback: &fn(node_id) -> bool)\n     let mut continue = true;\n     match item.node {\n         item_enum(ref enum_def, _) => {\n-            for enum_def.variants.each |variant| {\n+            for enum_def.variants.iter().advance |variant| {\n                 continue = callback(variant.node.id);\n                 if !continue {\n                     break\n@@ -516,7 +516,7 @@ fn encode_reexports(ecx: &EncodeContext,\n     match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n-            for exports.each |exp| {\n+            for exports.iter().advance |exp| {\n                 debug!(\"(encoding info for module) reexport '%s' for %d\",\n                        exp.name, id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n@@ -900,7 +900,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n \n         // Encode all the items in this module.\n-        for fm.items.each |foreign_item| {\n+        for fm.items.iter().advance |foreign_item| {\n             ebml_w.start_tag(tag_mod_child);\n             ebml_w.wr_str(def_to_str(local_def(foreign_item.id)));\n             ebml_w.end_tag();\n@@ -1506,7 +1506,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_misc_info);\n     ebml_w.start_tag(tag_misc_info_crate_items);\n-    for crate.node.module.items.each |&item| {\n+    for crate.node.module.items.iter().advance |&item| {\n         ebml_w.start_tag(tag_mod_child);\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();"}, {"sha": "fe7eccf9d594a647dff0973977b4fa223e31d3a6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -140,7 +140,7 @@ impl ReachableContext {\n                     }\n                     item_enum(ref enum_def, _) => {\n                         if privacy_context == PublicContext {\n-                            for enum_def.variants.each |variant| {\n+                            for enum_def.variants.iter().advance |variant| {\n                                 reachable_symbols.insert(variant.node.id);\n                             }\n                         }\n@@ -159,7 +159,7 @@ impl ReachableContext {\n                         };\n \n                         // Mark all public methods as reachable.\n-                        for methods.each |&method| {\n+                        for methods.iter().advance |&method| {\n                             if should_be_considered_public(method) {\n                                 reachable_symbols.insert(method.id);\n                             }\n@@ -168,15 +168,15 @@ impl ReachableContext {\n                         if generics_require_inlining(generics) {\n                             // If the impl itself has generics, add all public\n                             // symbols to the worklist.\n-                            for methods.each |&method| {\n+                            for methods.iter().advance |&method| {\n                                 if should_be_considered_public(method) {\n                                     worklist.push(method.id)\n                                 }\n                             }\n                         } else {\n                             // Otherwise, add only public methods that have\n                             // generics to the worklist.\n-                            for methods.each |method| {\n+                            for methods.iter().advance |method| {\n                                 let generics = &method.generics;\n                                 let attrs = &method.attrs;\n                                 if generics_require_inlining(generics) ||\n@@ -190,7 +190,7 @@ impl ReachableContext {\n                     item_trait(_, _, ref trait_methods) => {\n                         // Mark all provided methods as reachable.\n                         if privacy_context == PublicContext {\n-                            for trait_methods.each |trait_method| {\n+                            for trait_methods.iter().advance |trait_method| {\n                                 match *trait_method {\n                                     provided(method) => {\n                                         reachable_symbols.insert(method.id);"}, {"sha": "aa7033221cf25f18af9289a9a59911a26221a5ef", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -1240,7 +1240,7 @@ impl Resolver {\n                 // Create the module and add all methods.\n                 match *ty {\n                     Ty {\n-                        node: ty_path(path, _),\n+                        node: ty_path(path, _, _),\n                         _\n                     } if path.idents.len() == 1 => {\n                         let name = path_to_ident(path);"}, {"sha": "dc32a3b4e2c884e9d5ff3afe2cfa15bf06c2e8ec", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -616,7 +616,7 @@ pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     // we care about.\n     if ixs.len() < 16 {\n         let mut small_vec = [ C_i32(0), ..16 ];\n-        for ixs.eachi |i, &ix| {\n+        for ixs.iter().enumerate().advance |(i, &ix)| {\n             small_vec[i] = C_i32(ix as i32)\n         }\n         InBoundsGEP(cx, base, small_vec.slice(0, ixs.len()))"}, {"sha": "6c264e637a60b944456ea0bb5e406b99ec92ed97", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -39,7 +39,11 @@ enum RegClass {\n     Memory\n }\n \n-impl Type {\n+trait TypeMethods {\n+    fn is_reg_ty(&self) -> bool;\n+}\n+\n+impl TypeMethods for Type {\n     fn is_reg_ty(&self) -> bool {\n         match self.kind() {\n             Integer | Pointer | Float | Double => true,"}, {"sha": "f88c59988626cdc4a10b6adeea2297d573cee453", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -1908,7 +1908,7 @@ impl TypeContents {\n             // this assertion.\n             assert!(self.intersects(TC_OWNED_POINTER));\n         }\n-        let tc = TC_MANAGED + TC_DTOR + TypeContents::owned(cx);\n+        let tc = TC_MANAGED + TC_DTOR + TypeContents::sendable(cx);\n         self.intersects(tc)\n     }\n "}, {"sha": "4bebca3c9a8b3308caff76da6b2fd9cbfd8dd9e5", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -1088,16 +1088,19 @@ impl<'self> LookupContext<'self> {\n             _ => {}\n         }\n \n-        return match candidate.method_ty.explicit_self {\n+        let result = match candidate.method_ty.explicit_self {\n             sty_static => {\n+                debug!(\"(is relevant?) explicit self is static\");\n                 false\n             }\n \n             sty_value => {\n+                debug!(\"(is relevant?) explicit self is by-value\");\n                 self.fcx.can_mk_subty(rcvr_ty, candidate.rcvr_ty).is_ok()\n             }\n \n             sty_region(_, m) => {\n+                debug!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1109,6 +1112,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_box(m) => {\n+                debug!(\"(is relevant?) explicit self is a box\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_box(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1120,6 +1124,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_uniq(m) => {\n+                debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1131,6 +1136,10 @@ impl<'self> LookupContext<'self> {\n             }\n         };\n \n+        debug!(\"(is relevant?) %s\", if result { \"yes\" } else { \"no\" });\n+\n+        return result;\n+\n         fn mutability_matches(self_mutbl: ast::mutability,\n                               candidate_mutbl: ast::mutability) -> bool {\n             //! True if `self_mutbl <: candidate_mutbl`"}, {"sha": "a537d0cc72c571ed64c9d931bd44f16ddbb4cca4", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -895,8 +895,22 @@ impl CoherenceChecker {\n         }\n \n         // Record all the trait methods.\n-        let implementation = @implementation;\n+        let mut implementation = @implementation;\n         for associated_traits.iter().advance |trait_ref| {\n+            self.instantiate_default_methods(implementation.did,\n+                                             *trait_ref);\n+\n+            // XXX(sully): We could probably avoid this copy if there are no\n+            // default methods.\n+            let mut methods = copy implementation.methods;\n+            self.add_provided_methods_to_impl(&mut methods,\n+                                              &trait_ref.def_id,\n+                                              &implementation.did);\n+            implementation = @Impl {\n+                methods: methods,\n+                ..*implementation\n+            };\n+\n             self.add_trait_method(trait_ref.def_id, implementation);\n         }\n \n@@ -929,9 +943,6 @@ impl CoherenceChecker {\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n             for each_path(crate_store, crate_number) |_, def_like, _| {\n                 match def_like {\n-                    dl_def(def_trait(def_id)) => {\n-                        self.add_default_methods_for_external_trait(def_id);\n-                    }\n                     dl_impl(def_id) => {\n                         self.add_external_impl(&mut impls_seen,\n                                                crate_store,"}, {"sha": "548eebaea0bea78c16a814abf0c3f8c0b5f926d5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -488,7 +488,9 @@ pub fn parameterized(cx: ctxt,\n         }\n     };\n \n-    strs += vec::map(tps, |t| ty_to_str(cx, *t));\n+    for tps.iter().advance |t| {\n+        strs.push(ty_to_str(cx, *t))\n+    }\n \n     if strs.len() > 0u {\n         fmt!(\"%s<%s>\", base, strs.connect(\",\"))"}, {"sha": "5873f361ad7341dc42bfafa054defe81dd2f7067", "filename": "src/librusti/rusti.rc", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -0,0 +1,666 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * rusti - A REPL using the JIT backend\n+ *\n+ * Rusti works by serializing state between lines of input. This means that each\n+ * line can be run in a separate task, and the only limiting factor is that all\n+ * local bound variables are encodable.\n+ *\n+ * This is accomplished by feeding in generated input to rustc for execution in\n+ * the JIT compiler. Currently input actually gets fed in three times to get\n+ * information about the program.\n+ *\n+ * - Pass #1\n+ *   In this pass, the input is simply thrown at the parser and the input comes\n+ *   back. This validates the structure of the program, and at this stage the\n+ *   global items (fns, structs, impls, traits, etc.) are filtered from the\n+ *   input into the \"global namespace\". These declarations shadow all previous\n+ *   declarations of an item by the same name.\n+ *\n+ * - Pass #2\n+ *   After items have been stripped, the remaining input is passed to rustc\n+ *   along with all local variables declared (initialized to nothing). This pass\n+ *   runs up to typechecking. From this, we can learn about the types of each\n+ *   bound variable, what variables are bound, and also ensure that all the\n+ *   types are encodable (the input can actually be run).\n+ *\n+ * - Pass #3\n+ *   Finally, a program is generated to deserialize the local variable state,\n+ *   run the code input, and then reserialize all bindings back into a local\n+ *   hash map. Once this code runs, the input has fully been run and the REPL\n+ *   waits for new input.\n+ *\n+ * Encoding/decoding is done with EBML, and there is simply a map of ~str ->\n+ * ~[u8] maintaining the values of each local binding (by name).\n+ */\n+\n+#[link(name = \"rusti\",\n+       vers = \"0.7-pre\",\n+       uuid = \"7fb5bf52-7d45-4fee-8325-5ad3311149fc\",\n+       url = \"https://github.com/mozilla/rust/tree/master/src/rusti\")];\n+\n+#[license = \"MIT/ASL2\"];\n+#[crate_type = \"lib\"];\n+\n+extern mod extra;\n+extern mod rustc;\n+extern mod syntax;\n+\n+use std::{libc, io, os, task, vec};\n+use std::cell::Cell;\n+use extra::rl;\n+\n+use rustc::driver::{driver, session};\n+use syntax::{ast, diagnostic};\n+use syntax::ast_util::*;\n+use syntax::parse::token;\n+use syntax::print::pprust;\n+\n+use program::Program;\n+use utils::*;\n+\n+mod program;\n+pub mod utils;\n+\n+/**\n+ * A structure shared across REPL instances for storing history\n+ * such as statements and view items. I wish the AST was sendable.\n+ */\n+pub struct Repl {\n+    prompt: ~str,\n+    binary: ~str,\n+    running: bool,\n+    lib_search_paths: ~[~str],\n+\n+    program: Program,\n+}\n+\n+// Action to do after reading a :command\n+enum CmdAction {\n+    action_none,\n+    action_run_line(~str),\n+}\n+\n+/// Run an input string in a Repl, returning the new Repl.\n+fn run(mut repl: Repl, input: ~str) -> Repl {\n+    // Build some necessary rustc boilerplate for compiling things\n+    let binary = repl.binary.to_managed();\n+    let options = @session::options {\n+        crate_type: session::unknown_crate,\n+        binary: binary,\n+        addl_lib_search_paths: @mut repl.lib_search_paths.map(|p| Path(*p)),\n+        jit: true,\n+        .. copy *session::basic_options()\n+    };\n+    // Because we assume that everything is encodable (and assert so), add some\n+    // extra helpful information if the error crops up. Otherwise people are\n+    // bound to be very confused when they find out code is running that they\n+    // never typed in...\n+    let sess = driver::build_session(options, |cm, msg, lvl| {\n+        diagnostic::emit(cm, msg, lvl);\n+        if msg.contains(\"failed to find an implementation of trait\") &&\n+           msg.contains(\"extra::serialize::Encodable\") {\n+            diagnostic::emit(cm,\n+                             \"Currrently rusti serializes bound locals between \\\n+                              different lines of input. This means that all \\\n+                              values of local variables need to be encodable, \\\n+                              and this type isn't encodable\",\n+                             diagnostic::note);\n+        }\n+    });\n+    let intr = token::get_ident_interner();\n+\n+    //\n+    // Stage 1: parse the input and filter it into the program (as necessary)\n+    //\n+    debug!(\"parsing: %s\", input);\n+    let crate = parse_input(sess, binary, input);\n+    let mut to_run = ~[];       // statements to run (emitted back into code)\n+    let new_locals = @mut ~[];  // new locals being defined\n+    let mut result = None;      // resultant expression (to print via pp)\n+    do find_main(crate, sess) |blk| {\n+        // Fish out all the view items, be sure to record 'extern mod' items\n+        // differently beause they must appear before all 'use' statements\n+        for blk.node.view_items.iter().advance |vi| {\n+            let s = do with_pp(intr) |pp, _| {\n+                pprust::print_view_item(pp, *vi);\n+            };\n+            match vi.node {\n+                ast::view_item_extern_mod(*) => {\n+                    repl.program.record_extern(s);\n+                }\n+                ast::view_item_use(*) => { repl.program.record_view_item(s); }\n+            }\n+        }\n+\n+        // Iterate through all of the block's statements, inserting them into\n+        // the correct portions of the program\n+        for blk.node.stmts.iter().advance |stmt| {\n+            let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n+            match stmt.node {\n+                ast::stmt_decl(d, _) => {\n+                    match d.node {\n+                        ast::decl_item(it) => {\n+                            let name = sess.str_of(it.ident);\n+                            match it.node {\n+                                // Structs are treated specially because to make\n+                                // them at all usable they need to be decorated\n+                                // with #[deriving(Encoable, Decodable)]\n+                                ast::item_struct(*) => {\n+                                    repl.program.record_struct(name, s);\n+                                }\n+                                // Item declarations are hoisted out of main()\n+                                _ => { repl.program.record_item(name, s); }\n+                            }\n+                        }\n+\n+                        // Local declarations must be specially dealt with,\n+                        // record all local declarations for use later on\n+                        ast::decl_local(l) => {\n+                            let mutbl = l.node.is_mutbl;\n+                            do each_binding(l) |path, _| {\n+                                let s = do with_pp(intr) |pp, _| {\n+                                    pprust::print_path(pp, path, false);\n+                                };\n+                                new_locals.push((s, mutbl));\n+                            }\n+                            to_run.push(s);\n+                        }\n+                    }\n+                }\n+\n+                // run statements with expressions (they have effects)\n+                ast::stmt_mac(*) | ast::stmt_semi(*) | ast::stmt_expr(*) => {\n+                    to_run.push(s);\n+                }\n+            }\n+        }\n+        result = do blk.node.expr.map_consume |e| {\n+            do with_pp(intr) |pp, _| { pprust::print_expr(pp, e); }\n+        };\n+    }\n+    // return fast for empty inputs\n+    if to_run.len() == 0 && result.is_none() {\n+        return repl;\n+    }\n+\n+    //\n+    // Stage 2: run everything up to typeck to learn the types of the new\n+    //          variables introduced into the program\n+    //\n+    info!(\"Learning about the new types in the program\");\n+    repl.program.set_cache(); // before register_new_vars (which changes them)\n+    let input = to_run.connect(\"\\n\");\n+    let test = repl.program.test_code(input, &result, *new_locals);\n+    debug!(\"testing with ^^^^^^ %?\", (||{ println(test) })());\n+    let dinput = driver::str_input(test.to_managed());\n+    let cfg = driver::build_configuration(sess, binary, &dinput);\n+    let outputs = driver::build_output_filenames(&dinput, &None, &None, [], sess);\n+    let (crate, tcx) = driver::compile_upto(sess, copy cfg, &dinput,\n+                                            driver::cu_typeck, Some(outputs));\n+    // Once we're typechecked, record the types of all local variables defined\n+    // in this input\n+    do find_main(crate.expect(\"crate after cu_typeck\"), sess) |blk| {\n+        repl.program.register_new_vars(blk, tcx.expect(\"tcx after cu_typeck\"));\n+    }\n+\n+    //\n+    // Stage 3: Actually run the code in the JIT\n+    //\n+    info!(\"actually running code\");\n+    let code = repl.program.code(input, &result);\n+    debug!(\"actually running ^^^^^^ %?\", (||{ println(code) })());\n+    let input = driver::str_input(code.to_managed());\n+    let cfg = driver::build_configuration(sess, binary, &input);\n+    let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n+    let sess = driver::build_session(options, diagnostic::emit);\n+    driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n+                         Some(outputs));\n+\n+    //\n+    // Stage 4: Inform the program that computation is done so it can update all\n+    //          local variable bindings.\n+    //\n+    info!(\"cleaning up after code\");\n+    repl.program.consume_cache();\n+\n+    return repl;\n+\n+    fn parse_input(sess: session::Session, binary: @str,\n+                   input: &str) -> @ast::crate {\n+        let code = fmt!(\"fn main() {\\n %s \\n}\", input);\n+        let input = driver::str_input(code.to_managed());\n+        let cfg = driver::build_configuration(sess, binary, &input);\n+        let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n+        let (crate, _) = driver::compile_upto(sess, cfg, &input,\n+                                              driver::cu_parse, Some(outputs));\n+        crate.expect(\"parsing should return a crate\")\n+    }\n+\n+    fn find_main(crate: @ast::crate, sess: session::Session,\n+                 f: &fn(&ast::blk)) {\n+        for crate.node.module.items.iter().advance |item| {\n+            match item.node {\n+                ast::item_fn(_, _, _, _, ref blk) => {\n+                    if item.ident == sess.ident_of(\"main\") {\n+                        return f(blk);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        fail!(\"main function was expected somewhere...\");\n+    }\n+}\n+\n+// Compiles a crate given by the filename as a library if the compiled\n+// version doesn't exist or is older than the source file. Binary is\n+// the name of the compiling executable. Returns Some(true) if it\n+// successfully compiled, Some(false) if the crate wasn't compiled\n+// because it already exists and is newer than the source file, or\n+// None if there were compile errors.\n+fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n+    match do task::try {\n+        let src_path = Path(src_filename);\n+        let binary = binary.to_managed();\n+        let options = @session::options {\n+            binary: binary,\n+            addl_lib_search_paths: @mut ~[os::getcwd()],\n+            .. copy *session::basic_options()\n+        };\n+        let input = driver::file_input(copy src_path);\n+        let sess = driver::build_session(options, diagnostic::emit);\n+        *sess.building_library = true;\n+        let cfg = driver::build_configuration(sess, binary, &input);\n+        let outputs = driver::build_output_filenames(\n+            &input, &None, &None, [], sess);\n+        // If the library already exists and is newer than the source\n+        // file, skip compilation and return None.\n+        let mut should_compile = true;\n+        let dir = os::list_dir_path(&Path(outputs.out_filename.dirname()));\n+        let maybe_lib_path = do dir.iter().find_ |file| {\n+            // The actual file's name has a hash value and version\n+            // number in it which is unknown at this time, so looking\n+            // for a file that matches out_filename won't work,\n+            // instead we guess which file is the library by matching\n+            // the prefix and suffix of out_filename to files in the\n+            // directory.\n+            let file_str = file.filename().get();\n+            file_str.starts_with(outputs.out_filename.filestem().get())\n+                && file_str.ends_with(outputs.out_filename.filetype().get())\n+        };\n+        match maybe_lib_path {\n+            Some(lib_path) => {\n+                let (src_mtime, _) = src_path.get_mtime().get();\n+                let (lib_mtime, _) = lib_path.get_mtime().get();\n+                if lib_mtime >= src_mtime {\n+                    should_compile = false;\n+                }\n+            },\n+            None => { },\n+        }\n+        if (should_compile) {\n+            println(fmt!(\"compiling %s...\", src_filename));\n+            driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n+                                 Some(outputs));\n+            true\n+        } else { false }\n+    } {\n+        Ok(true) => Some(true),\n+        Ok(false) => Some(false),\n+        Err(_) => None,\n+    }\n+}\n+\n+/// Tries to get a line from rl after outputting a prompt. Returns\n+/// None if no input was read (e.g. EOF was reached).\n+fn get_line(use_rl: bool, prompt: &str) -> Option<~str> {\n+    if use_rl {\n+        let result = unsafe { rl::read(prompt) };\n+\n+        match result {\n+            None => None,\n+            Some(line) => {\n+                unsafe { rl::add_history(line) };\n+                Some(line)\n+            }\n+        }\n+    } else {\n+        if io::stdin().eof() {\n+            None\n+        } else {\n+            Some(io::stdin().read_line())\n+        }\n+    }\n+}\n+\n+/// Run a command, e.g. :clear, :exit, etc.\n+fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n+           cmd: ~str, args: ~[~str], use_rl: bool) -> CmdAction {\n+    let mut action = action_none;\n+    match cmd {\n+        ~\"exit\" => repl.running = false,\n+        ~\"clear\" => {\n+            repl.program.clear();\n+\n+            // XXX: Win32 version of linenoise can't do this\n+            //rl::clear();\n+        }\n+        ~\"help\" => {\n+            println(\n+                \":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\\\n+                 :load <crate> ... - loads given crates as dynamic libraries\\n\\\n+                 :clear - clear the bindings\\n\\\n+                 :exit - exit from the repl\\n\\\n+                 :help - show this message\");\n+        }\n+        ~\"load\" => {\n+            let mut loaded_crates: ~[~str] = ~[];\n+            for args.iter().advance |arg| {\n+                let (crate, filename) =\n+                    if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n+                    (arg.slice_to(arg.len() - 3).to_owned(), copy *arg)\n+                } else {\n+                    (copy *arg, *arg + \".rs\")\n+                };\n+                match compile_crate(filename, copy repl.binary) {\n+                    Some(_) => loaded_crates.push(crate),\n+                    None => { }\n+                }\n+            }\n+            for loaded_crates.iter().advance |crate| {\n+                let crate_path = Path(*crate);\n+                let crate_dir = crate_path.dirname();\n+                repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n+                if !repl.lib_search_paths.iter().any_(|x| x == &crate_dir) {\n+                    repl.lib_search_paths.push(crate_dir);\n+                }\n+            }\n+            if loaded_crates.is_empty() {\n+                println(\"no crates loaded\");\n+            } else {\n+                println(fmt!(\"crates loaded: %s\",\n+                                 loaded_crates.connect(\", \")));\n+            }\n+        }\n+        ~\"{\" => {\n+            let mut multiline_cmd = ~\"\";\n+            let mut end_multiline = false;\n+            while (!end_multiline) {\n+                match get_line(use_rl, \"rusti| \") {\n+                    None => fail!(\"unterminated multiline command :{ .. :}\"),\n+                    Some(line) => {\n+                        if line.trim() == \":}\" {\n+                            end_multiline = true;\n+                        } else {\n+                            multiline_cmd.push_str(line);\n+                            multiline_cmd.push_char('\\n');\n+                        }\n+                    }\n+                }\n+            }\n+            action = action_run_line(multiline_cmd);\n+        }\n+        _ => println(~\"unknown cmd: \" + cmd)\n+    }\n+    return action;\n+}\n+\n+/// Executes a line of input, which may either be rust code or a\n+/// :command. Returns a new Repl if it has changed.\n+pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n+                use_rl: bool)\n+    -> Option<Repl> {\n+    if line.starts_with(\":\") {\n+        // drop the : and the \\n (one byte each)\n+        let full = line.slice(1, line.len());\n+        let split: ~[~str] = full.word_iter().transform(|s| s.to_owned()).collect();\n+        let len = split.len();\n+\n+        if len > 0 {\n+            let cmd = copy split[0];\n+\n+            if !cmd.is_empty() {\n+                let args = if len > 1 {\n+                    vec::slice(split, 1, len).to_owned()\n+                } else { ~[] };\n+\n+                match run_cmd(repl, in, out, cmd, args, use_rl) {\n+                    action_none => { }\n+                    action_run_line(multiline_cmd) => {\n+                        if !multiline_cmd.is_empty() {\n+                            return run_line(repl, in, out, multiline_cmd, use_rl);\n+                        }\n+                    }\n+                }\n+                return None;\n+            }\n+        }\n+    }\n+\n+    let line = Cell::new(line);\n+    let r = Cell::new(copy *repl);\n+    let result = do task::try {\n+        run(r.take(), line.take())\n+    };\n+\n+    if result.is_ok() {\n+        return Some(result.get());\n+    }\n+    return None;\n+}\n+\n+pub fn main() {\n+    let args = os::args();\n+    let in = io::stdin();\n+    let out = io::stdout();\n+    let mut repl = Repl {\n+        prompt: ~\"rusti> \",\n+        binary: copy args[0],\n+        running: true,\n+        lib_search_paths: ~[],\n+\n+        program: Program::new(),\n+    };\n+\n+    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n+\n+    // only print this stuff if the user is actually typing into rusti\n+    if istty {\n+        println(\"WARNING: The Rust REPL is experimental and may be\");\n+        println(\"unstable. If you encounter problems, please use the\");\n+        println(\"compiler instead. Type :help for help.\");\n+\n+        unsafe {\n+            do rl::complete |line, suggest| {\n+                if line.starts_with(\":\") {\n+                    suggest(~\":clear\");\n+                    suggest(~\":exit\");\n+                    suggest(~\":help\");\n+                    suggest(~\":load\");\n+                }\n+            }\n+        }\n+    }\n+\n+    while repl.running {\n+        match get_line(istty, repl.prompt) {\n+            None => break,\n+            Some(line) => {\n+                if line.is_empty() {\n+                    if istty {\n+                        println(\"()\");\n+                    }\n+                    loop;\n+                }\n+                match run_line(&mut repl, in, out, line, istty) {\n+                    Some(new_repl) => repl = new_repl,\n+                    None => { }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::io;\n+    use std::iterator::IteratorUtil;\n+    use program::Program;\n+    use super::*;\n+\n+    fn repl() -> Repl {\n+        Repl {\n+            prompt: ~\"rusti> \",\n+            binary: ~\"rusti\",\n+            running: true,\n+            lib_search_paths: ~[],\n+            program: Program::new(),\n+        }\n+    }\n+\n+    fn run_program(prog: &str) {\n+        let mut r = repl();\n+        for prog.split_iter('\\n').advance |cmd| {\n+            let result = run_line(&mut r, io::stdin(), io::stdout(),\n+                                  cmd.to_owned(), false);\n+            r = result.expect(fmt!(\"the command '%s' failed\", cmd));\n+        }\n+    }\n+\n+    #[test]\n+    // FIXME: #7220 rusti on 32bit mac doesn't work.\n+    #[cfg(not(target_word_size=\"32\",\n+              target_os=\"macos\"))]\n+    fn run_all() {\n+        // FIXME(#7071):\n+        // By default, unit tests are run in parallel. Rusti, on the other hand,\n+        // does not enjoy doing this. I suspect that it is because the LLVM\n+        // bindings are not thread-safe (when running parallel tests, some tests\n+        // were triggering assertions in LLVM (or segfaults). Hence, this\n+        // function exists to run everything serially (sadface).\n+        //\n+        // To get some interesting output, run with RUST_LOG=rusti::tests\n+\n+        debug!(\"hopefully this runs\");\n+        run_program(\"\");\n+\n+        debug!(\"regression test for #5937\");\n+        run_program(\"use std::hashmap;\");\n+\n+        debug!(\"regression test for #5784\");\n+        run_program(\"let a = 3;\");\n+\n+        // XXX: can't spawn new tasks because the JIT code is cleaned up\n+        //      after the main function is done.\n+        // debug!(\"regression test for #5803\");\n+        // run_program(\"\n+        //     spawn( || println(\\\"Please don't segfault\\\") );\n+        //     do spawn { println(\\\"Please?\\\"); }\n+        // \");\n+\n+        debug!(\"inferred integers are usable\");\n+        run_program(\"let a = 2;\\n()\\n\");\n+        run_program(\"\n+            let a = 3;\n+            let b = 4u;\n+            assert!((a as uint) + b == 7)\n+        \");\n+\n+        debug!(\"local variables can be shadowed\");\n+        run_program(\"\n+            let a = 3;\n+            let a = 5;\n+            assert!(a == 5)\n+        \");\n+\n+        debug!(\"strings are usable\");\n+        run_program(\"\n+            let a = ~\\\"\\\";\n+            let b = \\\"\\\";\n+            let c = @\\\"\\\";\n+            let d = a + b + c;\n+            assert!(d.len() == 0);\n+        \");\n+\n+        debug!(\"vectors are usable\");\n+        run_program(\"\n+            let a = ~[1, 2, 3];\n+            let b = &[1, 2, 3];\n+            let c = @[1, 2, 3];\n+            let d = a + b + c;\n+            assert!(d.len() == 9);\n+            let e: &[int] = [];\n+        \");\n+\n+        debug!(\"structs are usable\");\n+        run_program(\"\n+            struct A{ a: int }\n+            let b = A{ a: 3 };\n+            assert!(b.a == 3)\n+        \");\n+\n+        debug!(\"mutable variables\");\n+        run_program(\"\n+            let mut a = 3;\n+            a = 5;\n+            let mut b = std::hashmap::HashSet::new::<int>();\n+            b.insert(a);\n+            assert!(b.contains(&5))\n+            assert!(b.len() == 1)\n+        \");\n+\n+        debug!(\"functions are cached\");\n+        run_program(\"\n+            fn fib(x: int) -> int { if x < 2 {x} else { fib(x - 1) + fib(x - 2) } }\n+            let a = fib(3);\n+            let a = a + fib(4);\n+            assert!(a == 5)\n+        \");\n+\n+        debug!(\"modules are cached\");\n+        run_program(\"\n+            mod b { pub fn foo() -> uint { 3 } }\n+            assert!(b::foo() == 3)\n+        \");\n+\n+        debug!(\"multiple function definitions are allowed\");\n+        run_program(\"\n+            fn f() {}\n+            fn f() {}\n+            f()\n+        \");\n+\n+        debug!(\"multiple item definitions are allowed\");\n+        run_program(\"\n+            fn f() {}\n+            mod f {}\n+            struct f;\n+            enum f {}\n+            fn f() {}\n+            f()\n+        \");\n+    }\n+\n+    #[test]\n+    // FIXME: #7220 rusti on 32bit mac doesn't work.\n+    #[cfg(not(target_word_size=\"32\",\n+              target_os=\"macos\"))]\n+    fn exit_quits() {\n+        let mut r = repl();\n+        assert!(r.running);\n+        let result = run_line(&mut r, io::stdin(), io::stdout(),\n+                              ~\":exit\", false);\n+        assert!(result.is_none());\n+        assert!(!r.running);\n+    }\n+}"}, {"sha": "83dcde48b3a8e4268dbb8b057d6979c558db7ddb", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -248,7 +248,7 @@ fn command_line_test_output(args: &[~str]) -> ~[~str] {\n     let p_output = command_line_test(args, &os::getcwd());\n     let test_output = str::from_bytes(p_output.output);\n     for test_output.split_iter('\\n').advance |s| {\n-        result += [s.to_owned()];\n+        result.push(s.to_owned());\n     }\n     result\n }"}, {"sha": "77701acd33e2eec8d88ced57ae28556e9def5aa5", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -55,7 +55,7 @@ impl<A:ToStr+Hash+Eq, B:ToStr+Hash+Eq> ToStr for HashMap<A, B> {\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"{\";\n         let mut first = true;\n-        for self.iter().advance |key, value| {\n+        for self.iter().advance |(key, value)| {\n             if first {\n                 first = false;\n             }"}, {"sha": "793626f0e1808a369d7afaef0522ac4aa779f1f7", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -563,7 +563,7 @@ pub mod keywords {\n         // Strict keywords\n         As,\n         Break,\n-        Freeze,\n+        Const,\n         Copy,\n         Do,\n         Else,"}, {"sha": "0c9220d18ab760949e35fa5d79a31aab960def88", "filename": "src/test/compile-fail/closure-bounds-subtype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -8,7 +8,7 @@ fn take_copyable(_: &fn:Copy()) {\n fn take_copyable_owned(_: &fn:Copy+Send()) {\n }\n \n-fn take_const_owned(_: &fn:Const+Owned()) {\n+fn take_const_owned(_: &fn:Freeze+Send()) {\n }\n \n fn give_any(f: &fn:()) {\n@@ -33,7 +33,7 @@ fn give_copyable_owned(f: &fn:Copy+Send()) {\n     take_any(f);\n     take_copyable(f);\n     take_copyable_owned(f);\n-    take_const_owned(f); //~ ERROR expected bounds `Owned+Const` but found bounds `Copy+Owned`\n+    take_const_owned(f); //~ ERROR expected bounds `Send+Freeze` but found bounds `Copy+Send`\n }\n \n fn main() {}"}, {"sha": "c6ce4d04e10866951d30c17fadb8c4dfefb1e56b", "filename": "src/test/compile-fail/impl-duplicate-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -11,7 +11,7 @@\n struct Foo;\n impl Foo {\n     fn orange(&self){}\n-    fn orange(&self){}   //~ ERROR error: duplicate definition of method `orange`\n+    fn orange(&self){}   //~ ERROR error: duplicate definition of value `orange`\n }\n \n fn main() {}"}, {"sha": "a96da398f5a1195dd27c9455619d561681df0523", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -11,14 +11,14 @@\n trait Foo {\n }\n \n-fn a(_x: ~Foo:Owned) {\n+fn a(_x: ~Foo:Send) {\n }\n \n-fn b(_x: ~Foo:Owned+Copy) {\n+fn b(_x: ~Foo:Send+Copy) {\n }\n \n-fn c(x: ~Foo:Const+Owned) {\n-    b(x); //~ ERROR expected bounds `Copy+Owned`\n+fn c(x: ~Foo:Freeze+Send) {\n+    b(x); //~ ERROR expected bounds `Copy+Send`\n }\n \n fn d(x: ~Foo:) {"}, {"sha": "d7c98ec4e9d242bc3ac556c5ddbeebc872e6dd90", "filename": "src/test/compile-fail/trait-bounds-not-on-bare-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -13,7 +13,7 @@ trait Foo {\n \n // This should emit the less confusing error, not the more confusing one.\n \n-fn foo(_x: Foo:Owned) { //~ERROR reference to trait `Foo` where a type is expected\n+fn foo(_x: Foo:Send) { //~ERROR reference to trait `Foo` where a type is expected\n }\n \n fn main() { }"}, {"sha": "ebffd0303e0478d31104e42bd578c22116e0b7c1", "filename": "src/test/compile-fail/trait-bounds-not-on-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -10,6 +10,6 @@\n \n struct Foo;\n \n-fn foo(_x: ~Foo:Owned) { } //~ ERROR kind bounds can only be used on trait types\n+fn foo(_x: ~Foo:Send) { } //~ ERROR kind bounds can only be used on trait types\n \n fn main() { }"}, {"sha": "ba8101d16ab0f170239a811f14c718abcb0ec5fe", "filename": "src/test/compile-fail/trait-duplicate-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Ftrait-duplicate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Ftrait-duplicate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-duplicate-methods.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -10,7 +10,7 @@\n \n trait Foo {\n     fn orange(&self);\n-    fn orange(&self);   //~ ERROR error: duplicate definition of method `orange`\n+    fn orange(&self);   //~ ERROR error: duplicate definition of value `orange`\n }\n \n fn main() {}"}, {"sha": "c44887593ab3c425956eee07bf010612501ae336", "filename": "src/test/compile-fail/trait-or-new-type-instead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: implement a trait or new type instead\n+// error-pattern: found value name used as a type\n impl<T> Option<T> {\n     pub fn foo(&self) { }\n }"}, {"sha": "95b0c9d79b7cb8ebd9bdc32e964b1c8f5d2b56ea", "filename": "src/test/run-pass/closure-bounds-can-capture-chan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -10,7 +10,7 @@\n \n use std::comm;\n \n-fn foo(blk: ~fn:Owned()) {\n+fn foo(blk: ~fn:Send()) {\n     blk();\n }\n "}, {"sha": "e0d60d62bb5824798003a3f926a93b4d8433eb2b", "filename": "src/test/run-pass/trait-bounds-basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -14,14 +14,14 @@ trait Foo {\n fn a(_x: ~Foo:) {\n }\n \n-fn b(_x: ~Foo:Owned) {\n+fn b(_x: ~Foo:Send) {\n }\n \n-fn c(x: ~Foo:Const+Owned) {\n+fn c(x: ~Foo:Freeze+Send) {\n     a(x);\n }\n \n-fn d(x: ~Foo:Owned+Copy) {\n+fn d(x: ~Foo:Send+Copy) {\n     b(x);\n }\n "}, {"sha": "f6c119c4faeb32a7f64c7707f768b8fc76f851a1", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb830558d13a8090988141c90ed49b16895c944a/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=bb830558d13a8090988141c90ed49b16895c944a", "patch": "@@ -44,12 +44,12 @@ fn main () {\n     let a = thing { x: 0 };\n     let b = thing { x: 1 };\n \n-    assert_eq!(0i.g(), 10);\n+    //assert_eq!(0i.g(), 10);\n     assert_eq!(a.g(), 10);\n     assert_eq!(a.h(), 10);\n \n \n-    assert_eq!(0i.thing(3.14, 1), (3.14, 1));\n+    //assert_eq!(0i.thing(3.14, 1), (3.14, 1));\n \n     assert_eq!(g(0i, 3.14, 1), (3.14, 1));\n     assert_eq!(g(false, 3.14, 1), (3.14, 1));\n@@ -59,8 +59,8 @@ fn main () {\n \n \n     // Trying out a real one\n-    assert!(12.test_neq(&10));\n-    assert!(!10.test_neq(&10));\n+    //assert!(12.test_neq(&10));\n+    //assert!(!10.test_neq(&10));\n     assert!(a.test_neq(&b));\n     assert!(!a.test_neq(&a));\n "}]}