{"sha": "7c21f91b15b7604f818565646b686d90f99d1baf", "node_id": "C_kwDOAAsO6NoAKDdjMjFmOTFiMTViNzYwNGY4MTg1NjU2NDZiNjg2ZDkwZjk5ZDFiYWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-05T13:12:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-05T13:12:09Z"}, "message": "Auto merge of #8788 - flip1995:rustup, r=xFrednet,flip1995\n\nRustup\n\nr? `@ghost`\n\nchangelog: move trait_duplication_in_bounds and type_repetition_in_bounds to nursery temporarily. This could already be reverted before the release. Check the Clippy in the Rust repo beta branch when writing this changelog.", "tree": {"sha": "f99733e7e345d24567effd0df3f50a75051bf64c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f99733e7e345d24567effd0df3f50a75051bf64c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c21f91b15b7604f818565646b686d90f99d1baf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c21f91b15b7604f818565646b686d90f99d1baf", "html_url": "https://github.com/rust-lang/rust/commit/7c21f91b15b7604f818565646b686d90f99d1baf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c21f91b15b7604f818565646b686d90f99d1baf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7a705a842fc30c4725b003c1b8b3443f2d0c07d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7a705a842fc30c4725b003c1b8b3443f2d0c07d", "html_url": "https://github.com/rust-lang/rust/commit/c7a705a842fc30c4725b003c1b8b3443f2d0c07d"}, {"sha": "006282964f1e741a58c72d8e12f872bf5c227af9", "url": "https://api.github.com/repos/rust-lang/rust/commits/006282964f1e741a58c72d8e12f872bf5c227af9", "html_url": "https://github.com/rust-lang/rust/commit/006282964f1e741a58c72d8e12f872bf5c227af9"}], "stats": {"total": 592, "additions": 316, "deletions": 276}, "files": [{"sha": "2cfbcea5034e653beb818b1be5dc89b94b856d2c", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -10,7 +10,7 @@ indoc = \"1.0\"\n itertools = \"0.10.1\"\n opener = \"0.5\"\n shell-escape = \"0.1\"\n-tempfile = \"3.3\"\n+tempfile = \"3.2\"\n walkdir = \"2.3\"\n \n [features]"}, {"sha": "8b0e11cb802eeae0996551e3c588f45688d096bc", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::msrvs;\n use clippy_utils::source::{first_line_of_span, is_present_in_source, snippet_opt, without_block_comments};\n use clippy_utils::{extract_msrv_attr, meets_msrv};\n use if_chain::if_chain;\n-use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MacArgs, MacArgsEq, MetaItemKind, NestedMetaItem};\n use rustc_errors::Applicability;\n use rustc_hir::{\n     Block, Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, StmtKind, TraitFn, TraitItem, TraitItemKind,\n@@ -593,6 +593,10 @@ fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::It\n         };\n \n         if attr.style == AttrStyle::Outer {\n+            if let MacArgs::Eq(_, MacArgsEq::Ast(expr)) = &attr_item.args\n+                && !matches!(expr.kind, rustc_ast::ExprKind::Lit(..)) {\n+                return;\n+            }\n             if attr_item.args.inner_tokens().is_empty() || !is_present_in_source(cx, attr.span) {\n                 return;\n             }"}, {"sha": "7af200708ff0326533b354b5d9801515261e6d0c", "filename": "clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n-use rustc_data_structures::intern::Interned;\n use rustc_hir::{Expr, ExprKind, PathSegment};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n@@ -56,8 +55,8 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n                 ty::Str => {\n                     return Some(span);\n                 },\n-                ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did, .. }, _)), _) => {\n-                    if ctx.tcx.is_diagnostic_item(sym::String, did) {\n+                ty::Adt(def, _) => {\n+                    if ctx.tcx.is_diagnostic_item(sym::String, def.did()) {\n                         return Some(span);\n                     }\n                 },"}, {"sha": "2bf7f868905458be690ecf5d3d39e80fcd404470", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -82,7 +82,7 @@ impl CognitiveComplexity {\n \n         if rust_cc > self.limit.limit() {\n             let fn_span = match kind {\n-                FnKind::ItemFn(ident, _, _, _) | FnKind::Method(ident, _, _) => ident.span,\n+                FnKind::ItemFn(ident, _, _) | FnKind::Method(ident, _) => ident.span,\n                 FnKind::Closure => {\n                     let header_span = body_span.with_hi(decl.output.span().lo());\n                     let pos = snippet_opt(cx, header_span).and_then(|snip| {"}, {"sha": "b3fd8af4730dc16d6ee1e6102e040d2e9da38217", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -240,7 +240,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                     lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n-            hir::ItemKind::Impl(ref impl_) => {\n+            hir::ItemKind::Impl(impl_) => {\n                 self.in_trait_impl = impl_.of_trait.is_some();\n             },\n             hir::ItemKind::Trait(_, unsafety, ..) => {\n@@ -622,7 +622,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n \n                 let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n                 let fallback_bundle =\n-                    rustc_errors::fallback_fluent_bundle(false).expect(\"failed to load fallback fluent bundle\");\n+                    rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n                 let emitter = EmitterWriter::new(\n                     Box::new(io::sink()),\n                     None,"}, {"sha": "346d03ca5568f0aaf7c3593a45f721999a758ea3", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -260,7 +260,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n                     }\n                     // The `module_name_repetitions` lint should only trigger if the item has the module in its\n                     // name. Having the same name is accepted.\n-                    if item.vis.node.is_pub() && item_camel.len() > mod_camel.len() {\n+                    if cx.tcx.visibility(item.def_id).is_public() && item_camel.len() > mod_camel.len() {\n                         let matching = count_match_start(mod_camel, &item_camel);\n                         let rmatching = count_match_end(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();"}, {"sha": "173d41b4b05060b7794a9cbac5432ace09c817c0", "filename": "clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -78,7 +78,10 @@ impl LateLintPass<'_> for ExhaustiveItems {\n             if !attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {\n                 let (lint, msg) = if let ItemKind::Struct(ref v, ..) = item.kind {\n-                    if v.fields().iter().any(|f| !f.vis.node.is_pub()) {\n+                    if v.fields().iter().any(|f| {\n+                        let def_id = cx.tcx.hir().local_def_id(f.hir_id);\n+                        !cx.tcx.visibility(def_id).is_public()\n+                    }) {\n                         // skip structs with private fields\n                         return;\n                     }"}, {"sha": "38e943d2eb8720cd98a0039e5dc3ac188c40d6b8", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -20,7 +20,7 @@ use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n     let attr = must_use_attr(attrs);\n-    if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n+    if let hir::ItemKind::Fn(ref sig, _generics, ref body_id) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n@@ -105,12 +105,7 @@ fn check_needless_must_use(\n             fn_header_span,\n             \"this unit-returning function has a `#[must_use]` attribute\",\n             |diag| {\n-                diag.span_suggestion(\n-                    attr.span,\n-                    \"remove the attribute\",\n-                    \"\".into(),\n-                    Applicability::MachineApplicable,\n-                );\n+                diag.span_suggestion(attr.span, \"remove the attribute\", \"\", Applicability::MachineApplicable);\n             },\n         );\n     } else if attr.value_str().is_none() && is_must_use_ty(cx, return_ty(cx, item_id)) {"}, {"sha": "565a1c871d7580458b633285ea8a84aa913e0410", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -17,8 +17,8 @@ pub(super) fn check_fn<'tcx>(\n     hir_id: hir::HirId,\n ) {\n     let unsafety = match kind {\n-        intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _) => unsafety,\n-        intravisit::FnKind::Method(_, sig, _) => sig.header.unsafety,\n+        intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }) => unsafety,\n+        intravisit::FnKind::Method(_, sig) => sig.header.unsafety,\n         intravisit::FnKind::Closure => return,\n     };\n "}, {"sha": "2e63a1f920d64b39a69ad214ecd4cb6e03ada3a2", "filename": "clippy_lints/src/functions/result_unit_err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -14,7 +14,7 @@ use clippy_utils::ty::is_type_diagnostic_item;\n use super::RESULT_UNIT_ERR;\n \n pub(super) fn check_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-    if let hir::ItemKind::Fn(ref sig, ref _generics, _) = item.kind {\n+    if let hir::ItemKind::Fn(ref sig, _generics, _) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if is_public {"}, {"sha": "5c8d8b8e7552c9e15f23b53a60f891a94357bf8a", "filename": "clippy_lints/src/functions/too_many_arguments.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -26,9 +26,8 @@ pub(super) fn check_fn(\n                     header: hir::FnHeader { abi: Abi::Rust, .. },\n                     ..\n                 },\n-                _,\n             )\n-            | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _) => check_arg_number(\n+            | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }) => check_arg_number(\n                 cx,\n                 decl,\n                 span.with_hi(decl.output.span().hi()),"}, {"sha": "feb1b1014b180838b74b771c0a852f6cf671497c", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n         }\n \n         match item.kind {\n-            ItemKind::Impl(ref impl_) => {\n+            ItemKind::Impl(impl_) => {\n                 let mut vis = ImplicitHasherTypeVisitor::new(cx);\n                 vis.visit_ty(impl_.self_ty);\n \n@@ -155,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n                     );\n                 }\n             },\n-            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+            ItemKind::Fn(ref sig, generics, body_id) => {\n                 let body = cx.tcx.hir().body(body_id);\n \n                 for ty in sig.decl.inputs {"}, {"sha": "6a031a627df946669e206ae77fb2255d21bf71e4", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n fn get_impl_span(cx: &LateContext<'_>, id: LocalDefId) -> Option<Span> {\n     let id = cx.tcx.hir().local_def_id_to_hir_id(id);\n     if let Node::Item(&Item {\n-        kind: ItemKind::Impl(ref impl_item),\n+        kind: ItemKind::Impl(impl_item),\n         span,\n         ..\n     }) = cx.tcx.hir().get(id)"}, {"sha": "ec187563b3f645a1c3c50d774cc8f2e26bf0d2ab", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -28,6 +28,8 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(strings::STRING_LIT_AS_BYTES),\n     LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n     LintId::of(trailing_empty_array::TRAILING_EMPTY_ARRAY),\n+    LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n+    LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n     LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::USELESS_TRANSMUTE),\n     LintId::of(use_self::USE_SELF),"}, {"sha": "2ee2c6e3358cd030ffd32a1b8287fc379932e348", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -84,8 +84,6 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED),\n     LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n     LintId::of(strings::STRING_ADD_ASSIGN),\n-    LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n-    LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n     LintId::of(types::LINKEDLIST),\n     LintId::of(types::OPTION_OPTION),"}, {"sha": "ab5d3fa7b6d9c98b55a5c82c0a192e75f68dde13", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n     BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n     ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, TraitBoundModifier,\n-    TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WhereClause, WherePredicate,\n+    TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter as middle_nested_filter;\n@@ -85,9 +85,9 @@ declare_lint_pass!(Lifetimes => [NEEDLESS_LIFETIMES, EXTRA_UNUSED_LIFETIMES]);\n \n impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Fn(ref sig, ref generics, id) = item.kind {\n+        if let ItemKind::Fn(ref sig, generics, id) = item.kind {\n             check_fn_inner(cx, sig.decl, Some(id), None, generics, item.span, true);\n-        } else if let ItemKind::Impl(ref impl_) = item.kind {\n+        } else if let ItemKind::Impl(impl_) = item.kind {\n             report_extra_impl_lifetimes(cx, impl_);\n         }\n     }\n@@ -100,7 +100,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 sig.decl,\n                 Some(id),\n                 None,\n-                &item.generics,\n+                item.generics,\n                 item.span,\n                 report_extra_lifetimes,\n             );\n@@ -113,7 +113,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 TraitFn::Required(sig) => (None, Some(sig)),\n                 TraitFn::Provided(id) => (Some(id), None),\n             };\n-            check_fn_inner(cx, sig.decl, body, trait_sig, &item.generics, item.span, true);\n+            check_fn_inner(cx, sig.decl, body, trait_sig, item.generics, item.span, true);\n         }\n     }\n }\n@@ -135,7 +135,7 @@ fn check_fn_inner<'tcx>(\n     span: Span,\n     report_extra_lifetimes: bool,\n ) {\n-    if span.from_expansion() || has_where_lifetimes(cx, &generics.where_clause) {\n+    if span.from_expansion() || has_where_lifetimes(cx, generics) {\n         return;\n     }\n \n@@ -144,28 +144,35 @@ fn check_fn_inner<'tcx>(\n         .iter()\n         .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n     for typ in types {\n-        for bound in typ.bounds {\n-            let mut visitor = RefVisitor::new(cx);\n-            walk_param_bound(&mut visitor, bound);\n-            if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n-                return;\n+        for pred in generics.bounds_for_param(cx.tcx.hir().local_def_id(typ.hir_id)) {\n+            if pred.in_where_clause {\n+                // has_where_lifetimes checked that this predicate contains no lifetime.\n+                continue;\n             }\n-            if let GenericBound::Trait(ref trait_ref, _) = *bound {\n-                let params = &trait_ref\n-                    .trait_ref\n-                    .path\n-                    .segments\n-                    .last()\n-                    .expect(\"a path must have at least one segment\")\n-                    .args;\n-                if let Some(params) = *params {\n-                    let lifetimes = params.args.iter().filter_map(|arg| match arg {\n-                        GenericArg::Lifetime(lt) => Some(lt),\n-                        _ => None,\n-                    });\n-                    for bound in lifetimes {\n-                        if bound.name != LifetimeName::Static && !bound.is_elided() {\n-                            return;\n+\n+            for bound in pred.bounds {\n+                let mut visitor = RefVisitor::new(cx);\n+                walk_param_bound(&mut visitor, bound);\n+                if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n+                    return;\n+                }\n+                if let GenericBound::Trait(ref trait_ref, _) = *bound {\n+                    let params = &trait_ref\n+                        .trait_ref\n+                        .path\n+                        .segments\n+                        .last()\n+                        .expect(\"a path must have at least one segment\")\n+                        .args;\n+                    if let Some(params) = *params {\n+                        let lifetimes = params.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Lifetime(lt) => Some(lt),\n+                            _ => None,\n+                        });\n+                        for bound in lifetimes {\n+                            if bound.name != LifetimeName::Static && !bound.is_elided() {\n+                                return;\n+                            }\n                         }\n                     }\n                 }\n@@ -326,9 +333,7 @@ fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n     let mut allowed_lts = FxHashSet::default();\n     for par in named_generics.iter() {\n         if let GenericParamKind::Lifetime { .. } = par.kind {\n-            if par.bounds.is_empty() {\n-                allowed_lts.insert(RefLt::Named(par.name.ident().name));\n-            }\n+            allowed_lts.insert(RefLt::Named(par.name.ident().name));\n         }\n     }\n     allowed_lts.insert(RefLt::Unnamed);\n@@ -449,8 +454,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n \n /// Are any lifetimes mentioned in the `where` clause? If so, we don't try to\n /// reason about elision.\n-fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereClause<'_>) -> bool {\n-    for predicate in where_clause.predicates {\n+fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, generics: &'tcx Generics<'_>) -> bool {\n+    for predicate in generics.predicates {\n         match *predicate {\n             WherePredicate::RegionPredicate(..) => return true,\n             WherePredicate::BoundPredicate(ref pred) => {\n@@ -565,7 +570,7 @@ fn report_extra_impl_lifetimes<'tcx>(cx: &LateContext<'tcx>, impl_: &'tcx Impl<'\n         .collect();\n     let mut checker = LifetimeChecker::<middle_nested_filter::All>::new(cx, hs);\n \n-    walk_generics(&mut checker, &impl_.generics);\n+    walk_generics(&mut checker, impl_.generics);\n     if let Some(ref trait_ref) = impl_.of_trait {\n         walk_trait_ref(&mut checker, trait_ref);\n     }"}, {"sha": "6ed141fa4a5a6dabe6b5b73560265eb98ef81b21", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -59,7 +59,7 @@ pub(super) fn check<'tcx>(\n                 if let Some(indexed_extent) = indexed_extent {\n                     let parent_def_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n                     let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n-                    let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n+                    let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id).unwrap();\n                     if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n                         return;\n                     }\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_def_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id).unwrap();\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,"}, {"sha": "70a118d6b353930ea8c751c0eef2fe0a96b47e0b", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -168,14 +168,16 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n             .operands\n             .iter()\n             .map(|(o, _)| match o {\n-                InlineAsmOperand::In { expr, .. }\n-                | InlineAsmOperand::InOut { expr, .. }\n-                | InlineAsmOperand::Sym { expr } => never_loop_expr(expr, main_loop_id),\n+                InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n+                    never_loop_expr(expr, main_loop_id)\n+                },\n                 InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter(), main_loop_id),\n                 InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n                     never_loop_expr_all(&mut once(in_expr).chain(out_expr.iter()), main_loop_id)\n                 },\n-                InlineAsmOperand::Const { .. } => NeverLoopResult::Otherwise,\n+                InlineAsmOperand::Const { .. }\n+                | InlineAsmOperand::SymFn { .. }\n+                | InlineAsmOperand::SymStatic { .. } => NeverLoopResult::Otherwise,\n             })\n             .fold(NeverLoopResult::Otherwise, combine_both),\n         ExprKind::Struct(_, _, None)"}, {"sha": "b8d620d81713046ac5892d9c6239cb72157d240f", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -177,9 +177,10 @@ impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n             && let [.., name] = p.segments\n             && let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = p.res\n             && name.ident.as_str().starts_with('_')\n-            && let Some(variant_id) = cx.tcx.parent(id)\n-            && let Some(enum_id) = cx.tcx.parent(variant_id)\n         {\n+            let variant_id = cx.tcx.parent(id);\n+            let enum_id = cx.tcx.parent(variant_id);\n+\n             self.constructed_enum_variants.insert((enum_id, variant_id));\n         }\n     }"}, {"sha": "c0b3e95b18523fcbd40bb7523be6d0b96d6b6731", "filename": "clippy_lints/src/matches/overlapping_arms.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -40,10 +40,8 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                         Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n                         None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n                     };\n-\n                     let lhs_val = lhs_const.int_value(cx, ty)?;\n                     let rhs_val = rhs_const.int_value(cx, ty)?;\n-\n                     let rhs_bound = match range_end {\n                         RangeEnd::Included => EndBound::Included(rhs_val),\n                         RangeEnd::Excluded => EndBound::Excluded(rhs_val),"}, {"sha": "37b67647efe9e0d6b54abddce1cbec6d5390f65d", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -139,7 +139,7 @@ fn find_sugg_for_if_let<'tcx>(\n         PatKind::TupleStruct(ref qpath, [sub_pat], _) => {\n             if let PatKind::Wild = sub_pat.kind {\n                 let res = cx.typeck_results().qpath_res(qpath, check_pat.hir_id);\n-                let Some(id) = res.opt_def_id().and_then(|ctor_id| cx.tcx.parent(ctor_id)) else { return };\n+                let Some(id) = res.opt_def_id().map(|ctor_id| cx.tcx.parent(ctor_id)) else { return };\n                 let lang_items = cx.tcx.lang_items();\n                 if Some(id) == lang_items.result_ok_variant() {\n                     (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))"}, {"sha": "b88ec0963f2b55da8cd2f4567e8b91d9f3f58e45", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -42,7 +42,7 @@ pub(crate) trait BindInsteadOfMap {\n \n     fn no_op_msg(cx: &LateContext<'_>) -> Option<String> {\n         let variant_id = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM).ok()?;\n-        let item_id = cx.tcx.parent(variant_id)?;\n+        let item_id = cx.tcx.parent(variant_id);\n         Some(format!(\n             \"using `{}.{}({})`, which is a no-op\",\n             cx.tcx.item_name(item_id),\n@@ -53,7 +53,7 @@ pub(crate) trait BindInsteadOfMap {\n \n     fn lint_msg(cx: &LateContext<'_>) -> Option<String> {\n         let variant_id = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM).ok()?;\n-        let item_id = cx.tcx.parent(variant_id)?;\n+        let item_id = cx.tcx.parent(variant_id);\n         Some(format!(\n             \"using `{}.{}(|x| {}(y))`, which is more succinctly expressed as `{}(|x| y)`\",\n             cx.tcx.item_name(item_id),\n@@ -145,7 +145,7 @@ pub(crate) trait BindInsteadOfMap {\n         if_chain! {\n             if let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def();\n             if let Ok(vid) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM);\n-            if Some(adt.did()) == cx.tcx.parent(vid);\n+            if adt.did() == cx.tcx.parent(vid);\n             then {} else { return false; }\n         }\n \n@@ -182,7 +182,7 @@ pub(crate) trait BindInsteadOfMap {\n     fn is_variant(cx: &LateContext<'_>, res: Res) -> bool {\n         if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n             if let Ok(variant_id) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM) {\n-                return cx.tcx.parent(id) == Some(variant_id);\n+                return cx.tcx.parent(id) == variant_id;\n             }\n         }\n         false"}, {"sha": "f7b79f0839ba8c17ffbfd08172c16df143491df8", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -19,7 +19,7 @@ pub(super) fn check(\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n         if let hir::ExprKind::Call(fun, [arg_char]) = info.other.kind;\n-        if let Some(id) = path_def_id(cx, fun).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n+        if let Some(id) = path_def_id(cx, fun).map(|ctor_id| cx.tcx.parent(ctor_id));\n         if Some(id) == cx.tcx.lang_items().option_some_variant();\n         then {\n             let mut applicability = Applicability::MachineApplicable;"}, {"sha": "76bc9466ed81800e23cdf94f4f8b771a2cc1a895", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -75,7 +75,7 @@ pub(super) fn check<'tcx>(\n             let arg_snippet = snippet(cx, span, \"..\");\n             let body = cx.tcx.hir().body(id);\n                 if let Some((func, [arg_char])) = reduce_unit_expression(&body.value);\n-                if let Some(id) = path_def_id(cx, func).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n+                if let Some(id) = path_def_id(cx, func).map(|ctor_id| cx.tcx.parent(ctor_id));\n                 if Some(id) == cx.tcx.lang_items().option_some_variant();\n                 then {\n                     let func_snippet = snippet(cx, arg_char.span, \"..\");"}, {"sha": "b99052e66ba57dc718d998a183e6f6a62d5789ad", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -11,7 +11,7 @@ use if_chain::if_chain;\n use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, DefIdTree};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::source_map::Span;\n@@ -131,8 +131,8 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == sym::main {\n-                    let def_key = cx.tcx.hir().def_key(it.def_id);\n-                    if def_key.parent == Some(hir::def_id::CRATE_DEF_INDEX) {\n+                    let at_root = cx.tcx.local_parent(it.def_id) == CRATE_DEF_ID;\n+                    if at_root {\n                         return;\n                     }\n                 }"}, {"sha": "0d95329918984c68a74d541042995ff1a94ec28b", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n                 let attrs = cx.tcx.hir().attrs(it.hir_id());\n                 check_missing_inline_attrs(cx, attrs, it.span, desc);\n             },\n-            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics, _bounds, trait_items) => {\n+            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, _generics, _bounds, trait_items) => {\n                 // note: we need to check if the trait is exported so we can't use\n                 // `LateLintPass::check_trait_item` here.\n                 for tit in trait_items {"}, {"sha": "4034079a90c0d097cbece091e56c388c3068c229", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -85,7 +85,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., header, _) => {\n+            FnKind::ItemFn(.., header) => {\n                 let attrs = cx.tcx.hir().attrs(hir_id);\n                 if header.abi != Abi::Rust || requires_exact_signature(attrs) {\n                     return;\n@@ -241,7 +241,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                                                 |x| Cow::from(format!(\"change `{}` to\", x)),\n                                             )\n                                             .as_ref(),\n-                                        suggestion.into(),\n+                                        suggestion,\n                                         Applicability::Unspecified,\n                                     );\n                                 }\n@@ -271,7 +271,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                                                 |x| Cow::from(format!(\"change `{}` to\", x))\n                                             )\n                                             .as_ref(),\n-                                        suggestion.into(),\n+                                        suggestion,\n                                         Applicability::Unspecified,\n                                     );\n                                 }"}, {"sha": "6ba9ba0753d49f42e5ac974d10e7c8e0a9e5ce17", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for NegMultiply {\n fn check_mul(cx: &LateContext<'_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref l) = lit.kind;\n-        if consts::lit_to_constant(&l.node, cx.typeck_results().expr_ty_opt(lit)) == Constant::Int(1);\n+        if consts::lit_to_mir_constant(&l.node, cx.typeck_results().expr_ty_opt(lit)) == Constant::Int(1);\n         if cx.typeck_results().expr_ty(exp).is_integral();\n \n         then {"}, {"sha": "2f733f221d572250866fd51150826a871b83a504", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -62,13 +62,13 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         if let hir::ItemKind::Impl(hir::Impl {\n             of_trait: None,\n-            ref generics,\n+            generics,\n             self_ty: impl_self_ty,\n             items,\n             ..\n         }) = item.kind\n         {\n-            for assoc_item in items {\n+            for assoc_item in *items {\n                 if assoc_item.kind == (hir::AssocItemKind::Fn { has_self: false }) {\n                     let impl_item = cx.tcx.hir().impl_item(assoc_item.id);\n                     if in_external_macro(cx.sess(), impl_item.span) {"}, {"sha": "1469cb434c00c07dfeb0190d14c5527bf5e96c25", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {\n-                for impl_item in impl_items {\n+                for impl_item in *impl_items {\n                     if impl_item.ident.name == sym::ne {\n                         span_lint_hir(\n                             cx,"}, {"sha": "9af3059a37f93c9f7137de24778a71a0cada764a", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -251,7 +251,7 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., header, _) => {\n+            FnKind::ItemFn(.., header) => {\n                 if header.abi != Abi::Rust {\n                     return;\n                 }"}, {"sha": "323326381d4079149ce2591abd3c6a402b4e453b", "filename": "clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -1,9 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{Item, ItemKind, VisibilityKind};\n+use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::hygiene::MacroKind;\n \n declare_clippy_lint! {\n@@ -44,7 +46,7 @@ impl_lint_pass!(RedundantPubCrate => [REDUNDANT_PUB_CRATE]);\n impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if_chain! {\n-            if let VisibilityKind::Crate { .. } = item.vis.node;\n+            if cx.tcx.visibility(item.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id());\n             if !cx.access_levels.is_exported(item.def_id) && self.is_exported.last() == Some(&false);\n             if is_not_macro_export(item);\n             then {\n@@ -57,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n                     &format!(\"pub(crate) {} inside private module\", descr),\n                     |diag| {\n                         diag.span_suggestion(\n-                            item.vis.span,\n+                            item.vis_span,\n                             \"consider using\",\n                             \"pub\".to_string(),\n                             Applicability::MachineApplicable,\n@@ -84,6 +86,8 @@ fn is_not_macro_export<'tcx>(item: &'tcx Item<'tcx>) -> bool {\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = path.res {\n             return false;\n         }\n+    } else if let ItemKind::Macro(..) = item.kind {\n+        return false;\n     }\n \n     true"}, {"sha": "91e5e1e8b289288ae9c2e8d653f28484bfd8db36", "filename": "clippy_lints/src/return_self_not_must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -111,7 +111,7 @@ impl<'tcx> LateLintPass<'tcx> for ReturnSelfNotMustUse {\n     ) {\n         if_chain! {\n             // We are only interested in methods, not in functions or associated functions.\n-            if matches!(kind, FnKind::Method(_, _, _));\n+            if matches!(kind, FnKind::Method(_, _));\n             if let Some(fn_def) = cx.tcx.hir().opt_local_def_id(hir_id);\n             if let Some(impl_def) = cx.tcx.impl_of_method(fn_def.to_def_id());\n             // We don't want this method to be te implementation of a trait because the"}, {"sha": "f63925a2f1438ea8a71e6f500f1a5c11a70cd55e", "filename": "clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 99, "deletions": 98, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsame_name_method.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -50,110 +50,111 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n     fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n         let mut map = FxHashMap::<Res, ExistingName>::default();\n \n-        for item in cx.tcx.hir().items() {\n-            if let ItemKind::Impl(Impl {\n-                items,\n-                of_trait,\n-                self_ty,\n-                ..\n-            }) = &item.kind\n+        for id in cx.tcx.hir().items() {\n+            if matches!(cx.tcx.hir().def_kind(id.def_id), DefKind::Impl)\n+                && let item = cx.tcx.hir().item(id)\n+                && let ItemKind::Impl(Impl {\n+                    items,\n+                    of_trait,\n+                    self_ty,\n+                    ..\n+                }) = &item.kind\n+                && let TyKind::Path(QPath::Resolved(_, Path { res, .. })) = self_ty.kind\n             {\n-                if let TyKind::Path(QPath::Resolved(_, Path { res, .. })) = self_ty.kind {\n-                    if !map.contains_key(res) {\n-                        map.insert(\n-                            *res,\n-                            ExistingName {\n-                                impl_methods: BTreeMap::new(),\n-                                trait_methods: BTreeMap::new(),\n-                            },\n-                        );\n-                    }\n-                    let existing_name = map.get_mut(res).unwrap();\n-\n-                    match of_trait {\n-                        Some(trait_ref) => {\n-                            let mut methods_in_trait: BTreeSet<Symbol> = if_chain! {\n-                                if let Some(Node::TraitRef(TraitRef { path, .. })) =\n-                                    cx.tcx.hir().find(trait_ref.hir_ref_id);\n-                                if let Res::Def(DefKind::Trait, did) = path.res;\n-                                then{\n-                                    // FIXME: if\n-                                    // `rustc_middle::ty::assoc::AssocItems::items` is public,\n-                                    // we can iterate its keys instead of `in_definition_order`,\n-                                    // which's more efficient\n-                                    cx.tcx\n-                                        .associated_items(did)\n-                                        .in_definition_order()\n-                                        .filter(|assoc_item| {\n-                                            matches!(assoc_item.kind, AssocKind::Fn)\n-                                        })\n-                                        .map(|assoc_item| assoc_item.name)\n-                                        .collect()\n-                                }else{\n-                                    BTreeSet::new()\n-                                }\n-                            };\n-\n-                            let mut check_trait_method = |method_name: Symbol, trait_method_span: Span| {\n-                                if let Some(impl_span) = existing_name.impl_methods.get(&method_name) {\n-                                    span_lint_and_then(\n-                                        cx,\n-                                        SAME_NAME_METHOD,\n-                                        *impl_span,\n-                                        \"method's name is the same as an existing method in a trait\",\n-                                        |diag| {\n-                                            diag.span_note(\n-                                                trait_method_span,\n-                                                &format!(\"existing `{}` defined here\", method_name),\n-                                            );\n-                                        },\n-                                    );\n-                                }\n-                                if let Some(v) = existing_name.trait_methods.get_mut(&method_name) {\n-                                    v.push(trait_method_span);\n-                                } else {\n-                                    existing_name.trait_methods.insert(method_name, vec![trait_method_span]);\n-                                }\n-                            };\n+                if !map.contains_key(res) {\n+                    map.insert(\n+                        *res,\n+                        ExistingName {\n+                            impl_methods: BTreeMap::new(),\n+                            trait_methods: BTreeMap::new(),\n+                        },\n+                    );\n+                }\n+                let existing_name = map.get_mut(res).unwrap();\n \n-                            for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n-                                matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n-                            }) {\n-                                let method_name = impl_item_ref.ident.name;\n-                                methods_in_trait.remove(&method_name);\n-                                check_trait_method(method_name, impl_item_ref.span);\n+                match of_trait {\n+                    Some(trait_ref) => {\n+                        let mut methods_in_trait: BTreeSet<Symbol> = if_chain! {\n+                            if let Some(Node::TraitRef(TraitRef { path, .. })) =\n+                                cx.tcx.hir().find(trait_ref.hir_ref_id);\n+                            if let Res::Def(DefKind::Trait, did) = path.res;\n+                            then{\n+                                // FIXME: if\n+                                // `rustc_middle::ty::assoc::AssocItems::items` is public,\n+                                // we can iterate its keys instead of `in_definition_order`,\n+                                // which's more efficient\n+                                cx.tcx\n+                                    .associated_items(did)\n+                                    .in_definition_order()\n+                                    .filter(|assoc_item| {\n+                                        matches!(assoc_item.kind, AssocKind::Fn)\n+                                    })\n+                                    .map(|assoc_item| assoc_item.name)\n+                                    .collect()\n+                            }else{\n+                                BTreeSet::new()\n                             }\n+                        };\n \n-                            for method_name in methods_in_trait {\n-                                check_trait_method(method_name, item.span);\n+                        let mut check_trait_method = |method_name: Symbol, trait_method_span: Span| {\n+                            if let Some(impl_span) = existing_name.impl_methods.get(&method_name) {\n+                                span_lint_and_then(\n+                                    cx,\n+                                    SAME_NAME_METHOD,\n+                                    *impl_span,\n+                                    \"method's name is the same as an existing method in a trait\",\n+                                    |diag| {\n+                                        diag.span_note(\n+                                            trait_method_span,\n+                                            &format!(\"existing `{}` defined here\", method_name),\n+                                        );\n+                                    },\n+                                );\n                             }\n-                        },\n-                        None => {\n-                            for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n-                                matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n-                            }) {\n-                                let method_name = impl_item_ref.ident.name;\n-                                let impl_span = impl_item_ref.span;\n-                                if let Some(trait_spans) = existing_name.trait_methods.get(&method_name) {\n-                                    span_lint_and_then(\n-                                        cx,\n-                                        SAME_NAME_METHOD,\n-                                        impl_span,\n-                                        \"method's name is the same as an existing method in a trait\",\n-                                        |diag| {\n-                                            // TODO should we `span_note` on every trait?\n-                                            // iterate on trait_spans?\n-                                            diag.span_note(\n-                                                trait_spans[0],\n-                                                &format!(\"existing `{}` defined here\", method_name),\n-                                            );\n-                                        },\n-                                    );\n-                                }\n-                                existing_name.impl_methods.insert(method_name, impl_span);\n+                            if let Some(v) = existing_name.trait_methods.get_mut(&method_name) {\n+                                v.push(trait_method_span);\n+                            } else {\n+                                existing_name.trait_methods.insert(method_name, vec![trait_method_span]);\n                             }\n-                        },\n-                    }\n+                        };\n+\n+                        for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n+                            matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n+                        }) {\n+                            let method_name = impl_item_ref.ident.name;\n+                            methods_in_trait.remove(&method_name);\n+                            check_trait_method(method_name, impl_item_ref.span);\n+                        }\n+\n+                        for method_name in methods_in_trait {\n+                            check_trait_method(method_name, item.span);\n+                        }\n+                    },\n+                    None => {\n+                        for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n+                            matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n+                        }) {\n+                            let method_name = impl_item_ref.ident.name;\n+                            let impl_span = impl_item_ref.span;\n+                            if let Some(trait_spans) = existing_name.trait_methods.get(&method_name) {\n+                                span_lint_and_then(\n+                                    cx,\n+                                    SAME_NAME_METHOD,\n+                                    impl_span,\n+                                    \"method's name is the same as an existing method in a trait\",\n+                                    |diag| {\n+                                        // TODO should we `span_note` on every trait?\n+                                        // iterate on trait_spans?\n+                                        diag.span_note(\n+                                            trait_spans[0],\n+                                            &format!(\"existing `{}` defined here\", method_name),\n+                                        );\n+                                    },\n+                                );\n+                            }\n+                            existing_name.impl_methods.insert(method_name, impl_span);\n+                        }\n+                    },\n                 }\n             }\n         }"}, {"sha": "fc1c2af9257bf98484d807b775a7a2da416a56e2", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> LateLintPass<'tcx> for SerdeApi {\n                 if did == visit_did {\n                     let mut seen_str = None;\n                     let mut seen_string = None;\n-                    for item in items {\n+                    for item in *items {\n                         match item.ident.as_str() {\n                             \"visit_str\" => seen_str = Some(item.span),\n                             \"visit_string\" => seen_string = Some(item.span),"}, {"sha": "1ab7f52110ce7c3742aeec202c9ccd4003959e99", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -160,8 +160,8 @@ impl<'tcx> LateLintPass<'tcx> for Shadow {\n \n fn is_shadow(cx: &LateContext<'_>, owner: LocalDefId, first: ItemLocalId, second: ItemLocalId) -> bool {\n     let scope_tree = cx.tcx.region_scope_tree(owner.to_def_id());\n-    let first_scope = scope_tree.var_scope(first);\n-    let second_scope = scope_tree.var_scope(second);\n+    let first_scope = scope_tree.var_scope(first).unwrap();\n+    let second_scope = scope_tree.var_scope(second).unwrap();\n     scope_tree.is_subscope_of(second_scope, first_scope)\n }\n "}, {"sha": "78e388a49af1d470291e93a36958e66e6c2c6572", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -8,8 +8,7 @@ use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{\n-    GenericBound, Generics, Item, ItemKind, Node, ParamName, Path, PathSegment, QPath, TraitItem, Ty, TyKind,\n-    WherePredicate,\n+    GenericBound, Generics, Item, ItemKind, Node, Path, PathSegment, QPath, TraitItem, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -36,7 +35,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.38.0\"]\n     pub TYPE_REPETITION_IN_BOUNDS,\n-    pedantic,\n+    nursery,\n     \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n }\n \n@@ -66,7 +65,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.47.0\"]\n     pub TRAIT_DUPLICATION_IN_BOUNDS,\n-    pedantic,\n+    nursery,\n     \"Check if the same trait bounds are specified twice during a function declaration\"\n }\n \n@@ -91,10 +90,9 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'tcx>) {\n-        let Generics { where_clause, .. } = &item.generics;\n         let mut self_bounds_map = FxHashMap::default();\n \n-        for predicate in where_clause.predicates {\n+        for predicate in item.generics.predicates {\n             if_chain! {\n                 if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n                 if !bound_predicate.span.from_expansion();\n@@ -167,7 +165,7 @@ impl TraitBounds {\n         }\n         let mut map: UnhashMap<SpanlessTy<'_, '_>, Vec<&GenericBound<'_>>> = UnhashMap::default();\n         let mut applicability = Applicability::MaybeIncorrect;\n-        for bound in gen.where_clause.predicates {\n+        for bound in gen.predicates {\n             if_chain! {\n                 if let WherePredicate::BoundPredicate(ref p) = bound;\n                 if p.bounds.len() as u64 <= self.max_trait_bounds;\n@@ -217,34 +215,23 @@ impl TraitBounds {\n }\n \n fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n-    if gen.span.from_expansion() || gen.params.is_empty() || gen.where_clause.predicates.is_empty() {\n+    if gen.span.from_expansion() || gen.params.is_empty() || gen.predicates.is_empty() {\n         return;\n     }\n \n-    let mut map = FxHashMap::default();\n-    for param in gen.params {\n-        if let ParamName::Plain(ref ident) = param.name {\n-            let res = param\n-                .bounds\n-                .iter()\n-                .filter_map(get_trait_info_from_bound)\n-                .collect::<Vec<_>>();\n-            map.insert(*ident, res);\n-        }\n-    }\n-\n-    for predicate in gen.where_clause.predicates {\n+    let mut map = FxHashMap::<_, Vec<_>>::default();\n+    for predicate in gen.predicates {\n         if_chain! {\n             if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n             if !bound_predicate.span.from_expansion();\n             if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n             if let Some(segment) = segments.first();\n-            if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n             then {\n-                for (res_where, _,  _) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n-                    if let Some((_, _, span_direct)) = trait_resolutions_direct\n+                for (res_where, _, span_where) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n+                    let trait_resolutions_direct = map.entry(segment.ident).or_default();\n+                    if let Some((_, span_direct)) = trait_resolutions_direct\n                                                 .iter()\n-                                                .find(|(res_direct, _, _)| *res_direct == res_where) {\n+                                                .find(|(res_direct, _)| *res_direct == res_where) {\n                         span_lint_and_help(\n                             cx,\n                             TRAIT_DUPLICATION_IN_BOUNDS,\n@@ -254,6 +241,9 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n                             \"consider removing this trait bound\",\n                         );\n                     }\n+                    else {\n+                        trait_resolutions_direct.push((res_where, span_where));\n+                    }\n                 }\n             }\n         }"}, {"sha": "f35f44eda5679fb34f365965dac7433983875010", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -104,8 +104,10 @@ fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id:\n         if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n         if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n         if synthetic;\n+        if let Some(generics) = cx.tcx.hir().get_generics(id.owner);\n+        if let Some(pred) = generics.bounds_for_param(did.expect_local()).next();\n         then {\n-            Some(generic_param.bounds)\n+            Some(pred.bounds)\n         } else {\n             None\n         }"}, {"sha": "465d8a914fb290b2a4e466750f923bc6be9cc4da", "filename": "clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -1,13 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::is_lint_allowed;\n use clippy_utils::source::walk_span_to_context;\n+use rustc_data_structures::sync::Lrc;\n use rustc_hir::{Block, BlockCheckMode, UnsafeSource};\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{BytePos, Pos, SyntaxContext};\n-use std::rc::Rc;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -117,7 +117,7 @@ fn block_has_safety_comment(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n         //     ^--------------------------------------------^\n         if let Ok(unsafe_line) = source_map.lookup_line(block.span.lo())\n             && let Ok(macro_line) = source_map.lookup_line(ctxt.outer_expn_data().def_site.lo())\n-            && Rc::ptr_eq(&unsafe_line.sf, &macro_line.sf)\n+            && Lrc::ptr_eq(&unsafe_line.sf, &macro_line.sf)\n             && let Some(src) = unsafe_line.sf.src.as_deref()\n         {\n             macro_line.line < unsafe_line.line && text_has_safety_comment(\n@@ -133,7 +133,7 @@ fn block_has_safety_comment(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n         && let Some(body) = cx.enclosing_body\n         && let Some(body_span) = walk_span_to_context(cx.tcx.hir().body(body).value.span, SyntaxContext::root())\n         && let Ok(body_line) = source_map.lookup_line(body_span.lo())\n-        && Rc::ptr_eq(&unsafe_line.sf, &body_line.sf)\n+        && Lrc::ptr_eq(&unsafe_line.sf, &body_line.sf)\n         && let Some(src) = unsafe_line.sf.src.as_deref()\n     {\n         // Get the text from the start of function body to the unsafe block."}, {"sha": "f3f1f53aac5652f6c07a0e79daa9bf85a7d21ff9", "filename": "clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -34,7 +34,7 @@ pub(super) fn check(cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n                             diag.span_suggestion(\n                                 local.pat.span,\n                                 \"use a wild (`_`) binding\",\n-                                \"_\".into(),\n+                                \"_\",\n                                 Applicability::MaybeIncorrect, // snippet\n                             );\n                     },"}, {"sha": "41333bb2addf7bbf70dfffc8a4fff632993348a3", "filename": "clippy_lints/src/unused_async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Funused_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Funused_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_async.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -67,7 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAsync {\n         span: Span,\n         hir_id: HirId,\n     ) {\n-        if let FnKind::ItemFn(_, _, FnHeader { asyncness, .. }, _) = &fn_kind {\n+        if let FnKind::ItemFn(_, _, FnHeader { asyncness, .. }) = &fn_kind {\n             if matches!(asyncness, IsAsync::Async) {\n                 let mut visitor = AsyncFnVisitor { cx, found_await: false };\n                 walk_fn(&mut visitor, fn_kind, fn_decl, body.id(), span, hir_id);"}, {"sha": "2f74eaf3cf5c319a9fff3f2bc0e06d06e24da1e3", "filename": "clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::{\n     Item, ItemKind, PathSegment, UseKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::kw;\n use rustc_span::{sym, BytePos};\n@@ -115,7 +116,8 @@ impl LateLintPass<'_> for WildcardImports {\n         if is_test_module_or_function(cx.tcx, item) {\n             self.test_modules_deep = self.test_modules_deep.saturating_add(1);\n         }\n-        if item.vis.node.is_pub() || item.vis.node.is_pub_restricted() {\n+        let module = cx.tcx.parent_module_from_def_id(item.def_id);\n+        if cx.tcx.visibility(item.def_id) != ty::Visibility::Restricted(module.to_def_id()) {\n             return;\n         }\n         if_chain! {"}, {"sha": "54b93a20a057d9b0fc8171f93afe5b2a7934e404", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -13,7 +13,7 @@ use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_parse::parser;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{kw, Symbol};\n-use rustc_span::{sym, BytePos, Span, DUMMY_SP};\n+use rustc_span::{sym, BytePos, InnerSpan, Span, DUMMY_SP};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -454,6 +454,7 @@ impl SimpleFormatArgs {\n                 }\n             },\n             ArgumentNamed(n, _) => {\n+                let n = Symbol::intern(n);\n                 if let Some(x) = self.named.iter_mut().find(|x| x.0 == n) {\n                     match x.1.as_slice() {\n                         // A non-empty format string has been seen already.\n@@ -495,7 +496,7 @@ impl Write {\n             let span = parser\n                 .arg_places\n                 .last()\n-                .map_or(DUMMY_SP, |&x| str_lit.span.from_inner(x));\n+                .map_or(DUMMY_SP, |&x| str_lit.span.from_inner(InnerSpan::new(x.start, x.end)));\n \n             if !self.in_debug_impl && arg.format.ty == \"?\" {\n                 // FIXME: modify rustc's fmt string parser to give us the current span"}, {"sha": "7919800483f522ff5bdb1434a6584fe31686543f", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -688,7 +688,8 @@ pub fn eq_mac_args(l: &MacArgs, r: &MacArgs) -> bool {\n     match (l, r) {\n         (Empty, Empty) => true,\n         (Delimited(_, ld, lts), Delimited(_, rd, rts)) => ld == rd && lts.eq_unspanned(rts),\n-        (Eq(_, lt), Eq(_, rt)) => lt.kind == rt.kind,\n+        (Eq(_, MacArgsEq::Ast(le)), Eq(_, MacArgsEq::Ast(re))) => eq_expr(le, re),\n+        (Eq(_, MacArgsEq::Hir(ll)), Eq(_, MacArgsEq::Hir(rl))) => ll.kind == rl.kind,\n         _ => false,\n     }\n }"}, {"sha": "fdb822c3e5b6d6f5908312885dbff2455323c455", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -179,7 +179,7 @@ impl Constant {\n }\n \n /// Parses a `LitKind` to a `Constant`.\n-pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n+pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n     match *lit {\n         LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n         LitKind::Byte(b) => Constant::Int(u128::from(b)),\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 if is_direct_expn_of(e.span, \"cfg\").is_some() {\n                     None\n                 } else {\n-                    Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e)))\n+                    Some(lit_to_mir_constant(&lit.node, self.typeck_results.expr_ty_opt(e)))\n                 }\n             },\n             ExprKind::Array(vec) => self.multi(vec).map(Constant::Vec),"}, {"sha": "f4da625f1e306a0e083716316ede4a5f07ced8d7", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -681,8 +681,10 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                                 self.hash_expr(out_expr);\n                             }\n                         },\n-                        InlineAsmOperand::Const { anon_const } => self.hash_body(anon_const.body),\n-                        InlineAsmOperand::Sym { expr } => self.hash_expr(expr),\n+                        InlineAsmOperand::Const { anon_const } | InlineAsmOperand::SymFn { anon_const } => {\n+                            self.hash_body(anon_const.body);\n+                        },\n+                        InlineAsmOperand::SymStatic { path, def_id: _ } => self.hash_qpath(path),\n                     }\n                 }\n             },"}, {"sha": "7d46952d9718b5cbcdf149de40a1a9206d1afa25", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -235,7 +235,7 @@ pub fn is_lang_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, lang_item: LangItem\n     if let QPath::Resolved(_, path) = qpath {\n         if let Res::Def(DefKind::Ctor(..), ctor_id) = path.res {\n             if let Ok(item_id) = cx.tcx.lang_items().require(lang_item) {\n-                return cx.tcx.parent(ctor_id) == Some(item_id);\n+                return cx.tcx.parent(ctor_id) == item_id;\n             }\n         }\n     }\n@@ -1690,7 +1690,7 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n \n /// Checks if the given function kind is an async function.\n pub fn is_async_fn(kind: FnKind<'_>) -> bool {\n-    matches!(kind, FnKind::ItemFn(_, _, header, _) if header.asyncness == IsAsync::Async)\n+    matches!(kind, FnKind::ItemFn(_, _, header) if header.asyncness == IsAsync::Async)\n }\n \n /// Peels away all the compiler generated code surrounding the body of an async function,"}, {"sha": "60971fb716dbdc69e364e137e032b2a5baab05cd", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -23,7 +23,7 @@ pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"\n pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n-pub const CSTRING_AS_C_STR: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n+pub const CSTRING_AS_C_STR: [&str; 5] = [\"alloc\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n /// Preferably use the diagnostic item `sym::deref_method` where possible"}, {"sha": "75808b1b17461d657f322903733e48fdf467fc2d", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -211,7 +211,9 @@ fn check_statement<'tcx>(\n \n         StatementKind::FakeRead(box (_, place)) => check_place(tcx, *place, span, body),\n         // just an assignment\n-        StatementKind::SetDiscriminant { place, .. } => check_place(tcx, **place, span, body),\n+        StatementKind::SetDiscriminant { place, .. } | StatementKind::Deinit(place) => {\n+            check_place(tcx, **place, span, body)\n+        },\n \n         StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping { dst, src, count }) => {\n             check_operand(tcx, dst, span, body)?;"}, {"sha": "18915553e61c06cdc97ee45265f796215f617874", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -214,6 +214,7 @@ impl<'a> Sugg<'a> {\n             | ast::ExprKind::Path(..)\n             | ast::ExprKind::Repeat(..)\n             | ast::ExprKind::Ret(..)\n+            | ast::ExprKind::Yeet(..)\n             | ast::ExprKind::Struct(..)\n             | ast::ExprKind::Try(..)\n             | ast::ExprKind::TryBlock(..)"}, {"sha": "03acb51306d7a92081b181f66bbb964bbca66a76", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-04-07\"\n+channel = \"nightly-2022-05-05\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "7de40fe63ac23a4559051c6f14c26b34ad4c067a", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -165,7 +165,7 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     // Separate the output with an empty line\n     eprintln!();\n \n-    let fallback_bundle = rustc_errors::fallback_fluent_bundle(false).expect(\"failed to load fallback fluent bundle\");\n+    let fallback_bundle = rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n     let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n         rustc_errors::ColorConfig::Auto,\n         None,"}, {"sha": "4b3fb764010821e375a167aca49b93620ef0fa7a", "filename": "tests/ui/crashes/ice-96721.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Fcrashes%2Fice-96721.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Fcrashes%2Fice-96721.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-96721.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -0,0 +1,10 @@\n+macro_rules! foo {\n+    () => {\n+        \"bar.rs\"\n+    };\n+}\n+\n+#[path = foo!()] //~ ERROR malformed `path` attribute\n+mod abc {}\n+\n+fn main() {}"}, {"sha": "78c567b8e772e989945c4098d8c9efbb09d0fd6b", "filename": "tests/ui/crashes/ice-96721.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Fcrashes%2Fice-96721.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Fcrashes%2Fice-96721.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-96721.stderr?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -0,0 +1,8 @@\n+error: malformed `path` attribute input\n+  --> $DIR/ice-96721.rs:7:1\n+   |\n+LL | #[path = foo!()] //~ ERROR malformed `path` attribute\n+   | ^^^^^^^^^^^^^^^^ help: must be of the form: `#[path = \"file\"]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "fcc12d4ce14b95977f4a5f46e4509b0b32dac7c6", "filename": "tests/ui/extra_unused_lifetimes.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Fextra_unused_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Fextra_unused_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_lifetimes.stderr?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -6,12 +6,6 @@ LL | fn unused_lt<'a>(x: u8) {}\n    |\n    = note: `-D clippy::extra-unused-lifetimes` implied by `-D warnings`\n \n-error: this lifetime isn't used in the function definition\n-  --> $DIR/extra_unused_lifetimes.rs:16:25\n-   |\n-LL | fn unused_lt_transitive<'a, 'b: 'a>(x: &'b u8) {\n-   |                         ^^\n-\n error: this lifetime isn't used in the function definition\n   --> $DIR/extra_unused_lifetimes.rs:41:10\n    |\n@@ -42,5 +36,5 @@ error: this lifetime isn't used in the function definition\n LL |         pub fn something<'c>() -> Self {\n    |                          ^^\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "a488bc01fffa289257f8cd7032c32eacf32ab3f3", "filename": "tests/ui/needless_lifetimes.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Fneedless_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Fneedless_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.stderr?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -108,12 +108,6 @@ error: explicit lifetimes given in parameter types where they could be elided (o\n LL |         fn baz<'a>(&'a self) -> impl Foo + 'a {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:307:5\n-   |\n-LL |     fn impl_trait_elidable_nested_named_lifetimes<'a>(i: &'a i32, f: impl for<'b> Fn(&'b i32) -> &'b i32) -> &'a i32 {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n   --> $DIR/needless_lifetimes.rs:310:5\n    |\n@@ -192,5 +186,5 @@ error: explicit lifetimes given in parameter types where they could be elided (o\n LL |         fn lifetime_elsewhere_provided<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 32 previous errors\n+error: aborting due to 31 previous errors\n "}, {"sha": "cf06eb32e0c7fc041738d367cd6e6c19a4c31b85", "filename": "tests/ui/same_name_method.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Fsame_name_method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Fsame_name_method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_name_method.stderr?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -11,6 +11,19 @@ note: existing `foo` defined here\n LL |             fn foo() {}\n    |             ^^^^^^^^^^^\n \n+error: method's name is the same as an existing method in a trait\n+  --> $DIR/same_name_method.rs:34:13\n+   |\n+LL |             fn clone() {}\n+   |             ^^^^^^^^^^^^^\n+   |\n+note: existing `clone` defined here\n+  --> $DIR/same_name_method.rs:30:18\n+   |\n+LL |         #[derive(Clone)]\n+   |                  ^^^^^\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error: method's name is the same as an existing method in a trait\n   --> $DIR/same_name_method.rs:44:13\n    |\n@@ -47,18 +60,5 @@ note: existing `foo` defined here\n LL |         impl T1 for S {}\n    |         ^^^^^^^^^^^^^^^^\n \n-error: method's name is the same as an existing method in a trait\n-  --> $DIR/same_name_method.rs:34:13\n-   |\n-LL |             fn clone() {}\n-   |             ^^^^^^^^^^^^^\n-   |\n-note: existing `clone` defined here\n-  --> $DIR/same_name_method.rs:30:18\n-   |\n-LL |         #[derive(Clone)]\n-   |                  ^^^^^\n-   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n error: aborting due to 5 previous errors\n "}, {"sha": "a21d4c5d637daec8678ce052656d1d86bff631aa", "filename": "tests/ui/trait_duplication_in_bounds.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -95,4 +95,7 @@ trait FooIter: Iterator<Item = Foo> {\n     }\n }\n \n+// This should not lint\n+fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n+\n fn main() {}"}, {"sha": "d0a4cfb88370e2060620137f7e015632a96ff3e7", "filename": "tests/ui/trait_duplication_in_bounds.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.stderr?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -67,5 +67,13 @@ LL |         Self: Iterator<Item = Foo>,\n    |\n    = help: consider removing this trait bound\n \n-error: aborting due to 8 previous errors\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:99:23\n+   |\n+LL | fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n+   |                       ^^^^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "d11432f9046111d4ff77f7279250bc7f10083975", "filename": "tests/ui/type_repetition_in_bounds.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Ftype_repetition_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Ftype_repetition_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_repetition_in_bounds.rs?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -79,4 +79,7 @@ where\n     u: U,\n }\n \n+// This should not lint\n+fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n+\n fn main() {}"}, {"sha": "abc25e59496bfa13262c3a5b938ce282a7b25edb", "filename": "tests/ui/type_repetition_in_bounds.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Ftype_repetition_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Ftype_repetition_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_repetition_in_bounds.stderr?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -19,5 +19,13 @@ LL |     Self: Copy + Default + Ord,\n    |\n    = help: consider combining the bounds: `Self: Clone + Copy + Default + Ord`\n \n-error: aborting due to 2 previous errors\n+error: this type has already been used as a bound predicate\n+  --> $DIR/type_repetition_in_bounds.rs:83:43\n+   |\n+LL | fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n+   |                                           ^^^^^^^^^^\n+   |\n+   = help: consider combining the bounds: `impl AsRef<str>: AsRef<str> + AsRef<str>`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "0d2cb77855be1198a45f9ee31bb930a56312e151", "filename": "tests/ui/unused_unit.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Funused_unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c21f91b15b7604f818565646b686d90f99d1baf/tests%2Fui%2Funused_unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.stderr?ref=7c21f91b15b7604f818565646b686d90f99d1baf", "patch": "@@ -1,8 +1,8 @@\n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:19:28\n+  --> $DIR/unused_unit.rs:19:58\n    |\n LL |     pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n-   |                            ^^^^^^ help: remove the `-> ()`\n+   |                                                          ^^^^^^ help: remove the `-> ()`\n    |\n note: the lint level is defined here\n   --> $DIR/unused_unit.rs:12:9\n@@ -11,16 +11,16 @@ LL | #![deny(clippy::unused_unit)]\n    |         ^^^^^^^^^^^^^^^^^^^\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:20:18\n+  --> $DIR/unused_unit.rs:19:28\n    |\n-LL |     where G: Fn() -> () {\n-   |                  ^^^^^^ help: remove the `-> ()`\n+LL |     pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n+   |                            ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:19:58\n+  --> $DIR/unused_unit.rs:20:18\n    |\n-LL |     pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n-   |                                                          ^^^^^^ help: remove the `-> ()`\n+LL |     where G: Fn() -> () {\n+   |                  ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n   --> $DIR/unused_unit.rs:21:26"}]}