{"sha": "ce1fed7f52584d4a23ddbd8d464b046d840c654e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMWZlZDdmNTI1ODRkNGEyM2RkYmQ4ZDQ2NGIwNDZkODQwYzY1NGU=", "commit": {"author": {"name": "Agustin Chiappe Berrini", "email": "jnieve@gmail.com", "date": "2017-12-07T08:52:25Z"}, "committer": {"name": "Agustin Chiappe Berrini", "email": "jnieve@gmail.com", "date": "2017-12-07T08:52:25Z"}, "message": "address comments", "tree": {"sha": "fa50e55a9471f16583d175c6ef53ef9818e1461c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa50e55a9471f16583d175c6ef53ef9818e1461c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce1fed7f52584d4a23ddbd8d464b046d840c654e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce1fed7f52584d4a23ddbd8d464b046d840c654e", "html_url": "https://github.com/rust-lang/rust/commit/ce1fed7f52584d4a23ddbd8d464b046d840c654e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce1fed7f52584d4a23ddbd8d464b046d840c654e/comments", "author": null, "committer": null, "parents": [{"sha": "65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "url": "https://api.github.com/repos/rust-lang/rust/commits/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "html_url": "https://github.com/rust-lang/rust/commit/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c"}], "stats": {"total": 74, "additions": 32, "deletions": 42}, "files": [{"sha": "205b8bf0d20ea348aeed6a16a0188cb631200eba", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=ce1fed7f52584d4a23ddbd8d464b046d840c654e", "patch": "@@ -21,8 +21,10 @@ use rustc::session::Session;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Spanned;\n+use syntax::parse::token;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n+use syntax_pos::symbol::keywords;\n use errors;\n \n struct AstValidator<'a> {\n@@ -35,15 +37,15 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn check_lifetime(&self, lifetime: &Lifetime) {\n-        if !lifetime.ident.without_first_quote().is_valid() &&\n-            !lifetime.ident.name.is_static_keyword() {\n+        let valid_names = [keywords::StaticLifetime.name(), keywords::Invalid.name()];\n+        if !valid_names.contains(&lifetime.ident.name) &&\n+            token::Ident(lifetime.ident.without_first_quote()).is_reserved_ident() {\n             self.err_handler().span_err(lifetime.span, \"lifetimes cannot use keyword names\");\n         }\n     }\n \n     fn check_label(&self, label: Ident, span: Span) {\n-        if label.name.is_static_keyword() || !label.without_first_quote().is_valid()\n-            || label.name == \"'_\" {\n+        if token::Ident(label.without_first_quote()).is_reserved_ident() || label.name == \"'_\" {\n             self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n         }\n     }\n@@ -207,23 +209,26 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_use_tree(self, use_tree, id);\n     }\n \n+    fn visit_lifetime(&mut self, lifetime: &'a Lifetime) {\n+        self.check_lifetime(lifetime);\n+        visit::walk_lifetime(self, lifetime);\n+    }\n+\n     fn visit_item(&mut self, item: &'a Item) {\n         match item.node {\n-            ItemKind::Impl(.., ref generics, Some(..), _, ref impl_items) => {\n+            ItemKind::Impl(.., Some(..), _, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, item.span, None);\n                 for impl_item in impl_items {\n                     self.invalid_visibility(&impl_item.vis, impl_item.span, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         self.check_trait_fn_not_const(sig.constness);\n                     }\n                 }\n-                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n             }\n-            ItemKind::Impl(.., ref generics, None, _, _) => {\n+            ItemKind::Impl(.., None, _, _) => {\n                 self.invalid_visibility(&item.vis,\n                                         item.span,\n                                         Some(\"place qualifiers on individual impl items instead\"));\n-                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n             }\n             ItemKind::AutoImpl(..) => {\n                 self.invalid_visibility(&item.vis, item.span, None);\n@@ -234,14 +239,13 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                                         Some(\"place qualifiers on individual foreign items \\\n                                               instead\"));\n             }\n-            ItemKind::Enum(ref def, ref generics) => {\n+            ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n                     self.invalid_non_exhaustive_attribute(variant);\n                     for field in variant.node.data.fields() {\n                         self.invalid_visibility(&field.vis, field.span, None);\n                     }\n                 }\n-                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n             }\n             ItemKind::Trait(is_auto, _, ref generics, ref bounds, ref trait_items) => {\n                 if is_auto == IsAuto::Yes {\n@@ -278,7 +282,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         }\n                     }\n                 }\n-                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n             }\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n@@ -289,7 +292,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.session.buffer_lint(lint, item.id, item.span, msg);\n                 }\n             }\n-            ItemKind::Union(ref vdata, ref generics) => {\n+            ItemKind::Union(ref vdata, _) => {\n                 if !vdata.is_struct() {\n                     self.err_handler().span_err(item.span,\n                                                 \"tuple and unit unions are not permitted\");\n@@ -298,12 +301,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.err_handler().span_err(item.span,\n                                                 \"unions cannot have zero fields\");\n                 }\n-                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n-            }\n-            ItemKind::Fn(.., ref generics, _) |\n-            ItemKind::Ty(_, ref generics) |\n-            ItemKind::Struct(_, ref generics) => {\n-                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n             }\n             _ => {}\n         }"}, {"sha": "d9c33fa50bd89ab8f0180b6884ec26399f0c48dd", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=ce1fed7f52584d4a23ddbd8d464b046d840c654e", "patch": "@@ -14,7 +14,7 @@ use codemap::{CodeMap, FilePathMapping};\n use errors::{FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n-use symbol::{Symbol};\n+use symbol::Symbol;\n use std_unicode::property::Pattern_White_Space;\n \n use std::borrow::Cow;"}, {"sha": "ff87f146c0a71616dd2b818f3b03556838aef2b8", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ce1fed7f52584d4a23ddbd8d464b046d840c654e", "patch": "@@ -364,12 +364,18 @@ impl Token {\n \n     /// Returns `true` if the token is a keyword used in the language.\n     pub fn is_used_keyword(&self) -> bool {\n-        self.ident().map(|id| id.name.is_used_keyword()).unwrap_or(false)\n+        match self.ident() {\n+            Some(id) => id.name >= keywords::As.name() && id.name <= keywords::While.name(),\n+            _ => false,\n+        }\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n     pub fn is_unused_keyword(&self) -> bool {\n-        self.ident().map(|id| id.name.is_unused_keyword()).unwrap_or(false)\n+        match self.ident() {\n+            Some(id) => id.name >= keywords::Abstract.name() && id.name <= keywords::Yield.name(),\n+            _ => false,\n+        }\n     }\n \n     pub fn glue(self, joint: Token) -> Option<Token> {"}, {"sha": "0e90e0922b977a8cebb68450d2a5b579ae442cd4", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=ce1fed7f52584d4a23ddbd8d464b046d840c654e", "patch": "@@ -42,10 +42,6 @@ impl Ident {\n     pub fn modern(self) -> Ident {\n         Ident { name: self.name, ctxt: self.ctxt.modern() }\n     }\n-\n-    pub fn is_valid(&self) -> bool {\n-        !self.name.is_used_keyword() && !self.name.is_unused_keyword()\n-    }\n }\n \n impl fmt::Debug for Ident {\n@@ -122,20 +118,6 @@ impl Symbol {\n         self.0\n     }\n \n-    /// Returns `true` if the token is a keyword used in the language.\n-    pub fn is_used_keyword(&self) -> bool {\n-        self >= &keywords::As.name() && self <= &keywords::While.name()\n-    }\n-\n-    /// Returns `true` if the token is a keyword reserved for possible future use.\n-    pub fn is_unused_keyword(&self) -> bool {\n-        self >= &keywords::Abstract.name() && self <= &keywords::Yield.name()\n-    }\n-\n-    pub fn is_static_keyword(&self) -> bool {\n-        self == &keywords::StaticLifetime.name()\n-    }\n-\n     pub fn without_first_quote(&self) -> Symbol {\n         Symbol::from(self.as_str().trim_left_matches('\\''))\n     }"}, {"sha": "03f4fd1b3c09b97e9ab0a48450ae98314ed25ebf", "filename": "src/test/compile-fail/issue-10412.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs?ref=ce1fed7f52584d4a23ddbd8d464b046d840c654e", "patch": "@@ -9,17 +9,21 @@\n // except according to those terms.\n \n trait Serializable<'self, T> { //~ ERROR lifetimes cannot use keyword names\n-    fn serialize(val : &'self T) -> Vec<u8> ;\n+    fn serialize(val : &'self T) -> Vec<u8>;\n+    //~^ ERROR lifetimes cannot use keyword names\n     fn deserialize(repr : &[u8]) -> &'self T;\n+    //~^ ERROR lifetimes cannot use keyword names\n }\n \n-impl<'self> Serializable<str> for &'self str {\n+impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n     //~^ ERROR lifetimes cannot use keyword names\n     //~| ERROR missing lifetime specifier\n     fn serialize(val : &'self str) -> Vec<u8> {\n+    //~^ ERROR lifetimes cannot use keyword names\n         vec![1]\n     }\n     fn deserialize(repr: &[u8]) -> &'self str {\n+    //~^ ERROR lifetimes cannot use keyword names\n         \"hi\"\n     }\n }"}, {"sha": "d583c4fc6c6b8461c5ef4d3ce89d4f7a3c5ab359", "filename": "src/test/compile-fail/lifetime-no-keyword.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce1fed7f52584d4a23ddbd8d464b046d840c654e/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs?ref=ce1fed7f52584d4a23ddbd8d464b046d840c654e", "patch": "@@ -11,6 +11,7 @@\n fn foo<'a>(a: &'a isize) { }\n fn bar(a: &'static isize) { }\n fn baz<'let>(a: &'let isize) { } //~ ERROR lifetimes cannot use keyword names\n+//~^ ERROR lifetimes cannot use keyword names\n fn zab<'self>(a: &'self isize) { } //~ ERROR lifetimes cannot use keyword names\n-\n+//~^ ERROR lifetimes cannot use keyword names\n fn main() { }"}]}