{"sha": "d68c5cc399a9ba4305face637843a3c03acd404b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OGM1Y2MzOTlhOWJhNDMwNWZhY2U2Mzc4NDNhM2MwM2FjZDQwNGI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-07T21:37:36Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-07T22:13:35Z"}, "message": "Use c_ulonglong now that it works in FFI, etc...\n\nAnnotate FIXMEs; remove obsolete FIXMEs; remove an unnecessary\nPointerCast.", "tree": {"sha": "b84afcf23764471c9796b0c85e221e06a713bfdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b84afcf23764471c9796b0c85e221e06a713bfdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d68c5cc399a9ba4305face637843a3c03acd404b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d68c5cc399a9ba4305face637843a3c03acd404b", "html_url": "https://github.com/rust-lang/rust/commit/d68c5cc399a9ba4305face637843a3c03acd404b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d68c5cc399a9ba4305face637843a3c03acd404b/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc773864944c00623dc98dd5a985ae963653bd54", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc773864944c00623dc98dd5a985ae963653bd54", "html_url": "https://github.com/rust-lang/rust/commit/dc773864944c00623dc98dd5a985ae963653bd54"}], "stats": {"total": 58, "additions": 27, "deletions": 31}, "files": [{"sha": "fc1e7b1a38ff8b9c670f6b818df6d0e2f8bd6583", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d68c5cc399a9ba4305face637843a3c03acd404b/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68c5cc399a9ba4305face637843a3c03acd404b/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=d68c5cc399a9ba4305face637843a3c03acd404b", "patch": "@@ -491,9 +491,11 @@ native mod llvm {\n     fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n     fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n     fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n-    fn LLVMAddFunctionAttr(Fn: ValueRef, PA: c_uint, HighPA: c_uint);\n-    fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n-    fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: c_uint, HighPA: c_uint);\n+    fn LLVMAddFunctionAttr(Fn: ValueRef, PA: c_ulonglong, HighPA:\n+                           c_ulonglong);\n+    fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n+    fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: c_ulonglong, HighPA:\n+                              c_ulonglong);\n \n     /* Operations on parameters */\n     fn LLVMCountParams(Fn: ValueRef) -> c_uint;"}, {"sha": "34845ceb45ab58c6379e980e0b1ddec051c5b906", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d68c5cc399a9ba4305face637843a3c03acd404b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68c5cc399a9ba4305face637843a3c03acd404b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d68c5cc399a9ba4305face637843a3c03acd404b", "patch": "@@ -13,7 +13,7 @@\n //     but many TypeRefs correspond to one ty::t; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n-import libc::c_uint;\n+import libc::{c_uint, c_ulonglong};\n import std::{map, time, list};\n import std::map::hashmap;\n import std::map::{int_hash, str_hash};\n@@ -450,25 +450,25 @@ fn get_static_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n }\n \n fn set_no_inline(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, lib::llvm::NoInlineAttribute as c_uint,\n-                              0u as c_uint);\n+    llvm::LLVMAddFunctionAttr(f, lib::llvm::NoInlineAttribute as c_ulonglong,\n+                              0u as c_ulonglong);\n }\n \n fn set_no_unwind(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, lib::llvm::NoUnwindAttribute as c_uint,\n-                              0u as c_uint);\n+    llvm::LLVMAddFunctionAttr(f, lib::llvm::NoUnwindAttribute as c_ulonglong,\n+                              0u as c_ulonglong);\n }\n \n // Tell LLVM to emit the information necessary to unwind the stack for the\n // function f.\n fn set_uwtable(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, lib::llvm::UWTableAttribute as c_uint,\n-                              0u as c_uint);\n+    llvm::LLVMAddFunctionAttr(f, lib::llvm::UWTableAttribute as c_ulonglong,\n+                              0u as c_ulonglong);\n }\n \n fn set_inline_hint(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, lib::llvm::InlineHintAttribute as c_uint,\n-                              0u as c_uint);\n+    llvm::LLVMAddFunctionAttr(f, lib::llvm::InlineHintAttribute\n+                              as c_ulonglong, 0u as c_ulonglong);\n }\n \n fn set_inline_hint_if_appr(attrs: [ast::attribute],\n@@ -481,13 +481,12 @@ fn set_inline_hint_if_appr(attrs: [ast::attribute],\n }\n \n fn set_always_inline(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, lib::llvm::AlwaysInlineAttribute as c_uint,\n-                              0u as c_uint);\n+    llvm::LLVMAddFunctionAttr(f, lib::llvm::AlwaysInlineAttribute\n+                              as c_ulonglong, 0u as c_ulonglong);\n }\n \n fn set_custom_stack_growth_fn(f: ValueRef) {\n-    // FIXME: Remove this hack to work around the lack of u64 in the FFI.\n-    llvm::LLVMAddFunctionAttr(f, 0u as c_uint, 1u as c_uint);\n+    llvm::LLVMAddFunctionAttr(f, 0u as c_ulonglong, 1u as c_ulonglong);\n }\n \n fn set_glue_inlining(f: ValueRef, t: ty::t) {\n@@ -1343,7 +1342,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n     // FIXME: Provide LLVM with better alignment information when the\n     // alignment is statically known (it must be nothing more than a constant\n     // int, or LLVM complains -- not even a constant element of a tydesc\n-    // works).\n+    // works). (Related to #1645, I think?)\n     let _icx = cx.insn_ctxt(\"call_memmove\");\n     let ccx = cx.ccx();\n     let key = alt ccx.sess.targ_cfg.arch {\n@@ -1428,7 +1427,7 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n // Since it needs to zero out the source, src also needs to be an lval.\n // FIXME: We always zero out the source. Ideally we would detect the\n // case where a variable is always deinitialized by block exit and thus\n-// doesn't need to be dropped.\n+// doesn't need to be dropped. (Issue #839)\n fn move_val(cx: block, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> block {\n     let _icx = cx.insn_ctxt(\"move_val\");\n@@ -1623,7 +1622,7 @@ fn cast_shift_rhs(op: ast::binop,\n             trunc(rhs, lhs_llty)\n         } else if lhs_sz > rhs_sz {\n             // FIXME: If shifting by negative values becomes not undefined\n-            // then this is wrong.\n+            // then this is wrong. (See discussion at #1570)\n             zext(rhs, lhs_llty)\n         } else {\n             rhs\n@@ -1713,6 +1712,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n             expr_ty(bcx, ex),\n             {|bcx|\n                 // FIXME provide the already-computed address, not the expr\n+                // #2528\n                 impl::trans_method_callee(bcx, callee_id, dst, origin)\n             },\n             arg_exprs([src]), save_in(lhs_res.val));\n@@ -2006,7 +2006,7 @@ fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n }\n \n fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> option<ty::t> {\n-    // FIXME[mono] could do this recursively. is that worthwhile?\n+    // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n     alt ty::get(ty).struct {\n       ty::ty_box(mt) { some(ty::mk_opaque_box(tcx)) }\n       ty::ty_fn(fty) { some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n@@ -2379,7 +2379,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n             ccx, node_id_type(bcx, id))));\n     }\n \n-    // FIXME: Need to support external crust functions\n+    // FIXME: Need to support external crust functions (#1840)\n     if fn_id.crate == ast::local_crate {\n         alt bcx.tcx().def_map.find(id) {\n           some(ast::def_fn(_, ast::crust_fn)) {\n@@ -2480,10 +2480,7 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n         } else {\n             // Nullary variant.\n             let enum_ty = node_id_type(cx, id);\n-            let llenumblob = alloc_ty(cx, enum_ty);\n-            // FIXME: This pointer cast probably isn't necessary\n-            let llenumty = type_of(ccx, enum_ty);\n-            let llenumptr = PointerCast(cx, llenumblob, T_ptr(llenumty));\n+            let llenumptr = alloc_ty(cx, enum_ty);\n             let lldiscrimptr = GEPi(cx, llenumptr, [0u, 0u]);\n             let lldiscrim_gv = lookup_discriminant(ccx, vid);\n             let lldiscrim = Load(cx, lldiscrim_gv);\n@@ -3666,7 +3663,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                                 expr_ty(bcx, src), is_last_use);\n           }\n           ast::expr_move(dst, src) {\n-            // FIXME: calculate copy init-ness in typestate.\n+            // FIXME: calculate copy init-ness in typestate. (#839)\n             assert dest == ignore;\n             let src_r = trans_temp_lval(bcx, src);\n             let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n@@ -4650,7 +4647,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n \n // FIXME: this should do some structural hash-consing to avoid\n // duplicate constants. I think. Maybe LLVM has a magical mode\n-// that does so later on?\n+// that does so later on? (#2530)\n fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_const_expr\");\n     alt e.node {\n@@ -4754,7 +4751,7 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n               }, _) {\n                 // FIXME: Instead of recursing here to regenerate the values\n                 // for other constants, we should just look up the\n-                // already-defined value\n+                // already-defined value (#2530)\n                 trans_const_expr(cx, subexpr)\n               }\n               _ {\n@@ -4800,7 +4797,6 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   // Make the fn context\n   let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id,\n                                    some(psubsts), some(sp));\n-  // FIXME: need to substitute into the fn arg types too?\n   create_llargs_for_fn_args(fcx, no_self, decl.inputs);\n   let mut bcx_top = top_scope_block(fcx, body.info());\n   let lltop = bcx_top.llbb;\n@@ -4953,8 +4949,6 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       ast::item_class(tps, _ifaces, items, ctor, m_dtor, _) {\n         if tps.len() == 0u {\n           let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n-                         // FIXME: vtables have to get filled in depending\n-                         // on ifaces\n                          vtables: none,\n                          bounds: @[]};\n           trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,"}]}