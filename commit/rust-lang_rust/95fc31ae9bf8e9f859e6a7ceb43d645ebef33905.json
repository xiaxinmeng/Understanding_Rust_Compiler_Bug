{"sha": "95fc31ae9bf8e9f859e6a7ceb43d645ebef33905", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZmMzMWFlOWJmOGU5Zjg1OWU2YTdjZWI0M2Q2NDVlYmVmMzM5MDU=", "commit": {"author": {"name": "Jyun-Yan You", "email": "jyyou@cs.nctu.edu.tw", "date": "2013-09-25T10:30:44Z"}, "committer": {"name": "Jyun-Yan You", "email": "jyyou.tw@gmail.com", "date": "2013-10-11T00:03:34Z"}, "message": "improve C ABI\n\nI borrow some ideas from clang's ABIInfo.h and TargetInfo.cpp.\nLLVMType is replaced with ArgType, which is similar to clang's ABIArgInfo,\nand I also merge attrs of FnType into it.\n\nNow ABI implementation doesn't need to insert hidden return pointer\nto arg_tys of FnType. Instead it is handled in foreign.rs.\n\nThis change also fixes LLVM assertion failure when compiling MIPS target.", "tree": {"sha": "bd858e00cf5813cc11e933a2528a3374a05d135e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd858e00cf5813cc11e933a2528a3374a05d135e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905", "html_url": "https://github.com/rust-lang/rust/commit/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/comments", "author": {"login": "crabtw", "id": 36015, "node_id": "MDQ6VXNlcjM2MDE1", "avatar_url": "https://avatars.githubusercontent.com/u/36015?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crabtw", "html_url": "https://github.com/crabtw", "followers_url": "https://api.github.com/users/crabtw/followers", "following_url": "https://api.github.com/users/crabtw/following{/other_user}", "gists_url": "https://api.github.com/users/crabtw/gists{/gist_id}", "starred_url": "https://api.github.com/users/crabtw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crabtw/subscriptions", "organizations_url": "https://api.github.com/users/crabtw/orgs", "repos_url": "https://api.github.com/users/crabtw/repos", "events_url": "https://api.github.com/users/crabtw/events{/privacy}", "received_events_url": "https://api.github.com/users/crabtw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crabtw", "id": 36015, "node_id": "MDQ6VXNlcjM2MDE1", "avatar_url": "https://avatars.githubusercontent.com/u/36015?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crabtw", "html_url": "https://github.com/crabtw", "followers_url": "https://api.github.com/users/crabtw/followers", "following_url": "https://api.github.com/users/crabtw/following{/other_user}", "gists_url": "https://api.github.com/users/crabtw/gists{/gist_id}", "starred_url": "https://api.github.com/users/crabtw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crabtw/subscriptions", "organizations_url": "https://api.github.com/users/crabtw/orgs", "repos_url": "https://api.github.com/users/crabtw/repos", "events_url": "https://api.github.com/users/crabtw/events{/privacy}", "received_events_url": "https://api.github.com/users/crabtw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6aa5934e2ba4ec26a3de617c3c05f113690d4086", "url": "https://api.github.com/repos/rust-lang/rust/commits/6aa5934e2ba4ec26a3de617c3c05f113690d4086", "html_url": "https://github.com/rust-lang/rust/commit/6aa5934e2ba4ec26a3de617c3c05f113690d4086"}], "stats": {"total": 394, "additions": 206, "deletions": 188}, "files": [{"sha": "8648bf6f34803b92fa1e178a8302b7437fd297bb", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=95fc31ae9bf8e9f859e6a7ceb43d645ebef33905", "patch": "@@ -18,10 +18,62 @@ use middle::trans::cabi_mips;\n use middle::trans::type_::Type;\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n+#[deriving(Clone, Eq)]\n+pub enum ArgKind {\n+    /// Pass the argument directly using the normal converted\n+    /// LLVM type or by coercing to another specified type\n+    Direct,\n+    /// Pass the argument indirectly via a hidden pointer\n+    Indirect\n+}\n+\n+/// Information about how a specific C type\n+/// should be passed to or returned from a function\n+///\n+/// This is borrowed from clang's ABIInfo.h\n #[deriving(Clone)]\n-pub struct LLVMType {\n-    cast: bool,\n-    ty: Type\n+pub struct ArgType {\n+    kind: ArgKind,\n+    /// Original LLVM type\n+    ty: Type,\n+    /// Coerced LLVM Type\n+    cast: option::Option<Type>,\n+    /// Dummy argument, which is emitted before the real argument\n+    pad: option::Option<Type>,\n+    /// LLVM attribute of argument\n+    attr: option::Option<Attribute>\n+}\n+\n+impl ArgType {\n+    pub fn direct(ty: Type, cast: option::Option<Type>,\n+                            pad: option::Option<Type>,\n+                            attr: option::Option<Attribute>) -> ArgType {\n+        ArgType {\n+            kind: Direct,\n+            ty: ty,\n+            cast: cast,\n+            pad: pad,\n+            attr: attr\n+        }\n+    }\n+\n+    pub fn indirect(ty: Type, attr: option::Option<Attribute>) -> ArgType {\n+        ArgType {\n+            kind: Indirect,\n+            ty: ty,\n+            cast: option::None,\n+            pad: option::None,\n+            attr: attr\n+        }\n+    }\n+\n+    pub fn is_direct(&self) -> bool {\n+        return self.kind == Direct;\n+    }\n+\n+    pub fn is_indirect(&self) -> bool {\n+        return self.kind == Indirect;\n+    }\n }\n \n /// Metadata describing how the arguments to a native function\n@@ -30,22 +82,11 @@ pub struct LLVMType {\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n pub struct FnType {\n-    /// The LLVM types of each argument. If the cast flag is true,\n-    /// then the argument should be cast, typically because the\n-    /// official argument type will be an int and the rust type is i8\n-    /// or something like that.\n-    arg_tys: ~[LLVMType],\n-\n-    /// A list of attributes to be attached to each argument (parallel\n-    /// the `arg_tys` array). If the attribute for a given is Some,\n-    /// then the argument should be passed by reference.\n-    attrs: ~[option::Option<Attribute>],\n+    /// The LLVM types of each argument.\n+    arg_tys: ~[ArgType],\n \n     /// LLVM return type.\n-    ret_ty: LLVMType,\n-\n-    /// If true, then an implicit pointer should be added for the result.\n-    sret: bool\n+    ret_ty: ArgType,\n }\n \n pub fn compute_abi_info(ccx: &mut CrateContext,"}, {"sha": "5add2250038fba753d08ee9163db28863eb0633e", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=95fc31ae9bf8e9f859e6a7ceb43d645ebef33905", "patch": "@@ -11,14 +11,14 @@\n #[allow(non_uppercase_pattern_statics)];\n \n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n-use lib::llvm::{Attribute, StructRetAttribute};\n-use middle::trans::cabi::{FnType, LLVMType};\n+use lib::llvm::StructRetAttribute;\n+use middle::trans::cabi::{FnType, ArgType};\n use middle::trans::context::CrateContext;\n \n use middle::trans::type_::Type;\n \n use std::num;\n-use std::option::{Option, None, Some};\n+use std::option::{None, Some};\n \n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n@@ -85,9 +85,9 @@ fn ty_size(ty: Type) -> uint {\n     }\n }\n \n-fn classify_ret_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n+fn classify_ret_ty(ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        return (LLVMType { cast: false, ty: ty }, None);\n+        return ArgType::direct(ty, None, None, None);\n     }\n     let size = ty_size(ty);\n     if size <= 4 {\n@@ -98,14 +98,14 @@ fn classify_ret_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n         } else {\n             Type::i32()\n         };\n-        return (LLVMType { cast: true, ty: llty }, None);\n+        return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    (LLVMType { cast: false, ty: ty.ptr_to() }, Some(StructRetAttribute))\n+    ArgType::indirect(ty, Some(StructRetAttribute))\n }\n \n-fn classify_arg_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n+fn classify_arg_ty(ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        return (LLVMType { cast: false, ty: ty }, None);\n+        return ArgType::direct(ty, None, None, None);\n     }\n     let align = ty_align(ty);\n     let size = ty_size(ty);\n@@ -114,7 +114,7 @@ fn classify_arg_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n     } else {\n         Type::array(&Type::i64(), ((size + 7) / 8) as u64)\n     };\n-    (LLVMType { cast: true, ty: llty }, None)\n+    ArgType::direct(ty, Some(llty), None, None)\n }\n \n fn is_reg_ty(ty: Type) -> bool {\n@@ -132,32 +132,19 @@ pub fn compute_abi_info(_ccx: &mut CrateContext,\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     let mut arg_tys = ~[];\n-    let mut attrs = ~[];\n     for &aty in atys.iter() {\n-        let (ty, attr) = classify_arg_ty(aty);\n+        let ty = classify_arg_ty(aty);\n         arg_tys.push(ty);\n-        attrs.push(attr);\n     }\n \n-    let (ret_ty, ret_attr) = if ret_def {\n+    let ret_ty = if ret_def {\n         classify_ret_ty(rty)\n     } else {\n-        (LLVMType { cast: false, ty: Type::void() }, None)\n+        ArgType::direct(Type::void(), None, None, None)\n     };\n \n-    let mut ret_ty = ret_ty;\n-\n-    let sret = ret_attr.is_some();\n-    if sret {\n-        arg_tys.unshift(ret_ty);\n-        attrs.unshift(ret_attr);\n-        ret_ty = LLVMType { cast: false, ty: Type::void() };\n-    }\n-\n     return FnType {\n         arg_tys: arg_tys,\n         ret_ty: ret_ty,\n-        attrs: attrs,\n-        sret: sret\n     };\n }"}, {"sha": "3f2d18ddbe2fc8715b661e46604367699e65470d", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 22, "deletions": 48, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=95fc31ae9bf8e9f859e6a7ceb43d645ebef33905", "patch": "@@ -12,9 +12,8 @@\n \n use std::libc::c_uint;\n use std::num;\n-use std::vec;\n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n-use lib::llvm::{Attribute, StructRetAttribute};\n+use lib::llvm::StructRetAttribute;\n use middle::trans::context::CrateContext;\n use middle::trans::context::task_llcx;\n use middle::trans::cabi::*;\n@@ -86,15 +85,15 @@ fn ty_size(ty: Type) -> uint {\n     }\n }\n \n-fn classify_ret_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n-    return if is_reg_ty(ty) {\n-        (LLVMType { cast: false, ty: ty }, None)\n+fn classify_ret_ty(ty: Type) -> ArgType {\n+    if is_reg_ty(ty) {\n+        ArgType::direct(ty, None, None, None)\n     } else {\n-        (LLVMType { cast: false, ty: ty.ptr_to() }, Some(StructRetAttribute))\n-    };\n+        ArgType::indirect(ty, Some(StructRetAttribute))\n+    }\n }\n \n-fn classify_arg_ty(ty: Type, offset: &mut uint) -> (LLVMType, Option<Attribute>) {\n+fn classify_arg_ty(ty: Type, offset: &mut uint) -> ArgType {\n     let orig_offset = *offset;\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n@@ -103,20 +102,16 @@ fn classify_arg_ty(ty: Type, offset: &mut uint) -> (LLVMType, Option<Attribute>)\n     *offset = align_up_to(*offset, align);\n     *offset += align_up_to(size, align * 8) / 8;\n \n-    let padding = padding_ty(align, orig_offset);\n-    return if !is_reg_ty(ty) {\n-        (LLVMType {\n-            cast: true,\n-            ty: struct_ty(ty, padding, true)\n-        }, None)\n-    } else if padding.is_some() {\n-        (LLVMType {\n-            cast: true,\n-            ty: struct_ty(ty, padding, false)\n-        }, None)\n+    if is_reg_ty(ty) {\n+        ArgType::direct(ty, None, None, None)\n     } else {\n-        (LLVMType { cast: false, ty: ty }, None)\n-    };\n+        ArgType::direct(\n+            ty,\n+            Some(struct_ty(ty)),\n+            padding_ty(align, orig_offset),\n+            None\n+        )\n+    }\n }\n \n fn is_reg_ty(ty: Type) -> bool {\n@@ -157,54 +152,33 @@ fn coerce_to_int(size: uint) -> ~[Type] {\n     args\n }\n \n-fn struct_ty(ty: Type,\n-             padding: Option<Type>,\n-             coerce: bool) -> Type {\n+fn struct_ty(ty: Type) -> Type {\n     let size = ty_size(ty) * 8;\n-    let mut fields = padding.map_default(~[], |p| ~[p]);\n-\n-    if coerce {\n-        fields = vec::append(fields, coerce_to_int(size));\n-    } else {\n-        fields.push(ty);\n-    }\n-\n+    let fields = coerce_to_int(size);\n     return Type::struct_(fields, false);\n }\n \n pub fn compute_abi_info(_ccx: &mut CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    let (ret_ty, ret_attr) = if ret_def {\n+    let ret_ty = if ret_def {\n         classify_ret_ty(rty)\n     } else {\n-        (LLVMType { cast: false, ty: Type::void() }, None)\n+        ArgType::direct(Type::void(), None, None, None)\n     };\n \n-    let mut ret_ty = ret_ty;\n-\n-    let sret = ret_attr.is_some();\n+    let sret = ret_ty.is_indirect();\n     let mut arg_tys = ~[];\n-    let mut attrs = ~[];\n     let mut offset = if sret { 4 } else { 0 };\n \n     for aty in atys.iter() {\n-        let (ty, attr) = classify_arg_ty(*aty, &mut offset);\n+        let ty = classify_arg_ty(*aty, &mut offset);\n         arg_tys.push(ty);\n-        attrs.push(attr);\n     };\n \n-    if sret {\n-        arg_tys = vec::append(~[ret_ty], arg_tys);\n-        attrs = vec::append(~[ret_attr], attrs);\n-        ret_ty = LLVMType { cast: false, ty: Type::void() };\n-    }\n-\n     return FnType {\n         arg_tys: arg_tys,\n         ret_ty: ret_ty,\n-        attrs: attrs,\n-        sret: sret\n     };\n }"}, {"sha": "244087f814ce13ffcf6f9ba8a28aa38c77ab2e00", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=95fc31ae9bf8e9f859e6a7ceb43d645ebef33905", "patch": "@@ -21,16 +21,10 @@ pub fn compute_abi_info(ccx: &mut CrateContext,\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     let mut arg_tys = ~[];\n-    let mut attrs = ~[];\n \n     let ret_ty;\n-    let sret;\n     if !ret_def {\n-        ret_ty = LLVMType {\n-            cast: false,\n-            ty: Type::void(),\n-        };\n-        sret = false;\n+        ret_ty = ArgType::direct(Type::void(), None, None, None);\n     } else if rty.kind() == Struct {\n         // Returning a structure. Most often, this will use\n         // a hidden first argument. On some platforms, though,\n@@ -58,43 +52,22 @@ pub fn compute_abi_info(ccx: &mut CrateContext,\n \n         match strategy {\n             RetValue(t) => {\n-                ret_ty = LLVMType {\n-                    cast: true,\n-                    ty: t\n-                };\n-                sret = false;\n+                ret_ty = ArgType::direct(rty, Some(t), None, None);\n             }\n             RetPointer => {\n-                arg_tys.push(LLVMType {\n-                    cast: false,\n-                    ty: rty.ptr_to()\n-                });\n-                attrs.push(Some(StructRetAttribute));\n-\n-                ret_ty = LLVMType {\n-                    cast: false,\n-                    ty: Type::void(),\n-                };\n-                sret = true;\n+                ret_ty = ArgType::indirect(rty, Some(StructRetAttribute));\n             }\n         }\n     } else {\n-        ret_ty = LLVMType {\n-            cast: false,\n-            ty: rty\n-        };\n-        sret = false;\n+        ret_ty = ArgType::direct(rty, None, None, None);\n     }\n \n     for &a in atys.iter() {\n-        arg_tys.push(LLVMType { cast: false, ty: a });\n-        attrs.push(None);\n+        arg_tys.push(ArgType::direct(a, None, None, None));\n     }\n \n     return FnType {\n         arg_tys: arg_tys,\n         ret_ty: ret_ty,\n-        attrs: attrs,\n-        sret: sret\n     };\n }"}, {"sha": "b35ffe5c965dcd61de9cca8090810073cb602d0a", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=95fc31ae9bf8e9f859e6a7ceb43d645ebef33905", "patch": "@@ -22,8 +22,6 @@ use middle::trans::context::CrateContext;\n use middle::trans::type_::Type;\n \n use std::num;\n-use std::option;\n-use std::option::Option;\n use std::vec;\n \n #[deriving(Clone, Eq)]\n@@ -340,50 +338,34 @@ pub fn compute_abi_info(_ccx: &mut CrateContext,\n                         ret_def: bool) -> FnType {\n     fn x86_64_ty(ty: Type,\n                  is_mem_cls: &fn(cls: &[RegClass]) -> bool,\n-                 attr: Attribute) -> (LLVMType, Option<Attribute>) {\n+                 attr: Attribute) -> ArgType {\n \n-        let (cast, attr, ty) = if !ty.is_reg_ty() {\n+        if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n             if is_mem_cls(cls) {\n-                (false, option::Some(attr), ty.ptr_to())\n+                ArgType::indirect(ty, Some(attr))\n             } else {\n-                (true, option::None, llreg_ty(cls))\n+                ArgType::direct(ty, Some(llreg_ty(cls)), None, None)\n             }\n         } else {\n-            (false, option::None, ty)\n-        };\n-\n-        (LLVMType { cast: cast, ty: ty }, attr)\n+            ArgType::direct(ty, None, None, None)\n+        }\n     }\n \n     let mut arg_tys = ~[];\n-    let mut attrs = ~[];\n     for t in atys.iter() {\n-        let (ty, attr) = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n+        let ty = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);\n-        attrs.push(attr);\n-    }\n-    let (ret_ty, ret_attr) = x86_64_ty(rty, |cls| cls.is_ret_bysret(),\n-                                       StructRetAttribute);\n-    let mut ret_ty = ret_ty;\n-    let sret = ret_attr.is_some();\n-    if sret {\n-        arg_tys = vec::append(~[ret_ty], arg_tys);\n-        ret_ty = LLVMType {\n-                   cast:  false,\n-                   ty: Type::void()\n-                 };\n-        attrs = vec::append(~[ret_attr], attrs);\n-    } else if !ret_def {\n-        ret_ty = LLVMType {\n-                   cast: false,\n-                   ty: Type::void()\n-                 };\n     }\n+\n+    let ret_ty = if ret_def {\n+        x86_64_ty(rty, |cls| cls.is_ret_bysret(), StructRetAttribute)\n+    } else {\n+        ArgType::direct(Type::void(), None, None, None)\n+    };\n+\n     return FnType {\n         arg_tys: arg_tys,\n         ret_ty: ret_ty,\n-        attrs: attrs,\n-        sret: sret\n     };\n }"}, {"sha": "9c83f7322045333d4327f9d82cb88c357973110d", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 94, "deletions": 33, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95fc31ae9bf8e9f859e6a7ceb43d645ebef33905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=95fc31ae9bf8e9f859e6a7ceb43d645ebef33905", "patch": "@@ -11,7 +11,7 @@\n \n use back::{link};\n use std::libc::c_uint;\n-use lib::llvm::{ValueRef, Attribute, CallConv, StructRetAttribute};\n+use lib::llvm::{ValueRef, CallConv, StructRetAttribute};\n use lib::llvm::llvm;\n use lib;\n use middle::trans::machine;\n@@ -183,29 +183,26 @@ pub fn trans_native_call(bcx: @mut Block,\n                                          llsig.llret_ty,\n                                          ret_def);\n \n-    let all_arg_tys: &[cabi::LLVMType] = fn_type.arg_tys;\n-    let all_attributes: &[Option<Attribute>] = fn_type.attrs;\n+    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys;\n \n     let mut llargs_foreign = ~[];\n \n     // If the foreign ABI expects return value by pointer, supply the\n     // pointer that Rust gave us. Sometimes we have to bitcast\n     // because foreign fns return slightly different (but equivalent)\n     // views on the same type (e.g., i64 in place of {i32,i32}).\n-    let (arg_tys, attributes) = {\n-        if fn_type.sret {\n-            if all_arg_tys[0].cast {\n+    if fn_type.ret_ty.is_indirect() {\n+        match fn_type.ret_ty.cast {\n+            Some(ty) => {\n                 let llcastedretptr =\n-                    BitCast(bcx, llretptr, all_arg_tys[0].ty.ptr_to());\n+                    BitCast(bcx, llretptr, ty.ptr_to());\n                 llargs_foreign.push(llcastedretptr);\n-            } else {\n+            }\n+            None => {\n                 llargs_foreign.push(llretptr);\n             }\n-            (all_arg_tys.tail(), all_attributes.tail())\n-        } else {\n-            (all_arg_tys, all_attributes)\n         }\n-    };\n+    }\n \n     for (i, &llarg_rust) in llargs_rust.iter().enumerate() {\n         let mut llarg_rust = llarg_rust;\n@@ -231,16 +228,16 @@ pub fn trans_native_call(bcx: @mut Block,\n                ccx.tn.val_to_str(llarg_rust));\n \n         // Check whether we need to do any casting\n-        let foreignarg_ty = arg_tys[i].ty;\n-        if arg_tys[i].cast {\n-            llarg_rust = BitCast(bcx, llarg_rust, foreignarg_ty.ptr_to());\n+        match arg_tys[i].cast {\n+            Some(ty) => llarg_rust = BitCast(bcx, llarg_rust, ty.ptr_to()),\n+            None => ()\n         }\n \n         debug2!(\"llarg_rust={} (after casting)\",\n                ccx.tn.val_to_str(llarg_rust));\n \n         // Finally, load the value if needed for the foreign ABI\n-        let foreign_indirect = attributes[i].is_some();\n+        let foreign_indirect = arg_tys[i].is_indirect();\n         let llarg_foreign = if foreign_indirect {\n             llarg_rust\n         } else {\n@@ -250,6 +247,11 @@ pub fn trans_native_call(bcx: @mut Block,\n         debug2!(\"argument {}, llarg_foreign={}\",\n                i, ccx.tn.val_to_str(llarg_foreign));\n \n+        // fill padding with undef value\n+        match arg_tys[i].pad {\n+            Some(ty) => llargs_foreign.push(C_undef(ty)),\n+            None => ()\n+        }\n         llargs_foreign.push(llarg_foreign);\n     }\n \n@@ -268,7 +270,7 @@ pub fn trans_native_call(bcx: @mut Block,\n     // any attributes with ABI implications directly to the call instruction. Right now, the\n     // only attribute we need to worry about is `sret`.\n     let attrs;\n-    if fn_type.sret {\n+    if fn_type.ret_ty.is_indirect() {\n         attrs = &[(1, StructRetAttribute)];\n     } else {\n         attrs = &[];\n@@ -280,9 +282,12 @@ pub fn trans_native_call(bcx: @mut Block,\n     // type to match because some ABIs will use a different type than\n     // the Rust type. e.g., a {u32,u32} struct could be returned as\n     // u64.\n-    if ret_def && !fn_type.sret {\n+    if ret_def && !fn_type.ret_ty.is_indirect() {\n         let llrust_ret_ty = llsig.llret_ty;\n-        let llforeign_ret_ty = fn_type.ret_ty.ty;\n+        let llforeign_ret_ty = match fn_type.ret_ty.cast {\n+            Some(ty) => ty,\n+            None => fn_type.ret_ty.ty\n+        };\n \n         debug2!(\"llretptr={}\", ccx.tn.val_to_str(llretptr));\n         debug2!(\"llforeign_retval={}\", ccx.tn.val_to_str(llforeign_retval));\n@@ -474,17 +479,17 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         // Array for the arguments we will pass to the rust function.\n         let mut llrust_args = ~[];\n         let mut next_foreign_arg_counter: c_uint = 0;\n-        let next_foreign_arg: &fn() -> c_uint = {\n-            || {\n-                next_foreign_arg_counter += 1;\n+        let next_foreign_arg: &fn(pad: bool) -> c_uint = {\n+            |pad: bool| {\n+                next_foreign_arg_counter += if pad { 2 } else { 1 };\n                 next_foreign_arg_counter - 1\n             }\n         };\n \n         // If there is an out pointer on the foreign function\n         let foreign_outptr = {\n-            if tys.fn_ty.sret {\n-                Some(llvm::LLVMGetParam(llwrapfn, next_foreign_arg()))\n+            if tys.fn_ty.ret_ty.is_indirect() {\n+                Some(llvm::LLVMGetParam(llwrapfn, next_foreign_arg(false)))\n             } else {\n                 None\n             }\n@@ -553,9 +558,12 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         for i in range(0, tys.fn_sig.inputs.len()) {\n             let rust_ty = tys.fn_sig.inputs[i];\n             let llrust_ty = tys.llsig.llarg_tys[i];\n-            let foreign_index = next_foreign_arg();\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n-            let foreign_indirect = tys.fn_ty.attrs[foreign_index].is_some();\n+            let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n+            let foreign_indirect = llforeign_arg_ty.is_indirect();\n+\n+            // skip padding\n+            let foreign_index = next_foreign_arg(llforeign_arg_ty.pad.is_some());\n             let mut llforeign_arg = llvm::LLVMGetParam(llwrapfn, foreign_index);\n \n             debug2!(\"llforeign_arg \\\\#{}: {}\",\n@@ -578,7 +586,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             // If the types in the ABI and the Rust types don't match,\n             // bitcast the llforeign_arg pointer so it matches the types\n             // Rust expects.\n-            if tys.fn_ty.arg_tys[foreign_index].cast {\n+            if llforeign_arg_ty.cast.is_some() {\n                 assert!(!foreign_indirect);\n                 llforeign_arg = llvm::LLVMBuildBitCast(\n                     builder, llforeign_arg,\n@@ -604,7 +612,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         };\n \n         // Get the return value where the foreign fn expects it.\n-        let llforeign_ret_ty = tys.fn_ty.ret_ty.ty;\n+        let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {\n+            Some(ty) => ty,\n+            None => tys.fn_ty.ret_ty.ty\n+        };\n         match foreign_outptr {\n             None if !tys.ret_def => {\n                 // Function returns `()` or `bot`, which in Rust is the LLVM\n@@ -744,9 +755,38 @@ fn foreign_types_for_fn_ty(ccx: &mut CrateContext,\n }\n \n fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n-    let llargument_tys: ~[Type] =\n-        tys.fn_ty.arg_tys.iter().map(|t| t.ty).collect();\n-    let llreturn_ty = tys.fn_ty.ret_ty.ty;\n+    let mut llargument_tys = ~[];\n+\n+    let ret_ty = tys.fn_ty.ret_ty;\n+    let llreturn_ty = if ret_ty.is_indirect() {\n+        llargument_tys.push(ret_ty.ty.ptr_to());\n+        Type::void()\n+    } else {\n+        match ret_ty.cast {\n+            Some(ty) => ty,\n+            None => ret_ty.ty\n+        }\n+    };\n+\n+    for &arg_ty in tys.fn_ty.arg_tys.iter() {\n+        // add padding\n+        match arg_ty.pad {\n+            Some(ty) => llargument_tys.push(ty),\n+            None => ()\n+        }\n+\n+        let llarg_ty = if arg_ty.is_indirect() {\n+            arg_ty.ty.ptr_to()\n+        } else {\n+            match arg_ty.cast {\n+                Some(ty) => ty,\n+                None => arg_ty.ty\n+            }\n+        };\n+\n+        llargument_tys.push(llarg_ty);\n+    }\n+\n     Type::func(llargument_tys, &llreturn_ty)\n }\n \n@@ -757,8 +797,27 @@ pub fn lltype_for_foreign_fn(ccx: &mut CrateContext, ty: ty::t) -> Type {\n \n fn add_argument_attributes(tys: &ForeignTypes,\n                            llfn: ValueRef) {\n-    for (i, a) in tys.fn_ty.attrs.iter().enumerate() {\n-        match *a {\n+    let mut i = 0;\n+\n+    if tys.fn_ty.ret_ty.is_indirect() {\n+        match tys.fn_ty.ret_ty.attr {\n+            Some(attr) => {\n+                let llarg = get_param(llfn, i);\n+                unsafe {\n+                    llvm::LLVMAddAttribute(llarg, attr as c_uint);\n+                }\n+            }\n+            None => {}\n+        }\n+\n+        i += 1;\n+    }\n+\n+    for &arg_ty in tys.fn_ty.arg_tys.iter() {\n+        // skip padding\n+        if arg_ty.pad.is_some() { i += 1; }\n+\n+        match arg_ty.attr {\n             Some(attr) => {\n                 let llarg = get_param(llfn, i);\n                 unsafe {\n@@ -767,5 +826,7 @@ fn add_argument_attributes(tys: &ForeignTypes,\n             }\n             None => ()\n         }\n+\n+        i += 1;\n     }\n }"}]}