{"sha": "15ea338ac991707d330288ba4d1bf5daa0fc75d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZWEzMzhhYzk5MTcwN2QzMzAyODhiYTRkMWJmNWRhYTBmYzc1ZDk=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-25T00:54:54Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-25T00:54:54Z"}, "message": "Merge branch 'master' of https://github.com/rust-analyzer/rust-analyzer into feature/themes", "tree": {"sha": "16aeab28bcdb07d36aae28e3fb4a385614865a48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16aeab28bcdb07d36aae28e3fb4a385614865a48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ea338ac991707d330288ba4d1bf5daa0fc75d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ea338ac991707d330288ba4d1bf5daa0fc75d9", "html_url": "https://github.com/rust-lang/rust/commit/15ea338ac991707d330288ba4d1bf5daa0fc75d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ea338ac991707d330288ba4d1bf5daa0fc75d9/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb7363d167c7a9f7c73cb950b621eb1dce493318", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb7363d167c7a9f7c73cb950b621eb1dce493318", "html_url": "https://github.com/rust-lang/rust/commit/eb7363d167c7a9f7c73cb950b621eb1dce493318"}, {"sha": "f7f9757b6b144385ab8ce57b15764473b1f57331", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f9757b6b144385ab8ce57b15764473b1f57331", "html_url": "https://github.com/rust-lang/rust/commit/f7f9757b6b144385ab8ce57b15764473b1f57331"}], "stats": {"total": 4372, "additions": 2468, "deletions": 1904}, "files": [{"sha": "fc0f7c12fa99191896e7e54199758756afccdc1c", "filename": "crates/ra_arena/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Flib.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -37,7 +37,7 @@ impl fmt::Display for RawId {\n }\n \n #[derive(Clone, PartialEq, Eq)]\n-pub struct Arena<ID: ArenaId, T> {\n+pub struct Arena<ID, T> {\n     data: Vec<T>,\n     _ty: PhantomData<ID>,\n }\n@@ -67,6 +67,12 @@ pub trait ArenaId {\n     fn into_raw(self) -> RawId;\n }\n \n+impl<ID, T> Arena<ID, T> {\n+    pub const fn new() -> Arena<ID, T> {\n+        Arena { data: Vec::new(), _ty: PhantomData }\n+    }\n+}\n+\n impl<ID: ArenaId, T> Arena<ID, T> {\n     pub fn len(&self) -> usize {\n         self.data.len()\n@@ -79,7 +85,7 @@ impl<ID: ArenaId, T> Arena<ID, T> {\n         self.data.push(value);\n         ID::from_raw(id)\n     }\n-    pub fn iter(&self) -> impl Iterator<Item = (ID, &T)> + ExactSizeIterator {\n+    pub fn iter(&self) -> impl Iterator<Item = (ID, &T)> + ExactSizeIterator + DoubleEndedIterator {\n         self.data.iter().enumerate().map(|(idx, value)| (ID::from_raw(RawId(idx as u32)), value))\n     }\n }"}, {"sha": "ee8bff34678b5a1bbb9cf888cba5460b31d8c876", "filename": "crates/ra_assists/src/assists/add_new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -36,7 +36,7 @@ pub(crate) fn add_new(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n \n     // We want to only apply this to non-union structs with named fields\n     let field_list = match (strukt.kind(), strukt.is_union()) {\n-        (StructKind::Named(named), false) => named,\n+        (StructKind::Record(named), false) => named,\n         _ => return None,\n     };\n "}, {"sha": "7c57c0560dfc6d62ada217f6e2d50bd28065ce32", "filename": "crates/ra_assists/src/assists/apply_demorgan.rs", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,6 +1,6 @@\n+use super::invert_if::invert_boolean_expression;\n use hir::db::HirDatabase;\n use ra_syntax::ast::{self, AstNode};\n-use ra_syntax::SyntaxNode;\n \n use crate::{Assist, AssistCtx, AssistId};\n \n@@ -32,18 +32,18 @@ pub(crate) fn apply_demorgan(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist>\n     if !cursor_in_range {\n         return None;\n     }\n-    let lhs = expr.lhs()?.syntax().clone();\n-    let lhs_range = lhs.text_range();\n-    let rhs = expr.rhs()?.syntax().clone();\n-    let rhs_range = rhs.text_range();\n-    let not_lhs = undo_negation(lhs)?;\n-    let not_rhs = undo_negation(rhs)?;\n+    let lhs = expr.lhs()?;\n+    let lhs_range = lhs.syntax().text_range();\n+    let rhs = expr.rhs()?;\n+    let rhs_range = rhs.syntax().text_range();\n+    let not_lhs = invert_boolean_expression(&lhs)?;\n+    let not_rhs = invert_boolean_expression(&rhs)?;\n \n     ctx.add_assist(AssistId(\"apply_demorgan\"), \"apply demorgan's law\", |edit| {\n         edit.target(op_range);\n         edit.replace(op_range, opposite_op);\n-        edit.replace(lhs_range, format!(\"!({}\", not_lhs));\n-        edit.replace(rhs_range, format!(\"{})\", not_rhs));\n+        edit.replace(lhs_range, format!(\"!({}\", not_lhs.syntax().text()));\n+        edit.replace(rhs_range, format!(\"{})\", not_rhs.syntax().text()));\n     })\n }\n \n@@ -56,28 +56,6 @@ fn opposite_logic_op(kind: ast::BinOp) -> Option<&'static str> {\n     }\n }\n \n-// This function tries to undo unary negation, or inequality\n-fn undo_negation(node: SyntaxNode) -> Option<String> {\n-    match ast::Expr::cast(node)? {\n-        ast::Expr::BinExpr(bin) => match bin.op_kind()? {\n-            ast::BinOp::NegatedEqualityTest => {\n-                let lhs = bin.lhs()?.syntax().text();\n-                let rhs = bin.rhs()?.syntax().text();\n-                Some(format!(\"{} == {}\", lhs, rhs))\n-            }\n-            _ => None,\n-        },\n-        ast::Expr::PrefixExpr(pe) => match pe.op_kind()? {\n-            ast::PrefixOp::Not => {\n-                let child = pe.expr()?.syntax().text();\n-                Some(String::from(child))\n-            }\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "8482897c57c1a5247079df0336f54333fe029b42", "filename": "crates/ra_assists/src/assists/fill_match_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -101,7 +101,7 @@ fn build_pat(var: ast::EnumVariant) -> Option<ast::Pat> {\n                 iter::repeat(make::placeholder_pat().into()).take(field_list.fields().count());\n             make::tuple_struct_pat(path, pats).into()\n         }\n-        ast::StructKind::Named(field_list) => {\n+        ast::StructKind::Record(field_list) => {\n             let pats = field_list.fields().map(|f| make::bind_pat(f.name().unwrap()).into());\n             make::record_pat(path, pats).into()\n         }"}, {"sha": "bababa3e25f38cb2e9c9f45f97a9ff043e17f40c", "filename": "crates/ra_assists/src/assists/invert_if.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Fassists%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Fassists%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Finvert_if.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -0,0 +1,102 @@\n+use hir::db::HirDatabase;\n+use ra_syntax::ast::{self, AstNode};\n+use ra_syntax::T;\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+\n+// Assist: invert_if\n+//\n+// Apply invert_if\n+// This transforms if expressions of the form `if !x {A} else {B}` into `if x {B} else {A}`\n+// This also works with `!=`. This assist can only be applied with the cursor\n+// on `if`.\n+//\n+// ```\n+// fn main() {\n+//     if<|> !y { A } else { B }\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     if y { B } else { A }\n+// }\n+// ```\n+\n+pub(crate) fn invert_if(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let if_keyword = ctx.find_token_at_offset(T![if])?;\n+    let expr = ast::IfExpr::cast(if_keyword.parent())?;\n+    let if_range = if_keyword.text_range();\n+    let cursor_in_range = ctx.frange.range.is_subrange(&if_range);\n+    if !cursor_in_range {\n+        return None;\n+    }\n+\n+    let cond = expr.condition()?.expr()?;\n+    let then_node = expr.then_branch()?.syntax().clone();\n+\n+    if let ast::ElseBranch::Block(else_block) = expr.else_branch()? {\n+        let flip_cond = invert_boolean_expression(&cond)?;\n+        let cond_range = cond.syntax().text_range();\n+        let else_node = else_block.syntax();\n+        let else_range = else_node.text_range();\n+        let then_range = then_node.text_range();\n+        return ctx.add_assist(AssistId(\"invert_if\"), \"invert if branches\", |edit| {\n+            edit.target(if_range);\n+            edit.replace(cond_range, flip_cond.syntax().text());\n+            edit.replace(else_range, then_node.text());\n+            edit.replace(then_range, else_node.text());\n+        });\n+    }\n+\n+    None\n+}\n+\n+pub(crate) fn invert_boolean_expression(expr: &ast::Expr) -> Option<ast::Expr> {\n+    match expr {\n+        ast::Expr::BinExpr(bin) => match bin.op_kind()? {\n+            ast::BinOp::NegatedEqualityTest => bin.replace_op(T![==]).map(|it| it.into()),\n+            _ => None,\n+        },\n+        ast::Expr::PrefixExpr(pe) => match pe.op_kind()? {\n+            ast::PrefixOp::Not => pe.expr(),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn invert_if_remove_inequality() {\n+        check_assist(\n+            invert_if,\n+            \"fn f() { i<|>f x != 3 { 1 } else { 3 + 2 } }\",\n+            \"fn f() { i<|>f x == 3 { 3 + 2 } else { 1 } }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn invert_if_remove_not() {\n+        check_assist(\n+            invert_if,\n+            \"fn f() { <|>if !cond { 3 * 2 } else { 1 } }\",\n+            \"fn f() { <|>if cond { 1 } else { 3 * 2 } }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn invert_if_doesnt_apply_with_cursor_not_on_if() {\n+        check_assist_not_applicable(invert_if, \"fn f() { if !<|>cond { 3 * 2 } else { 1 } }\")\n+    }\n+\n+    #[test]\n+    fn invert_if_doesnt_apply_without_negated() {\n+        check_assist_not_applicable(invert_if, \"fn f() { i<|>f cond { 3 * 2 } else { 1 } }\")\n+    }\n+}"}, {"sha": "3c716c2d121a392f2b9db699675eaa67c16faa87", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -341,6 +341,23 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_invert_if() {\n+    check(\n+        \"invert_if\",\n+        r#####\"\n+fn main() {\n+    if<|> !y { A } else { B }\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    if y { B } else { A }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_make_raw_string() {\n     check("}, {"sha": "a372bd8b9d54ea9695c47b00144c84369253e2af", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -97,6 +97,7 @@ mod assists {\n     mod add_impl;\n     mod add_new;\n     mod apply_demorgan;\n+    mod invert_if;\n     mod flip_comma;\n     mod flip_binexpr;\n     mod flip_trait_bound;\n@@ -122,6 +123,7 @@ mod assists {\n             add_impl::add_impl,\n             add_new::add_new,\n             apply_demorgan::apply_demorgan,\n+            invert_if::invert_if,\n             change_visibility::change_visibility,\n             fill_match_arms::fill_match_arms,\n             merge_match_arms::merge_match_arms,"}, {"sha": "5f96c974bc10eb960b9b2d7eac4f3cb2cf3a6f32", "filename": "crates/ra_assists/src/test_db.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftest_db.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -10,7 +10,6 @@ use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath\n     hir::db::InternDatabaseStorage,\n     hir::db::AstDatabaseStorage,\n     hir::db::DefDatabaseStorage,\n-    hir::db::DefDatabase2Storage,\n     hir::db::HirDatabaseStorage\n )]\n #[derive(Debug, Default)]"}, {"sha": "cb389eb26127e81302ade027570ee80b5e80b6fc", "filename": "crates/ra_batch/src/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_batch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_batch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2Fsrc%2Flib.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -117,9 +117,12 @@ pub fn load(\n                         done = true;\n                     }\n                 }\n-                VfsChange::AddFile { .. }\n-                | VfsChange::RemoveFile { .. }\n-                | VfsChange::ChangeFile { .. } => {\n+                VfsChange::AddFile { root, file, path, text } => {\n+                    let source_root_id = vfs_root_to_id(root);\n+                    let file_id = vfs_file_to_id(file);\n+                    analysis_change.add_file(source_root_id, file_id, path, text);\n+                }\n+                VfsChange::RemoveFile { .. } | VfsChange::ChangeFile { .. } => {\n                     // We just need the first scan, so just ignore these\n                 }\n             }"}, {"sha": "c4eb28245b2937af491d84a3649cd597ec580b75", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -3,7 +3,7 @@\n use std::{collections::HashSet, fmt::Write, path::Path, time::Instant};\n \n use ra_db::SourceDatabaseExt;\n-use ra_hir::{AssocItem, Crate, HasBodySource, HasSource, HirDisplay, ModuleDef, Ty, TypeWalk};\n+use ra_hir::{AssocItem, Crate, HasSource, HirDisplay, ModuleDef, Ty, TypeWalk};\n use ra_syntax::AstNode;\n \n use crate::{Result, Verbosity};\n@@ -109,7 +109,7 @@ pub fn run(\n         }\n         let body = f.body(db);\n         let inference_result = f.infer(db);\n-        for (expr_id, _) in body.exprs() {\n+        for (expr_id, _) in body.exprs.iter() {\n             let ty = &inference_result[expr_id];\n             num_exprs += 1;\n             if let Ty::Unknown = ty {\n@@ -128,15 +128,16 @@ pub fn run(\n             if let Some(mismatch) = inference_result.type_mismatch_for_expr(expr_id) {\n                 num_type_mismatches += 1;\n                 if verbosity.is_verbose() {\n-                    let src = f.expr_source(db, expr_id);\n+                    let src = f.body_source_map(db).expr_syntax(expr_id);\n                     if let Some(src) = src {\n                         // FIXME: it might be nice to have a function (on Analysis?) that goes from Source<T> -> (LineCol, LineCol) directly\n                         let original_file = src.file_id.original_file(db);\n                         let path = db.file_relative_path(original_file);\n                         let line_index = host.analysis().file_line_index(original_file).unwrap();\n-                        let text_range = src\n-                            .value\n-                            .either(|it| it.syntax().text_range(), |it| it.syntax().text_range());\n+                        let text_range = src.value.either(\n+                            |it| it.syntax_node_ptr().range(),\n+                            |it| it.syntax_node_ptr().range(),\n+                        );\n                         let (start, end) = (\n                             line_index.line_col(text_range.start()),\n                             line_index.line_col(text_range.end()),"}, {"sha": "e8f335e333c19f1c2bb91ed5955668bfb858aa47", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -8,7 +8,7 @@ use rustc_hash::FxHashMap;\n use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n \n use crate::{\n-    CrateGraph, CrateId, Edition, FileId, FilePosition, RelativePathBuf, SourceDatabaseExt,\n+    CrateGraph, CrateId, Edition, Env, FileId, FilePosition, RelativePathBuf, SourceDatabaseExt,\n     SourceRoot, SourceRootId,\n };\n \n@@ -53,7 +53,12 @@ fn with_single_file(db: &mut dyn SourceDatabaseExt, text: &str) -> FileId {\n     source_root.insert_file(rel_path.clone(), file_id);\n \n     let mut crate_graph = CrateGraph::default();\n-    crate_graph.add_crate_root(file_id, Edition::Edition2018, CfgOptions::default());\n+    crate_graph.add_crate_root(\n+        file_id,\n+        Edition::Edition2018,\n+        CfgOptions::default(),\n+        Env::default(),\n+    );\n \n     db.set_file_text(file_id, Arc::new(text.to_string()));\n     db.set_file_relative_path(file_id, rel_path);\n@@ -93,7 +98,8 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n         assert!(meta.path.starts_with(&source_root_prefix));\n \n         if let Some(krate) = meta.krate {\n-            let crate_id = crate_graph.add_crate_root(file_id, meta.edition, meta.cfg);\n+            let crate_id =\n+                crate_graph.add_crate_root(file_id, meta.edition, meta.cfg, Env::default());\n             let prev = crates.insert(krate.clone(), crate_id);\n             assert!(prev.is_none());\n             for dep in meta.deps {\n@@ -123,7 +129,12 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n \n     if crates.is_empty() {\n         let crate_root = default_crate_root.unwrap();\n-        crate_graph.add_crate_root(crate_root, Edition::Edition2018, CfgOptions::default());\n+        crate_graph.add_crate_root(\n+            crate_root,\n+            Edition::Edition2018,\n+            CfgOptions::default(),\n+            Env::default(),\n+        );\n     } else {\n         for (from, to) in crate_deps {\n             let from_id = crates[&from];"}, {"sha": "b6d851776129c2f1ade35a03fee43af02c689022", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 81, "deletions": 57, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -6,14 +6,14 @@\n //! actual IO. See `vfs` and `project_model` in the `ra_lsp_server` crate for how\n //! actual IO is done and lowered to input.\n \n-use rustc_hash::FxHashMap;\n+use std::{fmt, str::FromStr};\n \n use ra_cfg::CfgOptions;\n use ra_syntax::SmolStr;\n+use rustc_hash::FxHashMap;\n use rustc_hash::FxHashSet;\n \n use crate::{RelativePath, RelativePathBuf};\n-use std::str::FromStr;\n \n /// `FileId` is an integer which uniquely identifies a file. File paths are\n /// messy and system-dependent, so most of the code should work directly with\n@@ -80,56 +80,27 @@ pub struct CrateGraph {\n     arena: FxHashMap<CrateId, CrateData>,\n }\n \n-#[derive(Debug)]\n-pub struct CyclicDependencies;\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct CrateId(pub u32);\n \n-impl CrateId {\n-    pub fn shift(self, amount: u32) -> CrateId {\n-        CrateId(self.0 + amount)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum Edition {\n-    Edition2018,\n-    Edition2015,\n-}\n-\n-#[derive(Debug)]\n-pub struct ParseEditionError {\n-    pub msg: String,\n-}\n-\n-impl FromStr for Edition {\n-    type Err = ParseEditionError;\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"2015\" => Ok(Edition::Edition2015),\n-            \"2018\" => Ok(Edition::Edition2018),\n-            _ => Err(ParseEditionError { msg: format!(\"unknown edition: {}\", s) }),\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n struct CrateData {\n     file_id: FileId,\n     edition: Edition,\n-    dependencies: Vec<Dependency>,\n     cfg_options: CfgOptions,\n+    env: Env,\n+    dependencies: Vec<Dependency>,\n }\n \n-impl CrateData {\n-    fn new(file_id: FileId, edition: Edition, cfg_options: CfgOptions) -> CrateData {\n-        CrateData { file_id, edition, dependencies: Vec::new(), cfg_options }\n-    }\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum Edition {\n+    Edition2018,\n+    Edition2015,\n+}\n \n-    fn add_dep(&mut self, name: SmolStr, crate_id: CrateId) {\n-        self.dependencies.push(Dependency { name, crate_id })\n-    }\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub struct Env {\n+    entries: FxHashMap<String, String>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -138,21 +109,17 @@ pub struct Dependency {\n     pub name: SmolStr,\n }\n \n-impl Dependency {\n-    pub fn crate_id(&self) -> CrateId {\n-        self.crate_id\n-    }\n-}\n-\n impl CrateGraph {\n     pub fn add_crate_root(\n         &mut self,\n         file_id: FileId,\n         edition: Edition,\n         cfg_options: CfgOptions,\n+        env: Env,\n     ) -> CrateId {\n+        let data = CrateData::new(file_id, edition, cfg_options, env);\n         let crate_id = CrateId(self.arena.len() as u32);\n-        let prev = self.arena.insert(crate_id, CrateData::new(file_id, edition, cfg_options));\n+        let prev = self.arena.insert(crate_id, data);\n         assert!(prev.is_none());\n         crate_id\n     }\n@@ -166,9 +133,9 @@ impl CrateGraph {\n         from: CrateId,\n         name: SmolStr,\n         to: CrateId,\n-    ) -> Result<(), CyclicDependencies> {\n+    ) -> Result<(), CyclicDependenciesError> {\n         if self.dfs_find(from, to, &mut FxHashSet::default()) {\n-            return Err(CyclicDependencies);\n+            return Err(CyclicDependenciesError);\n         }\n         self.arena.get_mut(&from).unwrap().add_dep(name, to);\n         Ok(())\n@@ -239,16 +206,70 @@ impl CrateGraph {\n     }\n }\n \n+impl CrateId {\n+    pub fn shift(self, amount: u32) -> CrateId {\n+        CrateId(self.0 + amount)\n+    }\n+}\n+\n+impl CrateData {\n+    fn new(file_id: FileId, edition: Edition, cfg_options: CfgOptions, env: Env) -> CrateData {\n+        CrateData { file_id, edition, dependencies: Vec::new(), cfg_options, env }\n+    }\n+\n+    fn add_dep(&mut self, name: SmolStr, crate_id: CrateId) {\n+        self.dependencies.push(Dependency { name, crate_id })\n+    }\n+}\n+\n+impl FromStr for Edition {\n+    type Err = ParseEditionError;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        let res = match s {\n+            \"2015\" => Edition::Edition2015,\n+            \"2018\" => Edition::Edition2018,\n+            _ => Err(ParseEditionError { invalid_input: s.to_string() })?,\n+        };\n+        Ok(res)\n+    }\n+}\n+\n+impl Dependency {\n+    pub fn crate_id(&self) -> CrateId {\n+        self.crate_id\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ParseEditionError {\n+    invalid_input: String,\n+}\n+\n+impl fmt::Display for ParseEditionError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"invalid edition: {:?}\", self.invalid_input)\n+    }\n+}\n+\n+impl std::error::Error for ParseEditionError {}\n+\n+#[derive(Debug)]\n+pub struct CyclicDependenciesError;\n+\n #[cfg(test)]\n mod tests {\n-    use super::{CfgOptions, CrateGraph, Edition::Edition2018, FileId, SmolStr};\n+    use super::{CfgOptions, CrateGraph, Edition::Edition2018, Env, FileId, SmolStr};\n \n     #[test]\n     fn it_should_panic_because_of_cycle_dependencies() {\n         let mut graph = CrateGraph::default();\n-        let crate1 = graph.add_crate_root(FileId(1u32), Edition2018, CfgOptions::default());\n-        let crate2 = graph.add_crate_root(FileId(2u32), Edition2018, CfgOptions::default());\n-        let crate3 = graph.add_crate_root(FileId(3u32), Edition2018, CfgOptions::default());\n+        let crate1 =\n+            graph.add_crate_root(FileId(1u32), Edition2018, CfgOptions::default(), Env::default());\n+        let crate2 =\n+            graph.add_crate_root(FileId(2u32), Edition2018, CfgOptions::default(), Env::default());\n+        let crate3 =\n+            graph.add_crate_root(FileId(3u32), Edition2018, CfgOptions::default(), Env::default());\n         assert!(graph.add_dep(crate1, SmolStr::new(\"crate2\"), crate2).is_ok());\n         assert!(graph.add_dep(crate2, SmolStr::new(\"crate3\"), crate3).is_ok());\n         assert!(graph.add_dep(crate3, SmolStr::new(\"crate1\"), crate1).is_err());\n@@ -257,9 +278,12 @@ mod tests {\n     #[test]\n     fn it_works() {\n         let mut graph = CrateGraph::default();\n-        let crate1 = graph.add_crate_root(FileId(1u32), Edition2018, CfgOptions::default());\n-        let crate2 = graph.add_crate_root(FileId(2u32), Edition2018, CfgOptions::default());\n-        let crate3 = graph.add_crate_root(FileId(3u32), Edition2018, CfgOptions::default());\n+        let crate1 =\n+            graph.add_crate_root(FileId(1u32), Edition2018, CfgOptions::default(), Env::default());\n+        let crate2 =\n+            graph.add_crate_root(FileId(2u32), Edition2018, CfgOptions::default(), Env::default());\n+        let crate3 =\n+            graph.add_crate_root(FileId(3u32), Edition2018, CfgOptions::default(), Env::default());\n         assert!(graph.add_dep(crate1, SmolStr::new(\"crate2\"), crate2).is_ok());\n         assert!(graph.add_dep(crate2, SmolStr::new(\"crate3\"), crate3).is_ok());\n     }"}, {"sha": "e8852531bfb075e4b7f29f0138e40baf208990fd", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -10,11 +10,25 @@ use ra_syntax::{ast, Parse, SourceFile, TextRange, TextUnit};\n \n pub use crate::{\n     cancellation::Canceled,\n-    input::{CrateGraph, CrateId, Dependency, Edition, FileId, SourceRoot, SourceRootId},\n+    input::{CrateGraph, CrateId, Dependency, Edition, Env, FileId, SourceRoot, SourceRootId},\n };\n pub use relative_path::{RelativePath, RelativePathBuf};\n pub use salsa;\n \n+#[macro_export]\n+macro_rules! impl_intern_key {\n+    ($name:ident) => {\n+        impl $crate::salsa::InternKey for $name {\n+            fn from_intern_id(v: $crate::salsa::InternId) -> Self {\n+                $name(v)\n+            }\n+            fn as_intern_id(&self) -> $crate::salsa::InternId {\n+                self.0\n+            }\n+        }\n+    };\n+}\n+\n pub trait CheckCanceled {\n     /// Aborts current query if there are pending changes.\n     ///"}, {"sha": "3f44a50c4d1f4abc663c0f57ff31756a703ea384", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 195, "deletions": 231, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,38 +1,33 @@\n //! FIXME: write short doc here\n \n pub(crate) mod src;\n-pub(crate) mod docs;\n-pub(crate) mod attrs;\n \n use std::sync::Arc;\n \n use hir_def::{\n     adt::VariantData,\n-    body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n-    nameres::per_ns::PerNs,\n+    docs::Documentation,\n+    per_ns::PerNs,\n     resolver::{HasResolver, TypeNs},\n-    traits::TraitData,\n-    type_ref::{Mutability, TypeRef},\n-    ContainerId, CrateModuleId, HasModule, ImplId, LocalEnumVariantId, LocalStructFieldId, Lookup,\n-    ModuleId, UnionId,\n+    type_ref::TypeRef,\n+    AstItemDef, ConstId, ContainerId, EnumId, FunctionId, HasModule, ImplId, LocalEnumVariantId,\n+    LocalImportId, LocalModuleId, LocalStructFieldId, Lookup, ModuleId, StaticId, StructId,\n+    TraitId, TypeAliasId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n     name::{self, AsName},\n+    AstId, MacroDefId,\n };\n-use ra_db::{CrateId, Edition};\n-use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n+use ra_db::{CrateId, Edition, FileId, FilePosition};\n+use ra_syntax::{ast, AstNode, SyntaxNode};\n \n use crate::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n+    db::{DefDatabase, HirDatabase},\n     expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n-    ids::{\n-        AstItemDef, ConstId, EnumId, FunctionId, MacroDefId, StaticId, StructId, TraitId,\n-        TypeAliasId,\n-    },\n     ty::{InferenceResult, Namespace, TraitRef},\n-    Either, HasSource, ImportId, Name, Source, Ty,\n+    Either, Name, Source, Ty,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -66,7 +61,7 @@ impl Crate {\n     }\n \n     pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n-        let module_id = db.crate_def_map(self.crate_id).root();\n+        let module_id = db.crate_def_map(self.crate_id).root;\n         Some(Module::new(self, module_id))\n     }\n \n@@ -80,6 +75,64 @@ impl Crate {\n     }\n }\n \n+pub enum ModuleSource {\n+    SourceFile(ast::SourceFile),\n+    Module(ast::Module),\n+}\n+\n+impl ModuleSource {\n+    pub fn new(\n+        db: &impl DefDatabase,\n+        file_id: Option<FileId>,\n+        decl_id: Option<AstId<ast::Module>>,\n+    ) -> ModuleSource {\n+        match (file_id, decl_id) {\n+            (Some(file_id), _) => {\n+                let source_file = db.parse(file_id).tree();\n+                ModuleSource::SourceFile(source_file)\n+            }\n+            (None, Some(item_id)) => {\n+                let module = item_id.to_node(db);\n+                assert!(module.item_list().is_some(), \"expected inline module\");\n+                ModuleSource::Module(module)\n+            }\n+            (None, None) => panic!(),\n+        }\n+    }\n+\n+    // FIXME: this methods do not belong here\n+    pub fn from_position(db: &impl DefDatabase, position: FilePosition) -> ModuleSource {\n+        let parse = db.parse(position.file_id);\n+        match &ra_syntax::algo::find_node_at_offset::<ast::Module>(\n+            parse.tree().syntax(),\n+            position.offset,\n+        ) {\n+            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n+            _ => {\n+                let source_file = parse.tree();\n+                ModuleSource::SourceFile(source_file)\n+            }\n+        }\n+    }\n+\n+    pub fn from_child_node(db: &impl DefDatabase, child: Source<&SyntaxNode>) -> ModuleSource {\n+        if let Some(m) =\n+            child.value.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi())\n+        {\n+            ModuleSource::Module(m)\n+        } else {\n+            let file_id = child.file_id.original_file(db);\n+            let source_file = db.parse(file_id).tree();\n+            ModuleSource::SourceFile(source_file)\n+        }\n+    }\n+\n+    pub fn from_file_id(db: &impl DefDatabase, file_id: FileId) -> ModuleSource {\n+        let source_file = db.parse(file_id).tree();\n+        ModuleSource::SourceFile(source_file)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Module {\n     pub(crate) id: ModuleId,\n@@ -111,10 +164,10 @@ impl_froms!(\n     BuiltinType\n );\n \n-pub use hir_def::ModuleSource;\n+pub use hir_def::attr::Attrs;\n \n impl Module {\n-    pub(crate) fn new(krate: Crate, crate_module_id: CrateModuleId) -> Module {\n+    pub(crate) fn new(krate: Crate, crate_module_id: LocalModuleId) -> Module {\n         Module { id: ModuleId { krate: krate.crate_id, module_id: crate_module_id } }\n     }\n \n@@ -131,17 +184,6 @@ impl Module {\n         })\n     }\n \n-    /// Returns the syntax of the last path segment corresponding to this import\n-    pub fn import_source(\n-        self,\n-        db: &impl HirDatabase,\n-        import: ImportId,\n-    ) -> Either<ast::UseTree, ast::ExternCrateItem> {\n-        let src = self.definition_source(db);\n-        let (_, source_map) = db.raw_items_with_source_map(src.file_id);\n-        source_map.get(&src.value, import)\n-    }\n-\n     /// Returns the crate this module is part of.\n     pub fn krate(self) -> Crate {\n         Crate { crate_id: self.id.krate }\n@@ -152,7 +194,7 @@ impl Module {\n     /// in the module tree of any target in `Cargo.toml`.\n     pub fn crate_root(self, db: &impl DefDatabase) -> Module {\n         let def_map = db.crate_def_map(self.id.krate);\n-        self.with_module_id(def_map.root())\n+        self.with_module_id(def_map.root)\n     }\n \n     /// Finds a child module with the specified name.\n@@ -191,11 +233,13 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(self, db: &impl HirDatabase) -> Vec<(Name, ScopeDef, Option<ImportId>)> {\n+    pub fn scope(self, db: &impl HirDatabase) -> Vec<(Name, ScopeDef, Option<Import>)> {\n         db.crate_def_map(self.id.krate)[self.id.module_id]\n             .scope\n             .entries()\n-            .map(|(name, res)| (name.clone(), res.def.into(), res.import))\n+            .map(|(name, res)| {\n+                (name.clone(), res.def.into(), res.import.map(|id| Import { parent: self, id }))\n+            })\n             .collect()\n     }\n \n@@ -233,11 +277,16 @@ impl Module {\n         def_map[self.id.module_id].impls.iter().copied().map(ImplBlock::from).collect()\n     }\n \n-    fn with_module_id(self, module_id: CrateModuleId) -> Module {\n+    fn with_module_id(self, module_id: LocalModuleId) -> Module {\n         Module::new(self.krate(), module_id)\n     }\n }\n \n+pub struct Import {\n+    pub(crate) parent: Module,\n+    pub(crate) id: LocalImportId,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StructField {\n     pub(crate) parent: VariantDef,\n@@ -252,11 +301,11 @@ pub enum FieldSource {\n \n impl StructField {\n     pub fn name(&self, db: &impl HirDatabase) -> Name {\n-        self.parent.variant_data(db).fields().unwrap()[self.id].name.clone()\n+        self.parent.variant_data(db).fields()[self.id].name.clone()\n     }\n \n     pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_field(*self)\n+        db.field_types(self.parent.into())[self.id].clone()\n     }\n \n     pub fn parent_def(&self, _db: &impl HirDatabase) -> VariantDef {\n@@ -286,8 +335,7 @@ impl Struct {\n         db.struct_data(self.id.into())\n             .variant_data\n             .fields()\n-            .into_iter()\n-            .flat_map(|it| it.iter())\n+            .iter()\n             .map(|(id, _)| StructField { parent: self.into(), id })\n             .collect()\n     }\n@@ -296,8 +344,7 @@ impl Struct {\n         db.struct_data(self.id.into())\n             .variant_data\n             .fields()\n-            .into_iter()\n-            .flat_map(|it| it.iter())\n+            .iter()\n             .find(|(_id, data)| data.name == *name)\n             .map(|(id, _)| StructField { parent: self.into(), id })\n     }\n@@ -394,17 +441,15 @@ impl EnumVariant {\n     pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n         self.variant_data(db)\n             .fields()\n-            .into_iter()\n-            .flat_map(|it| it.iter())\n+            .iter()\n             .map(|(id, _)| StructField { parent: self.into(), id })\n             .collect()\n     }\n \n     pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n         self.variant_data(db)\n             .fields()\n-            .into_iter()\n-            .flat_map(|it| it.iter())\n+            .iter()\n             .find(|(_id, data)| data.name == *name)\n             .map(|(id, _)| StructField { parent: self.into(), id })\n     }\n@@ -460,7 +505,7 @@ impl VariantDef {\n         }\n     }\n \n-    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n+    pub(crate) fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n         match self {\n             VariantDef::Struct(it) => it.field(db, name),\n             VariantDef::EnumVariant(it) => it.field(db, name),\n@@ -510,128 +555,11 @@ impl DefWithBody {\n     }\n }\n \n-pub trait HasBody: Copy {\n-    fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult>;\n-    fn body(self, db: &impl HirDatabase) -> Arc<Body>;\n-    fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap>;\n-    fn expr_scopes(self, db: &impl HirDatabase) -> Arc<ExprScopes>;\n-}\n-\n-impl<T> HasBody for T\n-where\n-    T: Into<DefWithBody> + Copy + HasSource,\n-{\n-    fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.into())\n-    }\n-\n-    fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n-        self.into().body(db)\n-    }\n-\n-    fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        self.into().body_source_map(db)\n-    }\n-\n-    fn expr_scopes(self, db: &impl HirDatabase) -> Arc<ExprScopes> {\n-        self.into().expr_scopes(db)\n-    }\n-}\n-\n-impl HasBody for DefWithBody {\n-    fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self)\n-    }\n-\n-    fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body(self.into())\n-    }\n-\n-    fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map(self.into()).1\n-    }\n-\n-    fn expr_scopes(self, db: &impl HirDatabase) -> Arc<ExprScopes> {\n-        db.expr_scopes(self.into())\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Function {\n     pub(crate) id: FunctionId,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct FnData {\n-    pub(crate) name: Name,\n-    pub(crate) params: Vec<TypeRef>,\n-    pub(crate) ret_type: TypeRef,\n-    /// True if the first param is `self`. This is relevant to decide whether this\n-    /// can be called as a method.\n-    pub(crate) has_self_param: bool,\n-}\n-\n-impl FnData {\n-    pub(crate) fn fn_data_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        func: Function,\n-    ) -> Arc<FnData> {\n-        let src = func.source(db);\n-        let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n-        let mut params = Vec::new();\n-        let mut has_self_param = false;\n-        if let Some(param_list) = src.value.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n-                    TypeRef::from_ast(type_ref)\n-                } else {\n-                    let self_type = TypeRef::Path(name::SELF_TYPE.into());\n-                    match self_param.kind() {\n-                        ast::SelfParamKind::Owned => self_type,\n-                        ast::SelfParamKind::Ref => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n-                        }\n-                        ast::SelfParamKind::MutRef => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n-                        }\n-                    }\n-                };\n-                params.push(self_type);\n-                has_self_param = true;\n-            }\n-            for param in param_list.params() {\n-                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n-                params.push(type_ref);\n-            }\n-        }\n-        let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n-            TypeRef::from_ast(type_ref)\n-        } else {\n-            TypeRef::unit()\n-        };\n-\n-        let sig = FnData { name, params, ret_type, has_self_param };\n-        Arc::new(sig)\n-    }\n-    pub fn name(&self) -> &Name {\n-        &self.name\n-    }\n-\n-    pub fn params(&self) -> &[TypeRef] {\n-        &self.params\n-    }\n-\n-    pub fn ret_type(&self) -> &TypeRef {\n-        &self.ret_type\n-    }\n-\n-    /// True if the first arg is `self`. This is relevant to decide whether this\n-    /// can be called as a method.\n-    pub fn has_self_param(&self) -> bool {\n-        self.has_self_param\n-    }\n-}\n-\n impl Function {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.lookup(db).module(db).into()\n@@ -642,10 +570,18 @@ impl Function {\n     }\n \n     pub fn name(self, db: &impl HirDatabase) -> Name {\n-        self.data(db).name.clone()\n+        db.function_data(self.id).name.clone()\n+    }\n+\n+    pub fn has_self_param(self, db: &impl HirDatabase) -> bool {\n+        db.function_data(self.id).has_self_param\n+    }\n+\n+    pub fn params(self, db: &impl HirDatabase) -> Vec<TypeRef> {\n+        db.function_data(self.id).params.clone()\n     }\n \n-    pub(crate) fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n+    pub fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n         db.body_with_source_map(self.id.into()).1\n     }\n \n@@ -657,10 +593,6 @@ impl Function {\n         db.type_for_def(self.into(), Namespace::Values)\n     }\n \n-    pub fn data(self, db: &impl HirDatabase) -> Arc<FnData> {\n-        db.fn_data(self)\n-    }\n-\n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer(self.into())\n     }\n@@ -711,12 +643,8 @@ impl Const {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn data(self, db: &impl HirDatabase) -> Arc<ConstData> {\n-        db.const_data(self)\n-    }\n-\n     pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n-        self.data(db).name().cloned()\n+        db.const_data(self.id).name.clone()\n     }\n \n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n@@ -748,63 +676,20 @@ impl Const {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ConstData {\n-    pub(crate) name: Option<Name>,\n-    pub(crate) type_ref: TypeRef,\n-}\n-\n-impl ConstData {\n-    pub fn name(&self) -> Option<&Name> {\n-        self.name.as_ref()\n-    }\n-\n-    pub fn type_ref(&self) -> &TypeRef {\n-        &self.type_ref\n-    }\n-\n-    pub(crate) fn const_data_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        konst: Const,\n-    ) -> Arc<ConstData> {\n-        let node = konst.source(db).value;\n-        const_data_for(&node)\n-    }\n-\n-    pub(crate) fn static_data_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        konst: Static,\n-    ) -> Arc<ConstData> {\n-        let node = konst.source(db).value;\n-        const_data_for(&node)\n-    }\n-}\n-\n-fn const_data_for<N: NameOwner + TypeAscriptionOwner>(node: &N) -> Arc<ConstData> {\n-    let name = node.name().map(|n| n.as_name());\n-    let type_ref = TypeRef::from_ast_opt(node.ascribed_type());\n-    let sig = ConstData { name, type_ref };\n-    Arc::new(sig)\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Static {\n     pub(crate) id: StaticId,\n }\n \n impl Static {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        Module { id: self.id.lookup(db).module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn data(self, db: &impl HirDatabase) -> Arc<ConstData> {\n-        db.static_data(self)\n-    }\n-\n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer(self.into())\n     }\n@@ -821,11 +706,11 @@ impl Trait {\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        self.trait_data(db).name.clone()\n+        db.trait_data(self.id).name.clone()\n     }\n \n     pub fn items(self, db: &impl DefDatabase) -> Vec<AssocItem> {\n-        self.trait_data(db).items.iter().map(|it| (*it).into()).collect()\n+        db.trait_data(self.id).items.iter().map(|it| (*it).into()).collect()\n     }\n \n     fn direct_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n@@ -871,7 +756,7 @@ impl Trait {\n     }\n \n     pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n-        let trait_data = self.trait_data(db);\n+        let trait_data = db.trait_data(self.id);\n         let res =\n             trait_data.associated_types().map(TypeAlias::from).find(|t| &t.name(db) == name)?;\n         Some(res)\n@@ -885,16 +770,12 @@ impl Trait {\n         self.all_super_traits(db).into_iter().find_map(|t| t.associated_type_by_name(db, name))\n     }\n \n-    pub(crate) fn trait_data(self, db: &impl DefDatabase) -> Arc<TraitData> {\n-        db.trait_data(self.id)\n-    }\n-\n     pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {\n         TraitRef::for_trait(db, self)\n     }\n \n     pub fn is_auto(self, db: &impl DefDatabase) -> bool {\n-        self.trait_data(db).auto\n+        db.trait_data(self.id).auto\n     }\n }\n \n@@ -937,15 +818,15 @@ impl TypeAlias {\n     }\n \n     pub fn type_ref(self, db: &impl DefDatabase) -> Option<TypeRef> {\n-        db.type_alias_data(self).type_ref.clone()\n+        db.type_alias_data(self.id).type_ref.clone()\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n         db.type_for_def(self.into(), Namespace::Types)\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Name {\n-        db.type_alias_data(self).name.clone()\n+        db.type_alias_data(self.id).name.clone()\n     }\n }\n \n@@ -1034,7 +915,7 @@ pub struct Local {\n \n impl Local {\n     pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n-        let body = self.parent.body(db);\n+        let body = db.body(self.parent.into());\n         match &body[self.pat_id] {\n             Pat::Bind { name, .. } => Some(name.clone()),\n             _ => None,\n@@ -1046,7 +927,7 @@ impl Local {\n     }\n \n     pub fn is_mut(self, db: &impl HirDatabase) -> bool {\n-        let body = self.parent.body(db);\n+        let body = db.body(self.parent.into());\n         match &body[self.pat_id] {\n             Pat::Bind { mode, .. } => match mode {\n                 BindingAnnotation::Mutable | BindingAnnotation::RefMut => true,\n@@ -1070,7 +951,7 @@ impl Local {\n     }\n \n     pub fn source(self, db: &impl HirDatabase) -> Source<Either<ast::BindPat, ast::SelfParam>> {\n-        let source_map = self.parent.body_source_map(db);\n+        let (_body, source_map) = db.body_with_source_map(self.parent.into());\n         let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n         let root = src.file_syntax(db);\n         src.map(|ast| ast.map(|it| it.cast().unwrap().to_node(&root), |it| it.to_node(&root)))\n@@ -1088,6 +969,41 @@ pub struct ImplBlock {\n     pub(crate) id: ImplId,\n }\n \n+impl ImplBlock {\n+    pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n+        db.impl_data(self.id).target_trait.clone()\n+    }\n+\n+    pub fn target_type(&self, db: &impl DefDatabase) -> TypeRef {\n+        db.impl_data(self.id).target_type.clone()\n+    }\n+\n+    pub fn target_ty(&self, db: &impl HirDatabase) -> Ty {\n+        Ty::from_hir(db, &self.id.resolver(db), &self.target_type(db))\n+    }\n+\n+    pub fn target_trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n+        let target_ty = self.target_ty(db);\n+        TraitRef::from_hir(db, &self.id.resolver(db), &self.target_trait(db)?, Some(target_ty))\n+    }\n+\n+    pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {\n+        db.impl_data(self.id).items.iter().map(|it| (*it).into()).collect()\n+    }\n+\n+    pub fn is_negative(&self, db: &impl DefDatabase) -> bool {\n+        db.impl_data(self.id).is_negative\n+    }\n+\n+    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+        self.id.module(db).into()\n+    }\n+\n+    pub fn krate(&self, db: &impl DefDatabase) -> Crate {\n+        Crate { crate_id: self.module(db).id.krate }\n+    }\n+}\n+\n /// For IDE only\n pub enum ScopeDef {\n     ModuleDef(ModuleDef),\n@@ -1105,8 +1021,56 @@ impl From<PerNs> for ScopeDef {\n             .or_else(|| def.take_values())\n             .map(|module_def_id| ScopeDef::ModuleDef(module_def_id.into()))\n             .or_else(|| {\n-                def.get_macros().map(|macro_def_id| ScopeDef::MacroDef(macro_def_id.into()))\n+                def.take_macros().map(|macro_def_id| ScopeDef::MacroDef(macro_def_id.into()))\n             })\n             .unwrap_or(ScopeDef::Unknown)\n     }\n }\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum AttrDef {\n+    Module(Module),\n+    StructField(StructField),\n+    Adt(Adt),\n+    Function(Function),\n+    EnumVariant(EnumVariant),\n+    Static(Static),\n+    Const(Const),\n+    Trait(Trait),\n+    TypeAlias(TypeAlias),\n+    MacroDef(MacroDef),\n+}\n+\n+impl_froms!(\n+    AttrDef: Module,\n+    StructField,\n+    Adt(Struct, Enum, Union),\n+    EnumVariant,\n+    Static,\n+    Const,\n+    Function,\n+    Trait,\n+    TypeAlias,\n+    MacroDef\n+);\n+\n+pub trait HasAttrs {\n+    fn attrs(self, db: &impl DefDatabase) -> Attrs;\n+}\n+\n+impl<T: Into<AttrDef>> HasAttrs for T {\n+    fn attrs(self, db: &impl DefDatabase) -> Attrs {\n+        let def: AttrDef = self.into();\n+        db.attrs(def.into())\n+    }\n+}\n+\n+pub trait Docs {\n+    fn docs(&self, db: &impl HirDatabase) -> Option<Documentation>;\n+}\n+impl<T: Into<AttrDef> + Copy> Docs for T {\n+    fn docs(&self, db: &impl HirDatabase) -> Option<Documentation> {\n+        let def: AttrDef = (*self).into();\n+        db.documentation(def.into())\n+    }\n+}"}, {"sha": "9e304217c53d36082843e87401e6ffc7fc1f87c4", "filename": "crates/ra_hir/src/code_model/attrs.rs", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fattrs.rs?ref=eb7363d167c7a9f7c73cb950b621eb1dce493318", "patch": "@@ -1,92 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use crate::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n-    Adt, Const, Enum, EnumVariant, FieldSource, Function, HasSource, MacroDef, Module, Static,\n-    Struct, StructField, Trait, TypeAlias, Union,\n-};\n-use hir_def::attr::Attr;\n-use hir_expand::hygiene::Hygiene;\n-use ra_syntax::ast;\n-use std::sync::Arc;\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum AttrDef {\n-    Module(Module),\n-    StructField(StructField),\n-    Adt(Adt),\n-    Function(Function),\n-    EnumVariant(EnumVariant),\n-    Static(Static),\n-    Const(Const),\n-    Trait(Trait),\n-    TypeAlias(TypeAlias),\n-    MacroDef(MacroDef),\n-}\n-\n-impl_froms!(\n-    AttrDef: Module,\n-    StructField,\n-    Adt(Struct, Enum, Union),\n-    EnumVariant,\n-    Static,\n-    Const,\n-    Function,\n-    Trait,\n-    TypeAlias,\n-    MacroDef\n-);\n-\n-pub trait Attrs {\n-    fn attrs(&self, db: &impl HirDatabase) -> Option<Arc<[Attr]>>;\n-}\n-\n-pub(crate) fn attributes_query(\n-    db: &(impl DefDatabase + AstDatabase),\n-    def: AttrDef,\n-) -> Option<Arc<[Attr]>> {\n-    match def {\n-        AttrDef::Module(it) => {\n-            let src = it.declaration_source(db)?;\n-            let hygiene = Hygiene::new(db, src.file_id);\n-            Attr::from_attrs_owner(&src.value, &hygiene)\n-        }\n-        AttrDef::StructField(it) => match it.source(db).value {\n-            FieldSource::Named(named) => {\n-                let src = it.source(db);\n-                let hygiene = Hygiene::new(db, src.file_id);\n-                Attr::from_attrs_owner(&named, &hygiene)\n-            }\n-            FieldSource::Pos(..) => None,\n-        },\n-        AttrDef::Adt(it) => match it {\n-            Adt::Struct(it) => attrs_from_ast(it, db),\n-            Adt::Enum(it) => attrs_from_ast(it, db),\n-            Adt::Union(it) => attrs_from_ast(it, db),\n-        },\n-        AttrDef::EnumVariant(it) => attrs_from_ast(it, db),\n-        AttrDef::Static(it) => attrs_from_ast(it, db),\n-        AttrDef::Const(it) => attrs_from_ast(it, db),\n-        AttrDef::Function(it) => attrs_from_ast(it, db),\n-        AttrDef::Trait(it) => attrs_from_ast(it, db),\n-        AttrDef::TypeAlias(it) => attrs_from_ast(it, db),\n-        AttrDef::MacroDef(it) => attrs_from_ast(it, db),\n-    }\n-}\n-\n-fn attrs_from_ast<T, D>(node: T, db: &D) -> Option<Arc<[Attr]>>\n-where\n-    T: HasSource,\n-    T::Ast: ast::AttrsOwner,\n-    D: DefDatabase + AstDatabase,\n-{\n-    let src = node.source(db);\n-    let hygiene = Hygiene::new(db, src.file_id);\n-    Attr::from_attrs_owner(&src.value, &hygiene)\n-}\n-\n-impl<T: Into<AttrDef> + Copy> Attrs for T {\n-    fn attrs(&self, db: &impl HirDatabase) -> Option<Arc<[Attr]>> {\n-        db.attrs((*self).into())\n-    }\n-}"}, {"sha": "e40efef34aeb55fef5bd03fc82b3e77a0251068c", "filename": "crates/ra_hir/src/code_model/docs.rs", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs?ref=eb7363d167c7a9f7c73cb950b621eb1dce493318", "patch": "@@ -1,97 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use std::sync::Arc;\n-\n-use ra_syntax::ast;\n-\n-use crate::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n-    Adt, Const, Enum, EnumVariant, FieldSource, Function, HasSource, MacroDef, Module, Static,\n-    Struct, StructField, Trait, TypeAlias, Union,\n-};\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum DocDef {\n-    Module(Module),\n-    StructField(StructField),\n-    Adt(Adt),\n-    EnumVariant(EnumVariant),\n-    Static(Static),\n-    Const(Const),\n-    Function(Function),\n-    Trait(Trait),\n-    TypeAlias(TypeAlias),\n-    MacroDef(MacroDef),\n-}\n-\n-impl_froms!(\n-    DocDef: Module,\n-    StructField,\n-    Adt(Struct, Enum, Union),\n-    EnumVariant,\n-    Static,\n-    Const,\n-    Function,\n-    Trait,\n-    TypeAlias,\n-    MacroDef\n-);\n-\n-/// Holds documentation\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct Documentation(Arc<str>);\n-\n-impl Documentation {\n-    fn new(s: &str) -> Documentation {\n-        Documentation(s.into())\n-    }\n-\n-    pub fn as_str(&self) -> &str {\n-        &*self.0\n-    }\n-}\n-\n-impl Into<String> for Documentation {\n-    fn into(self) -> String {\n-        self.as_str().to_owned()\n-    }\n-}\n-\n-pub trait Docs {\n-    fn docs(&self, db: &impl HirDatabase) -> Option<Documentation>;\n-}\n-\n-pub(crate) fn docs_from_ast(node: &impl ast::DocCommentsOwner) -> Option<Documentation> {\n-    node.doc_comment_text().map(|it| Documentation::new(&it))\n-}\n-\n-pub(crate) fn documentation_query(\n-    db: &(impl DefDatabase + AstDatabase),\n-    def: DocDef,\n-) -> Option<Documentation> {\n-    match def {\n-        DocDef::Module(it) => docs_from_ast(&it.declaration_source(db)?.value),\n-        DocDef::StructField(it) => match it.source(db).value {\n-            FieldSource::Named(named) => docs_from_ast(&named),\n-            FieldSource::Pos(..) => None,\n-        },\n-        DocDef::Adt(it) => match it {\n-            Adt::Struct(it) => docs_from_ast(&it.source(db).value),\n-            Adt::Enum(it) => docs_from_ast(&it.source(db).value),\n-            Adt::Union(it) => docs_from_ast(&it.source(db).value),\n-        },\n-        DocDef::EnumVariant(it) => docs_from_ast(&it.source(db).value),\n-        DocDef::Static(it) => docs_from_ast(&it.source(db).value),\n-        DocDef::Const(it) => docs_from_ast(&it.source(db).value),\n-        DocDef::Function(it) => docs_from_ast(&it.source(db).value),\n-        DocDef::Trait(it) => docs_from_ast(&it.source(db).value),\n-        DocDef::TypeAlias(it) => docs_from_ast(&it.source(db).value),\n-        DocDef::MacroDef(it) => docs_from_ast(&it.source(db).value),\n-    }\n-}\n-\n-impl<T: Into<DocDef> + Copy> Docs for T {\n-    fn docs(&self, db: &impl HirDatabase) -> Option<Documentation> {\n-        db.documentation((*self).into())\n-    }\n-}"}, {"sha": "a4e317c203c69cc3cfacbf85abb00be49ea97a8b", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 47, "deletions": 91, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,172 +1,128 @@\n //! FIXME: write short doc here\n \n-use hir_def::{HasSource as _, Lookup};\n-use ra_syntax::ast::{self, AstNode};\n+use hir_def::{AstItemDef, HasChildSource, HasSource as _, Lookup, VariantId};\n+use hir_expand::either::Either;\n+use ra_syntax::ast;\n \n use crate::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n-    ids::AstItemDef,\n-    Const, Either, Enum, EnumVariant, FieldSource, Function, HasBody, HirFileId, MacroDef, Module,\n-    ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n+    db::DefDatabase, Const, Enum, EnumVariant, FieldSource, Function, ImplBlock, Import, MacroDef,\n+    Module, ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n };\n \n pub use hir_expand::Source;\n \n pub trait HasSource {\n     type Ast;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<Self::Ast>;\n+    fn source(self, db: &impl DefDatabase) -> Source<Self::Ast>;\n }\n \n /// NB: Module is !HasSource, because it has two source nodes at the same time:\n /// definition and declaration.\n impl Module {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n-    pub fn definition_source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ModuleSource> {\n+    pub fn definition_source(self, db: &impl DefDatabase) -> Source<ModuleSource> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        let decl_id = def_map[self.id.module_id].declaration;\n-        let file_id = def_map[self.id.module_id].definition;\n-        let value = ModuleSource::new(db, file_id, decl_id);\n-        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n-        Source { file_id, value }\n+        let src = def_map[self.id.module_id].definition_source(db);\n+        src.map(|it| match it {\n+            Either::A(it) => ModuleSource::SourceFile(it),\n+            Either::B(it) => ModuleSource::Module(it),\n+        })\n     }\n \n     /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n     /// `None` for the crate root.\n-    pub fn declaration_source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> Option<Source<ast::Module>> {\n+    pub fn declaration_source(self, db: &impl DefDatabase) -> Option<Source<ast::Module>> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        let decl = def_map[self.id.module_id].declaration?;\n-        let value = decl.to_node(db);\n-        Some(Source { file_id: decl.file_id(), value })\n+        def_map[self.id.module_id].declaration_source(db)\n     }\n }\n \n impl HasSource for StructField {\n     type Ast = FieldSource;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<FieldSource> {\n-        let var_data = self.parent.variant_data(db);\n-        let fields = var_data.fields().unwrap();\n-        let ss;\n-        let es;\n-        let (file_id, struct_kind) = match self.parent {\n-            VariantDef::Struct(s) => {\n-                ss = s.source(db);\n-                (ss.file_id, ss.value.kind())\n-            }\n-            VariantDef::EnumVariant(e) => {\n-                es = e.source(db);\n-                (es.file_id, es.value.kind())\n-            }\n-        };\n-\n-        let field_sources = match struct_kind {\n-            ast::StructKind::Tuple(fl) => fl.fields().map(|it| FieldSource::Pos(it)).collect(),\n-            ast::StructKind::Named(fl) => fl.fields().map(|it| FieldSource::Named(it)).collect(),\n-            ast::StructKind::Unit => Vec::new(),\n-        };\n-        let value = field_sources\n-            .into_iter()\n-            .zip(fields.iter())\n-            .find(|(_syntax, (id, _))| *id == self.id)\n-            .unwrap()\n-            .0;\n-        Source { file_id, value }\n+    fn source(self, db: &impl DefDatabase) -> Source<FieldSource> {\n+        let var = VariantId::from(self.parent);\n+        let src = var.child_source(db);\n+        src.map(|it| match it[self.id].clone() {\n+            Either::A(it) => FieldSource::Pos(it),\n+            Either::B(it) => FieldSource::Named(it),\n+        })\n     }\n }\n impl HasSource for Struct {\n     type Ast = ast::StructDef;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StructDef> {\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::StructDef> {\n         self.id.0.source(db)\n     }\n }\n impl HasSource for Union {\n     type Ast = ast::StructDef;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StructDef> {\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::StructDef> {\n         self.id.0.source(db)\n     }\n }\n impl HasSource for Enum {\n     type Ast = ast::EnumDef;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::EnumDef> {\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::EnumDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for EnumVariant {\n     type Ast = ast::EnumVariant;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::EnumVariant> {\n-        let enum_data = db.enum_data(self.parent.id);\n-        let src = self.parent.id.source(db);\n-        let value = src\n-            .value\n-            .variant_list()\n-            .into_iter()\n-            .flat_map(|it| it.variants())\n-            .zip(enum_data.variants.iter())\n-            .find(|(_syntax, (id, _))| *id == self.id)\n-            .unwrap()\n-            .0;\n-        Source { file_id: src.file_id, value }\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::EnumVariant> {\n+        self.parent.id.child_source(db).map(|map| map[self.id].clone())\n     }\n }\n impl HasSource for Function {\n     type Ast = ast::FnDef;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::FnDef> {\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::FnDef> {\n         self.id.lookup(db).source(db)\n     }\n }\n impl HasSource for Const {\n     type Ast = ast::ConstDef;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::ConstDef> {\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::ConstDef> {\n         self.id.lookup(db).source(db)\n     }\n }\n impl HasSource for Static {\n     type Ast = ast::StaticDef;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::StaticDef> {\n-        self.id.source(db)\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::StaticDef> {\n+        self.id.lookup(db).source(db)\n     }\n }\n impl HasSource for Trait {\n     type Ast = ast::TraitDef;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::TraitDef> {\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::TraitDef> {\n         self.id.source(db)\n     }\n }\n impl HasSource for TypeAlias {\n     type Ast = ast::TypeAliasDef;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::TypeAliasDef> {\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::TypeAliasDef> {\n         self.id.lookup(db).source(db)\n     }\n }\n impl HasSource for MacroDef {\n     type Ast = ast::MacroCall;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::MacroCall> {\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::MacroCall> {\n         Source { file_id: self.id.ast_id.file_id(), value: self.id.ast_id.to_node(db) }\n     }\n }\n-\n-pub trait HasBodySource: HasBody + HasSource\n-where\n-    Self::Ast: AstNode,\n-{\n-    fn expr_source(\n-        self,\n-        db: &impl HirDatabase,\n-        expr_id: crate::expr::ExprId,\n-    ) -> Option<Source<Either<ast::Expr, ast::RecordField>>> {\n-        let source_map = self.body_source_map(db);\n-        let source_ptr = source_map.expr_syntax(expr_id)?;\n-        let root = source_ptr.file_syntax(db);\n-        let source = source_ptr.map(|ast| ast.map(|it| it.to_node(&root), |it| it.to_node(&root)));\n-        Some(source)\n+impl HasSource for ImplBlock {\n+    type Ast = ast::ImplBlock;\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::ImplBlock> {\n+        self.id.source(db)\n     }\n }\n+impl HasSource for Import {\n+    type Ast = Either<ast::UseTree, ast::ExternCrateItem>;\n \n-impl<T> HasBodySource for T\n-where\n-    T: HasBody + HasSource,\n-    T::Ast: AstNode,\n-{\n+    /// Returns the syntax of the last path segment corresponding to this import\n+    fn source(self, db: &impl DefDatabase) -> Source<Self::Ast> {\n+        let src = self.parent.definition_source(db);\n+        let (_, source_map) = db.raw_items_with_source_map(src.file_id);\n+        let root = db.parse_or_expand(src.file_id).unwrap();\n+        let ptr = source_map.get(self.id);\n+        src.with_value(ptr.map(|it| it.to_node(&root), |it| it.to_node(&root)))\n+    }\n }"}, {"sha": "5084bbacf5370822be3af4ee8011729c6ab92856", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 21, "deletions": 51, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -2,79 +2,46 @@\n \n use std::sync::Arc;\n \n-use hir_def::attr::Attr;\n+use ra_arena::map::ArenaMap;\n use ra_db::salsa;\n-use ra_syntax::SmolStr;\n \n use crate::{\n-    debug::HirDebugDatabase,\n-    ids,\n-    lang_item::{LangItemTarget, LangItems},\n     ty::{\n         method_resolution::CrateImplBlocks,\n         traits::{AssocTyValue, Impl},\n         CallableDef, FnSig, GenericPredicate, InferenceResult, Namespace, Substs, Ty, TypableDef,\n         TypeCtor,\n     },\n-    type_alias::TypeAliasData,\n-    Const, ConstData, Crate, DefWithBody, FnData, Function, GenericDef, ImplBlock, Module, Static,\n-    StructField, Trait, TypeAlias,\n+    Crate, DefWithBody, GenericDef, ImplBlock, Trait,\n };\n \n-pub use hir_def::db::{\n-    BodyQuery, BodyWithSourceMapQuery, CrateDefMapQuery, DefDatabase2, DefDatabase2Storage,\n-    EnumDataQuery, ExprScopesQuery, GenericParamsQuery, ImplDataQuery, InternDatabase,\n-    InternDatabaseStorage, RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n-    TraitDataQuery,\n+pub use hir_def::{\n+    db::{\n+        BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQuery, CrateLangItemsQuery,\n+        DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery, ExprScopesQuery,\n+        FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternDatabase,\n+        InternDatabaseStorage, LangItemQuery, ModuleLangItemsQuery, RawItemsQuery,\n+        RawItemsWithSourceMapQuery, StaticDataQuery, StructDataQuery, TraitDataQuery,\n+        TypeAliasDataQuery,\n+    },\n+    LocalStructFieldId, VariantId,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n     ParseMacroQuery,\n };\n \n-// This database uses `AstDatabase` internally,\n-#[salsa::query_group(DefDatabaseStorage)]\n-#[salsa::requires(AstDatabase)]\n-pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n-    #[salsa::invoke(FnData::fn_data_query)]\n-    fn fn_data(&self, func: Function) -> Arc<FnData>;\n-\n-    #[salsa::invoke(TypeAliasData::type_alias_data_query)]\n-    fn type_alias_data(&self, typ: TypeAlias) -> Arc<TypeAliasData>;\n-\n-    #[salsa::invoke(ConstData::const_data_query)]\n-    fn const_data(&self, konst: Const) -> Arc<ConstData>;\n-\n-    #[salsa::invoke(ConstData::static_data_query)]\n-    fn static_data(&self, konst: Static) -> Arc<ConstData>;\n-\n-    #[salsa::invoke(LangItems::module_lang_items_query)]\n-    fn module_lang_items(&self, module: Module) -> Option<Arc<LangItems>>;\n-\n-    #[salsa::invoke(LangItems::crate_lang_items_query)]\n-    fn crate_lang_items(&self, krate: Crate) -> Arc<LangItems>;\n-\n-    #[salsa::invoke(LangItems::lang_item_query)]\n-    fn lang_item(&self, start_crate: Crate, item: SmolStr) -> Option<LangItemTarget>;\n-\n-    #[salsa::invoke(crate::code_model::docs::documentation_query)]\n-    fn documentation(&self, def: crate::DocDef) -> Option<crate::Documentation>;\n-\n-    #[salsa::invoke(crate::code_model::attrs::attributes_query)]\n-    fn attrs(&self, def: crate::AttrDef) -> Option<Arc<[Attr]>>;\n-}\n-\n #[salsa::query_group(HirDatabaseStorage)]\n #[salsa::requires(salsa::Database)]\n-pub trait HirDatabase: DefDatabase + AstDatabase {\n+pub trait HirDatabase: DefDatabase {\n     #[salsa::invoke(crate::ty::infer_query)]\n     fn infer(&self, def: DefWithBody) -> Arc<InferenceResult>;\n \n     #[salsa::invoke(crate::ty::type_for_def)]\n     fn type_for_def(&self, def: TypableDef, ns: Namespace) -> Ty;\n \n-    #[salsa::invoke(crate::ty::type_for_field)]\n-    fn type_for_field(&self, field: StructField) -> Ty;\n+    #[salsa::invoke(crate::ty::field_types_query)]\n+    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;\n \n     #[salsa::invoke(crate::ty::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n@@ -108,11 +75,14 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n \n     // Interned IDs for Chalk integration\n     #[salsa::interned]\n-    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n+    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> crate::ty::TypeCtorId;\n     #[salsa::interned]\n-    fn intern_chalk_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n+    fn intern_chalk_impl(&self, impl_: Impl) -> crate::ty::traits::GlobalImplId;\n     #[salsa::interned]\n-    fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> ids::AssocTyValueId;\n+    fn intern_assoc_ty_value(\n+        &self,\n+        assoc_ty_value: AssocTyValue,\n+    ) -> crate::ty::traits::AssocTyValueId;\n \n     #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n     fn associated_ty_data("}, {"sha": "7a2810f71aff1d227b197fdc908bfd666dfecf90", "filename": "crates/ra_hir/src/debug.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdebug.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,3 +1,5 @@\n+//! XXX: This does not work at the moment.\n+//!\n //! printf debugging infrastructure for rust-analyzer.\n //!\n //! When you print a hir type, like a module, using `eprintln!(\"{:?}\", module)`,\n@@ -20,9 +22,10 @@\n \n use std::fmt;\n \n+use hir_expand::HirFileId;\n use ra_db::{CrateId, FileId};\n \n-use crate::{db::HirDatabase, Crate, HirFileId, Module, Name};\n+use crate::{db::HirDatabase, Crate, Module, Name};\n \n impl Crate {\n     pub fn debug(self, db: &impl HirDebugDatabase) -> impl fmt::Debug + '_ {"}, {"sha": "dafacba70c373f99106d9dd647ea89994437248c", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -2,9 +2,10 @@\n \n use std::any::Any;\n \n+use hir_expand::HirFileId;\n use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n \n-use crate::{db::AstDatabase, HirFileId, Name, Source};\n+use crate::{db::AstDatabase, Name, Source};\n \n pub use hir_def::diagnostics::UnresolvedModule;\n pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};"}, {"sha": "43fedde7aa056eb69437e747f9d5dd693d2cdcff", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -44,15 +44,15 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n     pub(crate) fn validate_body(&mut self, db: &impl HirDatabase) {\n         let body = self.func.body(db);\n \n-        for e in body.exprs() {\n+        for e in body.exprs.iter() {\n             if let (id, Expr::RecordLit { path, fields, spread }) = e {\n                 self.validate_record_literal(id, path, fields, *spread, db);\n             }\n         }\n \n-        let body_expr = &body[body.body_expr()];\n+        let body_expr = &body[body.body_expr];\n         if let Expr::Block { statements: _, tail: Some(t) } = body_expr {\n-            self.validate_results_in_tail_expr(body.body_expr(), *t, db);\n+            self.validate_results_in_tail_expr(body.body_expr, *t, db);\n         }\n     }\n "}, {"sha": "529ac825172e34e327e9caeafe6d6fa1d212c1f2", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -4,14 +4,14 @@\n //! are splitting the hir.\n \n use hir_def::{\n-    AdtId, AssocItemId, ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n-    ModuleDefId, StaticId, StructId, TypeAliasId, UnionId,\n+    AdtId, AssocItemId, AttrDefId, ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n+    GenericDefId, ModuleDefId, StaticId, StructFieldId, StructId, TypeAliasId, UnionId, VariantId,\n };\n \n use crate::{\n     ty::{CallableDef, TypableDef},\n-    Adt, AssocItem, Const, Crate, DefWithBody, EnumVariant, Function, GenericDef, ModuleDef,\n-    Static, TypeAlias,\n+    Adt, AssocItem, AttrDef, Const, Crate, DefWithBody, EnumVariant, Function, GenericDef,\n+    ModuleDef, Static, StructField, TypeAlias, VariantDef,\n };\n \n impl From<ra_db::CrateId> for Crate {\n@@ -70,6 +70,12 @@ impl From<EnumVariantId> for EnumVariant {\n     }\n }\n \n+impl From<EnumVariant> for EnumVariantId {\n+    fn from(def: EnumVariant) -> Self {\n+        EnumVariantId { parent: def.parent.id, local_id: def.id }\n+    }\n+}\n+\n impl From<ModuleDefId> for ModuleDef {\n     fn from(id: ModuleDefId) -> Self {\n         match id {\n@@ -219,3 +225,35 @@ impl From<CallableDef> for GenericDefId {\n         }\n     }\n }\n+\n+impl From<VariantDef> for VariantId {\n+    fn from(def: VariantDef) -> Self {\n+        match def {\n+            VariantDef::Struct(it) => VariantId::StructId(it.id),\n+            VariantDef::EnumVariant(it) => VariantId::EnumVariantId(it.into()),\n+        }\n+    }\n+}\n+\n+impl From<StructField> for StructFieldId {\n+    fn from(def: StructField) -> Self {\n+        StructFieldId { parent: def.parent.into(), local_id: def.id }\n+    }\n+}\n+\n+impl From<AttrDef> for AttrDefId {\n+    fn from(def: AttrDef) -> Self {\n+        match def {\n+            AttrDef::Module(it) => AttrDefId::ModuleId(it.id),\n+            AttrDef::StructField(it) => AttrDefId::StructFieldId(it.into()),\n+            AttrDef::Adt(it) => AttrDefId::AdtId(it.into()),\n+            AttrDef::Function(it) => AttrDefId::FunctionId(it.id),\n+            AttrDef::EnumVariant(it) => AttrDefId::EnumVariantId(it.into()),\n+            AttrDef::Static(it) => AttrDefId::StaticId(it.id),\n+            AttrDef::Const(it) => AttrDefId::ConstId(it.id),\n+            AttrDef::Trait(it) => AttrDefId::TraitId(it.id),\n+            AttrDef::TypeAlias(it) => AttrDefId::TypeAliasId(it.id),\n+            AttrDef::MacroDef(it) => AttrDefId::MacroDefId(it.id),\n+        }\n+    }\n+}"}, {"sha": "1e7c22774d1cd55f8c6b3e82b0c83015eadc98c6", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir_def::{ModuleId, StructId, StructOrUnionId, UnionId};\n+use hir_def::{AstItemDef, LocationCtx, ModuleId, StructId, StructOrUnionId, UnionId};\n use hir_expand::{name::AsName, AstId, MacroDefId, MacroDefKind};\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n@@ -9,10 +9,9 @@ use ra_syntax::{\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    ids::{AstItemDef, LocationCtx},\n-    AssocItem, Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasBody, HasSource,\n-    ImplBlock, Local, MacroDef, Module, ModuleDef, ModuleSource, Source, Static, Struct,\n-    StructField, Trait, TypeAlias, Union, VariantDef,\n+    AssocItem, Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock,\n+    Local, MacroDef, Module, ModuleDef, ModuleSource, Source, Static, Struct, StructField, Trait,\n+    TypeAlias, Union, VariantDef,\n };\n \n pub trait FromSource: Sized {\n@@ -105,10 +104,21 @@ impl FromSource for Const {\n impl FromSource for Static {\n     type Ast = ast::StaticDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(Static { id })\n+        let module = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n+            Container::Module(it) => it,\n+            Container::Trait(_) | Container::ImplBlock(_) => return None,\n+        };\n+        module\n+            .declarations(db)\n+            .into_iter()\n+            .filter_map(|it| match it {\n+                ModuleDef::Static(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|it| same_source(&it.source(db), &src))\n     }\n }\n+\n impl FromSource for TypeAlias {\n     type Ast = ast::TypeAliasDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n@@ -190,8 +200,7 @@ impl FromSource for StructField {\n         variant_def\n             .variant_data(db)\n             .fields()\n-            .into_iter()\n-            .flat_map(|it| it.iter())\n+            .iter()\n             .map(|(id, _)| StructField { parent: variant_def, id })\n             .find(|f| f.source(db) == src)\n     }\n@@ -211,7 +220,7 @@ impl Local {\n             };\n             Some(res)\n         })?;\n-        let source_map = parent.body_source_map(db);\n+        let (_body, source_map) = db.body_with_source_map(parent.into());\n         let src = src.map(ast::Pat::from);\n         let pat_id = source_map.node_pat(src.as_ref())?;\n         Some(Local { parent, pat_id })\n@@ -272,7 +281,9 @@ where\n     let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n     let module = Module::from_definition(db, Source::new(src.file_id, module_src))?;\n     let ctx = LocationCtx::new(db, module.id, src.file_id);\n-    Some(DEF::from_ast(ctx, &src.value))\n+    let items = db.ast_id_map(src.file_id);\n+    let item_id = items.ast_id(&src.value);\n+    Some(DEF::from_ast_id(ctx, item_id))\n }\n \n enum Container {"}, {"sha": "2b59365fb6a43a3ffa45286bb2fe628998075789", "filename": "crates/ra_hir/src/ids.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=eb7363d167c7a9f7c73cb950b621eb1dce493318", "patch": "@@ -1,45 +0,0 @@\n-//! hir makes heavy use of ids: integer (u32) handlers to various things. You\n-//! can think of id as a pointer (but without a lifetime) or a file descriptor\n-//! (but for hir objects).\n-//!\n-//! This module defines a bunch of ids we are using. The most important ones are\n-//! probably `HirFileId` and `DefId`.\n-\n-use ra_db::salsa;\n-\n-pub use hir_def::{\n-    AstItemDef, ConstId, EnumId, FunctionId, ItemLoc, LocationCtx, StaticId, StructId, TraitId,\n-    TypeAliasId,\n-};\n-pub use hir_expand::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, MacroFileKind};\n-\n-macro_rules! impl_intern_key {\n-    ($name:ident) => {\n-        impl salsa::InternKey for $name {\n-            fn from_intern_id(v: salsa::InternId) -> Self {\n-                $name(v)\n-            }\n-            fn as_intern_id(&self) -> salsa::InternId {\n-                self.0\n-            }\n-        }\n-    };\n-}\n-\n-/// This exists just for Chalk, because Chalk just has a single `StructId` where\n-/// we have different kinds of ADTs, primitive types and special type\n-/// constructors like tuples and function pointers.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TypeCtorId(salsa::InternId);\n-impl_intern_key!(TypeCtorId);\n-\n-/// This exists just for Chalk, because our ImplIds are only unique per module.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct GlobalImplId(salsa::InternId);\n-impl_intern_key!(GlobalImplId);\n-\n-/// This exists just for Chalk, because it needs a unique ID for each associated\n-/// type value in an impl (even synthetic ones).\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct AssocTyValueId(salsa::InternId);\n-impl_intern_key!(AssocTyValueId);"}, {"sha": "774fa1d96404a8e9d97e4a06c06b588584becdc2", "filename": "crates/ra_hir/src/impl_block.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=eb7363d167c7a9f7c73cb950b621eb1dce493318", "patch": "@@ -1,52 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use hir_def::{resolver::HasResolver, type_ref::TypeRef, AstItemDef};\n-use ra_syntax::ast;\n-\n-use crate::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n-    ty::Ty,\n-    AssocItem, Crate, HasSource, ImplBlock, Module, Source, TraitRef,\n-};\n-\n-impl HasSource for ImplBlock {\n-    type Ast = ast::ImplBlock;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::ImplBlock> {\n-        self.id.source(db)\n-    }\n-}\n-\n-impl ImplBlock {\n-    pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n-        db.impl_data(self.id).target_trait().cloned()\n-    }\n-\n-    pub fn target_type(&self, db: &impl DefDatabase) -> TypeRef {\n-        db.impl_data(self.id).target_type().clone()\n-    }\n-\n-    pub fn target_ty(&self, db: &impl HirDatabase) -> Ty {\n-        Ty::from_hir(db, &self.id.resolver(db), &self.target_type(db))\n-    }\n-\n-    pub fn target_trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n-        let target_ty = self.target_ty(db);\n-        TraitRef::from_hir(db, &self.id.resolver(db), &self.target_trait(db)?, Some(target_ty))\n-    }\n-\n-    pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {\n-        db.impl_data(self.id).items().iter().map(|it| (*it).into()).collect()\n-    }\n-\n-    pub fn is_negative(&self, db: &impl DefDatabase) -> bool {\n-        db.impl_data(self.id).is_negative()\n-    }\n-\n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db).into()\n-    }\n-\n-    pub fn krate(&self, db: &impl DefDatabase) -> Crate {\n-        Crate { crate_id: self.module(db).id.krate }\n-    }\n-}"}, {"sha": "89fd85f59f959d0931a1f82c0d402de65a5e66eb", "filename": "crates/ra_hir/src/lang_item.rs", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=eb7363d167c7a9f7c73cb950b621eb1dce493318", "patch": "@@ -1,160 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use rustc_hash::FxHashMap;\n-use std::sync::Arc;\n-\n-use ra_syntax::{ast::AttrsOwner, SmolStr};\n-\n-use crate::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n-    Adt, Crate, Enum, Function, HasSource, ImplBlock, Module, ModuleDef, Static, Struct, Trait,\n-};\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum LangItemTarget {\n-    Enum(Enum),\n-    Function(Function),\n-    ImplBlock(ImplBlock),\n-    Static(Static),\n-    Struct(Struct),\n-    Trait(Trait),\n-}\n-\n-impl LangItemTarget {\n-    pub(crate) fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n-        Some(match self {\n-            LangItemTarget::Enum(e) => e.module(db).krate(),\n-            LangItemTarget::Function(f) => f.module(db).krate(),\n-            LangItemTarget::ImplBlock(i) => i.krate(db),\n-            LangItemTarget::Static(s) => s.module(db).krate(),\n-            LangItemTarget::Struct(s) => s.module(db).krate(),\n-            LangItemTarget::Trait(t) => t.module(db).krate(),\n-        })\n-    }\n-}\n-\n-#[derive(Default, Debug, Clone, PartialEq, Eq)]\n-pub struct LangItems {\n-    items: FxHashMap<SmolStr, LangItemTarget>,\n-}\n-\n-impl LangItems {\n-    pub fn target<'a>(&'a self, item: &str) -> Option<&'a LangItemTarget> {\n-        self.items.get(item)\n-    }\n-\n-    /// Salsa query. This will look for lang items in a specific crate.\n-    pub(crate) fn crate_lang_items_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        krate: Crate,\n-    ) -> Arc<LangItems> {\n-        let mut lang_items = LangItems::default();\n-\n-        if let Some(module) = krate.root_module(db) {\n-            lang_items.collect_lang_items_recursive(db, module);\n-        }\n-\n-        Arc::new(lang_items)\n-    }\n-\n-    pub(crate) fn module_lang_items_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        module: Module,\n-    ) -> Option<Arc<LangItems>> {\n-        let mut lang_items = LangItems::default();\n-        lang_items.collect_lang_items(db, module);\n-        if lang_items.items.is_empty() {\n-            None\n-        } else {\n-            Some(Arc::new(lang_items))\n-        }\n-    }\n-\n-    /// Salsa query. Look for a lang item, starting from the specified crate and recursively\n-    /// traversing its dependencies.\n-    pub(crate) fn lang_item_query(\n-        db: &impl DefDatabase,\n-        start_crate: Crate,\n-        item: SmolStr,\n-    ) -> Option<LangItemTarget> {\n-        let lang_items = db.crate_lang_items(start_crate);\n-        let start_crate_target = lang_items.items.get(&item);\n-        if let Some(target) = start_crate_target {\n-            Some(*target)\n-        } else {\n-            for dep in start_crate.dependencies(db) {\n-                let dep_crate = dep.krate;\n-                let dep_target = db.lang_item(dep_crate, item.clone());\n-                if dep_target.is_some() {\n-                    return dep_target;\n-                }\n-            }\n-            None\n-        }\n-    }\n-\n-    fn collect_lang_items(&mut self, db: &(impl DefDatabase + AstDatabase), module: Module) {\n-        // Look for impl targets\n-        for impl_block in module.impl_blocks(db) {\n-            let src = impl_block.source(db);\n-            if let Some(lang_item_name) = lang_item_name(&src.value) {\n-                self.items\n-                    .entry(lang_item_name)\n-                    .or_insert_with(|| LangItemTarget::ImplBlock(impl_block));\n-            }\n-        }\n-\n-        for def in module.declarations(db) {\n-            match def {\n-                ModuleDef::Trait(trait_) => {\n-                    self.collect_lang_item(db, trait_, LangItemTarget::Trait)\n-                }\n-                ModuleDef::Adt(Adt::Enum(e)) => self.collect_lang_item(db, e, LangItemTarget::Enum),\n-                ModuleDef::Adt(Adt::Struct(s)) => {\n-                    self.collect_lang_item(db, s, LangItemTarget::Struct)\n-                }\n-                ModuleDef::Function(f) => self.collect_lang_item(db, f, LangItemTarget::Function),\n-                ModuleDef::Static(s) => self.collect_lang_item(db, s, LangItemTarget::Static),\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    fn collect_lang_items_recursive(\n-        &mut self,\n-        db: &(impl DefDatabase + AstDatabase),\n-        module: Module,\n-    ) {\n-        if let Some(module_lang_items) = db.module_lang_items(module) {\n-            self.items.extend(module_lang_items.items.iter().map(|(k, v)| (k.clone(), *v)))\n-        }\n-\n-        // Look for lang items in the children\n-        for child in module.children(db) {\n-            self.collect_lang_items_recursive(db, child);\n-        }\n-    }\n-\n-    fn collect_lang_item<T, N>(\n-        &mut self,\n-        db: &(impl DefDatabase + AstDatabase),\n-        item: T,\n-        constructor: fn(T) -> LangItemTarget,\n-    ) where\n-        T: Copy + HasSource<Ast = N>,\n-        N: AttrsOwner,\n-    {\n-        let node = item.source(db).value;\n-        if let Some(lang_item_name) = lang_item_name(&node) {\n-            self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n-        }\n-    }\n-}\n-\n-fn lang_item_name<T: AttrsOwner>(node: &T) -> Option<SmolStr> {\n-    node.attrs()\n-        .filter_map(|a| a.as_simple_key_value())\n-        .filter(|(key, _)| key == \"lang\")\n-        .map(|(_, val)| val)\n-        .nth(0)\n-}"}, {"sha": "843ce6a88a20fd00d5d95e6b803ab28db41f982f", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -31,12 +31,8 @@ pub mod debug;\n pub mod db;\n pub mod source_binder;\n \n-mod ids;\n-mod type_alias;\n mod ty;\n-mod impl_block;\n mod expr;\n-mod lang_item;\n pub mod diagnostics;\n mod util;\n \n@@ -52,17 +48,13 @@ mod marks;\n \n pub use crate::{\n     code_model::{\n-        attrs::{AttrDef, Attrs},\n-        docs::{DocDef, Docs, Documentation},\n-        src::{HasBodySource, HasSource},\n-        Adt, AssocItem, Const, ConstData, Container, Crate, CrateDependency, DefWithBody, Enum,\n-        EnumVariant, FieldSource, FnData, Function, GenericDef, GenericParam, HasBody, ImplBlock,\n-        Local, MacroDef, Module, ModuleDef, ModuleSource, ScopeDef, Static, Struct, StructField,\n-        Trait, TypeAlias, Union, VariantDef,\n+        src::HasSource, Adt, AssocItem, AttrDef, Const, Container, Crate, CrateDependency,\n+        DefWithBody, Docs, Enum, EnumVariant, FieldSource, Function, GenericDef, GenericParam,\n+        HasAttrs, ImplBlock, Import, Local, MacroDef, Module, ModuleDef, ModuleSource, ScopeDef,\n+        Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n     },\n     expr::ExprScopes,\n     from_source::FromSource,\n-    ids::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile},\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     ty::{\n         display::HirDisplay,\n@@ -73,8 +65,10 @@ pub use crate::{\n \n pub use hir_def::{\n     builtin_type::BuiltinType,\n-    nameres::{per_ns::PerNs, raw::ImportId},\n+    docs::Documentation,\n     path::{Path, PathKind},\n     type_ref::Mutability,\n };\n-pub use hir_expand::{either::Either, name::Name, Source};\n+pub use hir_expand::{\n+    either::Either, name::Name, HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, Source,\n+};"}, {"sha": "31390bb7ff528de6580525f8b85bed63b31e774f", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -13,7 +13,9 @@ use hir_def::{\n     resolver::{self, resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},\n     DefWithBodyId,\n };\n-use hir_expand::{name::AsName, AstId, MacroCallId, MacroCallLoc, MacroFileKind, Source};\n+use hir_expand::{\n+    name::AsName, AstId, HirFileId, MacroCallId, MacroCallLoc, MacroFileKind, Source,\n+};\n use ra_syntax::{\n     ast::{self, AstNode},\n     match_ast, AstPtr,\n@@ -24,11 +26,9 @@ use ra_syntax::{\n use crate::{\n     db::HirDatabase,\n     expr::{BodySourceMap, ExprScopes, ScopeId},\n-    ids::LocationCtx,\n     ty::method_resolution::{self, implements_trait},\n     Adt, AssocItem, Const, DefWithBody, Either, Enum, EnumVariant, FromSource, Function,\n-    GenericParam, HasBody, HirFileId, Local, MacroDef, Module, Name, Path, ScopeDef, Static,\n-    Struct, Trait, Ty, TypeAlias,\n+    GenericParam, Local, MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Ty, TypeAlias,\n };\n \n fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -> Option<Resolver> {\n@@ -67,16 +67,12 @@ fn def_with_body_from_child_node(\n     db: &impl HirDatabase,\n     child: Source<&SyntaxNode>,\n ) -> Option<DefWithBody> {\n-    let module_source = crate::ModuleSource::from_child_node(db, child);\n-    let module = Module::from_definition(db, Source::new(child.file_id, module_source))?;\n-    let ctx = LocationCtx::new(db, module.id, child.file_id);\n-\n     child.value.ancestors().find_map(|node| {\n         match_ast! {\n             match node {\n                 ast::FnDef(def)  => { return Function::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n                 ast::ConstDef(def) => { return Const::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n-                ast::StaticDef(def) => { Some(Static { id: ctx.to_def(&def) }.into()) },\n+                ast::StaticDef(def) => { return Static::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n                 _ => { None },\n             }\n         }\n@@ -158,8 +154,8 @@ impl SourceAnalyzer {\n     ) -> SourceAnalyzer {\n         let def_with_body = def_with_body_from_child_node(db, node);\n         if let Some(def) = def_with_body {\n-            let source_map = def.body_source_map(db);\n-            let scopes = def.expr_scopes(db);\n+            let (_body, source_map) = db.body_with_source_map(def.into());\n+            let scopes = db.expr_scopes(def.into());\n             let scope = match offset {\n                 None => scope_for(&scopes, &source_map, node),\n                 Some(offset) => scope_for_offset(&scopes, &source_map, node.with_value(offset)),\n@@ -169,7 +165,7 @@ impl SourceAnalyzer {\n                 resolver,\n                 body_owner: Some(def),\n                 body_source_map: Some(source_map),\n-                infer: Some(def.infer(db)),\n+                infer: Some(db.infer(def)),\n                 scopes: Some(scopes),\n                 file_id: node.file_id,\n             }\n@@ -219,6 +215,11 @@ impl SourceAnalyzer {\n         self.infer.as_ref()?.field_resolution(expr_id)\n     }\n \n+    pub fn resolve_record_field(&self, field: &ast::RecordField) -> Option<crate::StructField> {\n+        let expr_id = self.expr_id(&field.expr()?)?;\n+        self.infer.as_ref()?.record_field_resolution(expr_id)\n+    }\n+\n     pub fn resolve_record_literal(&self, record_lit: &ast::RecordLit) -> Option<crate::VariantDef> {\n         let expr_id = self.expr_id(&record_lit.clone().into())?;\n         self.infer.as_ref()?.variant_resolution_for_expr(expr_id)\n@@ -544,7 +545,7 @@ fn adjust(\n }\n \n /// Given a `ast::MacroCall`, return what `MacroKindFile` it belongs to.\n-/// FIXME: Not completed  \n+/// FIXME: Not completed\n fn to_macro_file_kind(macro_call: &ast::MacroCall) -> MacroFileKind {\n     let syn = macro_call.syntax();\n     let parent = match syn.parent() {"}, {"sha": "efee2f658bba7e2e30febe0a4965ae3d968e7a32", "filename": "crates/ra_hir/src/test_db.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftest_db.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -2,7 +2,7 @@\n \n use std::{panic, sync::Arc};\n \n-use hir_def::{db::DefDatabase2, ModuleId};\n+use hir_def::{db::DefDatabase, ModuleId};\n use hir_expand::diagnostics::DiagnosticSink;\n use parking_lot::Mutex;\n use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath, SourceDatabase};\n@@ -15,7 +15,6 @@ use crate::{db, debug::HirDebugHelper};\n     db::InternDatabaseStorage,\n     db::AstDatabaseStorage,\n     db::DefDatabaseStorage,\n-    db::DefDatabase2Storage,\n     db::HirDatabaseStorage\n )]\n #[derive(Debug, Default)]\n@@ -81,7 +80,7 @@ impl TestDB {\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter().next() {\n             let crate_def_map = self.crate_def_map(krate);\n-            for module_id in crate_def_map.modules() {\n+            for (module_id, _) in crate_def_map.modules.iter() {\n                 let module_id = ModuleId { krate, module_id };\n                 let module = crate::Module::from(module_id);\n                 module.diagnostics("}, {"sha": "f62316c1fb4ab82f199a28a32cb18de3cbddbfbf", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -18,6 +18,7 @@ use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n use hir_def::{generics::GenericParams, AdtId};\n+use ra_db::{impl_intern_key, salsa};\n \n use crate::{\n     db::HirDatabase, expr::ExprId, util::make_mut_slice, Adt, Crate, DefWithBody, FloatTy,\n@@ -29,8 +30,9 @@ pub(crate) use autoderef::autoderef;\n pub(crate) use infer::{infer_query, InferTy, InferenceResult};\n pub use lower::CallableDef;\n pub(crate) use lower::{\n-    callable_item_sig, generic_defaults_query, generic_predicates_for_param_query,\n-    generic_predicates_query, type_for_def, type_for_field, Namespace, TypableDef,\n+    callable_item_sig, field_types_query, generic_defaults_query,\n+    generic_predicates_for_param_query, generic_predicates_query, type_for_def, Namespace,\n+    TypableDef,\n };\n pub(crate) use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n \n@@ -114,6 +116,13 @@ pub enum TypeCtor {\n     Closure { def: DefWithBody, expr: ExprId },\n }\n \n+/// This exists just for Chalk, because Chalk just has a single `StructId` where\n+/// we have different kinds of ADTs, primitive types and special type\n+/// constructors like tuples and function pointers.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TypeCtorId(salsa::InternId);\n+impl_intern_key!(TypeCtorId);\n+\n impl TypeCtor {\n     pub fn num_ty_params(self, db: &impl HirDatabase) -> usize {\n         match self {"}, {"sha": "41c99d227b68b2a7a03a95dd191046e9ddd2d8e3", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -5,12 +5,13 @@\n \n use std::iter::successors;\n \n-use hir_def::resolver::Resolver;\n+use hir_def::{lang_item::LangItemTarget, resolver::Resolver};\n use hir_expand::name;\n use log::{info, warn};\n \n+use crate::{db::HirDatabase, Trait};\n+\n use super::{traits::Solution, Canonical, Substs, Ty, TypeWalk};\n-use crate::db::HirDatabase;\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n \n@@ -41,7 +42,7 @@ fn deref_by_trait(\n ) -> Option<Canonical<Ty>> {\n     let krate = resolver.krate()?;\n     let deref_trait = match db.lang_item(krate.into(), \"deref\".into())? {\n-        crate::lang_item::LangItemTarget::Trait(t) => t,\n+        LangItemTarget::TraitId(t) => Trait::from(t),\n         _ => return None,\n     };\n     let target = deref_trait.associated_type_by_name(db, &name::TARGET_TYPE)?;"}, {"sha": "ddc7d262aa0ec8314ed562aaead9a7852bfbd754", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -22,6 +22,7 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use rustc_hash::FxHashMap;\n \n use hir_def::{\n+    data::{ConstData, FunctionData},\n     path::known,\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n@@ -43,8 +44,7 @@ use crate::{\n     db::HirDatabase,\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n     ty::infer::diagnostics::InferenceDiagnostic,\n-    Adt, AssocItem, ConstData, DefWithBody, FloatTy, FnData, Function, HasBody, IntTy, Path,\n-    StructField, Trait, VariantDef,\n+    Adt, AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, Trait, VariantDef,\n };\n \n macro_rules! ty_app {\n@@ -68,10 +68,10 @@ pub fn infer_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResu\n     let resolver = DefWithBodyId::from(def).resolver(db);\n     let mut ctx = InferenceContext::new(db, def, resolver);\n \n-    match def {\n-        DefWithBody::Const(ref c) => ctx.collect_const(&c.data(db)),\n-        DefWithBody::Function(ref f) => ctx.collect_fn(&f.data(db)),\n-        DefWithBody::Static(ref s) => ctx.collect_const(&s.data(db)),\n+    match &def {\n+        DefWithBody::Const(c) => ctx.collect_const(&db.const_data(c.id)),\n+        DefWithBody::Function(f) => ctx.collect_fn(&db.function_data(f.id)),\n+        DefWithBody::Static(s) => ctx.collect_const(&db.static_data(s.id)),\n     }\n \n     ctx.infer_body();\n@@ -125,6 +125,8 @@ pub struct InferenceResult {\n     method_resolutions: FxHashMap<ExprId, Function>,\n     /// For each field access expr, records the field it resolves to.\n     field_resolutions: FxHashMap<ExprId, StructField>,\n+    /// For each field in record literal, records the field it resolves to.\n+    record_field_resolutions: FxHashMap<ExprId, StructField>,\n     /// For each struct literal, records the variant it resolves to.\n     variant_resolutions: FxHashMap<ExprOrPatId, VariantDef>,\n     /// For each associated item record what it resolves to\n@@ -142,6 +144,9 @@ impl InferenceResult {\n     pub fn field_resolution(&self, expr: ExprId) -> Option<StructField> {\n         self.field_resolutions.get(&expr).copied()\n     }\n+    pub fn record_field_resolution(&self, expr: ExprId) -> Option<StructField> {\n+        self.record_field_resolutions.get(&expr).copied()\n+    }\n     pub fn variant_resolution_for_expr(&self, id: ExprId) -> Option<VariantDef> {\n         self.variant_resolutions.get(&id.into()).copied()\n     }\n@@ -215,7 +220,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             coerce_unsized_map: Self::init_coerce_unsized_map(db, &resolver),\n             db,\n             owner,\n-            body: owner.body(db),\n+            body: db.body(owner.into()),\n             resolver,\n         }\n     }\n@@ -559,21 +564,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn collect_const(&mut self, data: &ConstData) {\n-        self.return_ty = self.make_ty(data.type_ref());\n+        self.return_ty = self.make_ty(&data.type_ref);\n     }\n \n-    fn collect_fn(&mut self, data: &FnData) {\n+    fn collect_fn(&mut self, data: &FunctionData) {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        for (type_ref, pat) in data.params().iter().zip(body.params()) {\n+        for (type_ref, pat) in data.params.iter().zip(body.params.iter()) {\n             let ty = self.make_ty(type_ref);\n \n             self.infer_pat(*pat, &ty, BindingMode::default());\n         }\n-        self.return_ty = self.make_ty(data.ret_type());\n+        self.return_ty = self.make_ty(&data.ret_type);\n     }\n \n     fn infer_body(&mut self) {\n-        self.infer_expr(self.body.body_expr(), &Expectation::has_type(self.return_ty.clone()));\n+        self.infer_expr(self.body.body_expr, &Expectation::has_type(self.return_ty.clone()));\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAlias> {"}, {"sha": "54765da358e512232322a35029b8a46e12b9c927", "filename": "crates/ra_hir/src/ty/infer/coerce.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -4,13 +4,12 @@\n //!\n //! See: https://doc.rust-lang.org/nomicon/coercions.html\n \n-use hir_def::resolver::Resolver;\n+use hir_def::{lang_item::LangItemTarget, resolver::Resolver};\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n     db::HirDatabase,\n-    lang_item::LangItemTarget,\n     ty::{autoderef, Substs, Ty, TypeCtor, TypeWalk},\n     Adt, Mutability,\n };\n@@ -50,7 +49,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     ) -> FxHashMap<(TypeCtor, TypeCtor), usize> {\n         let krate = resolver.krate().unwrap();\n         let impls = match db.lang_item(krate.into(), \"coerce_unsized\".into()) {\n-            Some(LangItemTarget::Trait(trait_)) => db.impls_for_trait(krate.into(), trait_),\n+            Some(LangItemTarget::TraitId(trait_)) => {\n+                db.impls_for_trait(krate.into(), trait_.into())\n+            }\n             _ => return FxHashMap::default(),\n         };\n \n@@ -244,14 +245,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 ty_app!(TypeCtor::Adt(Adt::Struct(struct1)), st1),\n                 ty_app!(TypeCtor::Adt(Adt::Struct(struct2)), st2),\n             ) if struct1 == struct2 => {\n-                let fields = struct1.fields(self.db);\n-                let (last_field, prev_fields) = fields.split_last()?;\n+                let field_tys = self.db.field_types(struct1.id.into());\n+                let struct_data = self.db.struct_data(struct1.id.0);\n+\n+                let mut fields = struct_data.variant_data.fields().iter();\n+                let (last_field_id, _data) = fields.next_back()?;\n \n                 // Get the generic parameter involved in the last field.\n                 let unsize_generic_index = {\n                     let mut index = None;\n                     let mut multiple_param = false;\n-                    last_field.ty(self.db).walk(&mut |ty| match ty {\n+                    field_tys[last_field_id].walk(&mut |ty| match ty {\n                         &Ty::Param { idx, .. } => {\n                             if index.is_none() {\n                                 index = Some(idx);\n@@ -270,8 +274,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 // Check other fields do not involve it.\n                 let mut multiple_used = false;\n-                prev_fields.iter().for_each(|field| {\n-                    field.ty(self.db).walk(&mut |ty| match ty {\n+                fields.for_each(|(field_id, _data)| {\n+                    field_tys[field_id].walk(&mut |ty| match ty {\n                         &Ty::Param { idx, .. } if idx == unsize_generic_index => {\n                             multiple_used = true\n                         }"}, {"sha": "663ff9435c8f76c3fb414eeb0ca49ca04056c0d1", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -214,19 +214,24 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.unify(&ty, &expected.ty);\n \n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n+                let field_types =\n+                    def_id.map(|it| self.db.field_types(it.into())).unwrap_or_default();\n                 for (field_idx, field) in fields.iter().enumerate() {\n-                    let field_ty = def_id\n-                        .and_then(|it| match it.field(self.db, &field.name) {\n-                            Some(field) => Some(field),\n-                            None => {\n-                                self.push_diagnostic(InferenceDiagnostic::NoSuchField {\n-                                    expr: tgt_expr,\n-                                    field: field_idx,\n-                                });\n-                                None\n-                            }\n-                        })\n-                        .map_or(Ty::Unknown, |field| field.ty(self.db))\n+                    let field_def = def_id.and_then(|it| match it.field(self.db, &field.name) {\n+                        Some(field) => Some(field),\n+                        None => {\n+                            self.push_diagnostic(InferenceDiagnostic::NoSuchField {\n+                                expr: tgt_expr,\n+                                field: field_idx,\n+                            });\n+                            None\n+                        }\n+                    });\n+                    if let Some(field_def) = field_def {\n+                        self.result.record_field_resolutions.insert(field.expr, field_def);\n+                    }\n+                    let field_ty = field_def\n+                        .map_or(Ty::Unknown, |it| field_types[it.id].clone())\n                         .subst(&substs);\n                     self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n@@ -250,7 +255,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             .and_then(|idx| a_ty.parameters.0.get(idx).cloned()),\n                         TypeCtor::Adt(Adt::Struct(s)) => s.field(self.db, name).map(|field| {\n                             self.write_field_resolution(tgt_expr, field);\n-                            field.ty(self.db).subst(&a_ty.parameters)\n+                            self.db.field_types(s.id.into())[field.id]\n+                                .clone()\n+                                .subst(&a_ty.parameters)\n                         }),\n                         _ => None,\n                     },"}, {"sha": "641d61e87b4ece4239a3887d852c61a9e5218f25", "filename": "crates/ra_hir/src/ty/infer/pat.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpat.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -27,10 +27,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         let substs = ty.substs().unwrap_or_else(Substs::empty);\n \n+        let field_tys = def.map(|it| self.db.field_types(it.into())).unwrap_or_default();\n         for (i, &subpat) in subpats.iter().enumerate() {\n             let expected_ty = def\n                 .and_then(|d| d.field(self.db, &Name::new_tuple_field(i)))\n-                .map_or(Ty::Unknown, |field| field.ty(self.db))\n+                .map_or(Ty::Unknown, |field| field_tys[field.id].clone())\n                 .subst(&substs);\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n@@ -56,10 +57,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         let substs = ty.substs().unwrap_or_else(Substs::empty);\n \n+        let field_tys = def.map(|it| self.db.field_types(it.into())).unwrap_or_default();\n         for subpat in subpats {\n             let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n-            let expected_ty =\n-                matching_field.map_or(Ty::Unknown, |field| field.ty(self.db)).subst(&substs);\n+            let expected_ty = matching_field\n+                .map_or(Ty::Unknown, |field| field_tys[field.id].clone())\n+                .subst(&substs);\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }"}, {"sha": "a39beb2a089b34fbb014a0a5bb897d2c00cc7dc0", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -14,8 +14,9 @@ use hir_def::{\n     path::{GenericArg, PathSegment},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, GenericDefId,\n+    AdtId, GenericDefId, LocalStructFieldId, VariantId,\n };\n+use ra_arena::map::ArenaMap;\n \n use super::{\n     FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n@@ -29,7 +30,7 @@ use crate::{\n     },\n     util::make_mut_slice,\n     Const, Enum, EnumVariant, Function, GenericDef, ImplBlock, ModuleDef, Path, Static, Struct,\n-    StructField, Trait, TypeAlias, Union, VariantDef,\n+    Trait, TypeAlias, Union,\n };\n \n // FIXME: this is only really used in `type_for_def`, which contains a bunch of\n@@ -549,16 +550,23 @@ pub(crate) fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSi\n     }\n }\n \n-/// Build the type of a specific field of a struct or enum variant.\n-pub(crate) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n-    let parent_def = field.parent_def(db);\n-    let resolver = match parent_def {\n-        VariantDef::Struct(it) => it.id.resolver(db),\n-        VariantDef::EnumVariant(it) => it.parent.id.resolver(db),\n+/// Build the type of all specific fields of a struct or enum variant.\n+pub(crate) fn field_types_query(\n+    db: &impl HirDatabase,\n+    variant_id: VariantId,\n+) -> Arc<ArenaMap<LocalStructFieldId, Ty>> {\n+    let (resolver, var_data) = match variant_id {\n+        VariantId::StructId(it) => (it.resolver(db), db.struct_data(it.0).variant_data.clone()),\n+        VariantId::EnumVariantId(it) => (\n+            it.parent.resolver(db),\n+            db.enum_data(it.parent).variants[it.local_id].variant_data.clone(),\n+        ),\n     };\n-    let var_data = parent_def.variant_data(db);\n-    let type_ref = &var_data.fields().unwrap()[field.id].type_ref;\n-    Ty::from_hir(db, &resolver, type_ref)\n+    let mut res = ArenaMap::default();\n+    for (field_id, field_data) in var_data.fields().iter() {\n+        res.insert(field_id, Ty::from_hir(db, &resolver, &field_data.type_ref))\n+    }\n+    Arc::new(res)\n }\n \n /// This query exists only to be used when resolving short-hand associated types\n@@ -622,10 +630,10 @@ pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDef) ->\n }\n \n fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {\n-    let data = def.data(db);\n+    let data = db.function_data(def.id);\n     let resolver = def.id.resolver(db);\n-    let params = data.params().iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n-    let ret = Ty::from_hir(db, &resolver, data.ret_type());\n+    let params = data.params.iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n+    let ret = Ty::from_hir(db, &resolver, &data.ret_type);\n     FnSig::from_params_and_return(params, ret)\n }\n \n@@ -639,18 +647,18 @@ fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n \n /// Build the declared type of a const.\n fn type_for_const(db: &impl HirDatabase, def: Const) -> Ty {\n-    let data = def.data(db);\n+    let data = db.const_data(def.id);\n     let resolver = def.id.resolver(db);\n \n-    Ty::from_hir(db, &resolver, data.type_ref())\n+    Ty::from_hir(db, &resolver, &data.type_ref)\n }\n \n /// Build the declared type of a static.\n fn type_for_static(db: &impl HirDatabase, def: Static) -> Ty {\n-    let data = def.data(db);\n+    let data = db.static_data(def.id);\n     let resolver = def.id.resolver(db);\n \n-    Ty::from_hir(db, &resolver, data.type_ref())\n+    Ty::from_hir(db, &resolver, &data.type_ref)\n }\n \n /// Build the declared type of a static.\n@@ -696,10 +704,7 @@ impl From<Option<BuiltinFloat>> for Uncertain<FloatTy> {\n \n fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> FnSig {\n     let struct_data = db.struct_data(def.id.into());\n-    let fields = match struct_data.variant_data.fields() {\n-        Some(fields) => fields,\n-        None => panic!(\"fn_sig_for_struct_constructor called on unit struct\"),\n-    };\n+    let fields = struct_data.variant_data.fields();\n     let resolver = def.id.resolver(db);\n     let params = fields\n         .iter()\n@@ -712,7 +717,7 @@ fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> FnSig {\n /// Build the type of a tuple struct constructor.\n fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n     let struct_data = db.struct_data(def.id.into());\n-    if struct_data.variant_data.fields().is_none() {\n+    if struct_data.variant_data.is_unit() {\n         return type_for_adt(db, def); // Unit struct\n     }\n     let generics = db.generic_params(def.id.into());\n@@ -722,10 +727,7 @@ fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n \n fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) -> FnSig {\n     let var_data = def.variant_data(db);\n-    let fields = match var_data.fields() {\n-        Some(fields) => fields,\n-        None => panic!(\"fn_sig_for_enum_variant_constructor called for unit variant\"),\n-    };\n+    let fields = var_data.fields();\n     let resolver = def.parent.id.resolver(db);\n     let params = fields\n         .iter()\n@@ -740,7 +742,7 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant)\n /// Build the type of a tuple enum variant constructor.\n fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) -> Ty {\n     let var_data = def.variant_data(db);\n-    if var_data.fields().is_none() {\n+    if var_data.is_unit() {\n         return type_for_adt(db, def.parent_enum(db)); // Unit variant\n     }\n     let generics = db.generic_params(def.parent_enum(db).id.into());"}, {"sha": "caa5f5f74a9edbcf868f745183f10190b4446c0f", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -5,7 +5,7 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n-use hir_def::resolver::Resolver;\n+use hir_def::{lang_item::LangItemTarget, resolver::Resolver, AstItemDef};\n use rustc_hash::FxHashMap;\n \n use crate::{\n@@ -91,34 +91,43 @@ fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayV\n     // Types like slice can have inherent impls in several crates, (core and alloc).\n     // The corresponding impls are marked with lang items, so we can use them to find the required crates.\n     macro_rules! lang_item_crate {\n-        ($db:expr, $cur_crate:expr, $($name:expr),+ $(,)?) => {{\n-            let mut v = ArrayVec::<[Crate; 2]>::new();\n+        ($($name:expr),+ $(,)?) => {{\n+            let mut v = ArrayVec::<[LangItemTarget; 2]>::new();\n             $(\n-                v.extend($db.lang_item($cur_crate, $name.into()).and_then(|item| item.krate($db)));\n+                v.extend(db.lang_item(cur_crate.crate_id, $name.into()));\n             )+\n-            Some(v)\n+            v\n         }};\n     }\n \n-    match ty {\n+    let lang_item_targets = match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n-            TypeCtor::Adt(def_id) => Some(std::iter::once(def_id.krate(db)?).collect()),\n-            TypeCtor::Bool => lang_item_crate!(db, cur_crate, \"bool\"),\n-            TypeCtor::Char => lang_item_crate!(db, cur_crate, \"char\"),\n+            TypeCtor::Adt(def_id) => return Some(std::iter::once(def_id.krate(db)?).collect()),\n+            TypeCtor::Bool => lang_item_crate!(\"bool\"),\n+            TypeCtor::Char => lang_item_crate!(\"char\"),\n             TypeCtor::Float(Uncertain::Known(f)) => match f.bitness {\n                 // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n-                FloatBitness::X32 => lang_item_crate!(db, cur_crate, \"f32\", \"f32_runtime\"),\n-                FloatBitness::X64 => lang_item_crate!(db, cur_crate, \"f64\", \"f64_runtime\"),\n+                FloatBitness::X32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n+                FloatBitness::X64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n             },\n-            TypeCtor::Int(Uncertain::Known(i)) => lang_item_crate!(db, cur_crate, i.ty_to_string()),\n-            TypeCtor::Str => lang_item_crate!(db, cur_crate, \"str_alloc\", \"str\"),\n-            TypeCtor::Slice => lang_item_crate!(db, cur_crate, \"slice_alloc\", \"slice\"),\n-            TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(db, cur_crate, \"const_ptr\"),\n-            TypeCtor::RawPtr(Mutability::Mut) => lang_item_crate!(db, cur_crate, \"mut_ptr\"),\n-            _ => None,\n+            TypeCtor::Int(Uncertain::Known(i)) => lang_item_crate!(i.ty_to_string()),\n+            TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n+            TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n+            TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),\n+            TypeCtor::RawPtr(Mutability::Mut) => lang_item_crate!(\"mut_ptr\"),\n+            _ => return None,\n         },\n-        _ => None,\n-    }\n+        _ => return None,\n+    };\n+    let res = lang_item_targets\n+        .into_iter()\n+        .filter_map(|it| match it {\n+            LangItemTarget::ImplBlockId(it) => Some(it),\n+            _ => None,\n+        })\n+        .map(|it| it.module(db).krate.into())\n+        .collect();\n+    Some(res)\n }\n \n /// Look up the method with the given name, returning the actual autoderefed\n@@ -233,7 +242,7 @@ fn iterate_trait_method_candidates<T>(\n         .chain(traits_from_env)\n         .chain(resolver.traits_in_scope(db).into_iter().map(Trait::from));\n     'traits: for t in traits {\n-        let data = t.trait_data(db);\n+        let data = db.trait_data(t.id);\n \n         // we'll be lazy about checking whether the type implements the\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n@@ -291,9 +300,9 @@ fn is_valid_candidate(\n ) -> bool {\n     match item {\n         AssocItem::Function(m) => {\n-            let data = m.data(db);\n-            name.map_or(true, |name| data.name() == name)\n-                && (data.has_self_param() || mode == LookupMode::Path)\n+            let data = db.function_data(m.id);\n+            name.map_or(true, |name| data.name == *name)\n+                && (data.has_self_param || mode == LookupMode::Path)\n         }\n         AssocItem::Const(c) => {\n             name.map_or(true, |name| Some(name) == c.name(db).as_ref())"}, {"sha": "3209c66bd0e544c9d4810b7df7bd3aac31ce2547", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -2550,8 +2550,6 @@ fn test() {\n     [233; 246) 'GLOBAL_STATIC': u32\n     [256; 257) 'w': u32\n     [260; 277) 'GLOBAL...IC_MUT': u32\n-    [118; 120) '99': u32\n-    [161; 163) '99': u32\n     \"###\n     );\n }\n@@ -4857,3 +4855,41 @@ fn main() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn infer_builtin_macros_file() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! file {() => {}}\n+\n+fn main() {\n+    let x = file!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 2) '\"\"': &str\n+    [64; 88) '{     ...!(); }': ()\n+    [74; 75) 'x': &str\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_builtin_macros_column() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! column {() => {}}\n+\n+fn main() {\n+    let x = column!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 2) '13': i32\n+    [66; 92) '{     ...!(); }': ()\n+    [76; 77) 'x': i32\n+    \"###\n+    );\n+}"}, {"sha": "268fa09e4a26c5bef71b14d60e9ef732d066bb9f", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -3,7 +3,7 @@ use std::sync::{Arc, Mutex};\n \n use chalk_ir::{cast::Cast, family::ChalkIr};\n use log::debug;\n-use ra_db::salsa;\n+use ra_db::{impl_intern_key, salsa};\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n@@ -304,6 +304,10 @@ pub enum Impl {\n     /// Closure types implement the Fn traits synthetically.\n     ClosureFnTraitImpl(ClosureFnTraitImplData),\n }\n+/// This exists just for Chalk, because our ImplIds are only unique per module.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct GlobalImplId(salsa::InternId);\n+impl_intern_key!(GlobalImplId);\n \n /// An associated type value. Usually this comes from a `type` declaration\n /// inside an impl block, but for built-in impls we have to synthesize it.\n@@ -315,3 +319,8 @@ pub enum AssocTyValue {\n     /// The output type of the Fn trait implementation.\n     ClosureFnTraitImplOutput(ClosureFnTraitImplData),\n }\n+/// This exists just for Chalk, because it needs a unique ID for each associated\n+/// type value in an impl (even synthetic ones).\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct AssocTyValueId(salsa::InternId);\n+impl_intern_key!(AssocTyValueId);"}, {"sha": "1a93e5e506756d03d77900a5348c0792d3c79dc6", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -9,6 +9,7 @@ use chalk_ir::{\n };\n use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n \n+use hir_def::lang_item::LangItemTarget;\n use hir_expand::name;\n \n use ra_db::salsa::{InternId, InternKey};\n@@ -18,7 +19,7 @@ use crate::{\n     db::HirDatabase,\n     ty::display::HirDisplay,\n     ty::{ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n-    Crate, GenericDef, HasBody, ImplBlock, Trait, TypeAlias,\n+    Crate, GenericDef, ImplBlock, Trait, TypeAlias,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -714,7 +715,7 @@ fn closure_fn_trait_impl_datum(\n     let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n     fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n \n-    let num_args: u16 = match &data.def.body(db)[data.expr] {\n+    let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n         crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n             log::warn!(\"closure for closure type {:?} not found\", data);\n@@ -804,7 +805,7 @@ fn closure_fn_trait_output_assoc_ty_value(\n ) -> Arc<AssociatedTyValue<ChalkIr>> {\n     let impl_id = Impl::ClosureFnTraitImpl(data.clone()).to_chalk(db);\n \n-    let num_args: u16 = match &data.def.body(db)[data.expr] {\n+    let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n         crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n             log::warn!(\"closure for closure type {:?} not found\", data);\n@@ -832,9 +833,9 @@ fn closure_fn_trait_output_assoc_ty_value(\n }\n \n fn get_fn_trait(db: &impl HirDatabase, krate: Crate, fn_trait: super::FnTrait) -> Option<Trait> {\n-    let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n+    let target = db.lang_item(krate.crate_id, fn_trait.lang_item_name().into())?;\n     match target {\n-        crate::lang_item::LangItemTarget::Trait(t) => Some(t),\n+        LangItemTarget::TraitId(t) => Some(t.into()),\n         _ => None,\n     }\n }\n@@ -846,38 +847,38 @@ fn id_to_chalk<T: InternKey>(salsa_id: T) -> chalk_ir::RawId {\n     chalk_ir::RawId { index: salsa_id.as_intern_id().as_u32() }\n }\n \n-impl From<chalk_ir::StructId> for crate::ids::TypeCtorId {\n+impl From<chalk_ir::StructId> for crate::ty::TypeCtorId {\n     fn from(struct_id: chalk_ir::StructId) -> Self {\n         id_from_chalk(struct_id.0)\n     }\n }\n \n-impl From<crate::ids::TypeCtorId> for chalk_ir::StructId {\n-    fn from(type_ctor_id: crate::ids::TypeCtorId) -> Self {\n+impl From<crate::ty::TypeCtorId> for chalk_ir::StructId {\n+    fn from(type_ctor_id: crate::ty::TypeCtorId) -> Self {\n         chalk_ir::StructId(id_to_chalk(type_ctor_id))\n     }\n }\n \n-impl From<chalk_ir::ImplId> for crate::ids::GlobalImplId {\n+impl From<chalk_ir::ImplId> for crate::ty::traits::GlobalImplId {\n     fn from(impl_id: chalk_ir::ImplId) -> Self {\n         id_from_chalk(impl_id.0)\n     }\n }\n \n-impl From<crate::ids::GlobalImplId> for chalk_ir::ImplId {\n-    fn from(impl_id: crate::ids::GlobalImplId) -> Self {\n+impl From<crate::ty::traits::GlobalImplId> for chalk_ir::ImplId {\n+    fn from(impl_id: crate::ty::traits::GlobalImplId) -> Self {\n         chalk_ir::ImplId(id_to_chalk(impl_id))\n     }\n }\n \n-impl From<chalk_rust_ir::AssociatedTyValueId> for crate::ids::AssocTyValueId {\n+impl From<chalk_rust_ir::AssociatedTyValueId> for crate::ty::traits::AssocTyValueId {\n     fn from(id: chalk_rust_ir::AssociatedTyValueId) -> Self {\n         id_from_chalk(id.0)\n     }\n }\n \n-impl From<crate::ids::AssocTyValueId> for chalk_rust_ir::AssociatedTyValueId {\n-    fn from(assoc_ty_value_id: crate::ids::AssocTyValueId) -> Self {\n+impl From<crate::ty::traits::AssocTyValueId> for chalk_rust_ir::AssociatedTyValueId {\n+    fn from(assoc_ty_value_id: crate::ty::traits::AssocTyValueId) -> Self {\n         chalk_rust_ir::AssociatedTyValueId(id_to_chalk(assoc_ty_value_id))\n     }\n }"}, {"sha": "392f244cf17d872cc4bddff3e44c666cd4230afd", "filename": "crates/ra_hir/src/type_alias.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs?ref=eb7363d167c7a9f7c73cb950b621eb1dce493318", "patch": "@@ -1,31 +0,0 @@\n-//! HIR for type aliases (i.e. the `type` keyword).\n-\n-use std::sync::Arc;\n-\n-use hir_def::type_ref::TypeRef;\n-use hir_expand::name::{AsName, Name};\n-\n-use ra_syntax::ast::NameOwner;\n-\n-use crate::{\n-    db::{AstDatabase, DefDatabase},\n-    HasSource, TypeAlias,\n-};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct TypeAliasData {\n-    pub(crate) name: Name,\n-    pub(crate) type_ref: Option<TypeRef>,\n-}\n-\n-impl TypeAliasData {\n-    pub(crate) fn type_alias_data_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        typ: TypeAlias,\n-    ) -> Arc<TypeAliasData> {\n-        let node = typ.source(db).value;\n-        let name = node.name().map_or_else(Name::missing, |n| n.as_name());\n-        let type_ref = node.type_ref().map(TypeRef::from_ast);\n-        Arc::new(TypeAliasData { name, type_ref })\n-    }\n-}"}, {"sha": "c9f30923ee69701a0d631d4ec43d35c9c90aa091", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 118, "deletions": 51, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -2,13 +2,17 @@\n \n use std::sync::Arc;\n \n-use hir_expand::name::{AsName, Name};\n-use ra_arena::Arena;\n+use hir_expand::{\n+    either::Either,\n+    name::{AsName, Name},\n+    Source,\n+};\n+use ra_arena::{map::ArenaMap, Arena};\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n-    db::DefDatabase2, type_ref::TypeRef, AstItemDef, EnumId, LocalEnumVariantId,\n-    LocalStructFieldId, StructOrUnionId,\n+    db::DefDatabase, trace::Trace, type_ref::TypeRef, AstItemDef, EnumId, HasChildSource,\n+    LocalEnumVariantId, LocalStructFieldId, StructOrUnionId, VariantId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -30,13 +34,9 @@ pub struct EnumVariantData {\n     pub variant_data: Arc<VariantData>,\n }\n \n-/// Fields of an enum variant or struct\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct VariantData(VariantDataInner);\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n-enum VariantDataInner {\n-    Struct(Arena<LocalStructFieldId, StructFieldData>),\n+pub enum VariantData {\n+    Record(Arena<LocalStructFieldId, StructFieldData>),\n     Tuple(Arena<LocalStructFieldId, StructFieldData>),\n     Unit,\n }\n@@ -49,10 +49,7 @@ pub struct StructFieldData {\n }\n \n impl StructData {\n-    pub(crate) fn struct_data_query(\n-        db: &impl DefDatabase2,\n-        id: StructOrUnionId,\n-    ) -> Arc<StructData> {\n+    pub(crate) fn struct_data_query(db: &impl DefDatabase, id: StructOrUnionId) -> Arc<StructData> {\n         let src = id.source(db);\n         let name = src.value.name().map(|n| n.as_name());\n         let variant_data = VariantData::new(src.value.kind());\n@@ -62,20 +59,12 @@ impl StructData {\n }\n \n impl EnumData {\n-    pub(crate) fn enum_data_query(db: &impl DefDatabase2, e: EnumId) -> Arc<EnumData> {\n+    pub(crate) fn enum_data_query(db: &impl DefDatabase, e: EnumId) -> Arc<EnumData> {\n         let src = e.source(db);\n         let name = src.value.name().map(|n| n.as_name());\n-        let variants = src\n-            .value\n-            .variant_list()\n-            .into_iter()\n-            .flat_map(|it| it.variants())\n-            .map(|var| EnumVariantData {\n-                name: var.name().map(|it| it.as_name()),\n-                variant_data: Arc::new(VariantData::new(var.kind())),\n-            })\n-            .collect();\n-        Arc::new(EnumData { name, variants })\n+        let mut trace = Trace::new_for_arena();\n+        lower_enum(&mut trace, &src.value);\n+        Arc::new(EnumData { name, variants: trace.into_arena() })\n     }\n \n     pub(crate) fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n@@ -84,39 +73,117 @@ impl EnumData {\n     }\n }\n \n+impl HasChildSource for EnumId {\n+    type ChildId = LocalEnumVariantId;\n+    type Value = ast::EnumVariant;\n+    fn child_source(&self, db: &impl DefDatabase) -> Source<ArenaMap<Self::ChildId, Self::Value>> {\n+        let src = self.source(db);\n+        let mut trace = Trace::new_for_map();\n+        lower_enum(&mut trace, &src.value);\n+        src.with_value(trace.into_map())\n+    }\n+}\n+\n+fn lower_enum(\n+    trace: &mut Trace<LocalEnumVariantId, EnumVariantData, ast::EnumVariant>,\n+    ast: &ast::EnumDef,\n+) {\n+    for var in ast.variant_list().into_iter().flat_map(|it| it.variants()) {\n+        trace.alloc(\n+            || var.clone(),\n+            || EnumVariantData {\n+                name: var.name().map(|it| it.as_name()),\n+                variant_data: Arc::new(VariantData::new(var.kind())),\n+            },\n+        );\n+    }\n+}\n+\n impl VariantData {\n     fn new(flavor: ast::StructKind) -> Self {\n-        let inner = match flavor {\n-            ast::StructKind::Tuple(fl) => {\n-                let fields = fl\n-                    .fields()\n-                    .enumerate()\n-                    .map(|(i, fd)| StructFieldData {\n+        let mut trace = Trace::new_for_arena();\n+        match lower_struct(&mut trace, &flavor) {\n+            StructKind::Tuple => VariantData::Tuple(trace.into_arena()),\n+            StructKind::Record => VariantData::Record(trace.into_arena()),\n+            StructKind::Unit => VariantData::Unit,\n+        }\n+    }\n+\n+    pub fn fields(&self) -> &Arena<LocalStructFieldId, StructFieldData> {\n+        const EMPTY: &Arena<LocalStructFieldId, StructFieldData> = &Arena::new();\n+        match &self {\n+            VariantData::Record(fields) | VariantData::Tuple(fields) => fields,\n+            _ => EMPTY,\n+        }\n+    }\n+\n+    pub fn is_unit(&self) -> bool {\n+        match self {\n+            VariantData::Unit => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl HasChildSource for VariantId {\n+    type ChildId = LocalStructFieldId;\n+    type Value = Either<ast::TupleFieldDef, ast::RecordFieldDef>;\n+\n+    fn child_source(&self, db: &impl DefDatabase) -> Source<ArenaMap<Self::ChildId, Self::Value>> {\n+        let src = match self {\n+            VariantId::EnumVariantId(it) => {\n+                // I don't really like the fact that we call into parent source\n+                // here, this might add to more queries then necessary.\n+                let src = it.parent.child_source(db);\n+                src.map(|map| map[it.local_id].kind())\n+            }\n+            VariantId::StructId(it) => it.0.source(db).map(|it| it.kind()),\n+        };\n+        let mut trace = Trace::new_for_map();\n+        lower_struct(&mut trace, &src.value);\n+        src.with_value(trace.into_map())\n+    }\n+}\n+\n+enum StructKind {\n+    Tuple,\n+    Record,\n+    Unit,\n+}\n+\n+fn lower_struct(\n+    trace: &mut Trace<\n+        LocalStructFieldId,\n+        StructFieldData,\n+        Either<ast::TupleFieldDef, ast::RecordFieldDef>,\n+    >,\n+    ast: &ast::StructKind,\n+) -> StructKind {\n+    match ast {\n+        ast::StructKind::Tuple(fl) => {\n+            for (i, fd) in fl.fields().enumerate() {\n+                trace.alloc(\n+                    || Either::A(fd.clone()),\n+                    || StructFieldData {\n                         name: Name::new_tuple_field(i),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n-                    })\n-                    .collect();\n-                VariantDataInner::Tuple(fields)\n+                    },\n+                );\n             }\n-            ast::StructKind::Named(fl) => {\n-                let fields = fl\n-                    .fields()\n-                    .map(|fd| StructFieldData {\n+            StructKind::Tuple\n+        }\n+        ast::StructKind::Record(fl) => {\n+            for fd in fl.fields() {\n+                trace.alloc(\n+                    || Either::B(fd.clone()),\n+                    || StructFieldData {\n                         name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n                         type_ref: TypeRef::from_ast_opt(fd.ascribed_type()),\n-                    })\n-                    .collect();\n-                VariantDataInner::Struct(fields)\n+                    },\n+                );\n             }\n-            ast::StructKind::Unit => VariantDataInner::Unit,\n-        };\n-        VariantData(inner)\n-    }\n-\n-    pub fn fields(&self) -> Option<&Arena<LocalStructFieldId, StructFieldData>> {\n-        match &self.0 {\n-            VariantDataInner::Struct(fields) | VariantDataInner::Tuple(fields) => Some(fields),\n-            _ => None,\n+            StructKind::Record\n         }\n+        ast::StructKind::Unit => StructKind::Unit,\n     }\n }"}, {"sha": "53456fc08508a57a27a65589adce88dc02a5f3eb", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 122, "deletions": 34, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,17 +1,93 @@\n //! A higher level attributes based on TokenTree, with also some shortcuts.\n \n-use std::sync::Arc;\n+use std::{ops, sync::Arc};\n \n-use hir_expand::hygiene::Hygiene;\n+use hir_expand::{either::Either, hygiene::Hygiene, AstId, Source};\n use mbe::ast_to_token_tree;\n-use ra_cfg::CfgOptions;\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     SmolStr,\n };\n use tt::Subtree;\n \n-use crate::path::Path;\n+use crate::{\n+    db::DefDatabase, path::Path, AdtId, AstItemDef, AttrDefId, HasChildSource, HasSource, Lookup,\n+};\n+\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub struct Attrs {\n+    entries: Option<Arc<[Attr]>>,\n+}\n+\n+impl ops::Deref for Attrs {\n+    type Target = [Attr];\n+\n+    fn deref(&self) -> &[Attr] {\n+        match &self.entries {\n+            Some(it) => &*it,\n+            None => &[],\n+        }\n+    }\n+}\n+\n+impl Attrs {\n+    pub(crate) fn attrs_query(db: &impl DefDatabase, def: AttrDefId) -> Attrs {\n+        match def {\n+            AttrDefId::ModuleId(module) => {\n+                let def_map = db.crate_def_map(module.krate);\n+                let src = match def_map[module.module_id].declaration_source(db) {\n+                    Some(it) => it,\n+                    None => return Attrs::default(),\n+                };\n+                Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n+            }\n+            AttrDefId::StructFieldId(it) => {\n+                let src = it.parent.child_source(db);\n+                match &src.value[it.local_id] {\n+                    Either::A(_tuple) => Attrs::default(),\n+                    Either::B(record) => Attrs::from_attrs_owner(db, src.with_value(record)),\n+                }\n+            }\n+            AttrDefId::EnumVariantId(var_id) => {\n+                let src = var_id.parent.child_source(db);\n+                let src = src.as_ref().map(|it| &it[var_id.local_id]);\n+                Attrs::from_attrs_owner(db, src.map(|it| it as &dyn AttrsOwner))\n+            }\n+            AttrDefId::AdtId(it) => match it {\n+                AdtId::StructId(it) => attrs_from_ast(it.0.lookup_intern(db).ast_id, db),\n+                AdtId::EnumId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n+                AdtId::UnionId(it) => attrs_from_ast(it.0.lookup_intern(db).ast_id, db),\n+            },\n+            AttrDefId::TraitId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n+            AttrDefId::MacroDefId(it) => attrs_from_ast(it.ast_id, db),\n+            AttrDefId::ImplId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n+            AttrDefId::ConstId(it) => attrs_from_loc(it.lookup(db), db),\n+            AttrDefId::StaticId(it) => attrs_from_loc(it.lookup(db), db),\n+            AttrDefId::FunctionId(it) => attrs_from_loc(it.lookup(db), db),\n+            AttrDefId::TypeAliasId(it) => attrs_from_loc(it.lookup(db), db),\n+        }\n+    }\n+\n+    fn from_attrs_owner(db: &impl DefDatabase, owner: Source<&dyn AttrsOwner>) -> Attrs {\n+        let hygiene = Hygiene::new(db, owner.file_id);\n+        Attrs::new(owner.value, &hygiene)\n+    }\n+\n+    pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Attrs {\n+        let mut attrs = owner.attrs().peekable();\n+        let entries = if attrs.peek().is_none() {\n+            // Avoid heap allocation\n+            None\n+        } else {\n+            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).collect())\n+        };\n+        Attrs { entries }\n+    }\n+\n+    pub fn by_key(&self, key: &'static str) -> AttrQuery<'_> {\n+        AttrQuery { attrs: self, key }\n+    }\n+}\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n@@ -26,7 +102,7 @@ pub enum AttrInput {\n }\n \n impl Attr {\n-    pub(crate) fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n+    fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n         let path = Path::from_src(ast.path()?, hygiene)?;\n         let input = match ast.input() {\n             None => None,\n@@ -42,43 +118,55 @@ impl Attr {\n \n         Some(Attr { path, input })\n     }\n+}\n \n-    pub fn from_attrs_owner(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Option<Arc<[Attr]>> {\n-        let mut attrs = owner.attrs().peekable();\n-        if attrs.peek().is_none() {\n-            // Avoid heap allocation\n-            return None;\n-        }\n-        Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).collect())\n-    }\n+pub struct AttrQuery<'a> {\n+    attrs: &'a Attrs,\n+    key: &'static str,\n+}\n \n-    pub fn is_simple_atom(&self, name: &str) -> bool {\n-        // FIXME: Avoid cloning\n-        self.path.as_ident().map_or(false, |s| s.to_string() == name)\n+impl<'a> AttrQuery<'a> {\n+    pub fn tt_values(self) -> impl Iterator<Item = &'a Subtree> {\n+        self.attrs().filter_map(|attr| match attr.input.as_ref()? {\n+            AttrInput::TokenTree(it) => Some(it),\n+            _ => None,\n+        })\n     }\n \n-    // FIXME: handle cfg_attr :-)\n-    pub fn as_cfg(&self) -> Option<&Subtree> {\n-        if !self.is_simple_atom(\"cfg\") {\n-            return None;\n-        }\n-        match &self.input {\n-            Some(AttrInput::TokenTree(subtree)) => Some(subtree),\n+    pub fn string_value(self) -> Option<&'a SmolStr> {\n+        self.attrs().find_map(|attr| match attr.input.as_ref()? {\n+            AttrInput::Literal(it) => Some(it),\n             _ => None,\n-        }\n+        })\n     }\n \n-    pub fn as_path(&self) -> Option<&SmolStr> {\n-        if !self.is_simple_atom(\"path\") {\n-            return None;\n-        }\n-        match &self.input {\n-            Some(AttrInput::Literal(it)) => Some(it),\n-            _ => None,\n-        }\n+    pub fn exists(self) -> bool {\n+        self.attrs().next().is_some()\n     }\n \n-    pub fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> Option<bool> {\n-        cfg_options.is_cfg_enabled(self.as_cfg()?)\n+    fn attrs(self) -> impl Iterator<Item = &'a Attr> {\n+        let key = self.key;\n+        self.attrs\n+            .iter()\n+            .filter(move |attr| attr.path.as_ident().map_or(false, |s| s.to_string() == key))\n     }\n }\n+\n+fn attrs_from_ast<D, N>(src: AstId<N>, db: &D) -> Attrs\n+where\n+    N: ast::AttrsOwner,\n+    D: DefDatabase,\n+{\n+    let src = Source::new(src.file_id(), src.to_node(db));\n+    Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n+}\n+\n+fn attrs_from_loc<T, D>(node: T, db: &D) -> Attrs\n+where\n+    T: HasSource,\n+    T::Value: ast::AttrsOwner,\n+    D: DefDatabase,\n+{\n+    let src = node.source(db);\n+    Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n+}"}, {"sha": "d77ccb272ac838d1650072b30a47010a56c3d9e7", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,4 +1,5 @@\n-//! FIXME: write short doc here\n+//! Defines `Body`: a lowered representation of bodies of functions, statics and\n+//! consts.\n mod lower;\n pub mod scope;\n \n@@ -13,30 +14,30 @@ use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    db::DefDatabase2,\n+    db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId},\n     nameres::CrateDefMap,\n     path::Path,\n-    AstItemDef, DefWithBodyId, HasModule, HasSource, Lookup, ModuleId,\n+    DefWithBodyId, HasModule, HasSource, Lookup, ModuleId,\n };\n \n-pub struct Expander {\n+struct Expander {\n     crate_def_map: Arc<CrateDefMap>,\n     current_file_id: HirFileId,\n     hygiene: Hygiene,\n     module: ModuleId,\n }\n \n impl Expander {\n-    pub fn new(db: &impl DefDatabase2, current_file_id: HirFileId, module: ModuleId) -> Expander {\n+    fn new(db: &impl DefDatabase, current_file_id: HirFileId, module: ModuleId) -> Expander {\n         let crate_def_map = db.crate_def_map(module.krate);\n         let hygiene = Hygiene::new(db, current_file_id);\n         Expander { crate_def_map, current_file_id, hygiene, module }\n     }\n \n     fn enter_expand(\n         &mut self,\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         macro_call: ast::MacroCall,\n     ) -> Option<(Mark, ast::Expr)> {\n         let ast_id = AstId::new(\n@@ -67,7 +68,7 @@ impl Expander {\n         None\n     }\n \n-    fn exit(&mut self, db: &impl DefDatabase2, mark: Mark) {\n+    fn exit(&mut self, db: &impl DefDatabase, mark: Mark) {\n         self.hygiene = Hygiene::new(db, mark.file_id);\n         self.current_file_id = mark.file_id;\n         std::mem::forget(mark);\n@@ -81,8 +82,8 @@ impl Expander {\n         Path::from_src(path, &self.hygiene)\n     }\n \n-    fn resolve_path_as_macro(&self, db: &impl DefDatabase2, path: &Path) -> Option<MacroDefId> {\n-        self.crate_def_map.resolve_path(db, self.module.module_id, path).0.get_macros()\n+    fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n+        self.crate_def_map.resolve_path(db, self.module.module_id, path).0.take_macros()\n     }\n }\n \n@@ -101,17 +102,17 @@ impl Drop for Mark {\n /// The body of an item (function, const etc.).\n #[derive(Debug, Eq, PartialEq)]\n pub struct Body {\n-    exprs: Arena<ExprId, Expr>,\n-    pats: Arena<PatId, Pat>,\n+    pub exprs: Arena<ExprId, Expr>,\n+    pub pats: Arena<PatId, Pat>,\n     /// The patterns for the function's parameters. While the parameter types are\n     /// part of the function signature, the patterns are not (they don't change\n     /// the external type of the function).\n     ///\n     /// If this `Body` is for the body of a constant, this will just be\n     /// empty.\n-    params: Vec<PatId>,\n+    pub params: Vec<PatId>,\n     /// The `ExprId` of the actual body expression.\n-    body_expr: ExprId,\n+    pub body_expr: ExprId,\n }\n \n pub type ExprPtr = Either<AstPtr<ast::Expr>, AstPtr<ast::RecordField>>;\n@@ -142,7 +143,7 @@ pub struct BodySourceMap {\n \n impl Body {\n     pub(crate) fn body_with_source_map_query(\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         def: DefWithBodyId,\n     ) -> (Arc<Body>, Arc<BodySourceMap>) {\n         let mut params = None;\n@@ -160,6 +161,7 @@ impl Body {\n                 (src.file_id, c.module(db), src.value.body())\n             }\n             DefWithBodyId::StaticId(s) => {\n+                let s = s.lookup(db);\n                 let src = s.source(db);\n                 (src.file_id, s.module(db), src.value.body())\n             }\n@@ -169,34 +171,18 @@ impl Body {\n         (Arc::new(body), Arc::new(source_map))\n     }\n \n-    pub(crate) fn body_query(db: &impl DefDatabase2, def: DefWithBodyId) -> Arc<Body> {\n+    pub(crate) fn body_query(db: &impl DefDatabase, def: DefWithBodyId) -> Arc<Body> {\n         db.body_with_source_map(def).0\n     }\n \n     fn new(\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         expander: Expander,\n         params: Option<ast::ParamList>,\n         body: Option<ast::Expr>,\n     ) -> (Body, BodySourceMap) {\n         lower::lower(db, expander, params, body)\n     }\n-\n-    pub fn params(&self) -> &[PatId] {\n-        &self.params\n-    }\n-\n-    pub fn body_expr(&self) -> ExprId {\n-        self.body_expr\n-    }\n-\n-    pub fn exprs(&self) -> impl Iterator<Item = (ExprId, &Expr)> {\n-        self.exprs.iter()\n-    }\n-\n-    pub fn pats(&self) -> impl Iterator<Item = (PatId, &Pat)> {\n-        self.pats.iter()\n-    }\n }\n \n impl Index<ExprId> for Body {"}, {"sha": "331736cb23a4fa31203e90883bc1d8e080b2bfb4", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,4 +1,5 @@\n-//! FIXME: write short doc here\n+//! Transforms `ast::Expr` into an equivalent `hir_def::expr::Expr`\n+//! representation.\n \n use hir_expand::{\n     either::Either,\n@@ -17,7 +18,7 @@ use test_utils::tested_by;\n use crate::{\n     body::{Body, BodySourceMap, Expander, PatPtr},\n     builtin_type::{BuiltinFloat, BuiltinInt},\n-    db::DefDatabase2,\n+    db::DefDatabase,\n     expr::{\n         ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n         MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n@@ -28,7 +29,7 @@ use crate::{\n };\n \n pub(super) fn lower(\n-    db: &impl DefDatabase2,\n+    db: &impl DefDatabase,\n     expander: Expander,\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n@@ -57,7 +58,7 @@ struct ExprCollector<DB> {\n \n impl<'a, DB> ExprCollector<&'a DB>\n where\n-    DB: DefDatabase2,\n+    DB: DefDatabase,\n {\n     fn collect(\n         mut self,"}, {"sha": "625aa39dd04f30a97d0d3476583b8f79769cd496", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,4 +1,4 @@\n-//! FIXME: write short doc here\n+//! Name resolution for expressions.\n use std::sync::Arc;\n \n use hir_expand::name::Name;\n@@ -7,7 +7,7 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     body::Body,\n-    db::DefDatabase2,\n+    db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId, Statement},\n     DefWithBodyId,\n };\n@@ -45,7 +45,7 @@ pub struct ScopeData {\n }\n \n impl ExprScopes {\n-    pub(crate) fn expr_scopes_query(db: &impl DefDatabase2, def: DefWithBodyId) -> Arc<ExprScopes> {\n+    pub(crate) fn expr_scopes_query(db: &impl DefDatabase, def: DefWithBodyId) -> Arc<ExprScopes> {\n         let body = db.body(def);\n         Arc::new(ExprScopes::new(&*body))\n     }\n@@ -54,8 +54,8 @@ impl ExprScopes {\n         let mut scopes =\n             ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n         let root = scopes.root_scope();\n-        scopes.add_params_bindings(body, root, body.params());\n-        compute_expr_scopes(body.body_expr(), body, &mut scopes, root);\n+        scopes.add_params_bindings(body, root, &body.params);\n+        compute_expr_scopes(body.body_expr, body, &mut scopes, root);\n         scopes\n     }\n \n@@ -176,7 +176,7 @@ mod tests {\n     use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n     use test_utils::{assert_eq_text, covers, extract_offset};\n \n-    use crate::{db::DefDatabase2, test_db::TestDB, FunctionId, ModuleDefId};\n+    use crate::{db::DefDatabase, test_db::TestDB, FunctionId, ModuleDefId};\n \n     fn find_function(db: &TestDB, file_id: FileId) -> FunctionId {\n         let krate = db.test_crate();"}, {"sha": "68bea34df7c8e83b9dd4e1f691878581f4b6a2ea", "filename": "crates/ra_hir_def/src/data.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -0,0 +1,216 @@\n+//! Contains basic data about various HIR declarations.\n+\n+use std::sync::Arc;\n+\n+use hir_expand::{\n+    name::{self, AsName, Name},\n+    AstId,\n+};\n+use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n+\n+use crate::{\n+    db::DefDatabase,\n+    type_ref::{Mutability, TypeRef},\n+    AssocItemId, AstItemDef, ConstId, ConstLoc, ContainerId, FunctionId, FunctionLoc, HasSource,\n+    ImplId, Intern, Lookup, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct FunctionData {\n+    pub name: Name,\n+    pub params: Vec<TypeRef>,\n+    pub ret_type: TypeRef,\n+    /// True if the first param is `self`. This is relevant to decide whether this\n+    /// can be called as a method.\n+    pub has_self_param: bool,\n+}\n+\n+impl FunctionData {\n+    pub(crate) fn fn_data_query(db: &impl DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n+        let src = func.lookup(db).source(db);\n+        let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n+        let mut params = Vec::new();\n+        let mut has_self_param = false;\n+        if let Some(param_list) = src.value.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n+                    TypeRef::from_ast(type_ref)\n+                } else {\n+                    let self_type = TypeRef::Path(name::SELF_TYPE.into());\n+                    match self_param.kind() {\n+                        ast::SelfParamKind::Owned => self_type,\n+                        ast::SelfParamKind::Ref => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n+                        }\n+                        ast::SelfParamKind::MutRef => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n+                        }\n+                    }\n+                };\n+                params.push(self_type);\n+                has_self_param = true;\n+            }\n+            for param in param_list.params() {\n+                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+                params.push(type_ref);\n+            }\n+        }\n+        let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n+            TypeRef::from_ast(type_ref)\n+        } else {\n+            TypeRef::unit()\n+        };\n+\n+        let sig = FunctionData { name, params, ret_type, has_self_param };\n+        Arc::new(sig)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TypeAliasData {\n+    pub name: Name,\n+    pub type_ref: Option<TypeRef>,\n+}\n+\n+impl TypeAliasData {\n+    pub(crate) fn type_alias_data_query(\n+        db: &impl DefDatabase,\n+        typ: TypeAliasId,\n+    ) -> Arc<TypeAliasData> {\n+        let node = typ.lookup(db).source(db).value;\n+        let name = node.name().map_or_else(Name::missing, |n| n.as_name());\n+        let type_ref = node.type_ref().map(TypeRef::from_ast);\n+        Arc::new(TypeAliasData { name, type_ref })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitData {\n+    pub name: Option<Name>,\n+    pub items: Vec<AssocItemId>,\n+    pub auto: bool,\n+}\n+\n+impl TraitData {\n+    pub(crate) fn trait_data_query(db: &impl DefDatabase, tr: TraitId) -> Arc<TraitData> {\n+        let src = tr.source(db);\n+        let name = src.value.name().map(|n| n.as_name());\n+        let auto = src.value.is_auto();\n+        let ast_id_map = db.ast_id_map(src.file_id);\n+        let items = if let Some(item_list) = src.value.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => FunctionLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                    ast::ImplItem::ConstDef(it) => ConstLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                    ast::ImplItem::TypeAliasDef(it) => TypeAliasLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TraitData { name, items, auto })\n+    }\n+\n+    pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n+        self.items.iter().filter_map(|item| match item {\n+            AssocItemId::TypeAliasId(t) => Some(*t),\n+            _ => None,\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImplData {\n+    pub target_trait: Option<TypeRef>,\n+    pub target_type: TypeRef,\n+    pub items: Vec<AssocItemId>,\n+    pub is_negative: bool,\n+}\n+\n+impl ImplData {\n+    pub(crate) fn impl_data_query(db: &impl DefDatabase, id: ImplId) -> Arc<ImplData> {\n+        let src = id.source(db);\n+        let items = db.ast_id_map(src.file_id);\n+\n+        let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n+        let target_type = TypeRef::from_ast_opt(src.value.target_type());\n+        let is_negative = src.value.is_negative();\n+\n+        let items = if let Some(item_list) = src.value.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => {\n+                        let def = FunctionLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n+                    }\n+                    ast::ImplItem::ConstDef(it) => {\n+                        let def = ConstLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n+                    }\n+                    ast::ImplItem::TypeAliasDef(it) => {\n+                        let def = TypeAliasLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n+                    }\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+\n+        let res = ImplData { target_trait, target_type, items, is_negative };\n+        Arc::new(res)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ConstData {\n+    pub name: Option<Name>,\n+    pub type_ref: TypeRef,\n+}\n+\n+impl ConstData {\n+    pub(crate) fn const_data_query(db: &impl DefDatabase, konst: ConstId) -> Arc<ConstData> {\n+        let node = konst.lookup(db).source(db).value;\n+        Arc::new(ConstData::new(&node))\n+    }\n+\n+    pub(crate) fn static_data_query(db: &impl DefDatabase, konst: StaticId) -> Arc<ConstData> {\n+        let node = konst.lookup(db).source(db).value;\n+        Arc::new(ConstData::new(&node))\n+    }\n+\n+    fn new<N: NameOwner + TypeAscriptionOwner>(node: &N) -> ConstData {\n+        let name = node.name().map(|n| n.as_name());\n+        let type_ref = TypeRef::from_ast_opt(node.ascribed_type());\n+        ConstData { name, type_ref }\n+    }\n+}"}, {"sha": "32adb11bdc4d39e3f6103e7f213b402283878ef7", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -3,43 +3,47 @@ use std::sync::Arc;\n \n use hir_expand::{db::AstDatabase, HirFileId};\n use ra_db::{salsa, CrateId, SourceDatabase};\n-use ra_syntax::ast;\n+use ra_syntax::{ast, SmolStr};\n \n use crate::{\n     adt::{EnumData, StructData},\n+    attr::Attrs,\n     body::{scope::ExprScopes, Body, BodySourceMap},\n+    data::{ConstData, FunctionData, ImplData, TraitData, TypeAliasData},\n+    docs::Documentation,\n     generics::GenericParams,\n-    impls::ImplData,\n+    lang_item::{LangItemTarget, LangItems},\n     nameres::{\n         raw::{ImportSourceMap, RawItems},\n         CrateDefMap,\n     },\n-    traits::TraitData,\n-    DefWithBodyId, EnumId, GenericDefId, ImplId, ItemLoc, StructOrUnionId, TraitId,\n+    AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, FunctionId, FunctionLoc, GenericDefId,\n+    ImplId, ItemLoc, ModuleId, StaticId, StaticLoc, StructOrUnionId, TraitId, TypeAliasId,\n+    TypeAliasLoc,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n-    fn intern_function(&self, loc: crate::FunctionLoc) -> crate::FunctionId;\n+    fn intern_function(&self, loc: FunctionLoc) -> FunctionId;\n     #[salsa::interned]\n-    fn intern_struct_or_union(&self, loc: ItemLoc<ast::StructDef>) -> crate::StructOrUnionId;\n+    fn intern_struct_or_union(&self, loc: ItemLoc<ast::StructDef>) -> StructOrUnionId;\n     #[salsa::interned]\n-    fn intern_enum(&self, loc: ItemLoc<ast::EnumDef>) -> crate::EnumId;\n+    fn intern_enum(&self, loc: ItemLoc<ast::EnumDef>) -> EnumId;\n     #[salsa::interned]\n-    fn intern_const(&self, loc: crate::ConstLoc) -> crate::ConstId;\n+    fn intern_const(&self, loc: ConstLoc) -> ConstId;\n     #[salsa::interned]\n-    fn intern_static(&self, loc: ItemLoc<ast::StaticDef>) -> crate::StaticId;\n+    fn intern_static(&self, loc: StaticLoc) -> StaticId;\n     #[salsa::interned]\n-    fn intern_trait(&self, loc: ItemLoc<ast::TraitDef>) -> crate::TraitId;\n+    fn intern_trait(&self, loc: ItemLoc<ast::TraitDef>) -> TraitId;\n     #[salsa::interned]\n-    fn intern_type_alias(&self, loc: crate::TypeAliasLoc) -> crate::TypeAliasId;\n+    fn intern_type_alias(&self, loc: TypeAliasLoc) -> TypeAliasId;\n     #[salsa::interned]\n-    fn intern_impl(&self, loc: ItemLoc<ast::ImplBlock>) -> crate::ImplId;\n+    fn intern_impl(&self, loc: ItemLoc<ast::ImplBlock>) -> ImplId;\n }\n \n-#[salsa::query_group(DefDatabase2Storage)]\n-pub trait DefDatabase2: InternDatabase + AstDatabase {\n+#[salsa::query_group(DefDatabaseStorage)]\n+pub trait DefDatabase: InternDatabase + AstDatabase {\n     #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n     fn raw_items_with_source_map(\n         &self,\n@@ -64,6 +68,18 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n     #[salsa::invoke(TraitData::trait_data_query)]\n     fn trait_data(&self, e: TraitId) -> Arc<TraitData>;\n \n+    #[salsa::invoke(TypeAliasData::type_alias_data_query)]\n+    fn type_alias_data(&self, e: TypeAliasId) -> Arc<TypeAliasData>;\n+\n+    #[salsa::invoke(FunctionData::fn_data_query)]\n+    fn function_data(&self, func: FunctionId) -> Arc<FunctionData>;\n+\n+    #[salsa::invoke(ConstData::const_data_query)]\n+    fn const_data(&self, konst: ConstId) -> Arc<ConstData>;\n+\n+    #[salsa::invoke(ConstData::static_data_query)]\n+    fn static_data(&self, konst: StaticId) -> Arc<ConstData>;\n+\n     #[salsa::invoke(Body::body_with_source_map_query)]\n     fn body_with_source_map(&self, def: DefWithBodyId) -> (Arc<Body>, Arc<BodySourceMap>);\n \n@@ -75,4 +91,21 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n \n     #[salsa::invoke(GenericParams::generic_params_query)]\n     fn generic_params(&self, def: GenericDefId) -> Arc<GenericParams>;\n+\n+    #[salsa::invoke(Attrs::attrs_query)]\n+    fn attrs(&self, def: AttrDefId) -> Attrs;\n+\n+    #[salsa::invoke(LangItems::module_lang_items_query)]\n+    fn module_lang_items(&self, module: ModuleId) -> Option<Arc<LangItems>>;\n+\n+    #[salsa::invoke(LangItems::crate_lang_items_query)]\n+    fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n+\n+    #[salsa::invoke(LangItems::lang_item_query)]\n+    fn lang_item(&self, start_crate: CrateId, item: SmolStr) -> Option<LangItemTarget>;\n+\n+    // FIXME(https://github.com/rust-analyzer/rust-analyzer/issues/2148#issuecomment-550519102)\n+    // Remove this query completely, in favor of `Attrs::docs` method\n+    #[salsa::invoke(Documentation::documentation_query)]\n+    fn documentation(&self, def: AttrDefId) -> Option<Documentation>;\n }"}, {"sha": "90a8627bc6911990d1211d0c2fc5e685fa0cf02d", "filename": "crates/ra_hir_def/src/docs.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -0,0 +1,71 @@\n+//! Defines hir documentation.\n+//!\n+//! This really shouldn't exist, instead, we should deshugar doc comments into attributes, see\n+//! https://github.com/rust-analyzer/rust-analyzer/issues/2148#issuecomment-550519102\n+\n+use std::sync::Arc;\n+\n+use hir_expand::either::Either;\n+use ra_syntax::ast;\n+\n+use crate::{db::DefDatabase, AdtId, AstItemDef, AttrDefId, HasChildSource, HasSource, Lookup};\n+\n+/// Holds documentation\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Documentation(Arc<str>);\n+\n+impl Into<String> for Documentation {\n+    fn into(self) -> String {\n+        self.as_str().to_owned()\n+    }\n+}\n+\n+impl Documentation {\n+    fn new(s: &str) -> Documentation {\n+        Documentation(s.into())\n+    }\n+\n+    pub fn as_str(&self) -> &str {\n+        &*self.0\n+    }\n+\n+    pub(crate) fn documentation_query(\n+        db: &impl DefDatabase,\n+        def: AttrDefId,\n+    ) -> Option<Documentation> {\n+        match def {\n+            AttrDefId::ModuleId(module) => {\n+                let def_map = db.crate_def_map(module.krate);\n+                let src = def_map[module.module_id].declaration_source(db)?;\n+                docs_from_ast(&src.value)\n+            }\n+            AttrDefId::StructFieldId(it) => {\n+                let src = it.parent.child_source(db);\n+                match &src.value[it.local_id] {\n+                    Either::A(_tuple) => None,\n+                    Either::B(record) => docs_from_ast(record),\n+                }\n+            }\n+            AttrDefId::AdtId(it) => match it {\n+                AdtId::StructId(it) => docs_from_ast(&it.0.source(db).value),\n+                AdtId::EnumId(it) => docs_from_ast(&it.source(db).value),\n+                AdtId::UnionId(it) => docs_from_ast(&it.0.source(db).value),\n+            },\n+            AttrDefId::EnumVariantId(it) => {\n+                let src = it.parent.child_source(db);\n+                docs_from_ast(&src.value[it.local_id])\n+            }\n+            AttrDefId::TraitId(it) => docs_from_ast(&it.source(db).value),\n+            AttrDefId::MacroDefId(it) => docs_from_ast(&it.ast_id.to_node(db)),\n+            AttrDefId::ConstId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n+            AttrDefId::StaticId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n+            AttrDefId::FunctionId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n+            AttrDefId::TypeAliasId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n+            AttrDefId::ImplId(_) => None,\n+        }\n+    }\n+}\n+\n+pub(crate) fn docs_from_ast(node: &impl ast::DocCommentsOwner) -> Option<Documentation> {\n+    node.doc_comment_text().map(|it| Documentation::new(&it))\n+}"}, {"sha": "015fe772e54b38fdfcda032421173d824422e928", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -8,7 +8,7 @@ use hir_expand::name::{self, AsName, Name};\n use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n \n use crate::{\n-    db::DefDatabase2,\n+    db::DefDatabase,\n     type_ref::{TypeBound, TypeRef},\n     AdtId, AstItemDef, ContainerId, GenericDefId, HasSource, Lookup,\n };\n@@ -42,15 +42,15 @@ pub struct WherePredicate {\n \n impl GenericParams {\n     pub(crate) fn generic_params_query(\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         def: GenericDefId,\n     ) -> Arc<GenericParams> {\n         let parent_generics = parent_generic_def(db, def).map(|it| db.generic_params(it));\n         Arc::new(GenericParams::new(db, def.into(), parent_generics))\n     }\n \n     fn new(\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         def: GenericDefId,\n         parent_params: Option<Arc<GenericParams>>,\n     ) -> GenericParams {\n@@ -168,7 +168,7 @@ impl GenericParams {\n     }\n }\n \n-fn parent_generic_def(db: &impl DefDatabase2, def: GenericDefId) -> Option<GenericDefId> {\n+fn parent_generic_def(db: &impl DefDatabase, def: GenericDefId) -> Option<GenericDefId> {\n     let container = match def {\n         GenericDefId::FunctionId(it) => it.lookup(db).container,\n         GenericDefId::TypeAliasId(it) => it.lookup(db).container,"}, {"sha": "750a869f256fa9cc02e5669ec5094d91bb7a716e", "filename": "crates/ra_hir_def/src/impls.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs?ref=eb7363d167c7a9f7c73cb950b621eb1dce493318", "patch": "@@ -1,86 +0,0 @@\n-//! Defines hir-level representation of impls.\n-//!\n-//! The handling is similar, but is not quite the same as for other items,\n-//! because `impl`s don't have names.\n-\n-use std::sync::Arc;\n-\n-use hir_expand::AstId;\n-use ra_syntax::ast;\n-\n-use crate::{\n-    db::DefDatabase2, type_ref::TypeRef, AssocItemId, AstItemDef, ConstLoc, ContainerId,\n-    FunctionLoc, ImplId, Intern, TypeAliasLoc,\n-};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ImplData {\n-    target_trait: Option<TypeRef>,\n-    target_type: TypeRef,\n-    items: Vec<AssocItemId>,\n-    negative: bool,\n-}\n-\n-impl ImplData {\n-    pub(crate) fn impl_data_query(db: &impl DefDatabase2, id: ImplId) -> Arc<ImplData> {\n-        let src = id.source(db);\n-        let items = db.ast_id_map(src.file_id);\n-\n-        let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n-        let target_type = TypeRef::from_ast_opt(src.value.target_type());\n-        let negative = src.value.is_negative();\n-\n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => {\n-                        let def = FunctionLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                    ast::ImplItem::ConstDef(it) => {\n-                        let def = ConstLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                    ast::ImplItem::TypeAliasDef(it) => {\n-                        let def = TypeAliasLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n-\n-        let res = ImplData { target_trait, target_type, items, negative };\n-        Arc::new(res)\n-    }\n-\n-    pub fn target_trait(&self) -> Option<&TypeRef> {\n-        self.target_trait.as_ref()\n-    }\n-\n-    pub fn target_type(&self) -> &TypeRef {\n-        &self.target_type\n-    }\n-\n-    pub fn items(&self) -> &[AssocItemId] {\n-        &self.items\n-    }\n-\n-    pub fn is_negative(&self) -> bool {\n-        self.negative\n-    }\n-}"}, {"sha": "f15c23db9df815dab2aa2b0dc89f3162049d8a26", "filename": "crates/ra_hir_def/src/lang_item.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -0,0 +1,121 @@\n+//! Collects lang items: items marked with `#[lang = \"...\"]` attribute.\n+//!\n+//! This attribute to tell the compiler about semi built-in std library\n+//! features, such as Fn family of traits.\n+use std::sync::Arc;\n+\n+use ra_syntax::SmolStr;\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    db::DefDatabase, AdtId, AttrDefId, CrateId, EnumId, FunctionId, ImplId, ModuleDefId, ModuleId,\n+    StaticId, StructId, TraitId,\n+};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum LangItemTarget {\n+    EnumId(EnumId),\n+    FunctionId(FunctionId),\n+    ImplBlockId(ImplId),\n+    StaticId(StaticId),\n+    StructId(StructId),\n+    TraitId(TraitId),\n+}\n+\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub struct LangItems {\n+    items: FxHashMap<SmolStr, LangItemTarget>,\n+}\n+\n+impl LangItems {\n+    pub fn target<'a>(&'a self, item: &str) -> Option<&'a LangItemTarget> {\n+        self.items.get(item)\n+    }\n+\n+    /// Salsa query. This will look for lang items in a specific crate.\n+    pub(crate) fn crate_lang_items_query(db: &impl DefDatabase, krate: CrateId) -> Arc<LangItems> {\n+        let mut lang_items = LangItems::default();\n+\n+        let crate_def_map = db.crate_def_map(krate);\n+\n+        crate_def_map\n+            .modules\n+            .iter()\n+            .filter_map(|(module_id, _)| db.module_lang_items(ModuleId { krate, module_id }))\n+            .for_each(|it| lang_items.items.extend(it.items.iter().map(|(k, v)| (k.clone(), *v))));\n+\n+        Arc::new(lang_items)\n+    }\n+\n+    pub(crate) fn module_lang_items_query(\n+        db: &impl DefDatabase,\n+        module: ModuleId,\n+    ) -> Option<Arc<LangItems>> {\n+        let mut lang_items = LangItems::default();\n+        lang_items.collect_lang_items(db, module);\n+        if lang_items.items.is_empty() {\n+            None\n+        } else {\n+            Some(Arc::new(lang_items))\n+        }\n+    }\n+\n+    /// Salsa query. Look for a lang item, starting from the specified crate and recursively\n+    /// traversing its dependencies.\n+    pub(crate) fn lang_item_query(\n+        db: &impl DefDatabase,\n+        start_crate: CrateId,\n+        item: SmolStr,\n+    ) -> Option<LangItemTarget> {\n+        let lang_items = db.crate_lang_items(start_crate);\n+        let start_crate_target = lang_items.items.get(&item);\n+        if let Some(target) = start_crate_target {\n+            return Some(*target);\n+        }\n+        db.crate_graph()\n+            .dependencies(start_crate)\n+            .find_map(|dep| db.lang_item(dep.crate_id, item.clone()))\n+    }\n+\n+    fn collect_lang_items(&mut self, db: &impl DefDatabase, module: ModuleId) {\n+        // Look for impl targets\n+        let def_map = db.crate_def_map(module.krate);\n+        let module_data = &def_map[module.module_id];\n+        for &impl_block in module_data.impls.iter() {\n+            self.collect_lang_item(db, impl_block, LangItemTarget::ImplBlockId)\n+        }\n+\n+        for def in module_data.scope.declarations() {\n+            match def {\n+                ModuleDefId::TraitId(trait_) => {\n+                    self.collect_lang_item(db, trait_, LangItemTarget::TraitId)\n+                }\n+                ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n+                    self.collect_lang_item(db, e, LangItemTarget::EnumId)\n+                }\n+                ModuleDefId::AdtId(AdtId::StructId(s)) => {\n+                    self.collect_lang_item(db, s, LangItemTarget::StructId)\n+                }\n+                ModuleDefId::FunctionId(f) => {\n+                    self.collect_lang_item(db, f, LangItemTarget::FunctionId)\n+                }\n+                ModuleDefId::StaticId(s) => self.collect_lang_item(db, s, LangItemTarget::StaticId),\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    fn collect_lang_item<T>(\n+        &mut self,\n+        db: &impl DefDatabase,\n+        item: T,\n+        constructor: fn(T) -> LangItemTarget,\n+    ) where\n+        T: Into<AttrDefId> + Copy,\n+    {\n+        let attrs = db.attrs(item.into());\n+        if let Some(lang_item_name) = attrs.by_key(\"lang\").string_value() {\n+            self.items.entry(lang_item_name.clone()).or_insert_with(|| constructor(item));\n+        }\n+    }\n+}"}, {"sha": "8e8c2d74908fec8e162e25ca18173bd3ae6cf449", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 127, "deletions": 131, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -8,121 +8,56 @@\n //! actually true.\n \n pub mod db;\n+\n pub mod attr;\n pub mod path;\n pub mod type_ref;\n pub mod builtin_type;\n-pub mod adt;\n-pub mod impls;\n pub mod diagnostics;\n+pub mod per_ns;\n+\n+pub mod adt;\n+pub mod data;\n+pub mod generics;\n+pub mod lang_item;\n+pub mod docs;\n+\n pub mod expr;\n pub mod body;\n-pub mod generics;\n-pub mod traits;\n pub mod resolver;\n \n+mod trace;\n+mod nameres;\n+\n #[cfg(test)]\n mod test_db;\n #[cfg(test)]\n mod marks;\n \n-// FIXME: this should be private\n-pub mod nameres;\n-\n use std::hash::{Hash, Hasher};\n \n-use hir_expand::{ast_id_map::FileAstId, db::AstDatabase, AstId, HirFileId, Source};\n-use ra_arena::{impl_arena_id, RawId};\n-use ra_db::{salsa, CrateId, FileId};\n-use ra_syntax::{ast, AstNode, SyntaxNode};\n+use hir_expand::{ast_id_map::FileAstId, db::AstDatabase, AstId, HirFileId, MacroDefId, Source};\n+use ra_arena::{impl_arena_id, map::ArenaMap, RawId};\n+use ra_db::{impl_intern_key, salsa, CrateId};\n+use ra_syntax::{ast, AstNode};\n \n use crate::{builtin_type::BuiltinType, db::InternDatabase};\n \n-pub enum ModuleSource {\n-    SourceFile(ast::SourceFile),\n-    Module(ast::Module),\n-}\n-\n-impl ModuleSource {\n-    pub fn new(\n-        db: &impl db::DefDatabase2,\n-        file_id: Option<FileId>,\n-        decl_id: Option<AstId<ast::Module>>,\n-    ) -> ModuleSource {\n-        match (file_id, decl_id) {\n-            (Some(file_id), _) => {\n-                let source_file = db.parse(file_id).tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-            (None, Some(item_id)) => {\n-                let module = item_id.to_node(db);\n-                assert!(module.item_list().is_some(), \"expected inline module\");\n-                ModuleSource::Module(module)\n-            }\n-            (None, None) => panic!(),\n-        }\n-    }\n-\n-    // FIXME: this methods do not belong here\n-    pub fn from_position(\n-        db: &impl db::DefDatabase2,\n-        position: ra_db::FilePosition,\n-    ) -> ModuleSource {\n-        let parse = db.parse(position.file_id);\n-        match &ra_syntax::algo::find_node_at_offset::<ast::Module>(\n-            parse.tree().syntax(),\n-            position.offset,\n-        ) {\n-            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n-            _ => {\n-                let source_file = parse.tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-        }\n-    }\n-\n-    pub fn from_child_node(db: &impl db::DefDatabase2, child: Source<&SyntaxNode>) -> ModuleSource {\n-        if let Some(m) =\n-            child.value.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi())\n-        {\n-            ModuleSource::Module(m)\n-        } else {\n-            let file_id = child.file_id.original_file(db);\n-            let source_file = db.parse(file_id).tree();\n-            ModuleSource::SourceFile(source_file)\n-        }\n-    }\n-\n-    pub fn from_file_id(db: &impl db::DefDatabase2, file_id: FileId) -> ModuleSource {\n-        let source_file = db.parse(file_id).tree();\n-        ModuleSource::SourceFile(source_file)\n-    }\n-}\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct LocalImportId(RawId);\n+impl_arena_id!(LocalImportId);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n     pub krate: CrateId,\n-    pub module_id: CrateModuleId,\n+    pub module_id: LocalModuleId,\n }\n \n /// An ID of a module, **local** to a specific crate\n // FIXME: rename to `LocalModuleId`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct CrateModuleId(RawId);\n-impl_arena_id!(CrateModuleId);\n-\n-macro_rules! impl_intern_key {\n-    ($name:ident) => {\n-        impl salsa::InternKey for $name {\n-            fn from_intern_id(v: salsa::InternId) -> Self {\n-                $name(v)\n-            }\n-            fn as_intern_id(&self) -> salsa::InternId {\n-                self.0\n-            }\n-        }\n-    };\n-}\n+pub struct LocalModuleId(RawId);\n+impl_arena_id!(LocalModuleId);\n \n #[derive(Debug)]\n pub struct ItemLoc<N: AstNode> {\n@@ -162,25 +97,10 @@ impl<'a, DB> LocationCtx<&'a DB> {\n     }\n }\n \n-impl<'a, DB: AstDatabase + InternDatabase> LocationCtx<&'a DB> {\n-    pub fn to_def<N, DEF>(self, ast: &N) -> DEF\n-    where\n-        N: AstNode,\n-        DEF: AstItemDef<N>,\n-    {\n-        DEF::from_ast(self, ast)\n-    }\n-}\n-\n pub trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n     fn intern(db: &impl InternDatabase, loc: ItemLoc<N>) -> Self;\n     fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<N>;\n \n-    fn from_ast(ctx: LocationCtx<&(impl AstDatabase + InternDatabase)>, ast: &N) -> Self {\n-        let items = ctx.db.ast_id_map(ctx.file_id);\n-        let item_id = items.ast_id(ast);\n-        Self::from_ast_id(ctx, item_id)\n-    }\n     fn from_ast_id(ctx: LocationCtx<&impl InternDatabase>, ast_id: FileAstId<N>) -> Self {\n         let loc = ItemLoc { module: ctx.module, ast_id: AstId::new(ctx.file_id, ast_id) };\n         Self::intern(ctx.db, loc)\n@@ -208,14 +128,14 @@ pub struct FunctionLoc {\n \n impl Intern for FunctionLoc {\n     type ID = FunctionId;\n-    fn intern(self, db: &impl db::DefDatabase2) -> FunctionId {\n+    fn intern(self, db: &impl db::DefDatabase) -> FunctionId {\n         db.intern_function(self)\n     }\n }\n \n impl Lookup for FunctionId {\n     type Data = FunctionLoc;\n-    fn lookup(&self, db: &impl db::DefDatabase2) -> FunctionLoc {\n+    fn lookup(&self, db: &impl db::DefDatabase) -> FunctionLoc {\n         db.lookup_intern_function(*self)\n     }\n }\n@@ -271,16 +191,10 @@ pub struct EnumVariantId {\n pub struct LocalEnumVariantId(RawId);\n impl_arena_id!(LocalEnumVariantId);\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum VariantId {\n-    EnumVariantId(EnumVariantId),\n-    StructId(StructId),\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StructFieldId {\n-    parent: VariantId,\n-    local_id: LocalStructFieldId,\n+    pub parent: VariantId,\n+    pub local_id: LocalStructFieldId,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -298,27 +212,39 @@ pub struct ConstLoc {\n \n impl Intern for ConstLoc {\n     type ID = ConstId;\n-    fn intern(self, db: &impl db::DefDatabase2) -> ConstId {\n+    fn intern(self, db: &impl db::DefDatabase) -> ConstId {\n         db.intern_const(self)\n     }\n }\n \n impl Lookup for ConstId {\n     type Data = ConstLoc;\n-    fn lookup(&self, db: &impl db::DefDatabase2) -> ConstLoc {\n+    fn lookup(&self, db: &impl db::DefDatabase) -> ConstLoc {\n         db.lookup_intern_const(*self)\n     }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StaticId(salsa::InternId);\n impl_intern_key!(StaticId);\n-impl AstItemDef<ast::StaticDef> for StaticId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StaticDef>) -> Self {\n-        db.intern_static(loc)\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct StaticLoc {\n+    pub container: ModuleId,\n+    pub ast_id: AstId<ast::StaticDef>,\n+}\n+\n+impl Intern for StaticLoc {\n+    type ID = StaticId;\n+    fn intern(self, db: &impl db::DefDatabase) -> StaticId {\n+        db.intern_static(self)\n     }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StaticDef> {\n-        db.lookup_intern_static(self)\n+}\n+\n+impl Lookup for StaticId {\n+    type Data = StaticLoc;\n+    fn lookup(&self, db: &impl db::DefDatabase) -> StaticLoc {\n+        db.lookup_intern_static(*self)\n     }\n }\n \n@@ -346,14 +272,14 @@ pub struct TypeAliasLoc {\n \n impl Intern for TypeAliasLoc {\n     type ID = TypeAliasId;\n-    fn intern(self, db: &impl db::DefDatabase2) -> TypeAliasId {\n+    fn intern(self, db: &impl db::DefDatabase) -> TypeAliasId {\n         db.intern_type_alias(self)\n     }\n }\n \n impl Lookup for TypeAliasId {\n     type Data = TypeAliasLoc;\n-    fn lookup(&self, db: &impl db::DefDatabase2) -> TypeAliasLoc {\n+    fn lookup(&self, db: &impl db::DefDatabase) -> TypeAliasLoc {\n         db.lookup_intern_type_alias(*self)\n     }\n }\n@@ -476,22 +402,58 @@ impl_froms!(\n     ConstId\n );\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum AttrDefId {\n+    ModuleId(ModuleId),\n+    StructFieldId(StructFieldId),\n+    AdtId(AdtId),\n+    FunctionId(FunctionId),\n+    EnumVariantId(EnumVariantId),\n+    StaticId(StaticId),\n+    ConstId(ConstId),\n+    TraitId(TraitId),\n+    TypeAliasId(TypeAliasId),\n+    MacroDefId(MacroDefId),\n+    ImplId(ImplId),\n+}\n+\n+impl_froms!(\n+    AttrDefId: ModuleId,\n+    StructFieldId,\n+    AdtId(StructId, EnumId, UnionId),\n+    EnumVariantId,\n+    StaticId,\n+    ConstId,\n+    FunctionId,\n+    TraitId,\n+    TypeAliasId,\n+    MacroDefId,\n+    ImplId\n+);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum VariantId {\n+    EnumVariantId(EnumVariantId),\n+    StructId(StructId),\n+}\n+impl_froms!(VariantId: EnumVariantId, StructId);\n+\n trait Intern {\n     type ID;\n-    fn intern(self, db: &impl db::DefDatabase2) -> Self::ID;\n+    fn intern(self, db: &impl db::DefDatabase) -> Self::ID;\n }\n \n pub trait Lookup {\n     type Data;\n-    fn lookup(&self, db: &impl db::DefDatabase2) -> Self::Data;\n+    fn lookup(&self, db: &impl db::DefDatabase) -> Self::Data;\n }\n \n pub trait HasModule {\n-    fn module(&self, db: &impl db::DefDatabase2) -> ModuleId;\n+    fn module(&self, db: &impl db::DefDatabase) -> ModuleId;\n }\n \n impl HasModule for FunctionLoc {\n-    fn module(&self, db: &impl db::DefDatabase2) -> ModuleId {\n+    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n         match self.container {\n             ContainerId::ModuleId(it) => it,\n             ContainerId::ImplId(it) => it.module(db),\n@@ -501,7 +463,7 @@ impl HasModule for FunctionLoc {\n }\n \n impl HasModule for TypeAliasLoc {\n-    fn module(&self, db: &impl db::DefDatabase2) -> ModuleId {\n+    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n         match self.container {\n             ContainerId::ModuleId(it) => it,\n             ContainerId::ImplId(it) => it.module(db),\n@@ -511,7 +473,7 @@ impl HasModule for TypeAliasLoc {\n }\n \n impl HasModule for ConstLoc {\n-    fn module(&self, db: &impl db::DefDatabase2) -> ModuleId {\n+    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n         match self.container {\n             ContainerId::ModuleId(it) => it,\n             ContainerId::ImplId(it) => it.module(db),\n@@ -520,15 +482,31 @@ impl HasModule for ConstLoc {\n     }\n }\n \n+impl HasModule for AdtId {\n+    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+        match self {\n+            AdtId::StructId(it) => it.0.module(db),\n+            AdtId::UnionId(it) => it.0.module(db),\n+            AdtId::EnumId(it) => it.module(db),\n+        }\n+    }\n+}\n+\n+impl HasModule for StaticLoc {\n+    fn module(&self, _db: &impl db::DefDatabase) -> ModuleId {\n+        self.container\n+    }\n+}\n+\n pub trait HasSource {\n     type Value;\n-    fn source(&self, db: &impl db::DefDatabase2) -> Source<Self::Value>;\n+    fn source(&self, db: &impl db::DefDatabase) -> Source<Self::Value>;\n }\n \n impl HasSource for FunctionLoc {\n     type Value = ast::FnDef;\n \n-    fn source(&self, db: &impl db::DefDatabase2) -> Source<ast::FnDef> {\n+    fn source(&self, db: &impl db::DefDatabase) -> Source<ast::FnDef> {\n         let node = self.ast_id.to_node(db);\n         Source::new(self.ast_id.file_id(), node)\n     }\n@@ -537,7 +515,7 @@ impl HasSource for FunctionLoc {\n impl HasSource for TypeAliasLoc {\n     type Value = ast::TypeAliasDef;\n \n-    fn source(&self, db: &impl db::DefDatabase2) -> Source<ast::TypeAliasDef> {\n+    fn source(&self, db: &impl db::DefDatabase) -> Source<ast::TypeAliasDef> {\n         let node = self.ast_id.to_node(db);\n         Source::new(self.ast_id.file_id(), node)\n     }\n@@ -546,8 +524,26 @@ impl HasSource for TypeAliasLoc {\n impl HasSource for ConstLoc {\n     type Value = ast::ConstDef;\n \n-    fn source(&self, db: &impl db::DefDatabase2) -> Source<ast::ConstDef> {\n+    fn source(&self, db: &impl db::DefDatabase) -> Source<ast::ConstDef> {\n         let node = self.ast_id.to_node(db);\n         Source::new(self.ast_id.file_id(), node)\n     }\n }\n+\n+impl HasSource for StaticLoc {\n+    type Value = ast::StaticDef;\n+\n+    fn source(&self, db: &impl db::DefDatabase) -> Source<ast::StaticDef> {\n+        let node = self.ast_id.to_node(db);\n+        Source::new(self.ast_id.file_id(), node)\n+    }\n+}\n+\n+pub trait HasChildSource {\n+    type ChildId;\n+    type Value;\n+    fn child_source(\n+        &self,\n+        db: &impl db::DefDatabase,\n+    ) -> Source<ArenaMap<Self::ChildId, Self::Value>>;\n+}"}, {"sha": "2359386c2806c51ba4e6e0aff9176c1088f75238", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 62, "deletions": 68, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -47,8 +47,7 @@\n //! path and, upon success, we run macro expansion and \"collect module\" phase on\n //! the result\n \n-pub mod raw;\n-pub mod per_ns;\n+pub(crate) mod raw;\n mod collector;\n mod mod_resolution;\n mod path_resolution;\n@@ -58,70 +57,63 @@ mod tests;\n \n use std::sync::Arc;\n \n-use hir_expand::{ast_id_map::FileAstId, diagnostics::DiagnosticSink, name::Name, MacroDefId};\n+use hir_expand::{\n+    ast_id_map::FileAstId, diagnostics::DiagnosticSink, either::Either, name::Name, MacroDefId,\n+    Source,\n+};\n use once_cell::sync::Lazy;\n use ra_arena::Arena;\n use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n use ra_syntax::ast;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n \n use crate::{\n     builtin_type::BuiltinType,\n-    db::DefDatabase2,\n-    nameres::{\n-        diagnostics::DefDiagnostic, path_resolution::ResolveMode, per_ns::PerNs, raw::ImportId,\n-    },\n+    db::DefDatabase,\n+    nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode},\n     path::Path,\n-    AstId, CrateModuleId, FunctionId, ImplId, ModuleDefId, ModuleId, TraitId,\n+    per_ns::PerNs,\n+    AstId, FunctionId, ImplId, LocalImportId, LocalModuleId, ModuleDefId, ModuleId, TraitId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateDefMap {\n-    krate: CrateId,\n-    edition: Edition,\n+    pub root: LocalModuleId,\n+    pub modules: Arena<LocalModuleId, ModuleData>,\n+    pub(crate) krate: CrateId,\n     /// The prelude module for this crate. This either comes from an import\n     /// marked with the `prelude_import` attribute, or (in the normal case) from\n     /// a dependency (`std` or `core`).\n-    prelude: Option<ModuleId>,\n-    extern_prelude: FxHashMap<Name, ModuleDefId>,\n-    root: CrateModuleId,\n-    modules: Arena<CrateModuleId, ModuleData>,\n-\n-    /// Some macros are not well-behavior, which leads to infinite loop\n-    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n-    /// We mark it down and skip it in collector\n-    ///\n-    /// FIXME:\n-    /// Right now it only handle a poison macro in a single crate,\n-    /// such that if other crate try to call that macro,\n-    /// the whole process will do again until it became poisoned in that crate.\n-    /// We should handle this macro set globally\n-    /// However, do we want to put it as a global variable?\n-    poison_macros: FxHashSet<MacroDefId>,\n+    pub(crate) prelude: Option<ModuleId>,\n+    pub(crate) extern_prelude: FxHashMap<Name, ModuleDefId>,\n \n+    edition: Edition,\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n-impl std::ops::Index<CrateModuleId> for CrateDefMap {\n+impl std::ops::Index<LocalModuleId> for CrateDefMap {\n     type Output = ModuleData;\n-    fn index(&self, id: CrateModuleId) -> &ModuleData {\n+    fn index(&self, id: LocalModuleId) -> &ModuleData {\n         &self.modules[id]\n     }\n }\n \n #[derive(Default, Debug, PartialEq, Eq)]\n pub struct ModuleData {\n-    pub parent: Option<CrateModuleId>,\n-    pub children: FxHashMap<Name, CrateModuleId>,\n+    pub parent: Option<LocalModuleId>,\n+    pub children: FxHashMap<Name, LocalModuleId>,\n     pub scope: ModuleScope,\n+\n+    //  FIXME: these can't be both null, we need a three-state enum here.\n     /// None for root\n     pub declaration: Option<AstId<ast::Module>>,\n     /// None for inline modules.\n     ///\n     /// Note that non-inline modules, by definition, live inside non-macro file.\n     pub definition: Option<FileId>,\n+\n     pub impls: Vec<ImplId>,\n }\n \n@@ -177,7 +169,7 @@ impl ModuleScope {\n     pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n         self.items\n             .iter()\n-            .filter_map(|(name, res)| res.def.get_macros().map(|macro_| (name, macro_)))\n+            .filter_map(|(name, res)| res.def.take_macros().map(|macro_| (name, macro_)))\n     }\n \n     /// Iterate over all legacy textual scoped macros visable at the end of the module\n@@ -207,21 +199,21 @@ pub struct Resolution {\n     /// None for unresolved\n     pub def: PerNs,\n     /// ident by which this is imported into local scope.\n-    pub import: Option<ImportId>,\n+    pub import: Option<LocalImportId>,\n }\n \n impl CrateDefMap {\n     pub(crate) fn crate_def_map_query(\n         // Note that this doesn't have `+ AstDatabase`!\n         // This gurantess that `CrateDefMap` is stable across reparses.\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         krate: CrateId,\n     ) -> Arc<CrateDefMap> {\n         let _p = profile(\"crate_def_map_query\");\n         let def_map = {\n             let crate_graph = db.crate_graph();\n             let edition = crate_graph.edition(krate);\n-            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let mut modules: Arena<LocalModuleId, ModuleData> = Arena::default();\n             let root = modules.alloc(ModuleData::default());\n             CrateDefMap {\n                 krate,\n@@ -230,58 +222,60 @@ impl CrateDefMap {\n                 prelude: None,\n                 root,\n                 modules,\n-                poison_macros: FxHashSet::default(),\n                 diagnostics: Vec::new(),\n             }\n         };\n         let def_map = collector::collect_defs(db, def_map);\n         Arc::new(def_map)\n     }\n \n-    pub fn krate(&self) -> CrateId {\n-        self.krate\n-    }\n-\n-    pub fn root(&self) -> CrateModuleId {\n-        self.root\n-    }\n-\n-    pub fn prelude(&self) -> Option<ModuleId> {\n-        self.prelude\n-    }\n-\n-    pub fn extern_prelude(&self) -> &FxHashMap<Name, ModuleDefId> {\n-        &self.extern_prelude\n-    }\n-\n     pub fn add_diagnostics(\n         &self,\n-        db: &impl DefDatabase2,\n-        module: CrateModuleId,\n+        db: &impl DefDatabase,\n+        module: LocalModuleId,\n         sink: &mut DiagnosticSink,\n     ) {\n         self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n     }\n \n-    pub fn resolve_path(\n+    pub fn modules_for_file(&self, file_id: FileId) -> impl Iterator<Item = LocalModuleId> + '_ {\n+        self.modules\n+            .iter()\n+            .filter(move |(_id, data)| data.definition == Some(file_id))\n+            .map(|(id, _data)| id)\n+    }\n+\n+    pub(crate) fn resolve_path(\n         &self,\n-        db: &impl DefDatabase2,\n-        original_module: CrateModuleId,\n+        db: &impl DefDatabase,\n+        original_module: LocalModuleId,\n         path: &Path,\n     ) -> (PerNs, Option<usize>) {\n         let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n         (res.resolved_def, res.segment_index)\n     }\n+}\n \n-    pub fn modules(&self) -> impl Iterator<Item = CrateModuleId> + '_ {\n-        self.modules.iter().map(|(id, _data)| id)\n+impl ModuleData {\n+    /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n+    pub fn definition_source(\n+        &self,\n+        db: &impl DefDatabase,\n+    ) -> Source<Either<ast::SourceFile, ast::Module>> {\n+        if let Some(file_id) = self.definition {\n+            let sf = db.parse(file_id).tree();\n+            return Source::new(file_id.into(), Either::A(sf));\n+        }\n+        let decl = self.declaration.unwrap();\n+        Source::new(decl.file_id(), Either::B(decl.to_node(db)))\n     }\n \n-    pub fn modules_for_file(&self, file_id: FileId) -> impl Iterator<Item = CrateModuleId> + '_ {\n-        self.modules\n-            .iter()\n-            .filter(move |(_id, data)| data.definition == Some(file_id))\n-            .map(|(id, _data)| id)\n+    /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n+    /// `None` for the crate root.\n+    pub fn declaration_source(&self, db: &impl DefDatabase) -> Option<Source<ast::Module>> {\n+        let decl = self.declaration?;\n+        let value = decl.to_node(db);\n+        Some(Source { file_id: decl.file_id(), value })\n     }\n }\n \n@@ -290,12 +284,12 @@ mod diagnostics {\n     use ra_db::RelativePathBuf;\n     use ra_syntax::{ast, AstPtr};\n \n-    use crate::{db::DefDatabase2, diagnostics::UnresolvedModule, nameres::CrateModuleId, AstId};\n+    use crate::{db::DefDatabase, diagnostics::UnresolvedModule, nameres::LocalModuleId, AstId};\n \n     #[derive(Debug, PartialEq, Eq)]\n     pub(super) enum DefDiagnostic {\n         UnresolvedModule {\n-            module: CrateModuleId,\n+            module: LocalModuleId,\n             declaration: AstId<ast::Module>,\n             candidate: RelativePathBuf,\n         },\n@@ -304,8 +298,8 @@ mod diagnostics {\n     impl DefDiagnostic {\n         pub(super) fn add_to(\n             &self,\n-            db: &impl DefDatabase2,\n-            target_module: CrateModuleId,\n+            db: &impl DefDatabase,\n+            target_module: LocalModuleId,\n             sink: &mut DiagnosticSink,\n         ) {\n             match self {"}, {"sha": "41becf8dffd22bab59f4f1563a7721f32a33c01a", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 80, "deletions": 61, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,4 +1,7 @@\n-//! FIXME: write short doc here\n+//! The core of the module-level name resolution algorithm.\n+//!\n+//! `DefCollector::collect` contains the fixed-point iteration loop which\n+//! resolves imports and expands macros.\n \n use hir_expand::{\n     builtin_macro::find_builtin_macro,\n@@ -7,24 +10,25 @@ use hir_expand::{\n };\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId};\n-use ra_syntax::{ast, SmolStr};\n-use rustc_hash::FxHashMap;\n+use ra_syntax::ast;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use test_utils::tested_by;\n \n use crate::{\n-    attr::Attr,\n-    db::DefDatabase2,\n+    attr::Attrs,\n+    db::DefDatabase,\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n-        per_ns::PerNs, raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n+        raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n     },\n     path::{Path, PathKind},\n-    AdtId, AstId, AstItemDef, ConstLoc, ContainerId, CrateModuleId, EnumId, EnumVariantId,\n-    FunctionLoc, ImplId, Intern, LocationCtx, ModuleDefId, ModuleId, StaticId, StructId,\n+    per_ns::PerNs,\n+    AdtId, AstId, AstItemDef, ConstLoc, ContainerId, EnumId, EnumVariantId, FunctionLoc, ImplId,\n+    Intern, LocalImportId, LocalModuleId, LocationCtx, ModuleDefId, ModuleId, StaticLoc, StructId,\n     StructOrUnionId, TraitId, TypeAliasLoc, UnionId,\n };\n \n-pub(super) fn collect_defs(db: &impl DefDatabase2, mut def_map: CrateDefMap) -> CrateDefMap {\n+pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n     let crate_graph = db.crate_graph();\n \n     // populate external prelude\n@@ -56,6 +60,7 @@ pub(super) fn collect_defs(db: &impl DefDatabase2, mut def_map: CrateDefMap) ->\n         unexpanded_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n         macro_stack_monitor: MacroStackMonitor::default(),\n+        poison_macros: FxHashSet::default(),\n         cfg_options,\n     };\n     collector.collect();\n@@ -94,21 +99,32 @@ impl MacroStackMonitor {\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n-    glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n-    unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n-    unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n-    mod_dirs: FxHashMap<CrateModuleId, ModDir>,\n+    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, LocalImportId)>>,\n+    unresolved_imports: Vec<(LocalModuleId, LocalImportId, raw::ImportData)>,\n+    unexpanded_macros: Vec<(LocalModuleId, AstId<ast::MacroCall>, Path)>,\n+    mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n \n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stack overflow, we add a deep counter here for prevent that.\n     macro_stack_monitor: MacroStackMonitor,\n+    /// Some macros are not well-behavior, which leads to infinite loop\n+    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n+    /// We mark it down and skip it in collector\n+    ///\n+    /// FIXME:\n+    /// Right now it only handle a poison macro in a single crate,\n+    /// such that if other crate try to call that macro,\n+    /// the whole process will do again until it became poisoned in that crate.\n+    /// We should handle this macro set globally\n+    /// However, do we want to put it as a global variable?\n+    poison_macros: FxHashSet<MacroDefId>,\n \n     cfg_options: &'a CfgOptions,\n }\n \n impl<DB> DefCollector<'_, DB>\n where\n-    DB: DefDatabase2,\n+    DB: DefDatabase,\n {\n     fn collect(&mut self) {\n         let crate_graph = self.db.crate_graph();\n@@ -173,7 +189,7 @@ where\n     /// ```\n     fn define_macro(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         name: Name,\n         macro_: MacroDefId,\n         export: bool,\n@@ -200,15 +216,15 @@ where\n     /// the definition of current module.\n     /// And also, `macro_use` on a module will import all legacy macros visable inside to\n     /// current legacy scope, with possible shadowing.\n-    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_: MacroDefId) {\n+    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, macro_: MacroDefId) {\n         // Always shadowing\n         self.def_map.modules[module_id].scope.legacy_macros.insert(name, macro_);\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n     fn import_macros_from_extern_crate(\n         &mut self,\n-        current_module_id: CrateModuleId,\n+        current_module_id: LocalModuleId,\n         import: &raw::ImportData,\n     ) {\n         log::debug!(\n@@ -235,7 +251,7 @@ where\n     /// Exported macros are just all macros in the root module scope.\n     /// Note that it contains not only all `#[macro_export]` macros, but also all aliases\n     /// created by `use` in the root module, ignoring the visibility of `use`.\n-    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, krate: CrateId) {\n+    fn import_all_macros_exported(&mut self, current_module_id: LocalModuleId, krate: CrateId) {\n         let def_map = self.db.crate_def_map(krate);\n         for (name, def) in def_map[def_map.root].scope.macros() {\n             // `macro_use` only bring things into legacy scope.\n@@ -265,7 +281,7 @@ where\n \n     fn resolve_import(\n         &self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         import: &raw::ImportData,\n     ) -> (PerNs, ReachedFixedPoint) {\n         log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n@@ -291,9 +307,9 @@ where\n \n     fn record_resolved_import(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         def: PerNs,\n-        import_id: raw::ImportId,\n+        import_id: LocalImportId,\n         import: &raw::ImportData,\n     ) {\n         if import.is_glob {\n@@ -387,17 +403,17 @@ where\n \n     fn update(\n         &mut self,\n-        module_id: CrateModuleId,\n-        import: Option<raw::ImportId>,\n+        module_id: LocalModuleId,\n+        import: Option<LocalImportId>,\n         resolutions: &[(Name, Resolution)],\n     ) {\n         self.update_recursive(module_id, import, resolutions, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n-        module_id: CrateModuleId,\n-        import: Option<raw::ImportId>,\n+        module_id: LocalModuleId,\n+        import: Option<LocalImportId>,\n         resolutions: &[(Name, Resolution)],\n         depth: usize,\n     ) {\n@@ -463,7 +479,7 @@ where\n                 path,\n             );\n \n-            if let Some(def) = resolved_res.resolved_def.get_macros() {\n+            if let Some(def) = resolved_res.resolved_def.take_macros() {\n                 let call_id = self.db.intern_macro(MacroCallLoc { def, ast_id: *ast_id });\n                 resolved.push((*module_id, call_id, def));\n                 res = ReachedFixedPoint::No;\n@@ -484,11 +500,11 @@ where\n \n     fn collect_macro_expansion(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         macro_call_id: MacroCallId,\n         macro_def_id: MacroDefId,\n     ) {\n-        if self.def_map.poison_macros.contains(&macro_def_id) {\n+        if self.poison_macros.contains(&macro_def_id) {\n             return;\n         }\n \n@@ -508,7 +524,7 @@ where\n             .collect(raw_items.items());\n         } else {\n             log::error!(\"Too deep macro expansion: {:?}\", macro_call_id);\n-            self.def_map.poison_macros.insert(macro_def_id);\n+            self.poison_macros.insert(macro_def_id);\n         }\n \n         self.macro_stack_monitor.decrease(macro_def_id);\n@@ -522,15 +538,15 @@ where\n /// Walks a single module, populating defs, imports and macros\n struct ModCollector<'a, D> {\n     def_collector: D,\n-    module_id: CrateModuleId,\n+    module_id: LocalModuleId,\n     file_id: HirFileId,\n     raw_items: &'a raw::RawItems,\n     mod_dir: ModDir,\n }\n \n impl<DB> ModCollector<'_, &'_ mut DefCollector<'_, DB>>\n where\n-    DB: DefDatabase2,\n+    DB: DefDatabase,\n {\n     fn collect(&mut self, items: &[raw::RawItem]) {\n         // Note: don't assert that inserted value is fresh: it's simply not true\n@@ -549,7 +565,7 @@ where\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n         for item in items {\n-            if self.is_cfg_enabled(item.attrs()) {\n+            if self.is_cfg_enabled(&item.attrs) {\n                 if let raw::RawItemKind::Import(import_id) = item.kind {\n                     let import = self.raw_items[import_id].clone();\n                     if import.is_extern_crate && import.is_macro_use {\n@@ -560,10 +576,10 @@ where\n         }\n \n         for item in items {\n-            if self.is_cfg_enabled(item.attrs()) {\n+            if self.is_cfg_enabled(&item.attrs) {\n                 match item.kind {\n                     raw::RawItemKind::Module(m) => {\n-                        self.collect_module(&self.raw_items[m], item.attrs())\n+                        self.collect_module(&self.raw_items[m], &item.attrs)\n                     }\n                     raw::RawItemKind::Import(import_id) => self\n                         .def_collector\n@@ -585,9 +601,9 @@ where\n         }\n     }\n \n-    fn collect_module(&mut self, module: &raw::ModuleData, attrs: &[Attr]) {\n-        let path_attr = self.path_attr(attrs);\n-        let is_macro_use = self.is_macro_use(attrs);\n+    fn collect_module(&mut self, module: &raw::ModuleData, attrs: &Attrs) {\n+        let path_attr = attrs.by_key(\"path\").string_value();\n+        let is_macro_use = attrs.by_key(\"macro_use\").exists();\n         match module {\n             // inline module, just recurse\n             raw::ModuleData::Definition { name, items, ast_id } => {\n@@ -647,7 +663,7 @@ where\n         name: Name,\n         declaration: AstId<ast::Module>,\n         definition: Option<FileId>,\n-    ) -> CrateModuleId {\n+    ) -> LocalModuleId {\n         let modules = &mut self.def_collector.def_map.modules;\n         let res = modules.alloc(ModuleData::default());\n         modules[res].parent = Some(self.module_id);\n@@ -702,7 +718,10 @@ where\n                 PerNs::values(def.into())\n             }\n             raw::DefKind::Static(ast_id) => {\n-                PerNs::values(StaticId::from_ast_id(ctx, ast_id).into())\n+                let def = StaticLoc { container: module, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db);\n+\n+                PerNs::values(def.into())\n             }\n             raw::DefKind::Trait(ast_id) => PerNs::types(TraitId::from_ast_id(ctx, ast_id).into()),\n             raw::DefKind::TypeAlias(ast_id) => {\n@@ -772,23 +791,19 @@ where\n         self.def_collector.unexpanded_macros.push((self.module_id, ast_id, path));\n     }\n \n-    fn import_all_legacy_macros(&mut self, module_id: CrateModuleId) {\n+    fn import_all_legacy_macros(&mut self, module_id: LocalModuleId) {\n         let macros = self.def_collector.def_map[module_id].scope.legacy_macros.clone();\n         for (name, macro_) in macros {\n             self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_);\n         }\n     }\n \n-    fn is_cfg_enabled(&self, attrs: &[Attr]) -> bool {\n-        attrs.iter().all(|attr| attr.is_cfg_enabled(&self.def_collector.cfg_options) != Some(false))\n-    }\n-\n-    fn path_attr<'a>(&self, attrs: &'a [Attr]) -> Option<&'a SmolStr> {\n-        attrs.iter().find_map(|attr| attr.as_path())\n-    }\n-\n-    fn is_macro_use<'a>(&self, attrs: &'a [Attr]) -> bool {\n-        attrs.iter().any(|attr| attr.is_simple_atom(\"macro_use\"))\n+    fn is_cfg_enabled(&self, attrs: &Attrs) -> bool {\n+        // FIXME: handle cfg_attr :-)\n+        attrs\n+            .by_key(\"cfg\")\n+            .tt_values()\n+            .all(|tt| self.def_collector.cfg_options.is_cfg_enabled(tt) != Some(false))\n     }\n }\n \n@@ -802,15 +817,15 @@ mod tests {\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n     use rustc_hash::FxHashSet;\n \n-    use crate::{db::DefDatabase2, test_db::TestDB};\n+    use crate::{db::DefDatabase, test_db::TestDB};\n \n     use super::*;\n \n     fn do_collect_defs(\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         def_map: CrateDefMap,\n         monitor: MacroStackMonitor,\n-    ) -> CrateDefMap {\n+    ) -> (CrateDefMap, FxHashSet<MacroDefId>) {\n         let mut collector = DefCollector {\n             db,\n             def_map,\n@@ -819,19 +834,24 @@ mod tests {\n             unexpanded_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n             macro_stack_monitor: monitor,\n+            poison_macros: FxHashSet::default(),\n             cfg_options: &CfgOptions::default(),\n         };\n         collector.collect();\n-        collector.finish()\n+        (collector.def_map, collector.poison_macros)\n     }\n \n-    fn do_limited_resolve(code: &str, limit: u32, poison_limit: u32) -> CrateDefMap {\n+    fn do_limited_resolve(\n+        code: &str,\n+        limit: u32,\n+        poison_limit: u32,\n+    ) -> (CrateDefMap, FxHashSet<MacroDefId>) {\n         let (db, _file_id) = TestDB::with_single_file(&code);\n         let krate = db.test_crate();\n \n         let def_map = {\n             let edition = db.crate_graph().edition(krate);\n-            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let mut modules: Arena<LocalModuleId, ModuleData> = Arena::default();\n             let root = modules.alloc(ModuleData::default());\n             CrateDefMap {\n                 krate,\n@@ -840,7 +860,6 @@ mod tests {\n                 prelude: None,\n                 root,\n                 modules,\n-                poison_macros: FxHashSet::default(),\n                 diagnostics: Vec::new(),\n             }\n         };\n@@ -870,7 +889,7 @@ foo!(KABOOM);\n \n     #[test]\n     fn test_macro_expand_poisoned() {\n-        let def = do_limited_resolve(\n+        let (_, poison_macros) = do_limited_resolve(\n             r#\"\n         macro_rules! foo {\n             ($ty:ty) => { foo!($ty); }\n@@ -881,12 +900,12 @@ foo!(KABOOM);\n             16,\n         );\n \n-        assert_eq!(def.poison_macros.len(), 1);\n+        assert_eq!(poison_macros.len(), 1);\n     }\n \n     #[test]\n     fn test_macro_expand_normal() {\n-        let def = do_limited_resolve(\n+        let (_, poison_macros) = do_limited_resolve(\n             r#\"\n         macro_rules! foo {\n             ($ident:ident) => { struct $ident {} }\n@@ -897,6 +916,6 @@ foo!(Bar);\n             16,\n         );\n \n-        assert_eq!(def.poison_macros.len(), 0);\n+        assert_eq!(poison_macros.len(), 0);\n     }\n }"}, {"sha": "14fb8ba3a734eccdabd7b099e2b77935f9b187c7", "filename": "crates/ra_hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -3,7 +3,7 @@ use hir_expand::name::Name;\n use ra_db::{FileId, RelativePathBuf};\n use ra_syntax::SmolStr;\n \n-use crate::{db::DefDatabase2, HirFileId};\n+use crate::{db::DefDatabase, HirFileId};\n \n #[derive(Clone, Debug)]\n pub(super) struct ModDir {\n@@ -40,7 +40,7 @@ impl ModDir {\n \n     pub(super) fn resolve_declaration(\n         &self,\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         file_id: HirFileId,\n         name: &Name,\n         attr_path: Option<&SmolStr>,"}, {"sha": "9455f22bbd6fe155dd81f2210fcbe227a411e2bd", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -15,10 +15,11 @@ use ra_db::Edition;\n use test_utils::tested_by;\n \n use crate::{\n-    db::DefDatabase2,\n-    nameres::{per_ns::PerNs, CrateDefMap},\n+    db::DefDatabase,\n+    nameres::CrateDefMap,\n     path::{Path, PathKind},\n-    AdtId, CrateModuleId, EnumVariantId, ModuleDefId, ModuleId,\n+    per_ns::PerNs,\n+    AdtId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -63,9 +64,9 @@ impl CrateDefMap {\n     // the result.\n     pub(super) fn resolve_path_fp_with_macro(\n         &self,\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         mode: ResolveMode,\n-        original_module: CrateModuleId,\n+        original_module: LocalModuleId,\n         path: &Path,\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n@@ -216,8 +217,8 @@ impl CrateDefMap {\n \n     fn resolve_name_in_module(\n         &self,\n-        db: &impl DefDatabase2,\n-        module: CrateModuleId,\n+        db: &impl DefDatabase,\n+        module: LocalModuleId,\n         name: &Name,\n     ) -> PerNs {\n         // Resolve in:\n@@ -243,7 +244,7 @@ impl CrateDefMap {\n         from_crate_root.or(from_extern_prelude)\n     }\n \n-    fn resolve_in_prelude(&self, db: &impl DefDatabase2, name: &Name) -> PerNs {\n+    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs {\n         if let Some(prelude) = self.prelude {\n             let keep;\n             let def_map = if prelude.krate == self.krate {"}, {"sha": "401af031cc8feeaf38434b38561840b7e34f4a2e", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 30, "deletions": 46, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,4 +1,9 @@\n-//! FIXME: write short doc here\n+//! Lowers syntax tree of a rust file into a raw representation of containing\n+//! items, *without* attaching them to a module structure.\n+//!\n+//! That is, raw items don't have semantics, just as syntax, but, unlike syntax,\n+//! they don't change with trivial source code edits, making them a great tool\n+//! for building salsa recomputation firewalls.\n \n use std::{ops::Index, sync::Arc};\n \n@@ -12,11 +17,14 @@ use hir_expand::{\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n-    AstNode, AstPtr, SourceFile,\n+    AstNode, AstPtr,\n };\n use test_utils::tested_by;\n \n-use crate::{attr::Attr, db::DefDatabase2, path::Path, FileAstId, HirFileId, ModuleSource, Source};\n+use crate::{\n+    attr::Attrs, db::DefDatabase, path::Path, trace::Trace, FileAstId, HirFileId, LocalImportId,\n+    Source,\n+};\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n ///\n@@ -25,7 +33,7 @@ use crate::{attr::Attr, db::DefDatabase2, path::Path, FileAstId, HirFileId, Modu\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct RawItems {\n     modules: Arena<Module, ModuleData>,\n-    imports: Arena<ImportId, ImportData>,\n+    imports: Arena<LocalImportId, ImportData>,\n     defs: Arena<Def, DefData>,\n     macros: Arena<Macro, MacroData>,\n     impls: Arena<Impl, ImplData>,\n@@ -35,47 +43,33 @@ pub struct RawItems {\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ImportSourceMap {\n-    map: ArenaMap<ImportId, ImportSourcePtr>,\n+    map: ArenaMap<LocalImportId, ImportSourcePtr>,\n }\n \n type ImportSourcePtr = Either<AstPtr<ast::UseTree>, AstPtr<ast::ExternCrateItem>>;\n-type ImportSource = Either<ast::UseTree, ast::ExternCrateItem>;\n-\n-fn to_node(ptr: ImportSourcePtr, file: &SourceFile) -> ImportSource {\n-    ptr.map(|ptr| ptr.to_node(file.syntax()), |ptr| ptr.to_node(file.syntax()))\n-}\n \n impl ImportSourceMap {\n-    fn insert(&mut self, import: ImportId, ptr: ImportSourcePtr) {\n-        self.map.insert(import, ptr)\n-    }\n-\n-    pub fn get(&self, source: &ModuleSource, import: ImportId) -> ImportSource {\n-        let file = match source {\n-            ModuleSource::SourceFile(file) => file.clone(),\n-            ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n-        };\n-\n-        to_node(self.map[import], &file)\n+    pub fn get(&self, import: LocalImportId) -> ImportSourcePtr {\n+        self.map[import].clone()\n     }\n }\n \n impl RawItems {\n     pub(crate) fn raw_items_query(\n-        db: &(impl DefDatabase2 + AstDatabase),\n+        db: &(impl DefDatabase + AstDatabase),\n         file_id: HirFileId,\n     ) -> Arc<RawItems> {\n         db.raw_items_with_source_map(file_id).0\n     }\n \n     pub(crate) fn raw_items_with_source_map_query(\n-        db: &(impl DefDatabase2 + AstDatabase),\n+        db: &(impl DefDatabase + AstDatabase),\n         file_id: HirFileId,\n     ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n             source_ast_id_map: db.ast_id_map(file_id),\n-            source_map: ImportSourceMap::default(),\n+            imports: Trace::new(),\n             file_id,\n             hygiene: Hygiene::new(db, file_id),\n         };\n@@ -86,7 +80,11 @@ impl RawItems {\n                 collector.process_module(None, item_list);\n             }\n         }\n-        (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n+        let mut raw_items = collector.raw_items;\n+        let (arena, map) = collector.imports.into_arena_and_map();\n+        raw_items.imports = arena;\n+        let source_map = ImportSourceMap { map };\n+        (Arc::new(raw_items), Arc::new(source_map))\n     }\n \n     pub(super) fn items(&self) -> &[RawItem] {\n@@ -101,9 +99,9 @@ impl Index<Module> for RawItems {\n     }\n }\n \n-impl Index<ImportId> for RawItems {\n+impl Index<LocalImportId> for RawItems {\n     type Output = ImportData;\n-    fn index(&self, idx: ImportId) -> &ImportData {\n+    fn index(&self, idx: LocalImportId) -> &ImportData {\n         &self.imports[idx]\n     }\n }\n@@ -129,25 +127,16 @@ impl Index<Impl> for RawItems {\n     }\n }\n \n-// Avoid heap allocation on items without attributes.\n-type Attrs = Option<Arc<[Attr]>>;\n-\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub(super) struct RawItem {\n-    attrs: Attrs,\n+    pub(super) attrs: Attrs,\n     pub(super) kind: RawItemKind,\n }\n \n-impl RawItem {\n-    pub(super) fn attrs(&self) -> &[Attr] {\n-        self.attrs.as_ref().map_or(&[], |it| &*it)\n-    }\n-}\n-\n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub(super) enum RawItemKind {\n     Module(Module),\n-    Import(ImportId),\n+    Import(LocalImportId),\n     Def(Def),\n     Macro(Macro),\n     Impl(Impl),\n@@ -163,10 +152,6 @@ pub(super) enum ModuleData {\n     Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ImportId(RawId);\n-impl_arena_id!(ImportId);\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n     pub(super) path: Path,\n@@ -223,8 +208,8 @@ pub(super) struct ImplData {\n \n struct RawItemsCollector {\n     raw_items: RawItems,\n+    imports: Trace<LocalImportId, ImportData, ImportSourcePtr>,\n     source_ast_id_map: Arc<AstIdMap>,\n-    source_map: ImportSourceMap,\n     file_id: HirFileId,\n     hygiene: Hygiene,\n }\n@@ -408,8 +393,7 @@ impl RawItemsCollector {\n         data: ImportData,\n         source: ImportSourcePtr,\n     ) {\n-        let import = self.raw_items.imports.alloc(data);\n-        self.source_map.insert(import, source);\n+        let import = self.imports.alloc(|| source, || data);\n         self.push_item(current_module, attrs, RawItemKind::Import(import))\n     }\n \n@@ -425,6 +409,6 @@ impl RawItemsCollector {\n     }\n \n     fn parse_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n-        Attr::from_attrs_owner(item, &self.hygiene)\n+        Attrs::new(item, &self.hygiene)\n     }\n }"}, {"sha": "f502f1cb30e1eb11a0b999c2463e06fac4045c9c", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -10,7 +10,7 @@ use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, SourceDatabase};\n use test_utils::covers;\n \n-use crate::{db::DefDatabase2, nameres::*, test_db::TestDB, CrateModuleId};\n+use crate::{db::DefDatabase, nameres::*, test_db::TestDB, LocalModuleId};\n \n fn def_map(fixtute: &str) -> String {\n     let dm = compute_crate_def_map(fixtute);\n@@ -25,10 +25,10 @@ fn compute_crate_def_map(fixture: &str) -> Arc<CrateDefMap> {\n \n fn render_crate_def_map(map: &CrateDefMap) -> String {\n     let mut buf = String::new();\n-    go(&mut buf, map, \"\\ncrate\", map.root());\n+    go(&mut buf, map, \"\\ncrate\", map.root);\n     return buf.trim().to_string();\n \n-    fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: CrateModuleId) {\n+    fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: LocalModuleId) {\n         *buf += path;\n         *buf += \"\\n\";\n "}, {"sha": "e11530062d2bd8904492510c16a1b23fbf0796c9", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -665,7 +665,7 @@ fn unresolved_module_diagnostics() {\n         @r###\"\n     [\n         UnresolvedModule {\n-            module: CrateModuleId(\n+            module: LocalModuleId(\n                 0,\n             ),\n             declaration: AstId {"}, {"sha": "0e606fd0e819dbfa348d42a7cf2a144a1a2d8da9", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,4 +1,4 @@\n-//! FIXME: write short doc here\n+//! A desugared representation of paths like `crate::foo` or `<Type as Trait>::bar`.\n \n use std::{iter, sync::Arc};\n \n@@ -66,7 +66,7 @@ pub enum PathKind {\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n-    pub fn expand_use_item(\n+    pub(crate) fn expand_use_item(\n         item_src: Source<ast::UseItem>,\n         hygiene: &Hygiene,\n         mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n@@ -76,7 +76,10 @@ impl Path {\n         }\n     }\n \n-    pub fn from_simple_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> Path {\n+    pub(crate) fn from_simple_segments(\n+        kind: PathKind,\n+        segments: impl IntoIterator<Item = Name>,\n+    ) -> Path {\n         Path {\n             kind,\n             segments: segments\n@@ -94,7 +97,7 @@ impl Path {\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n-    pub fn from_src(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n+    pub(crate) fn from_src(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -192,7 +195,7 @@ impl Path {\n     }\n \n     /// Converts an `ast::NameRef` into a single-identifier `Path`.\n-    pub fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n+    pub(crate) fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n         name_ref.as_name().into()\n     }\n \n@@ -227,7 +230,7 @@ impl Path {\n }\n \n impl GenericArgs {\n-    pub fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n+    pub(crate) fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n         let mut args = Vec::new();\n         for type_arg in node.type_args() {\n             let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());"}, {"sha": "00e866bf9ff97afb5fed1f6eb8479f0f7412106e", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "renamed", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,4 +1,7 @@\n-//! FIXME: write short doc here\n+//! In rust, it is possible to have a value, a type and a macro with the same\n+//! name without conflicts.\n+//!\n+//! `PerNs` (per namespace) captures this.\n \n use hir_expand::MacroDefId;\n \n@@ -44,10 +47,6 @@ impl PerNs {\n         self.types.is_none() && self.values.is_none() && self.macros.is_none()\n     }\n \n-    pub fn is_all(&self) -> bool {\n-        self.types.is_some() && self.values.is_some() && self.macros.is_some()\n-    }\n-\n     pub fn take_types(self) -> Option<ModuleDefId> {\n         self.types\n     }\n@@ -56,14 +55,10 @@ impl PerNs {\n         self.values\n     }\n \n-    pub fn get_macros(&self) -> Option<MacroDefId> {\n+    pub fn take_macros(self) -> Option<MacroDefId> {\n         self.macros\n     }\n \n-    pub fn only_macros(&self) -> PerNs {\n-        PerNs { types: None, values: None, macros: self.macros }\n-    }\n-\n     pub fn or(self, other: PerNs) -> PerNs {\n         PerNs {\n             types: self.types.or(other.types),", "previous_filename": "crates/ra_hir_def/src/nameres/per_ns.rs"}, {"sha": "95b3c926dc28febbc311db35302c3f8a6eb173ea", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 46, "deletions": 55, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -11,14 +11,15 @@ use rustc_hash::FxHashSet;\n use crate::{\n     body::scope::{ExprScopes, ScopeId},\n     builtin_type::BuiltinType,\n-    db::DefDatabase2,\n+    db::DefDatabase,\n     expr::{ExprId, PatId},\n     generics::GenericParams,\n-    nameres::{per_ns::PerNs, CrateDefMap},\n+    nameres::CrateDefMap,\n     path::{Path, PathKind},\n-    AdtId, AstItemDef, ConstId, ContainerId, CrateModuleId, DefWithBodyId, EnumId, EnumVariantId,\n-    FunctionId, GenericDefId, ImplId, Lookup, ModuleDefId, ModuleId, StaticId, StructId, TraitId,\n-    TypeAliasId,\n+    per_ns::PerNs,\n+    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n+    GenericDefId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId,\n+    StructId, TraitId, TypeAliasId,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -28,20 +29,20 @@ pub struct Resolver {\n \n // FIXME how to store these best\n #[derive(Debug, Clone)]\n-pub(crate) struct ModuleItemMap {\n+struct ModuleItemMap {\n     crate_def_map: Arc<CrateDefMap>,\n-    module_id: CrateModuleId,\n+    module_id: LocalModuleId,\n }\n \n #[derive(Debug, Clone)]\n-pub(crate) struct ExprScope {\n+struct ExprScope {\n     owner: DefWithBodyId,\n     expr_scopes: Arc<ExprScopes>,\n     scope_id: ScopeId,\n }\n \n #[derive(Debug, Clone)]\n-pub(crate) enum Scope {\n+enum Scope {\n     /// All the items and imported names of a module\n     ModuleScope(ModuleItemMap),\n     /// Brings the generic parameters of an item into scope\n@@ -87,7 +88,7 @@ pub enum ValueNs {\n \n impl Resolver {\n     /// Resolve known trait from std, like `std::futures::Future`\n-    pub fn resolve_known_trait(&self, db: &impl DefDatabase2, path: &Path) -> Option<TraitId> {\n+    pub fn resolve_known_trait(&self, db: &impl DefDatabase, path: &Path) -> Option<TraitId> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n             ModuleDefId::TraitId(it) => Some(it),\n@@ -96,7 +97,7 @@ impl Resolver {\n     }\n \n     /// Resolve known struct from std, like `std::boxed::Box`\n-    pub fn resolve_known_struct(&self, db: &impl DefDatabase2, path: &Path) -> Option<StructId> {\n+    pub fn resolve_known_struct(&self, db: &impl DefDatabase, path: &Path) -> Option<StructId> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n             ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it),\n@@ -105,7 +106,7 @@ impl Resolver {\n     }\n \n     /// Resolve known enum from std, like `std::result::Result`\n-    pub fn resolve_known_enum(&self, db: &impl DefDatabase2, path: &Path) -> Option<EnumId> {\n+    pub fn resolve_known_enum(&self, db: &impl DefDatabase, path: &Path) -> Option<EnumId> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n             ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it),\n@@ -114,7 +115,7 @@ impl Resolver {\n     }\n \n     /// pub only for source-binder\n-    pub fn resolve_module_path(&self, db: &impl DefDatabase2, path: &Path) -> PerNs {\n+    pub fn resolve_module_path(&self, db: &impl DefDatabase, path: &Path) -> PerNs {\n         let (item_map, module) = match self.module() {\n             Some(it) => it,\n             None => return PerNs::none(),\n@@ -128,7 +129,7 @@ impl Resolver {\n \n     pub fn resolve_path_in_type_ns(\n         &self,\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         path: &Path,\n     ) -> Option<(TypeNs, Option<usize>)> {\n         if path.is_type_relative() {\n@@ -184,7 +185,7 @@ impl Resolver {\n \n     pub fn resolve_path_in_type_ns_fully(\n         &self,\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         path: &Path,\n     ) -> Option<TypeNs> {\n         let (res, unresolved) = self.resolve_path_in_type_ns(db, path)?;\n@@ -196,7 +197,7 @@ impl Resolver {\n \n     pub fn resolve_path_in_value_ns<'p>(\n         &self,\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         path: &'p Path,\n     ) -> Option<ResolveValueResult> {\n         if path.is_type_relative() {\n@@ -296,7 +297,7 @@ impl Resolver {\n \n     pub fn resolve_path_in_value_ns_fully(\n         &self,\n-        db: &impl DefDatabase2,\n+        db: &impl DefDatabase,\n         path: &Path,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n@@ -305,22 +306,22 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_path_as_macro(&self, db: &impl DefDatabase2, path: &Path) -> Option<MacroDefId> {\n+    pub fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n         let (item_map, module) = self.module()?;\n-        item_map.resolve_path(db, module, path).0.get_macros()\n+        item_map.resolve_path(db, module, path).0.take_macros()\n     }\n \n-    pub fn process_all_names(&self, db: &impl DefDatabase2, f: &mut dyn FnMut(Name, ScopeDef)) {\n+    pub fn process_all_names(&self, db: &impl DefDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n         for scope in self.scopes.iter().rev() {\n             scope.process_names(db, f);\n         }\n     }\n \n-    pub fn traits_in_scope(&self, db: &impl DefDatabase2) -> FxHashSet<TraitId> {\n+    pub fn traits_in_scope(&self, db: &impl DefDatabase) -> FxHashSet<TraitId> {\n         let mut traits = FxHashSet::default();\n         for scope in &self.scopes {\n             if let Scope::ModuleScope(m) = scope {\n-                if let Some(prelude) = m.crate_def_map.prelude() {\n+                if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n                     traits.extend(prelude_def_map[prelude.module_id].scope.traits());\n                 }\n@@ -330,7 +331,7 @@ impl Resolver {\n         traits\n     }\n \n-    fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n+    fn module(&self) -> Option<(&CrateDefMap, LocalModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),\n \n@@ -339,7 +340,7 @@ impl Resolver {\n     }\n \n     pub fn krate(&self) -> Option<CrateId> {\n-        self.module().map(|t| t.0.krate())\n+        self.module().map(|t| t.0.krate)\n     }\n \n     pub fn where_predicates_in_scope<'a>(\n@@ -378,7 +379,7 @@ pub enum ScopeDef {\n }\n \n impl Scope {\n-    fn process_names(&self, db: &impl DefDatabase2, f: &mut dyn FnMut(Name, ScopeDef)) {\n+    fn process_names(&self, db: &impl DefDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n         match self {\n             Scope::ModuleScope(m) => {\n                 // FIXME: should we provide `self` here?\n@@ -394,10 +395,10 @@ impl Scope {\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n                     f(name.clone(), ScopeDef::PerNs(PerNs::macros(macro_)));\n                 });\n-                m.crate_def_map.extern_prelude().iter().for_each(|(name, &def)| {\n+                m.crate_def_map.extern_prelude.iter().for_each(|(name, &def)| {\n                     f(name.clone(), ScopeDef::PerNs(PerNs::types(def.into())));\n                 });\n-                if let Some(prelude) = m.crate_def_map.prelude() {\n+                if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n                     prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n                         f(name.clone(), ScopeDef::PerNs(res.def));\n@@ -425,17 +426,13 @@ impl Scope {\n }\n \n // needs arbitrary_self_types to be a method... or maybe move to the def?\n-pub fn resolver_for_expr(\n-    db: &impl DefDatabase2,\n-    owner: DefWithBodyId,\n-    expr_id: ExprId,\n-) -> Resolver {\n+pub fn resolver_for_expr(db: &impl DefDatabase, owner: DefWithBodyId, expr_id: ExprId) -> Resolver {\n     let scopes = db.expr_scopes(owner);\n     resolver_for_scope(db, owner, scopes.scope_for(expr_id))\n }\n \n pub fn resolver_for_scope(\n-    db: &impl DefDatabase2,\n+    db: &impl DefDatabase,\n     owner: DefWithBodyId,\n     scope_id: Option<ScopeId>,\n ) -> Resolver {\n@@ -454,7 +451,7 @@ impl Resolver {\n         self\n     }\n \n-    fn push_generic_params_scope(self, db: &impl DefDatabase2, def: GenericDefId) -> Resolver {\n+    fn push_generic_params_scope(self, db: &impl DefDatabase, def: GenericDefId) -> Resolver {\n         let params = db.generic_params(def);\n         if params.params.is_empty() {\n             self\n@@ -470,7 +467,7 @@ impl Resolver {\n     fn push_module_scope(\n         self,\n         crate_def_map: Arc<CrateDefMap>,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n     ) -> Resolver {\n         self.push_scope(Scope::ModuleScope(ModuleItemMap { crate_def_map, module_id }))\n     }\n@@ -487,46 +484,40 @@ impl Resolver {\n \n pub trait HasResolver {\n     /// Builds a resolver for type references inside this def.\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver;\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver;\n }\n \n impl HasResolver for ModuleId {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         let def_map = db.crate_def_map(self.krate);\n         Resolver::default().push_module_scope(def_map, self.module_id)\n     }\n }\n \n impl HasResolver for TraitId {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         self.module(db).resolver(db).push_generic_params_scope(db, self.into())\n     }\n }\n \n impl<T: Into<AdtId>> HasResolver for T {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         let def = self.into();\n-        let module = match def {\n-            AdtId::StructId(it) => it.0.module(db),\n-            AdtId::UnionId(it) => it.0.module(db),\n-            AdtId::EnumId(it) => it.module(db),\n-        };\n-\n-        module\n+        def.module(db)\n             .resolver(db)\n             .push_generic_params_scope(db, def.into())\n             .push_scope(Scope::AdtScope(def))\n     }\n }\n \n impl HasResolver for FunctionId {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         self.lookup(db).container.resolver(db).push_generic_params_scope(db, self.into())\n     }\n }\n \n impl HasResolver for DefWithBodyId {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         match self {\n             DefWithBodyId::ConstId(c) => c.resolver(db),\n             DefWithBodyId::FunctionId(f) => f.resolver(db),\n@@ -536,25 +527,25 @@ impl HasResolver for DefWithBodyId {\n }\n \n impl HasResolver for ConstId {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         self.lookup(db).container.resolver(db)\n     }\n }\n \n impl HasResolver for StaticId {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n-        self.module(db).resolver(db)\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        self.lookup(db).container.resolver(db)\n     }\n }\n \n impl HasResolver for TypeAliasId {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         self.lookup(db).container.resolver(db).push_generic_params_scope(db, self.into())\n     }\n }\n \n impl HasResolver for ContainerId {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         match self {\n             ContainerId::TraitId(it) => it.resolver(db),\n             ContainerId::ImplId(it) => it.resolver(db),\n@@ -564,7 +555,7 @@ impl HasResolver for ContainerId {\n }\n \n impl HasResolver for GenericDefId {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         match self {\n             GenericDefId::FunctionId(inner) => inner.resolver(db),\n             GenericDefId::AdtId(adt) => adt.resolver(db),\n@@ -578,7 +569,7 @@ impl HasResolver for GenericDefId {\n }\n \n impl HasResolver for ImplId {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         self.module(db)\n             .resolver(db)\n             .push_generic_params_scope(db, self.into())"}, {"sha": "439e8a412b9e026daeeaba4256a34d95f7afe5cf", "filename": "crates/ra_hir_def/src/test_db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -12,7 +12,7 @@ use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath\n     ra_db::SourceDatabaseStorage,\n     hir_expand::db::AstDatabaseStorage,\n     crate::db::InternDatabaseStorage,\n-    crate::db::DefDatabase2Storage\n+    crate::db::DefDatabaseStorage\n )]\n #[derive(Debug, Default)]\n pub struct TestDB {"}, {"sha": "2bcd707bcd3a46901e87e8a55fa78b42681bd839", "filename": "crates/ra_hir_def/src/trace.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -0,0 +1,59 @@\n+//! Trace is a pretty niche data structure which is used when lowering a CST\n+//! into HIR.\n+//!\n+//! Lowering process calculates two bits of information:\n+//! * the lowered syntax itself\n+//! * a mapping between lowered syntax and original syntax\n+//!\n+//! Due to the way salsa works, the mapping is usually hot lava, as it contains\n+//! absolute offsets. The `Trace` structure (inspired, at least in name, by\n+//! Kotlin's `BindingTrace`) allows use the same code to compute both\n+//! projections.\n+use ra_arena::{map::ArenaMap, Arena, ArenaId, RawId};\n+\n+pub(crate) struct Trace<ID: ArenaId, T, V> {\n+    arena: Option<Arena<ID, T>>,\n+    map: Option<ArenaMap<ID, V>>,\n+    len: u32,\n+}\n+\n+impl<ID: ra_arena::ArenaId + Copy, T, V> Trace<ID, T, V> {\n+    pub(crate) fn new() -> Trace<ID, T, V> {\n+        Trace { arena: Some(Arena::default()), map: Some(ArenaMap::default()), len: 0 }\n+    }\n+\n+    pub(crate) fn new_for_arena() -> Trace<ID, T, V> {\n+        Trace { arena: Some(Arena::default()), map: None, len: 0 }\n+    }\n+\n+    pub(crate) fn new_for_map() -> Trace<ID, T, V> {\n+        Trace { arena: None, map: Some(ArenaMap::default()), len: 0 }\n+    }\n+\n+    pub(crate) fn alloc(&mut self, value: impl FnOnce() -> V, data: impl FnOnce() -> T) -> ID {\n+        let id = if let Some(arena) = &mut self.arena {\n+            arena.alloc(data())\n+        } else {\n+            let id = ID::from_raw(RawId::from(self.len));\n+            self.len += 1;\n+            id\n+        };\n+\n+        if let Some(map) = &mut self.map {\n+            map.insert(id, value());\n+        }\n+        id\n+    }\n+\n+    pub(crate) fn into_arena(mut self) -> Arena<ID, T> {\n+        self.arena.take().unwrap()\n+    }\n+\n+    pub(crate) fn into_map(mut self) -> ArenaMap<ID, V> {\n+        self.map.take().unwrap()\n+    }\n+\n+    pub(crate) fn into_arena_and_map(mut self) -> (Arena<ID, T>, ArenaMap<ID, V>) {\n+        (self.arena.take().unwrap(), self.map.take().unwrap())\n+    }\n+}"}, {"sha": "6c2d5b2a9f7be9bbdb1aa293ad054dc99bf55977", "filename": "crates/ra_hir_def/src/traits.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb7363d167c7a9f7c73cb950b621eb1dce493318/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs?ref=eb7363d167c7a9f7c73cb950b621eb1dce493318", "patch": "@@ -1,66 +0,0 @@\n-//! HIR for trait definitions.\n-\n-use std::sync::Arc;\n-\n-use hir_expand::{\n-    name::{AsName, Name},\n-    AstId,\n-};\n-\n-use ra_syntax::ast::{self, NameOwner};\n-\n-use crate::{\n-    db::DefDatabase2, AssocItemId, AstItemDef, ConstLoc, ContainerId, FunctionLoc, Intern, TraitId,\n-    TypeAliasId, TypeAliasLoc,\n-};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct TraitData {\n-    pub name: Option<Name>,\n-    pub items: Vec<AssocItemId>,\n-    pub auto: bool,\n-}\n-\n-impl TraitData {\n-    pub(crate) fn trait_data_query(db: &impl DefDatabase2, tr: TraitId) -> Arc<TraitData> {\n-        let src = tr.source(db);\n-        let name = src.value.name().map(|n| n.as_name());\n-        let auto = src.value.is_auto();\n-        let ast_id_map = db.ast_id_map(src.file_id);\n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => FunctionLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                    }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::ConstDef(it) => ConstLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                    }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::TypeAliasDef(it) => TypeAliasLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                    }\n-                    .intern(db)\n-                    .into(),\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n-        Arc::new(TraitData { name, items, auto })\n-    }\n-\n-    pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n-        self.items.iter().filter_map(|item| match item {\n-            AssocItemId::TypeAliasId(t) => Some(*t),\n-            _ => None,\n-        })\n-    }\n-}"}, {"sha": "5f10e9a88bae39316db1001a624c6971c9eb9844", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -64,7 +64,7 @@ pub enum TypeBound {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub fn from_ast(node: ast::TypeRef) -> Self {\n+    pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n         match node {\n             ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n             ast::TypeRef::TupleType(inner) => {\n@@ -113,15 +113,15 @@ impl TypeRef {\n         }\n     }\n \n-    pub fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n+    pub(crate) fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n         if let Some(node) = node {\n             TypeRef::from_ast(node)\n         } else {\n             TypeRef::Error\n         }\n     }\n \n-    pub fn unit() -> TypeRef {\n+    pub(crate) fn unit() -> TypeRef {\n         TypeRef::Tuple(Vec::new())\n     }\n }\n@@ -135,7 +135,7 @@ pub(crate) fn type_bounds_from_ast(type_bounds_opt: Option<ast::TypeBoundList>)\n }\n \n impl TypeBound {\n-    pub fn from_ast(node: ast::TypeBound) -> Self {\n+    pub(crate) fn from_ast(node: ast::TypeBound) -> Self {\n         match node.kind() {\n             ast::TypeBoundKind::PathType(path_type) => {\n                 let path = match path_type.path() {"}, {"sha": "c0e0436c0a597eae56f028db68418a26ce311437", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 207, "deletions": 25, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -8,35 +8,47 @@ use crate::{\n \n use crate::quote;\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum BuiltinExpander {\n-    Line,\n-}\n+macro_rules! register_builtin {\n+    ( $(($name:ident, $kind: ident) => $expand:ident),* ) => {\n+        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+        pub enum BuiltinFnLikeExpander {\n+            $($kind),*\n+        }\n \n-impl BuiltinExpander {\n-    pub fn expand(\n-        &self,\n-        db: &dyn AstDatabase,\n-        id: MacroCallId,\n-        tt: &tt::Subtree,\n-    ) -> Result<tt::Subtree, mbe::ExpandError> {\n-        match self {\n-            BuiltinExpander::Line => line_expand(db, id, tt),\n+        impl BuiltinFnLikeExpander {\n+            pub fn expand(\n+                &self,\n+                db: &dyn AstDatabase,\n+                id: MacroCallId,\n+                tt: &tt::Subtree,\n+            ) -> Result<tt::Subtree, mbe::ExpandError> {\n+                let expander = match *self {\n+                    $( BuiltinFnLikeExpander::$kind => $expand, )*\n+                };\n+                expander(db, id, tt)\n+            }\n         }\n-    }\n+\n+        pub fn find_builtin_macro(\n+            ident: &name::Name,\n+            krate: CrateId,\n+            ast_id: AstId<ast::MacroCall>,\n+        ) -> Option<MacroDefId> {\n+            let kind = match ident {\n+                 $( id if id == &name::$name => BuiltinFnLikeExpander::$kind, )*\n+                 _ => return None,\n+            };\n+\n+            Some(MacroDefId { krate, ast_id, kind: MacroDefKind::BuiltIn(kind) })\n+        }\n+    };\n }\n \n-pub fn find_builtin_macro(\n-    ident: &name::Name,\n-    krate: CrateId,\n-    ast_id: AstId<ast::MacroCall>,\n-) -> Option<MacroDefId> {\n-    // FIXME: Better registering method\n-    if ident == &name::LINE_MACRO {\n-        Some(MacroDefId { krate, ast_id, kind: MacroDefKind::BuiltIn(BuiltinExpander::Line) })\n-    } else {\n-        None\n-    }\n+register_builtin! {\n+    (COLUMN_MACRO, Column) => column_expand,\n+    (FILE_MACRO, File) => file_expand,\n+    (LINE_MACRO, Line) => line_expand,\n+    (STRINGIFY_MACRO, Stringify) => stringify_expand\n }\n \n fn to_line_number(db: &dyn AstDatabase, file: HirFileId, pos: TextUnit) -> usize {\n@@ -78,3 +90,173 @@ fn line_expand(\n \n     Ok(expanded)\n }\n+\n+fn stringify_expand(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+    _tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let loc = db.lookup_intern_macro(id);\n+    let macro_call = loc.ast_id.to_node(db);\n+\n+    let macro_content = {\n+        let arg = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n+        let macro_args = arg.syntax().clone();\n+        let text = macro_args.text();\n+        let without_parens = TextUnit::of_char('(')..text.len() - TextUnit::of_char(')');\n+        text.slice(without_parens).to_string()\n+    };\n+\n+    let expanded = quote! {\n+        #macro_content\n+    };\n+\n+    Ok(expanded)\n+}\n+\n+fn to_col_number(db: &dyn AstDatabase, file: HirFileId, pos: TextUnit) -> usize {\n+    // FIXME: Use expansion info\n+    let file_id = file.original_file(db);\n+    let text = db.file_text(file_id);\n+    let mut col_num = 1;\n+\n+    for c in text[..pos.to_usize()].chars().rev() {\n+        if c == '\\n' {\n+            break;\n+        }\n+        col_num = col_num + 1;\n+    }\n+\n+    col_num\n+}\n+\n+fn column_expand(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+    _tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let loc = db.lookup_intern_macro(id);\n+    let macro_call = loc.ast_id.to_node(db);\n+\n+    let _arg = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n+    let col_start = macro_call.syntax().text_range().start();\n+\n+    let file = id.as_file(MacroFileKind::Expr);\n+    let col_num = to_col_number(db, file, col_start);\n+\n+    let expanded = quote! {\n+        #col_num\n+    };\n+\n+    Ok(expanded)\n+}\n+\n+fn file_expand(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+    _tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let loc = db.lookup_intern_macro(id);\n+    let macro_call = loc.ast_id.to_node(db);\n+\n+    let _ = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n+\n+    // FIXME: RA purposefully lacks knowledge of absolute file names\n+    // so just return \"\".\n+    let file_name = \"\";\n+\n+    let expanded = quote! {\n+        #file_name\n+    };\n+\n+    Ok(expanded)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::{test_db::TestDB, MacroCallLoc};\n+    use ra_db::{fixture::WithFixture, SourceDatabase};\n+\n+    fn expand_builtin_macro(s: &str, expander: BuiltinFnLikeExpander) -> String {\n+        let (db, file_id) = TestDB::with_single_file(&s);\n+        let parsed = db.parse(file_id);\n+        let macro_calls: Vec<_> =\n+            parsed.syntax_node().descendants().filter_map(|it| ast::MacroCall::cast(it)).collect();\n+\n+        let ast_id_map = db.ast_id_map(file_id.into());\n+\n+        // the first one should be a macro_rules\n+        let def = MacroDefId {\n+            krate: CrateId(0),\n+            ast_id: AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0])),\n+            kind: MacroDefKind::BuiltIn(expander),\n+        };\n+\n+        let loc = MacroCallLoc {\n+            def,\n+            ast_id: AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[1])),\n+        };\n+\n+        let id = db.intern_macro(loc);\n+        let parsed = db.parse_or_expand(id.as_file(MacroFileKind::Expr)).unwrap();\n+\n+        parsed.text().to_string()\n+    }\n+\n+    #[test]\n+    fn test_column_expand() {\n+        let expanded = expand_builtin_macro(\n+            r#\"\n+        #[rustc_builtin_macro]\n+        macro_rules! column {() => {}}\n+        column!()\n+\"#,\n+            BuiltinFnLikeExpander::Column,\n+        );\n+\n+        assert_eq!(expanded, \"9\");\n+    }\n+\n+    #[test]\n+    fn test_line_expand() {\n+        let expanded = expand_builtin_macro(\n+            r#\"\n+        #[rustc_builtin_macro]\n+        macro_rules! line {() => {}}\n+        line!()\n+\"#,\n+            BuiltinFnLikeExpander::Line,\n+        );\n+\n+        assert_eq!(expanded, \"4\");\n+    }\n+\n+    #[test]\n+    fn test_stringify_expand() {\n+        let expanded = expand_builtin_macro(\n+            r#\"\n+        #[rustc_builtin_macro]\n+        macro_rules! stringify {() => {}}\n+        stringify!(a b c)\n+\"#,\n+            BuiltinFnLikeExpander::Stringify,\n+        );\n+\n+        assert_eq!(expanded, \"\\\"a b c\\\"\");\n+    }\n+\n+    #[test]\n+    fn test_file_expand() {\n+        let expanded = expand_builtin_macro(\n+            r#\"\n+        #[rustc_builtin_macro]\n+        macro_rules! file {() => {}}\n+        file!()\n+\"#,\n+            BuiltinFnLikeExpander::File,\n+        );\n+\n+        assert_eq!(expanded, \"\\\"\\\"\");\n+    }\n+}"}, {"sha": "8e46fa177d65bcd08c3599a9a7782c69d13b4ba5", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -9,14 +9,14 @@ use ra_prof::profile;\n use ra_syntax::{AstNode, Parse, SyntaxNode};\n \n use crate::{\n-    ast_id_map::AstIdMap, BuiltinExpander, HirFileId, HirFileIdRepr, MacroCallId, MacroCallLoc,\n-    MacroDefId, MacroDefKind, MacroFile, MacroFileKind,\n+    ast_id_map::AstIdMap, BuiltinFnLikeExpander, HirFileId, HirFileIdRepr, MacroCallId,\n+    MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, MacroFileKind,\n };\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum TokenExpander {\n     MacroRules(mbe::MacroRules),\n-    Builtin(BuiltinExpander),\n+    Builtin(BuiltinFnLikeExpander),\n }\n \n impl TokenExpander {"}, {"sha": "4f3ccf1d0ddb57aa08cd4812d6e5c5732ecaa804", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -24,7 +24,10 @@ use ra_syntax::{\n };\n \n use crate::ast_id_map::FileAstId;\n-use crate::builtin_macro::BuiltinExpander;\n+use crate::builtin_macro::BuiltinFnLikeExpander;\n+\n+#[cfg(test)]\n+mod test_db;\n \n /// Input to the analyzer is a set of files, where each file is identified by\n /// `FileId` and contains source code. However, another source of source code in\n@@ -135,7 +138,7 @@ pub struct MacroDefId {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum MacroDefKind {\n     Declarative,\n-    BuiltIn(BuiltinExpander),\n+    BuiltIn(BuiltinFnLikeExpander),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}, {"sha": "eaea7a6a86de295f8440349538cc9bb2a259a255", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -142,4 +142,7 @@ pub const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n pub const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");\n \n // Builtin Macros\n+pub const FILE_MACRO: Name = Name::new_inline_ascii(4, b\"file\");\n+pub const COLUMN_MACRO: Name = Name::new_inline_ascii(6, b\"column\");\n pub const LINE_MACRO: Name = Name::new_inline_ascii(4, b\"line\");\n+pub const STRINGIFY_MACRO: Name = Name::new_inline_ascii(9, b\"stringify\");"}, {"sha": "d23e75d9ee3b93ee421e5d0e7ad3ec2b5cf1fe58", "filename": "crates/ra_hir_expand/src/test_db.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -0,0 +1,50 @@\n+//! Database used for testing `hir_expand`.\n+\n+use std::{\n+    panic,\n+    sync::{Arc, Mutex},\n+};\n+\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath};\n+\n+#[salsa::database(\n+    ra_db::SourceDatabaseExtStorage,\n+    ra_db::SourceDatabaseStorage,\n+    crate::db::AstDatabaseStorage\n+)]\n+#[derive(Debug, Default)]\n+pub struct TestDB {\n+    runtime: salsa::Runtime<TestDB>,\n+    events: Mutex<Option<Vec<salsa::Event<TestDB>>>>,\n+}\n+\n+impl salsa::Database for TestDB {\n+    fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n+        &self.runtime\n+    }\n+\n+    fn salsa_event(&self, event: impl Fn() -> salsa::Event<TestDB>) {\n+        let mut events = self.events.lock().unwrap();\n+        if let Some(events) = &mut *events {\n+            events.push(event());\n+        }\n+    }\n+}\n+\n+impl panic::RefUnwindSafe for TestDB {}\n+\n+impl FileLoader for TestDB {\n+    fn file_text(&self, file_id: FileId) -> Arc<String> {\n+        FileLoaderDelegate(self).file_text(file_id)\n+    }\n+    fn resolve_relative_path(\n+        &self,\n+        anchor: FileId,\n+        relative_path: &RelativePath,\n+    ) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    }\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+        FileLoaderDelegate(self).relevant_crates(file_id)\n+    }\n+}"}, {"sha": "7c367230e7192c753e574b8dfa6995ad96c75fc2", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -30,15 +30,15 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n             let (callable_def, _subst) = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n                 hir::CallableDef::Function(it) => {\n-                    (CallInfo::with_fn(db, it), it.data(db).has_self_param())\n+                    (CallInfo::with_fn(db, it), it.has_self_param(db))\n                 }\n                 hir::CallableDef::Struct(it) => (CallInfo::with_struct(db, it)?, false),\n                 hir::CallableDef::EnumVariant(it) => (CallInfo::with_enum_variant(db, it)?, false),\n             }\n         }\n         FnCallNode::MethodCallExpr(expr) => {\n             let function = analyzer.resolve_method_call(&expr)?;\n-            (CallInfo::with_fn(db, function), function.data(db).has_self_param())\n+            (CallInfo::with_fn(db, function), function.has_self_param(db))\n         }\n         FnCallNode::MacroCallExpr(expr) => {\n             let macro_def = analyzer.resolve_macro_call(db, &expr)?;"}, {"sha": "0f692460dc7537c860c41c520ff9cad68ff0d1a2", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -313,7 +313,7 @@ impl RootDatabase {\n             hir::db::RawItemsQuery\n             hir::db::CrateDefMapQuery\n             hir::db::GenericParamsQuery\n-            hir::db::FnDataQuery\n+            hir::db::FunctionDataQuery\n             hir::db::TypeAliasDataQuery\n             hir::db::ConstDataQuery\n             hir::db::StaticDataQuery\n@@ -324,7 +324,7 @@ impl RootDatabase {\n             hir::db::ExprScopesQuery\n             hir::db::InferQuery\n             hir::db::TypeForDefQuery\n-            hir::db::TypeForFieldQuery\n+            hir::db::FieldTypesQuery\n             hir::db::CallableItemSignatureQuery\n             hir::db::GenericPredicatesQuery\n             hir::db::GenericDefaultsQuery"}, {"sha": "5a3f9b5f64a329a2cfb654fe69dd7391a75f1945", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -59,8 +59,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     let mut seen_methods = FxHashSet::default();\n     ctx.analyzer.iterate_method_candidates(ctx.db, receiver, None, |_ty, func| {\n-        let data = func.data(ctx.db);\n-        if data.has_self_param() && seen_methods.insert(data.name().clone()) {\n+        if func.has_self_param(ctx.db) && seen_methods.insert(func.name(ctx.db)) {\n             acc.add_function(ctx, func);\n         }\n         None::<()>"}, {"sha": "63e25e0bf10dfa802c1f12e4514b1e1c2dd8d9cb", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{Adt, Either, PathResolution};\n+use hir::{Adt, Either, HasSource, PathResolution};\n use ra_syntax::AstNode;\n use test_utils::tested_by;\n \n@@ -27,7 +27,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 }\n                 if Some(module) == ctx.module {\n                     if let Some(import) = import {\n-                        if let Either::A(use_tree) = module.import_source(ctx.db, import) {\n+                        if let Either::A(use_tree) = import.source(ctx.db).value {\n                             if use_tree.syntax().text_range().contains_inclusive(ctx.offset) {\n                                 // for `use self::foo<|>`, don't suggest `foo` as a completion\n                                 tested_by!(dont_complete_current_use);\n@@ -53,8 +53,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n             ctx.analyzer.iterate_path_candidates(ctx.db, ty.clone(), None, |_ty, item| {\n                 match item {\n                     hir::AssocItem::Function(func) => {\n-                        let data = func.data(ctx.db);\n-                        if !data.has_self_param() {\n+                        if !func.has_self_param(ctx.db) {\n                             acc.add_function(ctx, func);\n                         }\n                     }\n@@ -80,8 +79,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n             for item in t.items(ctx.db) {\n                 match item {\n                     hir::AssocItem::Function(func) => {\n-                        let data = func.data(ctx.db);\n-                        if !data.has_self_param() {\n+                        if !func.has_self_param(ctx.db) {\n                             acc.add_function(ctx, func);\n                         }\n                     }"}, {"sha": "bac3f7582fdb94195466256e52867d939dc90e17", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,6 +1,6 @@\n //! This modules takes care of rendering various definitions as completion items.\n \n-use hir::{db::HirDatabase, Attrs, Docs, HasSource, HirDisplay, ScopeDef, Ty, TypeWalk};\n+use hir::{db::HirDatabase, Docs, HasAttrs, HasSource, HirDisplay, ScopeDef, Ty, TypeWalk};\n use join_to_string::join;\n use ra_syntax::ast::NameOwner;\n use test_utils::tested_by;\n@@ -199,14 +199,17 @@ impl Completions {\n         name: Option<String>,\n         func: hir::Function,\n     ) {\n-        let data = func.data(ctx.db);\n-        let name = name.unwrap_or_else(|| data.name().to_string());\n+        let func_name = func.name(ctx.db);\n+        let has_self_param = func.has_self_param(ctx.db);\n+        let params = func.params(ctx.db);\n+\n+        let name = name.unwrap_or_else(|| func_name.to_string());\n         let ast_node = func.source(ctx.db).value;\n         let detail = function_label(&ast_node);\n \n         let mut builder =\n             CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n-                .kind(if data.has_self_param() {\n+                .kind(if has_self_param {\n                     CompletionItemKind::Method\n                 } else {\n                     CompletionItemKind::Function\n@@ -221,12 +224,11 @@ impl Completions {\n             && ctx.db.feature_flags.get(\"completion.insertion.add-call-parenthesis\")\n         {\n             tested_by!(inserts_parens_for_function_calls);\n-            let (snippet, label) =\n-                if data.params().is_empty() || data.has_self_param() && data.params().len() == 1 {\n-                    (format!(\"{}()$0\", data.name()), format!(\"{}()\", name))\n-                } else {\n-                    (format!(\"{}($0)\", data.name()), format!(\"{}(\u2026)\", name))\n-                };\n+            let (snippet, label) = if params.is_empty() || has_self_param && params.len() == 1 {\n+                (format!(\"{}()$0\", func_name), format!(\"{}()\", name))\n+            } else {\n+                (format!(\"{}($0)\", func_name), format!(\"{}(\u2026)\", name))\n+            };\n             builder = builder.lookup_by(name).label(label).insert_snippet(snippet);\n         }\n \n@@ -285,11 +287,8 @@ impl Completions {\n     }\n }\n \n-fn is_deprecated(node: impl Attrs, db: &impl HirDatabase) -> bool {\n-    match node.attrs(db) {\n-        None => false,\n-        Some(attrs) => attrs.iter().any(|x| x.is_simple_atom(\"deprecated\")),\n-    }\n+fn is_deprecated(node: impl HasAttrs, db: &impl HirDatabase) -> bool {\n+    node.attrs(db).by_key(\"deprecated\").exists()\n }\n \n fn has_non_default_type_params(def: hir::GenericDef, db: &db::RootDatabase) -> bool {"}, {"sha": "c2a9dcdd14aaf6fc20d2e55b5c0b86adc7373f03", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -22,7 +22,6 @@ use crate::{\n     hir::db::InternDatabaseStorage,\n     hir::db::AstDatabaseStorage,\n     hir::db::DefDatabaseStorage,\n-    hir::db::DefDatabase2Storage,\n     hir::db::HirDatabaseStorage\n )]\n #[derive(Debug)]"}, {"sha": "d96de4e4ce06946750121ac6e9f6eb335510724c", "filename": "crates/ra_ide_api/src/display/function_signature.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -55,7 +55,7 @@ impl FunctionSignature {\n     pub(crate) fn from_struct(db: &db::RootDatabase, st: hir::Struct) -> Option<Self> {\n         let node: ast::StructDef = st.source(db).value;\n         match node.kind() {\n-            ast::StructKind::Named(_) => return None,\n+            ast::StructKind::Record(_) => return None,\n             _ => (),\n         };\n \n@@ -89,7 +89,7 @@ impl FunctionSignature {\n     ) -> Option<Self> {\n         let node: ast::EnumVariant = variant.source(db).value;\n         match node.kind() {\n-            ast::StructKind::Named(_) | ast::StructKind::Unit => return None,\n+            ast::StructKind::Record(_) | ast::StructKind::Unit => return None,\n             _ => (),\n         };\n "}, {"sha": "0b540b8cdead6a1e67446103b414838a2ac73c32", "filename": "crates/ra_ide_api/src/expand_macro.rs", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fexpand_macro.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -40,16 +40,23 @@ fn expand_macro_recur(\n     let analyzer = hir::SourceAnalyzer::new(db, source, None);\n     let expansion = analyzer.expand(db, macro_call)?;\n     let macro_file_id = expansion.file_id();\n-    let expanded: SyntaxNode = db.parse_or_expand(macro_file_id)?;\n+    let mut expanded: SyntaxNode = db.parse_or_expand(macro_file_id)?;\n \n     let children = expanded.descendants().filter_map(ast::MacroCall::cast);\n     let mut replaces = FxHashMap::default();\n \n     for child in children.into_iter() {\n         let node = hir::Source::new(macro_file_id, &child);\n-        let new_node = expand_macro_recur(db, source, node)?;\n-\n-        replaces.insert(child.syntax().clone().into(), new_node.into());\n+        if let Some(new_node) = expand_macro_recur(db, source, node) {\n+            // Replace the whole node if it is root\n+            // `replace_descendants` will not replace the parent node\n+            // but `SyntaxNode::descendants include itself\n+            if expanded == *child.syntax() {\n+                expanded = new_node;\n+            } else {\n+                replaces.insert(child.syntax().clone().into(), new_node.into());\n+            }\n+        }\n     }\n \n     Some(replace_descendants(&expanded, &replaces))\n@@ -217,4 +224,49 @@ fn some_thing() -> u32 {\n }\n \"###);\n     }\n+\n+    #[test]\n+    fn macro_expand_match_ast_inside_let_statement() {\n+        let res = check_expand_macro(\n+            r#\"\n+        //- /lib.rs\n+        macro_rules! match_ast {\n+            (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };        \n+            (match ($node:expr) {}) => {{}};\n+        }        \n+\n+        fn main() {        \n+            let p = f(|it| {\n+                let res = mat<|>ch_ast! { match c {}};\n+                Some(res)\n+            })?;\n+        }\n+        \"#,\n+        );\n+\n+        assert_eq!(res.name, \"match_ast\");\n+        assert_snapshot!(res.expansion, @r###\"{}\"###);\n+    }\n+\n+    #[test]\n+    fn macro_expand_inner_macro_fail_to_expand() {\n+        let res = check_expand_macro(\n+            r#\"\n+        //- /lib.rs\n+        macro_rules! bar {\n+            (BAD) => {};\n+        }\n+        macro_rules! foo {\n+            () => {bar!()};\n+        }        \n+\n+        fn main() {        \n+            let res = fo<|>o!();\n+        }\n+        \"#,\n+        );\n+\n+        assert_eq!(res.name, \"foo\");\n+        assert_snapshot!(res.expansion, @r###\"bar!()\"###);\n+    }\n }"}, {"sha": "cb6c24eaa584e6f720457ff556b2d65ada1cdf94", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -54,7 +54,7 @@ use std::sync::Arc;\n use ra_cfg::CfgOptions;\n use ra_db::{\n     salsa::{self, ParallelDatabase},\n-    CheckCanceled, FileLoader, SourceDatabase,\n+    CheckCanceled, Env, FileLoader, SourceDatabase,\n };\n use ra_syntax::{SourceFile, TextRange, TextUnit};\n \n@@ -240,7 +240,7 @@ impl Analysis {\n         // Default to enable test for single file.\n         let mut cfg_options = CfgOptions::default();\n         cfg_options.insert_atom(\"test\".into());\n-        crate_graph.add_crate_root(file_id, Edition::Edition2018, cfg_options);\n+        crate_graph.add_crate_root(file_id, Edition::Edition2018, cfg_options, Env::default());\n         change.add_file(source_root, file_id, \"main.rs\".into(), Arc::new(text));\n         change.set_crate_graph(crate_graph);\n         host.apply_change(change);"}, {"sha": "bf8a5493242d1605d211925846f1baa4a14cbeff", "filename": "crates/ra_ide_api/src/mock_analysis.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n-use ra_db::RelativePathBuf;\n+use ra_db::{Env, RelativePathBuf};\n use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n \n use crate::{\n@@ -96,9 +96,15 @@ impl MockAnalysis {\n             let file_id = FileId(i as u32 + 1);\n             let cfg_options = CfgOptions::default();\n             if path == \"/lib.rs\" || path == \"/main.rs\" {\n-                root_crate = Some(crate_graph.add_crate_root(file_id, Edition2018, cfg_options));\n+                root_crate = Some(crate_graph.add_crate_root(\n+                    file_id,\n+                    Edition2018,\n+                    cfg_options,\n+                    Env::default(),\n+                ));\n             } else if path.ends_with(\"/lib.rs\") {\n-                let other_crate = crate_graph.add_crate_root(file_id, Edition2018, cfg_options);\n+                let other_crate =\n+                    crate_graph.add_crate_root(file_id, Edition2018, cfg_options, Env::default());\n                 let crate_name = path.parent().unwrap().file_name().unwrap();\n                 if let Some(root_crate) = root_crate {\n                     crate_graph.add_dep(root_crate, crate_name.into(), other_crate).unwrap();"}, {"sha": "6027e7d54d143741d79d525f9a4ef287aeb694b7", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -34,12 +34,14 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n \n #[cfg(test)]\n mod tests {\n+    use ra_cfg::CfgOptions;\n+    use ra_db::Env;\n+\n     use crate::{\n         mock_analysis::{analysis_and_position, MockAnalysis},\n         AnalysisChange, CrateGraph,\n         Edition::Edition2018,\n     };\n-    use ra_cfg::CfgOptions;\n \n     #[test]\n     fn test_resolve_parent_module() {\n@@ -87,7 +89,12 @@ mod tests {\n         assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n \n         let mut crate_graph = CrateGraph::default();\n-        let crate_id = crate_graph.add_crate_root(root_file, Edition2018, CfgOptions::default());\n+        let crate_id = crate_graph.add_crate_root(\n+            root_file,\n+            Edition2018,\n+            CfgOptions::default(),\n+            Env::default(),\n+        );\n         let mut change = AnalysisChange::new();\n         change.set_crate_graph(crate_graph);\n         host.apply_change(change);"}, {"sha": "cab06dea941b0426b135125f7bc60f0b9cd08c69", "filename": "crates/ra_ide_api/src/references/classify.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,6 +1,6 @@\n //! Functions that are used to classify an element from its definition or reference.\n \n-use hir::{FromSource, Module, ModuleSource, Path, PathResolution, Source, SourceAnalyzer};\n+use hir::{FromSource, Module, ModuleSource, PathResolution, Source, SourceAnalyzer};\n use ra_prof::profile;\n use ra_syntax::{ast, match_ast, AstNode};\n use test_utils::tested_by;\n@@ -140,12 +140,8 @@ pub(crate) fn classify_name_ref(\n \n     if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n         tested_by!(goto_definition_works_for_record_fields);\n-        if let Some(record_lit) = record_field.syntax().ancestors().find_map(ast::RecordLit::cast) {\n-            let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n-            let hir_path = Path::from_name_ref(name_ref.value);\n-            let hir_name = hir_path.as_ident()?;\n-            let field = variant_def.field(db, hir_name)?;\n-            return Some(from_struct_field(db, field));\n+        if let Some(field_def) = analyzer.resolve_record_field(&record_field) {\n+            return Some(from_struct_field(db, field_def));\n         }\n     }\n "}, {"sha": "351997dcdbeb7b3db9bcc35d8466ad0deca816b0", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -1,7 +1,6 @@\n //! FIXME: write short doc here\n \n use std::path::{Path, PathBuf};\n-use std::str::FromStr;\n \n use cargo_metadata::{CargoOpt, MetadataCommand};\n use ra_arena::{impl_arena_id, Arena, RawId};\n@@ -55,11 +54,13 @@ struct TargetData {\n     name: String,\n     root: PathBuf,\n     kind: TargetKind,\n+    is_proc_macro: bool,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum TargetKind {\n     Bin,\n+    /// Any kind of Cargo lib crate-type (dylib, rlib, proc-macro, ...).\n     Lib,\n     Example,\n     Test,\n@@ -75,6 +76,7 @@ impl TargetKind {\n                 \"test\" => TargetKind::Test,\n                 \"bench\" => TargetKind::Bench,\n                 \"example\" => TargetKind::Example,\n+                \"proc-macro\" => TargetKind::Lib,\n                 _ if kind.contains(\"lib\") => TargetKind::Lib,\n                 _ => continue,\n             };\n@@ -124,6 +126,9 @@ impl Target {\n     pub fn kind(self, ws: &CargoWorkspace) -> TargetKind {\n         ws.targets[self].kind\n     }\n+    pub fn is_proc_macro(self, ws: &CargoWorkspace) -> bool {\n+        ws.targets[self].is_proc_macro\n+    }\n }\n \n impl CargoWorkspace {\n@@ -143,8 +148,7 @@ impl CargoWorkspace {\n         for meta_pkg in meta.packages {\n             let cargo_metadata::Package { id, edition, name, manifest_path, .. } = meta_pkg;\n             let is_member = ws_members.contains(&id);\n-            let edition = Edition::from_str(&edition)\n-                .map_err(|e| (format!(\"metadata for package {} failed: {}\", &name, e.msg)))?;\n+            let edition = edition.parse::<Edition>()?;\n             let pkg = packages.alloc(PackageData {\n                 name,\n                 manifest: manifest_path,\n@@ -157,11 +161,13 @@ impl CargoWorkspace {\n             let pkg_data = &mut packages[pkg];\n             pkg_by_id.insert(id, pkg);\n             for meta_tgt in meta_pkg.targets {\n+                let is_proc_macro = meta_tgt.kind.as_slice() == &[\"proc-macro\"];\n                 let tgt = targets.alloc(TargetData {\n                     pkg,\n                     name: meta_tgt.name,\n                     root: meta_tgt.src_path.clone(),\n                     kind: TargetKind::new(meta_tgt.kind.as_slice()),\n+                    is_proc_macro,\n                 });\n                 pkg_data.targets.push(tgt);\n             }"}, {"sha": "55ff4d6efc78e6a966a20c9b6cf5d228316a927c", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -13,7 +13,7 @@ use std::{\n };\n \n use ra_cfg::CfgOptions;\n-use ra_db::{CrateGraph, CrateId, Edition, FileId};\n+use ra_db::{CrateGraph, CrateId, Edition, Env, FileId};\n use rustc_hash::FxHashMap;\n use serde_json::from_reader;\n \n@@ -146,7 +146,12 @@ impl ProjectWorkspace {\n                         };\n                         crates.insert(\n                             crate_id,\n-                            crate_graph.add_crate_root(file_id, edition, cfg_options),\n+                            crate_graph.add_crate_root(\n+                                file_id,\n+                                edition,\n+                                cfg_options,\n+                                Env::default(),\n+                            ),\n                         );\n                     }\n                 }\n@@ -180,8 +185,12 @@ impl ProjectWorkspace {\n                             opts\n                         };\n \n-                        let crate_id =\n-                            crate_graph.add_crate_root(file_id, Edition::Edition2018, cfg_options);\n+                        let crate_id = crate_graph.add_crate_root(\n+                            file_id,\n+                            Edition::Edition2018,\n+                            cfg_options,\n+                            Env::default(),\n+                        );\n                         sysroot_crates.insert(krate, crate_id);\n                         names.insert(crate_id, krate.name(&sysroot).to_string());\n                     }\n@@ -200,7 +209,10 @@ impl ProjectWorkspace {\n                 }\n \n                 let libcore = sysroot.core().and_then(|it| sysroot_crates.get(&it).copied());\n+                let liballoc = sysroot.alloc().and_then(|it| sysroot_crates.get(&it).copied());\n                 let libstd = sysroot.std().and_then(|it| sysroot_crates.get(&it).copied());\n+                let libproc_macro =\n+                    sysroot.proc_macro().and_then(|it| sysroot_crates.get(&it).copied());\n \n                 let mut pkg_to_lib_crate = FxHashMap::default();\n                 let mut pkg_crates = FxHashMap::default();\n@@ -216,13 +228,32 @@ impl ProjectWorkspace {\n                                 opts.insert_features(pkg.features(&cargo).iter().map(Into::into));\n                                 opts\n                             };\n-                            let crate_id =\n-                                crate_graph.add_crate_root(file_id, edition, cfg_options);\n+                            let crate_id = crate_graph.add_crate_root(\n+                                file_id,\n+                                edition,\n+                                cfg_options,\n+                                Env::default(),\n+                            );\n                             names.insert(crate_id, pkg.name(&cargo).to_string());\n                             if tgt.kind(&cargo) == TargetKind::Lib {\n                                 lib_tgt = Some(crate_id);\n                                 pkg_to_lib_crate.insert(pkg, crate_id);\n                             }\n+                            if tgt.is_proc_macro(&cargo) {\n+                                if let Some(proc_macro) = libproc_macro {\n+                                    if let Err(_) = crate_graph.add_dep(\n+                                        crate_id,\n+                                        \"proc_macro\".into(),\n+                                        proc_macro,\n+                                    ) {\n+                                        log::error!(\n+                                            \"cyclic dependency on proc_macro for {}\",\n+                                            pkg.name(&cargo)\n+                                        )\n+                                    }\n+                                }\n+                            }\n+\n                             pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n                         }\n                     }\n@@ -248,6 +279,11 @@ impl ProjectWorkspace {\n                                 log::error!(\"cyclic dependency on core for {}\", pkg.name(&cargo))\n                             }\n                         }\n+                        if let Some(alloc) = liballoc {\n+                            if let Err(_) = crate_graph.add_dep(from, \"alloc\".into(), alloc) {\n+                                log::error!(\"cyclic dependency on alloc for {}\", pkg.name(&cargo))\n+                            }\n+                        }\n                         if let Some(std) = libstd {\n                             if let Err(_) = crate_graph.add_dep(from, \"std\".into(), std) {\n                                 log::error!(\"cyclic dependency on std for {}\", pkg.name(&cargo))"}, {"sha": "10ca391b6aa947ae22180f15fd1b30d9cae7d443", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -31,10 +31,18 @@ impl Sysroot {\n         self.by_name(\"core\")\n     }\n \n+    pub fn alloc(&self) -> Option<SysrootCrate> {\n+        self.by_name(\"alloc\")\n+    }\n+\n     pub fn std(&self) -> Option<SysrootCrate> {\n         self.by_name(\"std\")\n     }\n \n+    pub fn proc_macro(&self) -> Option<SysrootCrate> {\n+        self.by_name(\"proc_macro\")\n+    }\n+\n     pub fn crates<'a>(&'a self) -> impl Iterator<Item = SysrootCrate> + ExactSizeIterator + 'a {\n         self.crates.iter().map(|(id, _data)| id)\n     }\n@@ -70,7 +78,7 @@ impl Sysroot {\n             }\n         }\n         if let Some(alloc) = sysroot.by_name(\"alloc\") {\n-            if let Some(core) = sysroot.by_name(\"core\") {\n+            if let Some(core) = sysroot.core() {\n                 sysroot.crates[alloc].deps.push(core);\n             }\n         }"}, {"sha": "95bf9db14733b0e49e433449a2e332b3e9b7f71e", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -13,11 +13,21 @@ use crate::{\n         make::{self, tokens},\n         AstNode, TypeBoundsOwner,\n     },\n-    AstToken, Direction, InsertPosition, SmolStr, SyntaxElement,\n+    AstToken, Direction, InsertPosition, SmolStr, SyntaxElement, SyntaxKind,\n     SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n     SyntaxNode, SyntaxToken, T,\n };\n \n+impl ast::BinExpr {\n+    #[must_use]\n+    pub fn replace_op(&self, op: SyntaxKind) -> Option<ast::BinExpr> {\n+        let op_node: SyntaxElement = self.op_details()?.0.into();\n+        let to_insert: Option<SyntaxElement> = Some(tokens::op(op).into());\n+        let replace_range = RangeInclusive::new(op_node.clone(), op_node);\n+        Some(replace_children(self, replace_range, to_insert.into_iter()))\n+    }\n+}\n+\n impl ast::FnDef {\n     #[must_use]\n     pub fn with_body(&self, body: ast::Block) -> ast::FnDef {"}, {"sha": "2fd039837828185dfbe1b2e1a332d59a2478d9f7", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -127,7 +127,7 @@ pub enum BinOp {\n }\n \n impl ast::BinExpr {\n-    fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n+    pub fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n         self.syntax().children_with_tokens().filter_map(|it| it.into_token()).find_map(|c| {\n             let bin_op = match c.kind() {\n                 T![||] => BinOp::BooleanOr,"}, {"sha": "513ed7920f983674579f675fda7d3b021f345dca", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -178,15 +178,15 @@ impl ast::ImplBlock {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum StructKind {\n+    Record(ast::RecordFieldDefList),\n     Tuple(ast::TupleFieldDefList),\n-    Named(ast::RecordFieldDefList),\n     Unit,\n }\n \n impl StructKind {\n     fn from_node<N: AstNode>(node: &N) -> StructKind {\n         if let Some(nfdl) = child_opt::<_, ast::RecordFieldDefList>(node) {\n-            StructKind::Named(nfdl)\n+            StructKind::Record(nfdl)\n         } else if let Some(pfl) = child_opt::<_, ast::TupleFieldDefList>(node) {\n             StructKind::Tuple(pfl)\n         } else {"}, {"sha": "40db570da0b58e0a7c416a265d7900be1ca6b41c", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -173,10 +173,21 @@ fn ast_from_text<N: AstNode>(text: &str) -> N {\n }\n \n pub mod tokens {\n-    use crate::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n+    use crate::{AstNode, Parse, SourceFile, SyntaxKind, SyntaxKind::*, SyntaxToken, T};\n     use once_cell::sync::Lazy;\n \n-    static SOURCE_FILE: Lazy<Parse<SourceFile>> = Lazy::new(|| SourceFile::parse(\",\\n; ;\"));\n+    static SOURCE_FILE: Lazy<Parse<SourceFile>> =\n+        Lazy::new(|| SourceFile::parse(\"const C: () = (1 != 1, 2 == 2)\\n;\"));\n+\n+    pub fn op(op: SyntaxKind) -> SyntaxToken {\n+        SOURCE_FILE\n+            .tree()\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .find(|it| it.kind() == op)\n+            .unwrap()\n+    }\n \n     pub fn comma() -> SyntaxToken {\n         SOURCE_FILE"}, {"sha": "1b2d98608cb1b1c5fb279af867ebc39036273d96", "filename": "docs/user/README.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/docs%2Fuser%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/docs%2Fuser%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2FREADME.md?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -141,6 +141,11 @@ to load path and require it in `init.el`\n \n ## Vim and NeoVim\n \n+Neovim 0.5 has a built in language server. For a quick start configuration of\n+rust-analyzer, use [neovim/nvim-lsp](https://github.com/neovim/nvim-lsp#rust_analyzer).\n+Once `neovim/nvim-lsp` is installed, you can use `call nvim_lsp#setup(\"rust_analyzer\", {})`\n+or `lua require'nvim_lsp'.rust_analyzer.setup({})` to quickly get set up.\n+\n * Install coc.nvim by following the instructions at [coc.nvim]\n   - You will need nodejs installed.\n   - You may want to include some of the sample vim configurations [from here][coc-vim-conf]"}, {"sha": "6f4c30bee3d769bc4841a88bafafa58fd25d0fa6", "filename": "docs/user/assists.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -329,6 +329,25 @@ fn main() {\n }\n ```\n \n+## `invert_if`\n+\n+Apply invert_if\n+This transforms if expressions of the form `if !x {A} else {B}` into `if x {B} else {A}`\n+This also works with `!=`. This assist can only be applied with the cursor\n+on `if`.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    if\u2503 !y { A } else { B }\n+}\n+\n+// AFTER\n+fn main() {\n+    if y { B } else { A }\n+}\n+```\n+\n ## `make_raw_string`\n \n Adds `r#` to a plain string literal."}, {"sha": "fae871285ab6d6ec191d886e672f7955878b9f3e", "filename": "xtask/tests/tidy-tests/docs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15ea338ac991707d330288ba4d1bf5daa0fc75d9/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea338ac991707d330288ba4d1bf5daa0fc75d9/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs?ref=15ea338ac991707d330288ba4d1bf5daa0fc75d9", "patch": "@@ -74,7 +74,6 @@ fn no_docs_comments() {\n         \"ra_db\",\n         \"ra_hir\",\n         \"ra_hir_expand\",\n-        \"ra_hir_def\",\n         \"ra_ide_api\",\n         \"ra_lsp_server\",\n         \"ra_mbe\","}]}