{"sha": "aa978addb3cffceb6f1020787369d07f65cf15b7", "node_id": "C_kwDOAAsO6NoAKGFhOTc4YWRkYjNjZmZjZWI2ZjEwMjA3ODczNjlkMDdmNjVjZjE1Yjc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-15T18:50:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-15T18:50:50Z"}, "message": "Rollup merge of #96040 - m-ou-se:futex-u32, r=Amanieu\n\nUse u32 instead of i32 for futexes.\n\nThis changes futexes from i32 to u32. The [Linux man page](https://man7.org/linux/man-pages/man2/futex.2.html) uses `uint32_t` for them, so I'm not sure why I used i32 for them. Maybe because I first used them for thread parkers, where I used -1, 0, and 1 as the states.\n\n(Wasm's `memory.atomic.wait32` does use `i32`, because wasm doesn't support `u32`.)\n\nIt doesn't matter much, but using the unsigned type probably results in fewer surprises when shifting bits around or using comparison operators.\n\nr? ```@Amanieu```", "tree": {"sha": "6998fc1c718ed3ceb9d7e427d0f194c0386a4ce2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6998fc1c718ed3ceb9d7e427d0f194c0386a4ce2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa978addb3cffceb6f1020787369d07f65cf15b7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiWb6KCRBK7hj4Ov3rIwAAWCEIAFC7KcfqgTHSu/yrYtdW9pcj\nLzfyaOv5QlCw4YtkeVRmj4nqX7JF3JCeRvzvBGQMrCUiq1AI8FH2wxZ/PvgKJQ7M\nEHhK/q6l5+fgoxzsWyKUJtiqiOz5hMwzN0bL7+z1aq9MrdnWuiXAGrKZePoSepk0\nwbhovpZ9patNDiFAwqbnwvA0FwcU7MbwxlFdM0UCx07PQa8NjFXti4YQheIcgp5U\ntu3P9tSKqxEOyKHjV9LAm1kxLlFS52ObPye0+pVEMuFPHuFzzeXRUxjm61V25mc2\nbkv4r/mZxGmIBNe3ObqNjNDYU32bkg+8W5CnkcoIr9c3LtCvbZNoMYW85OeLpZw=\n=WX8H\n-----END PGP SIGNATURE-----\n", "payload": "tree 6998fc1c718ed3ceb9d7e427d0f194c0386a4ce2\nparent 224afadb3bb746cd3a9f70047825481a5bf9c655\nparent 7a35c0f52d2a37d3ce10772b07d7a45a445ebbf0\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1650048650 +0200\ncommitter GitHub <noreply@github.com> 1650048650 +0200\n\nRollup merge of #96040 - m-ou-se:futex-u32, r=Amanieu\n\nUse u32 instead of i32 for futexes.\n\nThis changes futexes from i32 to u32. The [Linux man page](https://man7.org/linux/man-pages/man2/futex.2.html) uses `uint32_t` for them, so I'm not sure why I used i32 for them. Maybe because I first used them for thread parkers, where I used -1, 0, and 1 as the states.\n\n(Wasm's `memory.atomic.wait32` does use `i32`, because wasm doesn't support `u32`.)\n\nIt doesn't matter much, but using the unsigned type probably results in fewer surprises when shifting bits around or using comparison operators.\n\nr? ```@Amanieu```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa978addb3cffceb6f1020787369d07f65cf15b7", "html_url": "https://github.com/rust-lang/rust/commit/aa978addb3cffceb6f1020787369d07f65cf15b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa978addb3cffceb6f1020787369d07f65cf15b7/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "224afadb3bb746cd3a9f70047825481a5bf9c655", "url": "https://api.github.com/repos/rust-lang/rust/commits/224afadb3bb746cd3a9f70047825481a5bf9c655", "html_url": "https://github.com/rust-lang/rust/commit/224afadb3bb746cd3a9f70047825481a5bf9c655"}, {"sha": "7a35c0f52d2a37d3ce10772b07d7a45a445ebbf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a35c0f52d2a37d3ce10772b07d7a45a445ebbf0", "html_url": "https://github.com/rust-lang/rust/commit/7a35c0f52d2a37d3ce10772b07d7a45a445ebbf0"}], "stats": {"total": 108, "additions": 55, "deletions": 53}, "files": [{"sha": "62760373a6affecba019d63754011973ffaa2db1", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aa978addb3cffceb6f1020787369d07f65cf15b7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa978addb3cffceb6f1020787369d07f65cf15b7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=aa978addb3cffceb6f1020787369d07f65cf15b7", "patch": "@@ -4,7 +4,7 @@\n     all(target_os = \"emscripten\", target_feature = \"atomics\")\n ))]\n \n-use crate::sync::atomic::AtomicI32;\n+use crate::sync::atomic::AtomicU32;\n use crate::time::Duration;\n \n /// Wait for a futex_wake operation to wake us.\n@@ -13,7 +13,7 @@ use crate::time::Duration;\n ///\n /// Returns false on timeout, and true in all other cases.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) -> bool {\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {\n     use super::time::Timespec;\n     use crate::ptr::null;\n     use crate::sync::atomic::Ordering::Relaxed;\n@@ -35,7 +35,7 @@ pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) -\n         let r = unsafe {\n             libc::syscall(\n                 libc::SYS_futex,\n-                futex as *const AtomicI32,\n+                futex as *const AtomicU32,\n                 libc::FUTEX_WAIT_BITSET | libc::FUTEX_PRIVATE_FLAG,\n                 expected,\n                 timespec.as_ref().map_or(null(), |t| &t.t as *const libc::timespec),\n@@ -53,21 +53,19 @@ pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) -\n }\n \n #[cfg(target_os = \"emscripten\")]\n-pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) {\n     extern \"C\" {\n         fn emscripten_futex_wait(\n-            addr: *const AtomicI32,\n+            addr: *const AtomicU32,\n             val: libc::c_uint,\n             max_wait_ms: libc::c_double,\n         ) -> libc::c_int;\n     }\n \n     unsafe {\n         emscripten_futex_wait(\n-            futex as *const AtomicI32,\n-            // `val` is declared unsigned to match the Emscripten headers, but since it's used as\n-            // an opaque value, we can ignore the meaning of signed vs. unsigned and cast here.\n-            expected as libc::c_uint,\n+            futex,\n+            expected,\n             timeout.map_or(crate::f64::INFINITY, |d| d.as_secs_f64() * 1000.0),\n         );\n     }\n@@ -78,11 +76,11 @@ pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n /// Returns true if this actually woke up such a thread,\n /// or false if no thread was waiting on this futex.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn futex_wake(futex: &AtomicI32) -> bool {\n+pub fn futex_wake(futex: &AtomicU32) -> bool {\n     unsafe {\n         libc::syscall(\n             libc::SYS_futex,\n-            futex as *const AtomicI32,\n+            futex as *const AtomicU32,\n             libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n             1,\n         ) > 0\n@@ -91,22 +89,22 @@ pub fn futex_wake(futex: &AtomicI32) -> bool {\n \n /// Wake up all threads that are waiting on futex_wait on this futex.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn futex_wake_all(futex: &AtomicI32) {\n+pub fn futex_wake_all(futex: &AtomicU32) {\n     unsafe {\n         libc::syscall(\n             libc::SYS_futex,\n-            futex as *const AtomicI32,\n+            futex as *const AtomicU32,\n             libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n             i32::MAX,\n         );\n     }\n }\n \n #[cfg(target_os = \"emscripten\")]\n-pub fn futex_wake(futex: &AtomicI32) -> bool {\n+pub fn futex_wake(futex: &AtomicU32) -> bool {\n     extern \"C\" {\n-        fn emscripten_futex_wake(addr: *const AtomicI32, count: libc::c_int) -> libc::c_int;\n+        fn emscripten_futex_wake(addr: *const AtomicU32, count: libc::c_int) -> libc::c_int;\n     }\n \n-    unsafe { emscripten_futex_wake(futex as *const AtomicI32, 1) > 0 }\n+    unsafe { emscripten_futex_wake(futex, 1) > 0 }\n }"}, {"sha": "b166e7c453cad17bbdee1ad7f4bae550d6a02e71", "filename": "library/std/src/sys/unix/locks/futex.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa978addb3cffceb6f1020787369d07f65cf15b7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa978addb3cffceb6f1020787369d07f65cf15b7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs?ref=aa978addb3cffceb6f1020787369d07f65cf15b7", "patch": "@@ -1,6 +1,6 @@\n use crate::cell::UnsafeCell;\n use crate::sync::atomic::{\n-    AtomicI32, AtomicUsize,\n+    AtomicU32, AtomicUsize,\n     Ordering::{Acquire, Relaxed, Release},\n };\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n@@ -13,13 +13,13 @@ pub struct Mutex {\n     /// 0: unlocked\n     /// 1: locked, no other threads waiting\n     /// 2: locked, and other threads waiting (contended)\n-    futex: AtomicI32,\n+    futex: AtomicU32,\n }\n \n impl Mutex {\n     #[inline]\n     pub const fn new() -> Self {\n-        Self { futex: AtomicI32::new(0) }\n+        Self { futex: AtomicU32::new(0) }\n     }\n \n     #[inline]\n@@ -71,7 +71,7 @@ impl Mutex {\n         }\n     }\n \n-    fn spin(&self) -> i32 {\n+    fn spin(&self) -> u32 {\n         let mut spin = 100;\n         loop {\n             // We only use `load` (and not `swap` or `compare_exchange`)\n@@ -110,13 +110,13 @@ pub struct Condvar {\n     // The value of this atomic is simply incremented on every notification.\n     // This is used by `.wait()` to not miss any notifications after\n     // unlocking the mutex and before waiting for notifications.\n-    futex: AtomicI32,\n+    futex: AtomicU32,\n }\n \n impl Condvar {\n     #[inline]\n     pub const fn new() -> Self {\n-        Self { futex: AtomicI32::new(0) }\n+        Self { futex: AtomicU32::new(0) }\n     }\n \n     #[inline]"}, {"sha": "e42edb2585834da8d7fb6c94d4b0898055ad7f0a", "filename": "library/std/src/sys/unix/locks/futex_rwlock.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/aa978addb3cffceb6f1020787369d07f65cf15b7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa978addb3cffceb6f1020787369d07f65cf15b7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs?ref=aa978addb3cffceb6f1020787369d07f65cf15b7", "patch": "@@ -1,5 +1,5 @@\n use crate::sync::atomic::{\n-    AtomicI32,\n+    AtomicU32,\n     Ordering::{Acquire, Relaxed, Release},\n };\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n@@ -14,36 +14,36 @@ pub struct RwLock {\n     //   0x3FFF_FFFF: Write locked\n     // Bit 30: Readers are waiting on this futex.\n     // Bit 31: Writers are waiting on the writer_notify futex.\n-    state: AtomicI32,\n+    state: AtomicU32,\n     // The 'condition variable' to notify writers through.\n     // Incremented on every signal.\n-    writer_notify: AtomicI32,\n+    writer_notify: AtomicU32,\n }\n \n-const READ_LOCKED: i32 = 1;\n-const MASK: i32 = (1 << 30) - 1;\n-const WRITE_LOCKED: i32 = MASK;\n-const MAX_READERS: i32 = MASK - 1;\n-const READERS_WAITING: i32 = 1 << 30;\n-const WRITERS_WAITING: i32 = 1 << 31;\n+const READ_LOCKED: u32 = 1;\n+const MASK: u32 = (1 << 30) - 1;\n+const WRITE_LOCKED: u32 = MASK;\n+const MAX_READERS: u32 = MASK - 1;\n+const READERS_WAITING: u32 = 1 << 30;\n+const WRITERS_WAITING: u32 = 1 << 31;\n \n-fn is_unlocked(state: i32) -> bool {\n+fn is_unlocked(state: u32) -> bool {\n     state & MASK == 0\n }\n \n-fn is_write_locked(state: i32) -> bool {\n+fn is_write_locked(state: u32) -> bool {\n     state & MASK == WRITE_LOCKED\n }\n \n-fn has_readers_waiting(state: i32) -> bool {\n+fn has_readers_waiting(state: u32) -> bool {\n     state & READERS_WAITING != 0\n }\n \n-fn has_writers_waiting(state: i32) -> bool {\n+fn has_writers_waiting(state: u32) -> bool {\n     state & WRITERS_WAITING != 0\n }\n \n-fn is_read_lockable(state: i32) -> bool {\n+fn is_read_lockable(state: u32) -> bool {\n     // This also returns false if the counter could overflow if we tried to read lock it.\n     //\n     // We don't allow read-locking if there's readers waiting, even if the lock is unlocked\n@@ -53,14 +53,14 @@ fn is_read_lockable(state: i32) -> bool {\n     state & MASK < MAX_READERS && !has_readers_waiting(state) && !has_writers_waiting(state)\n }\n \n-fn has_reached_max_readers(state: i32) -> bool {\n+fn has_reached_max_readers(state: u32) -> bool {\n     state & MASK == MAX_READERS\n }\n \n impl RwLock {\n     #[inline]\n     pub const fn new() -> Self {\n-        Self { state: AtomicI32::new(0), writer_notify: AtomicI32::new(0) }\n+        Self { state: AtomicU32::new(0), writer_notify: AtomicU32::new(0) }\n     }\n \n     #[inline]\n@@ -227,7 +227,7 @@ impl RwLock {\n     /// If both are waiting, this will wake up only one writer, but will fall\n     /// back to waking up readers if there was no writer to wake up.\n     #[cold]\n-    fn wake_writer_or_readers(&self, mut state: i32) {\n+    fn wake_writer_or_readers(&self, mut state: u32) {\n         assert!(is_unlocked(state));\n \n         // The readers waiting bit might be turned on at any point now,\n@@ -287,7 +287,7 @@ impl RwLock {\n     }\n \n     /// Spin for a while, but stop directly at the given condition.\n-    fn spin_until(&self, f: impl Fn(i32) -> bool) -> i32 {\n+    fn spin_until(&self, f: impl Fn(u32) -> bool) -> u32 {\n         let mut spin = 100; // Chosen by fair dice roll.\n         loop {\n             let state = self.state.load(Relaxed);\n@@ -299,12 +299,12 @@ impl RwLock {\n         }\n     }\n \n-    fn spin_write(&self) -> i32 {\n+    fn spin_write(&self) -> u32 {\n         // Stop spinning when it's unlocked or when there's waiting writers, to keep things somewhat fair.\n         self.spin_until(|state| is_unlocked(state) || has_writers_waiting(state))\n     }\n \n-    fn spin_read(&self) -> i32 {\n+    fn spin_read(&self) -> u32 {\n         // Stop spinning when it's unlocked or read locked, or when there's waiting threads.\n         self.spin_until(|state| {\n             !is_write_locked(state) || has_readers_waiting(state) || has_writers_waiting(state)"}, {"sha": "bbe9bd6951af967e12d9be38040d0e07b9349292", "filename": "library/std/src/sys/wasm/atomics/futex.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa978addb3cffceb6f1020787369d07f65cf15b7/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa978addb3cffceb6f1020787369d07f65cf15b7/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs?ref=aa978addb3cffceb6f1020787369d07f65cf15b7", "patch": "@@ -1,17 +1,21 @@\n use crate::arch::wasm32;\n use crate::convert::TryInto;\n-use crate::sync::atomic::AtomicI32;\n+use crate::sync::atomic::AtomicU32;\n use crate::time::Duration;\n \n-pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) {\n     let timeout = timeout.and_then(|t| t.as_nanos().try_into().ok()).unwrap_or(-1);\n     unsafe {\n-        wasm32::memory_atomic_wait32(futex as *const AtomicI32 as *mut i32, expected, timeout);\n+        wasm32::memory_atomic_wait32(\n+            futex as *const AtomicU32 as *mut i32,\n+            expected as i32,\n+            timeout,\n+        );\n     }\n }\n \n-pub fn futex_wake(futex: &AtomicI32) {\n+pub fn futex_wake(futex: &AtomicU32) {\n     unsafe {\n-        wasm32::memory_atomic_notify(futex as *const AtomicI32 as *mut i32, 1);\n+        wasm32::memory_atomic_notify(futex as *const AtomicU32 as *mut i32, 1);\n     }\n }"}, {"sha": "fbf6231ff4ab324e5e43815f65c224e3a78f7950", "filename": "library/std/src/sys_common/thread_parker/futex.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa978addb3cffceb6f1020787369d07f65cf15b7/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa978addb3cffceb6f1020787369d07f65cf15b7/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs?ref=aa978addb3cffceb6f1020787369d07f65cf15b7", "patch": "@@ -1,14 +1,14 @@\n-use crate::sync::atomic::AtomicI32;\n+use crate::sync::atomic::AtomicU32;\n use crate::sync::atomic::Ordering::{Acquire, Release};\n use crate::sys::futex::{futex_wait, futex_wake};\n use crate::time::Duration;\n \n-const PARKED: i32 = -1;\n-const EMPTY: i32 = 0;\n-const NOTIFIED: i32 = 1;\n+const PARKED: u32 = u32::MAX;\n+const EMPTY: u32 = 0;\n+const NOTIFIED: u32 = 1;\n \n pub struct Parker {\n-    state: AtomicI32,\n+    state: AtomicU32,\n }\n \n // Notes about memory ordering:\n@@ -34,7 +34,7 @@ pub struct Parker {\n impl Parker {\n     #[inline]\n     pub const fn new() -> Self {\n-        Parker { state: AtomicI32::new(EMPTY) }\n+        Parker { state: AtomicU32::new(EMPTY) }\n     }\n \n     // Assumes this is only called by the thread that owns the Parker,"}]}