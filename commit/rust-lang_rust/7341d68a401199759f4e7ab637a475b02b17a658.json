{"sha": "7341d68a401199759f4e7ab637a475b02b17a658", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNDFkNjhhNDAxMTk5NzU5ZjRlN2FiNjM3YTQ3NWIwMmIxN2E2NTg=", "commit": {"author": {"name": "Diggory Blake", "email": "diggsey@googlemail.com", "date": "2016-07-09T12:33:03Z"}, "committer": {"name": "Diggory Blake", "email": "diggsey@googlemail.com", "date": "2016-08-12T17:13:18Z"}, "message": "Produce source package in rust-installer format in addition to vanilla tarball\n\nCopy source files from rust code\n\nAdd missing wildcard\n\nRemove unused function\n\nRemove use of tar --transform", "tree": {"sha": "6b893506a37d522954b37c3024dea5aa377c512c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b893506a37d522954b37c3024dea5aa377c512c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7341d68a401199759f4e7ab637a475b02b17a658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7341d68a401199759f4e7ab637a475b02b17a658", "html_url": "https://github.com/rust-lang/rust/commit/7341d68a401199759f4e7ab637a475b02b17a658", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7341d68a401199759f4e7ab637a475b02b17a658/comments", "author": {"login": "Diggsey", "id": 451321, "node_id": "MDQ6VXNlcjQ1MTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/451321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Diggsey", "html_url": "https://github.com/Diggsey", "followers_url": "https://api.github.com/users/Diggsey/followers", "following_url": "https://api.github.com/users/Diggsey/following{/other_user}", "gists_url": "https://api.github.com/users/Diggsey/gists{/gist_id}", "starred_url": "https://api.github.com/users/Diggsey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Diggsey/subscriptions", "organizations_url": "https://api.github.com/users/Diggsey/orgs", "repos_url": "https://api.github.com/users/Diggsey/repos", "events_url": "https://api.github.com/users/Diggsey/events{/privacy}", "received_events_url": "https://api.github.com/users/Diggsey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Diggsey", "id": 451321, "node_id": "MDQ6VXNlcjQ1MTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/451321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Diggsey", "html_url": "https://github.com/Diggsey", "followers_url": "https://api.github.com/users/Diggsey/followers", "following_url": "https://api.github.com/users/Diggsey/following{/other_user}", "gists_url": "https://api.github.com/users/Diggsey/gists{/gist_id}", "starred_url": "https://api.github.com/users/Diggsey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Diggsey/subscriptions", "organizations_url": "https://api.github.com/users/Diggsey/orgs", "repos_url": "https://api.github.com/users/Diggsey/repos", "events_url": "https://api.github.com/users/Diggsey/events{/privacy}", "received_events_url": "https://api.github.com/users/Diggsey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f55ac6944a88d4da62b30a16cc95893ca050c328", "url": "https://api.github.com/repos/rust-lang/rust/commits/f55ac6944a88d4da62b30a16cc95893ca050c328", "html_url": "https://github.com/rust-lang/rust/commit/f55ac6944a88d4da62b30a16cc95893ca050c328"}], "stats": {"total": 240, "additions": 230, "deletions": 10}, "files": [{"sha": "e81371037ac2b95699775e567127e5626900564a", "filename": "mk/dist.mk", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7341d68a401199759f4e7ab637a475b02b17a658/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7341d68a401199759f4e7ab637a475b02b17a658/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=7341d68a401199759f4e7ab637a475b02b17a658", "patch": "@@ -24,6 +24,7 @@ PKG_NAME := $(CFG_PACKAGE_NAME)\n STD_PKG_NAME := rust-std-$(CFG_PACKAGE_VERS)\n DOC_PKG_NAME := rust-docs-$(CFG_PACKAGE_VERS)\n MINGW_PKG_NAME := rust-mingw-$(CFG_PACKAGE_VERS)\n+SRC_PKG_NAME := rust-src-$(CFG_PACKAGE_VERS)\n \n # License suitable for displaying in a popup\n LICENSE.txt: $(S)COPYRIGHT $(S)LICENSE-APACHE $(S)LICENSE-MIT\n@@ -71,10 +72,10 @@ PKG_FILES := \\\n \n UNROOTED_PKG_FILES := $(patsubst $(S)%,./%,$(PKG_FILES))\n \n-$(PKG_TAR): $(PKG_FILES)\n-\t@$(call E, making dist dir)\n-\t$(Q)rm -Rf tmp/dist/$(PKG_NAME)\n-\t$(Q)mkdir -p tmp/dist/$(PKG_NAME)\n+tmp/dist/$$(SRC_PKG_NAME)-image: $(PKG_FILES)\n+\t@$(call E, making src image)\n+\t$(Q)rm -Rf tmp/dist/$(SRC_PKG_NAME)-image\n+\t$(Q)mkdir -p tmp/dist/$(SRC_PKG_NAME)-image/lib/rustlib/src/rust\n \t$(Q)tar \\\n          -C $(S) \\\n          -f - \\\n@@ -87,10 +88,11 @@ $(PKG_TAR): $(PKG_FILES)\n          --exclude=*/llvm/test/*/*/*.ll \\\n          --exclude=*/llvm/test/*/*/*.td \\\n          --exclude=*/llvm/test/*/*/*.s \\\n-         -c $(UNROOTED_PKG_FILES) | tar -x -f - -C tmp/dist/$(PKG_NAME)\n+         -c $(UNROOTED_PKG_FILES) | tar -x -f - -C tmp/dist/$(SRC_PKG_NAME)-image/lib/rustlib/src/rust\n+\n+$(PKG_TAR): tmp/dist/$$(SRC_PKG_NAME)-image\n \t@$(call E, making $@)\n-\t$(Q)tar -czf $(PKG_TAR) -C tmp/dist $(PKG_NAME)\n-\t$(Q)rm -Rf tmp/dist/$(PKG_NAME)\n+\t$(Q)tar -czf $(PKG_TAR) -C tmp/dist/$(SRC_PKG_NAME)-image/lib/rustlib/src rust --transform 's,^rust,$(PKG_NAME),S'\n \n dist-tar-src: $(PKG_TAR)\n \n@@ -259,6 +261,19 @@ endef\n $(foreach host,$(CFG_HOST),\\\n   $(eval $(call DEF_INSTALLER,$(host))))\n \n+dist/$(SRC_PKG_NAME).tar.gz: tmp/dist/$(SRC_PKG_NAME)-image\n+\t@$(call E, build: $@)\n+\t$(Q)$(S)src/rust-installer/gen-installer.sh \\\n+\t\t--product-name=Rust \\\n+\t\t--rel-manifest-dir=rustlib \\\n+\t\t--success-message=Awesome-Source. \\\n+\t\t--image-dir=tmp/dist/$(SRC_PKG_NAME)-image \\\n+\t\t--work-dir=tmp/dist \\\n+\t\t--output-dir=dist \\\n+\t\t--package-name=$(SRC_PKG_NAME) \\\n+\t\t--component-name=rust-src \\\n+\t\t--legacy-manifest-dirs=rustlib,cargo\n+\n # When generating packages for the standard library, we've actually got a lot of\n # artifacts to choose from. Each of the CFG_HOST compilers will have a copy of\n # the standard library for each CFG_TARGET, but we only want to generate one\n@@ -329,8 +344,8 @@ distcheck-docs: dist-docs\n # Primary targets (dist, distcheck)\n ######################################################################\n \n-MAYBE_DIST_TAR_SRC=dist-tar-src\n-MAYBE_DISTCHECK_TAR_SRC=distcheck-tar-src\n+MAYBE_DIST_TAR_SRC=dist-tar-src dist/$(SRC_PKG_NAME).tar.gz\n+MAYBE_DISTCHECK_TAR_SRC=distcheck-tar-src dist/$(SRC_PKG_NAME).tar.gz\n \n # FIXME #13224: On OS X don't produce tarballs simply because --exclude-vcs don't work.\n # This is a huge hack because I just don't have time to figure out another solution."}, {"sha": "d52577eb228e2b27454445b026696101b21da885", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=7341d68a401199759f4e7ab637a475b02b17a658", "patch": "@@ -11,11 +11,20 @@ dependencies = [\n  \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.73 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"aho-corasick\"\n+version = \"0.5.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"build_helper\"\n version = \"0.1.0\"\n@@ -70,6 +79,14 @@ name = \"md5\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"memchr\"\n+version = \"0.1.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"num_cpus\"\n version = \"0.2.11\"\n@@ -78,11 +95,45 @@ dependencies = [\n  \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"regex\"\n+version = \"0.1.73\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"aho-corasick 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thread_local 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"regex-syntax\"\n+version = \"0.3.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"rustc-serialize\"\n version = \"0.3.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"thread-id\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"thread_local\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"toml\"\n version = \"0.1.28\"\n@@ -91,6 +142,11 @@ dependencies = [\n  \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"utf8-ranges\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.6\""}, {"sha": "b19545590b9c06ed526eabe92d7c5f59e8594193", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=7341d68a401199759f4e7ab637a475b02b17a658", "patch": "@@ -32,3 +32,4 @@ kernel32-sys = \"0.2\"\n gcc = { git = \"https://github.com/alexcrichton/gcc-rs\" }\n libc = \"0.2\"\n md5 = \"0.1\"\n+regex = \"0.1.73\""}, {"sha": "9d18901eb000202327fc0194f4c2452e6eecbcf9", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 115, "deletions": 1, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=7341d68a401199759f4e7ab637a475b02b17a658", "patch": "@@ -24,7 +24,8 @@ use std::path::{PathBuf, Path};\n use std::process::Command;\n \n use {Build, Compiler};\n-use util::{cp_r, libdir, is_dylib};\n+use util::{cp_r, libdir, is_dylib, cp_filtered, copy};\n+use regex::{RegexSet, quote};\n \n fn package_vers(build: &Build) -> &str {\n     match &build.config.channel[..] {\n@@ -284,6 +285,119 @@ pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n     t!(fs::remove_dir_all(&image));\n }\n \n+/// Creates the `rust-src` installer component and the plain source tarball\n+pub fn rust_src(build: &Build) {\n+    println!(\"Dist src\");\n+    let plain_name = format!(\"rustc-{}-src\", package_vers(build));\n+    let name = format!(\"rust-src-{}\", package_vers(build));\n+    let image = tmpdir(build).join(format!(\"{}-image\", name));\n+    let _ = fs::remove_dir_all(&image);\n+\n+    let dst = image.join(\"lib/rustlib/src\");\n+    let dst_src = dst.join(\"rust\");\n+    let plain_dst_src = dst.join(&plain_name);\n+    t!(fs::create_dir_all(&dst_src));\n+\n+    // This is the set of root paths which will become part of the source package\n+    let src_files = [\n+        \"COPYRIGHT\",\n+        \"LICENSE-APACHE\",\n+        \"LICENSE-MIT\",\n+        \"CONTRIBUTING.md\",\n+        \"README.md\",\n+        \"RELEASES.md\",\n+        \"configure\",\n+        \"Makefile.in\"\n+    ];\n+    let src_dirs = [\n+        \"man\",\n+        \"src\",\n+        \"mk\"\n+    ];\n+\n+    // Exclude paths matching these wildcard expressions\n+    let excludes = [\n+        // exclude-vcs\n+        \"CVS\", \"RCS\", \"SCCS\", \".git\", \".gitignore\", \".gitmodules\", \".gitattributes\", \".cvsignore\",\n+        \".svn\", \".arch-ids\", \"{arch}\", \"=RELEASE-ID\", \"=meta-update\", \"=update\", \".bzr\",\n+        \".bzrignore\", \".bzrtags\", \".hg\", \".hgignore\", \".hgrags\", \"_darcs\",\n+        // extensions\n+        \"*~\", \"*.pyc\",\n+        // misc\n+        \"llvm/test/*/*.ll\",\n+        \"llvm/test/*/*.td\",\n+        \"llvm/test/*/*.s\",\n+        \"llvm/test/*/*/*.ll\",\n+        \"llvm/test/*/*/*.td\",\n+        \"llvm/test/*/*/*.s\"\n+    ];\n+\n+    // Construct a set of regexes for efficiently testing whether paths match one of the above\n+    // expressions.\n+    let regex_set = t!(RegexSet::new(\n+        // This converts a wildcard expression to a regex\n+        excludes.iter().map(|&s| {\n+            // Prefix ensures that matching starts on a path separator boundary\n+            r\"^(.*[\\\\/])?\".to_owned() + (\n+                // Escape the expression to produce a regex matching exactly that string\n+                &quote(s)\n+                // Replace slashes with a pattern matching either forward or backslash\n+                .replace(r\"/\", r\"[\\\\/]\")\n+                // Replace wildcards with a pattern matching a single path segment, ie. containing\n+                // no slashes.\n+                .replace(r\"\\*\", r\"[^\\\\/]*\")\n+            // Suffix anchors to the end of the path\n+            ) + \"$\"\n+        })\n+    ));\n+\n+    // Create a filter which skips files which match the regex set or contain invalid unicode\n+    let filter_fn = move |path: &Path| {\n+        if let Some(path) = path.to_str() {\n+            !regex_set.is_match(path)\n+        } else {\n+            false\n+        }\n+    };\n+\n+    // Copy the directories using our filter\n+    for item in &src_dirs {\n+        let dst = &dst_src.join(item);\n+        t!(fs::create_dir(dst));\n+        cp_filtered(&build.src.join(item), dst, &filter_fn);\n+    }\n+    // Copy the files normally\n+    for item in &src_files {\n+        copy(&build.src.join(item), &dst_src.join(item));\n+    }\n+\n+    // Create source tarball in rust-installer format\n+    let mut cmd = Command::new(\"sh\");\n+    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/gen-installer.sh\")))\n+       .arg(\"--product-name=Rust\")\n+       .arg(\"--rel-manifest-dir=rustlib\")\n+       .arg(\"--success-message=Awesome-Source.\")\n+       .arg(format!(\"--image-dir={}\", sanitize_sh(&image)))\n+       .arg(format!(\"--work-dir={}\", sanitize_sh(&tmpdir(build))))\n+       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n+       .arg(format!(\"--package-name={}\", name))\n+       .arg(\"--component-name=rust-src\")\n+       .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+    build.run(&mut cmd);\n+\n+    // Rename directory, so that root folder of tarball has the correct name\n+    t!(fs::rename(&dst_src, &plain_dst_src));\n+\n+    // Create plain source tarball\n+    let mut cmd = Command::new(\"tar\");\n+    cmd.arg(\"-czf\").arg(sanitize_sh(&distdir(build).join(&format!(\"{}.tar.gz\", plain_name))))\n+       .arg(&plain_name)\n+       .current_dir(&dst);\n+    build.run(&mut cmd);\n+\n+    t!(fs::remove_dir_all(&image));\n+}\n+\n fn install(src: &Path, dstdir: &Path, perms: u32) {\n     let dst = dstdir.join(src.file_name().unwrap());\n     t!(fs::create_dir_all(dstdir));"}, {"sha": "3ef8cb74dfa6d4dc592225e0e26df5e017efe11e", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=7341d68a401199759f4e7ab637a475b02b17a658", "patch": "@@ -26,6 +26,7 @@ extern crate md5;\n extern crate num_cpus;\n extern crate rustc_serialize;\n extern crate toml;\n+extern crate regex;\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n@@ -451,6 +452,7 @@ impl Build {\n                 DistMingw { _dummy } => dist::mingw(self, target.target),\n                 DistRustc { stage } => dist::rustc(self, stage, target.target),\n                 DistStd { compiler } => dist::std(self, &compiler, target.target),\n+                DistSrc { _dummy } => dist::rust_src(self),\n \n                 DebuggerScripts { stage } => {\n                     let compiler = Compiler::new(stage, target.target);"}, {"sha": "8d3cb36166b70ffb5e0ab2b5850734aa222f96d1", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=7341d68a401199759f4e7ab637a475b02b17a658", "patch": "@@ -140,6 +140,7 @@ macro_rules! targets {\n             (dist_mingw, DistMingw { _dummy: () }),\n             (dist_rustc, DistRustc { stage: u32 }),\n             (dist_std, DistStd { compiler: Compiler<'a> }),\n+            (dist_src, DistSrc { _dummy: () }),\n \n             // Misc targets\n             (android_copy_libs, AndroidCopyLibs { compiler: Compiler<'a> }),\n@@ -568,12 +569,14 @@ impl<'a> Step<'a> {\n                     vec![self.libtest(compiler)]\n                 }\n             }\n+            Source::DistSrc { _dummy: _ } => Vec::new(),\n \n             Source::Dist { stage } => {\n                 let mut base = Vec::new();\n \n                 for host in build.config.host.iter() {\n                     let host = self.target(host);\n+                    base.push(host.dist_src(()));\n                     base.push(host.dist_rustc(stage));\n                     if host.target.contains(\"windows-gnu\") {\n                         base.push(host.dist_mingw(()));"}, {"sha": "dfc1c7a243b5b1238e3f0513550f464366ecb90d", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7341d68a401199759f4e7ab637a475b02b17a658/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=7341d68a401199759f4e7ab637a475b02b17a658", "patch": "@@ -67,6 +67,35 @@ pub fn cp_r(src: &Path, dst: &Path) {\n     }\n }\n \n+/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+/// when this function is called. Unwanted files or directories can be skipped\n+/// by returning `false` from the filter function.\n+pub fn cp_filtered<F: Fn(&Path) -> bool>(src: &Path, dst: &Path, filter: &F) {\n+    // Inner function does the actual work\n+    fn recurse<F: Fn(&Path) -> bool>(src: &Path, dst: &Path, relative: &Path, filter: &F) {\n+        for f in t!(fs::read_dir(src)) {\n+            let f = t!(f);\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            let relative = relative.join(name);\n+            // Only copy file or directory if the filter function returns true\n+            if filter(&relative) {\n+                if t!(f.file_type()).is_dir() {\n+                    let _ = fs::remove_dir_all(&dst);\n+                    t!(fs::create_dir(&dst));\n+                    recurse(&path, &dst, &relative, filter);\n+                } else {\n+                    let _ = fs::remove_file(&dst);\n+                    copy(&path, &dst);\n+                }\n+            }\n+        }\n+    }\n+    // Immediately recurse with an empty relative path\n+    recurse(src, dst, Path::new(\"\"), filter)\n+}\n+\n /// Given an executable called `name`, return the filename for the\n /// executable for a particular target.\n pub fn exe(name: &str, target: &str) -> String {"}]}