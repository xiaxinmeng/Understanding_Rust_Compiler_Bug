{"sha": "d441c5468814b0d8f9ccdba426baf1f16b5134fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NDFjNTQ2ODgxNGIwZDhmOWNjZGJhNDI2YmFmMWYxNmI1MTM0ZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-11T13:41:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-11T13:41:18Z"}, "message": "auto merge of #10787 : nikomatsakis/rust/issue-9629-freeze-andmut, r=pnkfelix\n\nSee #9629 for details.\r\n\r\nr? @pnkfelix", "tree": {"sha": "1321648a000f427340c1bb6c159dcc4d80a675f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1321648a000f427340c1bb6c159dcc4d80a675f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d441c5468814b0d8f9ccdba426baf1f16b5134fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d441c5468814b0d8f9ccdba426baf1f16b5134fc", "html_url": "https://github.com/rust-lang/rust/commit/d441c5468814b0d8f9ccdba426baf1f16b5134fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d441c5468814b0d8f9ccdba426baf1f16b5134fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c2f8aa330575f001a7d15b8ccd335aaa337bf8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c2f8aa330575f001a7d15b8ccd335aaa337bf8b", "html_url": "https://github.com/rust-lang/rust/commit/5c2f8aa330575f001a7d15b8ccd335aaa337bf8b"}, {"sha": "fc74d64f7d1b4daa95b21ff93cb78bbaf9798e81", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc74d64f7d1b4daa95b21ff93cb78bbaf9798e81", "html_url": "https://github.com/rust-lang/rust/commit/fc74d64f7d1b4daa95b21ff93cb78bbaf9798e81"}], "stats": {"total": 672, "additions": 454, "deletions": 218}, "files": [{"sha": "38e93cd39fad7c9fe64e988de1d664c260cf1179", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 282, "deletions": 177, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=d441c5468814b0d8f9ccdba426baf1f16b5134fc", "patch": "@@ -39,7 +39,7 @@ occur. It also tracks initialization sites. For each borrow and move,\n it checks various basic safety conditions at this time (for example,\n that the lifetime of the borrow doesn't exceed the lifetime of the\n value being borrowed, or that there is no move out of an `&T`\n-pointee).\n+referent).\n \n It then uses the dataflow module to propagate which of those borrows\n may be in scope at each point in the procedure. A loan is considered\n@@ -110,7 +110,7 @@ follows:\n \n     LOAN = (LV, LT, MQ, RESTRICTION*)\n     RESTRICTION = (LV, ACTION*)\n-    ACTION = MUTATE | CLAIM | FREEZE | ALIAS\n+    ACTION = MUTATE | CLAIM | FREEZE\n \n Here the `LOAN` tuple defines the lvalue `LV` being borrowed; the\n lifetime `LT` of that borrow; the mutability `MQ` of the borrow; and a\n@@ -125,7 +125,6 @@ of actions that may be restricted for the path `LV`:\n - `MUTATE` means that `LV` cannot be assigned to;\n - `CLAIM` means that the `LV` cannot be borrowed mutably;\n - `FREEZE` means that the `LV` cannot be borrowed immutably;\n-- `ALIAS` means that `LV` cannot be aliased in any way (not even `&const`).\n \n Finally, it is never possible to move from an lvalue that appears in a\n restriction. This implies that the \"empty restriction\" `(LV, [])`,\n@@ -216,6 +215,24 @@ of this rule: there are comments in the borrowck source referencing\n these names, so that you can cross reference to find the actual code\n that corresponds to the formal rule.\n \n+### Invariants\n+\n+I want to collect, at a high-level, the invariants the borrow checker\n+maintains. I will give them names and refer to them throughout the\n+text. Together these invariants are crucial for the overall soundness\n+of the system.\n+\n+**Mutability requires uniqueness.** To mutate a path\n+\n+**Unique mutability.** There is only one *usable* mutable path to any\n+given memory at any given time. This implies that when claiming memory\n+with an expression like `p = &mut x`, the compiler must guarantee that\n+the borrowed value `x` can no longer be mutated so long as `p` is\n+live. (This is done via restrictions, read on.)\n+\n+**.**\n+\n+\n ### The `gather_loans` pass\n \n We start with the `gather_loans` pass, which walks the AST looking for\n@@ -325,19 +342,19 @@ The scope of a field is the scope of the struct:\n \n       SCOPE(LV.f) = SCOPE(LV)\n \n-The scope of a unique pointee is the scope of the pointer, since\n+The scope of a unique referent is the scope of the pointer, since\n (barring mutation or moves) the pointer will not be freed until\n the pointer itself `LV` goes out of scope:\n \n       SCOPE(*LV) = SCOPE(LV) if LV has type ~T\n \n-The scope of a managed pointee is also the scope of the pointer.  This\n+The scope of a managed referent is also the scope of the pointer.  This\n is a conservative approximation, since there may be other aliases fo\n that same managed box that would cause it to live longer:\n \n       SCOPE(*LV) = SCOPE(LV) if LV has type @T or @mut T\n \n-The scope of a borrowed pointee is the scope associated with the\n+The scope of a borrowed referent is the scope associated with the\n pointer.  This is a conservative approximation, since the data that\n the pointer points at may actually live longer:\n \n@@ -394,7 +411,7 @@ moves occur. Conditions (2) and (3) then serve to guarantee that the\n value is not mutated or moved. Note that lvalues are either\n (ultimately) owned by a local variable, in which case we can check\n whether that local variable is ever moved in its scope, or they are\n-owned by the pointee of an (immutable, due to condition 2) managed or\n+owned by the referent of an (immutable, due to condition 2) managed or\n borrowed pointer, in which case moves are not permitted because the\n location is aliasable.\n \n@@ -493,13 +510,13 @@ frozen or aliased, we cannot allow the owner to be frozen or aliased,\n since doing so indirectly freezes/aliases the field. This is the\n origin of inherited mutability.\n \n-### Restrictions for loans of owned pointees\n+### Restrictions for loans of owned referents\n \n-Because the mutability of owned pointees is inherited, restricting an\n-owned pointee is similar to restricting a field, in that it implies\n+Because the mutability of owned referents is inherited, restricting an\n+owned referent is similar to restricting a field, in that it implies\n restrictions on the pointer. However, owned pointers have an important\n-twist: if the owner `LV` is mutated, that causes the owned pointee\n-`*LV` to be freed! So whenever an owned pointee `*LV` is borrowed, we\n+twist: if the owner `LV` is mutated, that causes the owned referent\n+`*LV` to be freed! So whenever an owned referent `*LV` is borrowed, we\n must prevent the owned pointer `LV` from being mutated, which means\n that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n on `LV`:\n@@ -508,9 +525,9 @@ on `LV`:\n       TYPE(LV) = ~Ty\n       RESTRICTIONS(LV, LT, ACTIONS|MUTATE|CLAIM) = RS\n \n-### Restrictions for loans of immutable managed/borrowed pointees\n+### Restrictions for loans of immutable managed/borrowed referents\n \n-Immutable managed/borrowed pointees are freely aliasable, meaning that\n+Immutable managed/borrowed referents are freely aliasable, meaning that\n the compiler does not prevent you from copying the pointer.  This\n implies that issuing restrictions is useless. We might prevent the\n user from acting on `*LV` itself, but there could be another path\n@@ -519,25 +536,109 @@ restricting that path. Therefore, the rule for `&Ty` and `@Ty`\n pointers always returns an empty set of restrictions, and it only\n permits restricting `MUTATE` and `CLAIM` actions:\n \n+    RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Managed\n+      TYPE(LV) = @Ty\n+      ACTIONS subset of [MUTATE, CLAIM]\n+\n     RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n-      TYPE(LV) = &Ty or @Ty\n+      TYPE(LV) = &LT' Ty\n+      LT <= LT'                                            // (1)\n       ACTIONS subset of [MUTATE, CLAIM]\n \n The reason that we can restrict `MUTATE` and `CLAIM` actions even\n without a restrictions list is that it is never legal to mutate nor to\n borrow mutably the contents of a `&Ty` or `@Ty` pointer. In other\n words, those restrictions are already inherent in the type.\n \n-Typically, this limitation is not an issue, because restrictions other\n-than `MUTATE` or `CLAIM` typically arise due to `&mut` borrow, and as\n-we said, that is already illegal for `*LV`. However, there is one case\n-where we can be asked to enforce an `ALIAS` restriction on `*LV`,\n-which is when you have a type like `&&mut T`. In such cases we will\n-report an error because we cannot enforce a lack of aliases on a `&Ty`\n-or `@Ty` type. That case is described in more detail in the section on\n-mutable borrowed pointers.\n+Clause (1) in the rule for `&Ty` deserves mention. Here I\n+specify that the lifetime of the loan must be less than the lifetime\n+of the `&Ty` pointer. In simple cases, this clause is redundant, since\n+the `LIFETIME()` function will already enforce the required rule:\n \n-### Restrictions for loans of const aliasable pointees\n+    fn foo(point: &'a Point) -> &'static f32 {\n+        &point.x // Error\n+    }\n+\n+The above example fails to compile both because of clause (1) above\n+but also by the basic `LIFETIME()` check. However, in more advanced\n+examples involving multiple nested pointers, clause (1) is needed:\n+\n+    fn foo(point: &'a &'b mut Point) -> &'b f32 {\n+        &point.x // Error\n+    }\n+\n+The `LIFETIME` rule here would accept `'b` because, in fact, the\n+*memory is* guaranteed to remain valid (i.e., not be freed) for the\n+lifetime `'b`, since the `&mut` pointer is valid for `'b`. However, we\n+are returning an immutable reference, so we need the memory to be both\n+valid and immutable. Even though `point.x` is referenced by an `&mut`\n+pointer, it can still be considered immutable so long as that `&mut`\n+pointer is found in an aliased location. That means the memory is\n+guaranteed to be *immutable* for the lifetime of the `&` pointer,\n+which is only `'a`, not `'b`. Hence this example yields an error.\n+\n+As a final twist, consider the case of two nested *immutable*\n+pointers, rather than a mutable pointer within an immutable one:\n+\n+    fn foo(point: &'a &'b Point) -> &'b f32 {\n+        &point.x // OK\n+    }\n+\n+This function is legal. The reason for this is that the inner pointer\n+(`*point : &'b Point`) is enough to guarantee the memory is immutable\n+and valid for the lifetime `'b`.  This is reflected in\n+`RESTRICTIONS()` by the fact that we do not recurse (i.e., we impose\n+no restrictions on `LV`, which in this particular case is the pointer\n+`point : &'a &'b Point`).\n+\n+#### Why both `LIFETIME()` and `RESTRICTIONS()`?\n+\n+Given the previous text, it might seem that `LIFETIME` and\n+`RESTRICTIONS` should be folded together into one check, but there is\n+a reason that they are separated. They answer separate concerns.\n+The rules pertaining to `LIFETIME` exist to ensure that we don't\n+create a borrowed pointer that outlives the memory it points at. So\n+`LIFETIME` prevents a function like this:\n+\n+    fn get_1<'a>() -> &'a int {\n+        let x = 1;\n+        &x\n+    }\n+\n+Here we would be returning a pointer into the stack. Clearly bad.\n+\n+However, the `RESTRICTIONS` rules are more concerned with how memory\n+is used. The example above doesn't generate an error according to\n+`RESTRICTIONS` because, for local variables, we don't require that the\n+loan lifetime be a subset of the local variable lifetime. The idea\n+here is that we *can* guarantee that `x` is not (e.g.) mutated for the\n+lifetime `'a`, even though `'a` exceeds the function body and thus\n+involves unknown code in the caller -- after all, `x` ceases to exist\n+after we return and hence the remaining code in `'a` cannot possibly\n+mutate it. This distinction is important for type checking functions\n+like this one:\n+\n+    fn inc_and_get<'a>(p: &'a mut Point) -> &'a int {\n+        p.x += 1;\n+        &p.x\n+    }\n+\n+In this case, we take in a `&mut` and return a frozen borrowed pointer\n+with the same lifetime. So long as the lifetime of the returned value\n+doesn't exceed the lifetime of the `&mut` we receive as input, this is\n+fine, though it may seem surprising at first (it surprised me when I\n+first worked it through). After all, we're guaranteeing that `*p`\n+won't be mutated for the lifetime `'a`, even though we can't \"see\" the\n+entirety of the code during that lifetime, since some of it occurs in\n+our caller. But we *do* know that nobody can mutate `*p` except\n+through `p`. So if we don't mutate `*p` and we don't return `p`, then\n+we know that the right to mutate `*p` has been lost to our caller --\n+in terms of capability, the caller passed in the ability to mutate\n+`*p`, and we never gave it back. (Note that we can't return `p` while\n+`*p` is borrowed since that would be a move of `p`, as `&mut` pointers\n+are affine.)\n+\n+### Restrictions for loans of const aliasable referents\n \n Freeze pointers are read-only. There may be `&mut` or `&` aliases, and\n we can not prevent *anything* but moves in that case. So the\n@@ -549,185 +650,194 @@ result.\n     RESTRICTIONS(*LV, LT, []) = []                         // R-Deref-Freeze-Borrowed\n       TYPE(LV) = &const Ty or @const Ty\n \n-### Restrictions for loans of mutable borrowed pointees\n+### Restrictions for loans of mutable borrowed referents\n \n-Borrowing mutable borrowed pointees is a bit subtle because we permit\n-users to freeze or claim `&mut` pointees. To see what I mean, consider this\n-(perfectly safe) code example:\n+Mutable borrowed pointers are guaranteed to be the only way to mutate\n+their referent. This permits us to take greater license with them; for\n+example, the referent can be frozen simply be ensuring that we do not\n+use the original pointer to perform mutate. Similarly, we can allow\n+the referent to be claimed, so long as the original pointer is unused\n+while the new claimant is live.\n \n-    fn foo(t0: &mut T, op: fn(&T)) {\n-        let t1: &T = &*t0; // (1)\n-        op(t1);\n-    }\n+The rule for mutable borrowed pointers is as follows:\n \n-In the borrow marked `(1)`, the data at `*t0` is *frozen* as part of a\n-re-borrow. Therefore, for the lifetime of `t1`, `*t0` must not be\n-mutated. This is the same basic idea as when we freeze a mutable local\n-variable, but unlike in that case `t0` is a *pointer* to the data, and\n-thus we must enforce some subtle restrictions in order to guarantee\n-soundness.\n-\n-Intuitively, we must ensure that `*t0` is the only *mutable* path to\n-reach the memory that was frozen. The reason that we are so concerned\n-with *mutable* paths is that those are the paths through which the\n-user could mutate the data that was frozen and hence invalidate the\n-`t1` pointer. Note that const aliases to `*t0` are acceptable (and in\n-fact we can't prevent them without unacceptable performance cost, more\n-on that later) because\n-\n-There are two rules governing `&mut` pointers, but we'll begin with\n-the first. This rule governs cases where we are attempting to prevent\n-an `&mut` pointee from being mutated, claimed, or frozen, as occurs\n-whenever the `&mut` pointee `*LV` is reborrowed as mutable or\n-immutable:\n-\n-    RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed-1\n+    RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed\n       TYPE(LV) = &LT' mut Ty\n       LT <= LT'                                            // (1)\n-      RESTRICTIONS(LV, LT, MUTATE|CLAIM|ALIAS) = RS        // (2)\n-\n-There are two interesting parts to this rule:\n-\n-1. The lifetime of the loan (`LT`) cannot exceed the lifetime of the\n-   `&mut` pointer (`LT'`). The reason for this is that the `&mut`\n-   pointer is guaranteed to be the only legal way to mutate its\n-   pointee -- but only for the lifetime `LT'`.  After that lifetime,\n-   the loan on the pointee expires and hence the data may be modified\n-   by its owner again. This implies that we are only able to guarantee that\n-   the pointee will not be modified or aliased for a maximum of `LT'`.\n-\n-   Here is a concrete example of a bug this rule prevents:\n-\n-       // Test region-reborrow-from-shorter-mut-ref.rs:\n-       fn copy_pointer<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n-           &mut **p // ERROR due to clause (1)\n-       }\n-       fn main() {\n-           let mut x = 1;\n-           let mut y = &mut x; // <-'b-----------------------------+\n-           //      +-'a--------------------+                       |\n-           //      v                       v                       |\n-           let z = copy_borrowed_ptr(&mut y); // y is lent         |\n-           *y += 1; // Here y==z, so both should not be usable...  |\n-           *z += 1; // ...and yet they would be, but for clause 1. |\n-       } <---------------------------------------------------------+\n-\n-2. The final line recursively requires that the `&mut` *pointer* `LV`\n-   be restricted from being mutated, claimed, or aliased (not just the\n-   pointee). The goal of these restrictions is to ensure that, not\n-   considering the pointer that will result from this borrow, `LV`\n-   remains the *sole pointer with mutable access* to `*LV`.\n-\n-   Restrictions against claims are necessary because if the pointer in\n-   `LV` were to be somehow copied or moved to a different location,\n-   then the restriction issued for `*LV` would not apply to the new\n-   location. Note that because `&mut` values are non-copyable, a\n-   simple attempt to move the base pointer will fail due to the\n-   (implicit) restriction against moves:\n+      RESTRICTIONS(LV, LT, ACTIONS) = RS                   // (2)\n+\n+Let's examine the two numbered clauses:\n+\n+Clause (1) specifies that the lifetime of the loan (`LT`) cannot\n+exceed the lifetime of the `&mut` pointer (`LT'`). The reason for this\n+is that the `&mut` pointer is guaranteed to be the only legal way to\n+mutate its referent -- but only for the lifetime `LT'`.  After that\n+lifetime, the loan on the referent expires and hence the data may be\n+modified by its owner again. This implies that we are only able to\n+guarantee that the referent will not be modified or aliased for a\n+maximum of `LT'`.\n+\n+Here is a concrete example of a bug this rule prevents:\n+\n+     // Test region-reborrow-from-shorter-mut-ref.rs:\n+     fn copy_pointer<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n+         &mut **p // ERROR due to clause (1)\n+     }\n+     fn main() {\n+         let mut x = 1;\n+         let mut y = &mut x; // <-'b-----------------------------+\n+         //      +-'a--------------------+                       |\n+         //      v                       v                       |\n+         let z = copy_borrowed_ptr(&mut y); // y is lent         |\n+         *y += 1; // Here y==z, so both should not be usable...  |\n+         *z += 1; // ...and yet they would be, but for clause 1. |\n+     } <---------------------------------------------------------+\n+\n+Clause (2) propagates the restrictions on the referent to the pointer\n+itself. This is the same as with an owned pointer, though the\n+reasoning is mildly different. The basic goal in all cases is to\n+prevent the user from establishing another route to the same data. To\n+see what I mean, let's examine various cases of what can go wrong and\n+show how it is prevented.\n+\n+**Example danger 1: Moving the base pointer.** One of the simplest\n+ways to violate the rules is to move the base pointer to a new name\n+and access it via that new name, thus bypassing the restrictions on\n+the old name. Here is an example:\n \n        // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n        fn foo(t0: &mut int) {\n            let p: &int = &*t0; // Freezes `*t0`\n            let t1 = t0;        //~ ERROR cannot move out of `t0`\n-           *t1 = 22;\n+           *t1 = 22;           // OK, not a write through `*t0`\n        }\n \n-   However, the additional restrictions against claims mean that even\n-   a clever attempt to use a swap to circumvent the type system will\n-   encounter an error:\n+Remember that `&mut` pointers are linear, and hence `let t1 = t0` is a\n+move of `t0` -- or would be, if it were legal. Instead, we get an\n+error, because clause (2) imposes restrictions on `LV` (`t0`, here),\n+and any restrictions on a path make it impossible to move from that\n+path.\n \n-       // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n+**Example danger 2: Claiming the base pointer.** Another possible\n+danger is to mutably borrow the base path. This can lead to two bad\n+scenarios. The most obvious is that the mutable borrow itself becomes\n+another path to access the same data, as shown here:\n+\n+       // src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs\n        fn foo<'a>(mut t0: &'a mut int,\n                   mut t1: &'a mut int) {\n            let p: &int = &*t0;     // Freezes `*t0`\n-           swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n-           *t1 = 22;\n+           let mut t2 = &mut t0;   //~ ERROR cannot borrow `t0`\n+           **t2 += 1;              // Mutates `*t0`\n        }\n \n-   The restriction against *aliasing* (and, in turn, freezing) is\n-   necessary because, if an alias were of `LV` were to be produced,\n-   then `LV` would no longer be the sole path to access the `&mut`\n-   pointee. Since we are only issuing restrictions against `*LV`,\n-   these other aliases would be unrestricted, and the result would be\n-   unsound. For example:\n-\n-    // src/test/compile-fail/borrowck-alias-mut-base-ptr.rs\n-    fn foo(t0: &mut int) {\n-        let p: &int = &*t0; // Freezes `*t0`\n-        let q: &const &mut int = &const t0; //~ ERROR cannot borrow `t0`\n-        **q = 22;\n-    }\n-\n-The current rules could use some correction:\n-\n-1. Issue #10520. Now that the swap operator has been removed, I do not\n-   believe the restriction against mutating `LV` is needed, and in\n-   fact it prevents some useful patterns. For example, the following\n-   function will fail to compile:\n+In this example, `**t2` is the same memory as `*t0`. Because `t2` is\n+an `&mut` pointer, `**t2` is a unique path and hence it would be\n+possible to mutate `**t2` even though that memory was supposed to be\n+frozen by the creation of `p`. However, an error is reported -- the\n+reason is that the freeze `&*t0` will restrict claims and mutation\n+against `*t0` which, by clause 2, in turn prevents claims and mutation\n+of `t0`. Hence the claim `&mut t0` is illegal.\n \n-       fn mut_shift_ref<'a,T>(x: &mut &'a mut [T]) -> &'a mut T {\n-           // `mut_split_at` will restrict mutation against *x:\n-           let (head, tail) = (*x).mut_split_at(1);\n+Another danger with an `&mut` pointer is that we could swap the `t0`\n+value away to create a new path:\n \n-           // Hence mutating `*x` yields an error here:\n-           *x = tail;\n-           &mut head[0]\n+       // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n+       fn foo<'a>(mut t0: &'a mut int,\n+                  mut t1: &'a mut int) {\n+           let p: &int = &*t0;     // Freezes `*t0`\n+           swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n+           *t1 = 22;\n        }\n \n-   Note that this function -- which adjusts the slice `*x` in place so\n-   that it no longer contains the head element and then returns a\n-   pointer to that element separately -- is perfectly valid. It is\n-   currently implemented using unsafe code. I believe that now that\n-   the swap operator is removed from the language, we could liberalize\n-   the rules and make this function be accepted normally. The idea\n-   would be to have the assignment to `*x` kill the loans of `*x` and\n-   its subpaths -- after all, those subpaths are no longer accessible\n-   through `*x`, since it has been overwritten with a new value. Thus\n-   those subpaths are only accessible through prior existing borrows\n-   of `*x`, if any. The danger of the *swap* operator was that it\n-   allowed `*x` to be mutated without making the subpaths of `*x`\n-   inaccessible: worse, they became accessible through a new path (I\n-   suppose that we could support swap, too, if needed, by moving the\n-   loans over to the new path).\n-\n-   Note: the `swap()` function doesn't pose the same danger as the\n-   swap operator because it requires taking `&mut` refs to invoke it.\n-\n-2. Issue #9629. The current rules correctly prohibit `&mut` pointees\n-   from being assigned unless they are in a unique location. However,\n-   we *also* prohibit `&mut` pointees from being frozen. This prevents\n-   compositional patterns, like this one:\n-\n-       struct BorrowedMap<'a> {\n-           map: &'a mut HashMap\n-       }\n+This is illegal for the same reason as above. Note that if we added\n+back a swap operator -- as we used to have -- we would want to be very\n+careful to ensure this example is still illegal.\n \n-   If we have a pointer `x:&BorrowedMap`, we can't freeze `x.map`,\n-   and hence can't call `find` etc on it. But that's silly, since\n-   fact that the `&mut` exists in frozen data implies that it\n-   will not be mutable by anyone. For example, this program nets an\n-   error:\n+**Example danger 3: Freeze the base pointer.** In the case where the\n+referent is claimed, even freezing the base pointer can be dangerous,\n+as shown in the following example:\n \n-       fn main() {\n-           let a = &mut 2;\n-           let b = &a;\n-           *a += 1; // ERROR: cannot assign to `*a` because it is borrowed\n+       // src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs\n+       fn foo<'a>(mut t0: &'a mut int,\n+                  mut t1: &'a mut int) {\n+           let p: &mut int = &mut *t0; // Claims `*t0`\n+           let mut t2 = &t0;           //~ ERROR cannot borrow `t0`\n+           let q: &int = &*t2;         // Freezes `*t0` but not through `*p`\n+           *p += 1;                    // violates type of `*q`\n        }\n \n-   (Naturally `&mut` reborrows from an `&&mut` pointee should be illegal.)\n+Here the problem is that `*t0` is claimed by `p`, and hence `p` wants\n+to be the controlling pointer through which mutation or freezes occur.\n+But `t2` would -- if it were legal -- have the type `& &mut int`, and\n+hence would be a mutable pointer in an aliasable location, which is\n+considered frozen (since no one can write to `**t2` as it is not a\n+unique path). Therefore, we could reasonably create a frozen `&int`\n+pointer pointing at `*t0` that coexists with the mutable pointer `p`,\n+which is clearly unsound.\n \n-The second rule for `&mut` handles the case where we are not adding\n-any restrictions (beyond the default of \"no move\"):\n+However, it is not always unsafe to freeze the base pointer. In\n+particular, if the referent is frozen, there is no harm in it:\n \n-    RESTRICTIONS(*LV, LT, []) = []                    // R-Deref-Mut-Borrowed-2\n-      TYPE(LV) = &mut Ty\n+       // src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs\n+       fn foo<'a>(mut t0: &'a mut int,\n+                  mut t1: &'a mut int) {\n+           let p: &int = &*t0; // Freezes `*t0`\n+           let mut t2 = &t0;\n+           let q: &int = &*t2; // Freezes `*t0`, but that's ok...\n+           let r: &int = &*t0; // ...after all, could do same thing directly.\n+       }\n \n-Moving from an `&mut` pointee is never legal, so no special\n-restrictions are needed. This rule is used for `&const` borrows.\n+In this case, creating the alias `t2` of `t0` is safe because the only\n+thing `t2` can be used for is to further freeze `*t0`, which is\n+already frozen. In particular, we cannot assign to `*t0` through the\n+new alias `t2`, as demonstrated in this test case:\n \n-### Restrictions for loans of mutable managed pointees\n+       // src/test/run-pass/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs\n+       fn foo(t0: & &mut int) {\n+           let t1 = t0;\n+           let p: &int = &**t0;\n+           **t1 = 22; //~ ERROR cannot assign\n+       }\n \n-With `@mut` pointees, we don't make any static guarantees.  But as a\n+This distinction is reflected in the rules. When doing an `&mut`\n+borrow -- as in the first example -- the set `ACTIONS` will be\n+`CLAIM|MUTATE|FREEZE`, because claiming the referent implies that it\n+cannot be claimed, mutated, or frozen by anyone else. These\n+restrictions are propagated back to the base path and hence the base\n+path is considered unfreezable.\n+\n+In contrast, when the referent is merely frozen -- as in the second\n+example -- the set `ACTIONS` will be `CLAIM|MUTATE`, because freezing\n+the referent implies that it cannot be claimed or mutated but permits\n+others to freeze. Hence when these restrictions are propagated back to\n+the base path, it will still be considered freezable.\n+\n+\n+\n+**FIXME #10520: Restrictions against mutating the base pointer.** When\n+an `&mut` pointer is frozen or claimed, we currently pass along the\n+restriction against MUTATE to the base pointer. I do not believe this\n+restriction is needed. It dates from the days when we had a way to\n+mutate that preserved the value being mutated (i.e., swap). Nowadays\n+the only form of mutation is assignment, which destroys the pointer\n+being mutated -- therefore, a mutation cannot create a new path to the\n+same data. Rather, it removes an existing path. This implies that not\n+only can we permit mutation, we can have mutation kill restrictions in\n+the dataflow sense.\n+\n+**WARNING:** We do not currently have `const` borrows in the\n+language. If they are added back in, we must ensure that they are\n+consistent with all of these examples. The crucial question will be\n+what sorts of actions are permitted with a `&const &mut` pointer. I\n+would suggest that an `&mut` referent found in an `&const` location be\n+prohibited from both freezes and claims. This would avoid the need to\n+prevent `const` borrows of the base pointer when the referent is\n+borrowed.\n+\n+### Restrictions for loans of mutable managed referents\n+\n+With `@mut` referents, we don't make any static guarantees.  But as a\n convenience, we still register a restriction against `*LV`, because\n that way if we *can* find a simple static error, we will:\n \n@@ -891,11 +1001,6 @@ computed for that program point.\n While writing up these docs, I encountered some rules I believe to be\n stricter than necessary:\n \n-- I think the restriction against mutating `&mut` pointers found in an\n-  aliasable location is unnecessary. They cannot be reborrowed, to be sure,\n-  so it should be safe to mutate them. Lifting this might cause some common\n-  cases (`&mut int`) to work just fine, but might lead to further confusion\n-  in other cases, so maybe it's best to leave it as is.\n - I think restricting the `&mut` LV against moves and `ALIAS` is sufficient,\n   `MUTATE` and `CLAIM` are overkill. `MUTATE` was necessary when swap was\n   a built-in operator, but as it is not, it is implied by `CLAIM`,"}, {"sha": "0490fd19aa452961bdb7fa52b4c8eb810adea835", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=d441c5468814b0d8f9ccdba426baf1f16b5134fc", "patch": "@@ -114,10 +114,26 @@ impl<'self> RestrictionsContext<'self> {\n             }\n \n             mc::cat_copied_upvar(..) | // FIXME(#2152) allow mutation of upvars\n-            mc::cat_static_item(..) |\n-            mc::cat_deref(_, _, mc::region_ptr(MutImmutable, _)) |\n-            mc::cat_deref(_, _, mc::gc_ptr(MutImmutable)) => {\n+            mc::cat_static_item(..) => {\n+                Safe\n+            }\n+\n+            mc::cat_deref(cmt_base, _, mc::region_ptr(MutImmutable, lt)) => {\n                 // R-Deref-Imm-Borrowed\n+                if !self.bccx.is_subregion_of(self.loan_region, lt) {\n+                    self.bccx.report(\n+                        BckError {\n+                            span: self.span,\n+                            cmt: cmt_base,\n+                            code: err_borrowed_pointer_too_short(\n+                                self.loan_region, lt, restrictions)});\n+                    return Safe;\n+                }\n+                Safe\n+            }\n+\n+            mc::cat_deref(_, _, mc::gc_ptr(MutImmutable)) => {\n+                // R-Deref-Imm-Managed\n                 Safe\n             }\n \n@@ -170,30 +186,19 @@ impl<'self> RestrictionsContext<'self> {\n             }\n \n             mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(MutMutable, lt)) => {\n-                // Because an `&mut` pointer does not inherit its\n-                // mutability, we can only prevent mutation or prevent\n-                // freezing if it is not aliased. Therefore, in such\n-                // cases we restrict aliasing on `cmt_base`.\n-                if restrictions != RESTR_EMPTY {\n-                    if !self.bccx.is_subregion_of(self.loan_region, lt) {\n-                        self.bccx.report(\n-                            BckError {\n-                                span: self.span,\n-                                cmt: cmt_base,\n-                                code: err_mut_pointer_too_short(\n-                                    self.loan_region, lt, restrictions)});\n-                        return Safe;\n-                    }\n-\n-                    // R-Deref-Mut-Borrowed-1\n-                    let result = self.restrict(\n-                        cmt_base,\n-                        RESTR_ALIAS | RESTR_MUTATE | RESTR_CLAIM);\n-                    self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n-                } else {\n-                    // R-Deref-Mut-Borrowed-2\n-                    Safe\n+                // R-Deref-Mut-Borrowed\n+                if !self.bccx.is_subregion_of(self.loan_region, lt) {\n+                    self.bccx.report(\n+                        BckError {\n+                            span: self.span,\n+                            cmt: cmt_base,\n+                            code: err_borrowed_pointer_too_short(\n+                                self.loan_region, lt, restrictions)});\n+                    return Safe;\n                 }\n+\n+                let result = self.restrict(cmt_base, restrictions);\n+                self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n             }\n \n             mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {"}, {"sha": "7283374936167760ce6748496b76d7ffe80f5ca6", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=d441c5468814b0d8f9ccdba426baf1f16b5134fc", "patch": "@@ -444,7 +444,8 @@ pub enum bckerr_code {\n     err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n     err_freeze_aliasable_const,\n-    err_mut_pointer_too_short(ty::Region, ty::Region, RestrictionSet), // loan, ptr\n+    err_borrowed_pointer_too_short(\n+        ty::Region, ty::Region, RestrictionSet), // loan, ptr\n }\n \n // Combination of an error code and the categorization of the expression\n@@ -670,21 +671,15 @@ impl BorrowckCtxt {\n                 // supposed to be going away.\n                 format!(\"unsafe borrow of aliasable, const value\")\n             }\n-            err_mut_pointer_too_short(_, _, r) => {\n+            err_borrowed_pointer_too_short(..) => {\n                 let descr = match opt_loan_path(err.cmt) {\n                     Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n-                    None => ~\"`&mut` pointer\"\n+                    None => self.cmt_to_str(err.cmt),\n                 };\n \n-                let tag = if r.intersects(RESTR_ALIAS) {\n-                    \"its contents are unique\"\n-                } else {\n-                    \"its contents are not otherwise mutable\"\n-                };\n-\n-                format!(\"lifetime of {} is too short to guarantee {} \\\n-                        so they can be safely reborrowed\",\n-                        descr, tag)\n+                format!(\"lifetime of {} is too short to guarantee \\\n+                        its contents can be safely reborrowed\",\n+                        descr)\n             }\n         }\n     }\n@@ -761,10 +756,10 @@ impl BorrowckCtxt {\n                     \"\");\n             }\n \n-            err_mut_pointer_too_short(loan_scope, ptr_scope, _) => {\n+            err_borrowed_pointer_too_short(loan_scope, ptr_scope, _) => {\n                 let descr = match opt_loan_path(err.cmt) {\n                     Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n-                    None => ~\"`&mut` pointer\"\n+                    None => self.cmt_to_str(err.cmt),\n                 };\n                 note_and_explain_region(\n                     self.tcx,"}, {"sha": "f72dacc2d813c6c58be605d80135b25dada90d70", "filename": "src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs?ref=d441c5468814b0d8f9ccdba426baf1f16b5134fc", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n // Test that attempt to reborrow an `&mut` pointer in an aliasable\n // location yields an error.\n //\n@@ -7,7 +17,7 @@ use std::util::swap;\n \n fn foo(t0: & &mut int) {\n     let t1 = t0;\n-    let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&` pointer\n+    let p: &int = &**t0;\n     **t1 = 22; //~ ERROR cannot assign\n }\n "}, {"sha": "3f67952fa8ef026c436f4c4665cb58d5cb0271ab", "filename": "src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-of-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-of-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-of-mut-base-ptr.rs?ref=d441c5468814b0d8f9ccdba426baf1f16b5134fc", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that attempt to freeze an `&mut` pointer while referent is\n+// claimed yields an error.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+use std::util::swap;\n+\n+fn foo<'a>(mut t0: &'a mut int,\n+           mut t1: &'a mut int) {\n+    let p: &mut int = &mut *t0; // Claims `*t0`\n+    let mut t2 = &t0;           //~ ERROR cannot borrow `t0`\n+    let q: &int = &**t2;        // Freezes `*t0` but not through `*p`\n+    *p += 1;                    // violates type of `*q`\n+}\n+\n+fn main() {\n+}"}, {"sha": "b41fa5b8d3377d34cea7cf0a641f39b747fd431f", "filename": "src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-borrow-of-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-borrow-of-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-borrow-of-mut-base-ptr.rs?ref=d441c5468814b0d8f9ccdba426baf1f16b5134fc", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that attempt to mutably borrow `&mut` pointer while pointee is\n+// borrowed yields an error.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+use std::util::swap;\n+\n+fn foo<'a>(mut t0: &'a mut int,\n+           mut t1: &'a mut int) {\n+    let p: &int = &*t0;     // Freezes `*t0`\n+    let mut t2 = &mut t0;   //~ ERROR cannot borrow `t0`\n+    **t2 += 1;              // Mutates `*t0`\n+}\n+\n+fn bar<'a>(mut t0: &'a mut int,\n+           mut t1: &'a mut int) {\n+    let p: &mut int = &mut *t0; // Claims `*t0`\n+    let mut t2 = &mut t0;       //~ ERROR cannot borrow `t0`\n+    **t2 += 1;                  // Mutates `*t0` but not through `*p`\n+}\n+\n+fn main() {\n+}"}, {"sha": "b7aa2989ac5820466348e361385130bfb5a8ae98", "filename": "src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Ftest%2Frun-pass%2Fborrowck-borrow-of-mut-base-ptr-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Ftest%2Frun-pass%2Fborrowck-borrow-of-mut-base-ptr-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-of-mut-base-ptr-safe.rs?ref=d441c5468814b0d8f9ccdba426baf1f16b5134fc", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that freezing an `&mut` pointer while referent is\n+// frozen is legal.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+fn foo<'a>(mut t0: &'a mut int,\n+           mut t1: &'a mut int) {\n+    let p: &int = &*t0; // Freezes `*t0`\n+    let mut t2 = &t0;\n+    let q: &int = &**t2; // Freezes `*t0`, but that's ok...\n+    let r: &int = &*t0; // ...after all, could do same thing directly.\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "77e1a258dec846184854be73e810a7a74d0d3273", "filename": "src/test/run-pass/borrowck-freeze-frozen-mut.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d441c5468814b0d8f9ccdba426baf1f16b5134fc/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs?ref=d441c5468814b0d8f9ccdba426baf1f16b5134fc", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a `&mut` inside of an `&` is freezable.\n+\n+struct MutSlice<'a, T> {\n+    data: &'a mut [T]\n+}\n+\n+fn get<'a, T>(ms: &'a MutSlice<'a, T>, index: uint) -> &'a T {\n+    &ms.data[index]\n+}\n+\n+pub fn main() {\n+    let mut data = [1, 2, 3];\n+    {\n+        let slice = MutSlice { data: data };\n+        slice.data[0] += 4;\n+        let index0 = get(&slice, 0);\n+        let index1 = get(&slice, 1);\n+        let index2 = get(&slice, 2);\n+        assert_eq!(*index0, 5);\n+        assert_eq!(*index1, 2);\n+        assert_eq!(*index2, 3);\n+    }\n+    assert_eq!(data[0], 5);\n+    assert_eq!(data[1], 2);\n+    assert_eq!(data[2], 3);\n+}"}]}