{"sha": "6673e515b770350a97b42e2518f64908f2db16b3", "node_id": "C_kwDOAAsO6NoAKDY2NzNlNTE1Yjc3MDM1MGE5N2I0MmUyNTE4ZjY0OTA4ZjJkYjE2YjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-14T12:50:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-14T12:50:26Z"}, "message": "Auto merge of #13948 - Veykril:inlay-hints, r=Veykril\n\nMake inlay hint location links work for more types", "tree": {"sha": "e9db5a7fc80a6cb461d85969caf936bc2a678b01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9db5a7fc80a6cb461d85969caf936bc2a678b01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6673e515b770350a97b42e2518f64908f2db16b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6673e515b770350a97b42e2518f64908f2db16b3", "html_url": "https://github.com/rust-lang/rust/commit/6673e515b770350a97b42e2518f64908f2db16b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6673e515b770350a97b42e2518f64908f2db16b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce6955c10e579f936dee9905dff223d816061299", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce6955c10e579f936dee9905dff223d816061299", "html_url": "https://github.com/rust-lang/rust/commit/ce6955c10e579f936dee9905dff223d816061299"}, {"sha": "27ba598dfe293b7ec9c07015c86cb8eeb4f6a24d", "url": "https://api.github.com/repos/rust-lang/rust/commits/27ba598dfe293b7ec9c07015c86cb8eeb4f6a24d", "html_url": "https://github.com/rust-lang/rust/commit/27ba598dfe293b7ec9c07015c86cb8eeb4f6a24d"}], "stats": {"total": 321, "additions": 221, "deletions": 100}, "files": [{"sha": "3a96e53d719e960218a2e5528256e5a59540be00", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 108, "deletions": 74, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=6673e515b770350a97b42e2518f64908f2db16b3", "patch": "@@ -325,7 +325,7 @@ impl HirDisplay for ProjectionTy {\n \n         let trait_ref = self.trait_ref(f.db);\n         write!(f, \"<\")?;\n-        fmt_trait_ref(&trait_ref, f, true)?;\n+        fmt_trait_ref(f, &trait_ref, true)?;\n         write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n         let proj_params_count =\n             self.substitution.len(Interner) - trait_ref.substitution.len(Interner);\n@@ -383,7 +383,10 @@ impl HirDisplay for BoundVar {\n }\n \n impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(\n+        &self,\n+        f @ &mut HirFormatter { db, .. }: &mut HirFormatter<'_>,\n+    ) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{TYPE_HINT_TRUNCATION}\");\n         }\n@@ -434,7 +437,7 @@ impl HirDisplay for Ty {\n                     bounds.iter().any(|bound| {\n                         if let WhereClause::Implemented(trait_ref) = bound.skip_binders() {\n                             let trait_ = trait_ref.hir_trait_id();\n-                            fn_traits(f.db.upcast(), trait_).any(|it| it == trait_)\n+                            fn_traits(db.upcast(), trait_).any(|it| it == trait_)\n                         } else {\n                             false\n                         }\n@@ -450,12 +453,11 @@ impl HirDisplay for Ty {\n                         substitution: parameters,\n                     }))\n                     | TyKind::OpaqueType(opaque_ty_id, parameters) => {\n-                        let impl_trait_id =\n-                            f.db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n+                        let impl_trait_id = db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n                         if let ImplTraitId::ReturnTypeImplTrait(func, idx) = impl_trait_id {\n-                            let datas =\n-                                f.db.return_type_impl_traits(func)\n-                                    .expect(\"impl trait id without data\");\n+                            let datas = db\n+                                .return_type_impl_traits(func)\n+                                .expect(\"impl trait id without data\");\n                             let data = (*datas)\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n@@ -465,7 +467,7 @@ impl HirDisplay for Ty {\n                             // Don't count Sized but count when it absent\n                             // (i.e. when explicit ?Sized bound is set).\n                             let default_sized = SizedByDefault::Sized {\n-                                anchor: func.lookup(f.db.upcast()).module(f.db.upcast()).krate(),\n+                                anchor: func.lookup(db.upcast()).module(db.upcast()).krate(),\n                             };\n                             let sized_bounds = bounds\n                                 .skip_binders()\n@@ -476,7 +478,7 @@ impl HirDisplay for Ty {\n                                         WhereClause::Implemented(trait_ref)\n                                             if default_sized.is_sized_trait(\n                                                 trait_ref.hir_trait_id(),\n-                                                f.db.upcast(),\n+                                                db.upcast(),\n                                             ),\n                                     )\n                                 })\n@@ -524,19 +526,19 @@ impl HirDisplay for Ty {\n                 sig.hir_fmt(f)?;\n             }\n             TyKind::FnDef(def, parameters) => {\n-                let def = from_chalk(f.db, *def);\n-                let sig = f.db.callable_item_signature(def).substitute(Interner, parameters);\n+                let def = from_chalk(db, *def);\n+                let sig = db.callable_item_signature(def).substitute(Interner, parameters);\n+                f.start_location_link(def.into());\n                 match def {\n-                    CallableDefId::FunctionId(ff) => {\n-                        write!(f, \"fn {}\", f.db.function_data(ff).name)?\n-                    }\n-                    CallableDefId::StructId(s) => write!(f, \"{}\", f.db.struct_data(s).name)?,\n+                    CallableDefId::FunctionId(ff) => write!(f, \"fn {}\", db.function_data(ff).name)?,\n+                    CallableDefId::StructId(s) => write!(f, \"{}\", db.struct_data(s).name)?,\n                     CallableDefId::EnumVariantId(e) => {\n-                        write!(f, \"{}\", f.db.enum_data(e.parent).variants[e.local_id].name)?\n+                        write!(f, \"{}\", db.enum_data(e.parent).variants[e.local_id].name)?\n                     }\n                 };\n+                f.end_location_link();\n                 if parameters.len(Interner) > 0 {\n-                    let generics = generics(f.db.upcast(), def.into());\n+                    let generics = generics(db.upcast(), def.into());\n                     let (parent_params, self_param, type_params, const_params, _impl_trait_params) =\n                         generics.provenance_split();\n                     let total_len = parent_params + self_param + type_params + const_params;\n@@ -568,15 +570,15 @@ impl HirDisplay for Ty {\n                 match f.display_target {\n                     DisplayTarget::Diagnostics | DisplayTarget::Test => {\n                         let name = match *def_id {\n-                            hir_def::AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n-                            hir_def::AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n-                            hir_def::AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n+                            hir_def::AdtId::StructId(it) => db.struct_data(it).name.clone(),\n+                            hir_def::AdtId::UnionId(it) => db.union_data(it).name.clone(),\n+                            hir_def::AdtId::EnumId(it) => db.enum_data(it).name.clone(),\n                         };\n                         write!(f, \"{name}\")?;\n                     }\n                     DisplayTarget::SourceCode { module_id } => {\n                         if let Some(path) = find_path::find_path(\n-                            f.db.upcast(),\n+                            db.upcast(),\n                             ItemInNs::Types((*def_id).into()),\n                             module_id,\n                             false,\n@@ -596,8 +598,8 @@ impl HirDisplay for Ty {\n                         || f.omit_verbose_types()\n                     {\n                         match self\n-                            .as_generic_def(f.db)\n-                            .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n+                            .as_generic_def(db)\n+                            .map(|generic_def_id| db.generic_defaults(generic_def_id))\n                             .filter(|defaults| !defaults.is_empty())\n                         {\n                             None => parameters.as_slice(Interner),\n@@ -669,16 +671,23 @@ impl HirDisplay for Ty {\n             }\n             TyKind::AssociatedType(assoc_type_id, parameters) => {\n                 let type_alias = from_assoc_type_id(*assoc_type_id);\n-                let trait_ = match type_alias.lookup(f.db.upcast()).container {\n+                let trait_ = match type_alias.lookup(db.upcast()).container {\n                     ItemContainerId::TraitId(it) => it,\n                     _ => panic!(\"not an associated type\"),\n                 };\n-                let trait_ = f.db.trait_data(trait_);\n-                let type_alias_data = f.db.type_alias_data(type_alias);\n+                let trait_data = db.trait_data(trait_);\n+                let type_alias_data = db.type_alias_data(type_alias);\n \n                 // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n                 if f.display_target.is_test() {\n-                    write!(f, \"{}::{}\", trait_.name, type_alias_data.name)?;\n+                    f.start_location_link(trait_.into());\n+                    write!(f, \"{}\", trait_data.name)?;\n+                    f.end_location_link();\n+                    write!(f, \"::\")?;\n+\n+                    f.start_location_link(type_alias.into());\n+                    write!(f, \"{}\", type_alias_data.name)?;\n+                    f.end_location_link();\n                     // Note that the generic args for the associated type come before those for the\n                     // trait (including the self type).\n                     // FIXME: reconsider the generic args order upon formatting?\n@@ -697,25 +706,28 @@ impl HirDisplay for Ty {\n                 }\n             }\n             TyKind::Foreign(type_alias) => {\n-                let type_alias = f.db.type_alias_data(from_foreign_def_id(*type_alias));\n+                let alias = from_foreign_def_id(*type_alias);\n+                let type_alias = db.type_alias_data(alias);\n+                f.start_location_link(alias.into());\n                 write!(f, \"{}\", type_alias.name)?;\n+                f.end_location_link();\n             }\n             TyKind::OpaqueType(opaque_ty_id, parameters) => {\n-                let impl_trait_id = f.db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n+                let impl_trait_id = db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n                 match impl_trait_id {\n                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n-                            f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n+                            db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                         let bounds = data.substitute(Interner, &parameters);\n-                        let krate = func.lookup(f.db.upcast()).module(f.db.upcast()).krate();\n+                        let krate = func.lookup(db.upcast()).module(db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix(\n+                            f,\n                             \"impl\",\n                             bounds.skip_binders(),\n                             SizedByDefault::Sized { anchor: krate },\n-                            f,\n                         )?;\n                         // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n                     }\n@@ -732,7 +744,7 @@ impl HirDisplay for Ty {\n                         DisplaySourceCodeError::Closure,\n                     ));\n                 }\n-                let sig = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(f.db);\n+                let sig = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(db);\n                 if let Some(sig) = sig {\n                     if sig.params().is_empty() {\n                         write!(f, \"||\")?;\n@@ -751,37 +763,37 @@ impl HirDisplay for Ty {\n                 }\n             }\n             TyKind::Placeholder(idx) => {\n-                let id = from_placeholder_idx(f.db, *idx);\n-                let generics = generics(f.db.upcast(), id.parent);\n+                let id = from_placeholder_idx(db, *idx);\n+                let generics = generics(db.upcast(), id.parent);\n                 let param_data = &generics.params.type_or_consts[id.local_id];\n                 match param_data {\n                     TypeOrConstParamData::TypeParamData(p) => match p.provenance {\n                         TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n                             write!(f, \"{}\", p.name.clone().unwrap_or_else(Name::missing))?\n                         }\n                         TypeParamProvenance::ArgumentImplTrait => {\n-                            let substs = generics.placeholder_subst(f.db);\n-                            let bounds =\n-                                f.db.generic_predicates(id.parent)\n-                                    .iter()\n-                                    .map(|pred| pred.clone().substitute(Interner, &substs))\n-                                    .filter(|wc| match &wc.skip_binders() {\n-                                        WhereClause::Implemented(tr) => {\n-                                            &tr.self_type_parameter(Interner) == self\n-                                        }\n-                                        WhereClause::AliasEq(AliasEq {\n-                                            alias: AliasTy::Projection(proj),\n-                                            ty: _,\n-                                        }) => &proj.self_type_parameter(f.db) == self,\n-                                        _ => false,\n-                                    })\n-                                    .collect::<Vec<_>>();\n-                            let krate = id.parent.module(f.db.upcast()).krate();\n+                            let substs = generics.placeholder_subst(db);\n+                            let bounds = db\n+                                .generic_predicates(id.parent)\n+                                .iter()\n+                                .map(|pred| pred.clone().substitute(Interner, &substs))\n+                                .filter(|wc| match &wc.skip_binders() {\n+                                    WhereClause::Implemented(tr) => {\n+                                        &tr.self_type_parameter(Interner) == self\n+                                    }\n+                                    WhereClause::AliasEq(AliasEq {\n+                                        alias: AliasTy::Projection(proj),\n+                                        ty: _,\n+                                    }) => &proj.self_type_parameter(db) == self,\n+                                    _ => false,\n+                                })\n+                                .collect::<Vec<_>>();\n+                            let krate = id.parent.module(db.upcast()).krate();\n                             write_bounds_like_dyn_trait_with_prefix(\n+                                f,\n                                 \"impl\",\n                                 &bounds,\n                                 SizedByDefault::Sized { anchor: krate },\n-                                f,\n                             )?;\n                         }\n                     },\n@@ -803,29 +815,29 @@ impl HirDisplay for Ty {\n                 bounds.extend(auto_traits);\n \n                 write_bounds_like_dyn_trait_with_prefix(\n+                    f,\n                     \"dyn\",\n                     &bounds,\n                     SizedByDefault::NotSized,\n-                    f,\n                 )?;\n             }\n             TyKind::Alias(AliasTy::Projection(p_ty)) => p_ty.hir_fmt(f)?,\n             TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n-                let impl_trait_id = f.db.lookup_intern_impl_trait_id(opaque_ty.opaque_ty_id.into());\n+                let impl_trait_id = db.lookup_intern_impl_trait_id(opaque_ty.opaque_ty_id.into());\n                 match impl_trait_id {\n                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n-                            f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n+                            db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                         let bounds = data.substitute(Interner, &opaque_ty.substitution);\n-                        let krate = func.lookup(f.db.upcast()).module(f.db.upcast()).krate();\n+                        let krate = func.lookup(db.upcast()).module(db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix(\n+                            f,\n                             \"impl\",\n                             bounds.skip_binders(),\n                             SizedByDefault::Sized { anchor: krate },\n-                            f,\n                         )?;\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n@@ -848,7 +860,6 @@ impl HirDisplay for Ty {\n                         DisplaySourceCodeError::Generator,\n                     ));\n                 }\n-\n                 let subst = subst.as_slice(Interner);\n                 let a: Option<SmallVec<[&Ty; 3]>> = subst\n                     .get(subst.len() - 3..)\n@@ -923,26 +934,26 @@ impl SizedByDefault {\n }\n \n pub fn write_bounds_like_dyn_trait_with_prefix(\n+    f: &mut HirFormatter<'_>,\n     prefix: &str,\n     predicates: &[QuantifiedWhereClause],\n     default_sized: SizedByDefault,\n-    f: &mut HirFormatter<'_>,\n ) -> Result<(), HirDisplayError> {\n     write!(f, \"{prefix}\")?;\n     if !predicates.is_empty()\n         || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. })\n     {\n         write!(f, \" \")?;\n-        write_bounds_like_dyn_trait(predicates, default_sized, f)\n+        write_bounds_like_dyn_trait(f, predicates, default_sized)\n     } else {\n         Ok(())\n     }\n }\n \n fn write_bounds_like_dyn_trait(\n+    f: &mut HirFormatter<'_>,\n     predicates: &[QuantifiedWhereClause],\n     default_sized: SizedByDefault,\n-    f: &mut HirFormatter<'_>,\n ) -> Result<(), HirDisplayError> {\n     // Note: This code is written to produce nice results (i.e.\n     // corresponding to surface Rust) for types that can occur in\n@@ -978,7 +989,9 @@ fn write_bounds_like_dyn_trait(\n                 // We assume that the self type is ^0.0 (i.e. the\n                 // existential) here, which is the only thing that's\n                 // possible in actual Rust, and hence don't print it\n+                f.start_location_link(trait_.into());\n                 write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n+                f.end_location_link();\n                 if let [_, params @ ..] = &*trait_ref.substitution.as_slice(Interner) {\n                     if is_fn_trait {\n                         if let Some(args) =\n@@ -1015,7 +1028,9 @@ fn write_bounds_like_dyn_trait(\n                 if let AliasTy::Projection(proj) = alias {\n                     let assoc_ty_id = from_assoc_type_id(proj.associated_ty_id);\n                     let type_alias = f.db.type_alias_data(assoc_ty_id);\n+                    f.start_location_link(assoc_ty_id.into());\n                     write!(f, \"{}\", type_alias.name)?;\n+                    f.end_location_link();\n \n                     let proj_arg_count = generics(f.db.upcast(), assoc_ty_id.into()).len_self();\n                     if proj_arg_count > 0 {\n@@ -1040,19 +1055,34 @@ fn write_bounds_like_dyn_trait(\n     if angle_open {\n         write!(f, \">\")?;\n     }\n-    if matches!(default_sized, SizedByDefault::Sized { .. }) {\n+    if let SizedByDefault::Sized { anchor } = default_sized {\n+        let sized_trait =\n+            f.db.lang_item(anchor, SmolStr::new_inline(\"sized\"))\n+                .and_then(|lang_item| lang_item.as_trait());\n         if !is_sized {\n-            write!(f, \"{}?Sized\", if first { \"\" } else { \" + \" })?;\n+            if !first {\n+                write!(f, \" + \")?;\n+            }\n+            if let Some(sized_trait) = sized_trait {\n+                f.start_location_link(sized_trait.into());\n+            }\n+            write!(f, \"?Sized\")?;\n         } else if first {\n+            if let Some(sized_trait) = sized_trait {\n+                f.start_location_link(sized_trait.into());\n+            }\n             write!(f, \"Sized\")?;\n         }\n+        if let Some(_) = sized_trait {\n+            f.end_location_link();\n+        }\n     }\n     Ok(())\n }\n \n fn fmt_trait_ref(\n-    tr: &TraitRef,\n     f: &mut HirFormatter<'_>,\n+    tr: &TraitRef,\n     use_as: bool,\n ) -> Result<(), HirDisplayError> {\n     if f.should_truncate() {\n@@ -1065,7 +1095,10 @@ fn fmt_trait_ref(\n     } else {\n         write!(f, \": \")?;\n     }\n-    write!(f, \"{}\", f.db.trait_data(tr.hir_trait_id()).name)?;\n+    let trait_ = tr.hir_trait_id();\n+    f.start_location_link(trait_.into());\n+    write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n+    f.end_location_link();\n     if tr.substitution.len(Interner) > 1 {\n         write!(f, \"<\")?;\n         f.write_joined(&tr.substitution.as_slice(Interner)[1..], \", \")?;\n@@ -1076,7 +1109,7 @@ fn fmt_trait_ref(\n \n impl HirDisplay for TraitRef {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n-        fmt_trait_ref(self, f, false)\n+        fmt_trait_ref(f, self, false)\n     }\n }\n \n@@ -1090,12 +1123,13 @@ impl HirDisplay for WhereClause {\n             WhereClause::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n             WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n                 write!(f, \"<\")?;\n-                fmt_trait_ref(&projection_ty.trait_ref(f.db), f, true)?;\n-                write!(\n-                    f,\n-                    \">::{} = \",\n-                    f.db.type_alias_data(from_assoc_type_id(projection_ty.associated_ty_id)).name,\n-                )?;\n+                fmt_trait_ref(f, &projection_ty.trait_ref(f.db), true)?;\n+                write!(f, \">::\",)?;\n+                let type_alias = from_assoc_type_id(projection_ty.associated_ty_id);\n+                f.start_location_link(type_alias.into());\n+                write!(f, \"{}\", f.db.type_alias_data(type_alias).name,)?;\n+                f.end_location_link();\n+                write!(f, \" = \")?;\n                 ty.hir_fmt(f)?;\n             }\n             WhereClause::AliasEq(_) => write!(f, \"{{error}}\")?,"}, {"sha": "24973afb9cea6a17138652385e51068739541d76", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=6673e515b770350a97b42e2518f64908f2db16b3", "patch": "@@ -30,8 +30,8 @@ use hir_def::{\n         ConstScalarOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef,\n     },\n     AdtId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n-    HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, StaticId, StructId, TraitId,\n-    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n+    HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, StaticId, StructId,\n+    TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::Name, ExpandResult};\n use intern::Interned;\n@@ -1704,6 +1704,15 @@ pub enum CallableDefId {\n     EnumVariantId(EnumVariantId),\n }\n impl_from!(FunctionId, StructId, EnumVariantId for CallableDefId);\n+impl From<CallableDefId> for ModuleDefId {\n+    fn from(def: CallableDefId) -> ModuleDefId {\n+        match def {\n+            CallableDefId::FunctionId(f) => ModuleDefId::FunctionId(f),\n+            CallableDefId::StructId(s) => ModuleDefId::AdtId(AdtId::StructId(s)),\n+            CallableDefId::EnumVariantId(e) => ModuleDefId::EnumVariantId(e),\n+        }\n+    }\n+}\n \n impl CallableDefId {\n     pub fn krate(self, db: &dyn HirDatabase) -> CrateId {"}, {"sha": "55d3b6097685bf0e4903c4b5ff90fecec8d0ddfb", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=6673e515b770350a97b42e2518f64908f2db16b3", "patch": "@@ -270,7 +270,7 @@ impl HirDisplay for TypeParam {\n         let has_only_not_sized_bound = predicates.is_empty();\n         if !has_only_sized_bound || has_only_not_sized_bound {\n             let default_sized = SizedByDefault::Sized { anchor: krate };\n-            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, default_sized, f)?;\n+            write_bounds_like_dyn_trait_with_prefix(f, \":\", &predicates, default_sized)?;\n         }\n         Ok(())\n     }"}, {"sha": "3865175b6dc249d70a3b7603dc7d4743c3ed669f", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6673e515b770350a97b42e2518f64908f2db16b3", "patch": "@@ -127,7 +127,7 @@ pub use {\n         ExpandResult, HirFileId, InFile, MacroFile, Origin,\n     },\n     hir_ty::{\n-        display::{HirDisplay, HirWrite},\n+        display::{HirDisplay, HirDisplayError, HirWrite},\n         PointerCast, Safety,\n     },\n };"}, {"sha": "7d33d1eac062c94ea137a36201d839aa9dd84ecf", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=6673e515b770350a97b42e2518f64908f2db16b3", "patch": "@@ -4,7 +4,9 @@ use std::{\n };\n \n use either::Either;\n-use hir::{known, HasVisibility, HirDisplay, HirWrite, ModuleDef, ModuleDefId, Semantics};\n+use hir::{\n+    known, HasVisibility, HirDisplay, HirDisplayError, HirWrite, ModuleDef, ModuleDefId, Semantics,\n+};\n use ide_db::{base_db::FileRange, famous_defs::FamousDefs, RootDatabase};\n use itertools::Itertools;\n use smallvec::{smallvec, SmallVec};\n@@ -297,24 +299,35 @@ fn label_of_ty(\n         mut max_length: Option<usize>,\n         ty: hir::Type,\n         label_builder: &mut InlayHintLabelBuilder<'_>,\n-    ) {\n+    ) -> Result<(), HirDisplayError> {\n         let iter_item_type = hint_iterator(sema, famous_defs, &ty);\n         match iter_item_type {\n-            Some(ty) => {\n-                const LABEL_START: &str = \"impl Iterator<Item = \";\n+            Some((iter_trait, ty)) => {\n+                const LABEL_START: &str = \"impl \";\n+                const LABEL_ITERATOR: &str = \"Iterator\";\n+                const LABEL_MIDDLE: &str = \"<Item = \";\n                 const LABEL_END: &str = \">\";\n \n-                max_length =\n-                    max_length.map(|len| len.saturating_sub(LABEL_START.len() + LABEL_END.len()));\n-\n-                label_builder.write_str(LABEL_START).unwrap();\n-                rec(sema, famous_defs, max_length, ty, label_builder);\n-                label_builder.write_str(LABEL_END).unwrap();\n-            }\n-            None => {\n-                let _ = ty.display_truncated(sema.db, max_length).write_to(label_builder);\n+                max_length = max_length.map(|len| {\n+                    len.saturating_sub(\n+                        LABEL_START.len()\n+                            + LABEL_ITERATOR.len()\n+                            + LABEL_MIDDLE.len()\n+                            + LABEL_END.len(),\n+                    )\n+                });\n+\n+                label_builder.write_str(LABEL_START)?;\n+                label_builder.start_location_link(ModuleDef::from(iter_trait).into());\n+                label_builder.write_str(LABEL_ITERATOR)?;\n+                label_builder.end_location_link();\n+                label_builder.write_str(LABEL_MIDDLE)?;\n+                rec(sema, famous_defs, max_length, ty, label_builder)?;\n+                label_builder.write_str(LABEL_END)?;\n+                Ok(())\n             }\n-        };\n+            None => ty.display_truncated(sema.db, max_length).write_to(label_builder),\n+        }\n     }\n \n     let mut label_builder = InlayHintLabelBuilder {\n@@ -324,7 +337,7 @@ fn label_of_ty(\n         location_link_enabled: config.location_links,\n         result: InlayHintLabel::default(),\n     };\n-    rec(sema, famous_defs, config.max_length, ty, &mut label_builder);\n+    let _ = rec(sema, famous_defs, config.max_length, ty, &mut label_builder);\n     let r = label_builder.finish();\n     Some(r)\n }\n@@ -430,12 +443,12 @@ fn hints(\n     };\n }\n \n-/// Checks if the type is an Iterator from std::iter and returns its item type.\n+/// Checks if the type is an Iterator from std::iter and returns the iterator trait and the item type of the concrete iterator.\n fn hint_iterator(\n     sema: &Semantics<'_, RootDatabase>,\n     famous_defs: &FamousDefs<'_, '_>,\n     ty: &hir::Type,\n-) -> Option<hir::Type> {\n+) -> Option<(hir::Trait, hir::Type)> {\n     let db = sema.db;\n     let strukt = ty.strip_references().as_adt()?;\n     let krate = strukt.module(db).krate();\n@@ -458,7 +471,7 @@ fn hint_iterator(\n             _ => None,\n         })?;\n         if let Some(ty) = ty.normalize_trait_assoc_type(db, &[], assoc_type_item) {\n-            return Some(ty);\n+            return Some((iter_trait, ty));\n         }\n     }\n "}, {"sha": "9c9e3c4bdae127dc40e94403e96edf2a042b6e18", "filename": "crates/ide/src/inlay_hints/bind_pat.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs?ref=6673e515b770350a97b42e2518f64908f2db16b3", "patch": "@@ -318,7 +318,33 @@ fn main(a: SliceIter<'_, Container>) {\n                         range: 484..554,\n                         kind: Chaining,\n                         label: [\n-                            \"impl Iterator<Item = impl Iterator<Item = &&str>>\",\n+                            \"impl \",\n+                            InlayHintLabelPart {\n+                                text: \"Iterator\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2248..2256,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \"<Item = impl \",\n+                            InlayHintLabelPart {\n+                                text: \"Iterator\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2248..2256,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \"<Item = &&str>>\",\n                         ],\n                     },\n                     InlayHint {"}, {"sha": "66fb53ecebcadc96530110839865c683c3c3a876", "filename": "crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6673e515b770350a97b42e2518f64908f2db16b3/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=6673e515b770350a97b42e2518f64908f2db16b3", "patch": "@@ -408,21 +408,60 @@ fn main() {\n                         range: 174..241,\n                         kind: Chaining,\n                         label: [\n-                            \"impl Iterator<Item = ()>\",\n+                            \"impl \",\n+                            InlayHintLabelPart {\n+                                text: \"Iterator\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2248..2256,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \"<Item = ()>\",\n                         ],\n                     },\n                     InlayHint {\n                         range: 174..224,\n                         kind: Chaining,\n                         label: [\n-                            \"impl Iterator<Item = ()>\",\n+                            \"impl \",\n+                            InlayHintLabelPart {\n+                                text: \"Iterator\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2248..2256,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \"<Item = ()>\",\n                         ],\n                     },\n                     InlayHint {\n                         range: 174..206,\n                         kind: Chaining,\n                         label: [\n-                            \"impl Iterator<Item = ()>\",\n+                            \"impl \",\n+                            InlayHintLabelPart {\n+                                text: \"Iterator\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2248..2256,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \"<Item = ()>\",\n                         ],\n                     },\n                     InlayHint {"}]}