{"sha": "1deb858b2217cd9107bef4d64d35f1489f77f2ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZWI4NThiMjIxN2NkOTEwN2JlZjRkNjRkMzVmMTQ4OWY3N2YyZmY=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-24T17:39:29Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-26T05:23:21Z"}, "message": "libsyntax: is_keyword should take a &~str", "tree": {"sha": "549e50fc5e14e392c45f9e280dff15314d46f1cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/549e50fc5e14e392c45f9e280dff15314d46f1cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1deb858b2217cd9107bef4d64d35f1489f77f2ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1deb858b2217cd9107bef4d64d35f1489f77f2ff", "html_url": "https://github.com/rust-lang/rust/commit/1deb858b2217cd9107bef4d64d35f1489f77f2ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1deb858b2217cd9107bef4d64d35f1489f77f2ff/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b94ef0302c898b0643810c9a31978684b607a37", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b94ef0302c898b0643810c9a31978684b607a37", "html_url": "https://github.com/rust-lang/rust/commit/8b94ef0302c898b0643810c9a31978684b607a37"}], "stats": {"total": 260, "additions": 132, "deletions": 128}, "files": [{"sha": "fb7b41be2d6705f69fe304ba81362c10ad584ff3", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1deb858b2217cd9107bef4d64d35f1489f77f2ff/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1deb858b2217cd9107bef4d64d35f1489f77f2ff/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=1deb858b2217cd9107bef4d64d35f1489f77f2ff", "patch": "@@ -31,9 +31,9 @@ pub fn expand_trace_macros(cx: ext_ctxt, sp: span,\n     let rdr = tt_rdr as reader;\n     let rust_parser = Parser(sess, cfg, rdr.dup());\n \n-    if rust_parser.is_keyword(~\"true\") {\n+    if rust_parser.is_keyword(&~\"true\") {\n         cx.set_trace_macros(true);\n-    } else if rust_parser.is_keyword(~\"false\") {\n+    } else if rust_parser.is_keyword(&~\"false\") {\n         cx.set_trace_macros(false);\n     } else {\n         cx.span_fatal(sp, ~\"trace_macros! only accepts `true` or `false`\")"}, {"sha": "0317ae14e8cc4e0e16d4565bf9f603284e181b2e", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1deb858b2217cd9107bef4d64d35f1489f77f2ff/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1deb858b2217cd9107bef4d64d35f1489f77f2ff/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=1deb858b2217cd9107bef4d64d35f1489f77f2ff", "patch": "@@ -110,25 +110,25 @@ pub impl Parser {\n     // Storing keywords as interned idents instead of strings would be nifty.\n \n     // A sanity check that the word we are asking for is a known keyword\n-    fn require_keyword(word: ~str) {\n-        if !self.keywords.contains_key(&word) {\n-            self.bug(fmt!(\"unknown keyword: %s\", word));\n+    fn require_keyword(word: &~str) {\n+        if !self.keywords.contains_key(word) {\n+            self.bug(fmt!(\"unknown keyword: %s\", *word));\n         }\n     }\n \n-    fn token_is_word(word: ~str, ++tok: token::Token) -> bool {\n+    fn token_is_word(word: &~str, tok: token::Token) -> bool {\n         match tok {\n-          token::IDENT(sid, false) => { *self.id_to_str(sid) == word }\n+          token::IDENT(sid, false) => { *self.id_to_str(sid) == *word }\n           _ => { false }\n         }\n     }\n \n-    fn token_is_keyword(word: ~str, ++tok: token::Token) -> bool {\n+    fn token_is_keyword(word: &~str, ++tok: token::Token) -> bool {\n         self.require_keyword(word);\n         self.token_is_word(word, tok)\n     }\n \n-    fn is_keyword(word: ~str) -> bool {\n+    fn is_keyword(word: &~str) -> bool {\n         self.token_is_keyword(word, *self.token)\n     }\n \n@@ -141,62 +141,62 @@ pub impl Parser {\n         }\n     }\n \n-    fn eat_keyword(word: ~str) -> bool {\n+    fn eat_keyword(word: &~str) -> bool {\n         self.require_keyword(word);\n         let is_kw = match *self.token {\n-          token::IDENT(sid, false) => (word == *self.id_to_str(sid)),\n+          token::IDENT(sid, false) => *word == *self.id_to_str(sid),\n           _ => false\n         };\n         if is_kw { self.bump() }\n         is_kw\n     }\n \n-    fn expect_keyword(word: ~str) {\n+    fn expect_keyword(word: &~str) {\n         self.require_keyword(word);\n         if !self.eat_keyword(word) {\n-            self.fatal(~\"expected `\" + word + ~\"`, found `\" +\n+            self.fatal(~\"expected `\" + *word + ~\"`, found `\" +\n                        token_to_str(self.reader, *self.token) +\n                        ~\"`\");\n         }\n     }\n \n-    fn is_strict_keyword(word: ~str) -> bool {\n-        self.strict_keywords.contains_key(&word)\n+    fn is_strict_keyword(word: &~str) -> bool {\n+        self.strict_keywords.contains_key(word)\n     }\n \n     fn check_strict_keywords() {\n         match *self.token {\n           token::IDENT(_, false) => {\n             let w = token_to_str(self.reader, *self.token);\n-            self.check_strict_keywords_(w);\n+            self.check_strict_keywords_(&w);\n           }\n           _ => ()\n         }\n     }\n \n-    fn check_strict_keywords_(w: ~str) {\n+    fn check_strict_keywords_(w: &~str) {\n         if self.is_strict_keyword(w) {\n-            self.fatal(~\"found `\" + w + ~\"` in ident position\");\n+            self.fatal(~\"found `\" + *w + ~\"` in ident position\");\n         }\n     }\n \n-    fn is_reserved_keyword(word: ~str) -> bool {\n-        self.reserved_keywords.contains_key(&word)\n+    fn is_reserved_keyword(word: &~str) -> bool {\n+        self.reserved_keywords.contains_key(word)\n     }\n \n     fn check_reserved_keywords() {\n         match *self.token {\n           token::IDENT(_, false) => {\n             let w = token_to_str(self.reader, *self.token);\n-            self.check_reserved_keywords_(w);\n+            self.check_reserved_keywords_(&w);\n           }\n           _ => ()\n         }\n     }\n \n-    fn check_reserved_keywords_(w: ~str) {\n+    fn check_reserved_keywords_(w: &~str) {\n         if self.is_reserved_keyword(w) {\n-            self.fatal(~\"`\" + w + ~\"` is a reserved keyword\");\n+            self.fatal(~\"`\" + *w + ~\"` is a reserved keyword\");\n         }\n     }\n "}, {"sha": "02c2fb404c2078aec6eaac768c93455a784cdf51", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1deb858b2217cd9107bef4d64d35f1489f77f2ff/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1deb858b2217cd9107bef4d64d35f1489f77f2ff/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=1deb858b2217cd9107bef4d64d35f1489f77f2ff", "patch": "@@ -197,9 +197,9 @@ pub impl Parser {\n     }\n \n     fn try_parse_obsolete_priv_section() -> bool {\n-        if self.is_keyword(~\"priv\") && self.look_ahead(1) == token::LBRACE {\n+        if self.is_keyword(&~\"priv\") && self.look_ahead(1) == token::LBRACE {\n             self.obsolete(*self.span, ObsoletePrivSection);\n-            self.eat_keyword(~\"priv\");\n+            self.eat_keyword(&~\"priv\");\n             self.bump();\n             while *self.token != token::RBRACE {\n                 self.parse_single_class_item(ast::private);"}, {"sha": "ffc8a28a545833587ff489d5d4ee475d7465ed41", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 107, "deletions": 103, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/1deb858b2217cd9107bef4d64d35f1489f77f2ff/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1deb858b2217cd9107bef4d64d35f1489f77f2ff/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1deb858b2217cd9107bef4d64d35f1489f77f2ff", "patch": "@@ -310,10 +310,10 @@ pub impl Parser {\n     pure fn id_to_str(id: ident) -> @~str { self.sess.interner.get(id) }\n \n     fn token_is_closure_keyword(+tok: token::Token) -> bool {\n-        self.token_is_keyword(~\"pure\", tok) ||\n-            self.token_is_keyword(~\"unsafe\", tok) ||\n-            self.token_is_keyword(~\"once\", tok) ||\n-            self.token_is_keyword(~\"fn\", tok)\n+        self.token_is_keyword(&~\"pure\", tok) ||\n+            self.token_is_keyword(&~\"unsafe\", tok) ||\n+            self.token_is_keyword(&~\"once\", tok) ||\n+            self.token_is_keyword(&~\"fn\", tok)\n     }\n \n     fn parse_ty_bare_fn() -> ty_\n@@ -333,7 +333,7 @@ pub impl Parser {\n         */\n \n         let purity = self.parse_purity();\n-        self.expect_keyword(~\"fn\");\n+        self.expect_keyword(&~\"fn\");\n         return ty_bare_fn(@TyBareFn {\n             abi: RustAbi,\n             purity: purity,\n@@ -364,7 +364,7 @@ pub impl Parser {\n \n         let purity = self.parse_purity();\n         let onceness = parse_onceness(&self);\n-        self.expect_keyword(~\"fn\");\n+        self.expect_keyword(&~\"fn\");\n         let post_sigil = self.parse_fn_ty_sigil();\n \n         let sigil = match (pre_sigil, post_sigil) {\n@@ -392,14 +392,14 @@ pub impl Parser {\n         });\n \n         fn parse_onceness(self: &Parser) -> Onceness {\n-            if self.eat_keyword(~\"once\") {Once} else {Many}\n+            if self.eat_keyword(&~\"once\") { Once } else { Many }\n         }\n     }\n \n     fn parse_purity() -> purity {\n-        if self.eat_keyword(~\"pure\") {\n+        if self.eat_keyword(&~\"pure\") {\n             return pure_fn;\n-        } else if self.eat_keyword(~\"unsafe\") {\n+        } else if self.eat_keyword(&~\"unsafe\") {\n             return unsafe_fn;\n         } else {\n             return impure_fn;\n@@ -640,15 +640,17 @@ pub impl Parser {\n         } else if *self.token == token::BINOP(token::AND) {\n             self.bump();\n             self.parse_borrowed_pointee()\n-        } else if self.eat_keyword(~\"extern\") {\n+        } else if self.eat_keyword(&~\"extern\") {\n             self.parse_ty_bare_fn()\n         } else if self.token_is_closure_keyword(*self.token) {\n             self.parse_ty_closure(None, None)\n         } else if *self.token == token::MOD_SEP\n             || is_ident_or_path(*self.token) {\n             let path = self.parse_path_with_tps(colons_before_params);\n             ty_path(path, self.get_id())\n-        } else { self.fatal(~\"expected type\"); };\n+        } else {\n+            self.fatal(~\"expected type\");\n+        };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n         @Ty {id: self.get_id(), node: t, span: sp}\n@@ -667,8 +669,10 @@ pub impl Parser {\n \n             token::IDENT(rname, _) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n-                        self.token_is_closure_keyword(self.look_ahead(2u)) {\n-                    self.bump(); self.bump();\n+                    self.token_is_closure_keyword(self.look_ahead(2u))\n+                {\n+                    self.bump();\n+                    self.bump();\n                     return self.parse_ty_closure(Some(sigil), Some(rname));\n                 } else if self.token_is_closure_keyword(*self.token) {\n                     return self.parse_ty_closure(Some(sigil), None);\n@@ -756,7 +760,7 @@ pub impl Parser {\n     fn parse_capture_item_or(parse_arg_fn: fn(Parser) -> arg_or_capture_item)\n         -> arg_or_capture_item\n     {\n-        if self.eat_keyword(~\"copy\") {\n+        if self.eat_keyword(&~\"copy\") {\n             // XXX outdated syntax now that moves-based-on-type has gone in\n             self.parse_ident();\n             either::Right(())\n@@ -772,7 +776,7 @@ pub impl Parser {\n         let mut is_mutbl = false;\n         let pat = if require_name || self.is_named_argument() {\n             m = self.parse_arg_mode();\n-            is_mutbl = self.eat_keyword(~\"mut\");\n+            is_mutbl = self.eat_keyword(&~\"mut\");\n             let pat = self.parse_pat(false);\n             self.expect(token::COLON);\n             pat\n@@ -800,7 +804,7 @@ pub impl Parser {\n     fn parse_fn_block_arg() -> arg_or_capture_item {\n         do self.parse_capture_item_or |p| {\n             let m = p.parse_arg_mode();\n-            let is_mutbl = self.eat_keyword(~\"mut\");\n+            let is_mutbl = self.eat_keyword(&~\"mut\");\n             let pat = p.parse_pat(false);\n             let t = if p.eat(token::COLON) {\n                 p.parse_ty(false)\n@@ -856,9 +860,9 @@ pub impl Parser {\n \n     fn parse_lit() -> lit {\n         let lo = self.span.lo;\n-        let lit = if self.eat_keyword(~\"true\") {\n+        let lit = if self.eat_keyword(&~\"true\") {\n             lit_bool(true)\n-        } else if self.eat_keyword(~\"false\") {\n+        } else if self.eat_keyword(&~\"false\") {\n             lit_bool(false)\n         } else {\n             // XXX: This is a really bad copy!\n@@ -1024,9 +1028,9 @@ pub impl Parser {\n     }\n \n     fn parse_mutability() -> mutability {\n-        if self.eat_keyword(~\"mut\") {\n+        if self.eat_keyword(&~\"mut\") {\n             m_mutbl\n-        } else if self.eat_keyword(~\"const\") {\n+        } else if self.eat_keyword(&~\"const\") {\n             m_const\n         } else {\n             m_imm\n@@ -1124,21 +1128,21 @@ pub impl Parser {\n             }\n         } else if token::is_bar(*self.token) {\n             return self.parse_lambda_expr();\n-        } else if self.eat_keyword(~\"if\") {\n+        } else if self.eat_keyword(&~\"if\") {\n             return self.parse_if_expr();\n-        } else if self.eat_keyword(~\"for\") {\n+        } else if self.eat_keyword(&~\"for\") {\n             return self.parse_sugary_call_expr(~\"for\", ForSugar,\n                                                expr_loop_body);\n-        } else if self.eat_keyword(~\"do\") {\n+        } else if self.eat_keyword(&~\"do\") {\n             return self.parse_sugary_call_expr(~\"do\", DoSugar,\n                                                expr_do_body);\n-        } else if self.eat_keyword(~\"while\") {\n+        } else if self.eat_keyword(&~\"while\") {\n             return self.parse_while_expr();\n-        } else if self.eat_keyword(~\"loop\") {\n+        } else if self.eat_keyword(&~\"loop\") {\n             return self.parse_loop_expr();\n-        } else if self.eat_keyword(~\"match\") {\n+        } else if self.eat_keyword(&~\"match\") {\n             return self.parse_match_expr();\n-        } else if self.eat_keyword(~\"fn\") {\n+        } else if self.eat_keyword(&~\"fn\") {\n             let opt_sigil = self.parse_fn_ty_sigil();\n             let sigil = match opt_sigil {\n                 None => {\n@@ -1147,7 +1151,7 @@ pub impl Parser {\n                 Some(p) => { p }\n             };\n             return self.parse_fn_expr(sigil);\n-        } else if self.eat_keyword(~\"unsafe\") {\n+        } else if self.eat_keyword(&~\"unsafe\") {\n             return self.parse_block_expr(lo, unsafe_blk);\n         } else if *self.token == token::LBRACKET {\n             self.bump();\n@@ -1182,38 +1186,38 @@ pub impl Parser {\n                 }\n             }\n             hi = self.span.hi;\n-        } else if self.eat_keyword(~\"log\") {\n+        } else if self.eat_keyword(&~\"log\") {\n             self.expect(token::LPAREN);\n             let lvl = self.parse_expr();\n             self.expect(token::COMMA);\n             let e = self.parse_expr();\n             ex = expr_log(ast::log_other, lvl, e);\n             hi = self.span.hi;\n             self.expect(token::RPAREN);\n-        } else if self.eat_keyword(~\"assert\") {\n+        } else if self.eat_keyword(&~\"assert\") {\n             let e = self.parse_expr();\n             ex = expr_assert(e);\n             hi = e.span.hi;\n-        } else if self.eat_keyword(~\"return\") {\n+        } else if self.eat_keyword(&~\"return\") {\n             if can_begin_expr(*self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n                 ex = expr_ret(Some(e));\n             } else { ex = expr_ret(None); }\n-        } else if self.eat_keyword(~\"break\") {\n+        } else if self.eat_keyword(&~\"break\") {\n             if is_ident(*self.token) {\n                 ex = expr_break(Some(self.parse_ident()));\n             } else {\n                 ex = expr_break(None);\n             }\n             hi = self.span.hi;\n-        } else if self.eat_keyword(~\"copy\") {\n+        } else if self.eat_keyword(&~\"copy\") {\n             let e = self.parse_expr();\n             ex = expr_copy(e);\n             hi = e.span.hi;\n         } else if *self.token == token::MOD_SEP ||\n-                is_ident(*self.token) && !self.is_keyword(~\"true\") &&\n-                !self.is_keyword(~\"false\") {\n+                is_ident(*self.token) && !self.is_keyword(&~\"true\") &&\n+                !self.is_keyword(&~\"false\") {\n             let pth = self.parse_path_with_tps(true);\n \n             /* `!`, as an operator, is prefix, so we know this isn't that */\n@@ -1642,7 +1646,7 @@ pub impl Parser {\n                     }\n                 }\n                 None => {\n-                    if as_prec > min_prec && self.eat_keyword(~\"as\") {\n+                    if as_prec > min_prec && self.eat_keyword(&~\"as\") {\n                         let rhs = self.parse_ty(true);\n                         let _as = self.mk_expr(lhs.span.lo,\n                                                rhs.span.hi,\n@@ -1714,7 +1718,7 @@ pub impl Parser {\n         let thn = self.parse_block();\n         let mut els: Option<@expr> = None;\n         let mut hi = thn.span.hi;\n-        if self.eat_keyword(~\"else\") {\n+        if self.eat_keyword(&~\"else\") {\n             let elexpr = self.parse_else_expr();\n             els = Some(elexpr);\n             hi = elexpr.span.hi;\n@@ -1788,7 +1792,7 @@ pub impl Parser {\n     }\n \n     fn parse_else_expr() -> @expr {\n-        if self.eat_keyword(~\"if\") {\n+        if self.eat_keyword(&~\"if\") {\n             return self.parse_if_expr();\n         } else {\n             let blk = self.parse_block();\n@@ -1904,7 +1908,7 @@ pub impl Parser {\n     fn looking_at_record_literal() -> bool {\n         let lookahead = self.look_ahead(1);\n         *self.token == token::LBRACE &&\n-            (self.token_is_keyword(~\"mut\", lookahead) ||\n+            (self.token_is_keyword(&~\"mut\", lookahead) ||\n              (is_plain_ident(lookahead) &&\n               self.look_ahead(2) == token::COLON))\n     }\n@@ -1945,7 +1949,7 @@ pub impl Parser {\n         while *self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = None;\n-            if self.eat_keyword(~\"if\") { guard = Some(self.parse_expr()); }\n+            if self.eat_keyword(&~\"if\") { guard = Some(self.parse_expr()); }\n             self.expect(token::FAT_ARROW);\n             let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n \n@@ -2210,8 +2214,8 @@ pub impl Parser {\n           }\n           copy tok => {\n             if !is_ident_or_path(tok)\n-                || self.is_keyword(~\"true\")\n-                || self.is_keyword(~\"false\")\n+                || self.is_keyword(&~\"true\")\n+                || self.is_keyword(&~\"false\")\n             {\n                 let val = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 if self.eat(token::DOTDOT) {\n@@ -2220,10 +2224,10 @@ pub impl Parser {\n                 } else {\n                     pat = pat_lit(val);\n                 }\n-            } else if self.eat_keyword(~\"ref\") {\n+            } else if self.eat_keyword(&~\"ref\") {\n                 let mutbl = self.parse_mutability();\n                 pat = self.parse_pat_ident(refutable, bind_by_ref(mutbl));\n-            } else if self.eat_keyword(~\"copy\") {\n+            } else if self.eat_keyword(&~\"copy\") {\n                 pat = self.parse_pat_ident(refutable, bind_by_copy);\n             } else {\n                 // XXX---refutable match bindings should work same as let\n@@ -2355,7 +2359,7 @@ pub impl Parser {\n     }\n \n     fn parse_let() -> @decl {\n-        let is_mutbl = self.eat_keyword(~\"mut\");\n+        let is_mutbl = self.eat_keyword(&~\"mut\");\n         let lo = self.span.lo;\n         let mut locals = ~[self.parse_local(is_mutbl, true)];\n         while self.eat(token::COMMA) {\n@@ -2368,7 +2372,7 @@ pub impl Parser {\n     fn parse_instance_var(pr: visibility) -> @struct_field {\n         let mut is_mutbl = struct_immutable;\n         let lo = self.span.lo;\n-        if self.eat_keyword(~\"mut\") {\n+        if self.eat_keyword(&~\"mut\") {\n             is_mutbl = struct_mutable;\n         }\n         if !is_plain_ident(*self.token) {\n@@ -2395,9 +2399,9 @@ pub impl Parser {\n         }\n \n         let lo = self.span.lo;\n-        if self.is_keyword(~\"let\") {\n+        if self.is_keyword(&~\"let\") {\n             check_expected_item(self, first_item_attrs);\n-            self.expect_keyword(~\"let\");\n+            self.expect_keyword(&~\"let\");\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else if is_ident(*self.token)\n@@ -2491,7 +2495,7 @@ pub impl Parser {\n         }\n \n         let lo = self.span.lo;\n-        if self.eat_keyword(~\"unsafe\") {\n+        if self.eat_keyword(&~\"unsafe\") {\n             self.obsolete(*self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(token::LBRACE);\n@@ -2629,25 +2633,25 @@ pub impl Parser {\n     }\n \n     fn parse_optional_purity() -> ast::purity {\n-        if self.eat_keyword(~\"pure\") {\n+        if self.eat_keyword(&~\"pure\") {\n             ast::pure_fn\n-        } else if self.eat_keyword(~\"unsafe\") {\n+        } else if self.eat_keyword(&~\"unsafe\") {\n             ast::unsafe_fn\n         } else {\n             ast::impure_fn\n         }\n     }\n \n     fn parse_optional_onceness() -> ast::Onceness {\n-        if self.eat_keyword(~\"once\") { ast::Once } else { ast::Many }\n+        if self.eat_keyword(&~\"once\") { ast::Once } else { ast::Many }\n     }\n \n     fn parse_optional_ty_param_bounds() -> @~[ty_param_bound] {\n         let mut bounds = ~[];\n         if self.eat(token::COLON) {\n             loop {\n                 if self.eat(token::BINOP(token::AND)) {\n-                    if self.eat_keyword(~\"static\") {\n+                    if self.eat_keyword(&~\"static\") {\n                         bounds.push(RegionTyParamBound);\n                     } else {\n                         self.span_err(*self.span,\n@@ -2760,10 +2764,10 @@ pub impl Parser {\n         fn maybe_parse_self_ty(cnstr: fn(+v: mutability) -> ast::self_ty_,\n                                p: Parser) -> ast::self_ty_ {\n             // We need to make sure it isn't a mode or a type\n-            if p.token_is_keyword(~\"self\", p.look_ahead(1)) ||\n-                ((p.token_is_keyword(~\"const\", p.look_ahead(1)) ||\n-                  p.token_is_keyword(~\"mut\", p.look_ahead(1))) &&\n-                 p.token_is_keyword(~\"self\", p.look_ahead(2))) {\n+            if p.token_is_keyword(&~\"self\", p.look_ahead(1)) ||\n+                ((p.token_is_keyword(&~\"const\", p.look_ahead(1)) ||\n+                  p.token_is_keyword(&~\"mut\", p.look_ahead(1))) &&\n+                 p.token_is_keyword(&~\"self\", p.look_ahead(2))) {\n \n                 p.bump();\n                 let mutability = p.parse_mutability();\n@@ -2975,7 +2979,7 @@ pub impl Parser {\n         let mut ty = self.parse_ty(false);\n \n         // Parse traits, if necessary.\n-        let opt_trait = if self.eat_keyword(~\"for\") {\n+        let opt_trait = if self.eat_keyword(&~\"for\") {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n                 ty_path(path, node_id) => {\n@@ -3184,19 +3188,19 @@ pub impl Parser {\n \n         let attrs = self.parse_outer_attributes();\n \n-        if self.eat_keyword(~\"priv\") {\n+        if self.eat_keyword(&~\"priv\") {\n             return members(~[self.parse_single_class_item(private)])\n         }\n \n-        if self.eat_keyword(~\"pub\") {\n+        if self.eat_keyword(&~\"pub\") {\n            return members(~[self.parse_single_class_item(public)]);\n         }\n \n         if self.try_parse_obsolete_struct_ctor() {\n             return members(~[]);\n         }\n \n-        if self.eat_keyword(~\"drop\") {\n+        if self.eat_keyword(&~\"drop\") {\n            return self.parse_dtor(attrs);\n         }\n         else {\n@@ -3205,12 +3209,12 @@ pub impl Parser {\n     }\n \n     fn parse_visibility() -> visibility {\n-        if self.eat_keyword(~\"pub\") { public }\n-        else if self.eat_keyword(~\"priv\") { private }\n+        if self.eat_keyword(&~\"pub\") { public }\n+        else if self.eat_keyword(&~\"priv\") { private }\n         else { inherited }\n     }\n     fn parse_staticness() -> bool {\n-        self.eat_keyword(~\"static\")\n+        self.eat_keyword(&~\"static\")\n     }\n \n     // given a termination token and a vector of already-parsed\n@@ -3412,7 +3416,7 @@ pub impl Parser {\n     fn parse_item_foreign_const(vis: ast::visibility,\n                                 +attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n-        self.expect_keyword(~\"const\");\n+        self.expect_keyword(&~\"const\");\n         let ident = self.parse_ident();\n         self.expect(token::COLON);\n         let ty = self.parse_ty(false);\n@@ -3427,20 +3431,20 @@ pub impl Parser {\n     }\n \n     fn parse_fn_purity() -> purity {\n-        if self.eat_keyword(~\"fn\") { impure_fn }\n-        else if self.eat_keyword(~\"pure\") {\n-            self.expect_keyword(~\"fn\");\n+        if self.eat_keyword(&~\"fn\") { impure_fn }\n+        else if self.eat_keyword(&~\"pure\") {\n+            self.expect_keyword(&~\"fn\");\n             pure_fn\n-        } else if self.eat_keyword(~\"unsafe\") {\n-            self.expect_keyword(~\"fn\");\n+        } else if self.eat_keyword(&~\"unsafe\") {\n+            self.expect_keyword(&~\"fn\");\n             unsafe_fn\n         }\n         else { self.unexpected(); }\n     }\n \n     fn parse_foreign_item(+attrs: ~[attribute]) -> @foreign_item {\n         let vis = self.parse_visibility();\n-        if self.is_keyword(~\"const\") {\n+        if self.is_keyword(&~\"const\") {\n             self.parse_item_foreign_const(vis, attrs)\n         } else {\n             self.parse_item_foreign_fn(attrs)\n@@ -3496,9 +3500,9 @@ pub impl Parser {\n         }\n \n         let mut must_be_named_mod = false;\n-        if self.is_keyword(~\"mod\") {\n+        if self.is_keyword(&~\"mod\") {\n             must_be_named_mod = true;\n-            self.expect_keyword(~\"mod\");\n+            self.expect_keyword(&~\"mod\");\n         } else if *self.token != token::LBRACE {\n             self.span_fatal(*self.span,\n                             fmt!(\"expected `{` or `mod` but found %s\",\n@@ -3633,7 +3637,7 @@ pub impl Parser {\n             let vlo = self.span.lo;\n \n             // Is this a common field declaration?\n-            if self.eat_keyword(~\"struct\") {\n+            if self.eat_keyword(&~\"struct\") {\n                 if common_fields.is_some() {\n                     self.fatal(~\"duplicate declaration of shared fields\");\n                 }\n@@ -3647,7 +3651,7 @@ pub impl Parser {\n             // Is this a nested enum declaration?\n             let ident, needs_comma, kind;\n             let mut args = ~[], disr_expr = None;\n-            if self.eat_keyword(~\"enum\") {\n+            if self.eat_keyword(&~\"enum\") {\n                 ident = self.parse_ident();\n                 self.expect(token::LBRACE);\n                 let nested_enum_def = self.parse_enum_def(ty_params);\n@@ -3778,57 +3782,57 @@ pub impl Parser {\n         let lo = self.span.lo;\n \n         let visibility;\n-        if self.eat_keyword(~\"pub\") {\n+        if self.eat_keyword(&~\"pub\") {\n             visibility = public;\n-        } else if self.eat_keyword(~\"priv\") {\n+        } else if self.eat_keyword(&~\"priv\") {\n             visibility = private;\n         } else {\n             visibility = inherited;\n         }\n \n-        if items_allowed && self.eat_keyword(~\"const\") {\n+        if items_allowed && self.eat_keyword(&~\"const\") {\n             // CONST ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if foreign_items_allowed && self.is_keyword(~\"const\") {\n+        } else if foreign_items_allowed && self.is_keyword(&~\"const\") {\n             // FOREIGN CONST ITEM\n             let item = self.parse_item_foreign_const(visibility, attrs);\n             return iovi_foreign_item(item);\n         } else if items_allowed &&\n             // FUNCTION ITEM (not sure about lookahead condition...)\n-            self.is_keyword(~\"fn\") &&\n+            self.is_keyword(&~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_fn(impure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(~\"pure\") {\n+        } else if items_allowed && self.eat_keyword(&~\"pure\") {\n             // PURE FUNCTION ITEM\n-            self.expect_keyword(~\"fn\");\n+            self.expect_keyword(&~\"fn\");\n             let (ident, item_, extra_attrs) = self.parse_item_fn(pure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if foreign_items_allowed &&\n-            (self.is_keyword(~\"fn\") || self.is_keyword(~\"pure\") ||\n-             self.is_keyword(~\"unsafe\")) {\n+            (self.is_keyword(&~\"fn\") || self.is_keyword(&~\"pure\") ||\n+             self.is_keyword(&~\"unsafe\")) {\n             // FOREIGN FUNCTION ITEM (no items allowed)\n                 let item = self.parse_item_foreign_fn(attrs);\n                 return iovi_foreign_item(item);\n-        } else if items_allowed && self.is_keyword(~\"unsafe\")\n+        } else if items_allowed && self.is_keyword(&~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n             // UNSAFE FUNCTION ITEM (where items are allowed)\n             self.bump();\n-            self.expect_keyword(~\"fn\");\n+            self.expect_keyword(&~\"fn\");\n             let (ident, item_, extra_attrs) = self.parse_item_fn(unsafe_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"extern\") {\n-            if items_allowed && self.eat_keyword(~\"fn\") {\n+        } else if self.eat_keyword(&~\"extern\") {\n+            if items_allowed && self.eat_keyword(&~\"fn\") {\n                 // EXTERN FUNCTION ITEM\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(extern_fn);\n@@ -3840,43 +3844,43 @@ pub impl Parser {\n             // EXTERN MODULE ITEM\n             return self.parse_item_foreign_mod(lo, visibility, attrs,\n                                                items_allowed);\n-        } else if items_allowed && self.eat_keyword(~\"mod\") {\n+        } else if items_allowed && self.eat_keyword(&~\"mod\") {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(~\"type\") {\n+        } else if items_allowed && self.eat_keyword(&~\"type\") {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(~\"enum\") {\n+        } else if items_allowed && self.eat_keyword(&~\"enum\") {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(~\"trait\") {\n+        } else if items_allowed && self.eat_keyword(&~\"trait\") {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(~\"impl\") {\n+        } else if items_allowed && self.eat_keyword(&~\"impl\") {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_impl();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(~\"struct\") {\n+        } else if items_allowed && self.eat_keyword(&~\"struct\") {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"use\") {\n+        } else if self.eat_keyword(&~\"use\") {\n             // USE ITEM\n             let view_item = self.parse_use();\n             self.expect(token::SEMI);\n@@ -3959,7 +3963,7 @@ pub impl Parser {\n         let lo = self.span.lo;\n \n         let namespace;\n-        if self.eat_keyword(~\"mod\") {\n+        if self.eat_keyword(&~\"mod\") {\n             namespace = module_ns;\n         } else {\n             namespace = type_value_ns;\n@@ -4053,25 +4057,25 @@ pub impl Parser {\n \n     fn is_view_item() -> bool {\n         let tok, next_tok;\n-        if !self.is_keyword(~\"pub\") && !self.is_keyword(~\"priv\") {\n+        if !self.is_keyword(&~\"pub\") && !self.is_keyword(&~\"priv\") {\n             tok = *self.token;\n             next_tok = self.look_ahead(1);\n         } else {\n             tok = self.look_ahead(1);\n             next_tok = self.look_ahead(2);\n         };\n-        self.token_is_keyword(~\"use\", tok)\n-            || (self.token_is_keyword(~\"extern\", tok) &&\n-                self.token_is_keyword(~\"mod\", next_tok))\n+        self.token_is_keyword(&~\"use\", tok)\n+            || (self.token_is_keyword(&~\"extern\", tok) &&\n+                self.token_is_keyword(&~\"mod\", next_tok))\n     }\n \n     // parse a view item.\n     fn parse_view_item(+attrs: ~[attribute], vis: visibility) -> @view_item {\n         let lo = self.span.lo;\n-        let node = if self.eat_keyword(~\"use\") {\n+        let node = if self.eat_keyword(&~\"use\") {\n             self.parse_use()\n-        } else if self.eat_keyword(~\"extern\") {\n-            self.expect_keyword(~\"mod\");\n+        } else if self.eat_keyword(&~\"extern\") {\n+            self.expect_keyword(&~\"mod\");\n             let ident = self.parse_ident();\n             let metadata = self.parse_optional_meta();\n             view_item_extern_mod(ident, metadata, self.get_id())"}]}