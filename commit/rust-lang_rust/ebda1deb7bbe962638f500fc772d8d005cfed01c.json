{"sha": "ebda1deb7bbe962638f500fc772d8d005cfed01c", "node_id": "C_kwDOAAsO6NoAKGViZGExZGViN2JiZTk2MjYzOGY1MDBmYzc3MmQ4ZDAwNWNmZWQwMWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T02:12:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T02:12:09Z"}, "message": "Auto merge of #2397 - RalfJung:cleanup, r=RalfJung\n\nonly do env var cleanup if all threads have stopped\n\nHopefully fixes https://github.com/rust-lang/miri/issues/2396", "tree": {"sha": "643cc2bacd4bb4a856ba6dd94a62d6ef5fb6af2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/643cc2bacd4bb4a856ba6dd94a62d6ef5fb6af2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebda1deb7bbe962638f500fc772d8d005cfed01c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebda1deb7bbe962638f500fc772d8d005cfed01c", "html_url": "https://github.com/rust-lang/rust/commit/ebda1deb7bbe962638f500fc772d8d005cfed01c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebda1deb7bbe962638f500fc772d8d005cfed01c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddde70c1217740101ab09b32ab3d545555d8d820", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddde70c1217740101ab09b32ab3d545555d8d820", "html_url": "https://github.com/rust-lang/rust/commit/ddde70c1217740101ab09b32ab3d545555d8d820"}, {"sha": "5fbf036670592d79eae81c4617141502b53a09a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fbf036670592d79eae81c4617141502b53a09a8", "html_url": "https://github.com/rust-lang/rust/commit/5fbf036670592d79eae81c4617141502b53a09a8"}], "stats": {"total": 91, "additions": 45, "deletions": 46}, "files": [{"sha": "8ee8df7445b3bac36f4b18bf7598af4601cda23d", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ebda1deb7bbe962638f500fc772d8d005cfed01c/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebda1deb7bbe962638f500fc772d8d005cfed01c/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=ebda1deb7bbe962638f500fc772d8d005cfed01c", "patch": "@@ -436,45 +436,6 @@ impl MemoryCellClocks {\n /// Evaluation context extensions.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n-    /// Temporarily allow data-races to occur. This should only be used in\n-    /// one of these cases:\n-    /// - One of the appropriate `validate_atomic` functions will be called to\n-    /// to treat a memory access as atomic.\n-    /// - The memory being accessed should be treated as internal state, that\n-    /// cannot be accessed by the interpreted program.\n-    /// - Execution of the interpreted program execution has halted.\n-    #[inline]\n-    fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n-        let this = self.eval_context_ref();\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_action_data_race_free.set(true);\n-        }\n-        let result = op(this);\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_action_data_race_free.set(false);\n-        }\n-        result\n-    }\n-\n-    /// Same as `allow_data_races_ref`, this temporarily disables any data-race detection and\n-    /// so should only be used for atomic operations or internal state that the program cannot\n-    /// access.\n-    #[inline]\n-    fn allow_data_races_mut<R>(\n-        &mut self,\n-        op: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> R,\n-    ) -> R {\n-        let this = self.eval_context_mut();\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_action_data_race_free.set(true);\n-        }\n-        let result = op(this);\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_action_data_race_free.set(false);\n-        }\n-        result\n-    }\n-\n     /// Atomic variant of read_scalar_at_offset.\n     fn read_scalar_at_offset_atomic(\n         &self,\n@@ -1044,6 +1005,45 @@ impl VClockAlloc {\n \n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n+    /// Temporarily allow data-races to occur. This should only be used in\n+    /// one of these cases:\n+    /// - One of the appropriate `validate_atomic` functions will be called to\n+    /// to treat a memory access as atomic.\n+    /// - The memory being accessed should be treated as internal state, that\n+    /// cannot be accessed by the interpreted program.\n+    /// - Execution of the interpreted program execution has halted.\n+    #[inline]\n+    fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n+        let this = self.eval_context_ref();\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(true);\n+        }\n+        let result = op(this);\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(false);\n+        }\n+        result\n+    }\n+\n+    /// Same as `allow_data_races_ref`, this temporarily disables any data-race detection and\n+    /// so should only be used for atomic operations or internal state that the program cannot\n+    /// access.\n+    #[inline]\n+    fn allow_data_races_mut<R>(\n+        &mut self,\n+        op: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> R,\n+    ) -> R {\n+        let this = self.eval_context_mut();\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(true);\n+        }\n+        let result = op(this);\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(false);\n+        }\n+        result\n+    }\n+\n     /// Generic atomic operation implementation\n     fn validate_atomic_op<A: Debug + Copy>(\n         &self,"}, {"sha": "996d04a2c57ccd1c1e0c661c9938a79abafcdda0", "filename": "src/eval.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ebda1deb7bbe962638f500fc772d8d005cfed01c/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebda1deb7bbe962638f500fc772d8d005cfed01c/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=ebda1deb7bbe962638f500fc772d8d005cfed01c", "patch": "@@ -363,13 +363,12 @@ pub fn eval_entry<'tcx>(\n         panic::resume_unwind(panic_payload)\n     });\n \n-    // Machine cleanup.\n-    // Execution of the program has halted so any memory access we do here\n-    // cannot produce a real data race. If we do not do something to disable\n-    // data race detection here, some uncommon combination of errors will\n-    // cause a data race to be detected:\n-    // https://github.com/rust-lang/miri/issues/2020\n-    ecx.allow_data_races_mut(|ecx| EnvVars::cleanup(ecx).unwrap());\n+    // Machine cleanup. Only do this if all threads have terminated; threads that are still running\n+    // might cause data races (https://github.com/rust-lang/miri/issues/2020) or Stacked Borrows\n+    // errors (https://github.com/rust-lang/miri/issues/2396) if we deallocate here.\n+    if ecx.have_all_terminated() {\n+        EnvVars::cleanup(&mut ecx).unwrap();\n+    }\n \n     // Process the result.\n     match res {"}]}