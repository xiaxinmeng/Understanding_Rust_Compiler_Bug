{"sha": "70f9a0b214b7ce6f754b8bf8c52ffc119af444eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZjlhMGIyMTRiN2NlNmY3NTRiOGJmOGM1MmZmYzExOWFmNDQ0ZWI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-07T13:53:21Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-07T13:53:21Z"}, "message": "incr.comp.: Allow for forcing input nodes lazily.", "tree": {"sha": "dcd78ae2593b2c13b045cce5d51536ce83537f82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcd78ae2593b2c13b045cce5d51536ce83537f82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70f9a0b214b7ce6f754b8bf8c52ffc119af444eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70f9a0b214b7ce6f754b8bf8c52ffc119af444eb", "html_url": "https://github.com/rust-lang/rust/commit/70f9a0b214b7ce6f754b8bf8c52ffc119af444eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70f9a0b214b7ce6f754b8bf8c52ffc119af444eb/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54bbd567153463ce81d3ff7f0ca980a7f73cd3af", "url": "https://api.github.com/repos/rust-lang/rust/commits/54bbd567153463ce81d3ff7f0ca980a7f73cd3af", "html_url": "https://github.com/rust-lang/rust/commit/54bbd567153463ce81d3ff7f0ca980a7f73cd3af"}], "stats": {"total": 121, "additions": 70, "deletions": 51}, "files": [{"sha": "c22fc40658cac6612b9bf04219d17bd2aa249fd8", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 70, "deletions": 51, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/70f9a0b214b7ce6f754b8bf8c52ffc119af444eb/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f9a0b214b7ce6f754b8bf8c52ffc119af444eb/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=70f9a0b214b7ce6f754b8bf8c52ffc119af444eb", "patch": "@@ -506,60 +506,57 @@ impl DepGraph {\n                     return None\n                 }\n                 None => {\n-                    if dep_dep_node.kind.is_input() {\n-                        // This input does not exist anymore.\n-                        debug_assert!(dep_dep_node.extract_def_id(tcx).is_none(),\n-                                      \"Encountered input {:?} without color\",\n-                                      dep_dep_node);\n-                        debug!(\"try_mark_green({:?}) - END - dependency {:?} \\\n-                                was deleted input\", dep_node, dep_dep_node);\n-                        return None;\n+                    // We don't know the state of this dependency. If it isn't\n+                    // an input node, let's try to mark it green recursively.\n+                    if !dep_dep_node.kind.is_input() {\n+                         debug!(\"try_mark_green({:?}) --- state of dependency {:?} \\\n+                                 is unknown, trying to mark it green\", dep_node,\n+                                 dep_dep_node);\n+\n+                        if let Some(node_index) = self.try_mark_green(tcx, dep_dep_node) {\n+                            debug!(\"try_mark_green({:?}) --- managed to MARK \\\n+                                    dependency {:?} as green\", dep_node, dep_dep_node);\n+                            current_deps.push(node_index);\n+                            continue;\n+                        }\n                     }\n \n-                    debug!(\"try_mark_green({:?}) --- state of dependency {:?} \\\n-                            is unknown, trying to mark it green\", dep_node,\n-                            dep_dep_node);\n-\n-                    // We don't know the state of this dependency. Let's try to\n-                    // mark it green.\n-                    if let Some(node_index) = self.try_mark_green(tcx, dep_dep_node) {\n-                        debug!(\"try_mark_green({:?}) --- managed to MARK \\\n-                                dependency {:?} as green\", dep_node, dep_dep_node);\n-                        current_deps.push(node_index);\n-                    } else {\n-                        // We failed to mark it green, so we try to force the query.\n-                        debug!(\"try_mark_green({:?}) --- trying to force \\\n-                                dependency {:?}\", dep_node, dep_dep_node);\n-                        if ::ty::maps::force_from_dep_node(tcx, dep_dep_node) {\n-                            let dep_dep_node_color = data.colors\n-                                                         .borrow()\n-                                                         .get(dep_dep_node)\n-                                                         .cloned();\n-                            match dep_dep_node_color {\n-                                Some(DepNodeColor::Green(node_index)) => {\n-                                    debug!(\"try_mark_green({:?}) --- managed to \\\n-                                            FORCE dependency {:?} to green\",\n-                                            dep_node, dep_dep_node);\n-                                    current_deps.push(node_index);\n-                                }\n-                                Some(DepNodeColor::Red) => {\n-                                    debug!(\"try_mark_green({:?}) - END - \\\n-                                            dependency {:?} was red after forcing\",\n-                                           dep_node,\n-                                           dep_dep_node);\n-                                    return None\n-                                }\n-                                None => {\n-                                    bug!(\"try_mark_green() - Forcing the DepNode \\\n-                                          should have set its color\")\n-                                }\n+                    // We failed to mark it green, so we try to force the query.\n+                    debug!(\"try_mark_green({:?}) --- trying to force \\\n+                            dependency {:?}\", dep_node, dep_dep_node);\n+                    if ::ty::maps::force_from_dep_node(tcx, dep_dep_node) {\n+                        let dep_dep_node_color = data.colors\n+                                                     .borrow()\n+                                                     .get(dep_dep_node)\n+                                                     .cloned();\n+                        match dep_dep_node_color {\n+                            Some(DepNodeColor::Green(node_index)) => {\n+                                debug!(\"try_mark_green({:?}) --- managed to \\\n+                                        FORCE dependency {:?} to green\",\n+                                        dep_node, dep_dep_node);\n+                                current_deps.push(node_index);\n+                            }\n+                            Some(DepNodeColor::Red) => {\n+                                debug!(\"try_mark_green({:?}) - END - \\\n+                                        dependency {:?} was red after forcing\",\n+                                       dep_node,\n+                                       dep_dep_node);\n+                                return None\n+                            }\n+                            None => {\n+                                bug!(\"try_mark_green() - Forcing the DepNode \\\n+                                      should have set its color\")\n                             }\n-                        } else {\n-                            // The DepNode could not be forced.\n-                            debug!(\"try_mark_green({:?}) - END - dependency {:?} \\\n-                                    could not be forced\", dep_node, dep_dep_node);\n-                            return None\n                         }\n+                    } else {\n+                        debug_assert!(!dep_dep_node.kind.is_input() ||\n+                            dep_dep_node.extract_def_id(tcx).is_none(),\n+                            \"Could not force input that should still exist.\");\n+\n+                        // The DepNode could not be forced.\n+                        debug!(\"try_mark_green({:?}) - END - dependency {:?} \\\n+                                could not be forced\", dep_node, dep_dep_node);\n+                        return None\n                     }\n                 }\n             }\n@@ -772,7 +769,27 @@ impl CurrentDepGraph {\n             read_set: _,\n             reads\n         } = popped_node {\n-            debug_assert_eq!(node, key);\n+            assert_eq!(node, key);\n+\n+            // If this is an input node, we expect that it either has no\n+            // dependencies, or that it just depends on DepKind::CrateMetadata\n+            // or DepKind::Krate. This happens for some \"thin wrapper queries\"\n+            // like `crate_disambiguator` which sometimes have zero deps (for\n+            // when called for LOCAL_CRATE) or they depend on a CrateMetadata\n+            // node.\n+            if cfg!(debug_assertions) {\n+                if node.kind.is_input() && reads.len() > 0 &&\n+                    reads.iter().any(|&i| {\n+                        !(self.nodes[i].kind == DepKind::CrateMetadata ||\n+                          self.nodes[i].kind == DepKind::Krate)\n+                    })\n+                {\n+                    bug!(\"Input node {:?} with unexpected reads: {:?}\",\n+                        node,\n+                        reads.iter().map(|&i| self.nodes[i]).collect::<Vec<_>>())\n+                }\n+            }\n+\n             self.alloc_node(node, reads)\n         } else {\n             bug!(\"pop_task() - Expected regular task to be popped\")\n@@ -793,6 +810,8 @@ impl CurrentDepGraph {\n             read_set: _,\n             reads\n         } = popped_node {\n+            debug_assert!(!kind.is_input());\n+\n             let mut fingerprint = self.anon_id_seed;\n             let mut hasher = StableHasher::new();\n "}]}