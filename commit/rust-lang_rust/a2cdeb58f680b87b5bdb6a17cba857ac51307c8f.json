{"sha": "a2cdeb58f680b87b5bdb6a17cba857ac51307c8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyY2RlYjU4ZjY4MGI4N2I1YmRiNmExN2NiYTg1N2FjNTEzMDdjOGY=", "commit": {"author": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-12-22T01:23:47Z"}, "committer": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-12-23T02:52:52Z"}, "message": "Expose float from_bits and to_bits in libcore.", "tree": {"sha": "e63e0cdfb047d7c3da3610098f21db01cd993431", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e63e0cdfb047d7c3da3610098f21db01cd993431"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f", "html_url": "https://github.com/rust-lang/rust/commit/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5165ee9e209e0e70d89946ccbb7e90b9c0c3a7ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/5165ee9e209e0e70d89946ccbb7e90b9c0c3a7ac", "html_url": "https://github.com/rust-lang/rust/commit/5165ee9e209e0e70d89946ccbb7e90b9c0c3a7ac"}], "stats": {"total": 108, "additions": 55, "deletions": 53}, "files": [{"sha": "143a05a19445c806d4404ce6462afe8c3a3e325e", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 6, "deletions": 33, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=a2cdeb58f680b87b5bdb6a17cba857ac51307c8f", "patch": "@@ -27,11 +27,10 @@\n //! Many functions in this module only handle normal numbers. The dec2flt routines conservatively\n //! take the universally-correct slow path (Algorithm M) for very small and very large numbers.\n //! That algorithm needs only next_float() which does handle subnormals and zeros.\n-use u32;\n use cmp::Ordering::{Less, Equal, Greater};\n+use convert::TryInto;\n use ops::{Mul, Div, Neg};\n use fmt::{Debug, LowerExp};\n-use mem::transmute;\n use num::diy_float::Fp;\n use num::FpCategory::{Infinite, Zero, Subnormal, Normal, Nan};\n use num::Float;\n@@ -66,12 +65,6 @@ pub trait RawFloat : Float + Copy + Debug + LowerExp\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Get the raw binary representation of the float.\n-    fn transmute(self) -> u64;\n-\n-    /// Transmute the raw binary representation into a float.\n-    fn from_bits(bits: u64) -> Self;\n-\n     /// Decode the float.\n     fn unpack(self) -> Unpacked;\n \n@@ -159,7 +152,7 @@ impl RawFloat for f32 {\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe { transmute(self) };\n+        let bits = self.to_bits();\n         let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n         let mantissa = if exponent == 0 {\n@@ -172,16 +165,6 @@ impl RawFloat for f32 {\n         (mantissa as u64, exponent, sign)\n     }\n \n-    fn transmute(self) -> u64 {\n-        let bits: u32 = unsafe { transmute(self) };\n-        bits as u64\n-    }\n-\n-    fn from_bits(bits: u64) -> f32 {\n-        assert!(bits < u32::MAX as u64, \"f32::from_bits: too many bits\");\n-        unsafe { transmute(bits as u32) }\n-    }\n-\n     fn unpack(self) -> Unpacked {\n         let (sig, exp, _sig) = self.integer_decode();\n         Unpacked::new(sig, exp)\n@@ -210,7 +193,7 @@ impl RawFloat for f64 {\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe { transmute(self) };\n+        let bits = self.to_bits();\n         let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n         let mantissa = if exponent == 0 {\n@@ -223,15 +206,6 @@ impl RawFloat for f64 {\n         (mantissa, exponent, sign)\n     }\n \n-    fn transmute(self) -> u64 {\n-        let bits: u64 = unsafe { transmute(self) };\n-        bits\n-    }\n-\n-    fn from_bits(bits: u64) -> f64 {\n-        unsafe { transmute(bits) }\n-    }\n-\n     fn unpack(self) -> Unpacked {\n         let (sig, exp, _sig) = self.integer_decode();\n         Unpacked::new(sig, exp)\n@@ -296,14 +270,14 @@ pub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\n         \"encode_normal: exponent out of range\");\n     // Leave sign bit at 0 (\"+\"), our numbers are all positive\n     let bits = (k_enc as u64) << T::EXPLICIT_SIG_BITS | sig_enc;\n-    T::from_bits(bits)\n+    T::from_bits(bits.try_into().unwrap_or_else(|_| unreachable!()))\n }\n \n /// Construct a subnormal. A mantissa of 0 is allowed and constructs zero.\n pub fn encode_subnormal<T: RawFloat>(significand: u64) -> T {\n     assert!(significand < T::MIN_SIG, \"encode_subnormal: not actually subnormal\");\n     // Encoded exponent is 0, the sign bit is 0, so we just have to reinterpret the bits.\n-    T::from_bits(significand)\n+    T::from_bits(significand.try_into().unwrap_or_else(|_| unreachable!()))\n }\n \n /// Approximate a bignum with an Fp. Rounds within 0.5 ULP with half-to-even.\n@@ -363,8 +337,7 @@ pub fn next_float<T: RawFloat>(x: T) -> T {\n         // too is exactly what we want!\n         // Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.\n         Zero | Subnormal | Normal => {\n-            let bits: u64 = x.transmute();\n-            T::from_bits(bits + 1)\n+            T::from_bits(x.to_bits() + T::Bits::from(1u8))\n         }\n     }\n }"}, {"sha": "dc37bce8eb02c65120eb823b8a631d528b532f94", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a2cdeb58f680b87b5bdb6a17cba857ac51307c8f", "patch": "@@ -140,6 +140,8 @@ pub mod consts {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n impl Float for f32 {\n+    type Bits = u32;\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool {\n@@ -171,7 +173,7 @@ impl Float for f32 {\n         const EXP_MASK: u32 = 0x7f800000;\n         const MAN_MASK: u32 = 0x007fffff;\n \n-        let bits: u32 = unsafe { mem::transmute(self) };\n+        let bits = self.to_bits();\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0) => Fp::Zero,\n             (_, 0) => Fp::Subnormal,\n@@ -215,12 +217,7 @@ impl Float for f32 {\n     fn is_sign_negative(self) -> bool {\n         // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n         // applies to zeros and NaNs as well.\n-        #[repr(C)]\n-        union F32Bytes {\n-            f: f32,\n-            b: u32\n-        }\n-        unsafe { F32Bytes { f: self }.b & 0x8000_0000 != 0 }\n+        self.to_bits() & 0x8000_0000 != 0\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number.\n@@ -274,4 +271,17 @@ impl Float for f32 {\n         // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n         (if self < other || other.is_nan() { self } else { other }) * 1.0\n     }\n+\n+    /// Raw transmutation to `u32`.\n+    #[inline]\n+    fn to_bits(self) -> u32 {\n+        unsafe { mem::transmute(self) }\n+    }\n+\n+    /// Raw transmutation from `u32`.\n+    #[inline]\n+    fn from_bits(v: u32) -> Self {\n+        // It turns out the safety issues with sNaN were overblown! Hooray!\n+        unsafe { mem::transmute(v) }\n+    }\n }"}, {"sha": "5c217167f98323d14b496df01992632394c7ca33", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a2cdeb58f680b87b5bdb6a17cba857ac51307c8f", "patch": "@@ -140,6 +140,8 @@ pub mod consts {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n impl Float for f64 {\n+    type Bits = u64;\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool {\n@@ -171,7 +173,7 @@ impl Float for f64 {\n         const EXP_MASK: u64 = 0x7ff0000000000000;\n         const MAN_MASK: u64 = 0x000fffffffffffff;\n \n-        let bits: u64 = unsafe { mem::transmute(self) };\n+        let bits = self.to_bits();\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0) => Fp::Zero,\n             (_, 0) => Fp::Subnormal,\n@@ -213,12 +215,7 @@ impl Float for f64 {\n     /// negative sign bit and negative infinity.\n     #[inline]\n     fn is_sign_negative(self) -> bool {\n-        #[repr(C)]\n-        union F64Bytes {\n-            f: f64,\n-            b: u64\n-        }\n-        unsafe { F64Bytes { f: self }.b & 0x8000_0000_0000_0000 != 0 }\n+        self.to_bits() & 0x8000_0000_0000_0000 != 0\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number.\n@@ -272,4 +269,17 @@ impl Float for f64 {\n         // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n         (if self < other || other.is_nan() { self } else { other }) * 1.0\n     }\n+\n+    /// Raw transmutation to `u64`.\n+    #[inline]\n+    fn to_bits(self) -> u64 {\n+        unsafe { mem::transmute(self) }\n+    }\n+\n+    /// Raw transmutation from `u64`.\n+    #[inline]\n+    fn from_bits(v: u64) -> Self {\n+        // It turns out the safety issues with sNaN were overblown! Hooray!\n+        unsafe { mem::transmute(v) }\n+    }\n }"}, {"sha": "94efde6d41dbd98040fb7f9bffc30a26e94b426d", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a2cdeb58f680b87b5bdb6a17cba857ac51307c8f", "patch": "@@ -2872,6 +2872,10 @@ pub enum FpCategory {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n pub trait Float: Sized {\n+    /// Type used by `to_bits` and `from_bits`.\n+    #[stable(feature = \"core_float_bits\", since = \"1.24.0\")]\n+    type Bits: ops::Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;\n+\n     /// Returns `true` if this value is NaN and false otherwise.\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_nan(self) -> bool;\n@@ -2933,6 +2937,13 @@ pub trait Float: Sized {\n     /// Returns the minimum of the two numbers.\n     #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n     fn min(self, other: Self) -> Self;\n+\n+    /// Raw transmutation to integer.\n+    #[stable(feature = \"core_float_bits\", since=\"1.24.0\")]\n+    fn to_bits(self) -> Self::Bits;\n+    /// Raw transmutation from integer.\n+    #[stable(feature = \"core_float_bits\", since=\"1.24.0\")]\n+    fn from_bits(v: Self::Bits) -> Self;\n }\n \n macro_rules! from_str_radix_int_impl {"}, {"sha": "18eb2a27b91e79589e47452e65e0c161b1f74e2f", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=a2cdeb58f680b87b5bdb6a17cba857ac51307c8f", "patch": "@@ -1016,7 +1016,7 @@ impl f32 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn to_bits(self) -> u32 {\n-        unsafe { ::mem::transmute(self) }\n+        num::Float::to_bits(self)\n     }\n \n     /// Raw transmutation from `u32`.\n@@ -1060,8 +1060,7 @@ impl f32 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u32) -> Self {\n-        // It turns out the safety issues with sNaN were overblown! Hooray!\n-        unsafe { ::mem::transmute(v) }\n+        num::Float::from_bits(v)\n     }\n }\n "}, {"sha": "cabb2c48054bfe8f32e315b43ee3a627ec14ea66", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2cdeb58f680b87b5bdb6a17cba857ac51307c8f/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=a2cdeb58f680b87b5bdb6a17cba857ac51307c8f", "patch": "@@ -971,7 +971,7 @@ impl f64 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn to_bits(self) -> u64 {\n-        unsafe { ::mem::transmute(self) }\n+        num::Float::to_bits(self)\n     }\n \n     /// Raw transmutation from `u64`.\n@@ -1015,8 +1015,7 @@ impl f64 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u64) -> Self {\n-        // It turns out the safety issues with sNaN were overblown! Hooray!\n-        unsafe { ::mem::transmute(v) }\n+        num::Float::from_bits(v)\n     }\n }\n "}]}