{"sha": "b079ebeb8da4198112831af05c88b48974268337", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNzllYmViOGRhNDE5ODExMjgzMWFmMDVjODhiNDg5NzQyNjgzMzc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-27T04:25:37Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-27T04:25:37Z"}, "message": "syntax: improve the spans of some #[deriving] traits.\n\nThis makes error messages about (e.g.) `#[deriving(Clone)] struct Foo {\nx: Type }` point at `x: Type` rather than `Clone` in the header (while\nstill referring to the `#[deriving(Clone)]` in the expansion info).", "tree": {"sha": "23961d6c6f7d9d5183a197d1b695682ad5cf5453", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23961d6c6f7d9d5183a197d1b695682ad5cf5453"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b079ebeb8da4198112831af05c88b48974268337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b079ebeb8da4198112831af05c88b48974268337", "html_url": "https://github.com/rust-lang/rust/commit/b079ebeb8da4198112831af05c88b48974268337", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b079ebeb8da4198112831af05c88b48974268337/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b7f823156a9e11126792529ec45c7490fea2fc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7f823156a9e11126792529ec45c7490fea2fc3", "html_url": "https://github.com/rust-lang/rust/commit/0b7f823156a9e11126792529ec45c7490fea2fc3"}], "stats": {"total": 275, "additions": 138, "deletions": 137}, "files": [{"sha": "567b89d3453f7e640f5201e499896c1d25a52429", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=b079ebeb8da4198112831af05c88b48974268337", "patch": "@@ -74,13 +74,13 @@ pub fn expand_deriving_deep_clone(cx: &ExtCtxt,\n \n fn cs_clone(\n     name: &str,\n-    cx: &ExtCtxt, span: Span,\n+    cx: &ExtCtxt, trait_span: Span,\n     substr: &Substructure) -> @Expr {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;\n     let all_fields;\n-    let subcall = |field|\n-        cx.expr_method_call(span, field, clone_ident, ~[]);\n+    let subcall = |field: &FieldInfo|\n+        cx.expr_method_call(field.span, field.self_, clone_ident, ~[]);\n \n     match *substr.fields {\n         Struct(ref af) => {\n@@ -91,37 +91,37 @@ fn cs_clone(\n             ctor_ident = variant.node.name;\n             all_fields = af;\n         },\n-        EnumNonMatching(..) => cx.span_bug(span,\n-                                          format!(\"Non-matching enum variants in `deriving({})`\",\n-                                               name)),\n-        StaticEnum(..) | StaticStruct(..) => cx.span_bug(span,\n-                                                       format!(\"Static method in `deriving({})`\",\n-                                                            name))\n+        EnumNonMatching(..) => cx.span_bug(trait_span,\n+                                           format!(\"Non-matching enum variants in `deriving({})`\",\n+                                                  name)),\n+        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span,\n+                                                         format!(\"Static method in `deriving({})`\",\n+                                                                 name))\n     }\n \n     match *all_fields {\n         [FieldInfo { name: None, .. }, ..] => {\n             // enum-like\n-            let subcalls = all_fields.map(|field| subcall(field.self_));\n-            cx.expr_call_ident(span, ctor_ident, subcalls)\n+            let subcalls = all_fields.map(subcall);\n+            cx.expr_call_ident(trait_span, ctor_ident, subcalls)\n         },\n         _ => {\n             // struct-like\n             let fields = all_fields.map(|field| {\n                 let ident = match field.name {\n                     Some(i) => i,\n-                    None => cx.span_bug(span,\n+                    None => cx.span_bug(trait_span,\n                                         format!(\"unnamed field in normal struct in `deriving({})`\",\n-                                             name))\n+                                                name))\n                 };\n-                cx.field_imm(span, ident, subcall(field.self_))\n+                cx.field_imm(field.span, ident, subcall(field))\n             });\n \n             if fields.is_empty() {\n                 // no fields, so construct like `None`\n-                cx.expr_ident(span, ctor_ident)\n+                cx.expr_ident(trait_span, ctor_ident)\n             } else {\n-                cx.expr_struct_ident(span, ctor_ident, fields)\n+                cx.expr_struct_ident(trait_span, ctor_ident, fields)\n             }\n         }\n     }"}, {"sha": "a9268d85c91547e2c62a8ef6024fcb25c1a40558", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=b079ebeb8da4198112831af05c88b48974268337", "patch": "@@ -51,7 +51,7 @@ pub fn expand_deriving_decodable(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn decodable_substructure(cx: &ExtCtxt, span: Span,\n+fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n                           substr: &Substructure) -> @Expr {\n     let decoder = substr.nonself_args[0];\n     let recurse = ~[cx.ident_of(\"extra\"),\n@@ -60,9 +60,9 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n                     cx.ident_of(\"decode\")];\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_d\");\n-    let blkdecoder = cx.expr_ident(span, blkarg);\n-    let calldecode = cx.expr_call_global(span, recurse, ~[blkdecoder]);\n-    let lambdadecode = cx.lambda_expr_1(span, calldecode, blkarg);\n+    let blkdecoder = cx.expr_ident(trait_span, blkarg);\n+    let calldecode = cx.expr_call_global(trait_span, recurse, ~[blkdecoder]);\n+    let lambdadecode = cx.lambda_expr_1(trait_span, calldecode, blkarg);\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n@@ -73,7 +73,7 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n             let read_struct_field = cx.ident_of(\"read_struct_field\");\n \n             let result = decode_static_fields(cx,\n-                                              span,\n+                                              trait_span,\n                                               substr.type_ident,\n                                               summary,\n                                               |span, name, field| {\n@@ -82,10 +82,10 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n                                       cx.expr_uint(span, field),\n                                       lambdadecode])\n             });\n-            cx.expr_method_call(span, decoder, cx.ident_of(\"read_struct\"),\n-                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n-                                  cx.expr_uint(span, nfields),\n-                                  cx.lambda_expr_1(span, result, blkarg)])\n+            cx.expr_method_call(trait_span, decoder, cx.ident_of(\"read_struct\"),\n+                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n+                                  cx.expr_uint(trait_span, nfields),\n+                                  cx.lambda_expr_1(trait_span, result, blkarg)])\n         }\n         StaticEnum(_, ref fields) => {\n             let variant = cx.ident_of(\"i\");\n@@ -94,12 +94,11 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n             let mut variants = ~[];\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n-            for (i, f) in fields.iter().enumerate() {\n-                let (name, parts) = match *f { (i, ref p) => (i, p) };\n-                variants.push(cx.expr_str(span, cx.str_of(name)));\n+            for (i, &(name, v_span, ref parts)) in fields.iter().enumerate() {\n+                variants.push(cx.expr_str(v_span, cx.str_of(name)));\n \n                 let decoded = decode_static_fields(cx,\n-                                                   span,\n+                                                   v_span,\n                                                    name,\n                                                    parts,\n                                                    |span, _, field| {\n@@ -108,22 +107,22 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n                                           lambdadecode])\n                 });\n \n-                arms.push(cx.arm(span,\n-                                 ~[cx.pat_lit(span, cx.expr_uint(span, i))],\n+                arms.push(cx.arm(v_span,\n+                                 ~[cx.pat_lit(v_span, cx.expr_uint(v_span, i))],\n                                  decoded));\n             }\n \n-            arms.push(cx.arm_unreachable(span));\n+            arms.push(cx.arm_unreachable(trait_span));\n \n-            let result = cx.expr_match(span, cx.expr_ident(span, variant), arms);\n-            let lambda = cx.lambda_expr(span, ~[blkarg, variant], result);\n-            let variant_vec = cx.expr_vec(span, variants);\n-            let result = cx.expr_method_call(span, blkdecoder,\n+            let result = cx.expr_match(trait_span, cx.expr_ident(trait_span, variant), arms);\n+            let lambda = cx.lambda_expr(trait_span, ~[blkarg, variant], result);\n+            let variant_vec = cx.expr_vec(trait_span, variants);\n+            let result = cx.expr_method_call(trait_span, blkdecoder,\n                                              cx.ident_of(\"read_enum_variant\"),\n                                              ~[variant_vec, lambda]);\n-            cx.expr_method_call(span, decoder, cx.ident_of(\"read_enum\"),\n-                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n-                                  cx.lambda_expr_1(span, result, blkarg)])\n+            cx.expr_method_call(trait_span, decoder, cx.ident_of(\"read_enum\"),\n+                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n+                                  cx.lambda_expr_1(trait_span, result, blkarg)])\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in deriving(Decodable)\")\n     };\n@@ -133,29 +132,29 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n /// - `outer_pat_ident` is the name of this enum variant/struct\n /// - `getarg` should retrieve the `uint`-th field with name `@str`.\n fn decode_static_fields(cx: &ExtCtxt,\n-                        outer_span: Span,\n+                        trait_span: Span,\n                         outer_pat_ident: Ident,\n                         fields: &StaticFields,\n                         getarg: |Span, @str, uint| -> @Expr)\n                         -> @Expr {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {\n-                cx.expr_ident(outer_span, outer_pat_ident)\n+                cx.expr_ident(trait_span, outer_pat_ident)\n             } else {\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n                     getarg(span, format!(\"_field{}\", i).to_managed(), i)\n                 }).collect();\n \n-                cx.expr_call_ident(outer_span, outer_pat_ident, fields)\n+                cx.expr_call_ident(trait_span, outer_pat_ident, fields)\n             }\n         }\n         Named(ref fields) => {\n             // use the field's span to get nicer error messages.\n             let fields = fields.iter().enumerate().map(|(i, &(name, span))| {\n                 cx.field_imm(span, name, getarg(span, cx.str_of(name), i))\n             }).collect();\n-            cx.expr_struct_ident(outer_span, outer_pat_ident, fields)\n+            cx.expr_struct_ident(trait_span, outer_pat_ident, fields)\n         }\n     }\n }"}, {"sha": "22f850d56090e845abc57488836a51dfe723f5ea", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=b079ebeb8da4198112831af05c88b48974268337", "patch": "@@ -41,7 +41,7 @@ pub fn expand_deriving_default(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn default_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn default_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let default_ident = ~[\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"default\"),\n@@ -55,25 +55,25 @@ fn default_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Exp\n             match *summary {\n                 Unnamed(ref fields) => {\n                     if fields.is_empty() {\n-                        cx.expr_ident(span, substr.type_ident)\n+                        cx.expr_ident(trait_span, substr.type_ident)\n                     } else {\n                         let exprs = fields.map(|sp| default_call(*sp));\n-                        cx.expr_call_ident(span, substr.type_ident, exprs)\n+                        cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n                     }\n                 }\n                 Named(ref fields) => {\n                     let default_fields = fields.map(|&(ident, span)| {\n                         cx.field_imm(span, ident, default_call(span))\n                     });\n-                    cx.expr_struct_ident(span, substr.type_ident, default_fields)\n+                    cx.expr_struct_ident(trait_span, substr.type_ident, default_fields)\n                 }\n             }\n         }\n         StaticEnum(..) => {\n-            cx.span_err(span, \"`Default` cannot be derived for enums, only structs\");\n+            cx.span_err(trait_span, \"`Default` cannot be derived for enums, only structs\");\n             // let compilation continue\n-            cx.expr_uint(span, 0)\n+            cx.expr_uint(trait_span, 0)\n         }\n-        _ => cx.bug(\"Non-static method in `deriving(Default)`\")\n+        _ => cx.span_bug(trait_span, \"Non-static method in `deriving(Default)`\")\n     };\n }"}, {"sha": "9a8861f2e70e2daf3bc8a0a6671c6152361fd5a2", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=b079ebeb8da4198112831af05c88b48974268337", "patch": "@@ -113,24 +113,24 @@ pub fn expand_deriving_encodable(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn encodable_substructure(cx: &ExtCtxt, span: Span,\n+fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n                           substr: &Substructure) -> @Expr {\n     let encoder = substr.nonself_args[0];\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_e\");\n-    let blkencoder = cx.expr_ident(span, blkarg);\n+    let blkencoder = cx.expr_ident(trait_span, blkarg);\n     let encode = cx.ident_of(\"encode\");\n \n     return match *substr.fields {\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = ~[];\n-            for (i, f) in fields.iter().enumerate() {\n-                let name = match f.name {\n+            for (i, &FieldInfo { name, self_, span, .. }) in fields.iter().enumerate() {\n+                let name = match name {\n                     Some(id) => cx.str_of(id),\n                     None => format!(\"_field{}\", i).to_managed()\n                 };\n-                let enc = cx.expr_method_call(span, f.self_, encode, ~[blkencoder]);\n+                let enc = cx.expr_method_call(span, self_, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_struct_field,\n@@ -140,10 +140,10 @@ fn encodable_substructure(cx: &ExtCtxt, span: Span,\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n-            let blk = cx.lambda_stmts_1(span, stmts, blkarg);\n-            cx.expr_method_call(span, encoder, cx.ident_of(\"emit_struct\"),\n-                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n-                                  cx.expr_uint(span, fields.len()),\n+            let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n+            cx.expr_method_call(trait_span, encoder, cx.ident_of(\"emit_struct\"),\n+                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n+                                  cx.expr_uint(trait_span, fields.len()),\n                                   blk])\n         }\n \n@@ -152,12 +152,12 @@ fn encodable_substructure(cx: &ExtCtxt, span: Span,\n             // so we need to generate a unique local variable to take the\n             // mutable loan out on, otherwise we get conflicts which don't\n             // actually exist.\n-            let me = cx.stmt_let(span, false, blkarg, encoder);\n-            let encoder = cx.expr_ident(span, blkarg);\n+            let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n+            let encoder = cx.expr_ident(trait_span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = ~[];\n-            for (i, f) in fields.iter().enumerate() {\n-                let enc = cx.expr_method_call(span, f.self_, encode, ~[blkencoder]);\n+            for (i, &FieldInfo { self_, span, .. }) in fields.iter().enumerate() {\n+                let enc = cx.expr_method_call(span, self_, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_variant_arg,\n@@ -166,21 +166,21 @@ fn encodable_substructure(cx: &ExtCtxt, span: Span,\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n-            let blk = cx.lambda_stmts_1(span, stmts, blkarg);\n-            let name = cx.expr_str(span, cx.str_of(variant.node.name));\n-            let call = cx.expr_method_call(span, blkencoder,\n+            let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n+            let name = cx.expr_str(trait_span, cx.str_of(variant.node.name));\n+            let call = cx.expr_method_call(trait_span, blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n                                            ~[name,\n-                                             cx.expr_uint(span, idx),\n-                                             cx.expr_uint(span, fields.len()),\n+                                             cx.expr_uint(trait_span, idx),\n+                                             cx.expr_uint(trait_span, fields.len()),\n                                              blk]);\n-            let blk = cx.lambda_expr_1(span, call, blkarg);\n-            let ret = cx.expr_method_call(span, encoder,\n+            let blk = cx.lambda_expr_1(trait_span, call, blkarg);\n+            let ret = cx.expr_method_call(trait_span, encoder,\n                                           cx.ident_of(\"emit_enum\"),\n-                                          ~[cx.expr_str(span,\n+                                          ~[cx.expr_str(trait_span,\n                                             cx.str_of(substr.type_ident)),\n                                             blk]);\n-            cx.expr_block(cx.block(span, ~[me], Some(ret)))\n+            cx.expr_block(cx.block(trait_span, ~[me], Some(ret)))\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in deriving(Encodable)\")"}, {"sha": "1f778779fbd42a30f679681d41db6974ca3b71d7", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=b079ebeb8da4198112831af05c88b48974268337", "patch": "@@ -169,8 +169,9 @@ StaticStruct(<ast::StructDef of A>, Named(~[(<ident of x>, <span of x>)]))\n \n StaticStruct(<ast::StructDef of B>, Unnamed(~[<span of x>]))\n \n-StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, Unnamed(~[<span of int>])),\n-                                  (<ident of C1>, Named(~[(<ident of x>, <span of x>)]))])\n+StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span of int>])),\n+                                  (<ident of C1>, <span of C1>,\n+                                   Named(~[(<ident of x>, <span of x>)]))])\n ~~~\n \n */\n@@ -291,7 +292,7 @@ pub enum SubstructureFields<'a> {\n     /// A static method where Self is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n     /// A static method where Self is an enum.\n-    StaticEnum(&'a ast::EnumDef, ~[(Ident, StaticFields)])\n+    StaticEnum(&'a ast::EnumDef, ~[(Ident, Span, StaticFields)])\n }\n \n \n@@ -905,7 +906,7 @@ impl<'a> MethodDef<'a> {\n                     trait_.summarise_struct(struct_def)\n                 }\n             };\n-            (ident, summary)\n+            (ident, v.span, summary)\n         });\n         self.call_substructure_method(trait_, type_ident,\n                                       self_args, nonself_args,"}, {"sha": "d82e1ef1842614de0f044ff8a1df86af12691aa7", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=b079ebeb8da4198112831af05c88b48974268337", "patch": "@@ -45,19 +45,20 @@ pub fn expand_deriving_iter_bytes(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn iter_bytes_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn iter_bytes_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let (lsb0, f)= match substr.nonself_args {\n         [l, f] => (l, f),\n-        _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(IterBytes)`\")\n+        _ => cx.span_bug(trait_span, \"Incorrect number of arguments in `deriving(IterBytes)`\")\n     };\n     // Build the \"explicitly borrowed\" stack closure, \"|_buf| f(_buf)\".\n     let blk_arg = cx.ident_of(\"_buf\");\n     let borrowed_f =\n-        cx.lambda_expr_1(span, cx.expr_call(span, f, ~[cx.expr_ident(span, blk_arg)]),\n+        cx.lambda_expr_1(trait_span,\n+                         cx.expr_call(trait_span, f, ~[cx.expr_ident(trait_span, blk_arg)]),\n                          blk_arg);\n \n     let iter_bytes_ident = substr.method_ident;\n-    let call_iterbytes = |thing_expr| {\n+    let call_iterbytes = |span, thing_expr| {\n         cx.expr_method_call(span,\n                             thing_expr,\n                             iter_bytes_ident,\n@@ -74,25 +75,25 @@ fn iter_bytes_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @\n             // iteration function.\n             let discriminant = match variant.node.disr_expr {\n                 Some(d)=> d,\n-                None => cx.expr_uint(span, index)\n+                None => cx.expr_uint(trait_span, index)\n             };\n \n-            exprs.push(call_iterbytes(discriminant));\n+            exprs.push(call_iterbytes(trait_span, discriminant));\n \n             fields = fs;\n         }\n-        _ => cx.span_bug(span, \"Impossible substructure in `deriving(IterBytes)`\")\n+        _ => cx.span_bug(trait_span, \"Impossible substructure in `deriving(IterBytes)`\")\n     }\n \n-    for &FieldInfo { self_, .. } in fields.iter() {\n-        exprs.push(call_iterbytes(self_));\n+    for &FieldInfo { self_, span, .. } in fields.iter() {\n+        exprs.push(call_iterbytes(span, self_));\n     }\n \n     if exprs.len() == 0 {\n-        cx.span_bug(span, \"#[deriving(IterBytes)] needs at least one field\");\n+        cx.span_bug(trait_span, \"#[deriving(IterBytes)] needs at least one field\");\n     }\n \n     exprs.slice(1, exprs.len()).iter().fold(exprs[0], |prev, me| {\n-        cx.expr_binary(span, BiAnd, prev, *me)\n+        cx.expr_binary(trait_span, BiAnd, prev, *me)\n     })\n }"}, {"sha": "a4e606f53c0c2215ca313185c2c082020f4c925d", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=b079ebeb8da4198112831af05c88b48974268337", "patch": "@@ -64,21 +64,22 @@ pub fn expand_deriving_from_primitive(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn cs_from(name: &str, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn cs_from(name: &str, cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let n = match substr.nonself_args {\n         [n] => n,\n-        _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(FromPrimitive)`\")\n+        _ => cx.span_bug(trait_span, \"Incorrect number of arguments in `deriving(FromPrimitive)`\")\n     };\n \n     match *substr.fields {\n         StaticStruct(..) => {\n-            cx.span_err(span, \"`FromPrimitive` cannot be derived for structs\");\n-            return cx.expr_fail(span, @\"\");\n+            cx.span_err(trait_span, \"`FromPrimitive` cannot be derived for structs\");\n+            return cx.expr_fail(trait_span, @\"\");\n         }\n         StaticEnum(enum_def, _) => {\n             if enum_def.variants.is_empty() {\n-                cx.span_err(span, \"`FromPrimitive` cannot be derived for enums with no variants\");\n-                return cx.expr_fail(span, @\"\");\n+                cx.span_err(trait_span,\n+                            \"`FromPrimitive` cannot be derived for enums with no variants\");\n+                return cx.expr_fail(trait_span, @\"\");\n             }\n \n             let mut arms = ~[];\n@@ -87,10 +88,12 @@ fn cs_from(name: &str, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr\n                 match variant.node.kind {\n                     ast::TupleVariantKind(ref args) => {\n                         if !args.is_empty() {\n-                            cx.span_err(span, \"`FromPrimitive` cannot be derived for \\\n-                                               enum variants with arguments\");\n-                            return cx.expr_fail(span, @\"\");\n+                            cx.span_err(trait_span,\n+                                        \"`FromPrimitive` cannot be derived for \\\n+                                        enum variants with arguments\");\n+                            return cx.expr_fail(trait_span, @\"\");\n                         }\n+                        let span = variant.span;\n \n                         // expr for `$n == $variant as $name`\n                         let variant = cx.expr_ident(span, variant.node.name);\n@@ -111,23 +114,24 @@ fn cs_from(name: &str, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr\n                         arms.push(arm);\n                     }\n                     ast::StructVariantKind(_) => {\n-                        cx.span_err(span, \"`FromPrimitive` cannot be derived for enums \\\n-                                           with struct variants\");\n-                        return cx.expr_fail(span, @\"\");\n+                        cx.span_err(trait_span,\n+                                    \"`FromPrimitive` cannot be derived for enums \\\n+                                    with struct variants\");\n+                        return cx.expr_fail(trait_span, @\"\");\n                     }\n                 }\n             }\n \n             // arm for `_ => None`\n             let arm = ast::Arm {\n-                pats: ~[cx.pat_wild(span)],\n+                pats: ~[cx.pat_wild(trait_span)],\n                 guard: None,\n-                body: cx.block_expr(cx.expr_none(span)),\n+                body: cx.block_expr(cx.expr_none(trait_span)),\n             };\n             arms.push(arm);\n \n-            cx.expr_match(span, n, arms)\n+            cx.expr_match(trait_span, n, arms)\n         }\n-        _ => cx.bug(\"expected StaticEnum in deriving(FromPrimitive)\")\n+        _ => cx.span_bug(trait_span, \"expected StaticEnum in deriving(FromPrimitive)\")\n     }\n }"}, {"sha": "a22822c2ddcc5cde3f560f93268cf0c875215f54", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=b079ebeb8da4198112831af05c88b48974268337", "patch": "@@ -50,7 +50,7 @@ pub fn expand_deriving_rand(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn rand_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn rand_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let rng = match substr.nonself_args {\n         [rng] => ~[ rng ],\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n@@ -69,89 +69,85 @@ fn rand_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n-            rand_thing(cx, span, substr.type_ident, summary, rand_call)\n+            rand_thing(cx, trait_span, substr.type_ident, summary, rand_call)\n         }\n         StaticEnum(_, ref variants) => {\n             if variants.is_empty() {\n-                cx.span_err(span, \"`Rand` cannot be derived for enums with no variants\");\n+                cx.span_err(trait_span, \"`Rand` cannot be derived for enums with no variants\");\n                 // let compilation continue\n-                return cx.expr_uint(span, 0);\n+                return cx.expr_uint(trait_span, 0);\n             }\n \n-            let variant_count = cx.expr_uint(span, variants.len());\n+            let variant_count = cx.expr_uint(trait_span, variants.len());\n \n-            let rand_name = cx.path_all(span,\n+            let rand_name = cx.path_all(trait_span,\n                                         true,\n                                         rand_ident.clone(),\n                                         opt_vec::Empty,\n                                         ~[]);\n             let rand_name = cx.expr_path(rand_name);\n \n             // ::std::rand::Rand::rand(rng)\n-            let rv_call = cx.expr_call(span,\n+            let rv_call = cx.expr_call(trait_span,\n                                        rand_name,\n                                        ~[ rng[0] ]);\n \n             // need to specify the uint-ness of the random number\n-            let uint_ty = cx.ty_ident(span, cx.ident_of(\"uint\"));\n+            let uint_ty = cx.ty_ident(trait_span, cx.ident_of(\"uint\"));\n             let value_ident = cx.ident_of(\"__value\");\n-            let let_statement = cx.stmt_let_typed(span,\n+            let let_statement = cx.stmt_let_typed(trait_span,\n                                                   false,\n                                                   value_ident,\n                                                   uint_ty,\n                                                   rv_call);\n \n             // rand() % variants.len()\n-            let value_ref = cx.expr_ident(span, value_ident);\n-            let rand_variant = cx.expr_binary(span,\n+            let value_ref = cx.expr_ident(trait_span, value_ident);\n+            let rand_variant = cx.expr_binary(trait_span,\n                                               ast::BiRem,\n                                               value_ref,\n                                               variant_count);\n \n-            let mut arms = variants.iter().enumerate().map(|(i, id_sum)| {\n-                let i_expr = cx.expr_uint(span, i);\n-                let pat = cx.pat_lit(span, i_expr);\n+            let mut arms = variants.iter().enumerate().map(|(i, &(ident, v_span, ref summary))| {\n+                let i_expr = cx.expr_uint(v_span, i);\n+                let pat = cx.pat_lit(v_span, i_expr);\n \n-                match *id_sum {\n-                    (ident, ref summary) => {\n-                        cx.arm(span,\n-                               ~[ pat ],\n-                               rand_thing(cx, span, ident, summary, |sp| rand_call(sp)))\n-                    }\n-                }\n+                cx.arm(v_span,\n+                       ~[ pat ],\n+                       rand_thing(cx, v_span, ident, summary, |sp| rand_call(sp)))\n             }).collect::<~[ast::Arm]>();\n \n             // _ => {} at the end. Should never occur\n-            arms.push(cx.arm_unreachable(span));\n+            arms.push(cx.arm_unreachable(trait_span));\n \n-            let match_expr = cx.expr_match(span, rand_variant, arms);\n+            let match_expr = cx.expr_match(trait_span, rand_variant, arms);\n \n-            let block = cx.block(span, ~[ let_statement ], Some(match_expr));\n+            let block = cx.block(trait_span, ~[ let_statement ], Some(match_expr));\n             cx.expr_block(block)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n     fn rand_thing(cx: &ExtCtxt,\n-                  span: Span,\n+                  trait_span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,\n                   rand_call: |Span| -> @Expr)\n                   -> @Expr {\n         match *summary {\n             Unnamed(ref fields) => {\n                 if fields.is_empty() {\n-                    cx.expr_ident(span, ctor_ident)\n+                    cx.expr_ident(trait_span, ctor_ident)\n                 } else {\n                     let exprs = fields.map(|span| rand_call(*span));\n-                    cx.expr_call_ident(span, ctor_ident, exprs)\n+                    cx.expr_call_ident(trait_span, ctor_ident, exprs)\n                 }\n             }\n             Named(ref fields) => {\n                 let rand_fields = fields.map(|&(ident, span)| {\n                     cx.field_imm(span, ident, rand_call(span))\n                 });\n-                cx.expr_struct_ident(span, ctor_ident, rand_fields)\n+                cx.expr_struct_ident(trait_span, ctor_ident, rand_fields)\n             }\n         }\n     }"}, {"sha": "dd99e8216200544f59d4158c71e5005cdd35a617", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b079ebeb8da4198112831af05c88b48974268337/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=b079ebeb8da4198112831af05c88b48974268337", "patch": "@@ -57,7 +57,7 @@ pub fn expand_deriving_zero(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn zero_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn zero_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let zero_ident = ~[\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),\n@@ -71,24 +71,24 @@ fn zero_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n             match *summary {\n                 Unnamed(ref fields) => {\n                     if fields.is_empty() {\n-                        cx.expr_ident(span, substr.type_ident)\n+                        cx.expr_ident(trait_span, substr.type_ident)\n                     } else {\n                         let exprs = fields.map(|sp| zero_call(*sp));\n-                        cx.expr_call_ident(span, substr.type_ident, exprs)\n+                        cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n                     }\n                 }\n                 Named(ref fields) => {\n                     let zero_fields = fields.map(|&(ident, span)| {\n                         cx.field_imm(span, ident, zero_call(span))\n                     });\n-                    cx.expr_struct_ident(span, substr.type_ident, zero_fields)\n+                    cx.expr_struct_ident(trait_span, substr.type_ident, zero_fields)\n                 }\n             }\n         }\n         StaticEnum(..) => {\n-            cx.span_err(span, \"`Zero` cannot be derived for enums, only structs\");\n+            cx.span_err(trait_span, \"`Zero` cannot be derived for enums, only structs\");\n             // let compilation continue\n-            cx.expr_uint(span, 0)\n+            cx.expr_uint(trait_span, 0)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Zero)`\")\n     };"}]}