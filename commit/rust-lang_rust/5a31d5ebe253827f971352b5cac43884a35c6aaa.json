{"sha": "5a31d5ebe253827f971352b5cac43884a35c6aaa", "node_id": "C_kwDOAAsO6NoAKDVhMzFkNWViZTI1MzgyN2Y5NzEzNTJiNWNhYzQzODg0YTM1YzZhYWE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-10T20:24:10Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-12T21:01:34Z"}, "message": "Implement dummy query responses and a jank instantiate", "tree": {"sha": "1dd7a2b7b16941aebab47d8a2c6629fe7fabff7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dd7a2b7b16941aebab47d8a2c6629fe7fabff7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a31d5ebe253827f971352b5cac43884a35c6aaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a31d5ebe253827f971352b5cac43884a35c6aaa", "html_url": "https://github.com/rust-lang/rust/commit/5a31d5ebe253827f971352b5cac43884a35c6aaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a31d5ebe253827f971352b5cac43884a35c6aaa/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bc3683b3275a5eb2ed13d24edcdcbc59afe5d70", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bc3683b3275a5eb2ed13d24edcdcbc59afe5d70", "html_url": "https://github.com/rust-lang/rust/commit/1bc3683b3275a5eb2ed13d24edcdcbc59afe5d70"}], "stats": {"total": 135, "additions": 97, "deletions": 38}, "files": [{"sha": "ba68da0686feaea3aa7c0c5fb845e27f3034eab8", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a31d5ebe253827f971352b5cac43884a35c6aaa/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a31d5ebe253827f971352b5cac43884a35c6aaa/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=5a31d5ebe253827f971352b5cac43884a35c6aaa", "patch": "@@ -2,8 +2,8 @@\n \n use super::infcx_ext::InferCtxtExt;\n use super::{\n-    fixme_instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty,\n-    EvalCtxt, Goal,\n+    instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty, EvalCtxt,\n+    Goal,\n };\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -121,11 +121,8 @@ impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n             // canonical wrt the caller.\n             for Candidate { source, result } in normalized_candidates {\n                 self.infcx.probe(|_| {\n-                    let candidate_certainty = fixme_instantiate_canonical_query_response(\n-                        &self.infcx,\n-                        &orig_values,\n-                        result,\n-                    );\n+                    let candidate_certainty =\n+                        instantiate_canonical_query_response(&self.infcx, &orig_values, result);\n \n                     // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n                     //"}, {"sha": "f1ee73a5b853f463ad9c77b2104a231bcabd3be2", "filename": "compiler/rustc_trait_selection/src/solve/cache.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5a31d5ebe253827f971352b5cac43884a35c6aaa/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a31d5ebe253827f971352b5cac43884a35c6aaa/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs?ref=5a31d5ebe253827f971352b5cac43884a35c6aaa", "patch": "@@ -9,11 +9,12 @@\n //! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n //! before then or if I still haven't done that before January 2023.\n use super::overflow::OverflowData;\n-use super::CanonicalGoal;\n+use super::{CanonicalGoal, Certainty, MaybeCause, Response};\n use super::{EvalCtxt, QueryResult};\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n+use rustc_middle::ty::{self, TyCtxt};\n use std::{cmp::Ordering, collections::hash_map::Entry};\n \n #[derive(Debug, Clone)]\n@@ -111,11 +112,11 @@ impl<'tcx> EvalCtxt<'tcx> {\n             // No entry, simply push this goal on the stack after dealing with overflow.\n             Entry::Vacant(v) => {\n                 if self.overflow_data.has_overflow(cache.stack.len()) {\n-                    return Err(self.deal_with_overflow());\n+                    return Err(self.deal_with_overflow(goal));\n                 }\n \n                 v.insert(ProvisionalEntry {\n-                    response: fixme_response_yes_no_constraints(),\n+                    response: response_no_constraints(self.tcx, goal, Certainty::Yes),\n                     depth: cache.stack.len(),\n                 });\n                 cache.stack.push(StackElem { goal, has_been_used: false });\n@@ -150,7 +151,11 @@ impl<'tcx> EvalCtxt<'tcx> {\n                 {\n                     Err(entry.response)\n                 } else {\n-                    Err(fixme_response_maybe_no_constraints())\n+                    Err(response_no_constraints(\n+                        self.tcx,\n+                        goal,\n+                        Certainty::Maybe(MaybeCause::Ambiguity),\n+                    ))\n                 }\n             }\n         }\n@@ -248,10 +253,39 @@ impl<'tcx> EvalCtxt<'tcx> {\n     }\n }\n \n-fn fixme_response_yes_no_constraints<'tcx>() -> QueryResult<'tcx> {\n-    unimplemented!()\n-}\n+pub(super) fn response_no_constraints<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    goal: Canonical<'tcx, impl Sized>,\n+    certainty: Certainty,\n+) -> QueryResult<'tcx> {\n+    let var_values = goal\n+        .variables\n+        .iter()\n+        .enumerate()\n+        .map(|(i, info)| match info.kind {\n+            CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => {\n+                tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i).into())).into()\n+            }\n+            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(i),\n+                    kind: ty::BrAnon(i as u32, None),\n+                };\n+                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n+            }\n+            CanonicalVarKind::Const(_, ty) | CanonicalVarKind::PlaceholderConst(_, ty) => tcx\n+                .mk_const(ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i)), ty)\n+                .into(),\n+        })\n+        .collect();\n \n-fn fixme_response_maybe_no_constraints<'tcx>() -> QueryResult<'tcx> {\n-    unimplemented!()\n+    Ok(Canonical {\n+        max_universe: goal.max_universe,\n+        variables: goal.variables,\n+        value: Response {\n+            var_values: CanonicalVarValues { var_values },\n+            external_constraints: Default::default(),\n+            certainty,\n+        },\n+    })\n }"}, {"sha": "dfc2b5ed32947d11a847fd64019b391bf9fc32af", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a31d5ebe253827f971352b5cac43884a35c6aaa/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a31d5ebe253827f971352b5cac43884a35c6aaa/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=5a31d5ebe253827f971352b5cac43884a35c6aaa", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n         let mut errors = Vec::new();\n         for i in 0.. {\n             if !infcx.tcx.recursion_limit().value_within_limit(i) {\n-                unimplemented!(\"overflow\")\n+                unimplemented!(\"overflowed on pending obligations: {:?}\", self.obligations);\n             }\n \n             let mut has_changed = false;"}, {"sha": "35bb68b6fce55f7f824a25977c919aa5acf9c31f", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5a31d5ebe253827f971352b5cac43884a35c6aaa/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a31d5ebe253827f971352b5cac43884a35c6aaa/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=5a31d5ebe253827f971352b5cac43884a35c6aaa", "patch": "@@ -19,15 +19,19 @@\n \n use std::mem;\n \n-use rustc_infer::infer::canonical::OriginalQueryValues;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n+use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n+use rustc_middle::infer::canonical::Certainty as OldCertainty;\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{RegionOutlivesPredicate, ToPredicate, TypeOutlivesPredicate};\n use rustc_span::DUMMY_SP;\n \n+use crate::traits::ObligationCause;\n+\n+use self::cache::response_no_constraints;\n use self::infcx_ext::InferCtxtExt;\n \n mod assembly;\n@@ -119,7 +123,7 @@ pub enum MaybeCause {\n }\n \n /// Additional constraints returned on success.\n-#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable)]\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable, Default)]\n pub struct ExternalConstraints<'tcx> {\n     // FIXME: implement this.\n     regions: (),\n@@ -175,7 +179,7 @@ impl<'tcx> EvalCtxt<'tcx> {\n         let canonical_response = self.evaluate_canonical_goal(canonical_goal)?;\n         Ok((\n             true, // FIXME: check whether `var_values` are an identity substitution.\n-            fixme_instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n+            instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n         ))\n     }\n \n@@ -208,6 +212,7 @@ impl<'tcx> EvalCtxt<'tcx> {\n         // of `PredicateKind` this is the case and it is and faster than instantiating and\n         // recanonicalizing.\n         let Goal { param_env, predicate } = canonical_goal.value;\n+\n         if let Some(kind) = predicate.kind().no_bound_vars() {\n             match kind {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => self.compute_trait_goal(\n@@ -234,7 +239,10 @@ impl<'tcx> EvalCtxt<'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(_)\n                 | ty::PredicateKind::ConstEquate(_, _)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(_)\n-                | ty::PredicateKind::Ambiguous => unimplemented!(),\n+                | ty::PredicateKind::Ambiguous => {\n+                    // FIXME\n+                    response_no_constraints(self.tcx, canonical_goal, Certainty::Yes)\n+                }\n             }\n         } else {\n             let (infcx, goal, var_values) =\n@@ -248,16 +256,18 @@ impl<'tcx> EvalCtxt<'tcx> {\n \n     fn compute_type_outlives_goal(\n         &mut self,\n-        _goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+        goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        todo!()\n+        // FIXME\n+        response_no_constraints(self.tcx, goal, Certainty::Yes)\n     }\n \n     fn compute_region_outlives_goal(\n         &mut self,\n-        _goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+        goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        todo!()\n+        // FIXME\n+        response_no_constraints(self.tcx, goal, Certainty::Yes)\n     }\n }\n \n@@ -300,10 +310,27 @@ impl<'tcx> EvalCtxt<'tcx> {\n     }\n }\n \n-fn fixme_instantiate_canonical_query_response<'tcx>(\n-    _: &InferCtxt<'tcx>,\n-    _: &OriginalQueryValues<'tcx>,\n-    _: CanonicalResponse<'tcx>,\n+fn instantiate_canonical_query_response<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    original_values: &OriginalQueryValues<'tcx>,\n+    response: CanonicalResponse<'tcx>,\n ) -> Certainty {\n-    unimplemented!()\n+    let Ok(InferOk { value, obligations }) = infcx\n+        .instantiate_query_response_and_region_obligations(\n+            &ObligationCause::dummy(),\n+            ty::ParamEnv::empty(),\n+            original_values,\n+            &response.unchecked_map(|resp| QueryResponse {\n+                var_values: resp.var_values,\n+                region_constraints: QueryRegionConstraints::default(),\n+                certainty: match resp.certainty {\n+                    Certainty::Yes => OldCertainty::Proven,\n+                    Certainty::Maybe(_) => OldCertainty::Ambiguous,\n+                },\n+                opaque_types: resp.external_constraints.opaque_types,\n+                value: resp.certainty,\n+            }),\n+        ) else { bug!(); };\n+    assert!(obligations.is_empty());\n+    value\n }"}, {"sha": "8bbb9f63e78682702ed9fdba111658e8e9ad3539", "filename": "compiler/rustc_trait_selection/src/solve/overflow.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a31d5ebe253827f971352b5cac43884a35c6aaa/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a31d5ebe253827f971352b5cac43884a35c6aaa/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs?ref=5a31d5ebe253827f971352b5cac43884a35c6aaa", "patch": "@@ -1,7 +1,9 @@\n+use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Limit;\n \n+use super::cache::response_no_constraints;\n use super::{Certainty, EvalCtxt, MaybeCause, QueryResult};\n \n /// When detecting a solver overflow, we return ambiguity. Overflow can be\n@@ -49,9 +51,12 @@ impl OverflowData {\n }\n \n impl<'tcx> EvalCtxt<'tcx> {\n-    pub(super) fn deal_with_overflow(&mut self) -> QueryResult<'tcx> {\n+    pub(super) fn deal_with_overflow(\n+        &mut self,\n+        goal: Canonical<'tcx, impl Sized>,\n+    ) -> QueryResult<'tcx> {\n         self.overflow_data.deal_with_overflow();\n-        fixme_response_overflow_no_constraints()\n+        response_no_constraints(self.tcx, goal, Certainty::Maybe(MaybeCause::Overflow))\n     }\n \n     /// A `while`-loop which tracks overflow.\n@@ -74,7 +79,3 @@ impl<'tcx> EvalCtxt<'tcx> {\n         Ok(Certainty::Maybe(MaybeCause::Overflow))\n     }\n }\n-\n-fn fixme_response_overflow_no_constraints<'tcx>() -> QueryResult<'tcx> {\n-    unimplemented!()\n-}"}]}