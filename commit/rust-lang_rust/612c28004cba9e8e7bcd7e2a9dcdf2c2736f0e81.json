{"sha": "612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMmMyODAwNGNiYTllOGU3YmNkN2UyYTlkY2RmMmMyNzM2ZjBlODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-27T04:02:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-27T04:02:05Z"}, "message": "Auto merge of #51598 - Pazzaz:master, r=sfackler\n\nOptimize sum of Durations by using custom function\n\nThe current `impl Sum for Duration` uses `fold` to perform several `add`s (or really `checked_add`s) of durations. In doing so, it has to guarantee the number of nanoseconds is valid after every addition. If you squeese the current implementation into a single function it looks kind of like this:\n````rust\nfn sum<I: Iterator<Item = Duration>>(iter: I) -> Duration {\n    let mut sum = Duration::new(0, 0);\n    for rhs in iter {\n        if let Some(mut secs) = sum.secs.checked_add(rhs.secs) {\n            let mut nanos = sum.nanos + rhs.nanos;\n            if nanos >= NANOS_PER_SEC {\n                nanos -= NANOS_PER_SEC;\n                if let Some(new_secs) = secs.checked_add(1) {\n                    secs = new_secs;\n                } else {\n                    panic!(\"overflow when adding durations\");\n                }\n            }\n            sum = Duration { secs, nanos }\n        } else {\n            panic!(\"overflow when adding durations\");\n        }\n    }\n    sum\n}\n````\nWe only need to check if `nanos` is in the correct range when giving our final answer so we can have a more optimized version like so:\n````rust\nfn sum<I: Iterator<Item = Duration>>(iter: I) -> Duration {\n    let mut total_secs: u64 = 0;\n    let mut total_nanos: u64 = 0;\n\n    for entry in iter {\n        total_secs = total_secs\n            .checked_add(entry.secs)\n            .expect(\"overflow in iter::sum over durations\");\n        total_nanos = match total_nanos.checked_add(entry.nanos as u64) {\n            Some(n) => n,\n            None => {\n                total_secs = total_secs\n                    .checked_add(total_nanos / NANOS_PER_SEC as u64)\n                    .expect(\"overflow in iter::sum over durations\");\n                (total_nanos % NANOS_PER_SEC as u64) + entry.nanos as u64\n            }\n        };\n    }\n    total_secs = total_secs\n        .checked_add(total_nanos / NANOS_PER_SEC as u64)\n        .expect(\"overflow in iter::sum over durations\");\n    total_nanos = total_nanos % NANOS_PER_SEC as u64;\n    Duration {\n        secs: total_secs,\n        nanos: total_nanos as u32,\n    }\n}\n````\nWe now only convert `total_nanos` to `total_secs` (1) if `total_nanos` overflows and (2) at the end of the function when we have to output a valid `Duration`. This gave a 5-22% performance improvement when I benchmarked it, depending on how big the `nano` value of the `Duration`s in `iter` were.", "tree": {"sha": "3ee5ea9aaf650a3e31fd6c52859bae1460f10d7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ee5ea9aaf650a3e31fd6c52859bae1460f10d7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81", "html_url": "https://github.com/rust-lang/rust/commit/612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6e2239a0718b230444f7f218add58db5732817a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e2239a0718b230444f7f218add58db5732817a", "html_url": "https://github.com/rust-lang/rust/commit/d6e2239a0718b230444f7f218add58db5732817a"}, {"sha": "d22ad76ca83acda1428829173451eee0221f685a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d22ad76ca83acda1428829173451eee0221f685a", "html_url": "https://github.com/rust-lang/rust/commit/d22ad76ca83acda1428829173451eee0221f685a"}], "stats": {"total": 48, "additions": 46, "deletions": 2}, "files": [{"sha": "466f28f0ef0aab4182b4b433cb03315724094266", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81", "patch": "@@ -161,6 +161,20 @@ fn checked_div() {\n     assert_eq!(Duration::new(2, 0).checked_div(0), None);\n }\n \n+#[test]\n+fn correct_sum() {\n+    let durations = [\n+        Duration::new(1, 999_999_999),\n+        Duration::new(2, 999_999_999),\n+        Duration::new(0, 999_999_999),\n+        Duration::new(0, 999_999_999),\n+        Duration::new(0, 999_999_999),\n+        Duration::new(5, 0),\n+    ];\n+    let sum = durations.iter().sum::<Duration>();\n+    assert_eq!(sum, Duration::new(1+2+5+4, 1_000_000_000 - 5));\n+}\n+\n #[test]\n fn debug_formatting_extreme_values() {\n     assert_eq!("}, {"sha": "25721b7fcecbb8f93a317df1f99ddf4dcb4548ba", "filename": "src/libcore/time.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81", "patch": "@@ -524,17 +524,47 @@ impl DivAssign<u32> for Duration {\n     }\n }\n \n+macro_rules! sum_durations {\n+    ($iter:expr) => {{\n+        let mut total_secs: u64 = 0;\n+        let mut total_nanos: u64 = 0;\n+\n+        for entry in $iter {\n+            total_secs = total_secs\n+                .checked_add(entry.secs)\n+                .expect(\"overflow in iter::sum over durations\");\n+            total_nanos = match total_nanos.checked_add(entry.nanos as u64) {\n+                Some(n) => n,\n+                None => {\n+                    total_secs = total_secs\n+                        .checked_add(total_nanos / NANOS_PER_SEC as u64)\n+                        .expect(\"overflow in iter::sum over durations\");\n+                    (total_nanos % NANOS_PER_SEC as u64) + entry.nanos as u64\n+                }\n+            };\n+        }\n+        total_secs = total_secs\n+            .checked_add(total_nanos / NANOS_PER_SEC as u64)\n+            .expect(\"overflow in iter::sum over durations\");\n+        total_nanos = total_nanos % NANOS_PER_SEC as u64;\n+        Duration {\n+            secs: total_secs,\n+            nanos: total_nanos as u32,\n+        }\n+    }};\n+}\n+\n #[stable(feature = \"duration_sum\", since = \"1.16.0\")]\n impl Sum for Duration {\n     fn sum<I: Iterator<Item=Duration>>(iter: I) -> Duration {\n-        iter.fold(Duration::new(0, 0), |a, b| a + b)\n+        sum_durations!(iter)\n     }\n }\n \n #[stable(feature = \"duration_sum\", since = \"1.16.0\")]\n impl<'a> Sum<&'a Duration> for Duration {\n     fn sum<I: Iterator<Item=&'a Duration>>(iter: I) -> Duration {\n-        iter.fold(Duration::new(0, 0), |a, b| a + *b)\n+        sum_durations!(iter)\n     }\n }\n "}]}