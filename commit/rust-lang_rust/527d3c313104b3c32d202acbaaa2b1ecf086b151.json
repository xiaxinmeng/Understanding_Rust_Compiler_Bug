{"sha": "527d3c313104b3c32d202acbaaa2b1ecf086b151", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyN2QzYzMxMzEwNGIzYzMyZDIwMmFjYmFhYTJiMWVjZjA4NmIxNTE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-05T11:15:08Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-05T11:15:08Z"}, "message": "Merge pull request #621 from Manishearth/double-ref\n\nLint on cloning double pointer", "tree": {"sha": "6a39ced90b68ada11a61ed024f9c9ecd78be2f88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a39ced90b68ada11a61ed024f9c9ecd78be2f88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/527d3c313104b3c32d202acbaaa2b1ecf086b151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/527d3c313104b3c32d202acbaaa2b1ecf086b151", "html_url": "https://github.com/rust-lang/rust/commit/527d3c313104b3c32d202acbaaa2b1ecf086b151", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/527d3c313104b3c32d202acbaaa2b1ecf086b151/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b90288ecedb7b9d17a5470339a73cf53dc561079", "url": "https://api.github.com/repos/rust-lang/rust/commits/b90288ecedb7b9d17a5470339a73cf53dc561079", "html_url": "https://github.com/rust-lang/rust/commit/b90288ecedb7b9d17a5470339a73cf53dc561079"}, {"sha": "8f7b8524d3a0491f668cbe92e19e101fef6bd2d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f7b8524d3a0491f668cbe92e19e101fef6bd2d0", "html_url": "https://github.com/rust-lang/rust/commit/8f7b8524d3a0491f668cbe92e19e101fef6bd2d0"}], "stats": {"total": 162, "additions": 95, "deletions": 67}, "files": [{"sha": "d6daa49c52138e4a3ac64cec0ea171be06040309", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/527d3c313104b3c32d202acbaaa2b1ecf086b151/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/527d3c313104b3c32d202acbaaa2b1ecf086b151/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=527d3c313104b3c32d202acbaaa2b1ecf086b151", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 109 lints included in this crate:\n+There are 110 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -23,6 +23,7 @@ name\n [cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                               | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n [char_lit_as_u8](https://github.com/Manishearth/rust-clippy/wiki#char_lit_as_u8)                               | warn    | Casting a character literal to u8\n [chars_next_cmp](https://github.com/Manishearth/rust-clippy/wiki#chars_next_cmp)                               | warn    | using `.chars().next()` to check if a string starts with a char\n+[clone_double_ref](https://github.com/Manishearth/rust-clippy/wiki#clone_double_ref)                           | warn    | using `clone` on `&&T`\n [clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#clone_on_copy)                                 | warn    | using `clone` on a `Copy` type\n [cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                             | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n [cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                         | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`"}, {"sha": "482472b6651de50e4415685c6282087c45fb30e0", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/527d3c313104b3c32d202acbaaa2b1ecf086b151/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527d3c313104b3c32d202acbaaa2b1ecf086b151/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=527d3c313104b3c32d202acbaaa2b1ecf086b151", "patch": "@@ -215,6 +215,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n         methods::CHARS_NEXT_CMP,\n+        methods::CLONE_DOUBLE_REF,\n         methods::CLONE_ON_COPY,\n         methods::EXTEND_FROM_SLICE,\n         methods::FILTER_NEXT,"}, {"sha": "61a910a65ab98b7303a1faddf8ac8c20acca0d2f", "filename": "src/methods.rs", "status": "modified", "additions": 81, "deletions": 65, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/527d3c313104b3c32d202acbaaa2b1ecf086b151/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527d3c313104b3c32d202acbaaa2b1ecf086b151/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=527d3c313104b3c32d202acbaaa2b1ecf086b151", "patch": "@@ -7,15 +7,11 @@ use std::borrow::Cow;\n use syntax::ptr::P;\n use syntax::codemap::Span;\n \n-use utils::{\n-    get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path,\n-    match_trait_method, match_type, method_chain_args, snippet, span_lint, span_lint_and_then,\n-    span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth,\n-};\n-use utils::{\n-    BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH, OPTION_PATH, RESULT_PATH,\n-    STRING_PATH, VEC_PATH,\n-};\n+use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path, match_trait_method,\n+            match_type, method_chain_args, snippet, snippet_opt, span_lint, span_lint_and_then, span_note_and_lint,\n+            walk_ptrs_ty, walk_ptrs_ty_depth};\n+use utils::{BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH, OPTION_PATH, RESULT_PATH, STRING_PATH,\n+            VEC_PATH,};\n use utils::MethodArgs;\n use rustc::middle::cstore::CrateStore;\n \n@@ -231,6 +227,26 @@ declare_lint!(pub EXTEND_FROM_SLICE, Warn,\n declare_lint!(pub CLONE_ON_COPY, Warn,\n               \"using `clone` on a `Copy` type\");\n \n+/// **What it does:** This lint warns on using `.clone()` on an `&&T`\n+///\n+/// **Why is this bad?** Cloning an `&&T` copies the inner `&T`, instead of cloning the underlying\n+/// `T`\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// fn main() {\n+///    let x = vec![1];\n+///    let y = &&x;\n+///    let z = y.clone();\n+///    println!(\"{:p} {:p}\",*y, z); // prints out the same pointer\n+/// }\n+/// ```\n+/// \n+declare_lint!(pub CLONE_DOUBLE_REF, Warn,\n+              \"using `clone` on `&&T`\");\n+\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(EXTEND_FROM_SLICE,\n@@ -246,7 +262,8 @@ impl LintPass for MethodsPass {\n                     OPTION_MAP_UNWRAP_OR_ELSE,\n                     OR_FUN_CALL,\n                     CHARS_NEXT_CMP,\n-                    CLONE_ON_COPY)\n+                    CLONE_ON_COPY,\n+                    CLONE_DOUBLE_REF)\n     }\n }\n \n@@ -280,9 +297,11 @@ impl LateLintPass for MethodsPass {\n                 } else if let Some(arglists) = method_chain_args(expr, &[\"extend\"]) {\n                     lint_extend(cx, expr, arglists[0]);\n                 }\n-\n                 lint_or_fun_call(cx, expr, &name.node.as_str(), &args);\n-                lint_clone_on_copy(cx, expr, &name.node.as_str(), &args);\n+                if args.len() == 1 && name.node.as_str() == \"clone\" {\n+                    lint_clone_on_copy(cx, expr);\n+                    lint_clone_double_ref(cx, expr, &args[0]);\n+                }\n             }\n             ExprBinary(op, ref lhs, ref rhs) if op.node == BiEq || op.node == BiNe => {\n                 if !lint_chars_next(cx, expr, lhs, rhs, op.node == BiEq) {\n@@ -348,15 +367,9 @@ impl LateLintPass for MethodsPass {\n /// Checks for the `OR_FUN_CALL` lint.\n fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>]) {\n     /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n-    fn check_unwrap_or_default(\n-        cx: &LateContext,\n-        name: &str,\n-        fun: &Expr,\n-        self_expr: &Expr,\n-        arg: &Expr,\n-        or_has_args: bool,\n-        span: Span\n-    ) -> bool {\n+    fn check_unwrap_or_default(cx: &LateContext, name: &str, fun: &Expr, self_expr: &Expr, arg: &Expr,\n+                               or_has_args: bool, span: Span)\n+                               -> bool {\n         if or_has_args {\n             return false;\n         }\n@@ -379,11 +392,13 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n                     };\n \n                     if implements_trait(cx, arg_ty, default_trait_id, None) {\n-                        span_lint(cx, OR_FUN_CALL, span,\n+                        span_lint(cx,\n+                                  OR_FUN_CALL,\n+                                  span,\n                                   &format!(\"use of `{}` followed by a call to `{}`\", name, path))\n-                            .span_suggestion(span, \"try this\",\n-                                             format!(\"{}.unwrap_or_default()\",\n-                                                     snippet(cx, self_expr.span, \"_\")));\n+                            .span_suggestion(span,\n+                                             \"try this\",\n+                                             format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")));\n                         return true;\n                     }\n                 }\n@@ -394,34 +409,25 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n     }\n \n     /// Check for `*or(foo())`.\n-    fn check_general_case(\n-        cx: &LateContext,\n-        name: &str,\n-        fun: &Expr,\n-        self_expr: &Expr,\n-        arg: &Expr,\n-        or_has_args: bool,\n-        span: Span\n-    ) {\n+    fn check_general_case(cx: &LateContext, name: &str, fun: &Expr, self_expr: &Expr, arg: &Expr, or_has_args: bool,\n+                          span: Span) {\n         // (path, fn_has_argument, methods)\n-        let know_types : &[(&[_], _, &[_], _)] = &[\n-            (&BTREEMAP_ENTRY_PATH, false, &[\"or_insert\"], \"with\"),\n-            (&HASHMAP_ENTRY_PATH, false, &[\"or_insert\"], \"with\"),\n-            (&OPTION_PATH, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n-            (&RESULT_PATH, true, &[\"or\", \"unwrap_or\"], \"else\"),\n-        ];\n+        let know_types: &[(&[_], _, &[_], _)] = &[(&BTREEMAP_ENTRY_PATH, false, &[\"or_insert\"], \"with\"),\n+                                                  (&HASHMAP_ENTRY_PATH, false, &[\"or_insert\"], \"with\"),\n+                                                  (&OPTION_PATH,\n+                                                   false,\n+                                                   &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"],\n+                                                   \"else\"),\n+                                                  (&RESULT_PATH, true, &[\"or\", \"unwrap_or\"], \"else\")];\n \n         let self_ty = cx.tcx.expr_ty(self_expr);\n \n-        let (fn_has_arguments, poss, suffix) =\n-            if let Some(&(_, fn_has_arguments, poss, suffix)) = know_types.iter().find(|&&i| {\n-                match_type(cx, self_ty, i.0)\n-            }) {\n-                (fn_has_arguments, poss, suffix)\n-            }\n-            else {\n-                return\n-            };\n+        let (fn_has_arguments, poss, suffix) = if let Some(&(_, fn_has_arguments, poss, suffix)) =\n+                                                      know_types.iter().find(|&&i| match_type(cx, self_ty, i.0)) {\n+            (fn_has_arguments, poss, suffix)\n+        } else {\n+            return;\n+        };\n \n         if !poss.contains(&name) {\n             return;\n@@ -433,14 +439,10 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n             (false, true) => format!(\"{}\", snippet(cx, fun.span, \"..\")),\n         };\n \n-        span_lint(cx, OR_FUN_CALL, span,\n-                  &format!(\"use of `{}` followed by a function call\", name))\n-            .span_suggestion(span, \"try this\",\n-                             format!(\"{}.{}_{}({})\",\n-                                     snippet(cx, self_expr.span, \"_\"),\n-                                     name,\n-                                     suffix,\n-                                     sugg));\n+        span_lint(cx, OR_FUN_CALL, span, &format!(\"use of `{}` followed by a function call\", name))\n+            .span_suggestion(span,\n+                             \"try this\",\n+                             format!(\"{}.{}_{}({})\", snippet(cx, self_expr.span, \"_\"), name, suffix, sugg));\n     }\n \n     if args.len() == 2 {\n@@ -454,14 +456,28 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n }\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>]) {\n-    if args.len() == 1 && name == \"clone\" {\n-        let ty = cx.tcx.expr_ty(expr);\n-        let parent = cx.tcx.map.get_parent(expr.id);\n-        let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, parent);\n-\n-        if !ty.moves_by_default(&parameter_environment, expr.span) {\n-            span_lint(cx, CLONE_ON_COPY, expr.span, \"using `clone` on a `Copy` type\");\n+fn lint_clone_on_copy(cx: &LateContext, expr: &Expr) {\n+    let ty = cx.tcx.expr_ty(expr);\n+    let parent = cx.tcx.map.get_parent(expr.id);\n+    let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, parent);\n+\n+    if !ty.moves_by_default(&parameter_environment, expr.span) {\n+        span_lint(cx, CLONE_ON_COPY, expr.span, \"using `clone` on a `Copy` type\");\n+    }\n+}\n+\n+/// Checks for the `CLONE_DOUBLE_REF` lint.\n+fn lint_clone_double_ref(cx: &LateContext, expr: &Expr, arg: &Expr) {\n+    let ty = cx.tcx.expr_ty(arg);\n+    if let ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) = ty.sty {\n+        if let ty::TyRef(..) = inner.sty {\n+            let mut db = span_lint(cx, CLONE_DOUBLE_REF, expr.span,\n+                                   \"using `clone` on a double-reference; \\\n+                                    this will copy the reference instead of cloning \\\n+                                    the inner type\");\n+            if let Some(snip) = snippet_opt(cx, arg.span) {\n+                db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"(*{}).clone()\", snip));\n+            }\n         }\n     }\n }"}, {"sha": "4e515c2aa1259ea3ed00e747066a9b7d356b9cf1", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/527d3c313104b3c32d202acbaaa2b1ecf086b151/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527d3c313104b3c32d202acbaaa2b1ecf086b151/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=527d3c313104b3c32d202acbaaa2b1ecf086b151", "patch": "@@ -1,8 +1,8 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n-#![allow(unused)]\n #![deny(clippy, clippy_pedantic)]\n+#![allow(unused, print_stdout)]\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;\n@@ -334,3 +334,13 @@ fn clone_on_copy_generic<T: Copy>(t: T) {\n     t.clone(); //~ERROR using `clone` on a `Copy` type\n     Some(t).clone(); //~ERROR using `clone` on a `Copy` type\n }\n+\n+fn clone_on_double_ref() {\n+    let x = vec![1];\n+    let y = &&x;\n+    let z: &Vec<_> = y.clone(); //~ERROR using `clone` on a double\n+                                //~| HELP try dereferencing it\n+                                //~| SUGGESTION let z: &Vec<_> = (*y).clone();\n+                                //~^^^ERROR using `clone` on a `Copy` type\n+    println!(\"{:p} {:p}\",*y, z);\n+}"}]}