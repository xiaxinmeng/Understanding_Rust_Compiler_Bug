{"sha": "8770d0f34a9bee2691517ab95803a277c453dfda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NzBkMGYzNGE5YmVlMjY5MTUxN2FiOTU4MDNhMjc3YzQ1M2RmZGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-21T12:11:54Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-31T23:43:38Z"}, "message": "remove VerifyRegSubReg and cleanup region infer\n\nWe used to make region->region edges part of the verify set, but this\nchange stores them like other edges, as a full-fledged constraint.\nBesides making the code somewhat cleaner, this allows them to be more\neasily dropped as part of `pop_skolemized`. This change also refactors\nthe code a bit to remove some intermediate data structures that are no\nlonger particular useful (e.g., VarValue).", "tree": {"sha": "ea4ae7998e793ff747009416a8a85eb19a3fa9ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea4ae7998e793ff747009416a8a85eb19a3fa9ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8770d0f34a9bee2691517ab95803a277c453dfda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8770d0f34a9bee2691517ab95803a277c453dfda", "html_url": "https://github.com/rust-lang/rust/commit/8770d0f34a9bee2691517ab95803a277c453dfda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8770d0f34a9bee2691517ab95803a277c453dfda/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cacbb2147f709c634ed4c025f89f9c02e106fe33", "url": "https://api.github.com/repos/rust-lang/rust/commits/cacbb2147f709c634ed4c025f89f9c02e106fe33", "html_url": "https://github.com/rust-lang/rust/commit/cacbb2147f709c634ed4c025f89f9c02e106fe33"}], "stats": {"total": 275, "additions": 132, "deletions": 143}, "files": [{"sha": "905ad7c0faa236c45e18c6eb5d03cc64e3663441", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8770d0f34a9bee2691517ab95803a277c453dfda/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8770d0f34a9bee2691517ab95803a277c453dfda/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=8770d0f34a9bee2691517ab95803a277c453dfda", "patch": "@@ -213,8 +213,12 @@ fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n     match *c {\n         Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n             (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n-        Constraint::ConstrainRegSubVar(r_1, rv_2) => (Node::Region(r_1), Node::RegionVid(rv_2)),\n-        Constraint::ConstrainVarSubReg(rv_1, r_2) => (Node::RegionVid(rv_1), Node::Region(r_2)),\n+        Constraint::ConstrainRegSubVar(r_1, rv_2) =>\n+            (Node::Region(r_1), Node::RegionVid(rv_2)),\n+        Constraint::ConstrainVarSubReg(rv_1, r_2) =>\n+            (Node::RegionVid(rv_1), Node::Region(r_2)),\n+        Constraint::ConstrainRegSubReg(r_1, r_2) =>\n+            (Node::Region(r_1), Node::Region(r_2)),\n     }\n }\n "}, {"sha": "2211a565a325f215a2af2ca7ead346fc61d0f6dc", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 126, "deletions": 141, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/8770d0f34a9bee2691517ab95803a277c453dfda/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8770d0f34a9bee2691517ab95803a277c453dfda/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=8770d0f34a9bee2691517ab95803a277c453dfda", "patch": "@@ -11,7 +11,6 @@\n //! See README.md\n \n pub use self::Constraint::*;\n-pub use self::Verify::*;\n pub use self::UndoLogEntry::*;\n pub use self::CombineMapType::*;\n pub use self::RegionResolutionError::*;\n@@ -47,25 +46,28 @@ pub enum Constraint {\n     // Concrete region is subregion of region variable\n     ConstrainRegSubVar(Region, RegionVid),\n \n-    // Region variable is subregion of concrete region\n-    //\n-    // FIXME(#29436) -- should be remove in favor of a Verify\n+    // Region variable is subregion of concrete region. This does not\n+    // directly affect inference, but instead is checked after\n+    // inference is complete.\n     ConstrainVarSubReg(RegionVid, Region),\n+\n+    // A constraint where neither side is a variable. This does not\n+    // directly affect inference, but instead is checked after\n+    // inference is complete.\n+    ConstrainRegSubReg(Region, Region),\n }\n \n-// Something we have to verify after region inference is done, but\n-// which does not directly influence the inference process\n-pub enum Verify<'tcx> {\n-    // VerifyRegSubReg(a, b): Verify that `a <= b`. Neither `a` nor\n-    // `b` are inference variables.\n-    VerifyRegSubReg(SubregionOrigin<'tcx>, Region, Region),\n-\n-    // VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n-    // associated type) must outlive the region `R`. `T` is known to\n-    // outlive `RS`. Therefore verify that `R <= RS[i]` for some\n-    // `i`. Inference variables may be involved (but this verification\n-    // step doesn't influence inference).\n-    VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, VerifyBound),\n+// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+// associated type) must outlive the region `R`. `T` is known to\n+// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+// `i`. Inference variables may be involved (but this verification\n+// step doesn't influence inference).\n+#[derive(Debug)]\n+pub struct Verify<'tcx> {\n+    kind: GenericKind<'tcx>,\n+    origin: SubregionOrigin<'tcx>,\n+    region: Region,\n+    bound: VerifyBound,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -336,20 +338,16 @@ impl TaintSet {\n                     &AddConstraint(ConstrainVarSubReg(a, b)) => {\n                         self.add_edge(ReVar(a), b);\n                     }\n+                    &AddConstraint(ConstrainRegSubReg(a, b)) => {\n+                        self.add_edge(a, b);\n+                    }\n                     &AddGiven(a, b) => {\n                         self.add_edge(ReFree(a), ReVar(b));\n                     }\n                     &AddVerify(i) => {\n-                        match verifys[i] {\n-                            VerifyRegSubReg(_, a, b) => {\n-                                self.add_edge(a, b);\n-                            }\n-                            VerifyGenericBound(_, _, a, ref bound) => {\n-                                bound.for_each_region(&mut |b| {\n-                                    self.add_edge(a, b);\n-                                });\n-                            }\n-                        }\n+                        verifys[i].bound.for_each_region(&mut |b| {\n+                            self.add_edge(verifys[i].region, b);\n+                        });\n                     }\n                     &Purged |\n                     &AddCombination(..) |\n@@ -609,6 +607,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                     skols.contains(&a),\n                 &AddConstraint(ConstrainVarSubReg(_, b)) =>\n                     skols.contains(&b),\n+                &AddConstraint(ConstrainRegSubReg(a, b)) =>\n+                    skols.contains(&a) || skols.contains(&b),\n                 &AddGiven(_, _) =>\n                     false,\n                 &AddVerify(_) =>\n@@ -679,11 +679,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         debug!(\"RegionVarBindings: add_verify({:?})\", verify);\n \n         // skip no-op cases known to be satisfied\n-        match verify {\n-            VerifyGenericBound(_, _, _, VerifyBound::AllBounds(ref bs)) if bs.len() == 0 => {\n-                return;\n-            }\n-            _ => {}\n+        match verify.bound {\n+            VerifyBound::AllBounds(ref bs) if bs.len() == 0 => { return; }\n+            _ => { }\n         }\n \n         let mut verifys = self.verifys.borrow_mut();\n@@ -751,7 +749,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n             }\n             _ => {\n-                self.add_verify(VerifyRegSubReg(origin, sub, sup));\n+                self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n             }\n         }\n     }\n@@ -762,7 +760,12 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                                 kind: GenericKind<'tcx>,\n                                 sub: Region,\n                                 bound: VerifyBound) {\n-        self.add_verify(VerifyGenericBound(kind, origin, sub, bound));\n+        self.add_verify(Verify {\n+            kind: kind,\n+            origin: origin,\n+            region: sub,\n+            bound: bound\n+        });\n     }\n \n     pub fn lub_regions(&self, origin: SubregionOrigin<'tcx>, a: Region, b: Region) -> Region {\n@@ -988,10 +991,6 @@ pub enum VarValue {\n     ErrorValue,\n }\n \n-struct VarData {\n-    value: VarValue,\n-}\n-\n struct RegionAndOrigin<'tcx> {\n     region: Region,\n     origin: SubregionOrigin<'tcx>,\n@@ -1017,18 +1016,14 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n         self.expansion(free_regions, &mut var_data);\n-        self.contraction(free_regions, &mut var_data);\n-        let values = self.extract_values_and_collect_conflicts(free_regions,\n-                                                               &var_data,\n-                                                               &graph,\n-                                                               errors);\n-        self.collect_concrete_region_errors(free_regions, &values, errors);\n-        values\n+        self.collect_errors(free_regions, &mut var_data, errors);\n+        self.collect_var_errors(free_regions, &var_data, &graph, errors);\n+        var_data\n     }\n \n-    fn construct_var_data(&self) -> Vec<VarData> {\n+    fn construct_var_data(&self) -> Vec<VarValue> {\n         (0..self.num_vars() as usize)\n-            .map(|_| VarData { value: Value(ty::ReEmpty) })\n+            .map(|_| Value(ty::ReEmpty))\n             .collect()\n     }\n \n@@ -1065,30 +1060,28 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn expansion(&self, free_regions: &FreeRegionMap, var_data: &mut [VarData]) {\n-        self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n+    fn expansion(&self, free_regions: &FreeRegionMap, var_values: &mut [VarValue]) {\n+        self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\",\n-                   constraint,\n-                   self.constraints\n-                       .borrow()\n-                       .get(constraint)\n-                       .unwrap());\n+                   constraint, origin);\n             match *constraint {\n                 ConstrainRegSubVar(a_region, b_vid) => {\n-                    let b_data = &mut var_data[b_vid.index as usize];\n+                    let b_data = &mut var_values[b_vid.index as usize];\n                     self.expand_node(free_regions, a_region, b_vid, b_data)\n                 }\n                 ConstrainVarSubVar(a_vid, b_vid) => {\n-                    match var_data[a_vid.index as usize].value {\n+                    match var_values[a_vid.index as usize] {\n                         ErrorValue => false,\n                         Value(a_region) => {\n-                            let b_node = &mut var_data[b_vid.index as usize];\n+                            let b_node = &mut var_values[b_vid.index as usize];\n                             self.expand_node(free_regions, a_region, b_vid, b_node)\n                         }\n                     }\n                 }\n+                ConstrainRegSubReg(..) |\n                 ConstrainVarSubReg(..) => {\n-                    // This is a contraction constraint.  Ignore it.\n+                    // These constraints are checked after expansion\n+                    // is done, in `collect_errors`.\n                     false\n                 }\n             }\n@@ -1099,12 +1092,12 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                    free_regions: &FreeRegionMap,\n                    a_region: Region,\n                    b_vid: RegionVid,\n-                   b_data: &mut VarData)\n+                   b_data: &mut VarValue)\n                    -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\",\n                a_region,\n                b_vid,\n-               b_data.value);\n+               b_data);\n \n         // Check if this relationship is implied by a given.\n         match a_region {\n@@ -1117,7 +1110,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        match b_data.value {\n+        match *b_data {\n             Value(cur_region) => {\n                 let lub = self.lub_concrete_regions(free_regions, a_region, cur_region);\n                 if lub == cur_region {\n@@ -1129,7 +1122,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                        cur_region,\n                        lub);\n \n-                b_data.value = Value(lub);\n+                *b_data = Value(lub);\n                 return true;\n             }\n \n@@ -1139,94 +1132,92 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // FIXME(#29436) -- this fn would just go away if we removed ConstrainVarSubReg\n-    fn contraction(&self, free_regions: &FreeRegionMap, var_data: &mut [VarData]) {\n-        self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n-            debug!(\"contraction: constraint={:?} origin={:?}\",\n-                   constraint,\n-                   self.constraints\n-                       .borrow()\n-                       .get(constraint)\n-                       .unwrap());\n+    /// After expansion is complete, go and check upper bounds (i.e.,\n+    /// cases where the region cannot grow larger than a fixed point)\n+    /// and check that they are satisfied.\n+    fn collect_errors(&self,\n+                      free_regions: &FreeRegionMap,\n+                      var_data: &mut Vec<VarValue>,\n+                      errors: &mut Vec<RegionResolutionError<'tcx>>) {\n+        let constraints = self.constraints.borrow();\n+        for (constraint, origin) in constraints.iter() {\n+            debug!(\"collect_errors: constraint={:?} origin={:?}\",\n+                   constraint, origin);\n             match *constraint {\n                 ConstrainRegSubVar(..) |\n                 ConstrainVarSubVar(..) => {\n                     // Expansion will ensure that these constraints hold. Ignore.\n                 }\n+\n+                ConstrainRegSubReg(sub, sup) => {\n+                    if free_regions.is_subregion_of(self.tcx, sub, sup) {\n+                        continue;\n+                    }\n+\n+                    debug!(\"collect_errors: region error at {:?}: \\\n+                            cannot verify that {:?} <= {:?}\",\n+                           origin,\n+                           sub,\n+                           sup);\n+\n+                    errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n+                }\n+\n                 ConstrainVarSubReg(a_vid, b_region) => {\n                     let a_data = &mut var_data[a_vid.index as usize];\n                     debug!(\"contraction: {:?} == {:?}, {:?}\",\n                            a_vid,\n-                           a_data.value,\n+                           a_data,\n                            b_region);\n \n-                    let a_region = match a_data.value {\n-                        ErrorValue => return false,\n+                    let a_region = match *a_data {\n+                        ErrorValue => continue,\n                         Value(a_region) => a_region,\n                     };\n \n+                    // Do not report these errors immediately:\n+                    // instead, set the variable value to error and\n+                    // collect them later.\n                     if !free_regions.is_subregion_of(self.tcx, a_region, b_region) {\n-                        debug!(\"Setting {:?} to ErrorValue: {:?} not subregion of {:?}\",\n+                        debug!(\"collect_errors: region error at {:?}: \\\n+                                cannot verify that {:?}={:?} <= {:?}\",\n+                               origin,\n                                a_vid,\n                                a_region,\n                                b_region);\n-                        a_data.value = ErrorValue;\n+                        *a_data = ErrorValue;\n                     }\n                 }\n             }\n+        }\n \n-            false\n-        })\n-    }\n-\n-    fn collect_concrete_region_errors(&self,\n-                                      free_regions: &FreeRegionMap,\n-                                      values: &Vec<VarValue>,\n-                                      errors: &mut Vec<RegionResolutionError<'tcx>>) {\n-        let mut reg_reg_dups = FnvHashSet();\n         for verify in self.verifys.borrow().iter() {\n-            match *verify {\n-                VerifyRegSubReg(ref origin, sub, sup) => {\n-                    if free_regions.is_subregion_of(self.tcx, sub, sup) {\n-                        continue;\n-                    }\n-\n-                    if !reg_reg_dups.insert((sub, sup)) {\n-                        continue;\n-                    }\n-\n-                    debug!(\"region inference error at {:?}: {:?} <= {:?} is not true\",\n-                           origin,\n-                           sub,\n-                           sup);\n-\n-                    errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n-                }\n+            debug!(\"collect_errors: verify={:?}\", verify);\n+            let sub = normalize(var_data, verify.region);\n+            if verify.bound.is_met(self.tcx, free_regions, var_data, sub) {\n+                continue;\n+            }\n \n-                VerifyGenericBound(ref kind, ref origin, sub, ref bound) => {\n-                    let sub = normalize(values, sub);\n-                    if bound.is_met(self.tcx, free_regions, values, sub) {\n-                        continue;\n-                    }\n+            debug!(\"collect_errors: region error at {:?}: \\\n+                    cannot verify that {:?} <= {:?}\",\n+                   verify.origin,\n+                   verify.region,\n+                   verify.bound);\n \n-                    debug!(\"region inference error at {:?}: verifying {:?} <= {:?}\",\n-                           origin,\n-                           sub,\n-                           bound);\n-\n-                    errors.push(GenericBoundFailure((*origin).clone(), kind.clone(), sub));\n-                }\n-            }\n+            errors.push(GenericBoundFailure(verify.origin.clone(),\n+                                            verify.kind.clone(),\n+                                            sub));\n         }\n     }\n \n-    fn extract_values_and_collect_conflicts(&self,\n-                                            free_regions: &FreeRegionMap,\n-                                            var_data: &[VarData],\n-                                            graph: &RegionGraph,\n-                                            errors: &mut Vec<RegionResolutionError<'tcx>>)\n-                                            -> Vec<VarValue> {\n-        debug!(\"extract_values_and_collect_conflicts()\");\n+    /// Go over the variables that were declared to be error variables\n+    /// and create a `RegionResolutionError` for each of them.\n+    fn collect_var_errors(&self,\n+                          free_regions: &FreeRegionMap,\n+                          var_data: &[VarValue],\n+                          graph: &RegionGraph,\n+                          errors: &mut Vec<RegionResolutionError<'tcx>>) {\n+        debug!(\"collect_var_errors\");\n \n         // This is the best way that I have found to suppress\n         // duplicate and related errors. Basically we keep a set of\n@@ -1242,7 +1233,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         let mut dup_vec = vec![u32::MAX; self.num_vars() as usize];\n \n         for idx in 0..self.num_vars() as usize {\n-            match var_data[idx].value {\n+            match var_data[idx] {\n                 Value(_) => {\n                     /* Inference successful */\n                 }\n@@ -1279,8 +1270,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 }\n             }\n         }\n-\n-        (0..self.num_vars() as usize).map(|idx| var_data[idx].value).collect()\n     }\n \n     fn construct_graph(&self) -> RegionGraph {\n@@ -1315,6 +1304,10 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 ConstrainVarSubReg(a_id, _) => {\n                     graph.add_edge(NodeIndex(a_id.index as usize), dummy_sink, *constraint);\n                 }\n+                ConstrainRegSubReg(..) => {\n+                    // this would be an edge from `dummy_source` to\n+                    // `dummy_sink`; just ignore it.\n+                }\n             }\n         }\n \n@@ -1457,22 +1450,27 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                             origin: this.constraints.borrow().get(&edge.data).unwrap().clone(),\n                         });\n                     }\n+\n+                    ConstrainRegSubReg(..) => {\n+                        panic!(\"cannot reach reg-sub-reg edge in region inference \\\n+                                post-processing\")\n+                    }\n                 }\n             }\n         }\n     }\n \n     fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-        where F: FnMut(&Constraint) -> bool\n+        where F: FnMut(&Constraint, &SubregionOrigin<'tcx>) -> bool\n     {\n         let mut iteration = 0;\n         let mut changed = true;\n         while changed {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            for (constraint, _) in self.constraints.borrow().iter() {\n-                let edge_changed = body(constraint);\n+            for (constraint, origin) in self.constraints.borrow().iter() {\n+                let edge_changed = body(constraint, origin);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {:?}\", constraint);\n                     changed = true;\n@@ -1484,19 +1482,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n }\n \n-impl<'tcx> fmt::Debug for Verify<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            VerifyRegSubReg(_, ref a, ref b) => {\n-                write!(f, \"VerifyRegSubReg({:?}, {:?})\", a, b)\n-            }\n-            VerifyGenericBound(_, ref p, ref a, ref bs) => {\n-                write!(f, \"VerifyGenericBound({:?}, {:?}, {:?})\", p, a, bs)\n-            }\n-        }\n-    }\n-}\n-\n fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n     match r {\n         ty::ReVar(rid) => lookup(values, rid),"}]}