{"sha": "868d10160f81c9d836202ed1c0683b75730fe73d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OGQxMDE2MGY4MWM5ZDgzNjIwMmVkMWMwNjgzYjc1NzMwZmU3M2Q=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-09-28T00:05:13Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-09-28T00:05:13Z"}, "message": "Put function argument last in sort function. Fixes #3265.", "tree": {"sha": "c2959717ffb02907a1cfe6cd559d54a396ad8cb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2959717ffb02907a1cfe6cd559d54a396ad8cb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/868d10160f81c9d836202ed1c0683b75730fe73d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/868d10160f81c9d836202ed1c0683b75730fe73d", "html_url": "https://github.com/rust-lang/rust/commit/868d10160f81c9d836202ed1c0683b75730fe73d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/868d10160f81c9d836202ed1c0683b75730fe73d/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f98f00f7f6afac993fd2a08e7135bfdb8e70dec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f98f00f7f6afac993fd2a08e7135bfdb8e70dec6", "html_url": "https://github.com/rust-lang/rust/commit/f98f00f7f6afac993fd2a08e7135bfdb8e70dec6"}], "stats": {"total": 74, "additions": 42, "deletions": 32}, "files": [{"sha": "a9fa6ca899c6b8cd0741871cc1418999f9eed047", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=868d10160f81c9d836202ed1c0683b75730fe73d", "patch": "@@ -1498,7 +1498,7 @@ fn print_pkg(s: source, p: package) {\n fn print_source(s: source) {\n     info(s.name + ~\" (\" + s.url + ~\")\");\n \n-    let pks = sort::merge_sort(sys::shape_lt, s.packages.get());\n+    let pks = sort::merge_sort(s.packages.get(), sys::shape_lt);\n     let l = vec::len(pks);\n \n     print(io::with_str_writer(|writer| {"}, {"sha": "0094b5a92773b8e0a80db8f9e6812f0158f49463", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=868d10160f81c9d836202ed1c0683b75730fe73d", "patch": "@@ -145,7 +145,7 @@ fn to_writer_pretty(wr: io::Writer, j: Json, indent: uint) {\n         }\n \n         // sort by key strings\n-        let sorted_pairs = sort::merge_sort(|a,b| *a <= *b, pairs);\n+        let sorted_pairs = do sort::merge_sort(pairs) |a,b| { *a <= *b };\n \n         // {\n         wr.write_str(~\"{\\n\");"}, {"sha": "e0e35f68da2682b5027b10b4d758bc00239e8f9b", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=868d10160f81c9d836202ed1c0683b75730fe73d", "patch": "@@ -20,12 +20,12 @@ type Le<T> = pure fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n+fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n-    return merge_sort_(le, v, (0u, len(v)));\n+    return merge_sort_(v, (0u, len(v)), le);\n \n-    fn merge_sort_<T: Copy>(le: Le<T>, v: &[const T], slice: Slice)\n+    fn merge_sort_<T: Copy>(v: &[const T], slice: Slice, le: Le<T>)\n         -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n@@ -37,7 +37,7 @@ fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n         let mid = v_len / 2u + begin;\n         let a = (begin, mid);\n         let b = (mid, end);\n-        return merge(le, merge_sort_(le, v, a), merge_sort_(le, v, b));\n+        return merge(le, merge_sort_(v, a, le), merge_sort_(v, b, le));\n     }\n \n     fn merge<T: Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n@@ -58,8 +58,8 @@ fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n     }\n }\n \n-fn part<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n-                right: uint, pivot: uint) -> uint {\n+fn part<T: Copy>(arr: &[mut T], left: uint,\n+                right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n     let mut storage_index: uint = left;\n@@ -75,16 +75,16 @@ fn part<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n     return storage_index;\n }\n \n-fn qsort<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n-             right: uint) {\n+fn qsort<T: Copy>(arr: &[mut T], left: uint,\n+             right: uint, compare_func: Le<T>) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n-        let new_pivot = part::<T>(compare_func, arr, left, right, pivot);\n+        let new_pivot = part::<T>(arr, left, right, pivot, compare_func);\n         if new_pivot != 0u {\n             // Need to do this check before recursing due to overflow\n-            qsort::<T>(compare_func, arr, left, new_pivot - 1u);\n+            qsort::<T>(arr, left, new_pivot - 1u, compare_func);\n         }\n-        qsort::<T>(compare_func, arr, new_pivot + 1u, right);\n+        qsort::<T>(arr, new_pivot + 1u, right, compare_func);\n     }\n }\n \n@@ -94,9 +94,9 @@ fn qsort<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-fn quick_sort<T: Copy>(compare_func: Le<T>, arr: &[mut T]) {\n+fn quick_sort<T: Copy>(arr: &[mut T], compare_func: Le<T>) {\n     if len::<T>(arr) == 0u { return; }\n-    qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n+    qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n }\n \n fn qsort3<T: Copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n@@ -292,7 +292,8 @@ fn countRunAndMakeAscending<T: Ord>(array: &[mut T]) -> uint {\n     return run;\n }\n \n-pure fn gallopLeft<T: Ord>(key: &const T, array: &[const T], hint: uint) -> uint {  \n+pure fn gallopLeft<T: Ord>(key: &const T, array: &[const T],\n+                            hint: uint) -> uint {  \n     let size = array.len();\n     assert size != 0 && hint < size;\n \n@@ -340,7 +341,8 @@ pure fn gallopLeft<T: Ord>(key: &const T, array: &[const T], hint: uint) -> uint\n     return ofs;\n }\n \n-pure fn gallopRight<T: Ord>(key: &const T, array: &[const T], hint: uint) -> uint {\n+pure fn gallopRight<T: Ord>(key: &const T, array: &[const T],\n+                            hint: uint) -> uint {\n     let size = array.len();\n     assert size != 0 && hint < size;\n \n@@ -464,7 +466,8 @@ impl<T: Ord> &MergeState<T> {\n         self.runs.pop();\n     }\n \n-    fn mergeLo(array: &[mut T], base1: uint, len1: uint, base2: uint, len2: uint) {\n+    fn mergeLo(array: &[mut T], base1: uint, len1: uint,\n+                base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n         \n         vec::reserve(&mut self.tmp, len1);\n@@ -558,7 +561,9 @@ impl<T: Ord> &MergeState<T> {\n                 dest += 1; c1 += 1; len1 -= 1;\n                 if len1 == 1 { breakOuter = true; break; }\n                 minGallop -= 1;\n-                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) { break; } \n+                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n+                    break;\n+                } \n             }\n             if breakOuter { break; }\n             if minGallop < 0 { minGallop = 0; }\n@@ -584,7 +589,8 @@ impl<T: Ord> &MergeState<T> {\n         unsafe { vec::raw::set_len(self.tmp, 0); }\n     }\n \n-    fn mergeHi(array: &[mut T], base1: uint, len1: uint, base2: uint, len2: uint) {\n+    fn mergeHi(array: &[mut T], base1: uint, len1: uint,\n+                base2: uint, len2: uint) {\n         assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n \n         vec::reserve(&mut self.tmp, len2);\n@@ -655,7 +661,8 @@ impl<T: Ord> &MergeState<T> {\n                 assert len2 > 1 && len1 != 0;\n \n                 let tmpView = vec::mut_view(array, base1, base1+len1);\n-                count1 = len1-gallopRight(&const self.tmp[c2], tmpView, len1-1);\n+                count1 = len1 - gallopRight(\n+                    &const self.tmp[c2], tmpView, len1-1);\n \n                 if count1 != 0 {\n                     dest -= count1; c1 -= count1; len1 -= count1;\n@@ -670,8 +677,8 @@ impl<T: Ord> &MergeState<T> {\n                 if len2 == 1 { breakOuter = true; break; }\n \n                 let tmpView = vec::mut_view(self.tmp, 0, len2);\n-                let gL = gallopLeft(&const array[c1], tmpView, len2-1);\n-                count2 = len2 - gL;\n+                let count2 = len2 - gallopLeft(\n+                    &const array[c1], tmpView, len2-1);\n                 if count2 != 0 {\n                     dest -= count2; c2 -= count2; len2 -= count2;\n                     unsafe {\n@@ -683,7 +690,9 @@ impl<T: Ord> &MergeState<T> {\n                 dest -= 1; c1 -= 1; len1 -= 1;\n                 if len1 == 0 { breakOuter = true; break; }\n                 minGallop -= 1;\n-                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) { break; } \n+                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n+                    break;\n+                } \n             }\n             \n             if breakOuter { break; }\n@@ -748,7 +757,8 @@ impl<T: Ord> &MergeState<T> {\n // Moves elements to from dest to from\n // Unsafe as it makes the from parameter invalid between s2 and s2+len\n #[inline(always)]\n-unsafe fn moveVec<T>(dest: &[mut T], s1: uint, from: &[const T], s2: uint, len: uint) {   \n+unsafe fn moveVec<T>(dest: &[mut T], s1: uint, \n+                    from: &[const T], s2: uint, len: uint) {   \n     assert s1+len <= dest.len() && s2+len <= from.len();\n \n     do vec::as_mut_buf(dest) |p, _len| {"}, {"sha": "faa22ae096718d984db0283ec12c9619be41b450", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=868d10160f81c9d836202ed1c0683b75730fe73d", "patch": "@@ -229,7 +229,7 @@ fn print_failures(st: ConsoleTestState) {\n     st.out.write_line(~\"\\nfailures:\");\n     let failures = copy st.failures;\n     let failures = vec::map(failures, |test| test.name);\n-    let failures = sort::merge_sort(|x, y| str::le(*x, *y), failures);\n+    let failures = do sort::merge_sort(failures) |x, y| { str::le(*x, *y) };\n     for vec::each(failures) |name| {\n         st.out.write_line(fmt!(\"    %s\", *name));\n     }\n@@ -382,7 +382,7 @@ fn filter_tests(opts: &TestOpts,\n         pure fn lteq(t1: &TestDesc, t2: &TestDesc) -> bool {\n             str::le(t1.name, t2.name)\n         }\n-        sort::merge_sort(lteq, filtered)\n+        sort::merge_sort(filtered, lteq)\n     };\n \n     move filtered"}, {"sha": "a291501ef5fd667bcc1cdbde2256e4de994b4569", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=868d10160f81c9d836202ed1c0683b75730fe73d", "patch": "@@ -281,7 +281,7 @@ fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n     let v: ~[mut @ast::meta_item] = vec::to_mut(items);\n-    std::sort::quick_sort(lteq, v);\n+    std::sort::quick_sort(v, lteq);\n     vec::from_mut(move v)\n }\n "}, {"sha": "342743d8c46010a3861d5d7f704914b6fed23b28", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=868d10160f81c9d836202ed1c0683b75730fe73d", "patch": "@@ -127,7 +127,7 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n         pure fn by_lo(a: &gather_item, b: &gather_item) -> bool {\n             a.lo < b.lo\n         }\n-        std::sort::merge_sort(by_lo, v)\n+        std::sort::merge_sort(v, by_lo)\n     };\n     return cx;\n }"}, {"sha": "c5686153c000e5604d27c57d81b42334898ee8a1", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=868d10160f81c9d836202ed1c0683b75730fe73d", "patch": "@@ -166,7 +166,7 @@ fn get_dep_hashes(cstore: cstore) -> ~[~str] {\n         vec::push(result, {name: cdata.name, hash: hash});\n     };\n     pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {a.name <= b.name}\n-    let sorted = std::sort::merge_sort(lteq, result);\n+    let sorted = std::sort::merge_sort(result, lteq);\n     debug!(\"sorted:\");\n     for sorted.each |x| {\n         debug!(\"  hash[%s]: %s\", x.name, x.hash);"}, {"sha": "8da5fa0aee204b1bc925873d7f8efe4dd315a5b4", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=868d10160f81c9d836202ed1c0683b75730fe73d", "patch": "@@ -1038,7 +1038,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n         pure fn lteq(kv1: &numdep, kv2: &numdep) -> bool {\n             kv1.cnum <= kv2.cnum\n         }\n-        std::sort::quick_sort(lteq, deps);\n+        std::sort::quick_sort(deps, lteq);\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;"}, {"sha": "da3cf2395384e84cd88dbdf0456cbad16ff94199", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868d10160f81c9d836202ed1c0683b75730fe73d/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=868d10160f81c9d836202ed1c0683b75730fe73d", "patch": "@@ -36,7 +36,7 @@ fn fold_mod(\n ) -> doc::ModDoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n     doc::ModDoc_({\n-        items: sort::merge_sort(fold.ctxt, doc.items),\n+        items: sort::merge_sort(doc.items, fold.ctxt),\n         .. *doc\n     })\n }"}]}