{"sha": "844c152fd1be8f0142343a095d5b45586189f435", "node_id": "C_kwDOAAsO6NoAKDg0NGMxNTJmZDFiZThmMDE0MjM0M2EwOTVkNWI0NTU4NjE4OWY0MzU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-14T19:03:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-14T19:03:55Z"}, "message": "Merge #11248\n\n11248: Merge match assist: take arm types into consideration  r=Vannevelj a=Vannevelj\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/9337\n\nCo-authored-by: Jeroen Vannevel <jer_vannevel@outlook.com>", "tree": {"sha": "8861d59fea4d9893b26c991a1c4424ef60e311ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8861d59fea4d9893b26c991a1c4424ef60e311ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/844c152fd1be8f0142343a095d5b45586189f435", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh4ckbCRBK7hj4Ov3rIwAAiDkIAFlxQWMhQHD8Owfv1kHIGKP+\n6030PhsRIu/ZM2xSWG8S0wbWNZ0LE3h1nJgBPwL/JnJOftVTsOQxoY5xKL8MboXC\njU8MYCjxIHDlNPV0VO+zChirMjEFbrnR42xspi+KXP1ScntahVrDvea136aAsdw6\nYOQ6G8aKycIjj+NZwzOK7Q6L+PwPIYklX5lt1Q/LQDeKbTA44rJn+m5KRoKoxE5J\nbakuWpU97hW84X6myVB+i3LUerqL2/1nDMDl6QS/BYCkUhU8BKoYB9c3YZhUvpUn\nIRStKZ5rFUD9/ZOXnc3f66QBZdSeWiafoHtXMXa5g8zTMldKvuwnz7A6I3KjzFA=\n=/JaY\n-----END PGP SIGNATURE-----\n", "payload": "tree 8861d59fea4d9893b26c991a1c4424ef60e311ff\nparent b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd\nparent ffe4352d7c0727c5a657bd240275fffe7144ba8d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1642187035 +0000\ncommitter GitHub <noreply@github.com> 1642187035 +0000\n\nMerge #11248\n\n11248: Merge match assist: take arm types into consideration  r=Vannevelj a=Vannevelj\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/9337\n\nCo-authored-by: Jeroen Vannevel <jer_vannevel@outlook.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/844c152fd1be8f0142343a095d5b45586189f435", "html_url": "https://github.com/rust-lang/rust/commit/844c152fd1be8f0142343a095d5b45586189f435", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/844c152fd1be8f0142343a095d5b45586189f435/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd", "html_url": "https://github.com/rust-lang/rust/commit/b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd"}, {"sha": "ffe4352d7c0727c5a657bd240275fffe7144ba8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffe4352d7c0727c5a657bd240275fffe7144ba8d", "html_url": "https://github.com/rust-lang/rust/commit/ffe4352d7c0727c5a657bd240275fffe7144ba8d"}], "stats": {"total": 586, "additions": 582, "deletions": 4}, "files": [{"sha": "622ead81f105ba325b20a3992f5da7dea36b6665", "filename": "crates/ide_assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 582, "deletions": 4, "changes": 586, "blob_url": "https://github.com/rust-lang/rust/blob/844c152fd1be8f0142343a095d5b45586189f435/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844c152fd1be8f0142343a095d5b45586189f435/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=844c152fd1be8f0142343a095d5b45586189f435", "patch": "@@ -1,8 +1,8 @@\n-use std::iter::successors;\n-\n+use hir::TypeInfo;\n+use std::{collections::HashMap, iter::successors};\n use syntax::{\n     algo::neighbor,\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, HasName},\n     Direction,\n };\n \n@@ -40,13 +40,19 @@ pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option\n     }\n     let current_expr = current_arm.expr()?;\n     let current_text_range = current_arm.syntax().text_range();\n+    let current_arm_types = get_arm_types(&ctx, &current_arm);\n \n     // We check if the following match arms match this one. We could, but don't,\n     // compare to the previous match arm as well.\n     let arms_to_merge = successors(Some(current_arm), |it| neighbor(it, Direction::Next))\n         .take_while(|arm| match arm.expr() {\n             Some(expr) if arm.guard().is_none() => {\n-                expr.syntax().text() == current_expr.syntax().text()\n+                let same_text = expr.syntax().text() == current_expr.syntax().text();\n+                if !same_text {\n+                    return false;\n+                }\n+\n+                are_same_types(&current_arm_types, arm, ctx)\n             }\n             _ => false,\n         })\n@@ -88,6 +94,79 @@ fn contains_placeholder(a: &ast::MatchArm) -> bool {\n     matches!(a.pat(), Some(ast::Pat::WildcardPat(..)))\n }\n \n+fn are_same_types(\n+    current_arm_types: &HashMap<String, Option<TypeInfo>>,\n+    arm: &ast::MatchArm,\n+    ctx: &AssistContext,\n+) -> bool {\n+    let arm_types = get_arm_types(&ctx, &arm);\n+    for (other_arm_type_name, other_arm_type) in arm_types {\n+        match (current_arm_types.get(&other_arm_type_name), other_arm_type) {\n+            (Some(Some(current_arm_type)), Some(other_arm_type))\n+                if other_arm_type.original == current_arm_type.original =>\n+            {\n+                ()\n+            }\n+            _ => return false,\n+        }\n+    }\n+\n+    true\n+}\n+\n+fn get_arm_types(\n+    context: &AssistContext,\n+    arm: &ast::MatchArm,\n+) -> HashMap<String, Option<TypeInfo>> {\n+    let mut mapping: HashMap<String, Option<TypeInfo>> = HashMap::new();\n+\n+    fn recurse(\n+        map: &mut HashMap<String, Option<TypeInfo>>,\n+        ctx: &AssistContext,\n+        pat: &Option<ast::Pat>,\n+    ) {\n+        if let Some(local_pat) = pat {\n+            match pat {\n+                Some(ast::Pat::TupleStructPat(tuple)) => {\n+                    for field in tuple.fields() {\n+                        recurse(map, ctx, &Some(field));\n+                    }\n+                }\n+                Some(ast::Pat::TuplePat(tuple)) => {\n+                    for field in tuple.fields() {\n+                        recurse(map, ctx, &Some(field));\n+                    }\n+                }\n+                Some(ast::Pat::RecordPat(record)) => {\n+                    if let Some(field_list) = record.record_pat_field_list() {\n+                        for field in field_list.fields() {\n+                            recurse(map, ctx, &field.pat());\n+                        }\n+                    }\n+                }\n+                Some(ast::Pat::ParenPat(parentheses)) => {\n+                    recurse(map, ctx, &parentheses.pat());\n+                }\n+                Some(ast::Pat::SlicePat(slice)) => {\n+                    for slice_pat in slice.pats() {\n+                        recurse(map, ctx, &Some(slice_pat));\n+                    }\n+                }\n+                Some(ast::Pat::IdentPat(ident_pat)) => {\n+                    if let Some(name) = ident_pat.name() {\n+                        let pat_type = ctx.sema.type_of_pat(local_pat);\n+                        map.insert(name.text().to_string(), pat_type);\n+                    }\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    recurse(&mut mapping, &context, &arm.pat());\n+    mapping\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -244,4 +323,503 @@ fn main() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn merge_match_arms_different_type() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+//- minicore: result\n+fn func() {\n+    match Result::<f64, f32>::Ok(0f64) {\n+        Ok(x) => $0x.classify(),\n+        Err(x) => x.classify()\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_different_type_multiple_fields() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+//- minicore: result\n+fn func() {\n+    match Result::<(f64, f64), (f32, f32)>::Ok((0f64, 0f64)) {\n+        Ok(x) => $0x.1.classify(),\n+        Err(x) => x.1.classify()\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_same_type_multiple_fields() {\n+        check_assist(\n+            merge_match_arms,\n+            r#\"\n+//- minicore: result\n+fn func() {\n+    match Result::<(f64, f64), (f64, f64)>::Ok((0f64, 0f64)) {\n+        Ok(x) => $0x.1.classify(),\n+        Err(x) => x.1.classify()\n+    };\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    match Result::<(f64, f64), (f64, f64)>::Ok((0f64, 0f64)) {\n+        Ok(x) | Err(x) => x.1.classify(),\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_same_type_subsequent_arm_with_different_type_in_other() {\n+        check_assist(\n+            merge_match_arms,\n+            r#\"\n+enum MyEnum {\n+    OptionA(f32),\n+    OptionB(f32),\n+    OptionC(f64)\n+}\n+\n+fn func(e: MyEnum) {\n+    match e {\n+        MyEnum::OptionA(x) => $0x.classify(),\n+        MyEnum::OptionB(x) => x.classify(),\n+        MyEnum::OptionC(x) => x.classify(),\n+    };\n+}\n+\"#,\n+            r#\"\n+enum MyEnum {\n+    OptionA(f32),\n+    OptionB(f32),\n+    OptionC(f64)\n+}\n+\n+fn func(e: MyEnum) {\n+    match e {\n+        MyEnum::OptionA(x) | MyEnum::OptionB(x) => x.classify(),\n+        MyEnum::OptionC(x) => x.classify(),\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_same_type_skip_arm_with_different_type_in_between() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+enum MyEnum {\n+    OptionA(f32),\n+    OptionB(f64),\n+    OptionC(f32)\n+}\n+\n+fn func(e: MyEnum) {\n+    match e {\n+        MyEnum::OptionA(x) => $0x.classify(),\n+        MyEnum::OptionB(x) => x.classify(),\n+        MyEnum::OptionC(x) => x.classify(),\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_same_type_different_number_of_fields() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+//- minicore: result\n+fn func() {\n+    match Result::<(f64, f64, f64), (f64, f64)>::Ok((0f64, 0f64, 0f64)) {\n+        Ok(x) => $0x.1.classify(),\n+        Err(x) => x.1.classify()\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_match_same_destructuring_different_types() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn func() {\n+    let p = Point { x: 0, y: 7 };\n+\n+    match p {\n+        Point { x, y: 0 } => $0\"\",\n+        Point { x: 0, y } => \"\",\n+        Point { x, y } => \"\",\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_range() {\n+        check_assist(\n+            merge_match_arms,\n+            r#\"\n+fn func() {\n+    let x = 'c';\n+\n+    match x {\n+        'a'..='j' => $0\"\",\n+        'c'..='z' => \"\",\n+        _ => \"other\",\n+    };\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let x = 'c';\n+\n+    match x {\n+        'a'..='j' | 'c'..='z' => \"\",\n+        _ => \"other\",\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_enum_without_field() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+enum MyEnum {\n+    NoField,\n+    AField(u8)\n+}\n+\n+fn func(x: MyEnum) {\n+    match x {\n+        MyEnum::NoField => $0\"\",\n+        MyEnum::AField(x) => \"\"\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_enum_destructuring_different_types() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+enum MyEnum {\n+    Move { x: i32, y: i32 },\n+    Write(String),\n+}\n+\n+fn func(x: MyEnum) {\n+    match x {\n+        MyEnum::Move { x, y } => $0\"\",\n+        MyEnum::Write(text) => \"\",\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_enum_destructuring_same_types() {\n+        check_assist(\n+            merge_match_arms,\n+            r#\"\n+enum MyEnum {\n+    Move { x: i32, y: i32 },\n+    Crawl { x: i32, y: i32 }\n+}\n+\n+fn func(x: MyEnum) {\n+    match x {\n+        MyEnum::Move { x, y } => $0\"\",\n+        MyEnum::Crawl { x, y } => \"\",\n+    };\n+}\n+        \"#,\n+            r#\"\n+enum MyEnum {\n+    Move { x: i32, y: i32 },\n+    Crawl { x: i32, y: i32 }\n+}\n+\n+fn func(x: MyEnum) {\n+    match x {\n+        MyEnum::Move { x, y } | MyEnum::Crawl { x, y } => \"\",\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_enum_destructuring_same_types_different_name() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+enum MyEnum {\n+    Move { x: i32, y: i32 },\n+    Crawl { a: i32, b: i32 }\n+}\n+\n+fn func(x: MyEnum) {\n+    match x {\n+        MyEnum::Move { x, y } => $0\"\",\n+        MyEnum::Crawl { a, b } => \"\",\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_enum_nested_pattern_different_names() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+enum Color {\n+    Rgb(i32, i32, i32),\n+    Hsv(i32, i32, i32),\n+}\n+\n+enum Message {\n+    Quit,\n+    Move { x: i32, y: i32 },\n+    Write(String),\n+    ChangeColor(Color),\n+}\n+\n+fn main(msg: Message) {\n+    match msg {\n+        Message::ChangeColor(Color::Rgb(r, g, b)) => $0\"\",\n+        Message::ChangeColor(Color::Hsv(h, s, v)) => \"\",\n+        _ => \"other\"\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_enum_nested_pattern_same_names() {\n+        check_assist(\n+            merge_match_arms,\n+            r#\"\n+enum Color {\n+    Rgb(i32, i32, i32),\n+    Hsv(i32, i32, i32),\n+}\n+\n+enum Message {\n+    Quit,\n+    Move { x: i32, y: i32 },\n+    Write(String),\n+    ChangeColor(Color),\n+}\n+\n+fn main(msg: Message) {\n+    match msg {\n+        Message::ChangeColor(Color::Rgb(a, b, c)) => $0\"\",\n+        Message::ChangeColor(Color::Hsv(a, b, c)) => \"\",\n+        _ => \"other\"\n+    };\n+}\n+        \"#,\n+            r#\"\n+enum Color {\n+    Rgb(i32, i32, i32),\n+    Hsv(i32, i32, i32),\n+}\n+\n+enum Message {\n+    Quit,\n+    Move { x: i32, y: i32 },\n+    Write(String),\n+    ChangeColor(Color),\n+}\n+\n+fn main(msg: Message) {\n+    match msg {\n+        Message::ChangeColor(Color::Rgb(a, b, c)) | Message::ChangeColor(Color::Hsv(a, b, c)) => \"\",\n+        _ => \"other\"\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_enum_destructuring_with_ignore() {\n+        check_assist(\n+            merge_match_arms,\n+            r#\"\n+enum MyEnum {\n+    Move { x: i32, a: i32 },\n+    Crawl { x: i32, b: i32 }\n+}\n+\n+fn func(x: MyEnum) {\n+    match x {\n+        MyEnum::Move { x, .. } => $0\"\",\n+        MyEnum::Crawl { x, .. } => \"\",\n+    };\n+}\n+        \"#,\n+            r#\"\n+enum MyEnum {\n+    Move { x: i32, a: i32 },\n+    Crawl { x: i32, b: i32 }\n+}\n+\n+fn func(x: MyEnum) {\n+    match x {\n+        MyEnum::Move { x, .. } | MyEnum::Crawl { x, .. } => \"\",\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_nested_with_conflicting_identifier() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+enum Color {\n+    Rgb(i32, i32, i32),\n+    Hsv(i32, i32, i32),\n+}\n+\n+enum Message {\n+    Move { x: i32, y: i32 },\n+    ChangeColor(u8, Color),\n+}\n+\n+fn main(msg: Message) {\n+    match msg {\n+        Message::ChangeColor(x, Color::Rgb(y, b, c)) => $0\"\",\n+        Message::ChangeColor(y, Color::Hsv(x, b, c)) => \"\",\n+        _ => \"other\"\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_tuple() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+fn func() {\n+    match (0, \"boo\") {\n+        (x, y) => $0\"\",\n+        (y, x) => \"\",\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_parentheses() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+fn func(x: i32) {\n+    let variable = 2;\n+    match x {\n+        1 => $0\"\",\n+        ((((variable)))) => \"\",\n+        _ => \"other\"\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_refpat() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+fn func() {\n+    let name = Some(String::from(\"\"));\n+    let n = String::from(\"\");\n+    match name {\n+        Some(ref n) => $0\"\",\n+        Some(n) => \"\",\n+        _ => \"other\",\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_slice() {\n+        check_assist_not_applicable(\n+            merge_match_arms,\n+            r#\"\n+fn func(binary: &[u8]) {\n+    let space = b' ';\n+    match binary {\n+        [0x7f, b'E', b'L', b'F', ..] => $0\"\",\n+        [space] => \"\",\n+        _ => \"other\",\n+    };\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_match_arms_slice_identical() {\n+        check_assist(\n+            merge_match_arms,\n+            r#\"\n+fn func(binary: &[u8]) {\n+    let space = b' ';\n+    match binary {\n+        [space, 5u8] => $0\"\",\n+        [space] => \"\",\n+        _ => \"other\",\n+    };\n+}\n+        \"#,\n+            r#\"\n+fn func(binary: &[u8]) {\n+    let space = b' ';\n+    match binary {\n+        [space, 5u8] | [space] => \"\",\n+        _ => \"other\",\n+    };\n+}\n+        \"#,\n+        )\n+    }\n }"}]}