{"sha": "e893089ea066ce2b339543ac8e59b4e0ca8c44d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4OTMwODllYTA2NmNlMmIzMzk1NDNhYzhlNTliNGUwY2E4YzQ0ZDM=", "commit": {"author": {"name": "Ian Jackson", "email": "ijackson@chiark.greenend.org.uk", "date": "2021-03-03T12:17:16Z"}, "committer": {"name": "Ian Jackson", "email": "ijackson@chiark.greenend.org.uk", "date": "2021-05-12T10:12:19Z"}, "message": "Provide ExitStatusError\n\nCloses #73125\n\nThis is in pursuance of\n  Issue #73127 Consider adding #[must_use] to std::process::ExitStatus\n\nIn\n  MR #81452 Add #[must_use] to [...] process::ExitStatus\nwe concluded that the existing arrangements in are too awkward\nso adding that #[must_use] is blocked on improving the ergonomics.\n\nI wrote a mini-RFC-style discusion of the approach in\n  https://github.com/rust-lang/rust/issues/73125#issuecomment-771092741\n\nSigned-off-by: Ian Jackson <ijackson@chiark.greenend.org.uk>", "tree": {"sha": "959e608dbb64db52ee930ce42106e2db878644e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/959e608dbb64db52ee930ce42106e2db878644e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e893089ea066ce2b339543ac8e59b4e0ca8c44d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e893089ea066ce2b339543ac8e59b4e0ca8c44d3", "html_url": "https://github.com/rust-lang/rust/commit/e893089ea066ce2b339543ac8e59b4e0ca8c44d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/comments", "author": {"login": "ijackson", "id": 2090772, "node_id": "MDQ6VXNlcjIwOTA3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2090772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ijackson", "html_url": "https://github.com/ijackson", "followers_url": "https://api.github.com/users/ijackson/followers", "following_url": "https://api.github.com/users/ijackson/following{/other_user}", "gists_url": "https://api.github.com/users/ijackson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ijackson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ijackson/subscriptions", "organizations_url": "https://api.github.com/users/ijackson/orgs", "repos_url": "https://api.github.com/users/ijackson/repos", "events_url": "https://api.github.com/users/ijackson/events{/privacy}", "received_events_url": "https://api.github.com/users/ijackson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ijackson", "id": 2090772, "node_id": "MDQ6VXNlcjIwOTA3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2090772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ijackson", "html_url": "https://github.com/ijackson", "followers_url": "https://api.github.com/users/ijackson/followers", "following_url": "https://api.github.com/users/ijackson/following{/other_user}", "gists_url": "https://api.github.com/users/ijackson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ijackson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ijackson/subscriptions", "organizations_url": "https://api.github.com/users/ijackson/orgs", "repos_url": "https://api.github.com/users/ijackson/repos", "events_url": "https://api.github.com/users/ijackson/events{/privacy}", "received_events_url": "https://api.github.com/users/ijackson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b50c1bbb0e2b73aed1a3cfc8da5e1082ddb21040", "url": "https://api.github.com/repos/rust-lang/rust/commits/b50c1bbb0e2b73aed1a3cfc8da5e1082ddb21040", "html_url": "https://github.com/rust-lang/rust/commit/b50c1bbb0e2b73aed1a3cfc8da5e1082ddb21040"}], "stats": {"total": 240, "additions": 227, "deletions": 13}, "files": [{"sha": "6020ecf685366d7f5cd67d5dcc819f423ff07d0d", "filename": "library/std/src/process.rs", "status": "modified", "additions": 135, "deletions": 3, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=e893089ea066ce2b339543ac8e59b4e0ca8c44d3", "patch": "@@ -110,6 +110,7 @@ use crate::ffi::OsStr;\n use crate::fmt;\n use crate::fs;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n+use crate::num::NonZeroI32;\n use crate::path::Path;\n use crate::str;\n use crate::sys::pipe::{read2, AnonPipe};\n@@ -1387,8 +1388,8 @@ impl From<fs::File> for Stdio {\n /// An `ExitStatus` represents every possible disposition of a process.  On Unix this\n /// is the **wait status**.  It is *not* simply an *exit status* (a value passed to `exit`).\n ///\n-/// For proper error reporting of failed processes, print the value of `ExitStatus` using its\n-/// implementation of [`Display`](crate::fmt::Display).\n+/// For proper error reporting of failed processes, print the value of `ExitStatus` or\n+/// `ExitStatusError` using their implementations of [`Display`](crate::fmt::Display).\n ///\n /// [`status`]: Command::status\n /// [`wait`]: Child::wait\n@@ -1401,6 +1402,29 @@ pub struct ExitStatus(imp::ExitStatus);\n impl crate::sealed::Sealed for ExitStatus {}\n \n impl ExitStatus {\n+    /// Was termination successful?  Returns a `Result`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exit_status_error)]\n+    /// # if cfg!(unix) {\n+    /// use std::process::Command;\n+    ///\n+    /// let status = Command::new(\"ls\")\n+    ///                      .arg(\"/dev/nonexistent\")\n+    ///                      .status()\n+    ///                      .expect(\"ls could not be executed\");\n+    ///\n+    /// println!(\"ls: {}\", status);\n+    /// status.exit_ok().expect_err(\"/dev/nonexistent could be listed!\");\n+    /// # } // cfg!(unix)\n+    /// ```\n+    #[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n+        self.0.exit_ok().map_err(ExitStatusError)\n+    }\n+\n     /// Was termination successful? Signal termination is not considered a\n     /// success, and success is defined as a zero exit status.\n     ///\n@@ -1422,7 +1446,7 @@ impl ExitStatus {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn success(&self) -> bool {\n-        self.0.success()\n+        self.0.exit_ok().is_ok()\n     }\n \n     /// Returns the exit code of the process, if any.\n@@ -1476,6 +1500,114 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+/// Describes the result of a process after it has failed\n+///\n+/// Produced by the [`.exit_ok`](ExitStatus::exit_ok) method on [`ExitStatus`].\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(exit_status_error)]\n+/// # if cfg!(unix) {\n+/// use std::process::{Command, ExitStatusError};\n+///\n+/// fn run(cmd: &str) -> Result<(),ExitStatusError> {\n+///     Command::new(cmd).status().unwrap().exit_ok()?;\n+///     Ok(())\n+/// }\n+///\n+/// run(\"true\").unwrap();\n+/// run(\"false\").unwrap_err();\n+/// # } // cfg!(unix)\n+/// ```\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+// The definition of imp::ExitStatusError should ideally be such that\n+// Result<(), imp::ExitStatusError> has an identical representation to imp::ExitStatus.\n+pub struct ExitStatusError(imp::ExitStatusError);\n+\n+#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+impl ExitStatusError {\n+    /// Reports the exit code, if applicable, from an `ExitStatusError`.\n+    ///\n+    /// In Unix terms the return value is the **exit status**: the value passed to `exit`, if the\n+    /// process finished by calling `exit`.  Note that on Unix the exit status is truncated to 8\n+    /// bits, and that values that didn't come from a program's call to `exit` may be invented the\n+    /// runtime system (often, for example, 255, 254, 127 or 126).\n+    ///\n+    /// On Unix, this will return `None` if the process was terminated by a signal.  If you want to\n+    /// handle such situations specially, consider using\n+    /// [`ExitStatusExt`](crate::os::unix::process::ExitStatusExt) (possibly after getting the\n+    /// general `ExitStatus` by using [`status()`](ExitStatusError::status).\n+    ///\n+    /// If the process finished by calling `exit` with a nonzero value, this will return\n+    /// that exit status.\n+    ///\n+    /// If the error was something else, it will return `None`.\n+    ///\n+    /// If the process exited successfully (ie, by calling `exit(0)`), there is no\n+    /// `ExitStatusError`.  So the return value from `ExitStatusError::code()` is always nonzero.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exit_status_error)]\n+    /// # #[cfg(unix)] {\n+    /// use std::process::Command;\n+    ///\n+    /// let bad = Command::new(\"false\").status().unwrap().exit_ok().unwrap_err();\n+    /// assert_eq!(bad.code(), Some(1));\n+    /// # } // #[cfg(unix)]\n+    /// ```\n+    pub fn code(&self) -> Option<i32> {\n+        self.code_nonzero().map(Into::into)\n+    }\n+\n+    /// Reports the exit code, if applicable, from an `ExitStatusError`, as a `NonZero`\n+    ///\n+    /// This is exaclty like [`code()`](Self::code), except that it returns a `NonZeroI32`.\n+    ///\n+    /// Plain `code`, returning a plain integer, is provided because is is often more convenient.\n+    /// The returned value from `code()` is indeed also nonzero; use `code_nonzero()` when you want\n+    /// a type-level guarantee of nonzeroness.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exit_status_error)]\n+    /// # if cfg!(unix) {\n+    /// use std::convert::TryFrom;\n+    /// use std::num::NonZeroI32;\n+    /// use std::process::Command;\n+    ///\n+    /// let bad = Command::new(\"false\").status().unwrap().exit_ok().unwrap_err();\n+    /// assert_eq!(bad.code_nonzero().unwrap(), NonZeroI32::try_from(1).unwrap());\n+    /// # } // cfg!(unix)\n+    /// ```\n+    pub fn code_nonzero(&self) -> Option<NonZeroI32> {\n+        self.0.code()\n+    }\n+\n+    /// Converts an `ExitStatusError` (back) to an `ExitStatus`.\n+    pub fn into_status(&self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+impl fmt::Display for ExitStatusError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.into_status().fmt(f)\n+    }\n+}\n+\n /// This type represents the status code a process can return to its\n /// parent under normal termination.\n ///"}, {"sha": "b5a19ed54a2f25e78d1fc25dc52d4589778c5d14", "filename": "library/std/src/sys/unix/process/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs?ref=e893089ea066ce2b339543ac8e59b4e0ca8c44d3", "patch": "@@ -1,5 +1,5 @@\n pub use self::process_common::{Command, CommandArgs, ExitCode, Stdio, StdioPipes};\n-pub use self::process_inner::{ExitStatus, Process};\n+pub use self::process_inner::{ExitStatus, ExitStatusError, Process};\n pub use crate::ffi::OsString as EnvKey;\n pub use crate::sys_common::process::CommandEnvs;\n "}, {"sha": "507abb27871bf05747ffb0e132c0e99070781909", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=e893089ea066ce2b339543ac8e59b4e0ca8c44d3", "patch": "@@ -1,7 +1,8 @@\n-use crate::convert::TryInto;\n+use crate::convert::{TryFrom, TryInto};\n use crate::fmt;\n use crate::io;\n use crate::mem;\n+use crate::num::{NonZeroI32, NonZeroI64};\n use crate::ptr;\n \n use crate::sys::process::process_common::*;\n@@ -236,8 +237,11 @@ impl Process {\n pub struct ExitStatus(i64);\n \n impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        self.code() == Some(0)\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n+        match NonZeroI64::try_from(self.0) {\n+            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n+            /* was zero, couldn't convert */ Err(_) => Ok(()),\n+        }\n     }\n \n     pub fn code(&self) -> Option<i32> {\n@@ -306,3 +310,19 @@ impl fmt::Display for ExitStatus {\n         write!(f, \"exit code: {}\", self.0)\n     }\n }\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatusError(NonZeroI64);\n+\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+impl ExitStatusError {\n+    pub fn code(self) -> Option<NonZeroI32> {\n+        // fixme: affected by the same bug as ExitStatus::code()\n+        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n+    }\n+}"}, {"sha": "f711b4cc68950e81e816cf0bf23f4e4bbd143b65", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=e893089ea066ce2b339543ac8e59b4e0ca8c44d3", "patch": "@@ -1,7 +1,9 @@\n-use crate::convert::TryInto;\n+use crate::convert::{TryFrom, TryInto};\n use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n use crate::mem;\n+use crate::num::NonZeroI32;\n+use crate::os::raw::NonZero_c_int;\n use crate::ptr;\n use crate::sys;\n use crate::sys::cvt;\n@@ -490,8 +492,16 @@ impl ExitStatus {\n         libc::WIFEXITED(self.0)\n     }\n \n-    pub fn success(&self) -> bool {\n-        self.code() == Some(0)\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n+        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n+        // true on all actual versios of Unix, is widely assumed, and is specified in SuS\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n+        // true for a platform pretending to be Unix, the tests (our doctests, and also\n+        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n+        match NonZero_c_int::try_from(self.0) {\n+            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n+            /* was zero, couldn't convert */ Err(_) => Ok(()),\n+        }\n     }\n \n     pub fn code(&self) -> Option<i32> {\n@@ -546,6 +556,21 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatusError(NonZero_c_int);\n+\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+impl ExitStatusError {\n+    pub fn code(self) -> Option<NonZeroI32> {\n+        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n+    }\n+}\n+\n #[cfg(test)]\n #[path = \"process_unix/tests.rs\"]\n mod tests;"}, {"sha": "7846e43cfb53ee56aa0be7b9c0e2a11781e05725", "filename": "library/std/src/sys/unsupported/process.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs?ref=e893089ea066ce2b339543ac8e59b4e0ca8c44d3", "patch": "@@ -2,6 +2,7 @@ use crate::ffi::OsStr;\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n+use crate::num::NonZeroI32;\n use crate::path::Path;\n use crate::sys::fs::File;\n use crate::sys::pipe::AnonPipe;\n@@ -97,7 +98,7 @@ impl fmt::Debug for Command {\n pub struct ExitStatus(!);\n \n impl ExitStatus {\n-    pub fn success(&self) -> bool {\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n         self.0\n     }\n \n@@ -134,6 +135,21 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatusError(ExitStatus);\n+\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        self.0.0\n+    }\n+}\n+\n+impl ExitStatusError {\n+    pub fn code(self) -> Option<NonZeroI32> {\n+        self.0.0\n+    }\n+}\n+\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub struct ExitCode(bool);\n "}, {"sha": "81dbea4a067399755a1fd029fc3ed514c6c44e05", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e893089ea066ce2b339543ac8e59b4e0ca8c44d3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=e893089ea066ce2b339543ac8e59b4e0ca8c44d3", "patch": "@@ -5,17 +5,20 @@ mod tests;\n \n use crate::borrow::Borrow;\n use crate::collections::BTreeMap;\n+use crate::convert::{TryFrom, TryInto};\n use crate::env;\n use crate::env::split_paths;\n use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n use crate::fs;\n use crate::io::{self, Error, ErrorKind};\n use crate::mem;\n+use crate::num::NonZeroI32;\n use crate::os::windows::ffi::OsStrExt;\n use crate::path::Path;\n use crate::ptr;\n use crate::sys::c;\n+use crate::sys::c::NonZeroDWORD;\n use crate::sys::cvt;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n@@ -376,8 +379,11 @@ impl Process {\n pub struct ExitStatus(c::DWORD);\n \n impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        self.0 == 0\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n+        match NonZeroDWORD::try_from(self.0) {\n+            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n+            /* was zero, couldn't convert */ Err(_) => Ok(()),\n+        }\n     }\n     pub fn code(&self) -> Option<i32> {\n         Some(self.0 as i32)\n@@ -406,6 +412,21 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatusError(c::NonZeroDWORD);\n+\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+impl ExitStatusError {\n+    pub fn code(self) -> Option<NonZeroI32> {\n+        Some((u32::from(self.0) as i32).try_into().unwrap())\n+    }\n+}\n+\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub struct ExitCode(c::DWORD);\n "}]}