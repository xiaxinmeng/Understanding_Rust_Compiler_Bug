{"sha": "e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "node_id": "C_kwDOAAsO6NoAKGU4ZmMwNzZmMjMxNjk5ZDlhNDRmYzQ0YTFlMjk4ZWE0ZjcwZmRiNDg", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-09-28T14:48:54Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-10-05T23:34:13Z"}, "message": "Consider unfulfilled obligations in binop errors\n\nWhen encountering a binop where the types would have been accepted, if\nall the predicates had been fulfilled, include information about the\npredicates and suggest appropriate `#[derive]`s if possible.\n\nPoint at trait(s) that needs to be `impl`emented.", "tree": {"sha": "c4d83e0d4aa46d9c82d90f2cb50c98322ce5dafa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4d83e0d4aa46d9c82d90f2cb50c98322ce5dafa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "html_url": "https://github.com/rust-lang/rust/commit/e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "074f63648bd2368d5ca19aed02b5763a144e5d05", "url": "https://api.github.com/repos/rust-lang/rust/commits/074f63648bd2368d5ca19aed02b5763a144e5d05", "html_url": "https://github.com/rust-lang/rust/commit/074f63648bd2368d5ca19aed02b5763a144e5d05"}], "stats": {"total": 775, "additions": 667, "deletions": 108}, "files": [{"sha": "c9f0b508f59e0a83521037378aa6c443acee2909", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -2171,10 +2171,26 @@ impl fmt::Debug for TraitRefPrintOnlyTraitPath<'tcx> {\n     }\n }\n \n+/// Wrapper type for `ty::TraitRef` which opts-in to pretty printing only\n+/// the trait name. That is, it will print `Trait` instead of\n+/// `<T as Trait<U>>`.\n+#[derive(Copy, Clone, TypeFoldable, Lift)]\n+pub struct TraitRefPrintOnlyTraitName<'tcx>(ty::TraitRef<'tcx>);\n+\n+impl fmt::Debug for TraitRefPrintOnlyTraitName<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n impl ty::TraitRef<'tcx> {\n     pub fn print_only_trait_path(self) -> TraitRefPrintOnlyTraitPath<'tcx> {\n         TraitRefPrintOnlyTraitPath(self)\n     }\n+\n+    pub fn print_only_trait_name(self) -> TraitRefPrintOnlyTraitName<'tcx> {\n+        TraitRefPrintOnlyTraitName(self)\n+    }\n }\n \n impl ty::Binder<'tcx, ty::TraitRef<'tcx>> {\n@@ -2193,6 +2209,7 @@ forward_display_to_print! {\n     ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>,\n     ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n     ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    ty::Binder<'tcx, TraitRefPrintOnlyTraitName<'tcx>>,\n     ty::Binder<'tcx, ty::FnSig<'tcx>>,\n     ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n     ty::Binder<'tcx, ty::SubtypePredicate<'tcx>>,\n@@ -2255,6 +2272,10 @@ define_print_and_forward_display! {\n         p!(print_def_path(self.0.def_id, self.0.substs));\n     }\n \n+    TraitRefPrintOnlyTraitName<'tcx> {\n+        p!(print_def_path(self.0.def_id, &[]));\n+    }\n+\n     ty::ParamTy {\n         p!(write(\"{}\", self.name))\n     }"}, {"sha": "88e8df81488e69b95d7edeb82a922645613cc88a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -521,7 +521,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                     \"this error might have been caused by changes to \\\n                                     Rust's type-inference algorithm (see issue #48950 \\\n                                     <https://github.com/rust-lang/rust/issues/48950> \\\n-                                    for more information).\",\n+                                    for more information)\",\n                                 );\n                                 err.help(\"did you intend to use the type `()` here instead?\");\n                             }"}, {"sha": "f0f2470e80a8c69ec416c5e7934edffdf34448f9", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -290,29 +290,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n-    /// `lookup_method_in_trait` is used for overloaded operators.\n-    /// It does a very narrow slice of what the normal probe/confirm path does.\n-    /// In particular, it doesn't really do any probing: it simply constructs\n-    /// an obligation for a particular trait with the given self type and checks\n-    /// whether that trait is implemented.\n-    //\n-    // FIXME(#18741): it seems likely that we can consolidate some of this\n-    // code with the other method-lookup code. In particular, the second half\n-    // of this method is basically the same as confirmation.\n-    #[instrument(level = \"debug\", skip(self, span, opt_input_types))]\n-    pub fn lookup_method_in_trait(\n+    pub(super) fn obligation_for_method(\n         &self,\n         span: Span,\n-        m_name: Ident,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        debug!(\n-            \"lookup_in_trait_adjusted(self_ty={:?}, m_name={}, trait_def_id={:?}, opt_input_types={:?})\",\n-            self_ty, m_name, trait_def_id, opt_input_types\n-        );\n-\n+    ) -> (traits::Obligation<'tcx, ty::Predicate<'tcx>>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>)\n+    {\n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n         let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n             match param.kind {\n@@ -332,17 +317,48 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Construct an obligation\n         let poly_trait_ref = ty::Binder::dummy(trait_ref);\n-        let obligation = traits::Obligation::misc(\n-            span,\n-            self.body_id,\n-            self.param_env,\n-            poly_trait_ref.without_const().to_predicate(self.tcx),\n+        (\n+            traits::Obligation::misc(\n+                span,\n+                self.body_id,\n+                self.param_env,\n+                poly_trait_ref.without_const().to_predicate(self.tcx),\n+            ),\n+            substs,\n+        )\n+    }\n+\n+    /// `lookup_method_in_trait` is used for overloaded operators.\n+    /// It does a very narrow slice of what the normal probe/confirm path does.\n+    /// In particular, it doesn't really do any probing: it simply constructs\n+    /// an obligation for a particular trait with the given self type and checks\n+    /// whether that trait is implemented.\n+    //\n+    // FIXME(#18741): it seems likely that we can consolidate some of this\n+    // code with the other method-lookup code. In particular, the second half\n+    // of this method is basically the same as confirmation.\n+    #[instrument(level = \"debug\", skip(self, span, opt_input_types))]\n+    pub(super) fn lookup_method_in_trait(\n+        &self,\n+        span: Span,\n+        m_name: Ident,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        opt_input_types: Option<&[Ty<'tcx>]>,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        debug!(\n+            \"lookup_in_trait_adjusted(self_ty={:?}, m_name={}, trait_def_id={:?}, opt_input_types={:?})\",\n+            self_ty, m_name, trait_def_id, opt_input_types\n         );\n \n+        let (obligation, substs) =\n+            self.obligation_for_method(span, trait_def_id, self_ty, opt_input_types);\n+\n         // Now we want to know if this can be matched\n         if !self.predicate_may_hold(&obligation) {\n             debug!(\"--> Cannot match obligation\");\n-            return None; // Cannot be matched, no such method resolution is possible.\n+            // Cannot be matched, no such method resolution is possible.\n+            return None;\n         }\n \n         // Trait must have a method named `m_name` and it should not have\n@@ -416,7 +432,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(method_ty.into())).to_predicate(tcx),\n         ));\n \n-        let callee = MethodCallee { def_id, substs: trait_ref.substs, sig: fn_sig };\n+        let callee = MethodCallee { def_id, substs, sig: fn_sig };\n \n         debug!(\"callee = {:?}\", callee);\n "}, {"sha": "8c7ec2194644b5d340804bdca956b84413f357a6", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 118, "deletions": 3, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -15,9 +15,9 @@ use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_span::lev_distance;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{source_map, FileName, Span};\n+use rustc_span::{source_map, FileName, MultiSpan, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n-use rustc_trait_selection::traits::Obligation;\n+use rustc_trait_selection::traits::{FulfillmentError, Obligation};\n \n use std::cmp::Ordering;\n use std::iter;\n@@ -969,6 +969,79 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n+    crate fn note_unmet_impls_on_type(\n+        &self,\n+        err: &mut rustc_errors::DiagnosticBuilder<'_>,\n+        errors: Vec<FulfillmentError<'tcx>>,\n+    ) {\n+        let all_local_types_needing_impls =\n+            errors.iter().all(|e| match e.obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Trait(pred) => match pred.self_ty().kind() {\n+                    ty::Adt(def, _) => def.did.is_local(),\n+                    _ => false,\n+                },\n+                _ => false,\n+            });\n+        let mut preds: Vec<_> = errors\n+            .iter()\n+            .filter_map(|e| match e.obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Trait(pred) => Some(pred),\n+                _ => None,\n+            })\n+            .collect();\n+        preds.sort_by_key(|pred| (pred.def_id(), pred.self_ty()));\n+        let def_ids = preds\n+            .iter()\n+            .filter_map(|pred| match pred.self_ty().kind() {\n+                ty::Adt(def, _) => Some(def.did),\n+                _ => None,\n+            })\n+            .collect::<FxHashSet<_>>();\n+        let sm = self.tcx.sess.source_map();\n+        let mut spans: MultiSpan = def_ids\n+            .iter()\n+            .filter_map(|def_id| {\n+                let span = self.tcx.def_span(*def_id);\n+                if span.is_dummy() { None } else { Some(sm.guess_head_span(span)) }\n+            })\n+            .collect::<Vec<_>>()\n+            .into();\n+\n+        for pred in &preds {\n+            match pred.self_ty().kind() {\n+                ty::Adt(def, _) => {\n+                    spans.push_span_label(\n+                        sm.guess_head_span(self.tcx.def_span(def.did)),\n+                        format!(\"must implement `{}`\", pred.trait_ref.print_only_trait_path()),\n+                    );\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        if all_local_types_needing_impls && spans.primary_span().is_some() {\n+            let msg = if preds.len() == 1 {\n+                format!(\n+                    \"an implementation of `{}` might be missing for `{}`\",\n+                    preds[0].trait_ref.print_only_trait_path(),\n+                    preds[0].self_ty()\n+                )\n+            } else {\n+                format!(\n+                    \"the following type{} would have to `impl` {} required trait{} for this \\\n+                     operation to be valid\",\n+                    pluralize!(def_ids.len()),\n+                    if def_ids.len() == 1 { \"its\" } else { \"their\" },\n+                    pluralize!(preds.len()),\n+                )\n+            };\n+            err.span_note(spans, &msg);\n+        }\n+\n+        let preds: Vec<_> = errors.iter().map(|e| (e.obligation.predicate, None)).collect();\n+        self.suggest_derive(err, &preds);\n+    }\n+\n     fn suggest_derive(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -1010,7 +1083,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             return Some((\n                                 format!(\"{}\", trait_ref.self_ty()),\n                                 self.tcx.def_span(adt_def.did),\n-                                format!(\"{}\", trait_ref.print_only_trait_path()),\n+                                format!(\"{}\", trait_ref.print_only_trait_name()),\n                             ));\n                         }\n                         None\n@@ -1033,6 +1106,48 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 acc\n             },\n         );\n+        let mut traits: Vec<_> = unsatisfied_predicates\n+            .iter()\n+            .filter_map(|(pred, _)| {\n+                let trait_pred =\n+                    if let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() {\n+                        trait_pred\n+                    } else {\n+                        return None;\n+                    };\n+                if let ty::Adt(adt_def, _) = trait_pred.trait_ref.self_ty().kind() {\n+                    if !adt_def.did.is_local() {\n+                        return None;\n+                    }\n+                } else {\n+                    return None;\n+                };\n+\n+                let did = trait_pred.def_id();\n+                let diagnostic_items = self.tcx.diagnostic_items(did.krate);\n+\n+                if !derivables\n+                    .iter()\n+                    .any(|trait_derivable| diagnostic_items.get(trait_derivable) == Some(&did))\n+                {\n+                    Some(self.tcx.def_span(did))\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect();\n+        traits.sort();\n+        traits.dedup();\n+\n+        let len = traits.len();\n+        if len > 0 {\n+            let span: MultiSpan = traits.into();\n+            err.span_note(\n+                span,\n+                &format!(\"the following trait{} must be implemented\", pluralize!(len),),\n+            );\n+        }\n+\n         for (self_name, self_span, traits) in &derives_grouped {\n             err.span_suggestion_verbose(\n                 self_span.shrink_to_lo(),"}, {"sha": "79e004a47db53484d7d76ba2f212f58c591a4b6c", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -18,6 +18,7 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::{FulfillmentError, TraitEngine, TraitEngineExt};\n \n use std::ops::ControlFlow;\n \n@@ -257,12 +258,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 method.sig.output()\n             }\n             // error types are considered \"builtin\"\n-            Err(()) if lhs_ty.references_error() || rhs_ty.references_error() => {\n-                self.tcx.ty_error()\n-            }\n-            Err(()) => {\n+            Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => self.tcx.ty_error(),\n+            Err(errors) => {\n                 let source_map = self.tcx.sess.source_map();\n-                let (mut err, missing_trait, use_output, involves_fn) = match is_assign {\n+                let (mut err, missing_trait, use_output) = match is_assign {\n                     IsAssign::Yes => {\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n@@ -289,7 +288,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             hir::BinOpKind::Shr => Some(\"std::ops::ShrAssign\"),\n                             _ => None,\n                         };\n-                        (err, missing_trait, false, false)\n+                        self.note_unmet_impls_on_type(&mut err, errors);\n+                        (err, missing_trait, false)\n                     }\n                     IsAssign::No => {\n                         let (message, missing_trait, use_output) = match op.node {\n@@ -376,17 +376,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n                         let mut err =\n                             struct_span_err!(self.tcx.sess, op.span, E0369, \"{}\", message.as_str());\n-                        let mut involves_fn = false;\n                         if !lhs_expr.span.eq(&rhs_expr.span) {\n-                            involves_fn |= self.add_type_neq_err_label(\n+                            self.add_type_neq_err_label(\n                                 &mut err,\n                                 lhs_expr.span,\n                                 lhs_ty,\n                                 rhs_ty,\n                                 op,\n                                 is_assign,\n                             );\n-                            involves_fn |= self.add_type_neq_err_label(\n+                            self.add_type_neq_err_label(\n                                 &mut err,\n                                 rhs_expr.span,\n                                 rhs_ty,\n@@ -395,10 +394,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 is_assign,\n                             );\n                         }\n-                        (err, missing_trait, use_output, involves_fn)\n+                        self.note_unmet_impls_on_type(&mut err, errors);\n+                        (err, missing_trait, use_output)\n                     }\n                 };\n-                let mut suggested_deref = false;\n                 if let Ref(_, rty, _) = lhs_ty.kind() {\n                     if {\n                         self.infcx.type_is_copy_modulo_regions(self.param_env, rty, lhs_expr.span)\n@@ -423,7 +422,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 \"*\".to_string(),\n                                 rustc_errors::Applicability::MachineApplicable,\n                             );\n-                            suggested_deref = true;\n                         }\n                     }\n                 }\n@@ -474,8 +472,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             bug!(\"type param visitor stored a non type param: {:?}\", ty.kind());\n                         }\n-                    } else if !suggested_deref && !involves_fn {\n-                        suggest_impl_missing(&mut err, lhs_ty, missing_trait);\n                     }\n                 }\n                 err.emit();\n@@ -665,7 +661,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.write_method_call(ex.hir_id, method);\n                 method.sig.output()\n             }\n-            Err(()) => {\n+            Err(errors) => {\n                 let actual = self.resolve_vars_if_possible(operand_ty);\n                 if !actual.references_error() {\n                     let mut err = struct_span_err!(\n@@ -720,12 +716,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             Str | Never | Char | Tuple(_) | Array(_, _) => {}\n                             Ref(_, lty, _) if *lty.kind() == Str => {}\n                             _ => {\n-                                let missing_trait = match op {\n-                                    hir::UnOp::Neg => \"std::ops::Neg\",\n-                                    hir::UnOp::Not => \"std::ops::Not\",\n-                                    hir::UnOp::Deref => \"std::ops::UnDerf\",\n-                                };\n-                                suggest_impl_missing(&mut err, operand_ty, missing_trait);\n+                                self.note_unmet_impls_on_type(&mut err, errors);\n                             }\n                         }\n                     }\n@@ -741,7 +732,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lhs_ty: Ty<'tcx>,\n         other_tys: &[Ty<'tcx>],\n         op: Op,\n-    ) -> Result<MethodCallee<'tcx>, ()> {\n+    ) -> Result<MethodCallee<'tcx>, Vec<FulfillmentError<'tcx>>> {\n         let lang = self.tcx.lang_items();\n \n         let span = match op {\n@@ -820,22 +811,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Op::Unary(..) => 0,\n             },\n         ) {\n-            return Err(());\n+            return Err(vec![]);\n         }\n \n+        let opname = Ident::with_dummy_span(opname);\n         let method = trait_did.and_then(|trait_did| {\n-            let opname = Ident::with_dummy_span(opname);\n             self.lookup_method_in_trait(span, opname, trait_did, lhs_ty, Some(other_tys))\n         });\n \n-        match method {\n-            Some(ok) => {\n+        match (method, trait_did) {\n+            (Some(ok), _) => {\n                 let method = self.register_infer_ok_obligations(ok);\n                 self.select_obligations_where_possible(false, |_| {});\n-\n                 Ok(method)\n             }\n-            None => Err(()),\n+            (None, None) => Err(vec![]),\n+            (None, Some(trait_did)) => {\n+                let (obligation, _) =\n+                    self.obligation_for_method(span, trait_did, lhs_ty, Some(other_tys));\n+                let mut fulfill = <dyn TraitEngine<'_>>::new(self.tcx);\n+                fulfill.register_predicate_obligation(self, obligation);\n+                Err(match fulfill.select_where_possible(&self.infcx) {\n+                    Err(errors) => errors,\n+                    _ => vec![],\n+                })\n+            }\n         }\n     }\n }\n@@ -962,18 +962,6 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n     }\n }\n \n-/// If applicable, note that an implementation of `trait` for `ty` may fix the error.\n-fn suggest_impl_missing(err: &mut DiagnosticBuilder<'_>, ty: Ty<'_>, missing_trait: &str) {\n-    if let Adt(def, _) = ty.peel_refs().kind() {\n-        if def.did.is_local() {\n-            err.note(&format!(\n-                \"an implementation of `{}` might be missing for `{}`\",\n-                missing_trait, ty\n-            ));\n-        }\n-    }\n-}\n-\n fn suggest_constraining_param(\n     tcx: TyCtxt<'_>,\n     body_id: hir::HirId,"}, {"sha": "73c9f86e0022088e63e56a288523330ebe0a89ae", "filename": "src/test/ui/assignment-operator-unimplemented.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fassignment-operator-unimplemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fassignment-operator-unimplemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassignment-operator-unimplemented.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -6,7 +6,22 @@ LL |   a += *b;\n    |   |\n    |   cannot use `+=` on type `Foo`\n    |\n-   = note: an implementation of `std::ops::AddAssign` might be missing for `Foo`\n+note: an implementation of `AddAssign<_>` might be missing for `Foo`\n+  --> $DIR/assignment-operator-unimplemented.rs:1:1\n+   |\n+LL | struct Foo;\n+   | ^^^^^^^^^^^ must implement `AddAssign<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait AddAssign<Rhs = Self> {\n+LL | |     /// Performs the `+=` operation.\n+LL | |     ///\n+LL | |     /// # Example\n+...  |\n+LL | |     fn add_assign(&mut self, rhs: Rhs);\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "10f243bab158684547064ad0a445e95f4ce22806", "filename": "src/test/ui/binop/issue-28837.stderr", "status": "modified", "additions": 198, "deletions": 15, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fbinop%2Fissue-28837.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fbinop%2Fissue-28837.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-28837.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -6,7 +6,22 @@ LL |     a + a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::ops::Add` might be missing for `A`\n+note: an implementation of `Add<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `Add<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait Add<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `+` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn add(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0369]: cannot subtract `A` from `A`\n   --> $DIR/issue-28837.rs:8:7\n@@ -16,7 +31,22 @@ LL |     a - a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::ops::Sub` might be missing for `A`\n+note: an implementation of `Sub<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `Sub<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait Sub<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `-` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn sub(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0369]: cannot multiply `A` by `A`\n   --> $DIR/issue-28837.rs:10:7\n@@ -26,7 +56,22 @@ LL |     a * a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::ops::Mul` might be missing for `A`\n+note: an implementation of `Mul<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `Mul<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait Mul<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `*` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn mul(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0369]: cannot divide `A` by `A`\n   --> $DIR/issue-28837.rs:12:7\n@@ -36,7 +81,22 @@ LL |     a / a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::ops::Div` might be missing for `A`\n+note: an implementation of `Div<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `Div<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait Div<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `/` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn div(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0369]: cannot mod `A` by `A`\n   --> $DIR/issue-28837.rs:14:7\n@@ -46,7 +106,22 @@ LL |     a % a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::ops::Rem` might be missing for `A`\n+note: an implementation of `Rem<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `Rem<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait Rem<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `%` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn rem(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0369]: no implementation for `A & A`\n   --> $DIR/issue-28837.rs:16:7\n@@ -56,7 +131,22 @@ LL |     a & a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::ops::BitAnd` might be missing for `A`\n+note: an implementation of `BitAnd<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `BitAnd<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n+   |\n+LL | / pub trait BitAnd<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `&` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn bitand(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0369]: no implementation for `A | A`\n   --> $DIR/issue-28837.rs:18:7\n@@ -66,7 +156,22 @@ LL |     a | a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::ops::BitOr` might be missing for `A`\n+note: an implementation of `BitOr<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `BitOr<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n+   |\n+LL | / pub trait BitOr<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `|` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn bitor(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0369]: no implementation for `A << A`\n   --> $DIR/issue-28837.rs:20:7\n@@ -76,7 +181,22 @@ LL |     a << a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::ops::Shl` might be missing for `A`\n+note: an implementation of `Shl<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `Shl<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n+   |\n+LL | / pub trait Shl<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `<<` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn shl(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0369]: no implementation for `A >> A`\n   --> $DIR/issue-28837.rs:22:7\n@@ -86,7 +206,22 @@ LL |     a >> a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::ops::Shr` might be missing for `A`\n+note: an implementation of `Shr<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `Shr<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n+   |\n+LL | / pub trait Shr<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `>>` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn shr(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0369]: binary operation `==` cannot be applied to type `A`\n   --> $DIR/issue-28837.rs:24:7\n@@ -96,7 +231,15 @@ LL |     a == a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `A`\n+note: an implementation of `PartialEq<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `PartialEq<_>`\n+help: consider annotating `A` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error[E0369]: binary operation `!=` cannot be applied to type `A`\n   --> $DIR/issue-28837.rs:26:7\n@@ -106,7 +249,15 @@ LL |     a != a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `A`\n+note: an implementation of `PartialEq<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `PartialEq<_>`\n+help: consider annotating `A` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error[E0369]: binary operation `<` cannot be applied to type `A`\n   --> $DIR/issue-28837.rs:28:7\n@@ -116,7 +267,15 @@ LL |     a < a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::cmp::PartialOrd` might be missing for `A`\n+note: an implementation of `PartialOrd<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `PartialOrd<_>`\n+help: consider annotating `A` with `#[derive(PartialOrd)]`\n+   |\n+LL | #[derive(PartialOrd)]\n+   |\n \n error[E0369]: binary operation `<=` cannot be applied to type `A`\n   --> $DIR/issue-28837.rs:30:7\n@@ -126,7 +285,15 @@ LL |     a <= a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::cmp::PartialOrd` might be missing for `A`\n+note: an implementation of `PartialOrd<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `PartialOrd<_>`\n+help: consider annotating `A` with `#[derive(PartialOrd)]`\n+   |\n+LL | #[derive(PartialOrd)]\n+   |\n \n error[E0369]: binary operation `>` cannot be applied to type `A`\n   --> $DIR/issue-28837.rs:32:7\n@@ -136,7 +303,15 @@ LL |     a > a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::cmp::PartialOrd` might be missing for `A`\n+note: an implementation of `PartialOrd<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `PartialOrd<_>`\n+help: consider annotating `A` with `#[derive(PartialOrd)]`\n+   |\n+LL | #[derive(PartialOrd)]\n+   |\n \n error[E0369]: binary operation `>=` cannot be applied to type `A`\n   --> $DIR/issue-28837.rs:34:7\n@@ -146,7 +321,15 @@ LL |     a >= a;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::cmp::PartialOrd` might be missing for `A`\n+note: an implementation of `PartialOrd<_>` might be missing for `A`\n+  --> $DIR/issue-28837.rs:1:1\n+   |\n+LL | struct A;\n+   | ^^^^^^^^^ must implement `PartialOrd<_>`\n+help: consider annotating `A` with `#[derive(PartialOrd)]`\n+   |\n+LL | #[derive(PartialOrd)]\n+   |\n \n error: aborting due to 15 previous errors\n "}, {"sha": "19d2425ff23f739020d4e2413e6b164a73cc956c", "filename": "src/test/ui/derives/derives-span-PartialEq-enum-struct-variant.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -7,8 +7,16 @@ LL | #[derive(PartialEq)]\n LL |      x: Error\n    |      ^^^^^^^^\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+note: an implementation of `PartialEq<_>` might be missing for `Error`\n+  --> $DIR/derives-span-PartialEq-enum-struct-variant.rs:4:1\n+   |\n+LL | struct Error;\n+   | ^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Error` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error[E0369]: binary operation `!=` cannot be applied to type `Error`\n   --> $DIR/derives-span-PartialEq-enum-struct-variant.rs:9:6\n@@ -19,8 +27,16 @@ LL | #[derive(PartialEq)]\n LL |      x: Error\n    |      ^^^^^^^^\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+note: an implementation of `PartialEq<_>` might be missing for `Error`\n+  --> $DIR/derives-span-PartialEq-enum-struct-variant.rs:4:1\n+   |\n+LL | struct Error;\n+   | ^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Error` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "419832817ca18bb073ec0302f795dbb0ee4aa4ff", "filename": "src/test/ui/derives/derives-span-PartialEq-enum.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -7,8 +7,16 @@ LL | #[derive(PartialEq)]\n LL |      Error\n    |      ^^^^^\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+note: an implementation of `PartialEq<_>` might be missing for `Error`\n+  --> $DIR/derives-span-PartialEq-enum.rs:4:1\n+   |\n+LL | struct Error;\n+   | ^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Error` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error[E0369]: binary operation `!=` cannot be applied to type `Error`\n   --> $DIR/derives-span-PartialEq-enum.rs:9:6\n@@ -19,8 +27,16 @@ LL | #[derive(PartialEq)]\n LL |      Error\n    |      ^^^^^\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+note: an implementation of `PartialEq<_>` might be missing for `Error`\n+  --> $DIR/derives-span-PartialEq-enum.rs:4:1\n+   |\n+LL | struct Error;\n+   | ^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Error` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0000f882542ae15942c2a3c2420ad051b2763006", "filename": "src/test/ui/derives/derives-span-PartialEq-struct.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -7,8 +7,16 @@ LL | struct Struct {\n LL |     x: Error\n    |     ^^^^^^^^\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+note: an implementation of `PartialEq<_>` might be missing for `Error`\n+  --> $DIR/derives-span-PartialEq-struct.rs:4:1\n+   |\n+LL | struct Error;\n+   | ^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Error` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error[E0369]: binary operation `!=` cannot be applied to type `Error`\n   --> $DIR/derives-span-PartialEq-struct.rs:8:5\n@@ -19,8 +27,16 @@ LL | struct Struct {\n LL |     x: Error\n    |     ^^^^^^^^\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+note: an implementation of `PartialEq<_>` might be missing for `Error`\n+  --> $DIR/derives-span-PartialEq-struct.rs:4:1\n+   |\n+LL | struct Error;\n+   | ^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Error` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "07fa900a8c8295d2dad5fdd3b3bc397048e07bef", "filename": "src/test/ui/derives/derives-span-PartialEq-tuple-struct.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -7,8 +7,16 @@ LL | struct Struct(\n LL |     Error\n    |     ^^^^^\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+note: an implementation of `PartialEq<_>` might be missing for `Error`\n+  --> $DIR/derives-span-PartialEq-tuple-struct.rs:4:1\n+   |\n+LL | struct Error;\n+   | ^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Error` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error[E0369]: binary operation `!=` cannot be applied to type `Error`\n   --> $DIR/derives-span-PartialEq-tuple-struct.rs:8:5\n@@ -19,8 +27,16 @@ LL | struct Struct(\n LL |     Error\n    |     ^^^^^\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+note: an implementation of `PartialEq<_>` might be missing for `Error`\n+  --> $DIR/derives-span-PartialEq-tuple-struct.rs:4:1\n+   |\n+LL | struct Error;\n+   | ^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Error` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e322db97fab493ab59b02d9148cfeb686ab5b7b2", "filename": "src/test/ui/derives/deriving-no-inner-impl-error-message.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -7,8 +7,16 @@ LL | struct E {\n LL |     x: NoCloneOrEq\n    |     ^^^^^^^^^^^^^^\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `NoCloneOrEq`\n+note: an implementation of `PartialEq<_>` might be missing for `NoCloneOrEq`\n+  --> $DIR/deriving-no-inner-impl-error-message.rs:1:1\n+   |\n+LL | struct NoCloneOrEq;\n+   | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `NoCloneOrEq` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error[E0369]: binary operation `!=` cannot be applied to type `NoCloneOrEq`\n   --> $DIR/deriving-no-inner-impl-error-message.rs:5:5\n@@ -19,8 +27,16 @@ LL | struct E {\n LL |     x: NoCloneOrEq\n    |     ^^^^^^^^^^^^^^\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `NoCloneOrEq`\n+note: an implementation of `PartialEq<_>` might be missing for `NoCloneOrEq`\n+  --> $DIR/deriving-no-inner-impl-error-message.rs:1:1\n+   |\n+LL | struct NoCloneOrEq;\n+   | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `NoCloneOrEq` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error[E0277]: the trait bound `NoCloneOrEq: Clone` is not satisfied\n   --> $DIR/deriving-no-inner-impl-error-message.rs:10:5"}, {"sha": "7b9788ca0fef3215473721f79f764e7bf7284bee", "filename": "src/test/ui/destructuring-assignment/note-unsupported.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -99,7 +99,22 @@ LL |     S { x: a, y: b } += s;\n    |     |\n    |     cannot use `+=` on type `S`\n    |\n-   = note: an implementation of `std::ops::AddAssign` might be missing for `S`\n+note: an implementation of `AddAssign<_>` might be missing for `S`\n+  --> $DIR/note-unsupported.rs:1:1\n+   |\n+LL | struct S { x: u8, y: u8 }\n+   | ^^^^^^^^ must implement `AddAssign<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait AddAssign<Rhs = Self> {\n+LL | |     /// Performs the `+=` operation.\n+LL | |     ///\n+LL | |     /// # Example\n+...  |\n+LL | |     fn add_assign(&mut self, rhs: Rhs);\n+LL | | }\n+   | |_^\n \n error[E0067]: invalid left-hand side of assignment\n   --> $DIR/note-unsupported.rs:17:22"}, {"sha": "b8cd7b7464ae3662b1214df44c28d67ccd6923a4", "filename": "src/test/ui/error-festival.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Ferror-festival.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Ferror-festival.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-festival.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -36,7 +36,22 @@ error[E0600]: cannot apply unary operator `!` to type `Question`\n LL |     !Question::Yes;\n    |     ^^^^^^^^^^^^^^ cannot apply unary operator `!`\n    |\n-   = note: an implementation of `std::ops::Not` might be missing for `Question`\n+note: an implementation of `Not` might be missing for `Question`\n+  --> $DIR/error-festival.rs:1:1\n+   |\n+LL | enum Question {\n+   | ^^^^^^^^^^^^^ must implement `Not`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n+   |\n+LL | / pub trait Not {\n+LL | |     /// The resulting type after applying the `!` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn not(self) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0604]: only `u8` can be cast as `char`, not `u32`\n   --> $DIR/error-festival.rs:25:5"}, {"sha": "0b1cc9c768407f0af30fce4ac97bd49f32b88c6e", "filename": "src/test/ui/issues/issue-14091-2.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fissues%2Fissue-14091-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fissues%2Fissue-14091-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14091-2.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -4,7 +4,22 @@ error[E0600]: cannot apply unary operator `!` to type `BytePos`\n LL |     assert!(x, x);\n    |     ^^^^^^^^^^^^^^ cannot apply unary operator `!`\n    |\n-   = note: an implementation of `std::ops::Not` might be missing for `BytePos`\n+note: an implementation of `Not` might be missing for `BytePos`\n+  --> $DIR/issue-14091-2.rs:6:1\n+   |\n+LL | pub struct BytePos(pub u32);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `Not`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n+   |\n+LL | / pub trait Not {\n+LL | |     /// The resulting type after applying the `!` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn not(self) -> Self::Output;\n+LL | | }\n+   | |_^\n    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "cdb196d4ff23f8258170573f4c29b5addcd8b67d", "filename": "src/test/ui/issues/issue-31076.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fissues%2Fissue-31076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fissues%2Fissue-31076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31076.rs?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -11,7 +11,7 @@ impl Add<i32> for i32 {}\n \n fn main() {\n     let x = 5 + 6;\n-    //~^ ERROR cannot add `{integer}` to `{integer}`\n+    //~^ ERROR cannot add `i32` to `{integer}`\n     let y = 5i32 + 6i32;\n     //~^ ERROR cannot add `i32` to `i32`\n }"}, {"sha": "ac0d9dc7528794050aa680e3a3c0b0a64b502b1e", "filename": "src/test/ui/issues/issue-31076.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fissues%2Fissue-31076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fissues%2Fissue-31076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31076.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -1,8 +1,8 @@\n-error[E0369]: cannot add `{integer}` to `{integer}`\n+error[E0369]: cannot add `i32` to `{integer}`\n   --> $DIR/issue-31076.rs:13:15\n    |\n LL |     let x = 5 + 6;\n-   |             - ^ - {integer}\n+   |             - ^ - i32\n    |             |\n    |             {integer}\n "}, {"sha": "d5c24e1bb6cdb347b2e01280466603c442af8a40", "filename": "src/test/ui/issues/issue-3820.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fissues%2Fissue-3820.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fissues%2Fissue-3820.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3820.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -6,7 +6,22 @@ LL |     let w = u * 3;\n    |             |\n    |             Thing\n    |\n-   = note: an implementation of `std::ops::Mul` might be missing for `Thing`\n+note: an implementation of `Mul<_>` might be missing for `Thing`\n+  --> $DIR/issue-3820.rs:1:1\n+   |\n+LL | struct Thing {\n+   | ^^^^^^^^^^^^ must implement `Mul<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait Mul<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `*` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn mul(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "478e025bed230ab1e6cfc2e70679ed63bcebb8d4", "filename": "src/test/ui/issues/issue-62375.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fissues%2Fissue-62375.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fissues%2Fissue-62375.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-62375.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -6,7 +6,15 @@ LL |     a == A::Value;\n    |     |\n    |     A\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `A`\n+note: an implementation of `PartialEq<_>` might be missing for `A`\n+  --> $DIR/issue-62375.rs:1:1\n+   |\n+LL | enum A {\n+   | ^^^^^^ must implement `PartialEq<_>`\n+help: consider annotating `A` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "c1183e053eb43095a58050f9b37cbefbeb7fce67", "filename": "src/test/ui/methods/method-call-err-msg.stderr", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -55,6 +55,17 @@ LL |      .take()\n    = note: the following trait bounds were not satisfied:\n            `Foo: Iterator`\n            which is required by `&mut Foo: Iterator`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL | / pub trait Iterator {\n+LL | |     /// The type of the elements being iterated over.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Item;\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `take`, perhaps you need to implement it:\n            candidate #1: `Iterator`"}, {"sha": "b105f03f81cdd6f95169d5c34bf631ce93ab5cfe", "filename": "src/test/ui/never_type/defaulted-never-note.fallback.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -5,7 +5,7 @@ LL |     foo(_x);\n    |     ^^^ the trait `ImplementedForUnitButNotNever` is not implemented for `!`\n    |\n    = note: this trait is implemented for `()`\n-   = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information).\n+   = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information)\n    = help: did you intend to use the type `()` here instead?\n note: required by a bound in `foo`\n   --> $DIR/defaulted-never-note.rs:25:11"}, {"sha": "72cd69380573e5a2d0483c3642d94e951fffd66f", "filename": "src/test/ui/never_type/diverging-fallback-no-leak.fallback.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -5,7 +5,7 @@ LL |     unconstrained_arg(return);\n    |     ^^^^^^^^^^^^^^^^^ the trait `Test` is not implemented for `!`\n    |\n    = note: this trait is implemented for `()`\n-   = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information).\n+   = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information)\n    = help: did you intend to use the type `()` here instead?\n note: required by a bound in `unconstrained_arg`\n   --> $DIR/diverging-fallback-no-leak.rs:12:25"}, {"sha": "c94adfe4ab38aa8815bb665d93a6db3454fc002d", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -30,7 +30,22 @@ LL |     let _ = |A | B: E| ();\n    |                  |\n    |                  E\n    |\n-   = note: an implementation of `std::ops::BitOr` might be missing for `E`\n+note: an implementation of `BitOr<_>` might be missing for `E`\n+  --> $DIR/or-patterns-syntactic-fail.rs:6:1\n+   |\n+LL | enum E { A, B }\n+   | ^^^^^^ must implement `BitOr<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n+   |\n+LL | / pub trait BitOr<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `|` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn bitor(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "92e86bf5d6c91906cde0080801647f136cf18108", "filename": "src/test/ui/span/issue-39018.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -20,7 +20,22 @@ LL |     let y = World::Hello + World::Goodbye;\n    |             |\n    |             World\n    |\n-   = note: an implementation of `std::ops::Add` might be missing for `World`\n+note: an implementation of `Add<_>` might be missing for `World`\n+  --> $DIR/issue-39018.rs:15:1\n+   |\n+LL | enum World {\n+   | ^^^^^^^^^^ must implement `Add<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait Add<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `+` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn add(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0369]: cannot add `String` to `&str`\n   --> $DIR/issue-39018.rs:11:22"}, {"sha": "ce981bc00982afc380777638fe7e86907da24296", "filename": "src/test/ui/specialization/defaultimpl/specialization-trait-not-implemented.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -22,6 +22,14 @@ LL |     println!(\"{}\", MyStruct.foo_one());\n    |\n    = note: the following trait bounds were not satisfied:\n            `MyStruct: Foo`\n+note: the following trait must be implemented\n+  --> $DIR/specialization-trait-not-implemented.rs:7:1\n+   |\n+LL | / trait Foo {\n+LL | |     fn foo_one(&self) -> &'static str;\n+LL | |     fn foo_two(&self) -> &'static str;\n+LL | | }\n+   | |_^\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Foo` defines an item `foo_one`, perhaps you need to implement it\n   --> $DIR/specialization-trait-not-implemented.rs:7:1"}, {"sha": "d18c24e53d030ddfe9cd63570b9e0e90c1d107d0", "filename": "src/test/ui/suggestions/invalid-bin-op.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -6,7 +6,16 @@ LL |     let _ = s == t;\n    |             |\n    |             S<T>\n    |\n+note: an implementation of `PartialEq<_>` might be missing for `S<T>`\n+  --> $DIR/invalid-bin-op.rs:5:1\n+   |\n+LL | struct S<T>(T);\n+   | ^^^^^^^^^^^^^^^ must implement `PartialEq<_>`\n    = note: the trait `std::cmp::PartialEq` is not implemented for `S<T>`\n+help: consider annotating `S<T>` with `#[derive(PartialEq)]`\n+   |\n+LL | #[derive(PartialEq)]\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "ebce257b278bb43b8aea0bf609ab6e257a46e597", "filename": "src/test/ui/type/type-ascription-precedence.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-precedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8fc076f231699d9a44fc44a1e298ea4f70fdb48/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-precedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-precedence.stderr?ref=e8fc076f231699d9a44fc44a1e298ea4f70fdb48", "patch": "@@ -28,7 +28,22 @@ error[E0600]: cannot apply unary operator `-` to type `Z`\n LL |     -(S: Z);\n    |     ^^^^^^^ cannot apply unary operator `-`\n    |\n-   = note: an implementation of `std::ops::Neg` might be missing for `Z`\n+note: an implementation of `std::ops::Neg` might be missing for `Z`\n+  --> $DIR/type-ascription-precedence.rs:9:1\n+   |\n+LL | struct Z;\n+   | ^^^^^^^^^ must implement `std::ops::Neg`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait Neg {\n+LL | |     /// The resulting type after applying the `-` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn neg(self) -> Self::Output;\n+LL | | }\n+   | |_^\n \n error[E0308]: mismatched types\n   --> $DIR/type-ascription-precedence.rs:45:5"}]}