{"sha": "217beab62aeb8a0dce19ae744a664c9041688f56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxN2JlYWI2MmFlYjhhMGRjZTE5YWU3NDRhNjY0YzkwNDE2ODhmNTY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-15T12:17:09Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-15T12:18:54Z"}, "message": "Reduce the amount of calls to layout_of", "tree": {"sha": "689f90a5d819a463059c4b21218f4f92004c7243", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/689f90a5d819a463059c4b21218f4f92004c7243"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/217beab62aeb8a0dce19ae744a664c9041688f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/217beab62aeb8a0dce19ae744a664c9041688f56", "html_url": "https://github.com/rust-lang/rust/commit/217beab62aeb8a0dce19ae744a664c9041688f56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/217beab62aeb8a0dce19ae744a664c9041688f56/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0669a49b1068beaf839197f10e6bd4027b340639", "url": "https://api.github.com/repos/rust-lang/rust/commits/0669a49b1068beaf839197f10e6bd4027b340639", "html_url": "https://github.com/rust-lang/rust/commit/0669a49b1068beaf839197f10e6bd4027b340639"}], "stats": {"total": 111, "additions": 54, "deletions": 57}, "files": [{"sha": "00e7ae48b798aaafc75acc0b4b710b86665de019", "filename": "src/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=217beab62aeb8a0dce19ae744a664c9041688f56", "patch": "@@ -276,7 +276,7 @@ fn local_place<'tcx>(\n     let place = if is_ssa {\n         CPlace::new_var(fx, local, layout)\n     } else {\n-        CPlace::new_stack_slot(fx, layout.ty)\n+        CPlace::new_stack_slot(fx, layout)\n     };\n \n     #[cfg(debug_assertions)]\n@@ -667,13 +667,13 @@ pub fn codegen_drop<'tcx>(\n             _ => {\n                 let arg_place = CPlace::new_stack_slot(\n                     fx,\n-                    fx.tcx.mk_ref(\n+                    fx.layout_of(fx.tcx.mk_ref(\n                         &ty::RegionKind::ReErased,\n                         TypeAndMut {\n                             ty,\n                             mutbl: crate::rustc_hir::Mutability::Mut,\n                         },\n-                    ),\n+                    )),\n                 );\n                 drop_place.write_place_ref(fx, arg_place);\n                 let arg_value = arg_place.to_cvalue(fx);"}, {"sha": "231eb64de41b8b9f67c3e4ef9794bd0cbfdf2f25", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=217beab62aeb8a0dce19ae744a664c9041688f56", "patch": "@@ -131,7 +131,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n     arg_ty: Ty<'tcx>,\n ) -> Option<CValue<'tcx>> {\n     let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fx.tcx, fx.layout_of(arg_ty));\n+    let pass_mode = get_pass_mode(fx.tcx, layout);\n \n     if let PassMode::NoPass = pass_mode {\n         return None;"}, {"sha": "5eb0170a19dd59229c34df71e7e8153874a3ccef", "filename": "src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=217beab62aeb8a0dce19ae744a664c9041688f56", "patch": "@@ -363,7 +363,7 @@ fn trans_stmt<'tcx>(\n                         }\n                         UnOp::Neg => match layout.ty.kind {\n                             ty::Int(_) => {\n-                                let zero = CValue::const_val(fx, layout.ty, 0);\n+                                let zero = CValue::const_val(fx, layout, 0);\n                                 crate::num::trans_int_binop(fx, BinOp::Sub, zero, operand)\n                             }\n                             ty::Float(_) => {\n@@ -528,7 +528,7 @@ fn trans_stmt<'tcx>(\n                         .ty\n                         .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all()));\n                     let ty_size = fx.layout_of(fx.monomorphize(ty)).size.bytes();\n-                    let val = CValue::const_val(fx, fx.tcx.types.usize, ty_size.into());\n+                    let val = CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), ty_size.into());\n                     lval.write_cvalue(fx, val);\n                 }\n                 Rvalue::Aggregate(kind, operands) => match **kind {"}, {"sha": "6d33f71072ae2f8f8ce593ce9eaadcfa221432f3", "filename": "src/constant.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=217beab62aeb8a0dce19ae744a664c9041688f56", "patch": "@@ -43,11 +43,11 @@ pub fn codegen_static(constants_cx: &mut ConstantCx, def_id: DefId) {\n fn codegen_static_ref<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     def_id: DefId,\n-    ty: Ty<'tcx>,\n+    layout: TyLayout<'tcx>,\n ) -> CPlace<'tcx> {\n     let linkage = crate::linkage::get_static_ref_linkage(fx.tcx, def_id);\n     let data_id = data_id_for_static(fx.tcx, fx.module, def_id, linkage);\n-    cplace_for_dataid(fx, ty, data_id)\n+    cplace_for_dataid(fx, layout, data_id)\n }\n \n pub fn trans_constant<'tcx>(\n@@ -62,7 +62,7 @@ pub fn trans_constant<'tcx>(\n             return codegen_static_ref(\n                 fx,\n                 def_id,\n-                fx.monomorphize(&constant.literal.ty),\n+                fx.layout_of(fx.monomorphize(&constant.literal.ty)),\n             ).to_cvalue(fx);\n         }\n         ConstKind::Unevaluated(def_id, ref substs, promoted) => {\n@@ -137,13 +137,13 @@ pub fn trans_const_value<'tcx>(\n                     let bits = const_.val.try_to_bits(layout.size).unwrap_or_else(|| {\n                         panic!(\"{:?}\\n{:?}\", const_, layout);\n                     });\n-                    CValue::const_val(fx, ty, bits)\n+                    CValue::const_val(fx, layout, bits)\n                 }\n                 ty::Int(_) => {\n                     let bits = const_.val.try_to_bits(layout.size).unwrap();\n                     CValue::const_val(\n                         fx,\n-                        ty,\n+                        layout,\n                         rustc::mir::interpret::sign_extend(bits, layout.size),\n                     )\n                 }\n@@ -228,7 +228,7 @@ fn trans_const_place<'tcx>(\n     let alloc_id = fx.tcx.alloc_map.lock().create_memory_alloc(alloc);\n     fx.constants_cx.todo.insert(TodoItem::Alloc(alloc_id));\n     let data_id = data_id_for_alloc_id(fx.module, alloc_id, alloc.align);\n-    cplace_for_dataid(fx, const_.ty, data_id)\n+    cplace_for_dataid(fx, fx.layout_of(const_.ty), data_id)\n }\n \n fn data_id_for_alloc_id<B: Backend>(\n@@ -304,12 +304,11 @@ fn data_id_for_static(\n \n fn cplace_for_dataid<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    ty: Ty<'tcx>,\n+    layout: TyLayout<'tcx>,\n     data_id: DataId,\n ) -> CPlace<'tcx> {\n     let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n-    let layout = fx.layout_of(fx.monomorphize(&ty));\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n     CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)\n }"}, {"sha": "6389bd6277cef1cfb6af97f2e452b6f2b90e72f2", "filename": "src/discriminant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=217beab62aeb8a0dce19ae744a664c9041688f56", "patch": "@@ -27,7 +27,7 @@ pub fn codegen_set_discriminant<'tcx>(\n                 .discriminant_for_variant(fx.tcx, variant_index)\n                 .unwrap()\n                 .val;\n-            let discr = CValue::const_val(fx, ptr.layout().ty, to);\n+            let discr = CValue::const_val(fx, ptr.layout(), to);\n             ptr.write_cvalue(fx, discr);\n         }\n         layout::Variants::Multiple {\n@@ -45,7 +45,7 @@ pub fn codegen_set_discriminant<'tcx>(\n                 let niche = place.place_field(fx, mir::Field::new(discr_index));\n                 let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                 let niche_value = u128::from(niche_value).wrapping_add(niche_start);\n-                let niche_llval = CValue::const_val(fx, niche.layout().ty, niche_value);\n+                let niche_llval = CValue::const_val(fx, niche.layout(), niche_value);\n                 niche.write_cvalue(fx, niche_llval);\n             }\n         }\n@@ -73,7 +73,7 @@ pub fn codegen_get_discriminant<'tcx>(\n                 .ty\n                 .discriminant_for_variant(fx.tcx, *index)\n                 .map_or(u128::from(index.as_u32()), |discr| discr.val);\n-            return CValue::const_val(fx, dest_layout.ty, discr_val);\n+            return CValue::const_val(fx, dest_layout, discr_val);\n         }\n         layout::Variants::Multiple {\n             discr,"}, {"sha": "459c68baa63701f7e20bed54f2fd1aada4161870", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=217beab62aeb8a0dce19ae744a664c9041688f56", "patch": "@@ -453,7 +453,7 @@ pub fn codegen_intrinsic_call<'tcx>(\n             let layout = fx.layout_of(T);\n             let size = if layout.is_unsized() {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n-                let (size, _align) = crate::unsize::size_and_align_of_dst(fx, layout.ty, info);\n+                let (size, _align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n                 size\n             } else {\n                 fx\n@@ -467,7 +467,7 @@ pub fn codegen_intrinsic_call<'tcx>(\n             let layout = fx.layout_of(T);\n             let align = if layout.is_unsized() {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n-                let (_size, align) = crate::unsize::size_and_align_of_dst(fx, layout.ty, info);\n+                let (_size, align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n                 align\n             } else {\n                 fx\n@@ -951,7 +951,7 @@ pub fn codegen_intrinsic_call<'tcx>(\n \n             fx.bcx.ins().call_indirect(f_sig, f, &[data]);\n \n-            let ret_val = CValue::const_val(fx, ret.layout().ty, 0);\n+            let ret_val = CValue::const_val(fx, ret.layout(), 0);\n             ret.write_cvalue(fx, ret_val);\n         };\n     }"}, {"sha": "e11143d6bd2c4b37651003e04fa4da00ce9bdbba", "filename": "src/num.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=217beab62aeb8a0dce19ae744a664c9041688f56", "patch": "@@ -285,10 +285,11 @@ pub fn trans_checked_int_binop<'tcx>(\n     };\n \n     let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n+\n+    // FIXME directly write to result place instead\n     let out_place = CPlace::new_stack_slot(\n         fx,\n-        fx.tcx\n-            .mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()),\n+        fx.layout_of(fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter())),\n     );\n     let out_layout = out_place.layout();\n     out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));"}, {"sha": "ab2b2f201a212902ac08968b4ab98200737d61ae", "filename": "src/unsize.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=217beab62aeb8a0dce19ae744a664c9041688f56", "patch": "@@ -28,7 +28,9 @@ pub fn unsized_info<'tcx>(\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n+        (_, &ty::Dynamic(ref data, ..)) => {\n+            crate::vtable::get_vtable(fx, fx.layout_of(source), data.principal())\n+        }\n         _ => bug!(\n             \"unsized_info: invalid unsizing {:?} -> {:?}\",\n             source,\n@@ -38,29 +40,27 @@ pub fn unsized_info<'tcx>(\n }\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-pub fn unsize_thin_ptr<'tcx>(\n+fn unsize_thin_ptr<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     src: Value,\n-    src_ty: Ty<'tcx>,\n-    dst_ty: Ty<'tcx>,\n+    src_layout: TyLayout<'tcx>,\n+    dst_layout: TyLayout<'tcx>,\n ) -> (Value, Value) {\n-    match (&src_ty.kind, &dst_ty.kind) {\n+    match (&src_layout.ty.kind, &dst_layout.ty.kind) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n         | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(!fx.layout_of(a).is_unsized());\n             (src, unsized_info(fx, a, b, None))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n+            let (a, b) = (src_layout.ty.boxed_ty(), dst_layout.ty.boxed_ty());\n             assert!(!fx.layout_of(a).is_unsized());\n             (src, unsized_info(fx, a, b, None))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            let src_layout = fx.layout_of(src_ty);\n-            let dst_layout = fx.layout_of(dst_ty);\n             let mut result = None;\n             for i in 0..src_layout.fields.count() {\n                 let src_f = src_layout.field(fx, i);\n@@ -74,7 +74,7 @@ pub fn unsize_thin_ptr<'tcx>(\n                 let dst_f = dst_layout.field(fx, i);\n                 assert_ne!(src_f.ty, dst_f.ty);\n                 assert_eq!(result, None);\n-                result = Some(unsize_thin_ptr(fx, src, src_f.ty, dst_f.ty));\n+                result = Some(unsize_thin_ptr(fx, src, src_f, dst_f));\n             }\n             result.unwrap()\n         }\n@@ -101,7 +101,7 @@ pub fn coerce_unsized_into<'tcx>(\n             src.load_scalar_pair(fx)\n         } else {\n             let base = src.load_scalar(fx);\n-            unsize_thin_ptr(fx, base, src_ty, dst_ty)\n+            unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n         };\n         dst.write_cvalue(fx, CValue::by_val_pair(base, info, dst.layout()));\n     };\n@@ -139,10 +139,9 @@ pub fn coerce_unsized_into<'tcx>(\n \n pub fn size_and_align_of_dst<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    ty: Ty<'tcx>,\n+    layout: TyLayout<'tcx>,\n     info: Value,\n ) -> (Value, Value) {\n-    let layout = fx.layout_of(ty);\n     if !layout.is_unsized() {\n         let size = fx\n             .bcx\n@@ -154,7 +153,7 @@ pub fn size_and_align_of_dst<'tcx>(\n             .iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n         return (size, align);\n     }\n-    match ty.kind {\n+    match layout.ty.kind {\n         ty::Dynamic(..) => {\n             // load size/align from vtable\n             (\n@@ -177,7 +176,7 @@ pub fn size_and_align_of_dst<'tcx>(\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n             // want to avoid, as the unsized field's alignment could be smaller.\n-            assert!(!ty.is_simd());\n+            assert!(!layout.ty.is_simd());\n \n             let i = layout.fields.count() - 1;\n             let sized_size = layout.fields.offset(i).bytes();\n@@ -186,8 +185,8 @@ pub fn size_and_align_of_dst<'tcx>(\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let field_ty = layout.field(fx, i).ty;\n-            let (unsized_size, mut unsized_align) = size_and_align_of_dst(fx, field_ty, info);\n+            let field_layout = layout.field(fx, i);\n+            let (unsized_size, mut unsized_align) = size_and_align_of_dst(fx, field_layout, info);\n \n             // FIXME (#26403, #27023): We should be adding padding\n             // to `sized_size` (to accommodate the `unsized_align`\n@@ -200,7 +199,7 @@ pub fn size_and_align_of_dst<'tcx>(\n             let size = fx.bcx.ins().iadd_imm(unsized_size, sized_size as i64);\n \n             // Packed types ignore the alignment of their fields.\n-            if let ty::Adt(def, _) = ty.kind {\n+            if let ty::Adt(def, _) = layout.ty.kind {\n                 if def.repr.packed() {\n                     unsized_align = sized_align;\n                 }"}, {"sha": "95913256f24ca16b69fb6a04653534ac3caa1261", "filename": "src/value_and_place.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=217beab62aeb8a0dce19ae744a664c9041688f56", "patch": "@@ -32,7 +32,7 @@ fn codegen_field<'tcx>(\n             _ => {\n                 // We have to align the offset for DST's\n                 let unaligned_offset = field_offset.bytes();\n-                let (_, unsized_align) = crate::unsize::size_and_align_of_dst(fx, field_layout.ty, extra);\n+                let (_, unsized_align) = crate::unsize::size_and_align_of_dst(fx, field_layout, extra);\n \n                 let one = fx.bcx.ins().iconst(pointer_ty(fx.tcx), 1);\n                 let align_sub_1 = fx.bcx.ins().isub(unsized_align, one);\n@@ -88,12 +88,13 @@ impl<'tcx> CValue<'tcx> {\n         self.1\n     }\n \n+    // FIXME remove\n     pub fn force_stack<'a>(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> Pointer {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr) => ptr,\n             CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => {\n-                let cplace = CPlace::new_stack_slot(fx, layout.ty);\n+                let cplace = CPlace::new_stack_slot(fx, layout);\n                 cplace.write_cvalue(fx, self);\n                 cplace.to_ptr(fx)\n             }\n@@ -196,13 +197,12 @@ impl<'tcx> CValue<'tcx> {\n     /// If `ty` is signed, `const_val` must already be sign extended.\n     pub fn const_val<'a>(\n         fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-        ty: Ty<'tcx>,\n+        layout: TyLayout<'tcx>,\n         const_val: u128,\n     ) -> CValue<'tcx> {\n-        let clif_ty = fx.clif_type(ty).unwrap();\n-        let layout = fx.layout_of(ty);\n+        let clif_ty = fx.clif_type(layout.ty).unwrap();\n \n-        let val = match ty.kind {\n+        let val = match layout.ty.kind {\n             ty::TyKind::Uint(UintTy::U128) | ty::TyKind::Int(IntTy::I128) => {\n                 let lsb = fx.bcx.ins().iconst(types::I64, const_val as u64 as i64);\n                 let msb = fx\n@@ -226,7 +226,7 @@ impl<'tcx> CValue<'tcx> {\n             ty::TyKind::Int(_) => fx.bcx.ins().iconst(clif_ty, const_val as i128 as i64),\n             _ => panic!(\n                 \"CValue::const_val for non bool/integer/pointer type {:?} is not allowed\",\n-                ty\n+                layout.ty\n             ),\n         };\n \n@@ -270,9 +270,8 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub fn new_stack_slot(\n         fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-        ty: Ty<'tcx>,\n+        layout: TyLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        let layout = fx.layout_of(ty);\n         assert!(!layout.is_unsized());\n         if layout.size.bytes() == 0 {\n             return CPlace {"}, {"sha": "7eaf8ffdada7c8818520aad9421e0ed1cce63cb4", "filename": "src/vtable.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217beab62aeb8a0dce19ae744a664c9041688f56/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=217beab62aeb8a0dce19ae744a664c9041688f56", "patch": "@@ -60,14 +60,14 @@ pub fn get_ptr_and_method_ref<'tcx>(\n \n pub fn get_vtable<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    ty: Ty<'tcx>,\n+    layout: TyLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n-    let data_id = if let Some(data_id) = fx.vtables.get(&(ty, trait_ref)) {\n+    let data_id = if let Some(data_id) = fx.vtables.get(&(layout.ty, trait_ref)) {\n         *data_id\n     } else {\n-        let data_id = build_vtable(fx, ty, trait_ref);\n-        fx.vtables.insert((ty, trait_ref), data_id);\n+        let data_id = build_vtable(fx, layout, trait_ref);\n+        fx.vtables.insert((layout.ty, trait_ref), data_id);\n         data_id\n     };\n \n@@ -77,20 +77,20 @@ pub fn get_vtable<'tcx>(\n \n fn build_vtable<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    ty: Ty<'tcx>,\n+    layout: TyLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> DataId {\n     let tcx = fx.tcx;\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n \n     let drop_in_place_fn =\n-        import_function(tcx, fx.module, Instance::resolve_drop_in_place(tcx, ty));\n+        import_function(tcx, fx.module, Instance::resolve_drop_in_place(tcx, layout.ty));\n \n     let mut components: Vec<_> = vec![Some(drop_in_place_fn), None, None];\n \n     let methods_root;\n     let methods = if let Some(trait_ref) = trait_ref {\n-        methods_root = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n+        methods_root = tcx.vtable_methods(trait_ref.with_self_ty(tcx, layout.ty));\n         methods_root.iter()\n     } else {\n         (&[]).iter()\n@@ -112,7 +112,6 @@ fn build_vtable<'tcx>(\n         .collect::<Vec<u8>>()\n         .into_boxed_slice();\n \n-    let layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n     write_usize(fx.tcx, &mut data, SIZE_INDEX, layout.size.bytes());\n     write_usize(fx.tcx, &mut data, ALIGN_INDEX, layout.align.abi.bytes());\n     data_ctx.define(data);\n@@ -127,7 +126,7 @@ fn build_vtable<'tcx>(\n     let data_id = fx\n         .module\n         .declare_data(\n-            &format!(\"vtable.{:?}.for.{:?}\", trait_ref, ty),\n+            &format!(\"vtable.{:?}.for.{:?}\", trait_ref, layout.ty),\n             Linkage::Local,\n             false,\n             Some("}]}