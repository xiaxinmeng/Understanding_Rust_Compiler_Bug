{"sha": "d489ea777d38c5d44a5394bcd4bdcc69eb3cda40", "node_id": "C_kwDOAAsO6NoAKGQ0ODllYTc3N2QzOGM1ZDQ0YTUzOTRiY2Q0YmRjYzY5ZWIzY2RhNDA", "commit": {"author": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2022-03-11T23:21:35Z"}, "committer": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2022-03-23T18:59:37Z"}, "message": "Refactor set_ptr_value as with_metadata_of\n\nBy reversing the arguments we achieve several clarifications:\n\n- The function closely resembles `cast` but with an argument to\n  initialized the metadata. This is easier to teach and answers an long\n  outstanding question that had restricted cast to `Sized` targets\n  initially. See multiples reviews of\n  <https://github.com/rust-lang/rust/pull/47631>\n- The 'object identity', in the form or provenance, is now preserved\n  from the call receiver to the result. This helps explain the method as\n  a builder-style, instead of some kind of setter that would modify\n  something in-place. Ensuring that the result has the identity of the\n  `self` argument is also beneficial for an intuition of effects.\n- An outstanding concern, 'Correct argument type', is avoided by not\n  committing to any specific argument type. This is consistent with cast\n  which does not require its receiver to be a raw address.", "tree": {"sha": "985baf4f181fa45d9d28ed993aa2b5e04280a2cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/985baf4f181fa45d9d28ed993aa2b5e04280a2cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40", "html_url": "https://github.com/rust-lang/rust/commit/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40/comments", "author": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9b45e601065c3fb71a4f67481e912391d075621", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b45e601065c3fb71a4f67481e912391d075621", "html_url": "https://github.com/rust-lang/rust/commit/c9b45e601065c3fb71a4f67481e912391d075621"}], "stats": {"total": 183, "additions": 95, "deletions": 88}, "files": [{"sha": "881472c925d535644f9653fa6f19528d18f69fb1", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=d489ea777d38c5d44a5394bcd4bdcc69eb3cda40", "patch": "@@ -895,7 +895,7 @@ impl<T: ?Sized> Rc<T> {\n \n         // Reverse the offset to find the original RcBox.\n         let rc_ptr =\n-            unsafe { (ptr as *mut RcBox<T>).set_ptr_value((ptr as *mut u8).offset(-offset)) };\n+            unsafe { (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut RcBox<T>) };\n \n         unsafe { Self::from_ptr(rc_ptr) }\n     }\n@@ -1338,7 +1338,7 @@ impl<T: ?Sized> Rc<T> {\n             Self::allocate_for_layout(\n                 Layout::for_value(&*ptr),\n                 |layout| Global.allocate(layout),\n-                |mem| (ptr as *mut RcBox<T>).set_ptr_value(mem),\n+                |mem| mem.with_metadata_of(ptr as *mut RcBox<T>),\n             )\n         }\n     }\n@@ -2263,7 +2263,7 @@ impl<T: ?Sized> Weak<T> {\n             let offset = unsafe { data_offset(ptr) };\n             // Thus, we reverse the offset to get the whole RcBox.\n             // SAFETY: the pointer originated from a Weak, so this offset is safe.\n-            unsafe { (ptr as *mut RcBox<T>).set_ptr_value((ptr as *mut u8).offset(-offset)) }\n+            unsafe { (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut RcBox<T>) }\n         };\n \n         // SAFETY: we now have recovered the original Weak pointer, so can create the Weak."}, {"sha": "e302f874bfdd01dba99812916f36aa4864b536db", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=d489ea777d38c5d44a5394bcd4bdcc69eb3cda40", "patch": "@@ -895,7 +895,8 @@ impl<T: ?Sized> Arc<T> {\n             let offset = data_offset(ptr);\n \n             // Reverse the offset to find the original ArcInner.\n-            let arc_ptr = (ptr as *mut ArcInner<T>).set_ptr_value((ptr as *mut u8).offset(-offset));\n+            let arc_ptr =\n+                (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut ArcInner<T>);\n \n             Self::from_ptr(arc_ptr)\n         }\n@@ -1182,7 +1183,7 @@ impl<T: ?Sized> Arc<T> {\n             Self::allocate_for_layout(\n                 Layout::for_value(&*ptr),\n                 |layout| Global.allocate(layout),\n-                |mem| (ptr as *mut ArcInner<T>).set_ptr_value(mem) as *mut ArcInner<T>,\n+                |mem| mem.with_metadata_of(ptr as *mut ArcInner<T>),\n             )\n         }\n     }\n@@ -1887,7 +1888,7 @@ impl<T: ?Sized> Weak<T> {\n             let offset = unsafe { data_offset(ptr) };\n             // Thus, we reverse the offset to get the whole RcBox.\n             // SAFETY: the pointer originated from a Weak, so this offset is safe.\n-            unsafe { (ptr as *mut ArcInner<T>).set_ptr_value((ptr as *mut u8).offset(-offset)) }\n+            unsafe { (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut ArcInner<T>) }\n         };\n \n         // SAFETY: we now have recovered the original Weak pointer, so can create the Weak."}, {"sha": "b06e94a7a689e47e219888aa6da755fa653fcb88", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=d489ea777d38c5d44a5394bcd4bdcc69eb3cda40", "patch": "@@ -48,6 +48,50 @@ impl<T: ?Sized> *const T {\n         self as _\n     }\n \n+    /// Use the pointer value in a new pointer of another type.\n+    ///\n+    /// In case `val` is a (fat) pointer to an unsized type, this operation\n+    /// will ignore the pointer part, whereas for (thin) pointers to sized\n+    /// types, this has the same effect as a simple cast.\n+    ///\n+    /// The resulting pointer will have provenance of `self`, i.e., for a fat\n+    /// pointer, this operation is semantically the same as creating a new\n+    /// fat pointer with the data pointer value of `self` but the metadata of\n+    /// `val`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This function is primarily useful for allowing byte-wise pointer\n+    /// arithmetic on potentially fat pointers:\n+    ///\n+    /// ```\n+    /// #![feature(set_ptr_value)]\n+    /// # use core::fmt::Debug;\n+    /// let arr: [i32; 3] = [1, 2, 3];\n+    /// let mut ptr = arr.as_ptr() as *const dyn Debug;\n+    /// let thin = ptr as *const u8;\n+    /// unsafe {\n+    ///     ptr = thin.add(8).with_metadata_of(ptr);\n+    ///     # assert_eq!(*(ptr as *const i32), 3);\n+    ///     println!(\"{:?}\", &*ptr); // will print \"3\"\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[inline]\n+    pub fn with_metadata_of<U>(self, mut val: *const U) -> *const U\n+    where\n+        U: ?Sized,\n+    {\n+        let target = &mut val as *mut *const U as *mut *const u8;\n+        // SAFETY: In case of a thin pointer, this operations is identical\n+        // to a simple assignment. In case of a fat pointer, with the current\n+        // fat pointer layout implementation, the first field of such a\n+        // pointer is always the data pointer, which is likewise assigned.\n+        unsafe { *target = self as *const u8 };\n+        val\n+    }\n+\n     /// Changes constness without changing the type.\n     ///\n     /// This is a bit safer than `as` because it wouldn't silently change the type if the code is\n@@ -764,47 +808,6 @@ impl<T: ?Sized> *const T {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n \n-    /// Sets the pointer value to `ptr`.\n-    ///\n-    /// In case `self` is a (fat) pointer to an unsized type, this operation\n-    /// will only affect the pointer part, whereas for (thin) pointers to\n-    /// sized types, this has the same effect as a simple assignment.\n-    ///\n-    /// The resulting pointer will have provenance of `val`, i.e., for a fat\n-    /// pointer, this operation is semantically the same as creating a new\n-    /// fat pointer with the data pointer value of `val` but the metadata of\n-    /// `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This function is primarily useful for allowing byte-wise pointer\n-    /// arithmetic on potentially fat pointers:\n-    ///\n-    /// ```\n-    /// #![feature(set_ptr_value)]\n-    /// # use core::fmt::Debug;\n-    /// let arr: [i32; 3] = [1, 2, 3];\n-    /// let mut ptr = arr.as_ptr() as *const dyn Debug;\n-    /// let thin = ptr as *const u8;\n-    /// unsafe {\n-    ///     ptr = ptr.set_ptr_value(thin.add(8));\n-    ///     # assert_eq!(*(ptr as *const i32), 3);\n-    ///     println!(\"{:?}\", &*ptr); // will print \"3\"\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n-    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n-    #[inline]\n-    pub fn set_ptr_value(mut self, val: *const u8) -> Self {\n-        let thin = &mut self as *mut *const T as *mut *const u8;\n-        // SAFETY: In case of a thin pointer, this operations is identical\n-        // to a simple assignment. In case of a fat pointer, with the current\n-        // fat pointer layout implementation, the first field of such a\n-        // pointer is always the data pointer, which is likewise assigned.\n-        unsafe { *thin = val };\n-        self\n-    }\n-\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///"}, {"sha": "63bb22d6e0dd438baf40ae5a887c7d50ea74b257", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=d489ea777d38c5d44a5394bcd4bdcc69eb3cda40", "patch": "@@ -47,6 +47,50 @@ impl<T: ?Sized> *mut T {\n         self as _\n     }\n \n+    /// Use the pointer value in a new pointer of another type.\n+    ///\n+    /// In case `val` is a (fat) pointer to an unsized type, this operation\n+    /// will ignore the pointer part, whereas for (thin) pointers to sized\n+    /// types, this has the same effect as a simple cast.\n+    ///\n+    /// The resulting pointer will have provenance of `self`, i.e., for a fat\n+    /// pointer, this operation is semantically the same as creating a new\n+    /// fat pointer with the data pointer value of `self` but the metadata of\n+    /// `val`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This function is primarily useful for allowing byte-wise pointer\n+    /// arithmetic on potentially fat pointers:\n+    ///\n+    /// ```\n+    /// #![feature(set_ptr_value)]\n+    /// # use core::fmt::Debug;\n+    /// let mut arr: [i32; 3] = [1, 2, 3];\n+    /// let mut ptr = arr.as_mut_ptr() as *mut dyn Debug;\n+    /// let thin = ptr as *mut u8;\n+    /// unsafe {\n+    ///     ptr = thin.add(8).with_metadata_of(ptr);\n+    ///     # assert_eq!(*(ptr as *mut i32), 3);\n+    ///     println!(\"{:?}\", &*ptr); // will print \"3\"\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[inline]\n+    pub fn with_metadata_of<U>(self, mut val: *mut U) -> *mut U\n+    where\n+        U: ?Sized,\n+    {\n+        let target = &mut val as *mut *mut U as *mut *mut u8;\n+        // SAFETY: In case of a thin pointer, this operations is identical\n+        // to a simple assignment. In case of a fat pointer, with the current\n+        // fat pointer layout implementation, the first field of such a\n+        // pointer is always the data pointer, which is likewise assigned.\n+        unsafe { *target = self as *mut u8 };\n+        val\n+    }\n+\n     /// Changes constness without changing the type.\n     ///\n     /// This is a bit safer than `as` because it wouldn't silently change the type if the code is\n@@ -878,47 +922,6 @@ impl<T: ?Sized> *mut T {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n \n-    /// Sets the pointer value to `ptr`.\n-    ///\n-    /// In case `self` is a (fat) pointer to an unsized type, this operation\n-    /// will only affect the pointer part, whereas for (thin) pointers to\n-    /// sized types, this has the same effect as a simple assignment.\n-    ///\n-    /// The resulting pointer will have provenance of `val`, i.e., for a fat\n-    /// pointer, this operation is semantically the same as creating a new\n-    /// fat pointer with the data pointer value of `val` but the metadata of\n-    /// `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This function is primarily useful for allowing byte-wise pointer\n-    /// arithmetic on potentially fat pointers:\n-    ///\n-    /// ```\n-    /// #![feature(set_ptr_value)]\n-    /// # use core::fmt::Debug;\n-    /// let mut arr: [i32; 3] = [1, 2, 3];\n-    /// let mut ptr = arr.as_mut_ptr() as *mut dyn Debug;\n-    /// let thin = ptr as *mut u8;\n-    /// unsafe {\n-    ///     ptr = ptr.set_ptr_value(thin.add(8));\n-    ///     # assert_eq!(*(ptr as *mut i32), 3);\n-    ///     println!(\"{:?}\", &*ptr); // will print \"3\"\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n-    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n-    #[inline]\n-    pub fn set_ptr_value(mut self, val: *mut u8) -> Self {\n-        let thin = &mut self as *mut *mut T as *mut *mut u8;\n-        // SAFETY: In case of a thin pointer, this operations is identical\n-        // to a simple assignment. In case of a fat pointer, with the current\n-        // fat pointer layout implementation, the first field of such a\n-        // pointer is always the data pointer, which is likewise assigned.\n-        unsafe { *thin = val };\n-        self\n-    }\n-\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///"}]}