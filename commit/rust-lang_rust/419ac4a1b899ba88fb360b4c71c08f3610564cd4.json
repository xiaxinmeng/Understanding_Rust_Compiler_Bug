{"sha": "419ac4a1b899ba88fb360b4c71c08f3610564cd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOWFjNGExYjg5OWJhODhmYjM2MGI0YzcxYzA4ZjM2MTA1NjRjZDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-01-15T19:39:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-01-15T23:34:38Z"}, "message": "Issue #3511 - Rationalize temporary lifetimes.\n\nMajor changes:\n\n- Define temporary scopes in a syntax-based way that basically defaults\n  to the innermost statement or conditional block, except for in\n  a `let` initializer, where we default to the innermost block. Rules\n  are documented in the code, but not in the manual (yet).\n  See new test run-pass/cleanup-value-scopes.rs for examples.\n- Refactors Datum to better define cleanup roles.\n- Refactor cleanup scopes to not be tied to basic blocks, permitting\n  us to have a very large number of scopes (one per AST node).\n- Introduce nascent documentation in trans/doc.rs covering datums and\n  cleanup in a more comprehensive way.", "tree": {"sha": "a67114bd33e84818930d054f29ac81b726a88198", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a67114bd33e84818930d054f29ac81b726a88198"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/419ac4a1b899ba88fb360b4c71c08f3610564cd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/419ac4a1b899ba88fb360b4c71c08f3610564cd4", "html_url": "https://github.com/rust-lang/rust/commit/419ac4a1b899ba88fb360b4c71c08f3610564cd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/419ac4a1b899ba88fb360b4c71c08f3610564cd4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "149fc76698318f8f7cdfaa37a818e347721764e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/149fc76698318f8f7cdfaa37a818e347721764e7", "html_url": "https://github.com/rust-lang/rust/commit/149fc76698318f8f7cdfaa37a818e347721764e7"}], "stats": {"total": 8459, "additions": 4797, "deletions": 3662}, "files": [{"sha": "c259fa6a61831317dab350cd64e3f004d63c9182", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -1698,6 +1698,7 @@ pub mod llvm {\n \n         pub fn LLVMDICompositeTypeSetTypeArray(CompositeType: ValueRef, TypeArray: ValueRef);\n         pub fn LLVMTypeToString(Type: TypeRef) -> *c_char;\n+        pub fn LLVMValueToString(value_ref: ValueRef) -> *c_char;\n \n         pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n \n@@ -1847,8 +1848,10 @@ impl TypeNames {\n \n     pub fn val_to_str(&self, val: ValueRef) -> ~str {\n         unsafe {\n-            let ty = Type::from_ref(llvm::LLVMTypeOf(val));\n-            self.type_to_str(ty)\n+            let s = llvm::LLVMValueToString(val);\n+            let ret = from_c_str(s);\n+            free(s as *c_void);\n+            ret\n         }\n     }\n }"}, {"sha": "4ca6f5f370a5de806097d5270f5ac6dcfbb883b0", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -12,13 +12,14 @@\n use c = metadata::common;\n use cstore = metadata::cstore;\n use driver::session::Session;\n-use e = metadata::encoder;\n use metadata::decoder;\n+use e = metadata::encoder;\n+use middle::freevars::freevar_entry;\n+use middle::region;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n                          RegionParameter};\n use metadata::tyencode;\n-use middle::freevars::freevar_entry;\n use middle::typeck::{method_origin, method_map_entry};\n use middle::{ty, typeck, moves};\n use middle;\n@@ -146,6 +147,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         debug!(\"< Decoded inlined fn: {}::{}\",\n                ast_map::path_to_str(path, token::get_ident_interner()),\n                tcx.sess.str_of(ident));\n+        region::resolve_inlined_item(tcx.sess, &tcx.region_maps, &ii);\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::IIItem(i) => {"}, {"sha": "ea222839ffe16891fbd32c6682442ca0db124404", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -220,7 +220,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n \n         // If inside of a match arm, expand the rooting to the entire\n         // match. See the detailed discussion in `check()` above.\n-        let mut root_scope = match discr_scope {\n+        let root_scope = match discr_scope {\n             None => root_scope,\n             Some(id) => {\n                 if self.bccx.is_subscope_of(root_scope, id) {\n@@ -231,17 +231,6 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             }\n         };\n \n-        // FIXME(#3511) grow to the nearest cleanup scope---this can\n-        // cause observable errors if freezing!\n-        if !self.bccx.tcx.region_maps.is_cleanup_scope(root_scope) {\n-            debug!(\"{:?} is not a cleanup scope, adjusting\", root_scope);\n-\n-            let cleanup_scope =\n-                self.bccx.tcx.region_maps.cleanup_scope(root_scope);\n-\n-            root_scope = cleanup_scope;\n-        }\n-\n         // Add a record of what is required\n         let rm_key = root_map_key {id: cmt_deref.id, derefs: derefs};\n         let root_info = RootInfo {scope: root_scope};\n@@ -301,8 +290,8 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         // See the SCOPE(LV) function in doc.rs\n \n         match cmt.cat {\n-            mc::cat_rvalue(cleanup_scope_id) => {\n-                ty::ReScope(cleanup_scope_id)\n+            mc::cat_rvalue(temp_scope) => {\n+                temp_scope\n             }\n             mc::cat_copied_upvar(_) => {\n                 ty::ReScope(self.item_scope_id)\n@@ -313,7 +302,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_local(local_id) |\n             mc::cat_arg(local_id) |\n             mc::cat_self(local_id) => {\n-                self.bccx.tcx.region_maps.encl_region(local_id)\n+                ty::ReScope(self.bccx.tcx.region_maps.var_scope(local_id))\n             }\n             mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n                 ty::ReStatic"}, {"sha": "00e648db732e7ff05abbe58bbca660c2ca37c52b", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -662,8 +662,9 @@ impl<'a> GatherLoanCtxt<'a> {\n         //! with immutable `&` pointers, because borrows of such pointers\n         //! do not require restrictions and hence do not cause a loan.\n \n-        let lexical_scope = self.bccx.tcx.region_maps.encl_scope(lp.node_id());\n-        if self.bccx.tcx.region_maps.is_subscope_of(lexical_scope, loan_scope) {\n+        let rm = &self.bccx.tcx.region_maps;\n+        let lexical_scope = rm.var_scope(lp.node_id());\n+        if rm.is_subscope_of(lexical_scope, loan_scope) {\n             lexical_scope\n         } else {\n             assert!(self.bccx.tcx.region_maps.is_subscope_of(loan_scope, lexical_scope));\n@@ -688,7 +689,7 @@ impl<'a> GatherLoanCtxt<'a> {\n             let arg_cmt = mc_ctxt.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n-                body.id, // Arguments live only as long as the fn body.\n+                ty::ReScope(body.id), // Args live only as long as the fn body.\n                 arg_ty);\n \n             self.gather_pat(arg_cmt, arg.pat, None);"}, {"sha": "53cf5646cfb54fceca2986b3ab20ab16fd917fcc", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -471,7 +471,7 @@ impl MoveData {\n             for path in paths.get().iter() {\n                 match *path.loan_path {\n                     LpVar(id) => {\n-                        let kill_id = tcx.region_maps.encl_scope(id);\n+                        let kill_id = tcx.region_maps.var_scope(id);\n                         let path = {\n                             let path_map = self.path_map.borrow();\n                             *path_map.get().get(&path.loan_path)\n@@ -490,7 +490,7 @@ impl MoveData {\n                     var_assignments.get().iter().enumerate() {\n                 match *self.path_loan_path(assignment.path) {\n                     LpVar(id) => {\n-                        let kill_id = tcx.region_maps.encl_scope(id);\n+                        let kill_id = tcx.region_maps.var_scope(id);\n                         dfcx_assign.add_kill(kill_id, assignment_index);\n                     }\n                     LpExtend(..) => {"}, {"sha": "70d4f63a16449942ce484033f1b95c347df2f00e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -60,7 +60,7 @@ use syntax::parse::token;\n \n #[deriving(Eq)]\n pub enum categorization {\n-    cat_rvalue(ast::NodeId),           // temporary val, argument is its scope\n+    cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n     cat_stack_upvar(cmt),              // by ref upvar from ||\n@@ -585,21 +585,26 @@ impl mem_categorization_ctxt {\n     pub fn cat_rvalue_node<N:ast_node>(&self,\n                                        node: &N,\n                                        expr_ty: ty::t) -> cmt {\n-        self.cat_rvalue(node.id(),\n-                        node.span(),\n-                        self.tcx.region_maps.cleanup_scope(node.id()),\n-                        expr_ty)\n+        match self.tcx.region_maps.temporary_scope(node.id()) {\n+            Some(scope) => {\n+                self.cat_rvalue(node.id(), node.span(),\n+                                ty::ReScope(scope), expr_ty)\n+            }\n+            None => {\n+                self.cat_rvalue(node.id(), node.span(), ty::ReStatic, expr_ty)\n+            }\n+        }\n     }\n \n     pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n-                      cleanup_scope_id: ast::NodeId,\n+                      temp_scope: ty::Region,\n                       expr_ty: ty::t) -> cmt {\n         @cmt_ {\n             id:cmt_id,\n             span:span,\n-            cat:cat_rvalue(cleanup_scope_id),\n+            cat:cat_rvalue(temp_scope),\n             mutbl:McDeclared,\n             ty:expr_ty\n         }"}, {"sha": "50096c012be3d073ec4580012b2ab0248fa6ff6b", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -108,3 +108,14 @@ pub fn pat_contains_bindings(dm: resolve::DefMap, pat: &Pat) -> bool {\n     });\n     contains_bindings\n }\n+\n+pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Path> {\n+    match pat.node {\n+        PatIdent(BindByValue(_), ref path, None) => {\n+            Some(path)\n+        }\n+        _ => {\n+            None\n+        }\n+    }\n+}"}, {"sha": "3f4e5a4ef89c02d0336543f4f599242f12386c03", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 461, "deletions": 78, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -31,6 +31,7 @@ use syntax::codemap::Span;\n use syntax::{ast, visit};\n use syntax::visit::{Visitor, FnKind};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n+use syntax::ast_util::{stmt_id};\n \n /**\n The region maps encode information about region relationships.\n@@ -46,30 +47,30 @@ The region maps encode information about region relationships.\n   - the free region map is populated during type check as we check\n     each function. See the function `relate_free_regions` for\n     more information.\n-- `cleanup_scopes` includes scopes where trans cleanups occur\n-  - this is intended to reflect the current state of trans, not\n-    necessarily how I think things ought to work\n+- `temporary_scopes` includes scopes where cleanups for temporaries occur.\n+  These are statements and loop/fn bodies.\n */\n pub struct RegionMaps {\n     priv scope_map: RefCell<HashMap<ast::NodeId, ast::NodeId>>,\n+    priv var_map: RefCell<HashMap<ast::NodeId, ast::NodeId>>,\n     priv free_region_map: RefCell<HashMap<FreeRegion, ~[FreeRegion]>>,\n-    priv cleanup_scopes: RefCell<HashSet<ast::NodeId>>,\n+    priv rvalue_scopes: RefCell<HashMap<ast::NodeId, ast::NodeId>>,\n+    priv terminating_scopes: RefCell<HashSet<ast::NodeId>>,\n }\n \n #[deriving(Clone)]\n pub struct Context {\n-    // Scope where variables should be parented to\n     var_parent: Option<ast::NodeId>,\n \n     // Innermost enclosing expression\n     parent: Option<ast::NodeId>,\n }\n \n-struct RegionResolutionVisitor {\n+struct RegionResolutionVisitor<'a> {\n     sess: Session,\n \n     // Generated maps:\n-    region_maps: RegionMaps,\n+    region_maps: &'a RegionMaps,\n }\n \n \n@@ -91,22 +92,41 @@ impl RegionMaps {\n         free_region_map.get().insert(sub, ~[sup]);\n     }\n \n-    pub fn record_parent(&self, sub: ast::NodeId, sup: ast::NodeId) {\n-        debug!(\"record_parent(sub={:?}, sup={:?})\", sub, sup);\n+    pub fn record_encl_scope(&self, sub: ast::NodeId, sup: ast::NodeId) {\n+        debug!(\"record_encl_scope(sub={}, sup={})\", sub, sup);\n         assert!(sub != sup);\n \n         let mut scope_map = self.scope_map.borrow_mut();\n         scope_map.get().insert(sub, sup);\n     }\n \n-    pub fn record_cleanup_scope(&self, scope_id: ast::NodeId) {\n-        //! Records that a scope is a CLEANUP SCOPE.  This is invoked\n-        //! from within regionck.  We wait until regionck because we do\n-        //! not know which operators are overloaded until that point,\n-        //! and only overloaded operators result in cleanup scopes.\n+    pub fn record_var_scope(&self, var: ast::NodeId, lifetime: ast::NodeId) {\n+        debug!(\"record_var_scope(sub={}, sup={})\", var, lifetime);\n+        assert!(var != lifetime);\n \n-        let mut cleanup_scopes = self.cleanup_scopes.borrow_mut();\n-        cleanup_scopes.get().insert(scope_id);\n+        let mut var_map = self.var_map.borrow_mut();\n+        var_map.get().insert(var, lifetime);\n+    }\n+\n+    pub fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: ast::NodeId) {\n+        debug!(\"record_rvalue_scope(sub={}, sup={})\", var, lifetime);\n+        assert!(var != lifetime);\n+\n+        let mut rvalue_scopes = self.rvalue_scopes.borrow_mut();\n+        rvalue_scopes.get().insert(var, lifetime);\n+    }\n+\n+    pub fn mark_as_terminating_scope(&self, scope_id: ast::NodeId) {\n+        /*!\n+         * Records that a scope is a TERMINATING SCOPE. Whenever we\n+         * create automatic temporaries -- e.g. by an\n+         * expression like `a().f` -- they will be freed within\n+         * the innermost terminating scope.\n+         */\n+\n+        debug!(\"record_terminating_scope(scope_id={})\", scope_id);\n+        let mut terminating_scopes = self.terminating_scopes.borrow_mut();\n+        terminating_scopes.get().insert(scope_id);\n     }\n \n     pub fn opt_encl_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n@@ -122,24 +142,51 @@ impl RegionMaps {\n         let scope_map = self.scope_map.borrow();\n         match scope_map.get().find(&id) {\n             Some(&r) => r,\n-            None => { fail!(\"No enclosing scope for id {:?}\", id); }\n+            None => { fail!(\"No enclosing scope for id {}\", id); }\n         }\n     }\n \n-    pub fn is_cleanup_scope(&self, scope_id: ast::NodeId) -> bool {\n-        let cleanup_scopes = self.cleanup_scopes.borrow();\n-        cleanup_scopes.get().contains(&scope_id)\n+    pub fn var_scope(&self, var_id: ast::NodeId) -> ast::NodeId {\n+        /*!\n+         * Returns the lifetime of the local variable `var_id`\n+         */\n+\n+        let var_map = self.var_map.borrow();\n+        match var_map.get().find(&var_id) {\n+            Some(&r) => r,\n+            None => { fail!(\"No enclosing scope for id {}\", var_id); }\n+        }\n     }\n \n-    pub fn cleanup_scope(&self, expr_id: ast::NodeId) -> ast::NodeId {\n-        //! Returns the scope when temps in expr will be cleaned up\n+    pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<ast::NodeId> {\n+        //! Returns the scope when temp created by expr_id will be cleaned up\n+\n+        // check for a designated rvalue scope\n+        let rvalue_scopes = self.rvalue_scopes.borrow();\n+        match rvalue_scopes.get().find(&expr_id) {\n+            Some(&s) => {\n+                debug!(\"temporary_scope({}) = {} [custom]\", expr_id, s);\n+                return Some(s);\n+            }\n+            None => { }\n+        }\n \n+        // else, locate the innermost terminating scope\n         let mut id = self.encl_scope(expr_id);\n-        let cleanup_scopes = self.cleanup_scopes.borrow();\n-        while !cleanup_scopes.get().contains(&id) {\n-            id = self.encl_scope(id);\n+        let terminating_scopes = self.terminating_scopes.borrow();\n+        while !terminating_scopes.get().contains(&id) {\n+            match self.opt_encl_scope(id) {\n+                Some(p) => {\n+                    id = p;\n+                }\n+                None => {\n+                    debug!(\"temporary_scope({}) = None\", expr_id);\n+                    return None;\n+                }\n+            }\n         }\n-        return id;\n+        debug!(\"temporary_scope({}) = {} [enclosing]\", expr_id, id);\n+        return Some(id);\n     }\n \n     pub fn encl_region(&self, id: ast::NodeId) -> ty::Region {\n@@ -148,6 +195,12 @@ impl RegionMaps {\n         ty::ReScope(self.encl_scope(id))\n     }\n \n+    pub fn var_region(&self, id: ast::NodeId) -> ty::Region {\n+        //! Returns the lifetime of the variable `id`.\n+\n+        ty::ReScope(self.var_scope(id))\n+    }\n+\n     pub fn scopes_intersect(&self, scope1: ast::NodeId, scope2: ast::NodeId)\n                             -> bool {\n         self.is_subscope_of(scope1, scope2) ||\n@@ -168,7 +221,7 @@ impl RegionMaps {\n             let scope_map = self.scope_map.borrow();\n             match scope_map.get().find(&s) {\n                 None => {\n-                    debug!(\"is_subscope_of({:?}, {:?}, s={:?})=false\",\n+                    debug!(\"is_subscope_of({}, {}, s={})=false\",\n                            subscope, superscope, s);\n \n                     return false;\n@@ -177,7 +230,7 @@ impl RegionMaps {\n             }\n         }\n \n-        debug!(\"is_subscope_of({:?}, {:?})=true\",\n+        debug!(\"is_subscope_of({}, {})=true\",\n                subscope, superscope);\n \n         return true;\n@@ -323,67 +376,138 @@ impl RegionMaps {\n }\n \n /// Records the current parent (if any) as the parent of `child_id`.\n-fn parent_to_expr(visitor: &mut RegionResolutionVisitor,\n-                  cx: Context, child_id: ast::NodeId, sp: Span) {\n-    debug!(\"region::parent_to_expr(span={:?})\",\n-           visitor.sess.codemap.span_to_str(sp));\n-    for parent_id in cx.parent.iter() {\n-        visitor.region_maps.record_parent(child_id, *parent_id);\n+fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n+                        cx: Context,\n+                        child_id: ast::NodeId,\n+                        _sp: Span) {\n+    for &parent_id in cx.parent.iter() {\n+        visitor.region_maps.record_encl_scope(child_id, parent_id);\n+    }\n+}\n+\n+/// Records the lifetime of a local variable as `cx.var_parent`\n+fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n+                       cx: Context,\n+                       var_id: ast::NodeId,\n+                       _sp: Span) {\n+    match cx.var_parent {\n+        Some(parent_id) => {\n+            visitor.region_maps.record_var_scope(var_id, parent_id);\n+        }\n+        None => {\n+            // this can happen in extern fn declarations like\n+            //\n+            // extern fn isalnum(c: c_int) -> c_int\n+        }\n     }\n }\n \n fn resolve_block(visitor: &mut RegionResolutionVisitor,\n                  blk: &ast::Block,\n                  cx: Context) {\n-    // Record the parent of this block.\n-    parent_to_expr(visitor, cx, blk.id, blk.span);\n+    debug!(\"resolve_block(blk.id={})\", blk.id);\n \n-    // Descend.\n-    let new_cx = Context {var_parent: Some(blk.id),\n-                          parent: Some(blk.id)};\n-    visit::walk_block(visitor, blk, new_cx);\n+    // Record the parent of this block.\n+    record_superlifetime(visitor, cx, blk.id, blk.span);\n+\n+    // We treat the tail expression in the block (if any) somewhat\n+    // differently from the statements. The issue has to do with\n+    // temporary lifetimes. If the user writes:\n+    //\n+    //   {\n+    //     ... (&foo()) ...\n+    //   }\n+    //\n+\n+    let subcx = Context {var_parent: Some(blk.id), parent: Some(blk.id)};\n+    visit::walk_block(visitor, blk, subcx);\n }\n \n fn resolve_arm(visitor: &mut RegionResolutionVisitor,\n                arm: &ast::Arm,\n                cx: Context) {\n+    visitor.region_maps.mark_as_terminating_scope(arm.body.id);\n+\n+    match arm.guard {\n+        Some(expr) => {\n+            visitor.region_maps.mark_as_terminating_scope(expr.id);\n+        }\n+        None => { }\n+    }\n+\n     visit::walk_arm(visitor, arm, cx);\n }\n \n fn resolve_pat(visitor: &mut RegionResolutionVisitor,\n                pat: &ast::Pat,\n                cx: Context) {\n-    assert_eq!(cx.var_parent, cx.parent);\n-    parent_to_expr(visitor, cx, pat.id, pat.span);\n+    record_superlifetime(visitor, cx, pat.id, pat.span);\n+\n+    // If this is a binding (or maybe a binding, I'm too lazy to check\n+    // the def map) then record the lifetime of that binding.\n+    match pat.node {\n+        ast::PatIdent(..) => {\n+            record_var_lifetime(visitor, cx, pat.id, pat.span);\n+        }\n+        _ => { }\n+    }\n+\n     visit::walk_pat(visitor, pat, cx);\n }\n \n fn resolve_stmt(visitor: &mut RegionResolutionVisitor,\n                 stmt: &ast::Stmt,\n                 cx: Context) {\n-    match stmt.node {\n-        ast::StmtDecl(..) => {\n-            visit::walk_stmt(visitor, stmt, cx);\n-        }\n-        ast::StmtExpr(_, stmt_id) |\n-        ast::StmtSemi(_, stmt_id) => {\n-            parent_to_expr(visitor, cx, stmt_id, stmt.span);\n-            let expr_cx = Context {parent: Some(stmt_id), ..cx};\n-            visit::walk_stmt(visitor, stmt, expr_cx);\n-        }\n-        ast::StmtMac(..) => visitor.sess.bug(\"unexpanded macro\")\n-    }\n+    let stmt_id = stmt_id(stmt);\n+    debug!(\"resolve_stmt(stmt.id={})\", stmt_id);\n+\n+    visitor.region_maps.mark_as_terminating_scope(stmt_id);\n+    record_superlifetime(visitor, cx, stmt_id, stmt.span);\n+\n+    let subcx = Context {parent: Some(stmt_id), ..cx};\n+    visit::walk_stmt(visitor, stmt, subcx);\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n                 expr: &ast::Expr,\n                 cx: Context) {\n-    parent_to_expr(visitor, cx, expr.id, expr.span);\n+    debug!(\"resolve_expr(expr.id={})\", expr.id);\n+\n+    record_superlifetime(visitor, cx, expr.id, expr.span);\n \n     let mut new_cx = cx;\n     new_cx.parent = Some(expr.id);\n     match expr.node {\n-        ast::ExprAssignOp(..) | ast::ExprIndex(..) | ast::ExprBinary(..) |\n+        // Conditional or repeating scopes are always terminating\n+        // scopes, meaning that temporaries cannot outlive them.\n+        // This ensures fixed size stacks.\n+\n+        ast::ExprBinary(_, ast::BiAnd, _, r) |\n+        ast::ExprBinary(_, ast::BiOr, _, r) => {\n+            // For shortcircuiting operators, mark the RHS as a terminating\n+            // scope since it only executes conditionally.\n+            visitor.region_maps.mark_as_terminating_scope(r.id);\n+        }\n+\n+        ast::ExprIf(_, then, Some(otherwise)) => {\n+            visitor.region_maps.mark_as_terminating_scope(then.id);\n+            visitor.region_maps.mark_as_terminating_scope(otherwise.id);\n+        }\n+\n+        ast::ExprIf(_, then, None) => {\n+            visitor.region_maps.mark_as_terminating_scope(then.id);\n+        }\n+\n+        ast::ExprLoop(body, _) |\n+        ast::ExprWhile(_, body) => {\n+            visitor.region_maps.mark_as_terminating_scope(body.id);\n+        }\n+\n+        ast::ExprMatch(..) => {\n+            new_cx.var_parent = Some(expr.id);\n+        }\n+\n+        ast::ExprAssignOp(..) | ast::ExprIndex(..) |\n         ast::ExprUnary(..) | ast::ExprCall(..) | ast::ExprMethodCall(..) => {\n             // FIXME(#6268) Nested method calls\n             //\n@@ -402,11 +526,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n             // for an extended explanantion of why this distinction is\n             // important.\n             //\n-            // parent_to_expr(new_cx, expr.callee_id);\n-        }\n-\n-        ast::ExprMatch(..) => {\n-            new_cx.var_parent = Some(expr.id);\n+            // record_superlifetime(new_cx, expr.callee_id);\n         }\n \n         _ => {}\n@@ -419,9 +539,254 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n fn resolve_local(visitor: &mut RegionResolutionVisitor,\n                  local: &ast::Local,\n                  cx: Context) {\n-    assert_eq!(cx.var_parent, cx.parent);\n-    parent_to_expr(visitor, cx, local.id, local.span);\n+    debug!(\"resolve_local(local.id={},local.init={})\",\n+           local.id,local.init.is_some());\n+\n+    let blk_id = match cx.var_parent {\n+        Some(id) => id,\n+        None => {\n+            visitor.sess.span_bug(\n+                local.span,\n+                \"Local without enclosing block\");\n+        }\n+    };\n+\n+    // For convenience in trans, associate with the local-id the var\n+    // scope that will be used for any bindings declared in this\n+    // pattern.\n+    visitor.region_maps.record_var_scope(local.id, blk_id);\n+\n+    // As an exception to the normal rules governing temporary\n+    // lifetimes, initializers in a let have a temporary lifetime\n+    // of the enclosing block. This means that e.g. a program\n+    // like the following is legal:\n+    //\n+    //     let ref x = HashMap::new();\n+    //\n+    // Because the hash map will be freed in the enclosing block.\n+    //\n+    // We express the rules more formally based on 3 grammars (defined\n+    // fully in the helpers below that implement them):\n+    //\n+    // 1. `E&`, which matches expressions like `&<rvalue>` that\n+    //    own a pointer into the stack.\n+    //\n+    // 2. `P&`, which matches patterns like `ref x` or `(ref x, ref\n+    //    y)` that produce ref bindings into the value they are\n+    //    matched against or something (at least partially) owned by\n+    //    the value they are matched against. (By partially owned,\n+    //    I mean that creating a binding into a ref-counted or managed value\n+    //    would still count.)\n+    //\n+    // 3. `ET`, which matches both rvalues like `foo()` as well as lvalues\n+    //    based on rvalues like `foo().x[2].y`.\n+    //\n+    // A subexpression `<rvalue>` that appears in a let initializer\n+    // `let pat [: ty] = expr` has an extended temporary lifetime if\n+    // any of the following conditions are met:\n+    //\n+    // A. `pat` matches `P&` and `expr` matches `ET`\n+    //    (covers cases where `pat` creates ref bindings into an rvalue\n+    //     produced by `expr`)\n+    // B. `ty` is a borrowed pointer and `expr` matches `ET`\n+    //    (covers cases where coercion creates a borrow)\n+    // C. `expr` matches `E&`\n+    //    (covers cases `expr` borrows an rvalue that is then assigned\n+    //     to memory (at least partially) owned by the binding)\n+    //\n+    // Here are some examples hopefully giving an intution where each\n+    // rule comes into play and why:\n+    //\n+    // Rule A. `let (ref x, ref y) = (foo().x, 44)`. The rvalue `(22, 44)`\n+    // would have an extended lifetime, but not `foo()`.\n+    //\n+    // Rule B. `let x: &[...] = [foo().x]`. The rvalue `[foo().x]`\n+    // would have an extended lifetime, but not `foo()`.\n+    //\n+    // Rule C. `let x = &foo().x`. The rvalue ``foo()` would have extended\n+    // lifetime.\n+    //\n+    // In some cases, multiple rules may apply (though not to the same\n+    // rvalue). For example:\n+    //\n+    //     let ref x = [&a(), &b()];\n+    //\n+    // Here, the expression `[...]` has an extended lifetime due to rule\n+    // A, but the inner rvalues `a()` and `b()` have an extended lifetime\n+    // due to rule C.\n+    //\n+    // FIXME -- Note that `[]` patterns work more smoothly post-DST.\n+\n+    match local.init {\n+        Some(expr) => {\n+            record_rvalue_scope_if_borrow_expr(visitor, expr, blk_id);\n+\n+            if is_binding_pat(local.pat) || is_borrowed_ty(local.ty) {\n+                record_rvalue_scope(visitor, expr, blk_id);\n+            }\n+        }\n+\n+        None => { }\n+    }\n+\n     visit::walk_local(visitor, local, cx);\n+\n+    fn is_binding_pat(pat: &ast::Pat) -> bool {\n+        /*!\n+         * True if `pat` match the `P&` nonterminal:\n+         *\n+         *     P& = ref X\n+         *        | StructName { ..., P&, ... }\n+         *        | [ ..., P&, ... ]\n+         *        | ( ..., P&, ... )\n+         *        | ~P&\n+         *        | box P&\n+         */\n+\n+        match pat.node {\n+            ast::PatIdent(ast::BindByRef(_), _, _) => true,\n+\n+            ast::PatStruct(_, ref field_pats, _) => {\n+                field_pats.iter().any(|fp| is_binding_pat(fp.pat))\n+            }\n+\n+            ast::PatVec(ref pats1, ref pats2, ref pats3) => {\n+                pats1.iter().any(|&p| is_binding_pat(p)) ||\n+                pats2.iter().any(|&p| is_binding_pat(p)) ||\n+                pats3.iter().any(|&p| is_binding_pat(p))\n+            }\n+\n+            ast::PatTup(ref subpats) => {\n+                subpats.iter().any(|&p| is_binding_pat(p))\n+            }\n+\n+            ast::PatUniq(subpat) => {\n+                is_binding_pat(subpat)\n+            }\n+\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_borrowed_ty(ty: &ast::Ty) -> bool {\n+        /*!\n+         * True if `ty` is a borrowed pointer type\n+         * like `&int` or `&[...]`.\n+         */\n+\n+        match ty.node {\n+            ast::TyRptr(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    fn record_rvalue_scope_if_borrow_expr(visitor: &mut RegionResolutionVisitor,\n+                                          expr: &ast::Expr,\n+                                          blk_id: ast::NodeId) {\n+        /*!\n+         * If `expr` matches the `E&` grammar, then records an extended\n+         * rvalue scope as appropriate:\n+         *\n+         *     E& = & ET\n+         *        | StructName { ..., f: E&, ... }\n+         *        | [ ..., E&, ... ]\n+         *        | ( ..., E&, ... )\n+         *        | {...; E&}\n+         *        | ~E&\n+         *        | E& as ...\n+         *        | ( E& )\n+         */\n+\n+        match expr.node {\n+            ast::ExprAddrOf(_, subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n+                record_rvalue_scope(visitor, subexpr, blk_id);\n+            }\n+            ast::ExprStruct(_, ref fields, _) => {\n+                for field in fields.iter() {\n+                    record_rvalue_scope_if_borrow_expr(\n+                        visitor, field.expr, blk_id);\n+                }\n+            }\n+            ast::ExprVstore(subexpr, _) => {\n+                visitor.region_maps.record_rvalue_scope(subexpr.id, blk_id);\n+                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n+            }\n+            ast::ExprVec(ref subexprs, _) |\n+            ast::ExprTup(ref subexprs) => {\n+                for &subexpr in subexprs.iter() {\n+                    record_rvalue_scope_if_borrow_expr(\n+                        visitor, subexpr, blk_id);\n+                }\n+            }\n+            ast::ExprUnary(_, ast::UnUniq, subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n+            }\n+            ast::ExprCast(subexpr, _) |\n+            ast::ExprParen(subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id)\n+            }\n+            ast::ExprBlock(ref block) => {\n+                match block.expr {\n+                    Some(subexpr) => {\n+                        record_rvalue_scope_if_borrow_expr(\n+                            visitor, subexpr, blk_id);\n+                    }\n+                    None => { }\n+                }\n+            }\n+            _ => {\n+            }\n+        }\n+    }\n+\n+    fn record_rvalue_scope<'a>(visitor: &mut RegionResolutionVisitor,\n+                               expr: &'a ast::Expr,\n+                               blk_id: ast::NodeId) {\n+        /*!\n+         * Applied to an expression `expr` if `expr` -- or something\n+         * owned or partially owned by `expr` -- is going to be\n+         * indirectly referenced by a variable in a let statement. In\n+         * that case, the \"temporary lifetime\" or `expr` is extended\n+         * to be the block enclosing the `let` statement.\n+         *\n+         * More formally, if `expr` matches the grammar `ET`, record\n+         * the rvalue scope of the matching `<rvalue>` as `blk_id`:\n+         *\n+         *     ET = *ET\n+         *        | ET[...]\n+         *        | ET.f\n+         *        | (ET)\n+         *        | <rvalue>\n+         *\n+         * Note: ET is intended to match \"rvalues or\n+         * lvalues based on rvalues\".\n+         */\n+\n+        let mut expr = expr;\n+        loop {\n+            // Note: give all the expressions matching `ET` with the\n+            // extended temporary lifetime, not just the innermost rvalue,\n+            // because in trans if we must compile e.g. `*rvalue()`\n+            // into a temporary, we request the temporary scope of the\n+            // outer expression.\n+            visitor.region_maps.record_rvalue_scope(expr.id, blk_id);\n+\n+            match expr.node {\n+                ast::ExprAddrOf(_, ref subexpr) |\n+                ast::ExprUnary(_, ast::UnDeref, ref subexpr) |\n+                ast::ExprField(ref subexpr, _, _) |\n+                ast::ExprIndex(_, ref subexpr, _) |\n+                ast::ExprParen(ref subexpr) => {\n+                    let subexpr: &'a @Expr = subexpr; // FIXME\n+                    expr = &**subexpr;\n+                }\n+                _ => {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n }\n \n fn resolve_item(visitor: &mut RegionResolutionVisitor,\n@@ -439,22 +804,23 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               sp: Span,\n               id: ast::NodeId,\n               cx: Context) {\n-    debug!(\"region::resolve_fn(id={:?}, \\\n+    debug!(\"region::resolve_fn(id={}, \\\n                                span={:?}, \\\n-                               body.id={:?}, \\\n-                               cx.parent={:?})\",\n+                               body.id={}, \\\n+                               cx.parent={})\",\n            id,\n            visitor.sess.codemap.span_to_str(sp),\n            body.id,\n            cx.parent);\n \n+    visitor.region_maps.mark_as_terminating_scope(body.id);\n+\n     // The arguments and `self` are parented to the body of the fn.\n     let decl_cx = Context {parent: Some(body.id),\n-                           var_parent: Some(body.id),\n-                           ..cx};\n+                           var_parent: Some(body.id)};\n     match *fk {\n         visit::FkMethod(_, _, method) => {\n-            visitor.region_maps.record_parent(method.self_id, body.id);\n+            visitor.region_maps.record_var_scope(method.self_id, body.id);\n         }\n         _ => {}\n     }\n@@ -471,7 +837,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n     visitor.visit_block(body, body_cx);\n }\n \n-impl Visitor<Context> for RegionResolutionVisitor {\n+impl<'a> Visitor<Context> for RegionResolutionVisitor<'a> {\n \n     fn visit_block(&mut self, b: &Block, cx: Context) {\n         resolve_block(self, b, cx);\n@@ -503,16 +869,33 @@ impl Visitor<Context> for RegionResolutionVisitor {\n }\n \n pub fn resolve_crate(sess: Session, crate: &ast::Crate) -> RegionMaps {\n+    let maps = RegionMaps {\n+        scope_map: RefCell::new(HashMap::new()),\n+        var_map: RefCell::new(HashMap::new()),\n+        free_region_map: RefCell::new(HashMap::new()),\n+        rvalue_scopes: RefCell::new(HashMap::new()),\n+        terminating_scopes: RefCell::new(HashSet::new()),\n+    };\n+    {\n+        let mut visitor = RegionResolutionVisitor {\n+            sess: sess,\n+            region_maps: &maps\n+        };\n+        let cx = Context { parent: None, var_parent: None };\n+        visit::walk_crate(&mut visitor, crate, cx);\n+    }\n+    return maps;\n+}\n+\n+pub fn resolve_inlined_item(sess: Session,\n+                            region_maps: &RegionMaps,\n+                            item: &ast::InlinedItem) {\n+    let cx = Context {parent: None,\n+                      var_parent: None};\n     let mut visitor = RegionResolutionVisitor {\n         sess: sess,\n-        region_maps: RegionMaps {\n-            scope_map: RefCell::new(HashMap::new()),\n-            free_region_map: RefCell::new(HashMap::new()),\n-            cleanup_scopes: RefCell::new(HashSet::new())\n-        }\n+        region_maps: region_maps,\n     };\n-    let cx = Context { parent: None, var_parent: None };\n-    visit::walk_crate(&mut visitor, crate, cx);\n-    return visitor.region_maps;\n+    visit::walk_inlined_item(&mut visitor, item, cx);\n }\n "}, {"sha": "81bd7ba61890794e51de607680e6addde39ec7fe", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -2442,7 +2442,7 @@ impl Resolver {\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n                 debug!(\"(resolving single import) found type target: {:?}\",\n-                        name_bindings.type_def.get().unwrap().type_def);\n+                       {name_bindings.type_def.get().unwrap().type_def});\n                 import_resolution.type_target.set(\n                     Some(Target::new(target_module, name_bindings)));\n                 import_resolution.type_id.set(directive.id);"}, {"sha": "c7eb837aaf8646e83d91cde673a16a5366f90f96", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 225, "deletions": 248, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -204,6 +204,8 @@ use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n+use middle::trans::cleanup;\n+use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::controlflow;\n@@ -221,7 +223,6 @@ use util::ppaux::{Repr, vec_map_to_str};\n \n use std::cell::Cell;\n use std::hashmap::HashMap;\n-use std::ptr;\n use std::vec;\n use syntax::ast;\n use syntax::ast::Ident;\n@@ -315,16 +316,18 @@ pub enum opt_result<'a> {\n fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n     let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n-    let bcx = bcx;\n+    let mut bcx = bcx;\n     match *o {\n         lit(ExprLit(lit_expr)) => {\n-            let datumblock = expr::trans_to_datum(bcx, lit_expr);\n-            return single_result(datumblock.to_result());\n+            let lit_datum = unpack_datum!(bcx, expr::trans(bcx, lit_expr));\n+            let lit_datum = lit_datum.assert_rvalue(bcx); // literals are rvalues\n+            let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n+            return single_result(rslt(bcx, lit_datum.val));\n         }\n         lit(UnitLikeStructLit(pat_id)) => {\n             let struct_ty = ty::node_id_to_type(bcx.tcx(), pat_id);\n-            let datumblock = datum::scratch_datum(bcx, struct_ty, \"\", true);\n-            return single_result(datumblock.to_result(bcx));\n+            let datum = datum::rvalue_scratch_datum(bcx, struct_ty, \"\");\n+            return single_result(rslt(bcx, datum.val));\n         }\n         lit(ConstLit(lit_id)) => {\n             let (llval, _) = consts::get_const_val(bcx.ccx(), lit_id);\n@@ -1007,14 +1010,18 @@ fn extract_variant_args<'a>(\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n-fn match_datum<'a>(bcx: &'a Block<'a>, val: ValueRef, pat_id: ast::NodeId)\n-               -> Datum {\n-    //! Helper for converting from the ValueRef that we pass around in\n-    //! the match code, which is always by ref, into a Datum. Eventually\n-    //! we should just pass around a Datum and be done with it.\n+fn match_datum(bcx: &Block,\n+               val: ValueRef,\n+               pat_id: ast::NodeId)\n+               -> Datum<Lvalue> {\n+    /*!\n+     * Helper for converting from the ValueRef that we pass around in\n+     * the match code, which is always an lvalue, into a Datum. Eventually\n+     * we should just pass around a Datum and be done with it.\n+     */\n \n     let ty = node_id_type(bcx, pat_id);\n-    Datum {val: val, ty: ty, mode: datum::ByRef(RevokeClean)}\n+    Datum(val, ty, Lvalue)\n }\n \n \n@@ -1054,13 +1061,11 @@ fn extract_vec_elems<'a>(\n             ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable},\n             ty::vstore_slice(ty::ReStatic)\n         );\n-        let scratch = scratch_datum(bcx, slice_ty, \"\", false);\n+        let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n         Store(bcx, slice_begin,\n-            GEPi(bcx, scratch.val, [0u, abi::slice_elt_base])\n-        );\n+              GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n         Store(bcx, slice_len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         elems[n] = scratch.val;\n-        scratch.add_clean(bcx);\n     }\n \n     ExtractedBlock { vals: elems, bcx: bcx }\n@@ -1176,7 +1181,8 @@ impl<'a> DynamicFailureHandler<'a> {\n             _ => (),\n         }\n \n-        let fail_cx = sub_block(self.bcx, \"case_fallthrough\");\n+        let fcx = self.bcx.fcx;\n+        let fail_cx = fcx.new_block(false, \"case_fallthrough\", None);\n         controlflow::trans_fail(fail_cx, Some(self.sp), self.msg);\n         self.finished.set(Some(fail_cx.llbb));\n         fail_cx.llbb\n@@ -1297,69 +1303,61 @@ fn compare_values<'a>(\n fn store_non_ref_bindings<'a>(\n                           bcx: &'a Block<'a>,\n                           bindings_map: &BindingsMap,\n-                          mut opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n-                          -> &'a Block<'a> {\n+                          opt_cleanup_scope: Option<cleanup::ScopeId>)\n+                          -> &'a Block<'a>\n+{\n     /*!\n-     *\n-     * For each copy/move binding, copy the value from the value\n-     * being matched into its final home.  This code executes once\n-     * one of the patterns for a given arm has completely matched.\n-     * It adds temporary cleanups to the `temp_cleanups` array,\n-     * if one is provided.\n+     * For each copy/move binding, copy the value from the value being\n+     * matched into its final home.  This code executes once one of\n+     * the patterns for a given arm has completely matched.  It adds\n+     * cleanups to the `opt_cleanup_scope`, if one is provided.\n      */\n \n+    let fcx = bcx.fcx;\n     let mut bcx = bcx;\n     for (_, &binding_info) in bindings_map.iter() {\n         match binding_info.trmode {\n             TrByValue(lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n-                let datum = Datum {val: llval, ty: binding_info.ty,\n-                                   mode: ByRef(ZeroMem)};\n-                bcx = datum.store_to(bcx, INIT, lldest);\n-                opt_temp_cleanups.mutate(|temp_cleanups| {\n-                    add_clean_temp_mem(bcx, lldest, binding_info.ty);\n-                    temp_cleanups.push(lldest);\n-                    temp_cleanups\n-                });\n+                let datum = Datum(llval, binding_info.ty, Lvalue);\n+                bcx = datum.store_to(bcx, lldest);\n+\n+                match opt_cleanup_scope {\n+                    None => {}\n+                    Some(s) => {\n+                        fcx.schedule_drop_mem(s, lldest, binding_info.ty);\n+                    }\n+                }\n             }\n             TrByRef => {}\n         }\n     }\n     return bcx;\n }\n \n-fn insert_lllocals<'a>(\n-                   bcx: &'a Block<'a>,\n-                   bindings_map: &BindingsMap,\n-                   add_cleans: bool)\n-                   -> &'a Block<'a> {\n+fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n+                       bindings_map: &BindingsMap,\n+                       cleanup_scope: cleanup::ScopeId)\n+                       -> &'a Block<'a> {\n     /*!\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n-     * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n-     * the bindings.\n+     * the `fcx.lllocals` map, scheduling cleanup in `cleanup_scope`.\n      */\n \n+    let fcx = bcx.fcx;\n+\n     for (&ident, &binding_info) in bindings_map.iter() {\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n             TrByValue(lldest) => lldest,\n+\n             // By ref binding: use the ptr into the matched value\n             TrByRef => binding_info.llmatch\n         };\n \n-        let datum = Datum {\n-            val: llval,\n-            ty: binding_info.ty,\n-            mode: ByRef(ZeroMem)\n-        };\n-\n-        if add_cleans {\n-            match binding_info.trmode {\n-                TrByValue(_) => datum.add_clean(bcx),\n-                _ => {}\n-            }\n-        }\n+        let datum = Datum(llval, binding_info.ty, Lvalue);\n+        fcx.schedule_drop_mem(cleanup_scope, llval, binding_info.ty);\n \n         {\n             debug!(\"binding {:?} to {}\",\n@@ -1396,24 +1394,23 @@ fn compile_guard<'r,\n            vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n     let _indenter = indenter();\n \n+    // Lest the guard itself should fail, introduce a temporary cleanup\n+    // scope for any non-ref bindings we create.\n+    let temp_scope = bcx.fcx.push_custom_cleanup_scope();\n+\n     let mut bcx = bcx;\n-    let mut temp_cleanups = ~[];\n-    bcx = store_non_ref_bindings(bcx,\n-                                 data.bindings_map,\n-                                 Some(&mut temp_cleanups));\n-    bcx = insert_lllocals(bcx, data.bindings_map, false);\n-\n-    let val = unpack_result!(bcx, {\n-        with_scope_result(bcx, guard_expr.info(), \"guard\", |bcx| {\n-            expr::trans_to_datum(bcx, guard_expr).to_result()\n-        })\n-    });\n-    let val = bool_to_i1(bcx, val);\n+    bcx = store_non_ref_bindings(bcx, data.bindings_map,\n+                                 Some(cleanup::CustomScope(temp_scope)));\n+    bcx = insert_lllocals(bcx, data.bindings_map,\n+                          cleanup::CustomScope(temp_scope));\n \n-    // Revoke the temp cleanups now that the guard successfully executed.\n-    for llval in temp_cleanups.iter() {\n-        revoke_clean(bcx, *llval);\n-    }\n+    let val = unpack_datum!(bcx, expr::trans(bcx, guard_expr));\n+    let val = val.to_llbool(bcx);\n+\n+    // Cancel cleanups now that the guard successfully executed.  If\n+    // the guard was false, we will drop the values explicitly\n+    // below. Otherwise, we'll add lvalue cleanups at the end.\n+    bcx.fcx.pop_custom_cleanup_scope(temp_scope);\n \n     return with_cond(bcx, Not(bcx, val), |bcx| {\n         // Guard does not match: free the values we copied,\n@@ -1502,6 +1499,7 @@ fn compile_submatch_continue<'r,\n                              chk: &FailureHandler,\n                              col: uint,\n                              val: ValueRef) {\n+    let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n     let dm = tcx.def_map;\n \n@@ -1602,6 +1600,7 @@ fn compile_submatch_continue<'r,\n     debug!(\"options={:?}\", opts);\n     let mut kind = no_branch;\n     let mut test_val = val;\n+    debug!(\"test_val={}\", bcx.val_to_str(test_val));\n     if opts.len() > 0u {\n         match opts[0] {\n             var(_, repr) => {\n@@ -1621,8 +1620,7 @@ fn compile_submatch_continue<'r,\n             },\n             vec_len(..) => {\n                 let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n-                let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n-                let (_, len) = tvec::get_base_and_len(bcx, unboxed, vt.vec_ty);\n+                let (_, len) = tvec::get_base_and_len(bcx, val, vt.vec_ty);\n                 test_val = len;\n                 kind = compare_vec_len;\n             }\n@@ -1636,7 +1634,7 @@ fn compile_submatch_continue<'r,\n     }\n     let else_cx = match kind {\n         no_branch | single => bcx,\n-        _ => sub_block(bcx, \"match_else\")\n+        _ => bcx.fcx.new_temp_block(\"match_else\")\n     };\n     let sw = if kind == switch {\n         Switch(bcx, test_val, else_cx.llbb, opts.len())\n@@ -1657,7 +1655,7 @@ fn compile_submatch_continue<'r,\n         let mut branch_chk = None;\n         let mut opt_cx = else_cx;\n         if !exhaustive || i+1 < len {\n-            opt_cx = sub_block(bcx, \"match_case\");\n+            opt_cx = bcx.fcx.new_temp_block(\"match_case\");\n             match kind {\n               single => Br(bcx, opt_cx.llbb),\n               switch => {\n@@ -1678,75 +1676,65 @@ fn compile_submatch_continue<'r,\n               compare => {\n                   let t = node_id_type(bcx, pat_id);\n                   let Result {bcx: after_cx, val: matches} = {\n-                      with_scope_result(bcx, None, \"compaReScope\", |bcx| {\n-                          match trans_opt(bcx, opt) {\n-                              single_result(\n-                                  Result {bcx, val}) => {\n-                                  compare_values(bcx, test_val, val, t)\n-                              }\n-                              lower_bound(\n-                                  Result {bcx, val}) => {\n+                      match trans_opt(bcx, opt) {\n+                          single_result(Result {bcx, val}) => {\n+                              compare_values(bcx, test_val, val, t)\n+                          }\n+                          lower_bound(Result {bcx, val}) => {\n+                              compare_scalar_types(\n+                                  bcx, test_val, val,\n+                                  t, ast::BiGe)\n+                          }\n+                          range_result(Result {val: vbegin, ..},\n+                                       Result {bcx, val: vend}) => {\n+                              let Result {bcx, val: llge} =\n                                   compare_scalar_types(\n-                                          bcx, test_val, val,\n-                                          t, ast::BiGe)\n-                              }\n-                              range_result(\n-                                  Result {val: vbegin, ..},\n-                                  Result {bcx, val: vend}) => {\n-                                  let Result {bcx, val: llge} =\n-                                      compare_scalar_types(\n-                                          bcx, test_val,\n-                                          vbegin, t, ast::BiGe);\n-                                  let Result {bcx, val: llle} =\n-                                      compare_scalar_types(\n-                                          bcx, test_val, vend,\n-                                          t, ast::BiLe);\n-                                  rslt(bcx, And(bcx, llge, llle))\n-                              }\n+                                  bcx, test_val,\n+                                  vbegin, t, ast::BiGe);\n+                              let Result {bcx, val: llle} =\n+                                  compare_scalar_types(\n+                                  bcx, test_val, vend,\n+                                  t, ast::BiLe);\n+                              rslt(bcx, And(bcx, llge, llle))\n                           }\n-                      })\n+                      }\n                   };\n-                  bcx = sub_block(after_cx, \"compare_next\");\n+                  bcx = fcx.new_temp_block(\"compare_next\");\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               compare_vec_len => {\n                   let Result {bcx: after_cx, val: matches} = {\n-                      with_scope_result(bcx,\n-                                        None,\n-                                        \"compare_vec_len_scope\",\n-                                        |bcx| {\n-                          match trans_opt(bcx, opt) {\n-                              single_result(\n-                                  Result {bcx, val}) => {\n-                                  let value = compare_scalar_values(\n-                                      bcx, test_val, val,\n-                                      signed_int, ast::BiEq);\n-                                  rslt(bcx, value)\n-                              }\n-                              lower_bound(\n-                                  Result {bcx, val: val}) => {\n-                                  let value = compare_scalar_values(\n-                                      bcx, test_val, val,\n-                                      signed_int, ast::BiGe);\n-                                  rslt(bcx, value)\n-                              }\n-                              range_result(\n-                                  Result {val: vbegin, ..},\n-                                  Result {bcx, val: vend}) => {\n-                                  let llge =\n-                                      compare_scalar_values(\n-                                          bcx, test_val,\n-                                          vbegin, signed_int, ast::BiGe);\n-                                  let llle =\n-                                      compare_scalar_values(\n-                                          bcx, test_val, vend,\n-                                          signed_int, ast::BiLe);\n-                                  rslt(bcx, And(bcx, llge, llle))\n-                              }\n+                      match trans_opt(bcx, opt) {\n+                          single_result(\n+                              Result {bcx, val}) => {\n+                              let value = compare_scalar_values(\n+                                  bcx, test_val, val,\n+                                  signed_int, ast::BiEq);\n+                              rslt(bcx, value)\n                           }\n-                      })\n+                          lower_bound(\n+                              Result {bcx, val: val}) => {\n+                              let value = compare_scalar_values(\n+                                  bcx, test_val, val,\n+                                  signed_int, ast::BiGe);\n+                              rslt(bcx, value)\n+                          }\n+                          range_result(\n+                              Result {val: vbegin, ..},\n+                              Result {bcx, val: vend}) => {\n+                              let llge =\n+                                  compare_scalar_values(\n+                                  bcx, test_val,\n+                                  vbegin, signed_int, ast::BiGe);\n+                              let llle =\n+                                  compare_scalar_values(\n+                                  bcx, test_val, vend,\n+                                  signed_int, ast::BiLe);\n+                              rslt(bcx, And(bcx, llge, llle))\n+                          }\n+                      }\n                   };\n-                  bcx = sub_block(after_cx, \"compare_vec_len_next\");\n+                  bcx = fcx.new_temp_block(\"compare_vec_len_next\");\n \n                   // If none of these subcases match, move on to the\n                   // next condition.\n@@ -1812,9 +1800,7 @@ pub fn trans_match<'a>(\n                    dest: Dest)\n                    -> &'a Block<'a> {\n     let _icx = push_ctxt(\"match::trans_match\");\n-    with_scope(bcx, match_expr.info(), \"match\", |bcx| {\n-        trans_match_inner(bcx, discr_expr, arms, dest)\n-    })\n+    trans_match_inner(bcx, match_expr.id, discr_expr, arms, dest)\n }\n \n fn create_bindings_map(bcx: &Block, pat: @ast::Pat) -> BindingsMap {\n@@ -1857,27 +1843,26 @@ fn create_bindings_map(bcx: &Block, pat: @ast::Pat) -> BindingsMap {\n     return bindings_map;\n }\n \n-fn trans_match_inner<'a>(\n-                     scope_cx: &'a Block<'a>,\n-                     discr_expr: &ast::Expr,\n-                     arms: &[ast::Arm],\n-                     dest: Dest)\n-                     -> &'a Block<'a> {\n+fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n+                         match_id: ast::NodeId,\n+                         discr_expr: &ast::Expr,\n+                         arms: &[ast::Arm],\n+                         dest: Dest) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"match::trans_match_inner\");\n+    let fcx = scope_cx.fcx;\n     let mut bcx = scope_cx;\n     let tcx = bcx.tcx();\n \n-    let discr_datum = unpack_datum!(bcx, {\n-        expr::trans_to_datum(bcx, discr_expr)\n-    });\n+    let discr_datum = unpack_datum!(bcx, expr::trans_to_lvalue(bcx, discr_expr,\n+                                                               \"match\"));\n     if bcx.unreachable.get() {\n         return bcx;\n     }\n \n     let mut arm_datas = ~[];\n     let mut matches = ~[];\n     for arm in arms.iter() {\n-        let body = scope_block(bcx, arm.body.info(), \"case_body\");\n+        let body = fcx.new_id_block(\"case_body\", arm.body.id);\n         let bindings_map = create_bindings_map(bcx, arm.pats[0]);\n         let arm_data = ArmData {\n             bodycx: body,\n@@ -1910,7 +1895,7 @@ fn trans_match_inner<'a>(\n             Infallible\n         }\n     };\n-    let lldiscr = discr_datum.to_ref_llval(bcx);\n+    let lldiscr = discr_datum.val;\n     compile_submatch(bcx, matches, [lldiscr], &chk);\n \n     let mut arm_cxs = ~[];\n@@ -1926,14 +1911,15 @@ fn trans_match_inner<'a>(\n         }\n \n         // insert bindings into the lllocals map and add cleanups\n-        bcx = insert_lllocals(bcx, arm_data.bindings_map, true);\n-\n+        let cleanup_scope = fcx.push_custom_cleanup_scope();\n+        bcx = insert_lllocals(bcx, arm_data.bindings_map,\n+                              cleanup::CustomScope(cleanup_scope));\n         bcx = controlflow::trans_block(bcx, arm_data.arm.body, dest);\n-        bcx = trans_block_cleanups(bcx, block_cleanups(arm_data.bodycx));\n+        bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = controlflow::join_blocks(scope_cx, arm_cxs);\n+    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs);\n     return bcx;\n }\n \n@@ -1944,17 +1930,18 @@ enum IrrefutablePatternBindingMode {\n     BindArgument\n }\n \n-pub fn store_local<'a>(\n-                   bcx: &'a Block<'a>,\n-                   pat: @ast::Pat,\n-                   opt_init_expr: Option<@ast::Expr>)\n-                   -> &'a Block<'a> {\n+pub fn store_local<'a>(bcx: &'a Block<'a>,\n+                       local: &ast::Local)\n+                       -> &'a Block<'a> {\n     /*!\n      * Generates code for a local variable declaration like\n      * `let <pat>;` or `let <pat> = <opt_init_expr>`.\n      */\n     let _icx = push_ctxt(\"match::store_local\");\n     let mut bcx = bcx;\n+    let tcx = bcx.tcx();\n+    let pat = local.pat;\n+    let opt_init_expr = local.init;\n \n     return match opt_init_expr {\n         Some(init_expr) => {\n@@ -1970,50 +1957,55 @@ pub fn store_local<'a>(\n             // it assumes it is matching against a valid value.\n             match simple_identifier(pat) {\n                 Some(path) => {\n+                    let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n-                        bcx, pat.id, path, BindLocal,\n-                        |bcx, datum| expr::trans_into(bcx, init_expr, expr::SaveIn(datum.val)));\n+                        bcx, pat.id, path, BindLocal, var_scope, (),\n+                        |(), bcx, v, _| expr::trans_into(bcx, init_expr,\n+                                                         expr::SaveIn(v)));\n                 }\n \n                 None => {}\n             }\n \n             // General path.\n             let init_datum =\n-                unpack_datum!(\n-                    bcx,\n-                    expr::trans_to_datum(bcx, init_expr));\n+                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, init_expr, \"let\"));\n             if ty::type_is_bot(expr_ty(bcx, init_expr)) {\n                 create_dummy_locals(bcx, pat)\n             } else {\n                 if bcx.sess().asm_comments() {\n                     add_comment(bcx, \"creating zeroable ref llval\");\n                 }\n-                let llptr = init_datum.to_ref_llval(bcx);\n-                return bind_irrefutable_pat(bcx, pat, llptr, BindLocal);\n+                let var_scope = cleanup::var_scope(tcx, local.id);\n+                bind_irrefutable_pat(bcx, pat, init_datum.val, BindLocal, var_scope)\n             }\n         }\n         None => {\n             create_dummy_locals(bcx, pat)\n         }\n     };\n \n-    fn create_dummy_locals<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat)\n-                           -> &'a Block<'a> {\n+    fn create_dummy_locals<'a>(mut bcx: &'a Block<'a>,\n+                               pat: @ast::Pat)\n+                               -> &'a Block<'a> {\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n         pat_bindings(tcx.def_map, pat, |_, p_id, _, path| {\n-            bcx = mk_binding_alloca(\n-                bcx, p_id, path, BindLocal,\n-                |bcx, datum| { datum.cancel_clean(bcx); bcx });\n-        });\n+                let scope = cleanup::var_scope(tcx, p_id);\n+                bcx = mk_binding_alloca(\n+                    bcx, p_id, path, BindLocal, scope, (),\n+                    |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n+            });\n         bcx\n     }\n }\n \n-pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, arg: Datum)\n-                 -> &'a Block<'a> {\n+pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n+                     pat: @ast::Pat,\n+                     arg: Datum<Rvalue>,\n+                     arg_scope: cleanup::ScopeId)\n+                     -> &'a Block<'a> {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n      * Creates entries in the `llargs` map for each of the bindings\n@@ -2026,70 +2018,65 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, arg: Datum)\n      *   if the argument type is `T`, then `llval` is a `T*`). In some\n      *   cases, this code may zero out the memory `llval` points at.\n      */\n+\n     let _icx = push_ctxt(\"match::store_arg\");\n \n-    // We always need to cleanup the argument as we exit the fn scope.\n-    // Note that we cannot do it before for fear of a fn like\n-    //    fn getaddr(~ref x: ~uint) -> *uint {....}\n-    // (From test `run-pass/func-arg-ref-pattern.rs`)\n-    arg.add_clean(bcx);\n-\n-    // Debug information (the llvm.dbg.declare intrinsic to be precise) always expects to get an\n-    // alloca, which only is the case on the general path, so lets disable the optimized path when\n-    // debug info is enabled.\n-    let arg_is_alloca = unsafe { llvm::LLVMIsAAllocaInst(arg.val) != ptr::null() };\n-\n-    let fast_path = (arg_is_alloca || !bcx.ccx().sess.opts.extra_debuginfo)\n-                    && simple_identifier(pat).is_some();\n-\n-    if fast_path {\n-        // Optimized path for `x: T` case. This just adopts\n-        // `llval` wholesale as the pointer for `x`, avoiding the\n-        // general logic which may copy out of `llval`.\n-        let mut llargs = bcx.fcx.llargs.borrow_mut();\n-        llargs.get().insert(pat.id, arg);\n-    } else {\n-        // General path. Copy out the values that are used in the\n-        // pattern.\n-        let llptr = arg.to_ref_llval(bcx);\n-        bcx = bind_irrefutable_pat(bcx, pat, llptr, BindArgument);\n-    }\n+    match simple_identifier(pat) {\n+        Some(path) => {\n+            // Generate nicer LLVM for the common case of fn a pattern\n+            // like `x: T`\n+            mk_binding_alloca(\n+                bcx, pat.id, path, BindArgument, arg_scope, arg,\n+                |arg, bcx, llval, _| arg.store_to(bcx, llval))\n+        }\n \n-    return bcx;\n+        None => {\n+            // General path. Copy out the values that are used in the\n+            // pattern.\n+            let arg = unpack_datum!(\n+                bcx, arg.to_lvalue_datum_in_scope(bcx, \"__arg\", arg_scope));\n+            bind_irrefutable_pat(bcx, pat, arg.val,\n+                                 BindArgument, arg_scope)\n+        }\n+    }\n }\n \n-fn mk_binding_alloca<'a>(\n-                     bcx: &'a Block<'a>,\n-                     p_id: ast::NodeId,\n-                     path: &ast::Path,\n-                     binding_mode: IrrefutablePatternBindingMode,\n-                     populate: |&'a Block<'a>, Datum| -> &'a Block<'a>)\n-                     -> &'a Block<'a> {\n+fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n+                           p_id: ast::NodeId,\n+                           path: &ast::Path,\n+                           binding_mode: IrrefutablePatternBindingMode,\n+                           cleanup_scope: cleanup::ScopeId,\n+                           arg: A,\n+                           populate: |A, &'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>)\n+                         -> &'a Block<'a> {\n     let var_ty = node_id_type(bcx, p_id);\n     let ident = ast_util::path_to_ident(path);\n+\n+    // Allocate memory on stack for the binding.\n     let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));\n-    let datum = Datum {\n-        val: llval,\n-        ty: var_ty,\n-        mode: ByRef(ZeroMem)\n+\n+    // Subtle: be sure that we *populate* the memory *before*\n+    // we schedule the cleanup.\n+    let bcx = populate(arg, bcx, llval, var_ty);\n+    bcx.fcx.schedule_drop_mem(cleanup_scope, llval, var_ty);\n+\n+    // Now that memory is initialized and has cleanup scheduled,\n+    // create the datum and insert into the local variable map.\n+    let datum = Datum(llval, var_ty, Lvalue);\n+    let mut llmap = match binding_mode {\n+        BindLocal => bcx.fcx.lllocals.borrow_mut(),\n+        BindArgument => bcx.fcx.llargs.borrow_mut()\n     };\n-    {\n-        let mut llmap = match binding_mode {\n-            BindLocal => bcx.fcx.lllocals.borrow_mut(),\n-            BindArgument => bcx.fcx.llargs.borrow_mut()\n-        };\n-        llmap.get().insert(p_id, datum);\n-    }\n-    let bcx = populate(bcx, datum);\n-    datum.add_clean(bcx);\n+    llmap.get().insert(p_id, datum);\n     bcx\n }\n \n fn bind_irrefutable_pat<'a>(\n                         bcx: &'a Block<'a>,\n                         pat: @ast::Pat,\n                         val: ValueRef,\n-                        binding_mode: IrrefutablePatternBindingMode)\n+                        binding_mode: IrrefutablePatternBindingMode,\n+                        cleanup_scope: cleanup::ScopeId)\n                         -> &'a Block<'a> {\n     /*!\n      * A simple version of the pattern matching code that only handles\n@@ -2103,11 +2090,10 @@ fn bind_irrefutable_pat<'a>(\n      * # Arguments\n      * - bcx: starting basic block context\n      * - pat: the irrefutable pattern being matched.\n-     * - val: a pointer to the value being matched. If pat matches a value\n-     *   of type T, then this is a T*. If the value is moved from `pat`,\n-     *   then `*pat` will be zeroed; otherwise, it's existing cleanup\n-     *   applies.\n+     * - val: the value being matched -- must be an lvalue (by ref, with cleanup)\n      * - binding_mode: is this for an argument or a local variable?\n+     *\n+     * FIXME: convert `val` to `Datum<Lvalue>` for more type safety\n      */\n \n     debug!(\"bind_irrefutable_pat(bcx={}, pat={}, binding_mode={:?})\",\n@@ -2133,32 +2119,29 @@ fn bind_irrefutable_pat<'a>(\n                 // binding will live and place it into the appropriate\n                 // map.\n                 bcx = mk_binding_alloca(\n-                    bcx, pat.id, path, binding_mode,\n-                    |bcx, var_datum| {\n+                    bcx, pat.id, path, binding_mode, cleanup_scope, (),\n+                    |(), bcx, llval, ty| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {\n                                 // By value binding: move the value that `val`\n                                 // points at into the binding's stack slot.\n-                                let datum = Datum {\n-                                    val: val,\n-                                    ty: var_datum.ty,\n-                                    mode: ByRef(ZeroMem)\n-                                };\n-                                datum.store_to(bcx, INIT, var_datum.val)\n+                                let d = Datum(val, ty, Lvalue);\n+                                d.store_to(bcx, llval)\n                             }\n \n                             ast::BindByRef(_) => {\n                                 // By ref binding: the value of the variable\n                                 // is the pointer `val` itself.\n-                                Store(bcx, val, var_datum.val);\n+                                Store(bcx, val, llval);\n                                 bcx\n                             }\n                         }\n                     });\n             }\n \n             for &inner_pat in inner.iter() {\n-                bcx = bind_irrefutable_pat(bcx, inner_pat, val, binding_mode);\n+                bcx = bind_irrefutable_pat(bcx, inner_pat, val,\n+                                           binding_mode, cleanup_scope);\n             }\n         }\n         ast::PatEnum(_, ref sub_pats) => {\n@@ -2176,7 +2159,8 @@ fn bind_irrefutable_pat<'a>(\n                     for sub_pat in sub_pats.iter() {\n                         for (i, argval) in args.vals.iter().enumerate() {\n                             bcx = bind_irrefutable_pat(bcx, sub_pat[i],\n-                                                       *argval, binding_mode);\n+                                                       *argval, binding_mode,\n+                                                       cleanup_scope);\n                         }\n                     }\n                 }\n@@ -2193,7 +2177,8 @@ fn bind_irrefutable_pat<'a>(\n                                 let fldptr = adt::trans_field_ptr(bcx, repr,\n                                                                   val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx, *elem,\n-                                                           fldptr, binding_mode);\n+                                                           fldptr, binding_mode,\n+                                                           cleanup_scope);\n                             }\n                         }\n                     }\n@@ -2214,24 +2199,26 @@ fn bind_irrefutable_pat<'a>(\n                     let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n                                                       discr, ix);\n-                    bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, binding_mode);\n+                    bcx = bind_irrefutable_pat(bcx, f.pat, fldptr,\n+                                               binding_mode, cleanup_scope);\n                 }\n             })\n         }\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for (i, elem) in elems.iter().enumerate() {\n                 let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n-                bcx = bind_irrefutable_pat(bcx, *elem, fldptr, binding_mode);\n+                bcx = bind_irrefutable_pat(bcx, *elem, fldptr,\n+                                           binding_mode, cleanup_scope);\n             }\n         }\n         ast::PatUniq(inner) => {\n             let llbox = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, inner, llbox, binding_mode);\n+            bcx = bind_irrefutable_pat(bcx, inner, llbox, binding_mode, cleanup_scope);\n         }\n         ast::PatRegion(inner) => {\n             let loaded_val = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode);\n+            bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode, cleanup_scope);\n         }\n         ast::PatVec(..) => {\n             bcx.tcx().sess.span_bug(\n@@ -2243,14 +2230,4 @@ fn bind_irrefutable_pat<'a>(\n     return bcx;\n }\n \n-fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Path> {\n-    match pat.node {\n-        ast::PatIdent(ast::BindByValue(_), ref path, None) => {\n-            Some(path)\n-        }\n-        _ => {\n-            None\n-        }\n-    }\n-}\n "}, {"sha": "91dcae2d1d3084659e8e7fdd2a627366a23e187f", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -628,6 +628,25 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n     }\n }\n \n+/// Access a field, at a point when the value's case is known.\n+pub fn deref_ty(ccx: &CrateContext, r: &Repr) -> ty::t {\n+    match *r {\n+        CEnum(..) => {\n+            ccx.sess.bug(\"deref of c-like enum\")\n+        }\n+        Univariant(ref st, _) => {\n+            st.fields[0]\n+        }\n+        General(_, ref cases) => {\n+            assert!(cases.len() == 1);\n+            cases[0].fields[0]\n+        }\n+        NullablePointer{ .. } => {\n+            ccx.sess.bug(\"deref of nullable ptr\")\n+        }\n+    }\n+}\n+\n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n                        ix: uint) -> ValueRef {"}, {"sha": "bae35f68ada5630dd3e51edb4db1b6b358232356", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -18,8 +18,10 @@ use lib;\n use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::common::*;\n-use middle::trans::expr::*;\n-use middle::trans::type_of::*;\n+use middle::trans::cleanup;\n+use middle::trans::cleanup::CleanupMethods;\n+use middle::trans::expr;\n+use middle::trans::type_of;\n \n use middle::trans::type_::Type;\n \n@@ -28,26 +30,23 @@ use syntax::ast;\n // Take an inline assembly expression and splat it out via LLVM\n pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n                         -> &'a Block<'a> {\n+    let fcx = bcx.fcx;\n     let mut bcx = bcx;\n     let mut constraints = ~[];\n-    let mut cleanups = ~[];\n     let mut output_types = ~[];\n \n+    let temp_scope = fcx.push_custom_cleanup_scope();\n+\n     // Prepare the output operands\n     let outputs = ia.outputs.map(|&(c, out)| {\n         constraints.push(c);\n \n-        let out_datum = unpack_datum!(bcx, trans_to_datum(bcx, out));\n-        output_types.push(type_of(bcx.ccx(), out_datum.ty));\n+        let out_datum = unpack_datum!(bcx, expr::trans(bcx, out));\n+        output_types.push(type_of::type_of(bcx.ccx(), out_datum.ty));\n         out_datum.val\n \n     });\n \n-    for c in cleanups.iter() {\n-        revoke_clean(bcx, *c);\n-    }\n-    cleanups.clear();\n-\n     // Now the input operands\n     let inputs = ia.inputs.map(|&(c, input)| {\n         constraints.push(c);\n@@ -56,14 +55,13 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n             callee::trans_arg_expr(bcx,\n                                    expr_ty(bcx, input),\n                                    input,\n-                                   &mut cleanups,\n+                                   cleanup::CustomScope(temp_scope),\n                                    callee::DontAutorefArg)\n         })\n     });\n \n-    for c in cleanups.iter() {\n-        revoke_clean(bcx, *c);\n-    }\n+    // no failure occurred preparing operands, no need to cleanup\n+    fcx.pop_custom_cleanup_scope(temp_scope);\n \n     let mut constraints = constraints.connect(\",\");\n "}, {"sha": "ca618250c27f755a1ceb4842d1959ab3521a966a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 129, "deletions": 752, "changes": 881, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -37,17 +37,18 @@ use metadata::{csearch, encoder};\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::lang_items::{MallocFnLangItem, ClosureExchangeMallocFnLangItem};\n-use middle::lang_items::{EhPersonalityLangItem};\n use middle::trans::_match;\n use middle::trans::adt;\n-use middle::trans::base;\n use middle::trans::build::*;\n use middle::trans::builder::{Builder, noname};\n use middle::trans::callee;\n+use middle::trans::cleanup;\n+use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::controlflow;\n use middle::trans::datum;\n+// use middle::trans::datum::{Datum, Lvalue, Rvalue, ByRef, ByValue};\n use middle::trans::debuginfo;\n use middle::trans::expr;\n use middle::trans::foreign;\n@@ -75,15 +76,12 @@ use std::hashmap::HashMap;\n use std::libc::c_uint;\n use std::vec;\n use std::local_data;\n-use syntax::ast::Name;\n use syntax::ast_map::{PathName, PathPrettyName, path_elem_to_str};\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n-use syntax::parse::token::{special_idents};\n-use syntax::print::pprust::stmt_to_str;\n-use syntax::{ast, ast_util, codemap, ast_map};\n+use syntax::{ast, ast_util, ast_map};\n use syntax::attr::AttrMetaMethods;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n use syntax::visit;\n@@ -757,7 +755,8 @@ pub fn iter_structural_ty<'r,\n           }\n       }\n       ty::ty_enum(tid, ref substs) => {\n-          let ccx = cx.ccx();\n+          let fcx = cx.fcx;\n+          let ccx = fcx.ccx;\n \n           let repr = adt::represent_type(ccx, t);\n           let variants = ty::enum_variants(ccx.tcx, tid);\n@@ -773,16 +772,16 @@ pub fn iter_structural_ty<'r,\n               }\n               (_match::switch, Some(lldiscrim_a)) => {\n                   cx = f(cx, lldiscrim_a, ty::mk_int());\n-                  let unr_cx = sub_block(cx, \"enum-iter-unr\");\n+                  let unr_cx = fcx.new_temp_block(\"enum-iter-unr\");\n                   Unreachable(unr_cx);\n                   let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb,\n                                         n_variants);\n-                  let next_cx = sub_block(cx, \"enum-iter-next\");\n+                  let next_cx = fcx.new_temp_block(\"enum-iter-next\");\n \n                   for variant in (*variants).iter() {\n                       let variant_cx =\n-                          sub_block(cx, ~\"enum-iter-variant-\" +\n-                                    variant.disr_val.to_str());\n+                          fcx.new_temp_block(~\"enum-iter-variant-\" +\n+                                             variant.disr_val.to_str());\n                       let variant_cx =\n                           iter_variant(variant_cx, repr, av, *variant,\n                                        substs.tps, |x,y,z| f(x,y,z));\n@@ -929,23 +928,27 @@ pub fn invoke<'a>(\n         return (C_null(Type::i8()), bcx);\n     }\n \n-    match bcx.node_info {\n-        None => debug!(\"invoke at ???\"),\n-        Some(node_info) => {\n+    match bcx.opt_node_id {\n+        None => {\n+            debug!(\"invoke at ???\");\n+        }\n+        Some(id) => {\n             debug!(\"invoke at {}\",\n-                   bcx.sess().codemap.span_to_str(node_info.span));\n+                   ast_map::node_id_to_str(bcx.tcx().items,\n+                                           id,\n+                                           token::get_ident_interner()));\n         }\n     }\n \n-    if need_invoke(bcx) {\n+    if bcx.fcx.needs_invoke() {\n         unsafe {\n             debug!(\"invoking {} at {}\", llfn, bcx.llbb);\n             for &llarg in llargs.iter() {\n                 debug!(\"arg: {}\", llarg);\n             }\n         }\n-        let normal_bcx = sub_block(bcx, \"normal return\");\n-        let landing_pad = get_landing_pad(bcx);\n+        let normal_bcx = bcx.fcx.new_temp_block(\"normal-return\");\n+        let landing_pad = bcx.fcx.get_landing_pad();\n \n         match call_info {\n             Some(info) => debuginfo::set_source_location(bcx.fcx, info.id, info.span),\n@@ -987,146 +990,9 @@ pub fn need_invoke(bcx: &Block) -> bool {\n         return false;\n     }\n \n-    if have_cached_lpad(bcx) {\n-        return true;\n-    }\n-\n-    // Walk the scopes to look for cleanups\n-    let mut cur = bcx;\n-    let mut cur_scope = cur.scope.get();\n-    loop {\n-        cur_scope = match cur_scope {\n-            Some(inf) => {\n-                let cleanups = inf.cleanups.borrow();\n-                for cleanup in cleanups.get().iter() {\n-                    match *cleanup {\n-                        Clean(_, cleanup_type) | CleanTemp(_, _, cleanup_type) => {\n-                            if cleanup_type == normal_exit_and_unwind {\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                }\n-                inf.parent\n-            }\n-            None => {\n-                cur = match cur.parent {\n-                    Some(next) => next,\n-                    None => return false\n-                };\n-                cur.scope.get()\n-            }\n-        }\n-    }\n-}\n-\n-pub fn have_cached_lpad(bcx: &Block) -> bool {\n-    let mut res = false;\n-    in_lpad_scope_cx(bcx, |inf| {\n-        match inf.landing_pad.get() {\n-          Some(_) => res = true,\n-          None => res = false\n-        }\n-    });\n-    return res;\n+    bcx.fcx.needs_invoke()\n }\n \n-pub fn in_lpad_scope_cx<'a>(bcx: &'a Block<'a>, f: |si: &'a ScopeInfo<'a>|) {\n-    let mut bcx = bcx;\n-    let mut cur_scope = bcx.scope.get();\n-    loop {\n-        cur_scope = match cur_scope {\n-            Some(inf) => {\n-                if !inf.empty_cleanups() || (inf.parent.is_none() && bcx.parent.is_none()) {\n-                    f(inf);\n-                    return;\n-                }\n-                inf.parent\n-            }\n-            None => {\n-                bcx = block_parent(bcx);\n-                bcx.scope.get()\n-            }\n-        }\n-    }\n-}\n-\n-pub fn get_landing_pad<'a>(bcx: &'a Block<'a>) -> BasicBlockRef {\n-    let _icx = push_ctxt(\"get_landing_pad\");\n-\n-    let mut cached = None;\n-    let mut pad_bcx = bcx; // Guaranteed to be set below\n-    in_lpad_scope_cx(bcx, |inf| {\n-        // If there is a valid landing pad still around, use it\n-        match inf.landing_pad.get() {\n-          Some(target) => cached = Some(target),\n-          None => {\n-            pad_bcx = lpad_block(bcx, \"unwind\");\n-            inf.landing_pad.set(Some(pad_bcx.llbb));\n-          }\n-        }\n-    });\n-    // Can't return from block above\n-    match cached { Some(b) => return b, None => () }\n-    // The landing pad return type (the type being propagated). Not sure what\n-    // this represents but it's determined by the personality function and\n-    // this is what the EH proposal example uses.\n-    let llretty = Type::struct_([Type::i8p(), Type::i32()], false);\n-    // The exception handling personality function.\n-    let personality = callee::trans_fn_ref(bcx,\n-                                           langcall(bcx, None, \"\", EhPersonalityLangItem),\n-                                           0).llfn;\n-    // The only landing pad clause will be 'cleanup'\n-    let llretval = LandingPad(pad_bcx, llretty, personality, 1u);\n-    // The landing pad block is a cleanup\n-    SetCleanup(pad_bcx, llretval);\n-\n-    // We store the retval in a function-central alloca, so that calls to\n-    // Resume can find it.\n-    match bcx.fcx.personality.get() {\n-      Some(addr) => Store(pad_bcx, llretval, addr),\n-      None => {\n-        let addr = alloca(pad_bcx, val_ty(llretval), \"\");\n-        bcx.fcx.personality.set(Some(addr));\n-        Store(pad_bcx, llretval, addr);\n-      }\n-    }\n-\n-    // Unwind all parent scopes, and finish with a Resume instr\n-    cleanup_and_leave(pad_bcx, None, None);\n-    return pad_bcx.llbb;\n-}\n-\n-pub fn find_bcx_for_scope<'a>(bcx: &'a Block<'a>, scope_id: ast::NodeId)\n-                          -> &'a Block<'a> {\n-    let mut bcx_sid = bcx;\n-    let mut cur_scope = bcx_sid.scope.get();\n-    loop {\n-        cur_scope = match cur_scope {\n-            Some(inf) => {\n-                match inf.node_info {\n-                    Some(NodeInfo { id, .. }) if id == scope_id => {\n-                        return bcx_sid\n-                    }\n-                    // FIXME(#6268, #6248) hacky cleanup for nested method calls\n-                    Some(NodeInfo { callee_id: Some(id), .. }) if id == scope_id => {\n-                        return bcx_sid\n-                    }\n-                    _ => inf.parent\n-                }\n-            }\n-            None => {\n-                bcx_sid = match bcx_sid.parent {\n-                    None => bcx.tcx().sess.bug(format!(\"no enclosing scope with id {}\", scope_id)),\n-                    Some(bcx_par) => bcx_par\n-                };\n-                bcx_sid.scope.get()\n-            }\n-        }\n-    }\n-}\n-\n-\n pub fn do_spill(bcx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n         return C_null(Type::i8p());\n@@ -1181,376 +1047,15 @@ pub fn init_local<'a>(bcx: &'a Block<'a>, local: &ast::Local)\n         }\n     }\n \n-    _match::store_local(bcx, local.pat, local.init)\n-}\n-\n-pub fn trans_stmt<'a>(cx: &'a Block<'a>, s: &ast::Stmt) -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"trans_stmt\");\n-    debug!(\"trans_stmt({})\", stmt_to_str(s, cx.tcx().sess.intr()));\n-\n-    if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, stmt_to_str(s, cx.ccx().sess.intr()));\n-    }\n-\n-    let mut bcx = cx;\n-\n-    match s.node {\n-        ast::StmtExpr(e, _) | ast::StmtSemi(e, _) => {\n-            bcx = expr::trans_into(cx, e, expr::Ignore);\n-        }\n-        ast::StmtDecl(d, _) => {\n-            match d.node {\n-                ast::DeclLocal(ref local) => {\n-                    bcx = init_local(bcx, *local);\n-                    if cx.sess().opts.extra_debuginfo {\n-                        debuginfo::create_local_var_metadata(bcx, *local);\n-                    }\n-                }\n-                ast::DeclItem(i) => trans_item(cx.fcx.ccx, i)\n-            }\n-        }\n-        ast::StmtMac(..) => cx.tcx().sess.bug(\"unexpanded macro\")\n-    }\n-\n-    return bcx;\n-}\n-\n-// You probably don't want to use this one. See the\n-// next three functions instead.\n-pub fn new_block<'a>(\n-                 cx: &'a FunctionContext<'a>,\n-                 parent: Option<&'a Block<'a>>,\n-                 scope: Option<&'a ScopeInfo<'a>>,\n-                 is_lpad: bool,\n-                 name: &str,\n-                 opt_node_info: Option<NodeInfo>)\n-                 -> &'a Block<'a> {\n-    unsafe {\n-        let llbb = name.with_c_str(|buf| {\n-            llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n-        });\n-        let bcx = Block::new(llbb, parent, is_lpad, opt_node_info, cx);\n-        bcx.scope.set(scope);\n-        for cx in parent.iter() {\n-            if cx.unreachable.get() {\n-                Unreachable(bcx);\n-                break;\n-            }\n-        }\n-        bcx\n-    }\n-}\n-\n-pub fn simple_block_scope<'a>(\n-                          fcx: &'a FunctionContext<'a>,\n-                          parent: Option<&'a ScopeInfo<'a>>,\n-                          node_info: Option<NodeInfo>)\n-                          -> &'a ScopeInfo<'a> {\n-    fcx.scope_info_arena.alloc(ScopeInfo {\n-        parent: parent,\n-        loop_break: None,\n-        loop_label: None,\n-        cleanups: RefCell::new(~[]),\n-        cleanup_paths: RefCell::new(~[]),\n-        landing_pad: Cell::new(None),\n-        node_info: node_info,\n-    })\n-}\n-\n-// Use this when you're at the top block of a function or the like.\n-pub fn top_scope_block<'a>(\n-                       fcx: &'a FunctionContext<'a>,\n-                       opt_node_info: Option<NodeInfo>)\n-                       -> &'a Block<'a> {\n-    new_block(fcx,\n-              None,\n-              Some(simple_block_scope(fcx, None, opt_node_info)),\n-              false,\n-              \"function top level\",\n-              opt_node_info)\n-}\n-\n-pub fn scope_block<'a>(\n-                   bcx: &'a Block<'a>,\n-                   opt_node_info: Option<NodeInfo>,\n-                   n: &str)\n-                   -> &'a Block<'a> {\n-    new_block(bcx.fcx,\n-              Some(bcx),\n-              Some(simple_block_scope(bcx.fcx, None, opt_node_info)),\n-              bcx.is_lpad,\n-              n,\n-              opt_node_info)\n-}\n-\n-pub fn loop_scope_block<'a>(\n-                        bcx: &'a Block<'a>,\n-                        loop_break: &'a Block<'a>,\n-                        loop_label: Option<Name>,\n-                        n: &str,\n-                        opt_node_info: Option<NodeInfo>)\n-                        -> &'a Block<'a> {\n-    new_block(bcx.fcx,\n-              Some(bcx),\n-              Some(bcx.fcx.scope_info_arena.alloc(ScopeInfo {\n-                parent: None,\n-                loop_break: Some(loop_break),\n-                loop_label: loop_label,\n-                cleanups: RefCell::new(~[]),\n-                cleanup_paths: RefCell::new(~[]),\n-                landing_pad: Cell::new(None),\n-                node_info: opt_node_info,\n-              })),\n-              bcx.is_lpad,\n-              n,\n-              opt_node_info)\n-}\n-\n-// Use this when creating a block for the inside of a landing pad.\n-pub fn lpad_block<'a>(bcx: &'a Block<'a>, n: &str) -> &'a Block<'a> {\n-    new_block(bcx.fcx, Some(bcx), None, true, n, None)\n-}\n-\n-// Use this when you're making a general CFG BB within a scope.\n-pub fn sub_block<'a>(bcx: &'a Block<'a>, n: &str) -> &'a Block<'a> {\n-    new_block(bcx.fcx, Some(bcx), None, bcx.is_lpad, n, None)\n+    _match::store_local(bcx, local)\n }\n \n pub fn raw_block<'a>(\n                  fcx: &'a FunctionContext<'a>,\n                  is_lpad: bool,\n                  llbb: BasicBlockRef)\n                  -> &'a Block<'a> {\n-    Block::new(llbb, None, is_lpad, None, fcx)\n-}\n-\n-\n-// trans_block_cleanups: Go through all the cleanups attached to this\n-// block and execute them.\n-//\n-// When translating a block that introduces new variables during its scope, we\n-// need to make sure those variables go out of scope when the block ends.  We\n-// do that by running a 'cleanup' function for each variable.\n-// trans_block_cleanups runs all the cleanup functions for the block.\n-pub fn trans_block_cleanups<'a>(bcx: &'a Block<'a>, cleanups: ~[cleanup])\n-                            -> &'a Block<'a> {\n-    trans_block_cleanups_(bcx, cleanups, false)\n-}\n-\n-pub fn trans_block_cleanups_<'a>(\n-                             bcx: &'a Block<'a>,\n-                             cleanups: &[cleanup],\n-                             is_lpad: bool)\n-                             -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"trans_block_cleanups\");\n-    // NB: Don't short-circuit even if this block is unreachable because\n-    // GC-based cleanup needs to the see that the roots are live.\n-    let no_lpads = bcx.ccx().sess.no_landing_pads();\n-    if bcx.unreachable.get() && !no_lpads {\n-        return bcx\n-    }\n-    let mut bcx = bcx;\n-    for cu in cleanups.rev_iter() {\n-        match *cu {\n-            Clean(cfn, cleanup_type) | CleanTemp(_, cfn, cleanup_type) => {\n-                // Some types don't need to be cleaned up during\n-                // landing pads because they can be freed en mass later\n-                if cleanup_type == normal_exit_and_unwind || !is_lpad {\n-                    bcx = cfn.clean(bcx);\n-                }\n-            }\n-        }\n-    }\n-    return bcx;\n-}\n-\n-// In the last argument, Some(block) mean jump to this block, and none means\n-// this is a landing pad and leaving should be accomplished with a resume\n-// instruction.\n-pub fn cleanup_and_leave<'a>(\n-                         bcx: &'a Block<'a>,\n-                         upto: Option<BasicBlockRef>,\n-                         leave: Option<BasicBlockRef>) {\n-    let _icx = push_ctxt(\"cleanup_and_leave\");\n-    let mut cur = bcx;\n-    let mut bcx = bcx;\n-    let is_lpad = leave == None;\n-    loop {\n-        debug!(\"cleanup_and_leave: leaving {}\", cur.to_str());\n-\n-        let mut cur_scope = cur.scope.get();\n-        loop {\n-            cur_scope = match cur_scope {\n-                Some (inf) if !inf.empty_cleanups() => {\n-                    let (sub_cx, dest, inf_cleanups) = {\n-                        let inf = &*inf;\n-                        let mut skip = 0;\n-                        let mut dest = None;\n-                        {\n-                            let cleanup_paths = inf.cleanup_paths.borrow();\n-                            let r = cleanup_paths.get()\n-                                                 .rev_iter()\n-                                                 .find(|cp| {\n-                                cp.target == leave\n-                            });\n-                            for cp in r.iter() {\n-                                let cleanups = inf.cleanups.borrow();\n-                                if cp.size == cleanups.get().len() {\n-                                    Br(bcx, cp.dest);\n-                                    return;\n-                                }\n-\n-                                skip = cp.size;\n-                                dest = Some(cp.dest);\n-                            }\n-                        }\n-                        let sub_cx = sub_block(bcx, \"cleanup\");\n-                        Br(bcx, sub_cx.llbb);\n-                        let cleanups = inf.cleanups.borrow();\n-                        let mut cleanup_paths = inf.cleanup_paths\n-                                                   .borrow_mut();\n-                        cleanup_paths.get().push(cleanup_path {\n-                            target: leave,\n-                            size: cleanups.get().len(),\n-                            dest: sub_cx.llbb\n-                        });\n-                        (sub_cx, dest, cleanups.get().tailn(skip).to_owned())\n-                    };\n-                    bcx = trans_block_cleanups_(sub_cx,\n-                                                inf_cleanups,\n-                                                is_lpad);\n-                    for &dest in dest.iter() {\n-                        Br(bcx, dest);\n-                        return;\n-                    }\n-                    inf.parent\n-                }\n-                Some(inf) => inf.parent,\n-                None => break\n-            }\n-        }\n-\n-        match upto {\n-          Some(bb) => { if cur.llbb == bb { break; } }\n-          _ => ()\n-        }\n-        cur = match cur.parent {\n-          Some(next) => next,\n-          None => { assert!(upto.is_none()); break; }\n-        };\n-    }\n-    match leave {\n-      Some(target) => Br(bcx, target),\n-      None => {\n-          let ll_load = Load(bcx, bcx.fcx.personality.get().unwrap());\n-          Resume(bcx, ll_load);\n-      }\n-    }\n-}\n-\n-pub fn cleanup_block<'a>(bcx: &'a Block<'a>, upto: Option<BasicBlockRef>)\n-                     -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"cleanup_block\");\n-    let mut cur = bcx;\n-    let mut bcx = bcx;\n-    loop {\n-        debug!(\"cleanup_block: {}\", cur.to_str());\n-\n-        let mut cur_scope = cur.scope.get();\n-        loop {\n-            cur_scope = match cur_scope {\n-                Some(inf) => {\n-                    let cleanups = inf.cleanups.borrow();\n-                    bcx = trans_block_cleanups_(bcx,\n-                                                cleanups.get().to_owned(),\n-                                                false);\n-                    inf.parent\n-                }\n-                None => break\n-            }\n-        }\n-\n-        match upto {\n-          Some(bb) => { if cur.llbb == bb { break; } }\n-          _ => ()\n-        }\n-        cur = match cur.parent {\n-          Some(next) => next,\n-          None => { assert!(upto.is_none()); break; }\n-        };\n-    }\n-    bcx\n-}\n-\n-pub fn cleanup_and_Br<'a>(\n-                      bcx: &'a Block<'a>,\n-                      upto: &'a Block<'a>,\n-                      target: BasicBlockRef) {\n-    let _icx = push_ctxt(\"cleanup_and_Br\");\n-    cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n-}\n-\n-pub fn leave_block<'a>(bcx: &'a Block<'a>, out_of: &'a Block<'a>)\n-                   -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"leave_block\");\n-    let next_cx = sub_block(block_parent(out_of), \"next\");\n-    if bcx.unreachable.get() {\n-        Unreachable(next_cx);\n-    }\n-    cleanup_and_Br(bcx, out_of, next_cx.llbb);\n-    next_cx\n-}\n-\n-pub fn with_scope<'a>(\n-                  bcx: &'a Block<'a>,\n-                  opt_node_info: Option<NodeInfo>,\n-                  name: &str,\n-                  f: |&'a Block<'a>| -> &'a Block<'a>)\n-                  -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"with_scope\");\n-\n-    debug!(\"with_scope(bcx={}, opt_node_info={:?}, name={})\",\n-           bcx.to_str(), opt_node_info, name);\n-    let _indenter = indenter();\n-\n-    let scope = simple_block_scope(bcx.fcx, bcx.scope.get(), opt_node_info);\n-    bcx.scope.set(Some(scope));\n-    let ret = f(bcx);\n-    let ret = trans_block_cleanups_(ret, scope.cleanups.get(), false);\n-    bcx.scope.set(scope.parent);\n-    ret\n-}\n-\n-pub fn with_scope_result<'a>(\n-                         bcx: &'a Block<'a>,\n-                         opt_node_info: Option<NodeInfo>,\n-                         _name: &str,\n-                         f: |&'a Block<'a>| -> Result<'a>)\n-                         -> Result<'a> {\n-    let _icx = push_ctxt(\"with_scope_result\");\n-\n-    let scope = simple_block_scope(bcx.fcx, bcx.scope.get(), opt_node_info);\n-    bcx.scope.set(Some(scope));\n-    let Result { bcx: out_bcx, val } = f(bcx);\n-    let out_bcx = trans_block_cleanups_(out_bcx, scope.cleanups.get(), false);\n-    bcx.scope.set(scope.parent);\n-\n-    rslt(out_bcx, val)\n-}\n-\n-pub fn with_scope_datumblock<'a>(\n-                             bcx: &'a Block<'a>,\n-                             opt_node_info: Option<NodeInfo>,\n-                             name: &str,\n-                             f: |&'a Block| -> datum::DatumBlock<'a>)\n-                             -> datum::DatumBlock<'a> {\n-    use middle::trans::datum::DatumBlock;\n-\n-    let _icx = push_ctxt(\"with_scope_result\");\n-    let scope_cx = scope_block(bcx, opt_node_info, name);\n-    Br(bcx, scope_cx.llbb);\n-    let DatumBlock {bcx, datum} = f(scope_cx);\n-    DatumBlock {bcx: leave_block(bcx, scope_cx), datum: datum}\n+    Block::new(llbb, is_lpad, None, fcx)\n }\n \n pub fn block_locals(b: &ast::Block, it: |@ast::Local|) {\n@@ -1573,8 +1078,9 @@ pub fn with_cond<'a>(\n                  f: |&'a Block<'a>| -> &'a Block<'a>)\n                  -> &'a Block<'a> {\n     let _icx = push_ctxt(\"with_cond\");\n-    let next_cx = base::sub_block(bcx, \"next\");\n-    let cond_cx = base::sub_block(bcx, \"cond\");\n+    let fcx = bcx.fcx;\n+    let next_cx = fcx.new_temp_block(\"next\");\n+    let cond_cx = fcx.new_temp_block(\"cond\");\n     CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n     let after_cx = f(cond_cx);\n     if !after_cx.terminated.get() {\n@@ -1725,24 +1231,25 @@ pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n // NB: must keep 4 fns in sync:\n //\n //  - type_of_fn\n-//  - create_llargs_for_fn_args.\n+//  - create_datums_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n //\n // Be warned! You must call `init_function` before doing anything with the\n // returned function context.\n-pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n-                        path: ast_map::Path,\n-                        llfndecl: ValueRef,\n-                        id: ast::NodeId,\n-                        output_type: ty::t,\n-                        param_substs: Option<@param_substs>,\n-                        sp: Option<Span>)\n-                        -> FunctionContext {\n+pub fn new_fn_ctxt_detailed(ccx: @CrateContext,\n+                            path: ast_map::Path,\n+                            llfndecl: ValueRef,\n+                            id: ast::NodeId,\n+                            output_type: ty::t,\n+                            param_substs: Option<@param_substs>,\n+                            sp: Option<Span>)\n+                            -> FunctionContext {\n     for p in param_substs.iter() { p.validate(); }\n \n-    debug!(\"new_fn_ctxt_w_id(path={}, id={:?}, \\\n-            param_substs={})\",\n+    debug!(\"new_fn_ctxt_detailed(path={},\n+           id={:?}, \\\n+           param_substs={})\",\n            path_str(ccx.sess, path),\n            id,\n            param_substs.repr(ccx.tcx));\n@@ -1776,9 +1283,9 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n           span: sp,\n           path: path,\n           block_arena: TypedArena::new(),\n-          scope_info_arena: TypedArena::new(),\n           ccx: ccx,\n           debug_context: debug_context,\n+          scopes: RefCell::new(~[])\n     };\n     fcx.llenv.set(unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n@@ -1793,10 +1300,9 @@ pub fn init_function<'a>(\n                      fcx: &'a FunctionContext<'a>,\n                      skip_retptr: bool,\n                      output_type: ty::t,\n-                     param_substs: Option<@param_substs>,\n-                     opt_node_info: Option<NodeInfo>) {\n+                     param_substs: Option<@param_substs>) {\n     unsafe {\n-        let entry_bcx = top_scope_block(fcx, opt_node_info);\n+        let entry_bcx = fcx.new_temp_block(\"entry-block\");\n         Load(entry_bcx, C_null(Type::i8p()));\n \n         fcx.entry_bcx.set(Some(entry_bcx));\n@@ -1835,159 +1341,88 @@ pub fn new_fn_ctxt(ccx: @CrateContext,\n                    -> FunctionContext {\n     // FIXME(#11385): Do not call `init_function` here; it will typecheck\n     // but segfault.\n-    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, None, sp)\n+    new_fn_ctxt_detailed(ccx, path, llfndecl, -1, output_type, None, sp)\n }\n \n // NB: must keep 4 fns in sync:\n //\n //  - type_of_fn\n-//  - create_llargs_for_fn_args.\n+//  - create_datums_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n \n-// create_llargs_for_fn_args: Creates a mapping from incoming arguments to\n-// allocas created for them.\n-//\n-// When we translate a function, we need to map its incoming arguments to the\n-// spaces that have been created for them (by code in the llallocas field of\n-// the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n-// field of the fn_ctxt with\n-fn create_llargs_for_fn_args(cx: &FunctionContext,\n+fn arg_kind(cx: &FunctionContext, t: ty::t) -> datum::Rvalue {\n+    use middle::trans::datum::{ByRef, ByValue};\n+\n+    datum::Rvalue {\n+        mode: if arg_is_indirect(cx.ccx, t) { ByRef } else { ByValue }\n+    }\n+}\n+\n+// work around bizarre resolve errors\n+type RvalueDatum = datum::Datum<datum::Rvalue>;\n+type LvalueDatum = datum::Datum<datum::Lvalue>;\n+\n+// create_datums_for_fn_args: creates rvalue datums for `self` and each of the\n+// incoming function arguments. These will later be stored into\n+// appropriate lvalue datums.\n+fn create_datums_for_fn_args(cx: &FunctionContext,\n                              self_arg: Option<ty::t>,\n                              arg_tys: &[ty::t])\n-                             -> ~[datum::Datum] {\n-    let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n-\n-    match self_arg {\n-        Some(t) => {\n-            cx.llself.set(Some(datum::Datum {\n-                val: cx.llenv.get(),\n-                ty: t,\n-                mode: if arg_is_indirect(cx.ccx, t) {\n-                    datum::ByRef(datum::ZeroMem)\n-                } else {\n-                    datum::ByValue\n-                }\n-            }));\n-        }\n-        None => {}\n-    }\n+                             -> (Option<RvalueDatum>, ~[RvalueDatum]) {\n+    let _icx = push_ctxt(\"create_datums_for_fn_args\");\n+\n+    let self_datum = self_arg.map(\n+        |t| datum::Datum(cx.llenv.get(), t, arg_kind(cx, t)));\n \n     // Return an array wrapping the ValueRefs that we get from\n     // llvm::LLVMGetParam for each argument into datums.\n-    arg_tys.iter().enumerate().map(|(i, &arg_ty)| {\n-        let llarg = unsafe { llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint) };\n-        datum::Datum {\n-            val: llarg,\n-            ty: arg_ty,\n-            mode: if arg_is_indirect(cx.ccx, arg_ty) {\n-                datum::ByRef(datum::ZeroMem)\n-            } else {\n-                datum::ByValue\n-            }\n-        }\n-    }).collect()\n+    let arg_datums = arg_tys.iter().enumerate().map(|(i, &arg_ty)| {\n+            let llarg = unsafe {\n+                llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint)\n+            };\n+            datum::Datum(llarg, arg_ty, arg_kind(cx, arg_ty))\n+        }).collect();\n+\n+    (self_datum, arg_datums)\n }\n \n fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n+                            arg_scope: cleanup::CustomScopeIndex,\n                             bcx: &'a Block<'a>,\n                             args: &[ast::Arg],\n-                            method: Option<&ast::Method>,\n-                            raw_llargs: &[datum::Datum])\n+                            self_datum: Option<RvalueDatum>,\n+                            arg_datums: ~[RvalueDatum])\n                             -> &'a Block<'a> {\n-    debug!(\"copy_args_to_allocas: args=[{}]\",\n-           raw_llargs.map(|d| d.to_str(fcx.ccx)).connect(\", \"));\n+    debug!(\"copy_args_to_allocas\");\n \n     let _icx = push_ctxt(\"copy_args_to_allocas\");\n     let mut bcx = bcx;\n \n-    match fcx.llself.get() {\n-        Some(slf) => {\n-            let needs_indirection = if slf.mode.is_by_value() {\n-                // FIXME(eddyb) #11445 Always needs indirection because of cleanup.\n-                if true {\n-                    true\n-                } else {\n-                    match method {\n-                        Some(method) => {\n-                            match method.explicit_self.node {\n-                                ast::SelfValue(ast::MutMutable) => true,\n-                                _ => false\n-                            }\n-                        }\n-                        None => true\n-                    }\n-                }\n-            } else {\n-                false\n-            };\n-            let slf = if needs_indirection {\n-                // HACK(eddyb) this is just slf.to_ref_datum(bcx) with a named alloca.\n-                let alloc = alloc_ty(bcx, slf.ty, \"__self\");\n-                Store(bcx, slf.val, alloc);\n-                datum::Datum {\n-                    val: alloc,\n-                    ty: slf.ty,\n-                    mode: datum::ByRef(datum::ZeroMem)\n-                }\n-            } else {\n-                slf\n-            };\n-\n+    let arg_scope_id = cleanup::CustomScope(arg_scope);\n+    match self_datum {\n+        Some(slf_rv) => {\n+            let slf = unpack_datum!(\n+                bcx, slf_rv.to_lvalue_datum_in_scope(bcx, \"__self\",\n+                                                     arg_scope_id));\n             fcx.llself.set(Some(slf));\n-            slf.add_clean(bcx);\n-\n             if fcx.ccx.sess.opts.extra_debuginfo {\n                 debuginfo::create_self_argument_metadata(bcx, slf.ty, slf.val);\n             }\n         }\n         _ => {}\n     }\n \n-    for (i, &arg) in raw_llargs.iter().enumerate() {\n-        let needs_indirection = if arg.mode.is_by_value() {\n-            if fcx.ccx.sess.opts.extra_debuginfo {\n-                true\n-            } else {\n-                // FIXME(eddyb) #11445 Always needs indirection because of cleanup.\n-                if true {\n-                    true\n-                } else {\n-                    match args[i].pat.node {\n-                        ast::PatIdent(ast::BindByValue(ast::MutMutable), _, _) => true,\n-                        _ => false\n-                    }\n-                }\n-            }\n-        } else {\n-            false\n-        };\n+    for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n         // For certain mode/type combinations, the raw llarg values are passed\n         // by value.  However, within the fn body itself, we want to always\n         // have all locals and arguments be by-ref so that we can cancel the\n         // cleanup and for better interaction with LLVM's debug info.  So, if\n         // the argument would be passed by value, we store it into an alloca.\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n-        let arg = if needs_indirection {\n-            // HACK(eddyb) this is just arg.to_ref_datum(bcx) with a named alloca.\n-            let alloc = match args[i].pat.node {\n-                ast::PatIdent(_, ref path, _) => {\n-                    let name = ast_util::path_to_ident(path).name;\n-                    alloc_ty(bcx, arg.ty, token::interner_get(name))\n-                }\n-                _ => alloc_ty(bcx, arg.ty, \"__arg\")\n-            };\n-            Store(bcx, arg.val, alloc);\n-            datum::Datum {\n-                val: alloc,\n-                ty: arg.ty,\n-                mode: datum::ByRef(datum::ZeroMem)\n-            }\n-        } else {\n-            arg\n-        };\n-        bcx = _match::store_arg(bcx, args[i].pat, arg);\n+\n+        bcx = _match::store_arg(bcx, args[i].pat, arg_datum, arg_scope_id);\n \n         if fcx.ccx.sess.opts.extra_debuginfo {\n             debuginfo::create_argument_metadata(bcx, &args[i]);\n@@ -2056,7 +1491,6 @@ pub fn trans_closure(ccx: @CrateContext,\n                      self_arg: Option<ty::t>,\n                      param_substs: Option<@param_substs>,\n                      id: ast::NodeId,\n-                     method: Option<&ast::Method>,\n                      _attributes: &[ast::Attribute],\n                      output_type: ty::t,\n                      maybe_load_env: |&FunctionContext|) {\n@@ -2068,14 +1502,17 @@ pub fn trans_closure(ccx: @CrateContext,\n     debug!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx));\n \n-    let fcx = new_fn_ctxt_w_id(ccx,\n-                               path,\n-                               llfndecl,\n-                               id,\n-                               output_type,\n-                               param_substs,\n-                               Some(body.span));\n-    init_function(&fcx, false, output_type, param_substs, body.info());\n+    let fcx = new_fn_ctxt_detailed(ccx,\n+                                   path,\n+                                   llfndecl,\n+                                   id,\n+                                   output_type,\n+                                   param_substs,\n+                                   Some(body.span));\n+    init_function(&fcx, false, output_type, param_substs);\n+\n+    // cleanup scope for the incoming arguments\n+    let arg_scope = fcx.push_custom_cleanup_scope();\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n@@ -2085,9 +1522,11 @@ pub fn trans_closure(ccx: @CrateContext,\n \n     // Set up arguments to the function.\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    let raw_llargs = create_llargs_for_fn_args(&fcx, self_arg, arg_tys);\n+    let (self_datum, arg_datums) =\n+        create_datums_for_fn_args(&fcx, self_arg, arg_tys);\n \n-    bcx = copy_args_to_allocas(&fcx, bcx, decl.inputs, method, raw_llargs);\n+    bcx = copy_args_to_allocas(&fcx, arg_scope, bcx,\n+                               decl.inputs, self_datum, arg_datums);\n \n     maybe_load_env(&fcx);\n \n@@ -2108,8 +1547,15 @@ pub fn trans_closure(ccx: @CrateContext,\n     }\n \n     match fcx.llreturn.get() {\n-        Some(llreturn) => cleanup_and_Br(bcx, bcx_top, llreturn),\n-        None => bcx = cleanup_block(bcx, Some(bcx_top.llbb))\n+        Some(_) => {\n+            Br(bcx, fcx.return_exit_block());\n+            fcx.pop_custom_cleanup_scope(arg_scope);\n+        }\n+        None => {\n+            // Microoptimization writ large: avoid creating a separate\n+            // llreturn basic block\n+            bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n+        }\n     };\n \n     // Put return block after all other blocks.\n@@ -2135,9 +1581,7 @@ pub fn trans_fn(ccx: @CrateContext,\n                 self_arg: Option<ty::t>,\n                 param_substs: Option<@param_substs>,\n                 id: ast::NodeId,\n-                method: Option<&ast::Method>,\n                 attrs: &[ast::Attribute]) {\n-\n     let the_path_str = path_str(ccx.sess, path);\n     let _s = StatRecorder::new(ccx, the_path_str);\n     debug!(\"trans_fn(self_arg={:?}, param_substs={})\",\n@@ -2153,44 +1597,15 @@ pub fn trans_fn(ccx: @CrateContext,\n                   self_arg,\n                   param_substs,\n                   id,\n-                  method,\n                   attrs,\n                   output_type,\n                   |_fcx| { });\n }\n \n-fn insert_synthetic_type_entries(bcx: &Block,\n-                                 fn_args: &[ast::Arg],\n-                                 arg_tys: &[ty::t]) {\n-    /*!\n-     * For tuple-like structs and enum-variants, we generate\n-     * synthetic AST nodes for the arguments.  These have no types\n-     * in the type table and no entries in the moves table,\n-     * so the code in `copy_args_to_allocas` and `bind_irrefutable_pat`\n-     * gets upset. This hack of a function bridges the gap by inserting types.\n-     *\n-     * This feels horrible. I think we should just have a special path\n-     * for these functions and not try to use the generic code, but\n-     * that's not the problem I'm trying to solve right now. - nmatsakis\n-     */\n-\n-    let tcx = bcx.tcx();\n-    for i in range(0u, fn_args.len()) {\n-        debug!(\"setting type of argument {} (pat node {}) to {}\",\n-               i, fn_args[i].pat.id, bcx.ty_to_str(arg_tys[i]));\n-\n-        let pat_id = fn_args[i].pat.id;\n-        let arg_ty = arg_tys[i];\n-\n-        let mut node_types = tcx.node_types.borrow_mut();\n-        node_types.get().insert(pat_id as uint, arg_ty);\n-    }\n-}\n-\n pub fn trans_enum_variant(ccx: @CrateContext,\n                           _enum_id: ast::NodeId,\n                           variant: &ast::Variant,\n-                          args: &[ast::VariantArg],\n+                          _args: &[ast::VariantArg],\n                           disr: ty::Disr,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n@@ -2199,14 +1614,13 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n     trans_enum_variant_or_tuple_like_struct(\n         ccx,\n         variant.node.id,\n-        args,\n         disr,\n         param_substs,\n         llfndecl);\n }\n \n pub fn trans_tuple_struct(ccx: @CrateContext,\n-                          fields: &[ast::StructField],\n+                          _fields: &[ast::StructField],\n                           ctor_id: ast::NodeId,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n@@ -2215,46 +1629,16 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     trans_enum_variant_or_tuple_like_struct(\n         ccx,\n         ctor_id,\n-        fields,\n         0,\n         param_substs,\n         llfndecl);\n }\n \n-trait IdAndTy {\n-    fn id(&self) -> ast::NodeId;\n-    fn ty(&self) -> ast::P<ast::Ty>;\n-}\n-\n-impl IdAndTy for ast::VariantArg {\n-    fn id(&self) -> ast::NodeId { self.id }\n-    fn ty(&self) -> ast::P<ast::Ty> { self.ty }\n-}\n-\n-impl IdAndTy for ast::StructField {\n-    fn id(&self) -> ast::NodeId { self.node.id }\n-    fn ty(&self) -> ast::P<ast::Ty> { self.node.ty }\n-}\n-\n-fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n-    ccx: @CrateContext,\n-    ctor_id: ast::NodeId,\n-    args: &[A],\n-    disr: ty::Disr,\n-    param_substs: Option<@param_substs>,\n-    llfndecl: ValueRef) {\n-    // Translate variant arguments to function arguments.\n-    let fn_args = args.map(|varg| {\n-        ast::Arg {\n-            ty: varg.ty(),\n-            pat: ast_util::ident_to_pat(\n-                ccx.tcx.sess.next_node_id(),\n-                codemap::DUMMY_SP,\n-                special_idents::arg),\n-            id: varg.id(),\n-        }\n-    });\n-\n+fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n+                                           ctor_id: ast::NodeId,\n+                                           disr: ty::Disr,\n+                                           param_substs: Option<@param_substs>,\n+                                           llfndecl: ValueRef) {\n     let no_substs: &[ty::t] = [];\n     let ty_param_substs = match param_substs {\n         Some(ref substs) => {\n@@ -2280,38 +1664,32 @@ fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n                  ty_to_str(ccx.tcx, ctor_ty)))\n     };\n \n-    let fcx = new_fn_ctxt_w_id(ccx,\n-                               ~[],\n-                               llfndecl,\n-                               ctor_id,\n-                               result_ty,\n-                               param_substs,\n-                               None);\n-    init_function(&fcx, false, result_ty, param_substs, None);\n+    let fcx = new_fn_ctxt_detailed(ccx,\n+                                   ~[],\n+                                   llfndecl,\n+                                   ctor_id,\n+                                   result_ty,\n+                                   param_substs,\n+                                   None);\n+    init_function(&fcx, false, result_ty, param_substs);\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let raw_llargs = create_llargs_for_fn_args(&fcx, None, arg_tys);\n+    let (_, arg_datums) = create_datums_for_fn_args(&fcx, None, arg_tys);\n \n     let bcx = fcx.entry_bcx.get().unwrap();\n \n-    insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n-    let bcx = copy_args_to_allocas(&fcx, bcx, fn_args, None, raw_llargs);\n-\n     let repr = adt::represent_type(ccx, result_ty);\n     adt::trans_start_init(bcx, repr, fcx.llretptr.get().unwrap(), disr);\n-    for (i, fn_arg) in fn_args.iter().enumerate() {\n+    for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n                                              fcx.llretptr.get().unwrap(),\n                                              disr,\n                                              i);\n-        let llarg = {\n-            let llargs = fcx.llargs.borrow();\n-            llargs.get().get_copy(&fn_arg.pat.id)\n-        };\n-        llarg.move_to(bcx, datum::INIT, lldestptr);\n+        arg_datum.store_to(bcx, lldestptr);\n     }\n+\n     finish_fn(&fcx, bcx);\n }\n \n@@ -2380,7 +1758,6 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n                      None,\n                      None,\n                      item.id,\n-                     None,\n                      item.attrs);\n         } else {\n             // Be sure to travel more than just one layer deep to catch nested"}, {"sha": "44410ae24b9e4b3a0bba5d39be627ddc6fabefc6", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -24,6 +24,7 @@ use std::cast;\n use std::libc::{c_uint, c_ulonglong, c_char};\n \n pub fn terminate(cx: &Block, _: &str) {\n+    debug!(\"terminate({})\", cx.to_str());\n     cx.terminated.set(true);\n }\n \n@@ -315,12 +316,16 @@ pub fn ArrayMalloc(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n pub fn Alloca(cx: &Block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n-        let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n-        b.alloca(Ty, name)\n+        AllocaFcx(cx.fcx, Ty, name)\n     }\n }\n \n+pub fn AllocaFcx(fcx: &FunctionContext, Ty: Type, name: &str) -> ValueRef {\n+    let b = fcx.ccx.builder();\n+    b.position_before(fcx.alloca_insert_pt.get().unwrap());\n+    b.alloca(Ty, name)\n+}\n+\n pub fn ArrayAlloca(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }"}, {"sha": "310ae95ea2a08a9dbcb6b7fb1b33f6d5184d4c0e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 208, "deletions": 196, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -27,6 +27,8 @@ use middle::trans::base;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n+use middle::trans::cleanup;\n+use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n@@ -60,11 +62,10 @@ pub struct FnData {\n pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n-    temp_cleanup: Option<ValueRef>\n }\n \n pub enum CalleeData {\n-    Closure(Datum),\n+    Closure(Datum<Lvalue>),\n     Fn(FnData),\n     Method(MethodData)\n }\n@@ -74,7 +75,7 @@ pub struct Callee<'a> {\n     data: CalleeData\n }\n \n-pub fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n+fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n \n@@ -90,13 +91,15 @@ pub fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     return datum_callee(bcx, expr);\n \n     fn datum_callee<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n-        let DatumBlock {bcx, datum} = expr::trans_to_datum(bcx, expr);\n+        let DatumBlock {bcx: mut bcx, datum} = expr::trans(bcx, expr);\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(..) => {\n-                let llval = datum.to_appropriate_llval(bcx);\n+                let llval = datum.to_llscalarish(bcx);\n                 return Callee {bcx: bcx, data: Fn(FnData {llfn: llval})};\n             }\n             ty::ty_closure(..) => {\n+                let datum = unpack_datum!(\n+                    bcx, datum.to_lvalue_datum(bcx, \"callee\", expr.id));\n                 return Callee {bcx: bcx, data: Closure(datum)};\n             }\n             _ => {\n@@ -458,10 +461,10 @@ pub fn trans_call<'a>(\n                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n-                     call_ex.info(),\n+                     Some(common::expr_info(call_ex)),\n                      expr_ty(in_cx, f),\n                      node_id_type(in_cx, id),\n-                     |cx| trans(cx, f),\n+                     |cx, _| trans(cx, f),\n                      args,\n                      Some(dest),\n                      DontAutorefArg).bcx\n@@ -481,10 +484,10 @@ pub fn trans_method_call<'a>(\n            rcvr.repr(in_cx.tcx()));\n     trans_call_inner(\n         in_cx,\n-        call_ex.info(),\n+        Some(common::expr_info(call_ex)),\n         node_id_type(in_cx, callee_id),\n         expr_ty(in_cx, call_ex),\n-        |cx| {\n+        |cx, arg_cleanup_scope| {\n             let origin_opt = {\n                 let mut method_map = cx.ccx().maps.method_map.borrow_mut();\n                 method_map.get().find_copy(&call_ex.id)\n@@ -495,7 +498,11 @@ pub fn trans_method_call<'a>(\n                            call_ex.repr(in_cx.tcx()),\n                            origin.repr(in_cx.tcx()));\n \n-                    meth::trans_method_callee(cx, callee_id, rcvr, origin)\n+                    meth::trans_method_callee(cx,\n+                                              callee_id,\n+                                              rcvr,\n+                                              origin,\n+                                              arg_cleanup_scope)\n                 }\n                 None => {\n                     cx.tcx().sess.span_bug(call_ex.span, \"method call expr wasn't in method map\")\n@@ -523,7 +530,7 @@ pub fn trans_lang_call<'a>(\n                              None,\n                              fty,\n                              rty,\n-                             |bcx| {\n+                             |bcx, _| {\n                                 trans_fn_ref_with_vtables_to_callee(bcx,\n                                                                     did,\n                                                                     0,\n@@ -551,8 +558,11 @@ pub fn trans_lang_call_with_type_params<'a>(\n \n     let rty = ty::ty_fn_ret(fty);\n     return callee::trans_call_inner(\n-        bcx, None, fty, rty,\n-        |bcx| {\n+        bcx,\n+        None,\n+        fty,\n+        rty,\n+        |bcx, _| {\n             let callee =\n                 trans_fn_ref_with_vtables_to_callee(bcx, did, 0,\n                                                     type_params,\n@@ -577,11 +587,13 @@ pub fn trans_lang_call_with_type_params<'a>(\n }\n \n pub fn trans_call_inner<'a>(\n-                        in_cx: &'a Block<'a>,\n+                        bcx: &'a Block<'a>,\n                         call_info: Option<NodeInfo>,\n                         callee_ty: ty::t,\n                         ret_ty: ty::t,\n-                        get_callee: |&'a Block<'a>| -> Callee<'a>,\n+                        get_callee: |bcx: &'a Block<'a>,\n+                                     arg_cleanup_scope: cleanup::ScopeId|\n+                                     -> Callee<'a>,\n                         args: CallArgs,\n                         dest: Option<expr::Dest>,\n                         autoref_arg: AutorefArg)\n@@ -593,171 +605,182 @@ pub fn trans_call_inner<'a>(\n      * this into two functions seems like a good idea).\n      *\n      * In particular, for lang items, it is invoked with a dest of\n-     * None, and\n+     * None, and in that case the return value contains the result of\n+     * the fn. The lang item must not return a structural type or else\n+     * all heck breaks loose.\n+     *\n+     * For non-lang items, `dest` is always Some, and hence the result\n+     * is written into memory somewhere. Nonetheless we return the\n+     * actual return value of the function.\n      */\n \n+    // Introduce a temporary cleanup scope that will contain cleanups\n+    // for the arguments while they are being evaluated. The purpose\n+    // this cleanup is to ensure that, should a failure occur while\n+    // evaluating argument N, the values for arguments 0...N-1 are all\n+    // cleaned up. If no failure occurs, the values are handed off to\n+    // the callee, and hence none of the cleanups in this temporary\n+    // scope will ever execute.\n+    let fcx = bcx.fcx;\n+    let ccx = fcx.ccx;\n+    let tcx = ccx.tcx;\n+    let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n-    base::with_scope_result(in_cx, call_info, \"call\", |cx| {\n-        let callee = get_callee(cx);\n-        let mut bcx = callee.bcx;\n-        let ccx = cx.ccx();\n+    let callee = get_callee(bcx, cleanup::CustomScope(arg_cleanup_scope));\n+    let mut bcx = callee.bcx;\n \n-        let (llfn, llenv) = unsafe {\n-            match callee.data {\n-                Fn(d) => {\n-                    (d.llfn, llvm::LLVMGetUndef(Type::opaque_box(ccx).ptr_to().to_ref()))\n-                }\n-                Method(d) => {\n-                    // Weird but true: we pass self in the *environment* slot!\n-                    (d.llfn, d.llself)\n-                }\n-                Closure(d) => {\n-                    // Closures are represented as (llfn, llclosure) pair:\n-                    // load the requisite values out.\n-                    let pair = d.to_ref_llval(bcx);\n-                    let llfn = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n-                    let llfn = Load(bcx, llfn);\n-                    let llenv = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n-                    let llenv = Load(bcx, llenv);\n-                    (llfn, llenv)\n-                }\n+    let (llfn, llenv) = unsafe {\n+        match callee.data {\n+            Fn(d) => {\n+                (d.llfn, llvm::LLVMGetUndef(Type::opaque_box(ccx).ptr_to().to_ref()))\n             }\n-        };\n-\n-        let abi = match ty::get(callee_ty).sty {\n-            ty::ty_bare_fn(ref f) => f.abis,\n-            _ => AbiSet::Rust()\n-        };\n-        let is_rust_fn =\n-            abi.is_rust() ||\n-            abi.is_intrinsic();\n-\n-        // Generate a location to store the result. If the user does\n-        // not care about the result, just make a stack slot.\n-        let opt_llretslot = match dest {\n-            None => {\n-                assert!(!type_of::return_uses_outptr(in_cx.ccx(), ret_ty));\n-                None\n+            Method(d) => {\n+                // Weird but true: we pass self in the *environment* slot!\n+                (d.llfn, d.llself)\n             }\n-            Some(expr::SaveIn(dst)) => Some(dst),\n-            Some(expr::Ignore) => {\n-                if !ty::type_is_voidish(in_cx.tcx(), ret_ty) {\n-                    Some(alloc_ty(bcx, ret_ty, \"__llret\"))\n-                } else {\n-                    unsafe {\n-                        Some(llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()))\n-                    }\n+            Closure(d) => {\n+                // Closures are represented as (llfn, llclosure) pair:\n+                // load the requisite values out.\n+                let pair = d.to_llref();\n+                let llfn = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n+                let llfn = Load(bcx, llfn);\n+                let llenv = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n+                let llenv = Load(bcx, llenv);\n+                (llfn, llenv)\n+            }\n+        }\n+    };\n+\n+    let abi = match ty::get(callee_ty).sty {\n+        ty::ty_bare_fn(ref f) => f.abis,\n+        _ => AbiSet::Rust()\n+    };\n+    let is_rust_fn =\n+        abi.is_rust() ||\n+        abi.is_intrinsic();\n+\n+    // Generate a location to store the result. If the user does\n+    // not care about the result, just make a stack slot.\n+    let opt_llretslot = match dest {\n+        None => {\n+            assert!(!type_of::return_uses_outptr(ccx, ret_ty));\n+            None\n+        }\n+        Some(expr::SaveIn(dst)) => Some(dst),\n+        Some(expr::Ignore) => {\n+            if !ty::type_is_voidish(tcx, ret_ty) {\n+                Some(alloc_ty(bcx, ret_ty, \"__llret\"))\n+            } else {\n+                unsafe {\n+                    Some(llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()))\n                 }\n             }\n-        };\n+        }\n+    };\n \n-        let mut llresult = unsafe {\n-            llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n-        };\n+    let mut llresult = unsafe {\n+        llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n+    };\n \n-        // The code below invokes the function, using either the Rust\n-        // conventions (if it is a rust fn) or the native conventions\n-        // (otherwise).  The important part is that, when all is sad\n-        // and done, either the return value of the function will have been\n-        // written in opt_llretslot (if it is Some) or `llresult` will be\n-        // set appropriately (otherwise).\n-        if is_rust_fn {\n-            let mut llargs = ~[];\n-\n-            // Push the out-pointer if we use an out-pointer for this\n-            // return type, otherwise push \"undef\".\n-            if type_of::return_uses_outptr(in_cx.ccx(), ret_ty) {\n-                llargs.push(opt_llretslot.unwrap());\n-            }\n+    // The code below invokes the function, using either the Rust\n+    // conventions (if it is a rust fn) or the native conventions\n+    // (otherwise).  The important part is that, when all is sad\n+    // and done, either the return value of the function will have been\n+    // written in opt_llretslot (if it is Some) or `llresult` will be\n+    // set appropriately (otherwise).\n+    if is_rust_fn {\n+        let mut llargs = ~[];\n+\n+        // Push the out-pointer if we use an out-pointer for this\n+        // return type, otherwise push \"undef\".\n+        if type_of::return_uses_outptr(ccx, ret_ty) {\n+            llargs.push(opt_llretslot.unwrap());\n+        }\n \n-            // Push the environment.\n-            llargs.push(llenv);\n+        // Push the environment.\n+        llargs.push(llenv);\n \n-            // Push the arguments.\n-            bcx = trans_args(bcx, args, callee_ty,\n-                             autoref_arg, &mut llargs);\n+        // Push the arguments.\n+        bcx = trans_args(bcx, args, callee_ty,\n+                         autoref_arg, &mut llargs,\n+                         cleanup::CustomScope(arg_cleanup_scope));\n \n-            // Now that the arguments have finished evaluating, we\n-            // need to revoke the cleanup for the self argument\n-            match callee.data {\n-                Method(d) => {\n-                    for &v in d.temp_cleanup.iter() {\n-                        revoke_clean(bcx, v);\n-                    }\n-                }\n-                _ => {}\n-            }\n+        fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n \n-            // A function pointer is called without the declaration available, so we have to apply\n-            // any attributes with ABI implications directly to the call instruction. Right now, the\n-            // only attribute we need to worry about is `sret`.\n-            let mut attrs = ~[];\n-            if type_of::return_uses_outptr(in_cx.ccx(), ret_ty) {\n-                attrs.push((1, StructRetAttribute));\n-            }\n+        // A function pointer is called without the declaration\n+        // available, so we have to apply any attributes with ABI\n+        // implications directly to the call instruction. Right now,\n+        // the only attribute we need to worry about is `sret`.\n+        let mut attrs = ~[];\n+        if type_of::return_uses_outptr(ccx, ret_ty) {\n+            attrs.push((1, StructRetAttribute));\n+        }\n \n-            // The `noalias` attribute on the return value is useful to a function ptr caller.\n-            match ty::get(ret_ty).sty {\n-                // `~` pointer return values never alias because ownership is transferred\n-                ty::ty_uniq(..) |\n+        // The `noalias` attribute on the return value is useful to a\n+        // function ptr caller.\n+        match ty::get(ret_ty).sty {\n+            // `~` pointer return values never alias because ownership\n+            // is transferred\n+            ty::ty_uniq(..) |\n                 ty::ty_vec(_, ty::vstore_uniq) => {\n-                    attrs.push((0, NoAliasAttribute));\n-                }\n-                _ => ()\n+                attrs.push((0, NoAliasAttribute));\n             }\n+            _ => ()\n+        }\n \n-            // Invoke the actual rust fn and update bcx/llresult.\n-            let (llret, b) = base::invoke(bcx, llfn, llargs, attrs, call_info);\n-            bcx = b;\n-            llresult = llret;\n-\n-            // If the Rust convention for this type is return via\n-            // the return value, copy it into llretslot.\n-            match opt_llretslot {\n-                Some(llretslot) => {\n-                    if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n-                        !ty::type_is_voidish(bcx.tcx(), ret_ty)\n-                    {\n-                        Store(bcx, llret, llretslot);\n-                    }\n+        // Invoke the actual rust fn and update bcx/llresult.\n+        let (llret, b) = base::invoke(bcx, llfn, llargs, attrs, call_info);\n+        bcx = b;\n+        llresult = llret;\n+\n+        // If the Rust convention for this type is return via\n+        // the return value, copy it into llretslot.\n+        match opt_llretslot {\n+            Some(llretslot) => {\n+                if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n+                    !ty::type_is_voidish(bcx.tcx(), ret_ty)\n+                {\n+                    Store(bcx, llret, llretslot);\n                 }\n-                None => {}\n             }\n-        } else {\n-            // Lang items are the only case where dest is None, and\n-            // they are always Rust fns.\n-            assert!(dest.is_some());\n-\n-            let mut llargs = ~[];\n-            bcx = trans_args(bcx, args, callee_ty,\n-                             autoref_arg, &mut llargs);\n-            let arg_tys = match args {\n-                ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, *x)).collect(),\n-                ArgVals(_) => fail!(\"expected arg exprs.\")\n-            };\n-            bcx = foreign::trans_native_call(bcx, callee_ty,\n-                                             llfn, opt_llretslot.unwrap(), llargs, arg_tys);\n+            None => {}\n         }\n+    } else {\n+        // Lang items are the only case where dest is None, and\n+        // they are always Rust fns.\n+        assert!(dest.is_some());\n+\n+        let mut llargs = ~[];\n+        bcx = trans_args(bcx, args, callee_ty,\n+                         autoref_arg, &mut llargs,\n+                         cleanup::CustomScope(arg_cleanup_scope));\n+        fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n+        let arg_tys = match args {\n+            ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, *x)).collect(),\n+            ArgVals(_) => fail!(\"expected arg exprs.\")\n+        };\n+        bcx = foreign::trans_native_call(bcx, callee_ty,\n+                                         llfn, opt_llretslot.unwrap(), llargs, arg_tys);\n+    }\n \n-        // If the caller doesn't care about the result of this fn call,\n-        // drop the temporary slot we made.\n-        match dest {\n-            None => {\n-                assert!(!type_of::return_uses_outptr(bcx.ccx(), ret_ty));\n-            }\n-            Some(expr::Ignore) => {\n-                // drop the value if it is not being saved.\n-                bcx = glue::drop_ty(bcx, opt_llretslot.unwrap(), ret_ty);\n-            }\n-            Some(expr::SaveIn(_)) => { }\n+    // If the caller doesn't care about the result of this fn call,\n+    // drop the temporary slot we made.\n+    match dest {\n+        None => {\n+            assert!(!type_of::return_uses_outptr(bcx.ccx(), ret_ty));\n         }\n-\n-        if ty::type_is_bot(ret_ty) {\n-            Unreachable(bcx);\n+        Some(expr::Ignore) => {\n+            // drop the value if it is not being saved.\n+            bcx = glue::drop_ty(bcx, opt_llretslot.unwrap(), ret_ty);\n         }\n+        Some(expr::SaveIn(_)) => { }\n+    }\n \n-        rslt(bcx, llresult)\n-    })\n+    if ty::type_is_bot(ret_ty) {\n+        Unreachable(bcx);\n+    }\n+\n+    rslt(bcx, llresult)\n }\n \n pub enum CallArgs<'a> {\n@@ -770,10 +793,11 @@ pub fn trans_args<'a>(\n                   args: CallArgs,\n                   fn_ty: ty::t,\n                   autoref_arg: AutorefArg,\n-                  llargs: &mut ~[ValueRef])\n-                  -> &'a Block<'a> {\n+                  llargs: &mut ~[ValueRef],\n+                  arg_cleanup_scope: cleanup::ScopeId)\n+                  -> &'a Block<'a>\n+{\n     let _icx = push_ctxt(\"trans_args\");\n-    let mut temp_cleanups = ~[];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     let variadic = ty::fn_is_variadic(fn_ty);\n \n@@ -796,7 +820,7 @@ pub fn trans_args<'a>(\n                 trans_arg_expr(bcx,\n                                arg_ty,\n                                *arg_expr,\n-                               &mut temp_cleanups,\n+                               arg_cleanup_scope,\n                                autoref_arg)\n             });\n             llargs.push(arg_val);\n@@ -807,13 +831,6 @@ pub fn trans_args<'a>(\n       }\n     }\n \n-    // now that all arguments have been successfully built, we can revoke any\n-    // temporary cleanups, as they are only needed if argument construction\n-    // should fail (for example, cleanup of copy mode args).\n-    for c in temp_cleanups.iter() {\n-        revoke_clean(bcx, *c)\n-    }\n-\n     bcx\n }\n \n@@ -822,31 +839,29 @@ pub enum AutorefArg {\n     DoAutorefArg\n }\n \n-// temp_cleanups: cleanups that should run only if failure occurs before the\n-// call takes place:\n pub fn trans_arg_expr<'a>(\n                       bcx: &'a Block<'a>,\n                       formal_arg_ty: ty::t,\n                       arg_expr: &ast::Expr,\n-                      temp_cleanups: &mut ~[ValueRef],\n+                      arg_cleanup_scope: cleanup::ScopeId,\n                       autoref_arg: AutorefArg)\n                       -> Result<'a> {\n     let _icx = push_ctxt(\"trans_arg_expr\");\n+    let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n     debug!(\"trans_arg_expr(formal_arg_ty=({}), arg_expr={})\",\n            formal_arg_ty.repr(bcx.tcx()),\n            arg_expr.repr(bcx.tcx()));\n \n     // translate the arg expr to a datum\n-    let arg_datumblock = expr::trans_to_datum(bcx, arg_expr);\n-    let arg_datum = arg_datumblock.datum;\n-    let bcx = arg_datumblock.bcx;\n+    let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_expr));\n+    let arg_datum_ty = arg_datum.ty;\n \n     debug!(\"   arg datum: {}\", arg_datum.to_str(bcx.ccx()));\n \n     let mut val;\n-    if ty::type_is_bot(arg_datum.ty) {\n+    if ty::type_is_bot(arg_datum_ty) {\n         // For values of type _|_, we generate an\n         // \"undef\" value, as such a value should never\n         // be inspected. It's important for the value\n@@ -859,34 +874,31 @@ pub fn trans_arg_expr<'a>(\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n             DoAutorefArg => {\n-                val = arg_datum.to_ref_llval(bcx);\n+                // We will pass argument by reference\n+                // We want an lvalue, so that we can pass by reference and\n+                let arg_datum = unpack_datum!(\n+                    bcx, arg_datum.to_lvalue_datum(bcx, \"arg\", arg_expr.id));\n+                val = arg_datum.val;\n             }\n             DontAutorefArg => {\n-                let need_scratch = ty::type_needs_drop(bcx.tcx(), arg_datum.ty) ||\n-                    (bcx.expr_is_lval(arg_expr) &&\n-                     arg_datum.appropriate_mode(bcx.ccx()).is_by_ref());\n-\n-                let arg_datum = if need_scratch {\n-                    let scratch = scratch_datum(bcx, arg_datum.ty, \"__self\", false);\n-                    arg_datum.store_to_datum(bcx, INIT, scratch);\n-\n-                    // Technically, ownership of val passes to the callee.\n-                    // However, we must cleanup should we fail before the\n-                    // callee is actually invoked.\n-                    scratch.add_clean(bcx);\n-                    temp_cleanups.push(scratch.val);\n-\n-                    scratch\n-                } else {\n-                    arg_datum\n-                };\n-\n-                debug!(\"by copy arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n-                val = arg_datum.to_appropriate_llval(bcx);\n+                // Make this an rvalue, since we are going to be\n+                // passing ownership.\n+                let arg_datum = unpack_datum!(\n+                    bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n+\n+                // Now that arg_datum is owned, get it into the appropriate\n+                // mode (ref vs value).\n+                let arg_datum = unpack_datum!(\n+                    bcx, arg_datum.to_appropriate_datum(bcx));\n+\n+                // Technically, ownership of val passes to the callee.\n+                // However, we must cleanup should we fail before the\n+                // callee is actually invoked.\n+                val = arg_datum.add_clean(bcx.fcx, arg_cleanup_scope);\n             }\n         }\n \n-        if formal_arg_ty != arg_datum.ty {\n+        if formal_arg_ty != arg_datum_ty {\n             // this could happen due to e.g. subtyping\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n             debug!(\"casting actual type ({}) to match formal ({})\","}, {"sha": "2ecc84ebc0c020049447cf1d2fddee92874eaec7", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "added", "additions": 948, "deletions": 0, "changes": 948, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -0,0 +1,948 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Code pertaining to cleanup of temporaries as well as execution of\n+ * drop glue. See discussion in `doc.rs` for a high-level summary.\n+ */\n+\n+use lib::llvm::{BasicBlockRef, ValueRef};\n+use middle::lang_items::{EhPersonalityLangItem};\n+use middle::trans::base;\n+use middle::trans::build;\n+use middle::trans::callee;\n+use middle::trans::common;\n+use middle::trans::common::{Block, FunctionContext};\n+use middle::trans::glue;\n+use middle::trans::type_::Type;\n+use middle::ty;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::parse::token;\n+use syntax::opt_vec;\n+use syntax::opt_vec::OptVec;\n+use util::ppaux::Repr;\n+\n+pub struct CleanupScope<'a> {\n+    // The id of this cleanup scope. If the id is None,\n+    // this is a *temporary scope* that is pushed during trans to\n+    // cleanup miscellaneous garbage that trans may generate whose\n+    // lifetime is a subset of some expression.  See module doc for\n+    // more details.\n+    kind: CleanupScopeKind<'a>,\n+\n+    // Cleanups to run upon scope exit.\n+    cleanups: OptVec<~Cleanup>,\n+\n+    cached_early_exits: OptVec<CachedEarlyExit>,\n+    cached_landing_pad: Option<BasicBlockRef>,\n+}\n+\n+pub struct CustomScopeIndex {\n+    priv index: uint\n+}\n+\n+pub static EXIT_BREAK: uint = 0;\n+pub static EXIT_LOOP: uint = 1;\n+pub static EXIT_MAX: uint = 2;\n+\n+enum CleanupScopeKind<'a> {\n+    CustomScopeKind,\n+    AstScopeKind(ast::NodeId),\n+    LoopScopeKind(ast::NodeId, [&'a Block<'a>, ..EXIT_MAX])\n+}\n+\n+#[deriving(Eq)]\n+enum EarlyExitLabel {\n+    UnwindExit,\n+    ReturnExit,\n+    LoopExit(ast::NodeId, uint)\n+}\n+\n+struct CachedEarlyExit {\n+    label: EarlyExitLabel,\n+    cleanup_block: BasicBlockRef,\n+}\n+\n+pub trait Cleanup {\n+    fn clean_on_unwind(&self) -> bool;\n+    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a>;\n+}\n+\n+pub enum ScopeId {\n+    AstScope(ast::NodeId),\n+    CustomScope(CustomScopeIndex)\n+}\n+\n+impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n+    fn push_ast_cleanup_scope(&self, id: ast::NodeId) {\n+        /*!\n+         * Invoked when we start to trans the code contained\n+         * within a new cleanup scope.\n+         */\n+\n+        debug!(\"push_ast_cleanup_scope({})\",\n+               ast_map::node_id_to_str(self.ccx.tcx.items, id,\n+                                       token::get_ident_interner()));\n+\n+        // FIXME(#2202) -- currently closure bodies have a parent\n+        // region, which messes up the assertion below, since there\n+        // are no cleanup scopes on the stack at the start of\n+        // trans'ing a closure body.  I think though that this should\n+        // eventually be fixed by closure bodies not having a parent\n+        // region, though that's a touch unclear, and it might also be\n+        // better just to narrow this assertion more (i.e., by\n+        // excluding id's that correspond to closure bodies only). For\n+        // now we just say that if there is already an AST scope on the stack,\n+        // this new AST scope had better be its immediate child.\n+        let top_scope = self.top_ast_scope();\n+        if top_scope.is_some() {\n+            assert_eq!(self.ccx.tcx.region_maps.opt_encl_scope(id), top_scope);\n+        }\n+\n+        self.push_scope(CleanupScope::new(AstScopeKind(id)));\n+    }\n+\n+    fn push_loop_cleanup_scope(&self,\n+                               id: ast::NodeId,\n+                               exits: [&'a Block<'a>, ..EXIT_MAX]) {\n+        debug!(\"push_loop_cleanup_scope({})\",\n+               ast_map::node_id_to_str(self.ccx.tcx.items, id,\n+                                       token::get_ident_interner()));\n+        assert_eq!(Some(id), self.top_ast_scope());\n+\n+        self.push_scope(CleanupScope::new(LoopScopeKind(id, exits)));\n+    }\n+\n+    fn push_custom_cleanup_scope(&self) -> CustomScopeIndex {\n+        let index = self.scopes_len();\n+        debug!(\"push_custom_cleanup_scope(): {}\", index);\n+        self.push_scope(CleanupScope::new(CustomScopeKind));\n+        CustomScopeIndex { index: index }\n+    }\n+\n+    fn pop_and_trans_ast_cleanup_scope(&self,\n+                                       bcx: &'a Block<'a>,\n+                                       cleanup_scope: ast::NodeId)\n+                                       -> &'a Block<'a> {\n+        /*!\n+         * Removes the cleanup scope for id `cleanup_scope`, which\n+         * must be at the top of the cleanup stack, and generates the\n+         * code to do its cleanups for normal exit.\n+         */\n+\n+        debug!(\"pop_and_trans_ast_cleanup_scope({})\",\n+               ast_map::node_id_to_str(self.ccx.tcx.items, cleanup_scope,\n+                                       token::get_ident_interner()));\n+\n+        assert!(self.top_scope(|s| s.kind.is_ast_with_id(cleanup_scope)));\n+\n+        let scope = self.pop_scope();\n+        self.trans_scope_cleanups(bcx, &scope)\n+\n+    }\n+\n+    fn pop_loop_cleanup_scope(&self,\n+                              cleanup_scope: ast::NodeId) {\n+        /*!\n+         * Removes the loop cleanup scope for id `cleanup_scope`, which\n+         * must be at the top of the cleanup stack. Does not generate\n+         * any cleanup code, since loop scopes should exit by\n+         * branching to a block generated by `normal_exit_block`.\n+         */\n+\n+        debug!(\"pop_loop_cleanup_scope({})\",\n+               ast_map::node_id_to_str(self.ccx.tcx.items, cleanup_scope,\n+                                       token::get_ident_interner()));\n+\n+        assert!(self.top_scope(|s| s.kind.is_loop_with_id(cleanup_scope)));\n+\n+        let _ = self.pop_scope();\n+    }\n+\n+    fn pop_custom_cleanup_scope(&self,\n+                                custom_scope: CustomScopeIndex) {\n+        /*!\n+         * Removes the top cleanup scope from the stack without\n+         * executing its cleanups. The top cleanup scope must\n+         * be the temporary scope `custom_scope`.\n+         */\n+\n+        debug!(\"pop_custom_cleanup_scope({})\", custom_scope.index);\n+        assert!(self.is_valid_to_pop_custom_scope(custom_scope));\n+        let _ = self.pop_scope();\n+    }\n+\n+    fn pop_and_trans_custom_cleanup_scope(&self,\n+                                        bcx: &'a Block<'a>,\n+                                        custom_scope: CustomScopeIndex)\n+                                        -> &'a Block<'a> {\n+        /*!\n+         * Removes the top cleanup scope from the stack, which must be\n+         * a temporary scope, and generates the code to do its\n+         * cleanups for normal exit.\n+         */\n+\n+        debug!(\"pop_and_trans_custom_cleanup_scope({:?})\", custom_scope);\n+        assert!(self.is_valid_to_pop_custom_scope(custom_scope));\n+\n+        let scope = self.pop_scope();\n+        self.trans_scope_cleanups(bcx, &scope)\n+    }\n+\n+    fn top_loop_scope(&self) -> ast::NodeId {\n+        /*!\n+         * Returns the id of the top-most loop scope\n+         */\n+\n+        let scopes = self.scopes.borrow();\n+        for scope in scopes.get().iter().invert() {\n+            match scope.kind {\n+                LoopScopeKind(id, _) => {\n+                    return id;\n+                }\n+                _ => {}\n+            }\n+        }\n+        self.ccx.tcx.sess.bug(\"No loop scope found\");\n+    }\n+\n+    fn normal_exit_block(&self,\n+                         cleanup_scope: ast::NodeId,\n+                         exit: uint) -> BasicBlockRef {\n+        /*!\n+         * Returns a block to branch to which will perform all pending\n+         * cleanups and then break/continue (depending on `exit`) out\n+         * of the loop with id `cleanup_scope`\n+         */\n+\n+        self.trans_cleanups_to_exit_scope(LoopExit(cleanup_scope, exit))\n+    }\n+\n+    fn return_exit_block(&self) -> BasicBlockRef {\n+        /*!\n+         * Returns a block to branch to which will perform all pending\n+         * cleanups and then return from this function\n+         */\n+\n+        self.trans_cleanups_to_exit_scope(ReturnExit)\n+    }\n+\n+    fn schedule_drop_mem(&self,\n+                         cleanup_scope: ScopeId,\n+                         val: ValueRef,\n+                         ty: ty::t) {\n+        /*!\n+         * Schedules a (deep) drop of `val`, which is a pointer to an\n+         * instance of `ty`\n+         */\n+\n+        if !ty::type_needs_drop(self.ccx.tcx, ty) { return; }\n+        let drop = ~DropValue {\n+            is_immediate: false,\n+            on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx, ty),\n+            val: val,\n+            ty: ty\n+        };\n+\n+        debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n+               cleanup_scope,\n+               self.ccx.tn.val_to_str(val),\n+               ty.repr(self.ccx.tcx));\n+\n+        self.schedule_clean(cleanup_scope, drop as ~Cleanup);\n+    }\n+\n+    fn schedule_drop_immediate(&self,\n+                               cleanup_scope: ScopeId,\n+                               val: ValueRef,\n+                               ty: ty::t) {\n+        /*!\n+         * Schedules a (deep) drop of `val`, which is an instance of `ty`\n+         */\n+\n+        if !ty::type_needs_drop(self.ccx.tcx, ty) { return; }\n+        let drop = ~DropValue {\n+            is_immediate: true,\n+            on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx, ty),\n+            val: val,\n+            ty: ty\n+        };\n+\n+        debug!(\"schedule_drop_immediate({:?}, val={}, ty={})\",\n+               cleanup_scope,\n+               self.ccx.tn.val_to_str(val),\n+               ty.repr(self.ccx.tcx));\n+\n+        self.schedule_clean(cleanup_scope, drop as ~Cleanup);\n+    }\n+\n+    fn schedule_free_value(&self,\n+                           cleanup_scope: ScopeId,\n+                           val: ValueRef,\n+                           heap: common::heap) {\n+        /*!\n+         * Schedules a call to `free(val)`. Note that this is a shallow\n+         * operation.\n+         */\n+\n+        let drop = ~FreeValue { ptr: val, heap: heap };\n+\n+        debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n+               cleanup_scope,\n+               self.ccx.tn.val_to_str(val),\n+               heap);\n+\n+        self.schedule_clean(cleanup_scope, drop as ~Cleanup);\n+    }\n+\n+    fn schedule_clean(&self,\n+                      cleanup_scope: ScopeId,\n+                      cleanup: ~Cleanup) {\n+        match cleanup_scope {\n+            AstScope(id) => self.schedule_clean_in_ast_scope(id, cleanup),\n+            CustomScope(id) => self.schedule_clean_in_custom_scope(id, cleanup),\n+        }\n+    }\n+\n+    fn schedule_clean_in_ast_scope(&self,\n+                                   cleanup_scope: ast::NodeId,\n+                                   cleanup: ~Cleanup) {\n+        /*!\n+         * Schedules a cleanup to occur upon exit from `cleanup_scope`.\n+         * If `cleanup_scope` is not provided, then the cleanup is scheduled\n+         * in the topmost scope, which must be a temporary scope.\n+         */\n+\n+        debug!(\"schedule_clean_in_ast_scope(cleanup_scope={:?})\",\n+               cleanup_scope);\n+\n+        let mut scopes = self.scopes.borrow_mut();\n+        for scope in scopes.get().mut_iter().invert() {\n+            if scope.kind.is_ast_with_id(cleanup_scope) {\n+                scope.cleanups.push(cleanup);\n+                scope.clear_cached_exits();\n+                return;\n+            } else {\n+                // will be adding a cleanup to some enclosing scope\n+                scope.clear_cached_exits();\n+            }\n+        }\n+\n+        self.ccx.tcx.sess.bug(\n+            format!(\"No cleanup scope {} found\",\n+                    ast_map::node_id_to_str(self.ccx.tcx.items, cleanup_scope,\n+                                            token::get_ident_interner())));\n+    }\n+\n+    fn schedule_clean_in_custom_scope(&self,\n+                                      custom_scope: CustomScopeIndex,\n+                                      cleanup: ~Cleanup) {\n+        /*!\n+         * Schedules a cleanup to occur in the top-most scope,\n+         * which must be a temporary scope.\n+         */\n+\n+        debug!(\"schedule_clean_in_custom_scope(custom_scope={})\",\n+               custom_scope.index);\n+\n+        assert!(self.is_valid_custom_scope(custom_scope));\n+\n+        let mut scopes = self.scopes.borrow_mut();\n+        let scope = &mut scopes.get()[custom_scope.index];\n+        scope.cleanups.push(cleanup);\n+        scope.clear_cached_exits();\n+    }\n+\n+    fn needs_invoke(&self) -> bool {\n+        /*!\n+         * Returns true if there are pending cleanups that should\n+         * execute on failure.\n+         */\n+\n+        let scopes = self.scopes.borrow();\n+        scopes.get().iter().invert().any(|s| s.needs_invoke())\n+    }\n+\n+    fn get_landing_pad(&self) -> BasicBlockRef {\n+        /*!\n+         * Returns a basic block to branch to in the event of a failure.\n+         * This block will run the failure cleanups and eventually\n+         * invoke the LLVM `Resume` instruction.\n+         */\n+\n+        let _icx = base::push_ctxt(\"get_landing_pad\");\n+\n+        debug!(\"get_landing_pad\");\n+\n+        let orig_scopes_len = self.scopes_len();\n+        assert!(orig_scopes_len > 0);\n+\n+        // Remove any scopes that do not have cleanups on failure:\n+        let mut popped_scopes = opt_vec::Empty;\n+        while !self.top_scope(|s| s.needs_invoke()) {\n+            debug!(\"top scope does not need invoke\");\n+            popped_scopes.push(self.pop_scope());\n+        }\n+\n+        // Check for an existing landing pad in the new topmost scope:\n+        let llbb = self.get_or_create_landing_pad();\n+\n+        // Push the scopes we removed back on:\n+        while !popped_scopes.is_empty() {\n+            self.push_scope(popped_scopes.pop());\n+        }\n+\n+        assert_eq!(self.scopes_len(), orig_scopes_len);\n+\n+        return llbb;\n+    }\n+}\n+\n+impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n+    fn top_ast_scope(&self) -> Option<ast::NodeId> {\n+        /*!\n+         * Returns the id of the current top-most AST scope, if any.\n+         */\n+        let scopes = self.scopes.borrow();\n+        for scope in scopes.get().iter().invert() {\n+            match scope.kind {\n+                CustomScopeKind | LoopScopeKind(..) => {}\n+                AstScopeKind(i) => {\n+                    return Some(i);\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    fn top_nonempty_cleanup_scope(&self) -> Option<uint> {\n+        let scopes = self.scopes.borrow();\n+        scopes.get().iter().invert().position(|s| !s.cleanups.is_empty())\n+    }\n+\n+    fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n+        let scopes = self.scopes.borrow();\n+        self.is_valid_custom_scope(custom_scope) &&\n+            custom_scope.index == scopes.get().len() - 1\n+    }\n+\n+    fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n+        let scopes = self.scopes.borrow();\n+        custom_scope.index < scopes.get().len() &&\n+            scopes.get()[custom_scope.index].kind.is_temp()\n+    }\n+\n+    fn trans_scope_cleanups(&self, // cannot borrow self, will recurse\n+                            bcx: &'a Block<'a>,\n+                            scope: &CleanupScope) -> &'a Block<'a> {\n+        /*! Generates the cleanups for `scope` into `bcx` */\n+\n+        let mut bcx = bcx;\n+        if !bcx.unreachable.get() {\n+            for cleanup in scope.cleanups.iter().invert() {\n+                bcx = cleanup.trans(bcx);\n+            }\n+        }\n+        bcx\n+    }\n+\n+    fn scopes_len(&self) -> uint {\n+        let scopes = self.scopes.borrow();\n+        scopes.get().len()\n+    }\n+\n+    fn push_scope(&self, scope: CleanupScope<'a>) {\n+        let mut scopes = self.scopes.borrow_mut();\n+        scopes.get().push(scope);\n+    }\n+\n+    fn pop_scope(&self) -> CleanupScope<'a> {\n+        debug!(\"popping cleanup scope {}, {} scopes remaining\",\n+               self.top_scope(|s| s.block_name(\"\")),\n+               self.scopes_len() - 1);\n+\n+        let mut scopes = self.scopes.borrow_mut();\n+        scopes.get().pop()\n+    }\n+\n+    fn top_scope<R>(&self, f: |&CleanupScope<'a>| -> R) -> R {\n+        let scopes = self.scopes.borrow();\n+        f(scopes.get().last())\n+    }\n+\n+    fn trans_cleanups_to_exit_scope(&self,\n+                                    label: EarlyExitLabel)\n+                                    -> BasicBlockRef {\n+        /*!\n+         * Used when the caller wishes to jump to an early exit, such\n+         * as a return, break, continue, or unwind. This function will\n+         * generate all cleanups between the top of the stack and the\n+         * exit `label` and return a basic block that the caller can\n+         * branch to.\n+         *\n+         * For example, if the current stack of cleanups were as follows:\n+         *\n+         *      AST 22\n+         *      Custom 1\n+         *      AST 23\n+         *      Loop 23\n+         *      Custom 2\n+         *      AST 24\n+         *\n+         * and the `label` specifies a break from `Loop 23`, then this\n+         * function would generate a series of basic blocks as follows:\n+         *\n+         *      Cleanup(AST 24) -> Cleanup(Custom 2) -> break_blk\n+         *\n+         * where `break_blk` is the block specified in `Loop 23` as\n+         * the target for breaks. The return value would be the first\n+         * basic block in that sequence (`Cleanup(AST 24)`). The\n+         * caller could then branch to `Cleanup(AST 24)` and it will\n+         * perform all cleanups and finally branch to the `break_blk`.\n+         */\n+\n+        debug!(\"trans_cleanups_to_exit_scope label={:?} scopes={}\",\n+               label, self.scopes_len());\n+\n+        let orig_scopes_len = self.scopes_len();\n+        let mut prev_llbb;\n+        let mut popped_scopes = opt_vec::Empty;\n+\n+        // First we pop off all the cleanup stacks that are\n+        // traversed until the exit is reached, pushing them\n+        // onto the side vector `popped_scopes`. No code is\n+        // generated at this time.\n+        //\n+        // So, continuing the example from above, we would wind up\n+        // with a `popped_scopes` vector of `[AST 24, Custom 2]`.\n+        // (Presuming that there are no cached exits)\n+        loop {\n+            if self.scopes_len() == 0 {\n+                match label {\n+                    UnwindExit => {\n+                        // Generate a block that will `Resume`.\n+                        let prev_bcx = self.new_block(true, \"resume\", None);\n+                        let personality = self.personality.get().expect(\n+                            \"create_landing_pad() should have set this\");\n+                        build::Resume(prev_bcx,\n+                                      build::Load(prev_bcx, personality));\n+                        prev_llbb = prev_bcx.llbb;\n+                        break;\n+                    }\n+\n+                    ReturnExit => {\n+                        prev_llbb = self.get_llreturn();\n+                        break;\n+                    }\n+\n+                    LoopExit(id, _) => {\n+                        self.ccx.tcx.sess.bug(format!(\n+                                \"Cannot exit from scope {:?}, \\\n+                                not in scope\", id));\n+                    }\n+                }\n+            }\n+\n+            // Check if we have already cached the unwinding of this\n+            // scope for this label. If so, we can stop popping scopes\n+            // and branch to the cached label, since it contains the\n+            // cleanups for any subsequent scopes.\n+            match self.top_scope(|s| s.cached_early_exit(label)) {\n+                Some(cleanup_block) => {\n+                    prev_llbb = cleanup_block;\n+                    break;\n+                }\n+                None => { }\n+            }\n+\n+            // Pop off the scope, since we will be generating\n+            // unwinding code for it. If we are searching for a loop exit,\n+            // and this scope is that loop, then stop popping and set\n+            // `prev_llbb` to the appropriate exit block from the loop.\n+            popped_scopes.push(self.pop_scope());\n+            let scope = popped_scopes.last();\n+            match label {\n+                UnwindExit | ReturnExit => { }\n+                LoopExit(id, exit) => {\n+                    match scope.kind.early_exit_block(id, exit) {\n+                        Some(exitllbb) => {\n+                            prev_llbb = exitllbb;\n+                            break;\n+                        }\n+\n+                        None => { }\n+                    }\n+                }\n+            }\n+        }\n+\n+        debug!(\"trans_cleanups_to_exit_scope: popped {} scopes\",\n+               popped_scopes.len());\n+\n+        // Now push the popped scopes back on. As we go,\n+        // we track in `prev_llbb` the exit to which this scope\n+        // should branch when it's done.\n+        //\n+        // So, continuing with our example, we will start out with\n+        // `prev_llbb` being set to `break_blk` (or possibly a cached\n+        // early exit). We will then pop the scopes from `popped_scopes`\n+        // and generate a basic block for each one, prepending it in the\n+        // series and updating `prev_llbb`. So we begin by popping `Custom 2`\n+        // and generating `Cleanup(Custom 2)`. We make `Cleanup(Custom 2)`\n+        // branch to `prev_llbb == break_blk`, giving us a sequence like:\n+        //\n+        //     Cleanup(Custom 2) -> prev_llbb\n+        //\n+        // We then pop `AST 24` and repeat the process, giving us the sequence:\n+        //\n+        //     Cleanup(AST 24) -> Cleanup(Custom 2) -> prev_llbb\n+        //\n+        // At this point, `popped_scopes` is empty, and so the final block\n+        // that we return to the user is `Cleanup(AST 24)`.\n+        while !popped_scopes.is_empty() {\n+            let mut scope = popped_scopes.pop();\n+\n+            if scope.cleanups.iter().any(|c| cleanup_is_suitable_for(*c, label))\n+            {\n+                let name = scope.block_name(\"clean\");\n+                debug!(\"generating cleanups for {}\", name);\n+                let bcx_in = self.new_block(label.is_unwind(), name, None);\n+                let mut bcx_out = bcx_in;\n+                for cleanup in scope.cleanups.iter().invert() {\n+                    if cleanup_is_suitable_for(*cleanup, label) {\n+                        bcx_out = cleanup.trans(bcx_out);\n+                    }\n+                }\n+                build::Br(bcx_out, prev_llbb);\n+                prev_llbb = bcx_in.llbb;\n+            } else {\n+                debug!(\"no suitable cleanups in {}\",\n+                       scope.block_name(\"clean\"));\n+            }\n+\n+            scope.add_cached_early_exit(label, prev_llbb);\n+            self.push_scope(scope);\n+        }\n+\n+        debug!(\"trans_cleanups_to_exit_scope: prev_llbb={}\", prev_llbb);\n+\n+        assert_eq!(self.scopes_len(), orig_scopes_len);\n+        prev_llbb\n+    }\n+\n+    fn get_or_create_landing_pad(&self) -> BasicBlockRef {\n+        /*!\n+         * Creates a landing pad for the top scope, if one does not\n+         * exist.  The landing pad will perform all cleanups necessary\n+         * for an unwind and then `resume` to continue error\n+         * propagation:\n+         *\n+         *     landing_pad -> ... cleanups ... -> [resume]\n+         *\n+         * (The cleanups and resume instruction are created by\n+         * `trans_cleanups_to_exit_scope()`, not in this function\n+         * itself.)\n+         */\n+\n+        let pad_bcx;\n+\n+        debug!(\"get_or_create_landing_pad\");\n+\n+        // Check if a landing pad block exists; if not, create one.\n+        {\n+            let mut scopes = self.scopes.borrow_mut();\n+            let last_scope = scopes.get().mut_last();\n+            match last_scope.cached_landing_pad {\n+                Some(llbb) => { return llbb; }\n+                None => {\n+                    let name = last_scope.block_name(\"unwind\");\n+                    pad_bcx = self.new_block(true, name, None);\n+                    last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n+                }\n+            }\n+        }\n+\n+        // The landing pad return type (the type being propagated). Not sure what\n+        // this represents but it's determined by the personality function and\n+        // this is what the EH proposal example uses.\n+        let llretty = Type::struct_([Type::i8p(), Type::i32()], false);\n+\n+        // The exception handling personality function.\n+        let def_id = common::langcall(pad_bcx, None, \"\", EhPersonalityLangItem);\n+        let llpersonality = callee::trans_fn_ref(pad_bcx, def_id, 0).llfn;\n+\n+        // The only landing pad clause will be 'cleanup'\n+        let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1u);\n+\n+        // The landing pad block is a cleanup\n+        build::SetCleanup(pad_bcx, llretval);\n+\n+        // We store the retval in a function-central alloca, so that calls to\n+        // Resume can find it.\n+        match self.personality.get() {\n+            Some(addr) => {\n+                build::Store(pad_bcx, llretval, addr);\n+            }\n+            None => {\n+                let addr = base::alloca(pad_bcx, common::val_ty(llretval), \"\");\n+                self.personality.set(Some(addr));\n+                build::Store(pad_bcx, llretval, addr);\n+            }\n+        }\n+\n+        // Generate the cleanup block and branch to it.\n+        let cleanup_llbb = self.trans_cleanups_to_exit_scope(UnwindExit);\n+        build::Br(pad_bcx, cleanup_llbb);\n+\n+        return pad_bcx.llbb;\n+    }\n+}\n+\n+impl<'a> CleanupScope<'a> {\n+    fn new(kind: CleanupScopeKind<'a>) -> CleanupScope<'a> {\n+        CleanupScope {\n+            kind: kind,\n+            cleanups: opt_vec::Empty,\n+            cached_early_exits: opt_vec::Empty,\n+            cached_landing_pad: None,\n+        }\n+    }\n+\n+    fn clear_cached_exits(&mut self) {\n+        self.cached_early_exits = opt_vec::Empty;\n+        self.cached_landing_pad = None;\n+    }\n+\n+    fn cached_early_exit(&self,\n+                         label: EarlyExitLabel)\n+                         -> Option<BasicBlockRef> {\n+        self.cached_early_exits.iter().\n+            find(|e| e.label == label).\n+            map(|e| e.cleanup_block)\n+    }\n+\n+    fn add_cached_early_exit(&mut self,\n+                             label: EarlyExitLabel,\n+                             blk: BasicBlockRef) {\n+        self.cached_early_exits.push(\n+            CachedEarlyExit { label: label,\n+                              cleanup_block: blk });\n+    }\n+\n+    fn needs_invoke(&self) -> bool {\n+        /*! True if this scope has cleanups for use during unwinding */\n+\n+        self.cached_landing_pad.is_some() ||\n+            self.cleanups.iter().any(|c| c.clean_on_unwind())\n+    }\n+\n+    fn block_name(&self, prefix: &str) -> ~str {\n+        /*!\n+         * Returns a suitable name to use for the basic block that\n+         * handles this cleanup scope\n+         */\n+\n+        match self.kind {\n+            CustomScopeKind => format!(\"{}_custom_\", prefix),\n+            AstScopeKind(id) => format!(\"{}_ast_{}_\", prefix, id),\n+            LoopScopeKind(id, _) => format!(\"{}_loop_{}_\", prefix, id),\n+        }\n+    }\n+}\n+\n+impl<'a> CleanupScopeKind<'a> {\n+    fn is_temp(&self) -> bool {\n+        match *self {\n+            CustomScopeKind => true,\n+            LoopScopeKind(..) | AstScopeKind(..) => false,\n+        }\n+    }\n+\n+    fn is_ast_with_id(&self, id: ast::NodeId) -> bool {\n+        match *self {\n+            CustomScopeKind | LoopScopeKind(..) => false,\n+            AstScopeKind(i) => i == id\n+        }\n+    }\n+\n+    fn is_loop_with_id(&self, id: ast::NodeId) -> bool {\n+        match *self {\n+            CustomScopeKind | AstScopeKind(..) => false,\n+            LoopScopeKind(i, _) => i == id\n+        }\n+    }\n+\n+    fn early_exit_block(&self,\n+                        id: ast::NodeId,\n+                        exit: uint) -> Option<BasicBlockRef> {\n+        /*!\n+         * If this is a loop scope with id `id`, return the early\n+         * exit block `exit`, else `None`\n+         */\n+\n+        match *self {\n+            LoopScopeKind(i, ref exits) if id == i => Some(exits[exit].llbb),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl EarlyExitLabel {\n+    fn is_unwind(&self) -> bool {\n+        match *self {\n+            UnwindExit => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Cleanup types\n+\n+pub struct DropValue {\n+    is_immediate: bool,\n+    on_unwind: bool,\n+    val: ValueRef,\n+    ty: ty::t,\n+}\n+\n+impl Cleanup for DropValue {\n+    fn clean_on_unwind(&self) -> bool {\n+        self.on_unwind\n+    }\n+\n+    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+        if self.is_immediate {\n+            glue::drop_ty_immediate(bcx, self.val, self.ty)\n+        } else {\n+            glue::drop_ty(bcx, self.val, self.ty)\n+        }\n+    }\n+}\n+\n+pub struct FreeValue {\n+    ptr: ValueRef,\n+    heap: common::heap,\n+}\n+\n+impl Cleanup for FreeValue {\n+    fn clean_on_unwind(&self) -> bool {\n+        true\n+    }\n+\n+    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+        match self.heap {\n+            common::heap_managed => {\n+                glue::trans_free(bcx, self.ptr)\n+            }\n+            common::heap_exchange | common::heap_exchange_closure => {\n+                glue::trans_exchange_free(bcx, self.ptr)\n+            }\n+        }\n+    }\n+}\n+\n+pub fn temporary_scope(tcx: ty::ctxt,\n+                       id: ast::NodeId)\n+                       -> ScopeId {\n+    match tcx.region_maps.temporary_scope(id) {\n+        Some(scope) => {\n+            let r = AstScope(scope);\n+            debug!(\"temporary_scope({}) = {:?}\", id, r);\n+            r\n+        }\n+        None => {\n+            tcx.sess.bug(format!(\"no temporary scope available for expr {}\", id))\n+        }\n+    }\n+}\n+\n+pub fn var_scope(tcx: ty::ctxt,\n+                 id: ast::NodeId)\n+                 -> ScopeId {\n+    let r = AstScope(tcx.region_maps.var_scope(id));\n+    debug!(\"var_scope({}) = {:?}\", id, r);\n+    r\n+}\n+\n+fn cleanup_is_suitable_for(c: &Cleanup,\n+                           label: EarlyExitLabel) -> bool {\n+    !label.is_unwind() || c.clean_on_unwind()\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// These traits just exist to put the methods into this file.\n+\n+pub trait CleanupMethods<'a> {\n+    fn push_ast_cleanup_scope(&self, id: ast::NodeId);\n+    fn push_loop_cleanup_scope(&self,\n+                                   id: ast::NodeId,\n+                                   exits: [&'a Block<'a>, ..EXIT_MAX]);\n+    fn push_custom_cleanup_scope(&self) -> CustomScopeIndex;\n+    fn pop_and_trans_ast_cleanup_scope(&self,\n+                                              bcx: &'a Block<'a>,\n+                                              cleanup_scope: ast::NodeId)\n+                                              -> &'a Block<'a>;\n+    fn pop_loop_cleanup_scope(&self,\n+                              cleanup_scope: ast::NodeId);\n+    fn pop_custom_cleanup_scope(&self,\n+                                custom_scope: CustomScopeIndex);\n+    fn pop_and_trans_custom_cleanup_scope(&self,\n+                                          bcx: &'a Block<'a>,\n+                                          custom_scope: CustomScopeIndex)\n+                                          -> &'a Block<'a>;\n+    fn top_loop_scope(&self) -> ast::NodeId;\n+    fn normal_exit_block(&self,\n+                         cleanup_scope: ast::NodeId,\n+                         exit: uint) -> BasicBlockRef;\n+    fn return_exit_block(&self) -> BasicBlockRef;\n+    fn schedule_drop_mem(&self,\n+                         cleanup_scope: ScopeId,\n+                         val: ValueRef,\n+                         ty: ty::t);\n+    fn schedule_drop_immediate(&self,\n+                               cleanup_scope: ScopeId,\n+                               val: ValueRef,\n+                               ty: ty::t);\n+    fn schedule_free_value(&self,\n+                           cleanup_scope: ScopeId,\n+                           val: ValueRef,\n+                           heap: common::heap);\n+    fn schedule_clean(&self,\n+                      cleanup_scope: ScopeId,\n+                      cleanup: ~Cleanup);\n+    fn schedule_clean_in_ast_scope(&self,\n+                                   cleanup_scope: ast::NodeId,\n+                                   cleanup: ~Cleanup);\n+    fn schedule_clean_in_custom_scope(&self,\n+                                    custom_scope: CustomScopeIndex,\n+                                    cleanup: ~Cleanup);\n+    fn needs_invoke(&self) -> bool;\n+    fn get_landing_pad(&self) -> BasicBlockRef;\n+}\n+\n+trait CleanupHelperMethods<'a> {\n+    fn top_ast_scope(&self) -> Option<ast::NodeId>;\n+    fn top_nonempty_cleanup_scope(&self) -> Option<uint>;\n+    fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n+    fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n+    fn trans_scope_cleanups(&self,\n+                            bcx: &'a Block<'a>,\n+                            scope: &CleanupScope<'a>) -> &'a Block<'a>;\n+    fn trans_cleanups_to_exit_scope(&self,\n+                                    label: EarlyExitLabel)\n+                                    -> BasicBlockRef;\n+    fn get_or_create_landing_pad(&self) -> BasicBlockRef;\n+    fn scopes_len(&self) -> uint;\n+    fn push_scope(&self, scope: CleanupScope<'a>);\n+    fn pop_scope(&self) -> CleanupScope<'a>;\n+    fn top_scope<R>(&self, f: |&CleanupScope<'a>| -> R) -> R;\n+}"}, {"sha": "58f7171452e7df6178419d3cb026d73dd908a917", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -16,7 +16,7 @@ use middle::moves;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n-use middle::trans::datum::{Datum, INIT};\n+use middle::trans::datum::{Datum, Lvalue};\n use middle::trans::debuginfo;\n use middle::trans::expr;\n use middle::trans::glue;\n@@ -112,7 +112,7 @@ pub enum EnvAction {\n \n pub struct EnvValue {\n     action: EnvAction,\n-    datum: Datum\n+    datum: Datum<Lvalue>\n }\n \n impl EnvAction {\n@@ -219,7 +219,7 @@ pub fn store_environment<'a>(\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n-    for (i, bv) in bound_values.iter().enumerate() {\n+    for (i, bv) in bound_values.move_iter().enumerate() {\n         debug!(\"Copy {} into closure\", bv.to_str(ccx));\n \n         if ccx.sess.asm_comments() {\n@@ -230,17 +230,13 @@ pub fn store_environment<'a>(\n         let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);\n \n         match bv.action {\n-            EnvCopy => {\n-                bcx = bv.datum.copy_to(bcx, INIT, bound_data);\n-            }\n-            EnvMove => {\n-                bcx = bv.datum.move_to(bcx, INIT, bound_data);\n+            EnvCopy | EnvMove => {\n+                bcx = bv.datum.store_to(bcx, bound_data);\n             }\n             EnvRef => {\n-                Store(bcx, bv.datum.to_ref_llval(bcx), bound_data);\n+                Store(bcx, bv.datum.to_llref(), bound_data);\n             }\n         }\n-\n     }\n \n     ClosureResult { llbox: llbox, cdata_ty: cdata_ty, bcx: bcx }\n@@ -413,7 +409,6 @@ pub fn trans_expr_fn<'a>(\n                           None,\n                           bcx.fcx.param_substs,\n                           user_id,\n-                          None,\n                           [],\n                           ty::ty_fn_ret(fty),\n                           |fcx| load_environment(fcx, cdata_ty, cap_vars, sigil));"}, {"sha": "cb2987ac16a112ece5eb1d0b17a642bacc73c541", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 84, "deletions": 363, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -20,8 +20,9 @@ use lib;\n use middle::lang_items::LangItem;\n use middle::trans::base;\n use middle::trans::build;\n+use middle::trans::cleanup;\n use middle::trans::datum;\n-use middle::trans::glue;\n+use middle::trans::datum::{Datum, Lvalue};\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n use middle::ty::substs;\n@@ -37,8 +38,7 @@ use std::cast;\n use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n-use std::vec;\n-use syntax::ast::{Name, Ident};\n+use syntax::ast::{Ident};\n use syntax::ast_map::{Path, PathElem, PathPrettyName};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -122,6 +122,15 @@ pub struct tydesc_info {\n  *\n  */\n \n+pub struct NodeInfo {\n+    id: ast::NodeId,\n+    span: Span,\n+}\n+\n+pub fn expr_info(expr: &ast::Expr) -> NodeInfo {\n+    NodeInfo { id: expr.id, span: expr.span }\n+}\n+\n pub struct Stats {\n     n_static_tydescs: Cell<uint>,\n     n_glues_created: Cell<uint>,\n@@ -185,6 +194,10 @@ impl Repr for param_substs {\n     }\n }\n \n+// work around bizarre resolve errors\n+type RvalueDatum = datum::Datum<datum::Rvalue>;\n+type LvalueDatum = datum::Datum<datum::Lvalue>;\n+\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a> {\n@@ -213,13 +226,15 @@ pub struct FunctionContext<'a> {\n     // allocas, so that LLVM will coalesce them into a single alloca call.\n     alloca_insert_pt: Cell<Option<ValueRef>>,\n     llreturn: Cell<Option<BasicBlockRef>>,\n+\n     // The 'self' value currently in use in this function, if there\n     // is one.\n     //\n     // NB: This is the type of the self *variable*, not the self *type*. The\n     // self type is set only for default methods, while the self variable is\n     // set for all methods.\n-    llself: Cell<Option<datum::Datum>>,\n+    llself: Cell<Option<LvalueDatum>>,\n+\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n     personality: Cell<Option<ValueRef>>,\n@@ -230,10 +245,12 @@ pub struct FunctionContext<'a> {\n     caller_expects_out_pointer: bool,\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: RefCell<HashMap<ast::NodeId, datum::Datum>>,\n+    llargs: RefCell<HashMap<ast::NodeId, LvalueDatum>>,\n+\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: RefCell<HashMap<ast::NodeId, datum::Datum>>,\n+    lllocals: RefCell<HashMap<ast::NodeId, LvalueDatum>>,\n+\n     // Same as above, but for closure upvars\n     llupvars: RefCell<HashMap<ast::NodeId, ValueRef>>,\n \n@@ -253,14 +270,14 @@ pub struct FunctionContext<'a> {\n     // The arena that blocks are allocated from.\n     block_arena: TypedArena<Block<'a>>,\n \n-    // The arena that scope info is allocated from.\n-    scope_info_arena: TypedArena<ScopeInfo<'a>>,\n-\n     // This function's enclosing crate context.\n     ccx: @CrateContext,\n \n     // Used and maintained by the debuginfo module.\n     debug_context: debuginfo::FunctionDebugContext,\n+\n+    // Cleanup scopes.\n+    scopes: RefCell<~[cleanup::CleanupScope<'a>]>,\n }\n \n impl<'a> FunctionContext<'a> {\n@@ -302,315 +319,67 @@ impl<'a> FunctionContext<'a> {\n \n         self.llreturn.get().unwrap()\n     }\n-}\n-\n-pub fn warn_not_to_commit(ccx: &CrateContext, msg: &str) {\n-    if !ccx.do_not_commit_warning_issued.get() {\n-        ccx.do_not_commit_warning_issued.set(true);\n-        ccx.sess.warn(msg.to_str() + \" -- do not commit like this!\");\n-    }\n-}\n-\n-// Heap selectors. Indicate which heap something should go on.\n-#[deriving(Eq)]\n-pub enum heap {\n-    heap_managed,\n-    heap_exchange,\n-    heap_exchange_closure\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub enum cleantype {\n-    normal_exit_only,\n-    normal_exit_and_unwind\n-}\n-\n-// Cleanup functions\n-\n-/// A cleanup function: a built-in destructor.\n-pub trait CleanupFunction {\n-    fn clean<'a>(&self, block: &'a Block<'a>) -> &'a Block<'a>;\n-}\n-\n-/// A cleanup function that calls the \"drop glue\" (destructor function) on\n-/// a datum.\n-struct DatumDroppingCleanupFunction {\n-    datum: datum::Datum\n-}\n-\n-impl CleanupFunction for DatumDroppingCleanupFunction {\n-    fn clean<'a>(&self, block: &'a Block<'a>) -> &'a Block<'a> {\n-        self.datum.drop_val(block)\n-    }\n-}\n-\n-/// A cleanup function that frees some memory in the garbage-collected heap.\n-pub struct GCHeapFreeingCleanupFunction {\n-    ptr: ValueRef,\n-}\n-\n-impl CleanupFunction for GCHeapFreeingCleanupFunction {\n-    fn clean<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n-        glue::trans_free(bcx, self.ptr)\n-    }\n-}\n-\n-/// A cleanup function that frees some memory in the exchange heap.\n-pub struct ExchangeHeapFreeingCleanupFunction {\n-    ptr: ValueRef,\n-}\n-\n-impl CleanupFunction for ExchangeHeapFreeingCleanupFunction {\n-    fn clean<'a>(&self, bcx: &'a Block) -> &'a Block<'a> {\n-        glue::trans_exchange_free(bcx, self.ptr)\n-    }\n-}\n \n-pub enum cleanup {\n-    Clean(@CleanupFunction, cleantype),\n-    CleanTemp(ValueRef, @CleanupFunction, cleantype),\n-}\n-\n-// Can't use deriving(Clone) because of the managed closure.\n-impl Clone for cleanup {\n-    fn clone(&self) -> cleanup {\n-        match *self {\n-            Clean(f, ct) => Clean(f, ct),\n-            CleanTemp(v, f, ct) => CleanTemp(v, f, ct),\n+    pub fn new_block(&'a self,\n+                     is_lpad: bool,\n+                     name: &str,\n+                     opt_node_id: Option<ast::NodeId>)\n+                     -> &'a Block<'a> {\n+        unsafe {\n+            let llbb = name.with_c_str(|buf| {\n+                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx,\n+                                                        self.llfn,\n+                                                        buf)\n+                });\n+            Block::new(llbb, is_lpad, opt_node_id, self)\n         }\n     }\n-}\n-\n-// Used to remember and reuse existing cleanup paths\n-// target: none means the path ends in an resume instruction\n-#[deriving(Clone)]\n-pub struct cleanup_path {\n-    target: Option<BasicBlockRef>,\n-    size: uint,\n-    dest: BasicBlockRef\n-}\n-\n-pub fn shrink_scope_clean(scope_info: &ScopeInfo, size: uint) {\n-    scope_info.landing_pad.set(None);\n-    let new_cleanup_paths = {\n-        let cleanup_paths = scope_info.cleanup_paths.borrow();\n-        cleanup_paths.get()\n-                     .iter()\n-                     .take_while(|&cu| cu.size <= size)\n-                     .map(|&x| x)\n-                     .collect()\n-    };\n-    scope_info.cleanup_paths.set(new_cleanup_paths)\n-}\n-\n-pub fn grow_scope_clean(scope_info: &ScopeInfo) {\n-    scope_info.landing_pad.set(None);\n-}\n \n-pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n-    if ty::type_needs_unwind_cleanup(cx, ty) {\n-        normal_exit_and_unwind\n-    } else {\n-        normal_exit_only\n+    pub fn new_id_block(&'a self,\n+                        name: &str,\n+                        node_id: ast::NodeId)\n+                        -> &'a Block<'a> {\n+        self.new_block(false, name, Some(node_id))\n     }\n-}\n-\n-pub fn add_clean(bcx: &Block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(bcx.tcx(), ty) { return; }\n-\n-    debug!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), ty.repr(bcx.tcx()));\n-\n-    let cleanup_type = cleanup_type(bcx.tcx(), ty);\n-    in_scope_cx(bcx, None, |scope_info| {\n-        {\n-            let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(Clean(@DatumDroppingCleanupFunction {\n-                datum: datum::Datum {\n-                    val: val,\n-                    ty: ty,\n-                    mode: datum::ByRef(datum::ZeroMem)\n-                }\n-            } as @CleanupFunction,\n-            cleanup_type));\n-        }\n-        grow_scope_clean(scope_info);\n-    })\n-}\n-\n-pub fn add_clean_temp_immediate(bcx: &Block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(bcx.tcx(), ty) { return; }\n-\n-    debug!(\"add_clean_temp_immediate({}, {}, {})\",\n-           bcx.to_str(), bcx.val_to_str(val),\n-           ty.repr(bcx.tcx()));\n-    let cleanup_type = cleanup_type(bcx.tcx(), ty);\n-    in_scope_cx(bcx, None, |scope_info| {\n-        {\n-            let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(CleanTemp(val, @DatumDroppingCleanupFunction {\n-                datum: datum::Datum {\n-                    val: val,\n-                    ty: ty,\n-                    mode: datum::ByValue\n-                }\n-            } as @CleanupFunction,\n-            cleanup_type));\n-        }\n-        grow_scope_clean(scope_info);\n-    })\n-}\n-\n-pub fn add_clean_temp_mem(bcx: &Block, val: ValueRef, t: ty::t) {\n-    add_clean_temp_mem_in_scope_(bcx, None, val, t);\n-}\n-\n-pub fn add_clean_temp_mem_in_scope(bcx: &Block,\n-                                   scope_id: ast::NodeId,\n-                                   val: ValueRef,\n-                                   t: ty::t) {\n-    add_clean_temp_mem_in_scope_(bcx, Some(scope_id), val, t);\n-}\n \n-pub fn add_clean_temp_mem_in_scope_(bcx: &Block, scope_id: Option<ast::NodeId>,\n-                                    val: ValueRef, t: ty::t) {\n-    if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n-    debug!(\"add_clean_temp_mem({}, {}, {})\",\n-           bcx.to_str(), bcx.val_to_str(val),\n-           t.repr(bcx.tcx()));\n-    let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    in_scope_cx(bcx, scope_id, |scope_info| {\n-        {\n-            let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(CleanTemp(val, @DatumDroppingCleanupFunction {\n-                datum: datum::Datum {\n-                    val: val,\n-                    ty: t,\n-                    mode: datum::ByRef(datum::RevokeClean)\n-                }\n-            } as @CleanupFunction,\n-            cleanup_type));\n-        }\n-        grow_scope_clean(scope_info);\n-    })\n-}\n+    pub fn new_temp_block(&'a self,\n+                          name: &str)\n+                          -> &'a Block<'a> {\n+        self.new_block(false, name, None)\n+    }\n \n-pub fn add_clean_free(cx: &Block, ptr: ValueRef, heap: heap) {\n-    let free_fn = match heap {\n-        heap_managed => {\n-            @GCHeapFreeingCleanupFunction {\n-                ptr: ptr,\n-            } as @CleanupFunction\n-        }\n-        heap_exchange | heap_exchange_closure => {\n-            @ExchangeHeapFreeingCleanupFunction {\n-                ptr: ptr,\n-            } as @CleanupFunction\n-        }\n-    };\n-    in_scope_cx(cx, None, |scope_info| {\n-        {\n-            let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(CleanTemp(ptr,\n-                                           free_fn,\n-                                           normal_exit_and_unwind));\n+    pub fn join_blocks(&'a self,\n+                       id: ast::NodeId,\n+                       in_cxs: &[&'a Block<'a>])\n+                       -> &'a Block<'a> {\n+        let out = self.new_id_block(\"join\", id);\n+        let mut reachable = false;\n+        for bcx in in_cxs.iter() {\n+            if !bcx.unreachable.get() {\n+                build::Br(*bcx, out.llbb);\n+                reachable = true;\n+            }\n         }\n-        grow_scope_clean(scope_info);\n-    })\n-}\n-\n-// Note that this only works for temporaries. We should, at some point, move\n-// to a system where we can also cancel the cleanup on local variables, but\n-// this will be more involved. For now, we simply zero out the local, and the\n-// drop glue checks whether it is zero.\n-pub fn revoke_clean(cx: &Block, val: ValueRef) {\n-    in_scope_cx(cx, None, |scope_info| {\n-        let cleanup_pos = {\n-            let mut cleanups = scope_info.cleanups.borrow_mut();\n-            debug!(\"revoke_clean({}, {}) revoking {:?} from {:?}\",\n-                   cx.to_str(), cx.val_to_str(val), val, cleanups.get());\n-            cleanups.get().iter().position(|cu| {\n-                match *cu {\n-                    CleanTemp(v, _, _) if v == val => true,\n-                    _ => false\n-                }\n-            })\n-        };\n-        debug!(\"revoke_clean({}, {}) revoking {:?}\",\n-               cx.to_str(), cx.val_to_str(val), cleanup_pos);\n-        for &i in cleanup_pos.iter() {\n-            let new_cleanups = {\n-                let cleanups = scope_info.cleanups.borrow();\n-                vec::append(cleanups.get().slice(0u, i).to_owned(),\n-                            cleanups.get().slice(i + 1u, cleanups.get()\n-                                                                 .len()))\n-            };\n-            scope_info.cleanups.set(new_cleanups);\n-            shrink_scope_clean(scope_info, i);\n+        if !reachable {\n+            build::Unreachable(out);\n         }\n-    })\n-}\n-\n-pub fn block_cleanups(bcx: &Block) -> ~[cleanup] {\n-    match bcx.scope.get() {\n-       None  => ~[],\n-       Some(inf) => inf.cleanups.get(),\n-    }\n-}\n-\n-pub struct ScopeInfo<'a> {\n-    parent: Option<&'a ScopeInfo<'a>>,\n-    loop_break: Option<&'a Block<'a>>,\n-    loop_label: Option<Name>,\n-    // A list of functions that must be run at when leaving this\n-    // block, cleaning up any variables that were introduced in the\n-    // block.\n-    cleanups: RefCell<~[cleanup]>,\n-    // Existing cleanup paths that may be reused, indexed by destination and\n-    // cleared when the set of cleanups changes.\n-    cleanup_paths: RefCell<~[cleanup_path]>,\n-    // Unwinding landing pad. Also cleared when cleanups change.\n-    landing_pad: Cell<Option<BasicBlockRef>>,\n-    // info about the AST node this scope originated from, if any\n-    node_info: Option<NodeInfo>,\n-}\n-\n-impl<'a> ScopeInfo<'a> {\n-    pub fn empty_cleanups(&self) -> bool {\n-        let cleanups = self.cleanups.borrow();\n-        cleanups.get().is_empty()\n-    }\n-}\n-\n-pub trait get_node_info {\n-    fn info(&self) -> Option<NodeInfo>;\n-}\n-\n-impl get_node_info for ast::Expr {\n-    fn info(&self) -> Option<NodeInfo> {\n-        Some(NodeInfo {id: self.id,\n-                       callee_id: self.get_callee_id(),\n-                       span: self.span})\n-    }\n-}\n-\n-impl get_node_info for ast::Block {\n-    fn info(&self) -> Option<NodeInfo> {\n-        Some(NodeInfo {id: self.id,\n-                       callee_id: None,\n-                       span: self.span})\n+        return out;\n     }\n }\n \n-impl get_node_info for Option<@ast::Expr> {\n-    fn info(&self) -> Option<NodeInfo> {\n-        self.as_ref().and_then(|s| s.info())\n+pub fn warn_not_to_commit(ccx: &mut CrateContext, msg: &str) {\n+    if !ccx.do_not_commit_warning_issued.get() {\n+        ccx.do_not_commit_warning_issued.set(true);\n+        ccx.sess.warn(msg.to_str() + \" -- do not commit like this!\");\n     }\n }\n \n-pub struct NodeInfo {\n-    id: ast::NodeId,\n-    callee_id: Option<ast::NodeId>,\n-    span: Span\n+// Heap selectors. Indicate which heap something should go on.\n+#[deriving(Eq)]\n+pub enum heap {\n+    heap_managed,\n+    heap_exchange,\n+    heap_exchange_closure\n }\n \n // Basic block context.  We create a block context for each basic block\n@@ -627,13 +396,14 @@ pub struct Block<'a> {\n     llbb: BasicBlockRef,\n     terminated: Cell<bool>,\n     unreachable: Cell<bool>,\n-    parent: Option<&'a Block<'a>>,\n-    // The current scope within this basic block\n-    scope: RefCell<Option<&'a ScopeInfo<'a>>>,\n+\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n-    // info about the AST node this block originated from, if any\n-    node_info: Option<NodeInfo>,\n+\n+    // AST node-id associated with this block, if any. Used for\n+    // debugging purposes only.\n+    opt_node_id: Option<ast::NodeId>,\n+\n     // The function context for the function to which this block is\n     // attached.\n     fcx: &'a FunctionContext<'a>,\n@@ -642,20 +412,17 @@ pub struct Block<'a> {\n impl<'a> Block<'a> {\n     pub fn new<'a>(\n                llbb: BasicBlockRef,\n-               parent: Option<&'a Block<'a>>,\n                is_lpad: bool,\n-               node_info: Option<NodeInfo>,\n+               opt_node_id: Option<ast::NodeId>,\n                fcx: &'a FunctionContext<'a>)\n                -> &'a Block<'a> {\n         fcx.block_arena.alloc(Block {\n             llbb: llbb,\n             terminated: Cell::new(false),\n             unreachable: Cell::new(false),\n-            parent: parent,\n-            scope: RefCell::new(None),\n             is_lpad: is_lpad,\n-            node_info: node_info,\n-            fcx: fcx,\n+            opt_node_id: opt_node_id,\n+            fcx: fcx\n         })\n     }\n \n@@ -709,12 +476,8 @@ impl<'a> Block<'a> {\n     }\n \n     pub fn to_str(&self) -> ~str {\n-        unsafe {\n-            match self.node_info {\n-                Some(node_info) => format!(\"[block {}]\", node_info.id),\n-                None => format!(\"[block {}]\", transmute::<&Block, *Block>(self)),\n-            }\n-        }\n+        let blk: *Block = self;\n+        format!(\"[block {}]\", blk)\n     }\n }\n \n@@ -743,48 +506,6 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx<'a>(\n-                   cx: &'a Block<'a>,\n-                   scope_id: Option<ast::NodeId>,\n-                   f: |si: &'a ScopeInfo<'a>|) {\n-    let mut cur = cx;\n-    let mut cur_scope = cur.scope.get();\n-    loop {\n-        cur_scope = match cur_scope {\n-            Some(inf) => match scope_id {\n-                Some(wanted) => match inf.node_info {\n-                    Some(NodeInfo { id: actual, .. }) if wanted == actual => {\n-                        debug!(\"in_scope_cx: selected cur={} (cx={}) info={:?}\",\n-                               cur.to_str(), cx.to_str(), inf.node_info);\n-                        f(inf);\n-                        return;\n-                    },\n-                    _ => inf.parent,\n-                },\n-                None => {\n-                    debug!(\"in_scope_cx: selected cur={} (cx={}) info={:?}\",\n-                           cur.to_str(), cx.to_str(), inf.node_info);\n-                    f(inf);\n-                    return;\n-                }\n-            },\n-            None => {\n-                cur = block_parent(cur);\n-                cur.scope.get()\n-            }\n-        }\n-    }\n-}\n-\n-pub fn block_parent<'a>(cx: &'a Block<'a>) -> &'a Block<'a> {\n-    match cx.parent {\n-      Some(b) => b,\n-      None    => cx.sess().bug(format!(\"block_parent called on root block {:?}\",\n-                                   cx))\n-    }\n-}\n-\n-\n // Let T be the content of a box @T.  tuplify_box_ty(t) returns the\n // representation of @T as a tuple (i.e., the ty::t version of what T_box()\n // returns).\n@@ -1012,7 +733,7 @@ pub enum mono_param_id {\n     mono_repr(uint /* size */,\n               uint /* align */,\n               MonoDataClass,\n-              datum::DatumMode),\n+              datum::RvalueMode),\n }\n \n #[deriving(Eq,IterBytes)]"}, {"sha": "ec47dbacb39c0eb85ebaa91fa16b2ea46f7b5b2c", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 186, "deletions": 196, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -15,10 +15,12 @@ use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::debuginfo;\n+use middle::trans::cleanup;\n+use middle::trans::cleanup::CleanupMethods;\n use middle::trans::expr;\n use middle::ty;\n-use util::common::indenter;\n use util::ppaux;\n+use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n@@ -28,10 +30,56 @@ use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit::Visitor;\n \n-pub fn trans_block<'a>(bcx: &'a Block<'a>, b: &ast::Block, dest: expr::Dest)\n-                   -> &'a Block<'a> {\n+pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n+                      s: &ast::Stmt)\n+                      -> &'a Block<'a> {\n+    let _icx = push_ctxt(\"trans_stmt\");\n+    let fcx = cx.fcx;\n+    debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n+\n+    if cx.sess().asm_comments() {\n+        add_span_comment(cx, s.span, s.repr(cx.tcx()));\n+    }\n+\n+    let mut bcx = cx;\n+\n+    let id = ast_util::stmt_id(s);\n+    fcx.push_ast_cleanup_scope(id);\n+\n+    match s.node {\n+        ast::StmtExpr(e, _) | ast::StmtSemi(e, _) => {\n+            bcx = expr::trans_into(cx, e, expr::Ignore);\n+        }\n+        ast::StmtDecl(d, _) => {\n+            match d.node {\n+                ast::DeclLocal(ref local) => {\n+                    bcx = init_local(bcx, *local);\n+                    if cx.sess().opts.extra_debuginfo {\n+                        debuginfo::create_local_var_metadata(bcx, *local);\n+                    }\n+                }\n+                ast::DeclItem(i) => trans_item(cx.fcx.ccx, i)\n+            }\n+        }\n+        ast::StmtMac(..) => cx.tcx().sess.bug(\"unexpanded macro\")\n+    }\n+\n+    bcx = fcx.pop_and_trans_ast_cleanup_scope(\n+        bcx, ast_util::stmt_id(s));\n+\n+    return bcx;\n+}\n+\n+pub fn trans_block<'a>(bcx: &'a Block<'a>,\n+                       b: &ast::Block,\n+                       dest: expr::Dest)\n+                       -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_block\");\n+    let fcx = bcx.fcx;\n     let mut bcx = bcx;\n+\n+    fcx.push_ast_cleanup_scope(b.id);\n+\n     for s in b.stmts.iter() {\n         bcx = trans_stmt(bcx, *s);\n     }\n@@ -43,27 +91,26 @@ pub fn trans_block<'a>(bcx: &'a Block<'a>, b: &ast::Block, dest: expr::Dest)\n             assert!(dest == expr::Ignore || bcx.unreachable.get());\n         }\n     }\n+\n+    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, b.id);\n+\n     return bcx;\n }\n \n-pub fn trans_if<'a>(\n-                bcx: &'a Block<'a>,\n-                cond: &ast::Expr,\n-                thn: ast::P<ast::Block>,\n-                els: Option<@ast::Expr>,\n-                dest: expr::Dest)\n-                -> &'a Block<'a> {\n-    debug!(\"trans_if(bcx={}, cond={}, thn={:?}, dest={})\",\n-           bcx.to_str(), bcx.expr_to_str(cond), thn.id,\n+pub fn trans_if<'a>(bcx: &'a Block<'a>,\n+                    if_id: ast::NodeId,\n+                    cond: &ast::Expr,\n+                    thn: ast::P<ast::Block>,\n+                    els: Option<@ast::Expr>,\n+                    dest: expr::Dest)\n+                    -> &'a Block<'a> {\n+    debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={:?}, dest={})\",\n+           bcx.to_str(), if_id, bcx.expr_to_str(cond), thn.id,\n            dest.to_str(bcx.ccx()));\n-    let _indenter = indenter();\n-\n     let _icx = push_ctxt(\"trans_if\");\n+    let mut bcx = bcx;\n \n-    let Result {bcx, val: cond_val} =\n-        expr::trans_to_datum(bcx, cond).to_result();\n-\n-    let cond_val = bool_to_i1(bcx, cond_val);\n+    let cond_val = unpack_result!(bcx, expr::trans(bcx, cond).to_llbool());\n \n     // Drop branches that are known to be impossible\n     if is_const(cond_val) && !is_undef(cond_val) {\n@@ -76,241 +123,183 @@ pub fn trans_if<'a>(\n                 None => {}\n             }\n             // if true { .. } [else { .. }]\n-            return with_scope(bcx, thn.info(), \"if_true_then\", |bcx| {\n-                let bcx_out = trans_block(bcx, thn, dest);\n-                debuginfo::clear_source_location(bcx.fcx);\n-                bcx_out\n-            })\n+            bcx = trans_block(bcx, thn, dest);\n+            debuginfo::clear_source_location(bcx.fcx);\n         } else {\n             let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx } ;\n             trans.visit_block(thn, ());\n \n             match els {\n                 // if false { .. } else { .. }\n                 Some(elexpr) => {\n-                    return with_scope(bcx,\n-                                      elexpr.info(),\n-                                      \"if_false_then\",\n-                                      |bcx| {\n-                        let bcx_out = trans_if_else(bcx, elexpr, dest, false);\n-                        debuginfo::clear_source_location(bcx.fcx);\n-                        bcx_out\n-                    })\n+                    bcx = expr::trans_into(bcx, elexpr, dest);\n+                    debuginfo::clear_source_location(bcx.fcx);\n                 }\n+\n                 // if false { .. }\n-                None => return bcx,\n+                None => { }\n             }\n         }\n-    }\n \n-    let then_bcx_in = scope_block(bcx, thn.info(), \"then\");\n+        return bcx;\n+    }\n \n+    let name = format!(\"then-block-{}-\", thn.id);\n+    let then_bcx_in = bcx.fcx.new_id_block(name, thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n-\n     debuginfo::clear_source_location(bcx.fcx);\n-    let then_bcx_out = trans_block_cleanups(then_bcx_out,\n-                                            block_cleanups(then_bcx_in));\n-\n-    // Calling trans_block directly instead of trans_expr\n-    // because trans_expr will create another scope block\n-    // context for the block, but we've already got the\n-    // 'else' context\n-    let (else_bcx_in, next_bcx) = match els {\n-      Some(elexpr) => {\n-          let else_bcx_in = scope_block(bcx, elexpr.info(), \"else\");\n-          let else_bcx_out = trans_if_else(else_bcx_in, elexpr, dest, true);\n-          (else_bcx_in, join_blocks(bcx, [then_bcx_out, else_bcx_out]))\n-      }\n-      _ => {\n-          let next_bcx = sub_block(bcx, \"next\");\n-          Br(then_bcx_out, next_bcx.llbb);\n \n-          (next_bcx, next_bcx)\n-      }\n-    };\n+    let next_bcx;\n+    match els {\n+        Some(elexpr) => {\n+            let else_bcx_in = bcx.fcx.new_id_block(\"else-block\", elexpr.id);\n+            let else_bcx_out = expr::trans_into(else_bcx_in, elexpr, dest);\n+            next_bcx = bcx.fcx.join_blocks(if_id,\n+                                           [then_bcx_out, else_bcx_out]);\n+            CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n+        }\n \n-    debug!(\"then_bcx_in={}, else_bcx_in={}\",\n-           then_bcx_in.to_str(), else_bcx_in.to_str());\n+        None => {\n+            next_bcx = bcx.fcx.new_id_block(\"next-block\", if_id);\n+            Br(then_bcx_out, next_bcx.llbb);\n+            CondBr(bcx, cond_val, then_bcx_in.llbb, next_bcx.llbb);\n+        }\n+    }\n \n     // Clear the source location because it is still set to whatever has been translated\n     // right before.\n-    debuginfo::clear_source_location(else_bcx_in.fcx);\n-    CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n-    return next_bcx;\n-\n-    // trans `else [ if { .. } ... | { .. } ]`\n-    fn trans_if_else<'a>(\n-                     else_bcx_in: &'a Block<'a>,\n-                     elexpr: @ast::Expr,\n-                     dest: expr::Dest,\n-                     cleanup: bool)\n-                     -> &'a Block<'a> {\n-        let else_bcx_out = match elexpr.node {\n-            ast::ExprIf(_, _, _) => {\n-                let elseif_blk = ast_util::block_from_expr(elexpr);\n-                trans_block(else_bcx_in, elseif_blk, dest)\n-            }\n-            ast::ExprBlock(blk) => {\n-                trans_block(else_bcx_in, blk, dest)\n-            }\n-            // would be nice to have a constraint on ifs\n-            _ => else_bcx_in.tcx().sess.bug(\"strange alternative in if\")\n-        };\n-        if cleanup {\n-            debuginfo::clear_source_location(else_bcx_in.fcx);\n-            trans_block_cleanups(else_bcx_out, block_cleanups(else_bcx_in))\n-        } else {\n-            else_bcx_out\n-        }\n-    }\n-}\n+    debuginfo::clear_source_location(next_bcx.fcx);\n \n-pub fn join_blocks<'a>(\n-                   parent_bcx: &'a Block<'a>,\n-                   in_cxs: &[&'a Block<'a>])\n-                   -> &'a Block<'a> {\n-    let out = sub_block(parent_bcx, \"join\");\n-    let mut reachable = false;\n-    for bcx in in_cxs.iter() {\n-        if !bcx.unreachable.get() {\n-            Br(*bcx, out.llbb);\n-            reachable = true;\n-        }\n-    }\n-    if !reachable {\n-        Unreachable(out);\n-    }\n-    return out;\n+    next_bcx\n }\n \n-pub fn trans_while<'a>(\n-                   bcx: &'a Block<'a>,\n-                   cond: &ast::Expr,\n-                   body: &ast::Block)\n-                   -> &'a Block<'a> {\n+pub fn trans_while<'a>(bcx: &'a Block<'a>,\n+                       loop_id: ast::NodeId,\n+                       cond: &ast::Expr,\n+                       body: &ast::Block)\n+                       -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_while\");\n-    let next_bcx = sub_block(bcx, \"while next\");\n+    let fcx = bcx.fcx;\n \n     //            bcx\n     //             |\n-    //          loop_bcx\n-    //             |\n     //         cond_bcx_in  <--------+\n     //             |                 |\n     //         cond_bcx_out          |\n     //           |      |            |\n     //           |    body_bcx_in    |\n-    //    +------+      |            |\n+    // cleanup_blk      |            |\n     //    |           body_bcx_out --+\n-    // next_bcx\n+    // next_bcx_in\n+\n+    let next_bcx_in = fcx.new_id_block(\"while_exit\", loop_id);\n+    let cond_bcx_in = fcx.new_id_block(\"while_cond\", cond.id);\n+    let body_bcx_in = fcx.new_id_block(\"while_body\", body.id);\n+\n+    fcx.push_loop_cleanup_scope(loop_id, [next_bcx_in, cond_bcx_in]);\n \n-    let loop_bcx = loop_scope_block(bcx, next_bcx, None, \"`while`\",\n-                                    body.info());\n-    let cond_bcx_in = scope_block(loop_bcx, cond.info(), \"while loop cond\");\n-    let body_bcx_in = scope_block(loop_bcx, body.info(), \"while loop body\");\n-    Br(bcx, loop_bcx.llbb);\n-    Br(loop_bcx, cond_bcx_in.llbb);\n+    Br(bcx, cond_bcx_in.llbb);\n+\n+    // compile the block where we will handle loop cleanups\n+    let cleanup_llbb = fcx.normal_exit_block(loop_id, cleanup::EXIT_BREAK);\n \n     // compile the condition\n     let Result {bcx: cond_bcx_out, val: cond_val} =\n-        expr::trans_to_datum(cond_bcx_in, cond).to_result();\n-    let cond_val = bool_to_i1(cond_bcx_out, cond_val);\n-    let cond_bcx_out =\n-        trans_block_cleanups(cond_bcx_out, block_cleanups(cond_bcx_in));\n-    CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, next_bcx.llbb);\n+        expr::trans(cond_bcx_in, cond).to_llbool();\n+    CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, cleanup_llbb);\n \n     // loop body:\n     let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n-    cleanup_and_Br(body_bcx_out, body_bcx_in, cond_bcx_in.llbb);\n+    Br(body_bcx_out, cond_bcx_in.llbb);\n \n-    return next_bcx;\n+    fcx.pop_loop_cleanup_scope(loop_id);\n+    return next_bcx_in;\n }\n \n-pub fn trans_loop<'a>(\n-                  bcx: &'a Block<'a>,\n-                  body: &ast::Block,\n-                  opt_label: Option<Name>)\n-                  -> &'a Block<'a> {\n+pub fn trans_loop<'a>(bcx:&'a Block<'a>,\n+                      loop_id: ast::NodeId,\n+                      body: &ast::Block)\n+                      -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_loop\");\n-    let next_bcx = sub_block(bcx, \"next\");\n-    let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, \"`loop`\",\n-                                       body.info());\n+    let fcx = bcx.fcx;\n+\n+    //            bcx\n+    //             |\n+    //         body_bcx_in\n+    //             |\n+    //         body_bcx_out\n+    //\n+    // next_bcx\n+    //\n+    // Links between body_bcx_in and next_bcx are created by\n+    // break statements.\n+\n+    let next_bcx_in = bcx.fcx.new_id_block(\"loop_exit\", loop_id);\n+    let body_bcx_in = bcx.fcx.new_id_block(\"loop_body\", body.id);\n+\n+    fcx.push_loop_cleanup_scope(loop_id, [next_bcx_in, body_bcx_in]);\n+\n     Br(bcx, body_bcx_in.llbb);\n     let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n-    cleanup_and_Br(body_bcx_out, body_bcx_in, body_bcx_in.llbb);\n-    return next_bcx;\n+    Br(body_bcx_out, body_bcx_in.llbb);\n+\n+    fcx.pop_loop_cleanup_scope(loop_id);\n+\n+    return next_bcx_in;\n }\n \n-pub fn trans_break_cont<'a>(\n-                        bcx: &'a Block<'a>,\n-                        opt_label: Option<Name>,\n-                        to_end: bool)\n-                        -> &'a Block<'a> {\n+pub fn trans_break_cont<'a>(bcx: &'a Block<'a>,\n+                            expr_id: ast::NodeId,\n+                            opt_label: Option<Name>,\n+                            exit: uint)\n+                            -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_break_cont\");\n-    // Locate closest loop block, outputting cleanup as we go.\n-    let mut unwind = bcx;\n-    let mut cur_scope = unwind.scope.get();\n-    let mut target;\n-    loop {\n-        cur_scope = match cur_scope {\n-            Some(&ScopeInfo {\n-                loop_break: Some(brk),\n-                loop_label: l,\n-                parent,\n-                ..\n-            }) => {\n-                // If we're looking for a labeled loop, check the label...\n-                target = if to_end {\n-                    brk\n-                } else {\n-                    unwind\n-                };\n-                match opt_label {\n-                    Some(desired) => match l {\n-                        Some(actual) if actual == desired => break,\n-                        // If it doesn't match the one we want,\n-                        // don't break\n-                        _ => parent,\n-                    },\n-                    None => break,\n+    let fcx = bcx.fcx;\n+\n+    if bcx.unreachable.get() {\n+        return bcx;\n+    }\n+\n+    // Locate loop that we will break to\n+    let loop_id = match opt_label {\n+        None => fcx.top_loop_scope(),\n+        Some(_) => {\n+            let def_map = bcx.tcx().def_map.borrow();\n+            match def_map.get().find(&expr_id) {\n+                Some(&ast::DefLabel(loop_id)) => loop_id,\n+                ref r => {\n+                    bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\", r))\n                 }\n             }\n-            Some(inf) => inf.parent,\n-            None => {\n-                unwind = match unwind.parent {\n-                    Some(bcx) => bcx,\n-                        // This is a return from a loop body block\n-                        None => {\n-                            Store(bcx,\n-                                  C_bool(!to_end),\n-                                  bcx.fcx.llretptr.get().unwrap());\n-                            cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n-                            Unreachable(bcx);\n-                            return bcx;\n-                        }\n-                };\n-                unwind.scope.get()\n-            }\n         }\n-    }\n-    cleanup_and_Br(bcx, unwind, target.llbb);\n-    Unreachable(bcx);\n+    };\n+\n+    // Generate appropriate cleanup code and branch\n+    let cleanup_llbb = fcx.normal_exit_block(loop_id, exit);\n+    Br(bcx, cleanup_llbb);\n+    Unreachable(bcx); // anything afterwards should be ignored\n     return bcx;\n }\n \n-pub fn trans_break<'a>(bcx: &'a Block<'a>, label_opt: Option<Name>)\n-                   -> &'a Block<'a> {\n-    return trans_break_cont(bcx, label_opt, true);\n+pub fn trans_break<'a>(bcx: &'a Block<'a>,\n+                       expr_id: ast::NodeId,\n+                       label_opt: Option<Name>)\n+                       -> &'a Block<'a> {\n+    return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_BREAK);\n }\n \n-pub fn trans_cont<'a>(bcx: &'a Block<'a>, label_opt: Option<Name>)\n-                  -> &'a Block<'a> {\n-    return trans_break_cont(bcx, label_opt, false);\n+pub fn trans_cont<'a>(bcx: &'a Block<'a>,\n+                      expr_id: ast::NodeId,\n+                      label_opt: Option<Name>)\n+                      -> &'a Block<'a> {\n+    return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_LOOP);\n }\n \n-pub fn trans_ret<'a>(bcx: &'a Block<'a>, e: Option<@ast::Expr>)\n-                 -> &'a Block<'a> {\n+pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n+                     e: Option<@ast::Expr>)\n+                     -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_ret\");\n+    let fcx = bcx.fcx;\n     let mut bcx = bcx;\n     let dest = match bcx.fcx.llretptr.get() {\n         None => expr::Ignore,\n@@ -322,7 +311,8 @@ pub fn trans_ret<'a>(bcx: &'a Block<'a>, e: Option<@ast::Expr>)\n         }\n         _ => ()\n     }\n-    cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n+    let cleanup_llbb = fcx.return_exit_block();\n+    Br(bcx, cleanup_llbb);\n     Unreachable(bcx);\n     return bcx;\n }\n@@ -338,8 +328,8 @@ pub fn trans_fail_expr<'a>(\n         Some(arg_expr) => {\n             let ccx = bcx.ccx();\n             let tcx = ccx.tcx;\n-            let arg_datum = unpack_datum!(\n-                bcx, expr::trans_to_datum(bcx, arg_expr));\n+            let arg_datum =\n+                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, arg_expr, \"fail\"));\n \n             if ty::type_is_str(arg_datum.ty) {\n                 let (lldata, _) = arg_datum.get_vec_base_and_len_no_root(bcx);"}, {"sha": "4b89be64f53be1ed0753deacea62938620172a51", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 533, "deletions": 587, "changes": 1120, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -9,171 +9,142 @@\n // except according to those terms.\n \n /*!\n- *\n- * A `Datum` contains all the information you need to describe the LLVM\n- * translation of a Rust value.  It describes where the value is stored,\n- * what Rust type the value has, whether it is addressed by reference,\n- * and so forth.\n- *\n- * The idea of a datum is that, to the extent possible, you should not\n- * care about these details, but rather use the methods on the Datum\n- * type to \"do what you want to do\".  For example, you can simply call\n- * `copy_to()` or `move_to()` to copy or move the value into a new\n- * home.\n- *\n- * # Datum location\n- *\n- * The primary two fields of a datum are the `val` and the `mode`.\n- * The `val` is an LLVM value ref.  It may either *be the value* that\n- * is being tracked, or it may be a *pointer to the value being\n- * tracked*.  This is specified in the `mode` field, which can either\n- * be `ByValue` or `ByRef`, respectively.  The (Rust) type of the\n- * value stored in the datum is indicated in the field `ty`.\n- *\n- * Generally speaking, you probably do not want to access the `val` field\n- * unless you know what mode the value is in.  Instead you should use one\n- * of the following accessors:\n- *\n- * - `to_value_llval()` converts to by-value\n- * - `to_ref_llval()` converts to by-ref, allocating a stack slot if necessary\n- * - `to_appropriate_llval()` converts to by-value if this is an\n- *   immediate type, by-ref otherwise.  This is particularly\n- *   convenient for interfacing with the various code floating around\n- *   that predates datums.\n- *\n- * # Datum cleanup styles\n- *\n- * Each datum carries with it an idea of how its value will be cleaned\n- * up.  This is primarily determined by the mode: a `ByValue` datum\n- * will always be cleaned up by revoking cleanup using\n- * `revoke_clean()`, because there is no other option. By ref datums\n- * can sometimes be cleaned up via `revoke_clean` (in particular,\n- * by-ref datums that originated from rvalues), but sometimes they\n- * must be zeroed. This is indicated by the `DatumCleanup`\n- * parameter. Note that zeroing a by-ref datum *always works* to\n- * cancel the cleanup, but using `revoke_clean` is preferable since\n- * there is no runtime cost. Some older parts of the code (notably\n- * `match_`, at least at the time of this writing) rely on this and\n- * only use zeroing.\n- *\n- * # Copying, moving, and storing\n- *\n- * There are three methods for moving the value into a new\n- * location:\n- *\n- * - `copy_to()` will copy the value into a new location, meaning that\n- *    the value is first mem-copied and then the new location is \"taken\"\n- *    via the take glue, in effect creating a deep clone.\n- *\n- * - `move_to()` will copy the value, meaning that the value is mem-copied\n- *   into its new home and then the cleanup on the this datum is revoked.\n- *   This is a \"shallow\" clone.  After `move_to()`, the current datum\n- *   is invalid and should no longer be used.\n- *\n- * - `store_to()` either performs a copy or a move depending on the\n- *   Rust type of the datum.\n- *\n- * # Scratch datum\n- *\n- * Sometimes you just need some temporary scratch space.  The\n- * `scratch_datum()` function will yield you up a by-ref datum that\n- * points into the stack.  It's your responsibility to ensure that\n- * whatever you put in there gets cleaned up etc.\n- *\n- * # Other actions\n- *\n- * There are various other helper methods on Datum, such as `deref()`,\n- * `get_base_and_len()` and so forth.  These are documented on the\n- * methods themselves.  Most are only suitable for some types of\n- * values. */\n-\n+ * See the section on datums in `doc.rs` for an overview of what\n+ * Datums are and how they are intended to be used.\n+ */\n \n use lib;\n use lib::llvm::ValueRef;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n-use middle::trans::common;\n+use middle::trans::cleanup;\n+use middle::trans::cleanup::CleanupMethods;\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::write_guard;\n use middle::ty;\n-use util::common::indenter;\n-use util::ppaux::ty_to_str;\n+use util::ppaux::{ty_to_str};\n \n-use std::uint;\n use syntax::ast;\n use syntax::codemap::Span;\n \n-#[deriving(Eq)]\n-pub enum CopyAction {\n-    INIT,\n-    DROP_EXISTING\n-}\n-\n+/**\n+ * A `Datum` encapsulates the result of evaluating an expression.  It\n+ * describes where the value is stored, what Rust type the value has,\n+ * whether it is addressed by reference, and so forth. Please refer\n+ * the section on datums in `doc.rs` for more details.\n+ */\n #[deriving(Clone)]\n-pub struct Datum {\n+pub struct Datum<K> {\n     /// The llvm value.  This is either a pointer to the Rust value or\n-    /// the value itself, depending on `mode` below.\n+    /// the value itself, depending on `kind` below.\n     val: ValueRef,\n \n     /// The rust type of the value.\n     ty: ty::t,\n \n     /// Indicates whether this is by-ref or by-value.\n-    mode: DatumMode,\n+    kind: K,\n }\n \n-pub struct DatumBlock<'a> {\n+pub struct DatumBlock<'a, K> {\n     bcx: &'a Block<'a>,\n-    datum: Datum,\n+    datum: Datum<K>,\n+}\n+\n+pub enum Expr {\n+    /// a fresh value that was produced and which has no cleanup yet\n+    /// because it has not yet \"landed\" into its permanent home\n+    RvalueExpr(Rvalue),\n+\n+    /// `val` is a pointer into memory for which a cleanup is scheduled\n+    /// (and thus has type *T). If you move out of an Lvalue, you must\n+    /// zero out the memory (FIXME #5016).\n+    LvalueExpr,\n+}\n+\n+#[deriving(Clone)]\n+pub struct Lvalue;\n+\n+pub struct Rvalue {\n+    mode: RvalueMode\n+}\n+\n+pub fn Rvalue(m: RvalueMode) -> Rvalue {\n+    Rvalue { mode: m }\n }\n \n-#[deriving(Clone, Eq, IterBytes)]\n-pub enum DatumMode {\n-    /// `val` is a pointer to the actual value (and thus has type *T).\n-    /// The argument indicates how to cancel cleanup of this datum if\n-    /// the value is moved elsewhere, which can either be by zeroing\n-    /// the memory or by canceling a registered cleanup.\n-    ByRef(DatumCleanup),\n+// Make Datum linear for more type safety.\n+impl Drop for Rvalue {\n+    fn drop(&mut self) { }\n+}\n+\n+#[deriving(Eq, IterBytes)]\n+pub enum RvalueMode {\n+    /// `val` is a pointer to the actual value (and thus has type *T)\n+    ByRef,\n \n     /// `val` is the actual value (*only used for immediates* like ints, ptrs)\n     ByValue,\n }\n \n-impl DatumMode {\n-    pub fn is_by_ref(&self) -> bool {\n-        match *self { ByRef(_) => true, ByValue => false }\n-    }\n+pub fn Datum<K:KindOps>(val: ValueRef, ty: ty::t, kind: K) -> Datum<K> {\n+    Datum { val: val, ty: ty, kind: kind }\n+}\n \n-    pub fn is_by_value(&self) -> bool {\n-        match *self { ByRef(_) => false, ByValue => true }\n-    }\n+pub fn DatumBlock<'a, K>(bcx: &'a Block<'a>,\n+                         datum: Datum<K>)\n+                         -> DatumBlock<'a, K> {\n+    DatumBlock { bcx: bcx, datum: datum }\n }\n \n-/// See `Datum cleanup styles` section at the head of this module.\n-#[deriving(Clone, Eq, IterBytes)]\n-pub enum DatumCleanup {\n-    RevokeClean,\n-    ZeroMem\n+pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum<Rvalue> {\n+    return Datum(val, ty, Rvalue(ByValue));\n }\n \n-pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n-    return Datum {val: val, ty: ty, mode: ByValue};\n+pub fn immediate_rvalue_bcx<'a>(bcx: &'a Block<'a>,\n+                                val: ValueRef,\n+                                ty: ty::t)\n+                                -> DatumBlock<'a, Rvalue> {\n+    return DatumBlock(bcx, immediate_rvalue(val, ty))\n }\n \n-pub fn immediate_rvalue_bcx<'a>(bcx: &'a Block<'a>, val: ValueRef, ty: ty::t)\n-                            -> DatumBlock<'a> {\n-    DatumBlock {\n-        bcx: bcx,\n-        datum: immediate_rvalue(val, ty),\n-    }\n+\n+pub fn lvalue_scratch_datum<'a, A>(bcx: &'a Block<'a>,\n+                                   ty: ty::t,\n+                                   name: &str,\n+                                   zero: bool,\n+                                   scope: cleanup::ScopeId,\n+                                   arg: A,\n+                                   populate: |A, &'a Block<'a>, ValueRef|\n+                                             -> &'a Block<'a>)\n+                                   -> DatumBlock<'a, Lvalue> {\n+    /*!\n+     * Allocates temporary space on the stack using alloca() and\n+     * returns a by-ref Datum pointing to it. The memory will be\n+     * dropped upon exit from `scope`. The callback `populate` should\n+     * initialize the memory. If `zero` is true, the space will be\n+     * zeroed when it is allocated; this is not necessary unless `bcx`\n+     * does not dominate the end of `scope`.\n+     */\n+\n+    let llty = type_of::type_of(bcx.ccx(), ty);\n+    let scratch = alloca_maybe_zeroed(bcx, llty, name, zero);\n+\n+    // Subtle. Populate the scratch memory *before* scheduling cleanup.\n+    let bcx = populate(arg, bcx, scratch);\n+    bcx.fcx.schedule_drop_mem(scope, scratch, ty);\n+\n+    DatumBlock(bcx, Datum(scratch, ty, Lvalue))\n }\n \n-pub fn scratch_datum(bcx: &Block, ty: ty::t, name: &str, zero: bool)\n-                     -> Datum {\n+pub fn rvalue_scratch_datum(bcx: &Block,\n+                            ty: ty::t,\n+                            name: &str)\n+                            -> Datum<Rvalue> {\n     /*!\n      * Allocates temporary space on the stack using alloca() and\n      * returns a by-ref Datum pointing to it.  If `zero` is true, the\n@@ -185,11 +156,15 @@ pub fn scratch_datum(bcx: &Block, ty: ty::t, name: &str, zero: bool)\n      */\n \n     let llty = type_of::type_of(bcx.ccx(), ty);\n-    let scratch = alloca_maybe_zeroed(bcx, llty, name, zero);\n-    Datum { val: scratch, ty: ty, mode: ByRef(RevokeClean) }\n+    let scratch = alloca_maybe_zeroed(bcx, llty, name, false);\n+    Datum(scratch, ty, Rvalue(ByRef))\n+}\n+\n+pub fn is_by_value_type(ccx: &CrateContext, ty: ty::t) -> bool {\n+    appropriate_rvalue_mode(ccx, ty) == ByValue\n }\n \n-pub fn appropriate_mode(ccx: &CrateContext, ty: ty::t) -> DatumMode {\n+pub fn appropriate_rvalue_mode(ccx: &CrateContext, ty: ty::t) -> RvalueMode {\n     /*!\n      * Indicates the \"appropriate\" mode for this value,\n      * which is either by ref or by value, depending\n@@ -201,505 +176,356 @@ pub fn appropriate_mode(ccx: &CrateContext, ty: ty::t) -> DatumMode {\n     } else if type_is_immediate(ccx, ty) {\n         ByValue\n     } else {\n-        ByRef(RevokeClean)\n+        ByRef\n     }\n }\n \n-impl Datum {\n-    pub fn store_to<'a>(\n-                    &self,\n-                    bcx: &'a Block<'a>,\n-                    action: CopyAction,\n-                    dst: ValueRef)\n-                    -> &'a Block<'a> {\n-        /*!\n-         *\n-         * Stores this value into its final home.  This moves if\n-         * `id` is located in the move table, but copies otherwise.\n-         */\n-\n-        if ty::type_moves_by_default(bcx.tcx(), self.ty) {\n-            self.move_to(bcx, action, dst)\n-        } else {\n-            self.copy_to(bcx, action, dst)\n-        }\n+fn add_rvalue_clean(mode: RvalueMode,\n+                    fcx: &FunctionContext,\n+                    scope: cleanup::ScopeId,\n+                    val: ValueRef,\n+                    ty: ty::t) {\n+    match mode {\n+        ByValue => { fcx.schedule_drop_immediate(scope, val, ty); }\n+        ByRef => { fcx.schedule_drop_mem(scope, val, ty); }\n     }\n+}\n \n-    pub fn store_to_dest<'a>(&self, bcx: &'a Block<'a>, dest: expr::Dest)\n-                         -> &'a Block<'a> {\n-        match dest {\n-            expr::Ignore => {\n-                return bcx;\n-            }\n-            expr::SaveIn(addr) => {\n-                return self.store_to(bcx, INIT, addr);\n-            }\n-        }\n-    }\n+pub trait KindOps {\n \n-    pub fn store_to_datum<'a>(\n-                          &self,\n-                          bcx: &'a Block<'a>,\n-                          action: CopyAction,\n-                          datum: Datum)\n-                          -> &'a Block<'a> {\n-        debug!(\"store_to_datum(self={}, action={:?}, datum={})\",\n-               self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n-        assert!(datum.mode.is_by_ref());\n-        self.store_to(bcx, action, datum.val)\n-    }\n-\n-    pub fn move_to_datum<'a>(\n-                         &self,\n-                         bcx: &'a Block<'a>,\n-                         action: CopyAction,\n-                         datum: Datum)\n-                         -> &'a Block<'a> {\n-        assert!(datum.mode.is_by_ref());\n-        self.move_to(bcx, action, datum.val)\n-    }\n-\n-    pub fn copy_to_datum<'a>(\n-                         &self,\n-                         bcx: &'a Block<'a>,\n-                         action: CopyAction,\n-                         datum: Datum)\n-                         -> &'a Block<'a> {\n-        assert!(datum.mode.is_by_ref());\n-        self.copy_to(bcx, action, datum.val)\n-    }\n-\n-    pub fn copy_to<'a>(\n-                   &self,\n-                   bcx: &'a Block<'a>,\n-                   action: CopyAction,\n-                   dst: ValueRef)\n-                   -> &'a Block<'a> {\n-        /*!\n-         *\n-         * Copies the value into `dst`, which should be a pointer to a\n-         * memory location suitable for `self.ty`.  You PROBABLY want\n-         * `store_to()` instead, which will move if possible but copy if\n-         * neccessary. */\n+    /**\n+     * Take appropriate action after the value in `datum` has been\n+     * stored to a new location.\n+     */\n+    fn post_store<'a>(&self,\n+                      bcx: &'a Block<'a>,\n+                      val: ValueRef,\n+                      ty: ty::t)\n+                      -> &'a Block<'a>;\n+\n+    /**\n+     * True if this mode is a reference mode, meaning that the datum's\n+     * val field is a pointer to the actual value\n+     */\n+    fn is_by_ref(&self) -> bool;\n \n-        let _icx = push_ctxt(\"copy_to\");\n+    /**\n+     * Converts to an Expr kind\n+     */\n+    fn to_expr_kind(self) -> Expr;\n \n-        if ty::type_is_voidish(bcx.tcx(), self.ty) {\n-            return bcx;\n-        }\n+}\n \n-        debug!(\"copy_to(self={}, action={:?}, dst={})\",\n-               self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n-\n-        // Watch out for the case where we are writing the copying the\n-        // value into the same location we read it out from.  We want\n-        // to avoid the case where we drop the existing value, which\n-        // frees it, and then overwrite it with itself (which has been\n-        // freed).\n-        if action == DROP_EXISTING &&\n-            ty::type_needs_drop(bcx.tcx(), self.ty)\n-        {\n-            match self.mode {\n-                ByRef(_) => {\n-                    let cast = PointerCast(bcx, dst, val_ty(self.val));\n-                    let cmp = ICmp(bcx, lib::llvm::IntNE, cast, self.val);\n-                    with_cond(bcx, cmp, |bcx| {\n-                        self.copy_to_no_check(bcx, action, dst)\n-                    })\n-                }\n-                ByValue => {\n-                    self.copy_to_no_check(bcx, action, dst)\n-                }\n-            }\n-        } else {\n-            self.copy_to_no_check(bcx, action, dst)\n-        }\n+impl KindOps for Rvalue {\n+    fn post_store<'a>(&self,\n+                      bcx: &'a Block<'a>,\n+                      _val: ValueRef,\n+                      _ty: ty::t)\n+                      -> &'a Block<'a> {\n+        // No cleanup is scheduled for an rvalue, so we don't have\n+        // to do anything after a move to cancel or duplicate it.\n+        bcx\n     }\n \n-    pub fn copy_to_no_check<'a>(\n-                            &self,\n-                            bcx: &'a Block<'a>,\n-                            action: CopyAction,\n-                            dst: ValueRef)\n-                            -> &'a Block<'a> {\n-        /*!\n-         *\n-         * A helper for `copy_to()` which does not check to see if we\n-         * are copying to/from the same value. */\n+    fn is_by_ref(&self) -> bool {\n+        self.mode == ByRef\n+    }\n \n-        let _icx = push_ctxt(\"copy_to_no_check\");\n-        let mut bcx = bcx;\n+    fn to_expr_kind(self) -> Expr {\n+        RvalueExpr(self)\n+    }\n+}\n \n-        if action == DROP_EXISTING {\n-            bcx = glue::drop_ty(bcx, dst, self.ty);\n-        }\n+impl KindOps for Lvalue {\n+    fn post_store<'a>(&self,\n+                      bcx: &'a Block<'a>,\n+                      val: ValueRef,\n+                      ty: ty::t)\n+                      -> &'a Block<'a> {\n+        /*!\n+         * If an lvalue is moved, we must zero out the memory in which\n+         * it resides so as to cancel cleanup. If an @T lvalue is\n+         * copied, we must increment the reference count.\n+         */\n \n-        match self.mode {\n-            ByValue => {\n-                Store(bcx, self.val, dst);\n-            }\n-            ByRef(_) => {\n-                memcpy_ty(bcx, dst, self.val, self.ty);\n+        if ty::type_needs_drop(bcx.tcx(), ty) {\n+            if ty::type_moves_by_default(bcx.tcx(), ty) {\n+                // cancel cleanup of affine values by zeroing out\n+                let () = zero_mem(bcx, val, ty);\n+                bcx\n+            } else {\n+                // incr. refcount for @T or newtype'd @T\n+                glue::take_ty(bcx, val, ty)\n             }\n+        } else {\n+            bcx\n         }\n-\n-        return glue::take_ty(bcx, dst, self.ty);\n     }\n \n-    // This works like copy_val, except that it deinitializes the source.\n-    // Since it needs to zero out the source, src also needs to be an lval.\n-    //\n-    pub fn move_to<'a>(\n-                   &self,\n-                   bcx: &'a Block<'a>,\n-                   action: CopyAction,\n-                   dst: ValueRef)\n-                   -> &'a Block<'a> {\n-        let _icx = push_ctxt(\"move_to\");\n-        let mut bcx = bcx;\n+    fn is_by_ref(&self) -> bool {\n+        true\n+    }\n \n-        debug!(\"move_to(self={}, action={:?}, dst={})\",\n-               self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n+    fn to_expr_kind(self) -> Expr {\n+        LvalueExpr\n+    }\n+}\n \n-        if ty::type_is_voidish(bcx.tcx(), self.ty) {\n-            return bcx;\n+impl KindOps for Expr {\n+    fn post_store<'a>(&self,\n+                      bcx: &'a Block<'a>,\n+                      val: ValueRef,\n+                      ty: ty::t)\n+                      -> &'a Block<'a> {\n+        match *self {\n+            LvalueExpr => Lvalue.post_store(bcx, val, ty),\n+            RvalueExpr(ref r) => r.post_store(bcx, val, ty),\n         }\n+    }\n \n-        if action == DROP_EXISTING {\n-            bcx = glue::drop_ty(bcx, dst, self.ty);\n+    fn is_by_ref(&self) -> bool {\n+        match *self {\n+            LvalueExpr => Lvalue.is_by_ref(),\n+            RvalueExpr(ref r) => r.is_by_ref()\n         }\n+    }\n \n-        match self.mode {\n-            ByRef(_) => {\n-                memcpy_ty(bcx, dst, self.val, self.ty);\n-            }\n-            ByValue => {\n-                Store(bcx, self.val, dst);\n-            }\n-        }\n+    fn to_expr_kind(self) -> Expr {\n+        self\n+    }\n+}\n \n-        self.cancel_clean(bcx);\n+impl Datum<Rvalue> {\n+    pub fn add_clean(self,\n+                     fcx: &FunctionContext,\n+                     scope: cleanup::ScopeId)\n+                     -> ValueRef {\n+        /*!\n+         * Schedules a cleanup for this datum in the given scope.\n+         * That means that this datum is no longer an rvalue datum;\n+         * hence, this function consumes the datum and returns the\n+         * contained ValueRef.\n+         */\n \n-        return bcx;\n+        add_rvalue_clean(self.kind.mode, fcx, scope, self.val, self.ty);\n+        self.val\n     }\n \n-    pub fn add_clean(&self, bcx: &Block) {\n+    pub fn to_lvalue_datum_in_scope<'a>(self,\n+                                        bcx: &'a Block<'a>,\n+                                        name: &str,\n+                                        scope: cleanup::ScopeId)\n+                                        -> DatumBlock<'a, Lvalue> {\n         /*!\n-         * Schedules this datum for cleanup in `bcx`.  The datum\n-         * must be an rvalue.\n+         * Returns an lvalue datum (that is, a by ref datum with\n+         * cleanup scheduled). If `self` is not already an lvalue,\n+         * cleanup will be scheduled in the temporary scope for `expr_id`.\n          */\n+        let fcx = bcx.fcx;\n \n-        match self.mode {\n-            ByValue => {\n-                add_clean_temp_immediate(bcx, self.val, self.ty);\n+        match self.kind.mode {\n+            ByRef => {\n+                add_rvalue_clean(ByRef, fcx, scope, self.val, self.ty);\n+                DatumBlock(bcx, Datum(self.val, self.ty, Lvalue))\n             }\n-            ByRef(RevokeClean) => {\n-                add_clean_temp_mem(bcx, self.val, self.ty);\n+\n+            ByValue => {\n+                lvalue_scratch_datum(\n+                    bcx, self.ty, name, false, scope, self,\n+                    |this, bcx, llval| this.store_to(bcx, llval))\n             }\n-            ByRef(ZeroMem) => {\n-                add_clean(bcx, self.val, self.ty)\n+        }\n+    }\n+\n+    pub fn to_ref_datum<'a>(self, bcx: &'a Block<'a>) -> DatumBlock<'a, Rvalue> {\n+        let mut bcx = bcx;\n+        match self.kind.mode {\n+            ByRef => DatumBlock(bcx, self),\n+            ByValue => {\n+                let scratch = rvalue_scratch_datum(bcx, self.ty, \"to_ref\");\n+                bcx = self.store_to(bcx, scratch.val);\n+                DatumBlock(bcx, scratch)\n             }\n         }\n     }\n \n-    pub fn cancel_clean(&self, bcx: &Block) {\n-        if ty::type_needs_drop(bcx.tcx(), self.ty) {\n-            match self.mode {\n-                ByValue |\n-                ByRef(RevokeClean) => {\n-                    revoke_clean(bcx, self.val);\n-                }\n-                ByRef(ZeroMem) => {\n-                    // Lvalues which potentially need to be dropped\n-                    // must be passed by ref, so that we can zero them\n-                    // out.\n-                    zero_mem(bcx, self.val, self.ty);\n+    pub fn to_appropriate_datum<'a>(self,\n+                                    bcx: &'a Block<'a>)\n+                                    -> DatumBlock<'a, Rvalue> {\n+        match self.appropriate_rvalue_mode(bcx.ccx()) {\n+            ByRef => {\n+                self.to_ref_datum(bcx)\n+            }\n+            ByValue => {\n+                match self.kind.mode {\n+                    ByValue => DatumBlock(bcx, self),\n+                    ByRef => {\n+                        let llval = load(bcx, self.val, self.ty);\n+                        DatumBlock(bcx, Datum(llval, self.ty, Rvalue(ByValue)))\n+                    }\n                 }\n             }\n         }\n     }\n+}\n \n-    pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        format!(\"Datum \\\\{ val={}, ty={}, mode={:?} \\\\}\",\n-             ccx.tn.val_to_str(self.val),\n-             ty_to_str(ccx.tcx, self.ty),\n-             self.mode)\n+/**\n+ * Methods suitable for \"expr\" datums that could be either lvalues or\n+ * rvalues. These include coercions into lvalues/rvalues but also a number\n+ * of more general operations. (Some of those operations could be moved to\n+ * the more general `impl<K> Datum<K>`, but it's convenient to have them\n+ * here since we can `match self.kind` rather than having to implement\n+ * generic methods in `KindOps`.)\n+ */\n+impl Datum<Expr> {\n+    fn match_kind<R>(self,\n+                     if_lvalue: |Datum<Lvalue>| -> R,\n+                     if_rvalue: |Datum<Rvalue>| -> R)\n+                     -> R {\n+        let Datum { val, ty, kind } = self;\n+        match kind {\n+            LvalueExpr => if_lvalue(Datum(val, ty, Lvalue)),\n+            RvalueExpr(r) => if_rvalue(Datum(val, ty, r)),\n+        }\n     }\n \n-    pub fn to_value_datum(&self, bcx: &Block) -> Datum {\n-        /*!\n-         *\n-         * Yields a by-value form of this datum.  This may involve\n-         * creation of a temporary stack slot.  The value returned by\n-         * this function is not separately rooted from this datum, so\n-         * it will not live longer than the current datum. */\n-\n-        match self.mode {\n-            ByValue => *self,\n-            ByRef(_) => {\n-                Datum {val: self.to_value_llval(bcx), mode: ByValue,\n-                       ty: self.ty}\n-            }\n-        }\n+    pub fn is_by_ref(&self) -> bool {\n+        self.kind.is_by_ref()\n     }\n \n-    pub fn to_value_llval(&self, bcx: &Block) -> ValueRef {\n+    pub fn assert_lvalue(self, bcx: &Block) -> Datum<Lvalue> {\n         /*!\n-         *\n-         * Yields the value itself. */\n+         * Asserts that this datum *is* an lvalue and returns it.\n+         */\n \n-        if ty::type_is_voidish(bcx.tcx(), self.ty) {\n-            C_nil()\n-        } else {\n-            match self.mode {\n-                ByValue => self.val,\n-                ByRef(_) => {\n-                    if ty::type_is_bool(self.ty) {\n-                        LoadRangeAssert(bcx, self.val, 0, 2, lib::llvm::True)\n-                    } else {\n-                        Load(bcx, self.val)\n-                    }\n-                }\n-            }\n-        }\n+        self.match_kind(\n+            |d| d,\n+            |_| bcx.sess().bug(\"assert_lvalue given rvalue\"))\n     }\n \n-    pub fn to_ref_datum(&self, bcx: &Block) -> Datum {\n+    pub fn assert_rvalue(self, bcx: &Block) -> Datum<Rvalue> {\n         /*!\n-         * Yields a by-ref form of this datum.  This may involve\n-         * creation of a temporary stack slot.  The value returned by\n-         * this function is not separately rooted from this datum, so\n-         * it will not live longer than the current datum.\n+         * Asserts that this datum *is* an lvalue and returns it.\n          */\n \n-        match self.mode {\n-            ByRef(_) => *self,\n-            ByValue => {\n-                Datum {val: self.to_ref_llval(bcx), mode: ByRef(RevokeClean),\n-                       ty: self.ty}\n-            }\n-        }\n+        self.match_kind(\n+            |_| bcx.sess().bug(\"assert_rvalue given lvalue\"),\n+            |r| r)\n     }\n \n-    pub fn to_ref_llval(&self, bcx: &Block) -> ValueRef {\n-        match self.mode {\n-            ByRef(_) => self.val,\n-            ByValue => {\n-                if ty::type_is_voidish(bcx.tcx(), self.ty) {\n-                    C_null(type_of::type_of(bcx.ccx(), self.ty).ptr_to())\n-                } else {\n-                    let slot = alloc_ty(bcx, self.ty, \"\");\n-                    // The store created here can be modified through a reference, for example:\n-                    //\n-                    //     // free the old allocation, and change the pointer to a new allocation\n-                    //     fn foo(x: &mut ~u8) {\n-                    //         *x = ~5;\n-                    //     }\n-                    //\n-                    //     foo(&mut ~5);\n-                    Store(bcx, self.val, slot);\n-                    // The old cleanup needs to be cancelled, in order for the destructor to observe\n-                    // any changes made through the reference.\n-                    self.cancel_clean(bcx);\n-                    add_clean_temp_mem(bcx, slot, self.ty);\n-                    slot\n-                }\n+    pub fn store_to_dest<'a>(self,\n+                             bcx: &'a Block<'a>,\n+                             dest: expr::Dest,\n+                             expr_id: ast::NodeId)\n+                             -> &'a Block<'a> {\n+        match dest {\n+            expr::Ignore => {\n+                self.add_clean_if_rvalue(bcx, expr_id);\n+                bcx\n+            }\n+            expr::SaveIn(addr) => {\n+                self.store_to(bcx, addr)\n             }\n         }\n     }\n \n-    pub fn appropriate_mode(&self, ccx: &CrateContext) -> DatumMode {\n-        /*! See the `appropriate_mode()` function */\n-\n-        appropriate_mode(ccx, self.ty)\n-    }\n-\n-    pub fn to_appropriate_llval(&self, bcx: &Block) -> ValueRef {\n+    pub fn add_clean_if_rvalue<'a>(self,\n+                                   bcx: &'a Block<'a>,\n+                                   expr_id: ast::NodeId) {\n         /*!\n-         *\n-         * Yields an llvalue with the `appropriate_mode()`. */\n+         * Arranges cleanup for `self` if it is an rvalue. Use when\n+         * you are done working with a value that may need drop.\n+         */\n \n-        match self.appropriate_mode(bcx.ccx()) {\n-            ByValue => self.to_value_llval(bcx),\n-            ByRef(_) => self.to_ref_llval(bcx)\n-        }\n+        self.match_kind(\n+            |_| { /* Nothing to do, cleanup already arranged */ },\n+            |r| {\n+                let scope = cleanup::temporary_scope(bcx.tcx(), expr_id);\n+                r.add_clean(bcx.fcx, scope);\n+            })\n     }\n \n-    pub fn to_appropriate_datum(&self, bcx: &Block) -> Datum {\n+    pub fn clean<'a>(self,\n+                     bcx: &'a Block<'a>,\n+                     name: &'static str,\n+                     expr_id: ast::NodeId)\n+                     -> &'a Block<'a> {\n         /*!\n-         *\n-         * Yields a datum with the `appropriate_mode()`. */\n-\n-        match self.appropriate_mode(bcx.ccx()) {\n-            ByValue => self.to_value_datum(bcx),\n-            ByRef(_) => self.to_ref_datum(bcx)\n-        }\n-    }\n+         * Ensures that `self` will get cleaned up, if it is not an lvalue\n+         * already.\n+         */\n \n-    pub fn get_element(&self,\n-                       bcx: &Block,\n-                       ty: ty::t,\n-                       source: DatumCleanup,\n-                       gep: |ValueRef| -> ValueRef)\n-                       -> Datum {\n-        let base_val = self.to_ref_llval(bcx);\n-        Datum {\n-            val: gep(base_val),\n-            mode: ByRef(source),\n-            ty: ty,\n-        }\n+        self.to_lvalue_datum(bcx, name, expr_id).bcx\n     }\n \n-    pub fn drop_val<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n-        if !ty::type_needs_drop(bcx.tcx(), self.ty) {\n-            return bcx;\n-        }\n-\n-        return match self.mode {\n-            ByRef(_) => glue::drop_ty(bcx, self.val, self.ty),\n-            ByValue => glue::drop_ty_immediate(bcx, self.val, self.ty)\n-        };\n+    pub fn to_lvalue_datum<'a>(self,\n+                               bcx: &'a Block<'a>,\n+                               name: &str,\n+                               expr_id: ast::NodeId)\n+                               -> DatumBlock<'a, Lvalue> {\n+        self.match_kind(\n+            |l| DatumBlock(bcx, l),\n+            |r| {\n+                let scope = cleanup::temporary_scope(bcx.tcx(), expr_id);\n+                r.to_lvalue_datum_in_scope(bcx, name, scope)\n+            })\n     }\n \n-    pub fn box_body(&self, bcx: &Block) -> Datum {\n+    pub fn to_rvalue_datum<'a>(self,\n+                               bcx: &'a Block<'a>,\n+                               name: &'static str)\n+                               -> DatumBlock<'a, Rvalue> {\n         /*!\n-         *\n-         * This datum must represent an @T or ~T box.  Returns a new\n-         * by-ref datum of type T, pointing at the contents. */\n-\n-        let (content_ty, header) = match ty::get(self.ty).sty {\n-            ty::ty_box(typ) => (typ, true),\n-            ty::ty_uniq(typ) => (typ, false),\n-            _ => {\n-                bcx.tcx().sess.bug(format!(\n-                    \"box_body() invoked on non-box type {}\",\n-                    ty_to_str(bcx.tcx(), self.ty)));\n-            }\n-        };\n-\n-        if !header {\n-            let ptr = self.to_value_llval(bcx);\n-            let ty = type_of::type_of(bcx.ccx(), content_ty);\n-            let body = PointerCast(bcx, ptr, ty.ptr_to());\n-            Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n-        } else { // has a header\n-            let ptr = self.to_value_llval(bcx);\n-            let body = opaque_box_body(bcx, content_ty, ptr);\n-            Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n-        }\n-    }\n+         * Ensures that we have an rvalue datum (that is, a datum with\n+         * no cleanup scheduled).\n+         */\n \n-    pub fn to_rptr(&self, bcx: &Block) -> Datum {\n-        //! Returns a new datum of region-pointer type containing the\n-        //! the same ptr as this datum (after converting to by-ref\n-        //! using `to_ref_llval()`).\n-\n-        // Convert to ref, yielding lltype *T.  Then create a Rust\n-        // type &'static T (which translates to *T).  Construct new\n-        // result (which will be by-value).  Note that it is not\n-        // significant *which* region we pick here.\n-        let llval = self.to_ref_llval(bcx);\n-        let rptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::ReStatic,\n-                                      self.ty);\n-        Datum {val: llval, ty: rptr_ty, mode: ByValue}\n-    }\n-\n-    /// bcx: Block wherein to generate insns.\n-    /// span: Location where deref occurs.\n-    /// expr_id: ID of deref expr.\n-    /// derefs: Number of times deref'd already.\n-    /// is_auto: If true, only deref if auto-derefable.\n-    pub fn try_deref<'a>(\n-                     &self,\n-                     bcx: &'a Block<'a>,\n-                     span: Span,\n-                     expr_id: ast::NodeId,\n-                     derefs: uint,\n-                     is_auto: bool)\n-                     -> (Option<Datum>, &'a Block<'a>) {\n-        debug!(\"try_deref(expr_id={:?}, derefs={:?}, is_auto={}, self={:?})\",\n-               expr_id, derefs, is_auto, self.to_str(bcx.ccx()));\n-\n-        let bcx =\n-            write_guard::root_and_write_guard(\n-                self, bcx, span, expr_id, derefs);\n-\n-        match ty::get(self.ty).sty {\n-            ty::ty_box(_) | ty::ty_uniq(_) => {\n-                return (Some(self.box_body(bcx)), bcx);\n-            }\n-            ty::ty_ptr(mt) => {\n-                if is_auto { // unsafe ptrs are not AUTO-derefable\n-                    return (None, bcx);\n-                } else {\n-                    return (Some(deref_ptr(bcx, self, mt.ty)), bcx);\n+        let mut bcx = bcx;\n+        self.match_kind(\n+            |l| {\n+                match l.appropriate_rvalue_mode(bcx.ccx()) {\n+                    ByRef => {\n+                        let scratch = rvalue_scratch_datum(bcx, l.ty, name);\n+                        bcx = l.store_to(bcx, scratch.val);\n+                        DatumBlock(bcx, scratch)\n+                    }\n+                    ByValue => {\n+                        let v = load(bcx, l.val, l.ty);\n+                        l.kind.post_store(bcx, l.val, l.ty);\n+                        DatumBlock(bcx, Datum(v, l.ty, Rvalue(ByValue)))\n+                    }\n                 }\n-            }\n-            ty::ty_rptr(_, mt) => {\n-                return (Some(deref_ptr(bcx, self, mt.ty)), bcx);\n-            }\n-            _ => { // not derefable.\n-                return (None, bcx);\n-            }\n-        }\n-\n-        fn deref_ptr(bcx: &Block, lv: &Datum, ty: ty::t) -> Datum {\n-            Datum {\n-                val: lv.to_value_llval(bcx),\n-                ty: ty,\n-                mode: ByRef(ZeroMem)\n-            }\n-        }\n+            },\n+            |r| DatumBlock(bcx, r))\n     }\n \n-    /// expr: The deref expression.\n-    pub fn deref<'a>(\n-                 &self,\n-                 bcx: &'a Block<'a>,\n-                 expr: &ast::Expr,\n-                 derefs: uint)\n-                 -> DatumBlock<'a> {\n-        match self.try_deref(bcx, expr.span, expr.id, derefs, false) {\n-            (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },\n-            (None, _) => {\n-                bcx.ccx().sess.span_bug(expr.span,\n-                                        \"Cannot deref this expression\");\n-            }\n-        }\n+}\n+\n+/**\n+ * Methods suitable only for lvalues. These include the various\n+ * operations to extract components out of compound data structures,\n+ * such as extracting the field from a struct or a particular element\n+ * from an array.\n+ */\n+impl Datum<Lvalue> {\n+    pub fn to_llref(self) -> ValueRef {\n+        /*!\n+         * Converts a datum into a by-ref value. The datum type must\n+         * be one which is always passed by reference.\n+         */\n+\n+        self.val\n     }\n \n-    pub fn autoderef<'a>(\n-                     &self,\n-                     bcx: &'a Block<'a>,\n-                     span: Span,\n-                     expr_id: ast::NodeId,\n-                     max: uint)\n-                     -> DatumBlock<'a> {\n-        let _icx = push_ctxt(\"autoderef\");\n-\n-        debug!(\"autoderef(expr_id={}, max={:?}, self={:?})\",\n-               expr_id, max, self.to_str(bcx.ccx()));\n-        let _indenter = indenter();\n-\n-        let mut datum = *self;\n-        let mut derefs = 0u;\n-        let mut bcx = bcx;\n-        while derefs < max {\n-            derefs += 1u;\n-            match datum.try_deref(bcx, span, expr_id, derefs, true) {\n-                (None, new_bcx) => { bcx = new_bcx; break }\n-                (Some(datum_deref), new_bcx) => {\n-                    datum = datum_deref;\n-                    bcx = new_bcx;\n-                }\n-            }\n+    pub fn get_element(&self,\n+                       ty: ty::t,\n+                       gep: |ValueRef| -> ValueRef)\n+                       -> Datum<Lvalue> {\n+        Datum {\n+            val: gep(self.val),\n+            kind: Lvalue,\n+            ty: ty,\n         }\n-\n-        // either we were asked to deref a specific number of times,\n-        // in which case we should have, or we asked to deref as many\n-        // times as we can\n-        assert!(derefs == max || max == uint::max_value);\n-        DatumBlock { bcx: bcx, datum: datum }\n     }\n \n     pub fn get_vec_base_and_byte_len<'a>(\n@@ -723,17 +549,15 @@ impl Datum {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n \n-        let llval = self.to_appropriate_llval(bcx);\n-        tvec::get_base_and_byte_len(bcx, llval, self.ty)\n+        tvec::get_base_and_byte_len(bcx, self.val, self.ty)\n     }\n \n-    pub fn get_vec_base_and_len<'a>(\n-                                &self,\n-                                mut bcx: &'a Block<'a>,\n-                                span: Span,\n-                                expr_id: ast::NodeId,\n-                                derefs: uint)\n-                                -> (&'a Block<'a>, ValueRef, ValueRef) {\n+    pub fn get_vec_base_and_len<'a>(&self,\n+                                    mut bcx: &'a Block<'a>,\n+                                    span: Span,\n+                                    expr_id: ast::NodeId,\n+                                    derefs: uint)\n+                                    -> (&'a Block<'a>, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n@@ -744,12 +568,118 @@ impl Datum {\n     }\n \n     pub fn get_vec_base_and_len_no_root<'a>(&self, bcx: &'a Block<'a>)\n-                                        -> (ValueRef, ValueRef) {\n+                                            -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n \n-        let llval = self.to_appropriate_llval(bcx);\n-        tvec::get_base_and_len(bcx, llval, self.ty)\n+        tvec::get_base_and_len(bcx, self.val, self.ty)\n+    }\n+}\n+\n+fn load<'a>(bcx: &'a Block<'a>, llptr: ValueRef, ty: ty::t) -> ValueRef {\n+    /*!\n+     * Private helper for loading from a by-ref datum. Handles various\n+     * special cases where the type gives us better information about\n+     * what we are loading.\n+     */\n+\n+    if ty::type_is_voidish(bcx.tcx(), ty) {\n+        C_nil()\n+    } else if ty::type_is_bool(ty) {\n+        LoadRangeAssert(bcx, llptr, 0, 2, lib::llvm::True)\n+    } else {\n+        Load(bcx, llptr)\n+    }\n+}\n+\n+/**\n+ * Generic methods applicable to any sort of datum.\n+ */\n+impl<K:KindOps> Datum<K> {\n+    pub fn to_expr_datum(self) -> Datum<Expr> {\n+        let Datum { val, ty, kind } = self;\n+        Datum { val: val, ty: ty, kind: kind.to_expr_kind() }\n+    }\n+\n+    pub fn store_to<'a>(self,\n+                        bcx: &'a Block<'a>,\n+                        dst: ValueRef)\n+                        -> &'a Block<'a> {\n+        /*!\n+         * Moves or copies this value into a new home, as appropriate\n+         * depending on the type of the datum. This method consumes\n+         * the datum, since it would be incorrect to go on using the\n+         * datum if the value represented is affine (and hence the value\n+         * is moved).\n+         */\n+\n+        self.shallow_copy(bcx, dst);\n+\n+        self.kind.post_store(bcx, self.val, self.ty)\n+    }\n+\n+    fn shallow_copy<'a>(&self,\n+                        bcx: &'a Block<'a>,\n+                        dst: ValueRef)\n+                        -> &'a Block<'a> {\n+        /*!\n+         * Helper function that performs a shallow copy of this value\n+         * into `dst`, which should be a pointer to a memory location\n+         * suitable for `self.ty`. `dst` should contain uninitialized\n+         * memory (either newly allocated, zeroed, or dropped).\n+         *\n+         * This function is private to datums because it leaves memory\n+         * in an unstable state, where the source value has been\n+         * copied but not zeroed. Public methods are `store_to` (if\n+         * you no longer need the source value) or\n+         * `shallow_copy_and_take` (if you wish the source value to\n+         * remain valid).\n+         */\n+\n+        let _icx = push_ctxt(\"copy_to_no_check\");\n+\n+        if ty::type_is_voidish(bcx.tcx(), self.ty) {\n+            return bcx;\n+        }\n+\n+        if self.kind.is_by_ref() {\n+            memcpy_ty(bcx, dst, self.val, self.ty);\n+        } else {\n+            Store(bcx, self.val, dst);\n+        }\n+\n+        return bcx;\n+    }\n+\n+    pub fn shallow_copy_and_take<'a>(&self,\n+                                     bcx: &'a Block<'a>,\n+                                     dst: ValueRef)\n+                                     -> &'a Block<'a> {\n+        /*!\n+         * Copies the value into a new location and runs any necessary\n+         * take glue on the new location. This function always\n+         * preserves the existing datum as a valid value. Therefore,\n+         * it does not consume `self` and, also, cannot be applied to\n+         * affine values (since they must never be duplicated).\n+         */\n+\n+        assert!(!ty::type_moves_by_default(bcx.tcx(), self.ty));\n+        let mut bcx = bcx;\n+        bcx = self.shallow_copy(bcx, dst);\n+        glue::take_ty(bcx, dst, self.ty)\n+    }\n+\n+    pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n+        format!(\"Datum({}, {}, {:?})\",\n+             ccx.tn.val_to_str(self.val),\n+             ty_to_str(ccx.tcx, self.ty),\n+             self.kind)\n+    }\n+\n+    pub fn appropriate_rvalue_mode(&self, ccx: &CrateContext) -> RvalueMode {\n+        /*! See the `appropriate_rvalue_mode()` function */\n+\n+        appropriate_rvalue_mode(ccx, self.ty)\n     }\n \n     pub fn root_and_write_guard<'a>(\n@@ -762,47 +692,58 @@ impl Datum {\n         write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs)\n     }\n \n-    pub fn to_result<'a>(&self, bcx: &'a Block<'a>) -> common::Result<'a> {\n-        rslt(bcx, self.to_appropriate_llval(bcx))\n-    }\n-}\n-\n-impl<'a> DatumBlock<'a> {\n-    pub fn unpack(&self, bcx: &mut &'a Block<'a>) -> Datum {\n-        *bcx = self.bcx;\n-        return self.datum;\n-    }\n+    pub fn to_llscalarish<'a>(self, bcx: &'a Block<'a>) -> ValueRef {\n+        /*!\n+         * Converts `self` into a by-value `ValueRef`. Consumes this\n+         * datum (i.e., absolves you of responsibility to cleanup the\n+         * value). For this to work, the value must be something\n+         * scalar-ish (like an int or a pointer) which (1) does not\n+         * require drop glue and (2) is naturally passed around by\n+         * value, and not by reference.\n+         */\n \n-    pub fn assert_by_ref(&self) -> DatumBlock<'a> {\n-        assert!(self.datum.mode.is_by_ref());\n-        *self\n+        assert!(!ty::type_needs_drop(bcx.tcx(), self.ty));\n+        assert!(self.appropriate_rvalue_mode(bcx.ccx()) == ByValue);\n+        if self.kind.is_by_ref() {\n+            load(bcx, self.val, self.ty)\n+        } else {\n+            self.val\n+        }\n     }\n \n-    pub fn drop_val(&self) -> &'a Block<'a> {\n-        self.datum.drop_val(self.bcx)\n+    pub fn to_llbool<'a>(self, bcx: &'a Block<'a>) -> ValueRef {\n+        assert!(ty::type_is_bool(self.ty) || ty::type_is_bot(self.ty))\n+        let cond_val = self.to_llscalarish(bcx);\n+        bool_to_i1(bcx, cond_val)\n     }\n+}\n \n-    pub fn store_to(&self, action: CopyAction, dst: ValueRef)\n-                    -> &'a Block<'a> {\n-        self.datum.store_to(self.bcx, action, dst)\n+impl<'a, K:KindOps> DatumBlock<'a, K> {\n+    pub fn to_expr_datumblock(self) -> DatumBlock<'a, Expr> {\n+        DatumBlock(self.bcx, self.datum.to_expr_datum())\n     }\n+}\n \n-    pub fn copy_to(&self, action: CopyAction, dst: ValueRef)\n-                   -> &'a Block<'a> {\n-        self.datum.copy_to(self.bcx, action, dst)\n+impl<'a> DatumBlock<'a, Expr> {\n+    pub fn assert_by_ref(self) -> DatumBlock<'a, Expr> {\n+        assert!(self.datum.kind.is_by_ref());\n+        self\n     }\n \n-    pub fn move_to(&self, action: CopyAction, dst: ValueRef)\n-                   -> &'a Block<'a> {\n-        self.datum.move_to(self.bcx, action, dst)\n+    pub fn store_to(self, dst: ValueRef) -> &'a Block<'a> {\n+        let DatumBlock { bcx, datum } = self;\n+        datum.store_to(bcx, dst)\n     }\n \n-    pub fn to_value_llval(&self) -> ValueRef {\n-        self.datum.to_value_llval(self.bcx)\n+    pub fn store_to_dest(self,\n+                         dest: expr::Dest,\n+                         expr_id: ast::NodeId) -> &'a Block<'a> {\n+        let DatumBlock { bcx, datum } = self;\n+        datum.store_to_dest(bcx, dest, expr_id)\n     }\n \n-    pub fn to_result(&self) -> common::Result<'a> {\n-        rslt(self.bcx, self.datum.to_appropriate_llval(self.bcx))\n+    pub fn shallow_copy(self, dst: ValueRef) -> &'a Block<'a> {\n+        self.datum.shallow_copy(self.bcx, dst)\n     }\n \n     pub fn ccx(&self) -> @CrateContext {\n@@ -816,4 +757,9 @@ impl<'a> DatumBlock<'a> {\n     pub fn to_str(&self) -> ~str {\n         self.datum.to_str(self.ccx())\n     }\n+\n+    pub fn to_llbool(self) -> Result<'a> {\n+        let DatumBlock { datum, bcx } = self;\n+        rslt(bcx, datum.to_llbool(bcx))\n+    }\n }"}, {"sha": "88f38d9f4fd75f274199b6a7411471b06b472457", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -133,7 +133,7 @@ use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build;\n use middle::trans::common::*;\n-use middle::trans::datum;\n+use middle::trans::datum::{Datum, Lvalue};\n use middle::trans::machine;\n use middle::trans::type_of;\n use middle::trans::type_::Type;\n@@ -396,7 +396,7 @@ pub fn create_match_binding_metadata(bcx: &Block,\n                                      variable_ident: ast::Ident,\n                                      node_id: ast::NodeId,\n                                      span: Span,\n-                                     datum: datum::Datum) {\n+                                     datum: Datum<Lvalue>) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }"}, {"sha": "c781d1dcbbfe5e032bf27cc9d4cf4aa55884c517", "filename": "src/librustc/middle/trans/doc.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdoc.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -0,0 +1,227 @@\n+/*!\n+\n+# Documentation for the trans module\n+\n+This module contains high-level summaries of how the various modules\n+in trans work. It is a work in progress. For detailed comments,\n+naturally, you can refer to the individual modules themselves.\n+\n+## The Expr module\n+\n+The expr module handles translation of expressions. The most general\n+translation routine is `trans()`, which will translate an expression\n+into a datum. `trans_into()` is also available, which will translate\n+an expression and write the result directly into memory, sometimes\n+avoiding the need for a temporary stack slot. Finally,\n+`trans_to_lvalue()` is available if you'd like to ensure that the\n+result has cleanup scheduled.\n+\n+Internally, each of these functions dispatches to various other\n+expression functions depending on the kind of expression. We divide\n+up expressions into:\n+\n+- **Datum expressions:** Those that most naturally yield values.\n+  Examples would be `22`, `~x`, or `a + b` (when not overloaded).\n+- **DPS expressions:** Those that most naturally write into a location\n+  in memory. Examples would be `foo()` or `Point { x: 3, y: 4 }`.\n+- **Statement expressions:** That that do not generate a meaningful\n+  result. Examples would be `while { ... }` or `return 44`.\n+\n+## The Datum module\n+\n+A `Datum` encapsulates the result of evaluating a Rust expression.  It\n+contains a `ValueRef` indicating the result, a `ty::t` describing the\n+the Rust type, but also a *kind*. The kind indicates whether the datum\n+has cleanup scheduled (lvalue) or not (rvalue) and -- in the case of\n+rvalues -- whether or not the value is \"by ref\" or \"by value\".\n+\n+The datum API is designed to try and help you avoid memory errors like\n+forgetting to arrange cleanup or duplicating a value. The type of the\n+datum incorporates the kind, and thus reflects whether it has cleanup\n+scheduled:\n+\n+- `Datum<Lvalue>` -- by ref, cleanup scheduled\n+- `Datum<Rvalue>` -- by value or by ref, no cleanup scheduled\n+- `Datum<Expr>` -- either `Datum<Lvalue>` or `Datum<Rvalue>`\n+\n+Rvalue and expr datums are noncopyable, and most of the methods on\n+datums consume the datum itself (with some notable exceptions). This\n+reflects the fact that datums may represent affine values which ought\n+to be consumed exactly once, and if you were to try to (for example)\n+store an affine value multiple times, you would be duplicating it,\n+which would certainly be a bug.\n+\n+Some of the datum methods, however, are designed to work only on\n+copyable values such as ints or pointers. Those methods may borrow the\n+datum (`&self`) rather than consume it, but they always include\n+assertions on the type of the value represented to check that this\n+makes sense. An example is `shallow_copy_and_take()`, which duplicates\n+a datum value.\n+\n+Translating an expression always yields a `Datum<Expr>` result, but\n+the methods `to_[lr]value_datum()` can be used to coerce a\n+`Datum<Expr>` into a `Datum<Lvalue>` or `Datum<Rvalue>` as\n+needed. Coercing to an lvalue is fairly common, and generally occurs\n+whenever it is necessary to inspect a value and pull out its\n+subcomponents (for example, a match, or indexing expression). Coercing\n+to an rvalue is more unusual; it occurs when moving values from place\n+to place, such as in an assignment expression or parameter passing.\n+\n+### Lvalues in detail\n+\n+An lvalue datum is one for which cleanup has been scheduled. Lvalue\n+datums are always located in memory, and thus the `ValueRef` for an\n+LLVM value is always a pointer to the actual Rust value. This means\n+that if the Datum has a Rust type of `int`, then the LLVM type of the\n+`ValueRef` will be `int*` (pointer to int).\n+\n+Because lvalues already have cleanups scheduled, the memory must be\n+zeroed to prevent the cleanup from taking place (presuming that the\n+Rust type needs drop in the first place, otherwise it doesn't\n+matter). The Datum code automatically performs this zeroing when the\n+value is stored to a new location, for example.\n+\n+Lvalues usually result from evaluating lvalue expressions. For\n+example, evaluating a local variable `x` yields an lvalue, as does a\n+reference to a field like `x.f` or an index `x[i]`.\n+\n+Lvalue datums can also arise by *converting* an rvalue into an lvalue.\n+This is done with the `to_lvalue_datum` method defined on\n+`Datum<Expr>`. Basically this method just schedules cleanup if the\n+datum is an rvalue, possibly storing the value into a stack slot first\n+if needed. Converting rvalues into lvalues occurs in constructs like\n+`&foo()` or `match foo() { ref x => ... }`, where the user is\n+implicitly requesting a temporary.\n+\n+Somewhat surprisingly, not all lvalue expressions yield lvalue datums\n+when trans'd. Ultimately the reason for this is to micro-optimize\n+the resulting LLVM. For example, consider the following code:\n+\n+    fn foo() -> ~int { ... }\n+    let x = *foo();\n+\n+The expression `*foo()` is an lvalue, but if you invoke `expr::trans`,\n+it will return an rvalue datum. See `deref_once` in expr.rs for\n+more details.\n+\n+### Rvalues in detail\n+\n+Rvalues datums are values with no cleanup scheduled. One must be\n+careful with rvalue datums to ensure that cleanup is properly\n+arranged, usually by converting to an lvalue datum or by invoking the\n+`add_clean` method.\n+\n+### Scratch datums\n+\n+Sometimes you need some temporary scratch space.  The functions\n+`[lr]value_scratch_datum()` can be used to get temporary stack\n+space. As their name suggests, they yield lvalues and rvalues\n+respectively. That is, the slot from `lvalue_scratch_datum` will have\n+cleanup arranged, and the slot from `rvalue_scratch_datum` does not.\n+\n+## The Cleanup module\n+\n+The cleanup module tracks what values need to be cleaned up as scopes\n+are exited, either via failure or just normal control flow. The basic\n+idea is that the function context maintains a stack of cleanup scopes\n+that are pushed/popped as we traverse the AST tree. There is typically\n+at least one cleanup scope per AST node; some AST nodes may introduce\n+additional temporary scopes.\n+\n+Cleanup items can be scheduled into any of the scopes on the stack.\n+Typically, when a scope is popped, we will also generate the code for\n+each of its cleanups at that time. This corresponds to a normal exit\n+from a block (for example, an expression completing evaluation\n+successfully without failure). However, it is also possible to pop a\n+block *without* executing its cleanups; this is typically used to\n+guard intermediate values that must be cleaned up on failure, but not\n+if everything goes right. See the section on custom scopes below for\n+more details.\n+\n+Cleanup scopes come in three kinds:\n+- **AST scopes:** each AST node in a function body has a corresponding\n+  AST scope. We push the AST scope when we start generate code for an AST\n+  node and pop it once the AST node has been fully generated.\n+- **Loop scopes:** loops have an additional cleanup scope. Cleanups are\n+  never scheduled into loop scopes; instead, they are used to record the\n+  basic blocks that we should branch to when a `continue` or `break` statement\n+  is encountered.\n+- **Custom scopes:** custom scopes are typically used to ensure cleanup\n+  of intermediate values.\n+\n+### When to schedule cleanup\n+\n+Although the cleanup system is intended to *feel* fairly declarative,\n+it's still important to time calls to `schedule_clean()` correctly.\n+Basically, you should not schedule cleanup for memory until it has\n+been initialized, because if an unwind should occur before the memory\n+is fully initialized, then the cleanup will run and try to free or\n+drop uninitialized memory. If the initialization itself produces\n+byproducts that need to be freed, then you should use temporary custom\n+scopes to ensure that those byproducts will get freed on unwind.  For\n+example, an expression like `~foo()` will first allocate a box in the\n+heap and then call `foo()` -- if `foo()` should fail, this box needs\n+to be *shallowly* freed.\n+\n+### Long-distance jumps\n+\n+In addition to popping a scope, which corresponds to normal control\n+flow exiting the scope, we may also *jump out* of a scope into some\n+earlier scope on the stack. This can occur in response to a `return`,\n+`break`, or `continue` statement, but also in response to failure. In\n+any of these cases, we will generate a series of cleanup blocks for\n+each of the scopes that is exited. So, if the stack contains scopes A\n+... Z, and we break out of a loop whose corresponding cleanup scope is\n+X, we would generate cleanup blocks for the cleanups in X, Y, and Z.\n+After cleanup is done we would branch to the exit point for scope X.\n+But if failure should occur, we would generate cleanups for all the\n+scopes from A to Z and then resume the unwind process afterwards.\n+\n+To avoid generating tons of code, we cache the cleanup blocks that we\n+create for breaks, returns, unwinds, and other jumps. Whenever a new\n+cleanup is scheduled, though, we must clear these cached blocks. A\n+possible improvement would be to keep the cached blocks but simply\n+generate a new block which performs the additional cleanup and then\n+branches to the existing cached blocks.\n+\n+### AST and loop cleanup scopes\n+\n+AST cleanup scopes are pushed when we begin and end processing an AST\n+node. They are used to house cleanups related to rvalue temporary that\n+get referenced (e.g., due to an expression like `&Foo()`). Whenever an\n+AST scope is popped, we always trans all the cleanups, adding the cleanup\n+code after the postdominator of the AST node.\n+\n+AST nodes that represent breakable loops also push a loop scope; the\n+loop scope never has any actual cleanups, it's just used to point to\n+the basic blocks where control should flow after a \"continue\" or\n+\"break\" statement. Popping a loop scope never generates code.\n+\n+### Custom cleanup scopes\n+\n+Custom cleanup scopes are used for a variety of purposes. The most\n+common though is to handle temporary byproducts, where cleanup only\n+needs to occur on failure. The general strategy is to push a custom\n+cleanup scope, schedule *shallow* cleanups into the custom scope, and\n+then pop the custom scope (without transing the cleanups) when\n+execution succeeds normally. This way the cleanups are only trans'd on\n+unwind, and only up until the point where execution succeeded, at\n+which time the complete value should be stored in an lvalue or some\n+other place where normal cleanup applies.\n+\n+To spell it out, here is an example. Imagine an expression `~expr`.\n+We would basically:\n+\n+1. Push a custom cleanup scope C.\n+2. Allocate the `~` box.\n+3. Schedule a shallow free in the scope C.\n+4. Trans `expr` into the box.\n+5. Pop the scope C.\n+6. Return the box as an rvalue.\n+\n+This way, if a failure occurs while transing `expr`, the custom\n+cleanup scope C is pushed and hence the box will be freed. The trans\n+code for `expr` itself is responsible for freeing any other byproducts\n+that may be in play.\n+\n+*/"}, {"sha": "385c0c86ae58f21357351a8da11a3f992ff39073", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 876, "deletions": 771, "changes": 1647, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -9,110 +9,27 @@\n // except according to those terms.\n \n /*!\n-\n-# Translation of expressions.\n-\n-## Recommended entry point\n-\n-If you wish to translate an expression, the preferred way to do\n-so is to use:\n-\n-    expr::trans_into(block, expr, Dest) -> block\n-\n-This will generate code that evaluates `expr`, storing the result into\n-`Dest`, which must either be the special flag ignore (throw the result\n-away) or be a pointer to memory of the same type/size as the\n-expression.  It returns the resulting basic block.  This form will\n-handle all automatic adjustments for you. The value will be moved if\n-its type is linear and copied otherwise.\n-\n-## Translation to a datum\n-\n-In some cases, `trans_into()` is too narrow of an interface.\n-Generally this occurs either when you know that the result value is\n-going to be a scalar, or when you need to evaluate the expression into\n-some memory location so you can go and inspect it (e.g., assignments,\n-`match` expressions, the `&` operator).\n-\n-In such cases, you want the following function:\n-\n-    trans_to_datum(block, expr) -> DatumBlock\n-\n-This function generates code to evaluate the expression and return a\n-`Datum` describing where the result is to be found.  This function\n-tries to return its result in the most efficient way possible, without\n-introducing extra copies or sacrificing information.  Therefore, for\n-lvalue expressions, you always get a by-ref `Datum` in return that\n-points at the memory for this lvalue.  For rvalue expressions, we will\n-return a by-value `Datum` whenever possible, but it is often necessary\n-to allocate a stack slot, store the result of the rvalue in there, and\n-then return a pointer to the slot (see the discussion later on about\n-the different kinds of rvalues).\n-\n-NB: The `trans_to_datum()` function does perform adjustments, but\n-since it returns a pointer to the value \"in place\" it does not handle\n-moves.  If you wish to copy/move the value returned into a new\n-location, you should use the Datum method `store_to()` (move or copy\n-depending on type). You can also use `move_to()` (force move) or\n-`copy_to()` (force copy) for special situations.\n-\n-## Translating local variables\n-\n-`trans_local_var()` can be used to trans a ref to a local variable\n-that is not an expression.  This is needed for captures.\n-\n-## Ownership and cleanups\n-\n-The current system for cleanups associates required cleanups with\n-block contexts.  Block contexts are structured into a tree that\n-resembles the code itself.  Not every block context has cleanups\n-associated with it, only those blocks that have a kind of\n-`block_scope`.  See `common::block_kind` for more details.\n-\n-If you invoke `trans_into()`, no cleanup is scheduled for you.  The\n-value is written into the given destination and is assumed to be owned\n-by that destination.\n-\n-When you invoke `trans_to_datum()` on an rvalue, the resulting\n-datum/value will have an appropriate cleanup scheduled for the\n-innermost cleanup scope.  If you later use `move_to()` or\n-`drop_val()`, this cleanup will be canceled.\n-\n-During the evaluation of an expression, temporary cleanups are created\n-and later canceled.  These represent intermediate or partial results\n-which must be cleaned up in the event of task failure.\n-\n-## Implementation details\n-\n-We divide expressions into three categories, based on how they are most\n-naturally implemented:\n-\n-1. Lvalues\n-2. Datum rvalues\n-3. DPS rvalues\n-4. Statement rvalues\n-\n-Lvalues always refer to user-assignable memory locations.\n-Translating those always results in a by-ref datum; this introduces\n-no inefficiencies into the generated code, because all lvalues are\n-naturally addressable.\n-\n-Datum rvalues are rvalues that always generate datums as a result.\n-These are generally scalar results, such as `a+b` where `a` and `b`\n-are integers.\n-\n-DPS rvalues are rvalues that, when translated, must be given a\n-memory location to write into (or the Ignore flag).  These are\n-generally expressions that produce structural results that are\n-larger than one word (e.g., a struct literal), but also expressions\n-(like `if`) that involve control flow (otherwise we'd have to\n-generate phi nodes).\n-\n-Finally, statement rvalues are rvalues that always produce a nil\n-return type, such as `while` loops or assignments (`a = b`).\n-\n-*/\n-\n+ * # Translation of Expressions\n+ *\n+ * Public entry points:\n+ *\n+ * - `trans_into(bcx, expr, dest) -> bcx`: evaluates an expression,\n+ *   storing the result into `dest`. This is the preferred form, if you\n+ *   can manage it.\n+ *\n+ * - `trans(bcx, expr) -> DatumBlock`: evaluates an expression, yielding\n+ *   `Datum` with the result. You can then store the datum, inspect\n+ *   the value, etc. This may introduce temporaries if the datum is a\n+ *   structural type.\n+ *\n+ * - `trans_to_lvalue(bcx, expr, \"...\") -> DatumBlock`: evaluates an\n+ *   expression and ensures that the result has a cleanup associated with it,\n+ *   creating a temporary stack slot if necessary.\n+ *\n+ * - `trans_local_var -> Datum`: looks up a local variable or upvar.\n+ *\n+ * See doc.rs for more comments.\n+ */\n \n use back::abi;\n use back::link;\n@@ -127,17 +44,21 @@ use middle::trans::base;\n use middle::trans::build::*;\n use middle::trans::callee::DoAutorefArg;\n use middle::trans::callee;\n+use middle::trans::cleanup;\n+use middle::trans::cleanup::CleanupMethods;\n use middle::trans::closure;\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::controlflow;\n use middle::trans::datum::*;\n use middle::trans::debuginfo;\n+use middle::trans::glue;\n use middle::trans::machine;\n use middle::trans::meth;\n use middle::trans::inline;\n use middle::trans::tvec;\n use middle::trans::type_of;\n+use middle::trans::write_guard;\n use middle::ty::struct_fields;\n use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoObject, AutoUnsafe};\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n@@ -175,31 +96,102 @@ impl Dest {\n     }\n }\n \n-pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n-                      -> DatumBlock<'a> {\n-    debug!(\"trans_to_datum(expr={})\", bcx.expr_to_str(expr));\n+pub fn trans_into<'a>(bcx: &'a Block<'a>,\n+                      expr: &ast::Expr,\n+                      dest: Dest)\n+                      -> &'a Block<'a> {\n+    /*!\n+     * This function is equivalent to `trans(bcx, expr).store_to_dest(dest)`\n+     * but it may generate better optimized LLVM code.\n+     */\n+\n+    let mut bcx = bcx;\n+\n+    let is_adjusted = {\n+        let adjustments = bcx.tcx().adjustments.borrow();\n+        adjustments.get().contains_key(&expr.id)\n+    };\n+\n+    if is_adjusted {\n+        // use trans, which may be less efficient but\n+        // which will perform the adjustments:\n+        let datum = unpack_datum!(bcx, trans(bcx, expr));\n+        return datum.store_to_dest(bcx, dest, expr.id)\n+    }\n+\n+    debug!(\"trans_into() expr={}\", expr.repr(bcx.tcx()));\n+    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+\n+    bcx.fcx.push_ast_cleanup_scope(expr.id);\n+\n+    let kind = ty::expr_kind(bcx.tcx(), bcx.ccx().maps.method_map, expr);\n+    bcx = match kind {\n+        ty::LvalueExpr | ty::RvalueDatumExpr => {\n+            trans_unadjusted(bcx, expr).store_to_dest(dest, expr.id)\n+        }\n+        ty::RvalueDpsExpr => {\n+            trans_rvalue_dps_unadjusted(bcx, expr, dest)\n+        }\n+        ty::RvalueStmtExpr => {\n+            trans_rvalue_stmt_unadjusted(bcx, expr)\n+        }\n+    };\n+\n+    bcx.fcx.pop_and_trans_ast_cleanup_scope(bcx, expr.id)\n+}\n+\n+pub fn trans<'a>(bcx: &'a Block<'a>,\n+                 expr: &ast::Expr)\n+                 -> DatumBlock<'a, Expr> {\n+    /*!\n+     * Translates an expression, returning a datum (and new block)\n+     * encapsulating the result. When possible, it is preferred to\n+     * use `trans_into`, as that may avoid creating a temporary on\n+     * the stack.\n+     */\n+\n+    debug!(\"trans(expr={})\", bcx.expr_to_str(expr));\n \n     let mut bcx = bcx;\n-    let mut datum = unpack_datum!(bcx, trans_to_datum_unadjusted(bcx, expr));\n+    let fcx = bcx.fcx;\n+\n+    fcx.push_ast_cleanup_scope(expr.id);\n+    let datum = unpack_datum!(bcx, trans_unadjusted(bcx, expr));\n+    let datum = unpack_datum!(bcx, apply_adjustments(bcx, expr, datum));\n+    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, expr.id);\n+    return DatumBlock(bcx, datum);\n+}\n+\n+fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n+                         expr: &ast::Expr,\n+                         datum: Datum<Expr>)\n+                         -> DatumBlock<'a, Expr> {\n+    /*!\n+     * Helper for trans that apply adjustments from `expr` to `datum`,\n+     * which should be the unadjusted translation of `expr`.\n+     */\n+\n+    let mut bcx = bcx;\n+    let mut datum = datum;\n     let adjustment = {\n         let adjustments = bcx.tcx().adjustments.borrow();\n         match adjustments.get().find_copy(&expr.id) {\n-            None => { return DatumBlock {bcx: bcx, datum: datum}; }\n+            None => {\n+                return DatumBlock(bcx, datum);\n+            }\n             Some(adj) => { adj }\n         }\n     };\n-    debug!(\"unadjusted datum: {}\", datum.to_str(bcx.ccx()));\n+    debug!(\"unadjusted datum for expr {}: {}\",\n+           expr.id, datum.to_str(bcx.ccx()));\n     match *adjustment {\n         AutoAddEnv(..) => {\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n         }\n         AutoDerefRef(ref adj) => {\n             if adj.autoderefs > 0 {\n-                datum =\n-                    unpack_datum!(\n-                        bcx,\n-                        datum.autoderef(bcx, expr.span,\n-                                        expr.id, adj.autoderefs));\n+                datum = unpack_datum!(\n+                    bcx, deref_multiple(bcx, expr, datum, adj.autoderefs));\n             }\n \n             datum = match adj.autoref {\n@@ -208,7 +200,7 @@ pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n                 }\n                 Some(AutoUnsafe(..)) | // region + unsafe ptrs have same repr\n                 Some(AutoPtr(..)) => {\n-                    unpack_datum!(bcx, auto_ref(bcx, datum))\n+                    unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n                 }\n                 Some(AutoBorrowVec(..)) => {\n                     unpack_datum!(bcx, auto_slice(bcx, adj.autoderefs,\n@@ -230,51 +222,75 @@ pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n             };\n         }\n         AutoObject(..) => {\n-\n             let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr);\n-            let scratch = scratch_datum(bcx, adjusted_ty, \"__adjust\", false);\n-\n-            bcx = meth::trans_trait_cast(bcx, expr, expr.id, SaveIn(scratch.val), Some(datum));\n-\n-            datum = scratch.to_appropriate_datum(bcx);\n-            datum.add_clean(bcx);\n+            let scratch = rvalue_scratch_datum(bcx, adjusted_ty, \"__adjust\");\n+            bcx = meth::trans_trait_cast(\n+                bcx, datum, expr.id, SaveIn(scratch.val));\n+            datum = scratch.to_expr_datum();\n         }\n     }\n     debug!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n-    fn auto_ref<'a>(bcx: &'a Block<'a>, datum: Datum) -> DatumBlock<'a> {\n-        DatumBlock {bcx: bcx, datum: datum.to_rptr(bcx)}\n+    fn auto_ref<'a>(bcx: &'a Block<'a>,\n+                    datum: Datum<Expr>,\n+                    expr: &ast::Expr)\n+                    -> DatumBlock<'a, Expr> {\n+        let mut bcx = bcx;\n+\n+        // Ensure cleanup of `datum` if not already scheduled and obtain\n+        // a \"by ref\" pointer.\n+        let lv_datum = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"autoref\", expr.id));\n+\n+        // Compute final type. Note that we are loose with the region and\n+        // mutability, since those things don't matter in trans.\n+        let referent_ty = lv_datum.ty;\n+        let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::ReStatic, referent_ty);\n+\n+        // Get the pointer.\n+        let llref = lv_datum.to_llref();\n+\n+        // Construct the resulting datum, using what was the \"by ref\"\n+        // ValueRef of type `referent_ty` to be the \"by value\" ValueRef\n+        // of type `&referent_ty`.\n+        DatumBlock(bcx, Datum(llref, ptr_ty, RvalueExpr(Rvalue(ByValue))))\n     }\n \n     fn auto_borrow_fn<'a>(\n                       bcx: &'a Block<'a>,\n                       adjusted_ty: ty::t,\n-                      datum: Datum)\n-                      -> DatumBlock<'a> {\n+                      datum: Datum<Expr>)\n+                      -> DatumBlock<'a, Expr> {\n         // Currently, all closure types are represented precisely the\n         // same, so no runtime adjustment is required, but we still\n         // must patchup the type.\n         DatumBlock {bcx: bcx,\n-                    datum: Datum {val: datum.val, ty: adjusted_ty,\n-                                  mode: datum.mode}}\n+                    datum: Datum {val: datum.val,\n+                                  ty: adjusted_ty,\n+                                  kind: datum.kind}}\n     }\n \n     fn auto_slice<'a>(\n                   bcx: &'a Block<'a>,\n                   autoderefs: uint,\n                   expr: &ast::Expr,\n-                  datum: Datum)\n-                  -> DatumBlock<'a> {\n+                  datum: Datum<Expr>)\n+                  -> DatumBlock<'a, Expr> {\n         // This is not the most efficient thing possible; since slices\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n         // code and keep it DRY that accommodates that use case at the\n         // moment.\n \n+        let mut bcx = bcx;\n         let tcx = bcx.tcx();\n         let unit_ty = ty::sequence_element_type(tcx, datum.ty);\n \n+        // Arrange cleanup, if not already done. This is needed in\n+        // case we are auto-slicing an owned vector or some such.\n+        let datum = unpack_datum!(\n+            bcx, datum.to_lvalue_datum(bcx, \"auto_slice\", expr.id));\n+\n         let (bcx, base, len) =\n             datum.get_vec_base_and_len(bcx, expr.span, expr.id, autoderefs+1);\n \n@@ -284,15 +300,16 @@ pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n                                   ty::mt { ty: unit_ty, mutbl: ast::MutImmutable },\n                                   ty::vstore_slice(ty::ReStatic));\n \n-        let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n-\n+        let scratch = rvalue_scratch_datum(bcx, slice_ty, \"__adjust\");\n         Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n-        DatumBlock {bcx: bcx, datum: scratch}\n+        DatumBlock(bcx, scratch.to_expr_datum())\n     }\n \n-    fn add_env<'a>(bcx: &'a Block<'a>, expr: &ast::Expr, datum: Datum)\n-               -> DatumBlock<'a> {\n+    fn add_env<'a>(bcx: &'a Block<'a>,\n+                   expr: &ast::Expr,\n+                   datum: Datum<Expr>)\n+                   -> DatumBlock<'a, Expr> {\n         // This is not the most efficient thing possible; since closures\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -302,31 +319,31 @@ pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n         let tcx = bcx.tcx();\n         let closure_ty = expr_ty_adjusted(bcx, expr);\n         debug!(\"add_env(closure_ty={})\", closure_ty.repr(tcx));\n-        let scratch = scratch_datum(bcx, closure_ty, \"__adjust\", false);\n+        let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n-        assert_eq!(datum.appropriate_mode(bcx.ccx()), ByValue);\n-        Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n+        let llval = datum.to_llscalarish(bcx);\n+        Store(bcx, llval, llfn);\n         let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n         Store(bcx, base::null_env_ptr(bcx.ccx()), llenv);\n-        DatumBlock {bcx: bcx, datum: scratch}\n+        DatumBlock(bcx, scratch.to_expr_datum())\n     }\n \n     fn auto_slice_and_ref<'a>(\n                           bcx: &'a Block<'a>,\n                           autoderefs: uint,\n                           expr: &ast::Expr,\n-                          datum: Datum)\n-                          -> DatumBlock<'a> {\n+                          datum: Datum<Expr>)\n+                          -> DatumBlock<'a, Expr> {\n         let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n-        auto_ref(bcx, datum)\n+        auto_ref(bcx, datum, expr)\n     }\n \n     fn auto_borrow_obj<'a>(\n                        mut bcx: &'a Block<'a>,\n                        autoderefs: uint,\n                        expr: &ast::Expr,\n-                       source_datum: Datum)\n-                       -> DatumBlock<'a> {\n+                       source_datum: Datum<Expr>)\n+                       -> DatumBlock<'a, Expr> {\n         let tcx = bcx.tcx();\n         let target_obj_ty = expr_ty_adjusted(bcx, expr);\n         debug!(\"auto_borrow_obj(target={})\",\n@@ -343,7 +360,8 @@ pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n             }\n         };\n \n-        // check if any borrowing is really needed or we could reuse the source_datum instead\n+        // check if any borrowing is really needed or we could reuse\n+        // the source_datum instead\n         match ty::get(target_obj_ty).sty {\n             ty::ty_trait(_, _, ty::RegionTraitStore(target_scope), target_mutbl, _) => {\n                 if target_mutbl == ast::MutImmutable && target_mutbl == source_mutbl {\n@@ -361,14 +379,16 @@ pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n             _ => {}\n         }\n \n-        let scratch = scratch_datum(bcx, target_obj_ty,\n-                                    \"__auto_borrow_obj\", false);\n+        let scratch = rvalue_scratch_datum(bcx, target_obj_ty,\n+                                           \"__auto_borrow_obj\");\n \n         // Convert a @Object, ~Object, or &Object pair into an &Object pair.\n \n         // Get a pointer to the source object, which is represented as\n         // a (vtable, data) pair.\n-        let source_llval = source_datum.to_ref_llval(bcx);\n+        let source_datum = unpack_datum!(\n+            bcx, source_datum.to_lvalue_datum(bcx, \"auto_borrow_obj\", expr.id));\n+        let source_llval = source_datum.to_llref();\n \n         // Set the vtable field of the new pair\n         let vtable_ptr = GEPi(bcx, source_llval, [0u, abi::trt_field_vtable]);\n@@ -378,172 +398,87 @@ pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n         // Load the data for the source, which is either an @T,\n         // ~T, or &T, depending on source_obj_ty.\n         let source_data_ptr = GEPi(bcx, source_llval, [0u, abi::trt_field_box]);\n-        let source_data = Load(bcx, source_data_ptr); // always a ptr\n         let target_data = match source_store {\n             ty::BoxTraitStore(..) => {\n-                // For deref of @T, create a dummy datum and use the datum's\n-                // deref method. This is more work than just calling GEPi\n-                // ourselves. Note that we don't know the type T, so\n-                // just substitute `i8`-- it doesn't really matter for\n-                // our purposes right now.\n+                // For deref of @T, create a dummy datum and use the\n+                // datum's deref method. This is more work than just\n+                // calling GEPi ourselves, but it ensures that any\n+                // necessary rooting is performed. Note that we don't\n+                // know the type T, so just substitute `i8`-- it\n+                // doesn't really matter for our purposes right now.\n                 let source_ty = ty::mk_box(tcx, ty::mk_i8());\n-                let source_datum =\n-                    Datum {val: source_data,\n-                           ty: source_ty,\n-                           mode: ByValue};\n-                let derefd_datum =\n-                    unpack_datum!(bcx,\n-                                  source_datum.deref(bcx,\n-                                                     expr,\n-                                                     autoderefs));\n-                derefd_datum.to_rptr(bcx).to_value_llval(bcx)\n+                let source_datum = Datum(source_data_ptr, source_ty, LvalueExpr);\n+                let derefd_datum = unpack_datum!(\n+                    bcx, deref_once(bcx, expr, source_datum, autoderefs));\n+                derefd_datum.assert_lvalue(bcx).to_llref()\n             }\n             ty::UniqTraitStore(..) | ty::RegionTraitStore(..) => {\n-                source_data\n+                Load(bcx, source_data_ptr)\n             }\n         };\n         Store(bcx, target_data,\n               GEPi(bcx, scratch.val, [0u, abi::trt_field_box]));\n \n-        DatumBlock { bcx: bcx, datum: scratch }\n+        DatumBlock(bcx, scratch.to_expr_datum())\n     }\n }\n \n-pub fn trans_into<'a>(bcx: &'a Block<'a>, expr: &ast::Expr, dest: Dest)\n-                  -> &'a Block<'a> {\n-    let adjustment_found = {\n-        let adjustments = bcx.tcx().adjustments.borrow();\n-        adjustments.get().contains_key(&expr.id)\n-    };\n-    if adjustment_found {\n-        // use trans_to_datum, which is mildly less efficient but\n-        // which will perform the adjustments:\n-        let datumblock = trans_to_datum(bcx, expr);\n-        return match dest {\n-            Ignore => datumblock.bcx,\n-            SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n-        };\n-    }\n-\n-    trans_into_unadjusted(bcx, expr, dest)\n-}\n-\n-pub fn trans_into_unadjusted<'a>(\n-                             bcx: &'a Block<'a>,\n-                             expr: &ast::Expr,\n-                             dest: Dest)\n-                             -> &'a Block<'a> {\n-    let ty = expr_ty(bcx, expr);\n-\n-    debug!(\"trans_into_unadjusted(expr={}, dest={})\",\n-           bcx.expr_to_str(expr),\n-           dest.to_str(bcx.ccx()));\n-    let _indenter = indenter();\n-\n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n-\n-    let dest = {\n-        if ty::type_is_voidish(bcx.tcx(), ty) {\n-            Ignore\n-        } else {\n-            dest\n-        }\n-    };\n-\n-    let kind = bcx.expr_kind(expr);\n-    debug!(\"expr kind = {:?}\", kind);\n-    return match kind {\n-        ty::LvalueExpr => {\n-            let datumblock = trans_lvalue_unadjusted(bcx, expr);\n-            match dest {\n-                Ignore => datumblock.bcx,\n-                SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n-            }\n-        }\n-        ty::RvalueDatumExpr => {\n-            let datumblock = trans_rvalue_datum_unadjusted(bcx, expr);\n-            match dest {\n-                Ignore => datumblock.drop_val(),\n-\n-                // When processing an rvalue, the value will be newly\n-                // allocated, so we always `move_to` so as not to\n-                // unnecessarily inc ref counts and so forth:\n-                SaveIn(lldest) => datumblock.move_to(INIT, lldest)\n-            }\n-        }\n-        ty::RvalueDpsExpr => {\n-            trans_rvalue_dps_unadjusted(bcx, expr, dest)\n-        }\n-        ty::RvalueStmtExpr => {\n-            trans_rvalue_stmt_unadjusted(bcx, expr)\n-        }\n-    };\n-}\n-\n-fn trans_lvalue<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> DatumBlock<'a> {\n+pub fn trans_to_lvalue<'a>(bcx: &'a Block<'a>,\n+                           expr: &ast::Expr,\n+                           name: &str)\n+                           -> DatumBlock<'a, Lvalue> {\n     /*!\n+     * Translates an expression in \"lvalue\" mode -- meaning that it\n+     * returns a reference to the memory that the expr represents.\n+     *\n+     * If this expression is an rvalue, this implies introducing a\n+     * temporary.  In other words, something like `x().f` is\n+     * translated into roughly the equivalent of\n      *\n-     * Translates an lvalue expression, always yielding a by-ref\n-     * datum.  Generally speaking you should call trans_to_datum()\n-     * instead, but sometimes we call trans_lvalue() directly as a\n-     * means of asserting that a particular expression is an lvalue. */\n+     *   { tmp = x(); tmp.f }\n+     */\n \n-    let adjustment_opt = {\n-        let adjustments = bcx.tcx().adjustments.borrow();\n-        adjustments.get().find_copy(&expr.id)\n-    };\n-    match adjustment_opt {\n-        None => trans_lvalue_unadjusted(bcx, expr),\n-        Some(_) => {\n-            bcx.sess().span_bug(\n-                expr.span,\n-                format!(\"trans_lvalue() called on an expression \\\n-                      with adjustments\"));\n-        }\n-    }\n+    let mut bcx = bcx;\n+    let datum = unpack_datum!(bcx, trans(bcx, expr));\n+    return datum.to_lvalue_datum(bcx, name, expr.id);\n }\n \n-fn trans_to_datum_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n-                             -> DatumBlock<'a> {\n+fn trans_unadjusted<'a>(bcx: &'a Block<'a>,\n+                        expr: &ast::Expr)\n+                        -> DatumBlock<'a, Expr> {\n     /*!\n-     * Translates an expression into a datum.  If this expression\n-     * is an rvalue, this will result in a temporary value being\n-     * created.  If you plan to store the value somewhere else,\n-     * you should prefer `trans_into()` instead.\n+     * A version of `trans` that ignores adjustments. You almost\n+     * certainly do not want to call this directly.\n      */\n \n     let mut bcx = bcx;\n \n-    debug!(\"trans_to_datum_unadjusted(expr={})\", bcx.expr_to_str(expr));\n+    debug!(\"trans_unadjusted(expr={})\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n-    match ty::expr_kind(bcx.tcx(), bcx.ccx().maps.method_map, expr) {\n-        ty::LvalueExpr => {\n-            return trans_lvalue_unadjusted(bcx, expr);\n-        }\n-\n-        ty::RvalueDatumExpr => {\n+    return match ty::expr_kind(bcx.tcx(), bcx.ccx().maps.method_map, expr) {\n+        ty::LvalueExpr | ty::RvalueDatumExpr => {\n             let datum = unpack_datum!(bcx, {\n-                trans_rvalue_datum_unadjusted(bcx, expr)\n+                trans_datum_unadjusted(bcx, expr)\n             });\n-            datum.add_clean(bcx);\n-            return DatumBlock {bcx: bcx, datum: datum};\n+\n+            DatumBlock {bcx: bcx, datum: datum}\n         }\n \n         ty::RvalueStmtExpr => {\n             bcx = trans_rvalue_stmt_unadjusted(bcx, expr);\n-            return nil(bcx, expr_ty(bcx, expr));\n+            nil(bcx, expr_ty(bcx, expr))\n         }\n \n         ty::RvalueDpsExpr => {\n             let ty = expr_ty(bcx, expr);\n             if ty::type_is_voidish(bcx.tcx(), ty) {\n                 bcx = trans_rvalue_dps_unadjusted(bcx, expr, Ignore);\n-                return nil(bcx, ty);\n+                nil(bcx, ty)\n             } else {\n-                let scratch = scratch_datum(bcx, ty, \"\", false);\n+                let scratch = rvalue_scratch_datum(bcx, ty, \"\");\n                 bcx = trans_rvalue_dps_unadjusted(\n                     bcx, expr, SaveIn(scratch.val));\n \n@@ -556,38 +491,55 @@ fn trans_to_datum_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n                 // Still, in practice it seems to increase\n                 // performance, since we have fewer problems with\n                 // morestack churn.\n-                let scratch = scratch.to_appropriate_datum(bcx);\n+                let scratch = unpack_datum!(\n+                    bcx, scratch.to_appropriate_datum(bcx));\n \n-                scratch.add_clean(bcx);\n-                return DatumBlock {bcx: bcx, datum: scratch};\n+                DatumBlock(bcx, scratch.to_expr_datum())\n             }\n         }\n-    }\n+    };\n \n-    fn nil<'a>(bcx: &'a Block<'a>, ty: ty::t) -> DatumBlock<'a> {\n+    fn nil<'a>(bcx: &'a Block<'a>, ty: ty::t) -> DatumBlock<'a, Expr> {\n         let datum = immediate_rvalue(C_nil(), ty);\n-        DatumBlock {\n-            bcx: bcx,\n-            datum: datum,\n-        }\n+        DatumBlock(bcx, datum.to_expr_datum())\n     }\n }\n \n-fn trans_rvalue_datum_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n-                                 -> DatumBlock<'a> {\n-    let _icx = push_ctxt(\"trans_rvalue_datum_unadjusted\");\n+fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n+                              expr: &ast::Expr)\n+                              -> DatumBlock<'a, Expr> {\n+    let mut bcx = bcx;\n+    let fcx = bcx.fcx;\n+    let _icx = push_ctxt(\"trans_datum_unadjusted\");\n \n     match expr.node {\n+        ast::ExprParen(e) => {\n+            trans(bcx, e)\n+        }\n         ast::ExprPath(_) | ast::ExprSelf => {\n-            return trans_def_datum_unadjusted(bcx, expr, bcx.def(expr.id));\n+            trans_def(bcx, expr, bcx.def(expr.id))\n+        }\n+        ast::ExprField(base, ident, _) => {\n+            trans_rec_field(bcx, base, ident)\n+        }\n+        ast::ExprIndex(_, base, idx) => {\n+            trans_index(bcx, expr, base, idx)\n         }\n         ast::ExprVstore(contents, ast::ExprVstoreBox) => {\n-            return tvec::trans_uniq_or_managed_vstore(bcx, heap_managed,\n-                                                      expr, contents);\n+            fcx.push_ast_cleanup_scope(contents.id);\n+            let datum = unpack_datum!(\n+                bcx, tvec::trans_uniq_or_managed_vstore(bcx, heap_managed,\n+                                                        expr, contents));\n+            bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n+            DatumBlock(bcx, datum)\n         }\n         ast::ExprVstore(contents, ast::ExprVstoreUniq) => {\n-            return tvec::trans_uniq_or_managed_vstore(bcx, heap_exchange,\n-                                                      expr, contents);\n+            fcx.push_ast_cleanup_scope(contents.id);\n+            let datum = unpack_datum!(\n+                bcx, tvec::trans_uniq_or_managed_vstore(bcx, heap_exchange,\n+                                                        expr, contents));\n+            bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n+            DatumBlock(bcx, datum)\n         }\n         ast::ExprBox(_, contents) => {\n             // Special case for `~T`. (The other case, for GC, is handled in\n@@ -598,7 +550,7 @@ fn trans_rvalue_datum_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n             return trans_boxed_expr(bcx, box_ty, contents, contents_ty, heap)\n         }\n         ast::ExprLit(lit) => {\n-            return trans_immediate_lit(bcx, expr, *lit);\n+            trans_immediate_lit(bcx, expr, *lit)\n         }\n         ast::ExprBinary(_, op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n@@ -607,22 +559,24 @@ fn trans_rvalue_datum_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n                 assert!(!method_map.get().contains_key(&expr.id));\n             }\n \n-            return trans_binary(bcx, expr, op, lhs, rhs);\n+            trans_binary(bcx, expr, op, lhs, rhs)\n+        }\n+        ast::ExprUnary(_, ast::UnDeref, base) => {\n+            let basedatum = unpack_datum!(bcx, trans(bcx, base));\n+            deref_once(bcx, expr, basedatum, 0)\n         }\n         ast::ExprUnary(_, op, x) => {\n-            return trans_unary_datum(bcx, expr, op, x);\n+            trans_unary_datum(bcx, expr, op, x)\n         }\n         ast::ExprAddrOf(_, x) => {\n-            return trans_addr_of(bcx, expr, x);\n+            trans_addr_of(bcx, expr, x)\n         }\n         ast::ExprCast(val, _) => {\n-            return trans_imm_cast(bcx, val, expr.id);\n-        }\n-        ast::ExprParen(e) => {\n-            return trans_rvalue_datum_unadjusted(bcx, e);\n+            // Datum output mode means this is a scalar cast:\n+            trans_imm_cast(bcx, val, expr.id)\n         }\n         ast::ExprLogLevel => {\n-            return trans_log_level(bcx);\n+            trans_log_level(bcx)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -634,8 +588,152 @@ fn trans_rvalue_datum_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n     }\n }\n \n-fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n-                                -> &'a Block<'a> {\n+fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n+                       base: &ast::Expr,\n+                       field: ast::Ident)\n+                       -> DatumBlock<'a, Expr> {\n+    //! Translates `base.field`.\n+\n+    let mut bcx = bcx;\n+    let _icx = push_ctxt(\"trans_rec_field\");\n+\n+    let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"field\"));\n+    let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n+    with_field_tys(bcx.tcx(), base_datum.ty, None, |discr, field_tys| {\n+            let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n+            let d = base_datum.get_element(\n+                field_tys[ix].mt.ty,\n+                |srcval| adt::trans_field_ptr(bcx, repr, srcval, discr, ix));\n+            DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n+        })\n+}\n+\n+fn trans_index<'a>(bcx: &'a Block<'a>,\n+                   index_expr: &ast::Expr,\n+                   base: &ast::Expr,\n+                   idx: &ast::Expr)\n+                   -> DatumBlock<'a, Expr> {\n+    //! Translates `base[idx]`.\n+\n+    let _icx = push_ctxt(\"trans_index\");\n+    let ccx = bcx.ccx();\n+    let mut bcx = bcx;\n+\n+    let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"index\"));\n+\n+    // Translate index expression and cast to a suitable LLVM integer.\n+    // Rust is less strict than LLVM in this regard.\n+    let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n+    let ix_val = ix_datum.to_llscalarish(bcx);\n+    let ix_size = machine::llbitsize_of_real(bcx.ccx(), val_ty(ix_val));\n+    let int_size = machine::llbitsize_of_real(bcx.ccx(), ccx.int_type);\n+    let ix_val = {\n+        if ix_size < int_size {\n+            if ty::type_is_signed(expr_ty(bcx, idx)) {\n+                SExt(bcx, ix_val, ccx.int_type)\n+            } else { ZExt(bcx, ix_val, ccx.int_type) }\n+        } else if ix_size > int_size {\n+            Trunc(bcx, ix_val, ccx.int_type)\n+        } else {\n+            ix_val\n+        }\n+    };\n+\n+    let vt = tvec::vec_types(bcx, base_datum.ty);\n+    base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n+\n+    let (bcx, base, len) =\n+        base_datum.get_vec_base_and_len(bcx, index_expr.span, index_expr.id, 0);\n+\n+    debug!(\"trans_index: base {}\", bcx.val_to_str(base));\n+    debug!(\"trans_index: len {}\", bcx.val_to_str(len));\n+\n+    let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n+    let expect = ccx.intrinsics.get_copy(&(\"llvm.expect.i1\"));\n+    let expected = Call(bcx, expect, [bounds_check, C_i1(false)], []);\n+    let bcx = with_cond(bcx, expected, |bcx| {\n+            controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)\n+        });\n+    let elt = InBoundsGEP(bcx, base, [ix_val]);\n+    let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n+    DatumBlock(bcx, Datum(elt, vt.unit_ty, LvalueExpr))\n+}\n+\n+fn trans_def<'a>(bcx: &'a Block<'a>,\n+                 ref_expr: &ast::Expr,\n+                 def: ast::Def)\n+                 -> DatumBlock<'a, Expr>\n+{\n+    //! Translates a reference to a path.\n+\n+    let _icx = push_ctxt(\"trans_def_lvalue\");\n+    match def {\n+        ast::DefFn(..) | ast::DefStaticMethod(..) => {\n+            trans_def_fn_unadjusted(bcx, ref_expr, def)\n+        }\n+        ast::DefStatic(did, _) => {\n+            let const_ty = expr_ty(bcx, ref_expr);\n+\n+            fn get_did(ccx: @CrateContext, did: ast::DefId)\n+                       -> ast::DefId {\n+                if did.crate != ast::LOCAL_CRATE {\n+                    inline::maybe_instantiate_inline(ccx, did)\n+                } else {\n+                    did\n+                }\n+            }\n+\n+            fn get_val<'a>(bcx: &'a Block<'a>, did: ast::DefId, const_ty: ty::t)\n+                       -> ValueRef {\n+                // For external constants, we don't inline.\n+                if did.crate == ast::LOCAL_CRATE {\n+                    // The LLVM global has the type of its initializer,\n+                    // which may not be equal to the enum's type for\n+                    // non-C-like enums.\n+                    let val = base::get_item_val(bcx.ccx(), did.node);\n+                    let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n+                    PointerCast(bcx, val, pty)\n+                } else {\n+                    {\n+                        let extern_const_values = bcx.ccx().extern_const_values.borrow();\n+                        match extern_const_values.get().find(&did) {\n+                            None => {}  // Continue.\n+                            Some(llval) => {\n+                                return *llval;\n+                            }\n+                        }\n+                    }\n+\n+                    unsafe {\n+                        let llty = type_of::type_of(bcx.ccx(), const_ty);\n+                        let symbol = csearch::get_symbol(\n+                            bcx.ccx().sess.cstore,\n+                            did);\n+                        let llval = symbol.with_c_str(|buf| {\n+                                llvm::LLVMAddGlobal(bcx.ccx().llmod,\n+                                                    llty.to_ref(),\n+                                                    buf)\n+                            });\n+                        let mut extern_const_values = bcx.ccx().extern_const_values.borrow_mut();\n+                        extern_const_values.get().insert(did, llval);\n+                        llval\n+                    }\n+                }\n+            }\n+\n+            let did = get_did(bcx.ccx(), did);\n+            let val = get_val(bcx, did, const_ty);\n+            DatumBlock(bcx, Datum(val, const_ty, LvalueExpr))\n+        }\n+        _ => {\n+            DatumBlock(bcx, trans_local_var(bcx, def).to_expr_datum())\n+        }\n+    }\n+}\n+\n+fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n+                                    expr: &ast::Expr)\n+                                    -> &'a Block<'a> {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n@@ -644,38 +742,58 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n     }\n \n     match expr.node {\n+        ast::ExprParen(e) => {\n+            trans_into(bcx, e, Ignore)\n+        }\n         ast::ExprBreak(label_opt) => {\n-            return controlflow::trans_break(bcx, label_opt);\n+            controlflow::trans_break(bcx, expr.id, label_opt)\n         }\n         ast::ExprAgain(label_opt) => {\n-            return controlflow::trans_cont(bcx, label_opt);\n+            controlflow::trans_cont(bcx, expr.id, label_opt)\n         }\n         ast::ExprRet(ex) => {\n-            return controlflow::trans_ret(bcx, ex);\n+            controlflow::trans_ret(bcx, ex)\n         }\n         ast::ExprWhile(cond, body) => {\n-            return controlflow::trans_while(bcx, cond, body);\n+            controlflow::trans_while(bcx, expr.id, cond, body)\n         }\n-        ast::ExprLoop(body, opt_label) => {\n-            // FIXME #6993: map can go away when ast.rs is changed\n-            return controlflow::trans_loop(bcx, body, opt_label.map(|x| x.name));\n+        ast::ExprLoop(body, _) => {\n+            controlflow::trans_loop(bcx, expr.id, body)\n         }\n         ast::ExprAssign(dst, src) => {\n-            let src_datum = unpack_datum!(\n-                bcx, trans_to_datum(bcx, src));\n-            let dst_datum = unpack_datum!(\n-                bcx, trans_lvalue(bcx, dst));\n-            return src_datum.store_to_datum(\n-                bcx, DROP_EXISTING, dst_datum);\n+            let src_datum = unpack_datum!(bcx, trans(bcx, src));\n+            let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign\"));\n+\n+            if ty::type_needs_drop(bcx.tcx(), dst_datum.ty) {\n+                // If there are destructors involved, make sure we\n+                // are copying from an rvalue, since that cannot possible\n+                // alias an lvalue. We are concerned about code like:\n+                //\n+                //   a = a\n+                //\n+                // but also\n+                //\n+                //   a = a.b\n+                //\n+                // where e.g. a : Option<Foo> and a.b :\n+                // Option<Foo>. In that case, freeing `a` before the\n+                // assignment may also free `a.b`!\n+                //\n+                // We could avoid this intermediary with some analysis\n+                // to determine whether `dst` may possibly own `src`.\n+                let src_datum = unpack_datum!(\n+                    bcx, src_datum.to_rvalue_datum(bcx, \"ExprAssign\"));\n+                bcx = glue::drop_ty(bcx, dst_datum.val, dst_datum.ty);\n+                src_datum.store_to(bcx, dst_datum.val)\n+            } else {\n+                src_datum.store_to(bcx, dst_datum.val)\n+            }\n         }\n         ast::ExprAssignOp(callee_id, op, dst, src) => {\n-            return trans_assign_op(bcx, expr, callee_id, op, dst, src);\n-        }\n-        ast::ExprParen(a) => {\n-            return trans_rvalue_stmt_unadjusted(bcx, a);\n+            trans_assign_op(bcx, expr, callee_id, op, dst, src)\n         }\n         ast::ExprInlineAsm(ref a) => {\n-            return asm::trans_inline_asm(bcx, a);\n+            asm::trans_inline_asm(bcx, a)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -684,38 +802,34 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n                       fall-through case: {:?}\",\n                      expr.node));\n         }\n-    };\n+    }\n }\n \n-fn trans_rvalue_dps_unadjusted<'a>(\n-                               bcx: &'a Block<'a>,\n-                               expr: &ast::Expr,\n-                               dest: Dest)\n-                               -> &'a Block<'a> {\n+fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n+                                   expr: &ast::Expr,\n+                                   dest: Dest)\n+                                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n+    let mut bcx = bcx;\n     let tcx = bcx.tcx();\n+    let fcx = bcx.fcx;\n \n     match expr.node {\n         ast::ExprParen(e) => {\n-            return trans_rvalue_dps_unadjusted(bcx, e, dest);\n+            return trans_into(bcx, e, dest);\n         }\n         ast::ExprPath(_) | ast::ExprSelf => {\n             return trans_def_dps_unadjusted(bcx, expr,\n                                             bcx.def(expr.id), dest);\n         }\n         ast::ExprIf(cond, thn, els) => {\n-            return controlflow::trans_if(bcx, cond, thn, els, dest);\n+            return controlflow::trans_if(bcx, expr.id, cond, thn, els, dest);\n         }\n         ast::ExprMatch(discr, ref arms) => {\n             return _match::trans_match(bcx, expr, discr, *arms, dest);\n         }\n         ast::ExprBlock(blk) => {\n-            return base::with_scope(bcx,\n-                                    blk.info(),\n-                                    \"block-expr body\",\n-                                    |bcx| {\n-                controlflow::trans_block(bcx, blk, dest)\n-            });\n+            controlflow::trans_block(bcx, blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, base) => {\n             return trans_rec_or_struct(bcx, (*fields), base, expr.span, expr.id, dest);\n@@ -742,7 +856,9 @@ fn trans_rvalue_dps_unadjusted<'a>(\n         }\n         ast::ExprVstore(contents, ast::ExprVstoreSlice) |\n         ast::ExprVstore(contents, ast::ExprVstoreMutSlice) => {\n-            return tvec::trans_slice_vstore(bcx, expr, contents, dest);\n+            fcx.push_ast_cleanup_scope(contents.id);\n+            bcx = tvec::trans_slice_vstore(bcx, expr, contents, dest);\n+            return fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n         }\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n             return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n@@ -803,10 +919,11 @@ fn trans_rvalue_dps_unadjusted<'a>(\n                                        dest);\n         }\n         ast::ExprCast(val, _) => {\n+            // DPS output mode means this is a trait cast:\n             match ty::get(node_id_type(bcx, expr.id)).sty {\n                 ty::ty_trait(..) => {\n-                    return meth::trans_trait_cast(bcx, val, expr.id,\n-                                                  dest, None);\n+                    let datum = unpack_datum!(bcx, trans(bcx, val));\n+                    return meth::trans_trait_cast(bcx, datum, expr.id, dest);\n                 }\n                 _ => {\n                     bcx.tcx().sess.span_bug(expr.span,\n@@ -885,11 +1002,10 @@ fn trans_def_dps_unadjusted<'a>(\n     }\n }\n \n-fn trans_def_datum_unadjusted<'a>(\n-                              bcx: &'a Block<'a>,\n-                              ref_expr: &ast::Expr,\n-                              def: ast::Def)\n-                              -> DatumBlock<'a> {\n+fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n+                               ref_expr: &ast::Expr,\n+                               def: ast::Def) -> DatumBlock<'a, Expr>\n+{\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     let fn_data = match def {\n@@ -905,224 +1021,24 @@ fn trans_def_datum_unadjusted<'a>(\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n-                \"Non-DPS def {:?} referened by {}\",\n-                def, bcx.node_id_to_str(ref_expr.id)));\n+                    \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n+                    def,\n+                    ref_expr.repr(bcx.tcx())));\n         }\n     };\n \n     let fn_ty = expr_ty(bcx, ref_expr);\n-    DatumBlock {\n-        bcx: bcx,\n-        datum: Datum {\n-            val: fn_data.llfn,\n-            ty: fn_ty,\n-            mode: ByValue\n-        }\n-    }\n+    DatumBlock(bcx, Datum(fn_data.llfn, fn_ty, RvalueExpr(Rvalue(ByValue))))\n }\n \n-fn trans_lvalue_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n-                           -> DatumBlock<'a> {\n+pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n+                           def: ast::Def)\n+                           -> Datum<Lvalue> {\n     /*!\n-     *\n-     * Translates an lvalue expression, always yielding a by-ref\n-     * datum.  Does not apply any adjustments. */\n-\n-    let _icx = push_ctxt(\"trans_lval\");\n-    let mut bcx = bcx;\n-\n-    debug!(\"trans_lvalue(expr={})\", bcx.expr_to_str(expr));\n-    let _indenter = indenter();\n-\n-    return match expr.node {\n-        ast::ExprParen(e) => {\n-            trans_lvalue_unadjusted(bcx, e)\n-        }\n-        ast::ExprPath(_) | ast::ExprSelf => {\n-            trans_def_lvalue(bcx, expr, bcx.def(expr.id))\n-        }\n-        ast::ExprField(base, ident, _) => {\n-            trans_rec_field(bcx, base, ident)\n-        }\n-        ast::ExprIndex(_, base, idx) => {\n-            trans_index(bcx, expr, base, idx)\n-        }\n-        ast::ExprUnary(_, ast::UnDeref, base) => {\n-            let basedatum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-            basedatum.deref(bcx, expr, 0)\n-        }\n-        _ => {\n-            bcx.tcx().sess.span_bug(\n-                expr.span,\n-                format!(\"trans_lvalue reached fall-through case: {:?}\",\n-                     expr.node));\n-        }\n-    };\n-\n-    fn trans_rec_field<'a>(\n-                       bcx: &'a Block<'a>,\n-                       base: &ast::Expr,\n-                       field: ast::Ident)\n-                       -> DatumBlock<'a> {\n-        //! Translates `base.field`.\n-\n-        let mut bcx = bcx;\n-        let _icx = push_ctxt(\"trans_rec_field\");\n-\n-        let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-        let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n-        with_field_tys(bcx.tcx(), base_datum.ty, None, |discr, field_tys| {\n-            let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n-            DatumBlock {\n-                datum: base_datum.get_element(bcx,\n-                                              field_tys[ix].mt.ty,\n-                                              ZeroMem,\n-                                              |srcval| {\n-                    adt::trans_field_ptr(bcx, repr, srcval, discr, ix)\n-                }),\n-                bcx: bcx\n-            }\n-        })\n-    }\n-\n-    fn trans_index<'a>(\n-                   bcx: &'a Block<'a>,\n-                   index_expr: &ast::Expr,\n-                   base: &ast::Expr,\n-                   idx: &ast::Expr)\n-                   -> DatumBlock<'a> {\n-        //! Translates `base[idx]`.\n-\n-        let _icx = push_ctxt(\"trans_index\");\n-        let ccx = bcx.ccx();\n-        let mut bcx = bcx;\n-\n-        let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-\n-        // Translate index expression and cast to a suitable LLVM integer.\n-        // Rust is less strict than LLVM in this regard.\n-        let Result {bcx, val: ix_val} = trans_to_datum(bcx, idx).to_result();\n-        let ix_size = machine::llbitsize_of_real(bcx.ccx(), val_ty(ix_val));\n-        let int_size = machine::llbitsize_of_real(bcx.ccx(), ccx.int_type);\n-        let ix_val = {\n-            if ix_size < int_size {\n-                if ty::type_is_signed(expr_ty(bcx, idx)) {\n-                    SExt(bcx, ix_val, ccx.int_type)\n-                } else { ZExt(bcx, ix_val, ccx.int_type) }\n-            } else if ix_size > int_size {\n-                Trunc(bcx, ix_val, ccx.int_type)\n-            } else {\n-                ix_val\n-            }\n-        };\n-\n-        let vt = tvec::vec_types(bcx, base_datum.ty);\n-        base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n-\n-        let (bcx, base, len) =\n-            base_datum.get_vec_base_and_len(bcx, index_expr.span, index_expr.id, 0);\n-\n-        debug!(\"trans_index: base {}\", bcx.val_to_str(base));\n-        debug!(\"trans_index: len {}\", bcx.val_to_str(len));\n-\n-        let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n-        let expect = ccx.intrinsics.get_copy(&(\"llvm.expect.i1\"));\n-        let expected = Call(bcx, expect, [bounds_check, C_i1(false)], []);\n-        let bcx = with_cond(bcx, expected, |bcx| {\n-            controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)\n-        });\n-        let elt = InBoundsGEP(bcx, base, [ix_val]);\n-        let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n-        return DatumBlock {\n-            bcx: bcx,\n-            datum: Datum {val: elt,\n-                          ty: vt.unit_ty,\n-                          mode: ByRef(ZeroMem)}\n-        };\n-    }\n-\n-    fn trans_def_lvalue<'a>(\n-                        bcx: &'a Block<'a>,\n-                        ref_expr: &ast::Expr,\n-                        def: ast::Def)\n-                        -> DatumBlock<'a> {\n-        //! Translates a reference to a path.\n-\n-        let _icx = push_ctxt(\"trans_def_lvalue\");\n-        match def {\n-            ast::DefStatic(did, _) => {\n-                let const_ty = expr_ty(bcx, ref_expr);\n-\n-                fn get_did(ccx: @CrateContext, did: ast::DefId)\n-                    -> ast::DefId {\n-                    if did.crate != ast::LOCAL_CRATE {\n-                        inline::maybe_instantiate_inline(ccx, did)\n-                    } else {\n-                        did\n-                    }\n-                }\n-\n-                fn get_val(bcx: &Block, did: ast::DefId, const_ty: ty::t)\n-                           -> ValueRef {\n-                    // For external constants, we don't inline.\n-                    if did.crate == ast::LOCAL_CRATE {\n-                        // The LLVM global has the type of its initializer,\n-                        // which may not be equal to the enum's type for\n-                        // non-C-like enums.\n-                        let val = base::get_item_val(bcx.ccx(), did.node);\n-                        let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n-                        PointerCast(bcx, val, pty)\n-                    } else {\n-                        {\n-                            let extern_const_values = bcx.ccx()\n-                                                         .extern_const_values\n-                                                         .borrow();\n-                            match extern_const_values.get().find(&did) {\n-                                None => {}  // Continue.\n-                                Some(llval) => {\n-                                    return *llval;\n-                                }\n-                            }\n-                        }\n-\n-                        unsafe {\n-                            let llty = type_of::type_of(bcx.ccx(), const_ty);\n-                            let symbol = csearch::get_symbol(\n-                                bcx.ccx().sess.cstore,\n-                                did);\n-                            let llval = symbol.with_c_str(|buf| {\n-                                llvm::LLVMAddGlobal(bcx.ccx().llmod,\n-                                                    llty.to_ref(),\n-                                                    buf)\n-                            });\n-                            let mut extern_const_values =\n-                                bcx.ccx().extern_const_values.borrow_mut();\n-                            extern_const_values.get().insert(did, llval);\n-                            llval\n-                        }\n-                    }\n-                }\n-\n-                let did = get_did(bcx.ccx(), did);\n-                let val = get_val(bcx, did, const_ty);\n-                DatumBlock {\n-                    bcx: bcx,\n-                    datum: Datum {val: val,\n-                                  ty: const_ty,\n-                                  mode: ByRef(ZeroMem)}\n-                }\n-            }\n-            _ => {\n-                DatumBlock {\n-                    bcx: bcx,\n-                    datum: trans_local_var(bcx, def)\n-                }\n-            }\n-        }\n-    }\n-}\n+     * Translates a reference to a local variable or argument.\n+     * This always results in an lvalue datum.\n+     */\n \n-pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     return match def {\n@@ -1131,13 +1047,7 @@ pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n             let local_ty = node_id_type(bcx, nid);\n             let llupvars = bcx.fcx.llupvars.borrow();\n             match llupvars.get().find(&nid) {\n-                Some(&val) => {\n-                    Datum {\n-                        val: val,\n-                        ty: local_ty,\n-                        mode: ByRef(ZeroMem)\n-                    }\n-                }\n+                Some(&val) => Datum(val, local_ty, Lvalue),\n                 None => {\n                     bcx.sess().bug(format!(\n                         \"trans_local_var: no llval for upvar {:?} found\", nid));\n@@ -1173,9 +1083,10 @@ pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n         }\n     };\n \n-    fn take_local(bcx: &Block,\n-                  table: &HashMap<ast::NodeId, Datum>,\n-                  nid: ast::NodeId) -> Datum {\n+    fn take_local<'a>(bcx: &'a Block<'a>,\n+                      table: &HashMap<ast::NodeId, Datum<Lvalue>>,\n+                      nid: ast::NodeId)\n+                      -> Datum<Lvalue> {\n         let datum = match table.find(&nid) {\n             Some(&v) => v,\n             None => {\n@@ -1189,15 +1100,18 @@ pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n     }\n }\n \n-// The optional node ID here is the node ID of the path identifying the enum\n-// variant in use. If none, this cannot possibly an enum variant (so, if it\n-// is and `node_id_opt` is none, this function fails).\n-pub fn with_field_tys<R>(\n-                      tcx: ty::ctxt,\n-                      ty: ty::t,\n-                      node_id_opt: Option<ast::NodeId>,\n-                      op: |ty::Disr, (&[ty::field])| -> R)\n-                      -> R {\n+pub fn with_field_tys<R>(tcx: ty::ctxt,\n+                         ty: ty::t,\n+                         node_id_opt: Option<ast::NodeId>,\n+                         op: |ty::Disr, (&[ty::field])| -> R)\n+                         -> R {\n+    /*!\n+     * Helper for enumerating the field types of structs, enums, or records.\n+     * The optional node ID here is the node ID of the path identifying the enum\n+     * variant in use. If none, this cannot possibly an enum variant (so, if it\n+     * is and `node_id_opt` is none, this function fails).\n+     */\n+\n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_fields(tcx, did, substs))\n@@ -1330,6 +1244,7 @@ fn trans_adt<'a>(\n              dest: Dest)\n              -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_adt\");\n+    let fcx = bcx.fcx;\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n@@ -1344,52 +1259,58 @@ fn trans_adt<'a>(\n         }\n         SaveIn(pos) => pos\n     };\n-    let mut temp_cleanups = ~[];\n+\n+    // This scope holds intermediates that must be cleaned should\n+    // failure occur before the ADT as a whole is ready.\n+    let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n+\n     adt::trans_start_init(bcx, repr, addr, discr);\n+\n     for &(i, e) in fields.iter() {\n         let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n         let e_ty = expr_ty_adjusted(bcx, e);\n         bcx = trans_into(bcx, e, SaveIn(dest));\n-        add_clean_temp_mem(bcx, dest, e_ty);\n-        temp_cleanups.push(dest);\n+        fcx.schedule_drop_mem(cleanup::CustomScope(custom_cleanup_scope),\n+                              dest, e_ty);\n     }\n+\n     for base in optbase.iter() {\n         // FIXME #6573: is it sound to use the destination's repr on the base?\n         // And, would it ever be reasonable to be here with discr != 0?\n-        let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base.expr));\n+        let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base.expr, \"base\"));\n         for &(i, t) in base.fields.iter() {\n-            let datum = base_datum.get_element(bcx, t, ZeroMem, |srcval| {\n-                adt::trans_field_ptr(bcx, repr, srcval, discr, i)\n-            });\n+            let datum = base_datum.get_element(\n+                t,\n+                |srcval| adt::trans_field_ptr(bcx, repr, srcval, discr, i));\n             let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n-            bcx = datum.store_to(bcx, INIT, dest);\n+            bcx = datum.store_to(bcx, dest);\n         }\n     }\n \n-    for cleanup in temp_cleanups.iter() {\n-        revoke_clean(bcx, *cleanup);\n-    }\n+    fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n+\n     return bcx;\n }\n \n \n-fn trans_immediate_lit<'a>(\n-                       bcx: &'a Block<'a>,\n-                       expr: &ast::Expr,\n-                       lit: ast::Lit)\n-                       -> DatumBlock<'a> {\n+fn trans_immediate_lit<'a>(bcx: &'a Block<'a>,\n+                           expr: &ast::Expr,\n+                           lit: ast::Lit)\n+                           -> DatumBlock<'a, Expr> {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n     let ty = expr_ty(bcx, expr);\n-    immediate_rvalue_bcx(bcx, consts::const_lit(bcx.ccx(), expr, lit), ty)\n+    let v = consts::const_lit(bcx.ccx(), expr, lit);\n+    immediate_rvalue_bcx(bcx, v, ty).to_expr_datumblock()\n }\n \n fn trans_unary_datum<'a>(\n                      bcx: &'a Block<'a>,\n                      un_expr: &ast::Expr,\n                      op: ast::UnOp,\n                      sub_expr: &ast::Expr)\n-                     -> DatumBlock<'a> {\n+                     -> DatumBlock<'a, Expr> {\n+    let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n@@ -1406,33 +1327,31 @@ fn trans_unary_datum<'a>(\n \n     return match op {\n         ast::UnNot => {\n-            let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n-\n-            // If this is a boolean type, we must not use the LLVM Not\n-            // instruction, as that is a *bitwise* not and we want *logical*\n-            // not on our 8-bit boolean values.\n-            let llresult = match ty::get(un_ty).sty {\n-                ty::ty_bool => {\n-                    let llcond = ICmp(bcx,\n-                                      lib::llvm::IntEQ,\n-                                      val,\n-                                      C_bool(false));\n-                    Select(bcx, llcond, C_bool(true), C_bool(false))\n-                }\n-                _ => Not(bcx, val)\n+            let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n+            let llresult = if ty::type_is_bool(un_ty) {\n+                let val = datum.to_llscalarish(bcx);\n+                let llcond = ICmp(bcx,\n+                                  lib::llvm::IntEQ,\n+                                  val,\n+                                  C_bool(false));\n+                Select(bcx, llcond, C_bool(true), C_bool(false))\n+            } else {\n+                // Note: `Not` is bitwise, not suitable for logical not.\n+                Not(bcx, datum.to_llscalarish(bcx))\n             };\n-            immediate_rvalue_bcx(bcx, llresult, un_ty)\n+            immediate_rvalue_bcx(bcx, llresult, un_ty).to_expr_datumblock()\n         }\n         ast::UnNeg => {\n-            let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n+            let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n+            let val = datum.to_llscalarish(bcx);\n             let llneg = {\n                 if ty::type_is_fp(un_ty) {\n                     FNeg(bcx, val)\n                 } else {\n                     Neg(bcx, val)\n                 }\n             };\n-            immediate_rvalue_bcx(bcx, llneg, un_ty)\n+            immediate_rvalue_bcx(bcx, llneg, un_ty).to_expr_datumblock()\n         }\n         ast::UnBox => {\n             trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap_managed)\n@@ -1448,50 +1367,49 @@ fn trans_unary_datum<'a>(\n     };\n }\n \n-fn trans_boxed_expr<'a>(\n-                    bcx: &'a Block<'a>,\n-                    box_ty: ty::t,\n-                    contents: &ast::Expr,\n-                    contents_ty: ty::t,\n-                    heap: heap)\n-                    -> DatumBlock<'a> {\n+fn trans_boxed_expr<'a>(bcx: &'a Block<'a>,\n+                        box_ty: ty::t,\n+                        contents: &ast::Expr,\n+                        contents_ty: ty::t,\n+                        heap: heap)\n+                        -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_boxed_expr\");\n+    let fcx = bcx.fcx;\n     if heap == heap_exchange {\n         let llty = type_of::type_of(bcx.ccx(), contents_ty);\n         let size = llsize_of(bcx.ccx(), llty);\n         let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, contents_ty,\n                                                            heap_exchange, size);\n-        add_clean_free(bcx, val, heap_exchange);\n+        let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n+        fcx.schedule_free_value(cleanup::CustomScope(custom_cleanup_scope),\n+                                val, heap_exchange);\n         let bcx = trans_into(bcx, contents, SaveIn(val));\n-        revoke_clean(bcx, val);\n-        return immediate_rvalue_bcx(bcx, val, box_ty);\n+        fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n+        immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n     } else {\n-        let base::MallocResult {\n-            bcx,\n-            smart_ptr: bx,\n-            body\n-        } = base::malloc_general(bcx, contents_ty, heap);\n-        add_clean_free(bcx, bx, heap);\n+        let base::MallocResult { bcx, smart_ptr: bx, body } =\n+            base::malloc_general(bcx, contents_ty, heap);\n+        let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n+        fcx.schedule_free_value(cleanup::CustomScope(custom_cleanup_scope),\n+                                bx, heap);\n         let bcx = trans_into(bcx, contents, SaveIn(body));\n-        revoke_clean(bcx, bx);\n-        return immediate_rvalue_bcx(bcx, bx, box_ty);\n+        fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n+        immediate_rvalue_bcx(bcx, bx, box_ty).to_expr_datumblock()\n     }\n }\n \n-fn trans_addr_of<'a>(\n-                 bcx: &'a Block<'a>,\n-                 expr: &ast::Expr,\n-                 subexpr: &ast::Expr)\n-                 -> DatumBlock<'a> {\n+fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n+                     expr: &ast::Expr,\n+                     subexpr: &ast::Expr)\n+                     -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n-    let sub_datum = unpack_datum!(bcx, trans_to_datum(bcx, subexpr));\n-    let llval = sub_datum.to_ref_llval(bcx);\n-    return immediate_rvalue_bcx(bcx, llval, expr_ty(bcx, expr));\n+    let sub_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, subexpr, \"addr_of\"));\n+    let ty = expr_ty(bcx, expr);\n+    return immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock();\n }\n \n-pub fn trans_gc<'a>(\n-                mut bcx: &'a Block<'a>,\n+fn trans_gc<'a>(mut bcx: &'a Block<'a>,\n                 expr: &ast::Expr,\n                 contents: &ast::Expr,\n                 dest: Dest)\n@@ -1514,13 +1432,12 @@ pub fn trans_gc<'a>(\n     let repr = adt::represent_type(bcx.ccx(), expr_ty);\n     adt::trans_start_init(bcx, repr, addr, 0);\n     let field_dest = adt::trans_field_ptr(bcx, repr, addr, 0, 0);\n-    let contents_datum_block = trans_boxed_expr(bcx,\n-                                                box_ty,\n-                                                contents,\n-                                                contents_ty,\n-                                                heap_managed);\n-    bcx = contents_datum_block.bcx;\n-    bcx = contents_datum_block.datum.move_to(bcx, INIT, field_dest);\n+    let contents_datum = unpack_datum!(bcx, trans_boxed_expr(bcx,\n+                                                             box_ty,\n+                                                             contents,\n+                                                             contents_ty,\n+                                                             heap_managed));\n+    bcx = contents_datum.store_to(bcx, field_dest);\n \n     // Next, wrap it up in the struct.\n     bcx\n@@ -1533,17 +1450,13 @@ fn trans_eager_binop<'a>(\n                      binop_expr: &ast::Expr,\n                      binop_ty: ty::t,\n                      op: ast::BinOp,\n-                     lhs_datum: &Datum,\n-                     rhs_datum: &Datum)\n-                     -> DatumBlock<'a> {\n+                     lhs_t: ty::t,\n+                     lhs: ValueRef,\n+                     rhs_t: ty::t,\n+                     rhs: ValueRef)\n+                     -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_eager_binop\");\n \n-    let lhs = lhs_datum.to_appropriate_llval(bcx);\n-    let lhs_t = lhs_datum.ty;\n-\n-    let rhs = rhs_datum.to_appropriate_llval(bcx);\n-    let rhs_t = rhs_datum.ty;\n-\n     let mut intype = {\n         if ty::type_is_bot(lhs_t) { rhs_t }\n         else { lhs_t }\n@@ -1626,7 +1539,7 @@ fn trans_eager_binop<'a>(\n       }\n     };\n \n-    return immediate_rvalue_bcx(bcx, val, binop_ty);\n+    immediate_rvalue_bcx(bcx, val, binop_ty).to_expr_datumblock()\n }\n \n // refinement types would obviate the need for this\n@@ -1641,45 +1554,39 @@ fn trans_lazy_binop<'a>(\n                     op: lazy_binop_ty,\n                     a: &ast::Expr,\n                     b: &ast::Expr)\n-                    -> DatumBlock<'a> {\n+                    -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n-    let bcx = bcx;\n+    let fcx = bcx.fcx;\n \n-    let Result {bcx: past_lhs, val: lhs} = {\n-        base::with_scope_result(bcx, a.info(), \"lhs\", |bcx| {\n-            trans_to_datum(bcx, a).to_result()\n-        })\n-    };\n+    let DatumBlock {bcx: past_lhs, datum: lhs} = trans(bcx, a);\n+    let lhs = lhs.to_llscalarish(past_lhs);\n \n     if past_lhs.unreachable.get() {\n-        return immediate_rvalue_bcx(past_lhs, lhs, binop_ty);\n+        return immediate_rvalue_bcx(past_lhs, lhs, binop_ty).to_expr_datumblock();\n     }\n \n-    let join = base::sub_block(bcx, \"join\");\n-    let before_rhs = base::sub_block(bcx, \"rhs\");\n+    let join = fcx.new_id_block(\"join\", binop_expr.id);\n+    let before_rhs = fcx.new_id_block(\"before_rhs\", b.id);\n \n     let lhs_i1 = bool_to_i1(past_lhs, lhs);\n     match op {\n       lazy_and => CondBr(past_lhs, lhs_i1, before_rhs.llbb, join.llbb),\n       lazy_or => CondBr(past_lhs, lhs_i1, join.llbb, before_rhs.llbb)\n     }\n \n-    let Result {bcx: past_rhs, val: rhs} = {\n-        base::with_scope_result(before_rhs, b.info(), \"rhs\", |bcx| {\n-            trans_to_datum(bcx, b).to_result()\n-        })\n-    };\n+    let DatumBlock {bcx: past_rhs, datum: rhs} = trans(before_rhs, b);\n+    let rhs = rhs.to_llscalarish(past_rhs);\n \n     if past_rhs.unreachable.get() {\n-        return immediate_rvalue_bcx(join, lhs, binop_ty);\n+        return immediate_rvalue_bcx(join, lhs, binop_ty).to_expr_datumblock();\n     }\n \n     Br(past_rhs, join.llbb);\n     let phi = Phi(join, Type::bool(), [lhs, rhs], [past_lhs.llbb,\n-                                               past_rhs.llbb]);\n+                                                   past_rhs.llbb]);\n \n-    return immediate_rvalue_bcx(join, phi, binop_ty);\n+    return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n }\n \n fn trans_binary<'a>(\n@@ -1688,8 +1595,9 @@ fn trans_binary<'a>(\n                 op: ast::BinOp,\n                 lhs: &ast::Expr,\n                 rhs: &ast::Expr)\n-                -> DatumBlock<'a> {\n+                -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_binary\");\n+    let ccx = bcx.ccx();\n \n     match op {\n         ast::BiAnd => {\n@@ -1700,11 +1608,23 @@ fn trans_binary<'a>(\n         }\n         _ => {\n             let mut bcx = bcx;\n-            let lhs_datum = unpack_datum!(bcx, trans_to_datum(bcx, lhs));\n-            let rhs_datum = unpack_datum!(bcx, trans_to_datum(bcx, rhs));\n+            let lhs_datum = unpack_datum!(bcx, trans(bcx, lhs));\n+            let rhs_datum = unpack_datum!(bcx, trans(bcx, rhs));\n             let binop_ty = expr_ty(bcx, binop_expr);\n+\n+            debug!(\"trans_binary (expr {}): lhs_datum={}\",\n+                   binop_expr.id,\n+                   lhs_datum.to_str(ccx));\n+            let lhs_ty = lhs_datum.ty;\n+            let lhs = lhs_datum.to_llscalarish(bcx);\n+\n+            debug!(\"trans_binary (expr {}): rhs_datum={}\",\n+                   binop_expr.id,\n+                   rhs_datum.to_str(ccx));\n+            let rhs_ty = rhs_datum.ty;\n+            let rhs = rhs_datum.to_llscalarish(bcx);\n             trans_eager_binop(bcx, binop_expr, binop_ty, op,\n-                              &lhs_datum, &rhs_datum)\n+                              lhs_ty, lhs, rhs_ty, rhs)\n         }\n     }\n }\n@@ -1724,14 +1644,15 @@ fn trans_overloaded_op<'a>(\n     };\n     let fty = node_id_type(bcx, callee_id);\n     callee::trans_call_inner(bcx,\n-                             expr.info(),\n+                             Some(expr_info(expr)),\n                              fty,\n                              ret_ty,\n-                             |bcx| {\n+                             |bcx, arg_cleanup_scope| {\n                                 meth::trans_method_callee(bcx,\n                                                           callee_id,\n                                                           rcvr,\n-                                                          origin)\n+                                                          origin,\n+                                                          arg_cleanup_scope)\n                              },\n                              callee::ArgExprs(args),\n                              Some(dest),\n@@ -1799,85 +1720,90 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     }\n }\n \n-fn trans_imm_cast<'a>(bcx: &'a Block<'a>, expr: &ast::Expr, id: ast::NodeId)\n-                  -> DatumBlock<'a> {\n+fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n+                      expr: &ast::Expr,\n+                      id: ast::NodeId)\n+                      -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_cast\");\n+    let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n-    let t_out = node_id_type(bcx, id);\n-\n-    let mut bcx = bcx;\n-    let llexpr = unpack_result!(bcx, trans_to_datum(bcx, expr).to_result());\n-    let ll_t_in = val_ty(llexpr);\n     let t_in = expr_ty(bcx, expr);\n-    let ll_t_out = type_of::type_of(ccx, t_out);\n-\n+    let t_out = node_id_type(bcx, id);\n     let k_in = cast_type_kind(t_in);\n     let k_out = cast_type_kind(t_out);\n     let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n+    let ll_t_in = type_of::type_of(ccx, t_in);\n+    let ll_t_out = type_of::type_of(ccx, t_out);\n \n-    let newval =\n-        match (k_in, k_out) {\n-            (cast_integral, cast_integral) => {\n-                int_cast(bcx, ll_t_out, ll_t_in, llexpr, s_in)\n-            }\n-            (cast_float, cast_float) => {\n-                float_cast(bcx, ll_t_out, ll_t_in, llexpr)\n-            }\n-            (cast_integral, cast_float) => {\n-                if s_in {\n-                    SIToFP(bcx, llexpr, ll_t_out)\n-                } else { UIToFP(bcx, llexpr, ll_t_out) }\n-            }\n-            (cast_float, cast_integral) => {\n-                if ty::type_is_signed(t_out) {\n-                    FPToSI(bcx, llexpr, ll_t_out)\n-                } else { FPToUI(bcx, llexpr, ll_t_out) }\n-            }\n-            (cast_integral, cast_pointer) => {\n-                IntToPtr(bcx, llexpr, ll_t_out)\n-            }\n-            (cast_pointer, cast_integral) => {\n-                PtrToInt(bcx, llexpr, ll_t_out)\n-            }\n-            (cast_pointer, cast_pointer) => {\n-                PointerCast(bcx, llexpr, ll_t_out)\n-            }\n-            (cast_enum, cast_integral) |\n-            (cast_enum, cast_float) => {\n-                let bcx = bcx;\n-                let repr = adt::represent_type(ccx, t_in);\n-                let llexpr_ptr;\n-                if type_is_immediate(ccx, t_in) {\n-                    llexpr_ptr = Alloca(bcx, ll_t_in, \"\");\n-                    Store(bcx, llexpr, llexpr_ptr);\n-                } else {\n-                    llexpr_ptr = llexpr;\n-                }\n-                let lldiscrim_a = adt::trans_get_discr(bcx, repr, llexpr_ptr, Some(Type::i64()));\n-                match k_out {\n-                    cast_integral => int_cast(bcx, ll_t_out,\n-                                              val_ty(lldiscrim_a),\n-                                              lldiscrim_a, true),\n-                    cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n-                    _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n-                                           {} ({:?}) -> {} ({:?})\",\n-                                           t_in.repr(ccx.tcx), k_in,\n-                                           t_out.repr(ccx.tcx), k_out))\n-                }\n+    // Convert the value to be cast into a ValueRef, either by-ref or\n+    // by-value as appropriate given its type:\n+    let datum = unpack_datum!(bcx, trans(bcx, expr));\n+    let newval = match (k_in, k_out) {\n+        (cast_integral, cast_integral) => {\n+            let llexpr = datum.to_llscalarish(bcx);\n+            int_cast(bcx, ll_t_out, ll_t_in, llexpr, s_in)\n+        }\n+        (cast_float, cast_float) => {\n+            let llexpr = datum.to_llscalarish(bcx);\n+            float_cast(bcx, ll_t_out, ll_t_in, llexpr)\n+        }\n+        (cast_integral, cast_float) => {\n+            let llexpr = datum.to_llscalarish(bcx);\n+            if s_in {\n+                SIToFP(bcx, llexpr, ll_t_out)\n+            } else { UIToFP(bcx, llexpr, ll_t_out) }\n+        }\n+        (cast_float, cast_integral) => {\n+            let llexpr = datum.to_llscalarish(bcx);\n+            if ty::type_is_signed(t_out) {\n+                FPToSI(bcx, llexpr, ll_t_out)\n+            } else { FPToUI(bcx, llexpr, ll_t_out) }\n+        }\n+        (cast_integral, cast_pointer) => {\n+            let llexpr = datum.to_llscalarish(bcx);\n+            IntToPtr(bcx, llexpr, ll_t_out)\n+        }\n+        (cast_pointer, cast_integral) => {\n+            let llexpr = datum.to_llscalarish(bcx);\n+            PtrToInt(bcx, llexpr, ll_t_out)\n+        }\n+        (cast_pointer, cast_pointer) => {\n+            let llexpr = datum.to_llscalarish(bcx);\n+            PointerCast(bcx, llexpr, ll_t_out)\n+        }\n+        (cast_enum, cast_integral) |\n+        (cast_enum, cast_float) => {\n+            let mut bcx = bcx;\n+            let repr = adt::represent_type(ccx, t_in);\n+            let datum = unpack_datum!(\n+                bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n+            let llexpr_ptr = datum.to_llref();\n+            let lldiscrim_a =\n+                adt::trans_get_discr(bcx, repr, llexpr_ptr, Some(Type::i64()));\n+            match k_out {\n+                cast_integral => int_cast(bcx, ll_t_out,\n+                                          val_ty(lldiscrim_a),\n+                                          lldiscrim_a, true),\n+                cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n+                _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n+                                          {} ({:?}) -> {} ({:?})\",\n+                                          t_in.repr(ccx.tcx), k_in,\n+                                          t_out.repr(ccx.tcx), k_out))\n             }\n-            _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n-                                   {} ({:?}) -> {} ({:?})\",\n-                                   t_in.repr(ccx.tcx), k_in,\n-                                   t_out.repr(ccx.tcx), k_out))\n-        };\n-    return immediate_rvalue_bcx(bcx, newval, t_out);\n+        }\n+        _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n+                                  {} ({:?}) -> {} ({:?})\",\n+                                  t_in.repr(ccx.tcx), k_in,\n+                                  t_out.repr(ccx.tcx), k_out))\n+    };\n+    return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n \n fn trans_assign_op<'a>(\n                    bcx: &'a Block<'a>,\n                    expr: &ast::Expr,\n-                   callee_id: ast::NodeId,\n+                   _callee_id: ast::NodeId,\n                    op: ast::BinOp,\n                    dst: &ast::Expr,\n                    src: @ast::Expr)\n@@ -1887,40 +1813,32 @@ fn trans_assign_op<'a>(\n \n     debug!(\"trans_assign_op(expr={})\", bcx.expr_to_str(expr));\n \n-    // Evaluate LHS (destination), which should be an lvalue\n-    let dst_datum = unpack_datum!(bcx, trans_lvalue_unadjusted(bcx, dst));\n+    // User-defined operator methods cannot be used with `+=` etc right now\n+    assert!({\n+            let method_map = bcx.ccx().maps.method_map.borrow();\n+            !method_map.get().find(&expr.id).is_some()\n+        });\n \n-    // A user-defined operator method\n-    let found = {\n-        let method_map = bcx.ccx().maps.method_map.borrow();\n-        method_map.get().find(&expr.id).is_some()\n-    };\n-    if found {\n-        // FIXME(#2528) evaluates the receiver twice!!\n-        let scratch = scratch_datum(bcx, dst_datum.ty, \"__assign_op\", false);\n-        let bcx = trans_overloaded_op(bcx,\n-                                      expr,\n-                                      callee_id,\n-                                      dst,\n-                                      ~[src],\n-                                      dst_datum.ty,\n-                                      SaveIn(scratch.val));\n-        return scratch.move_to_datum(bcx, DROP_EXISTING, dst_datum);\n-    }\n+    // Evaluate LHS (destination), which should be an lvalue\n+    let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n+    assert!(!ty::type_needs_drop(bcx.tcx(), dst_datum.ty));\n+    let dst_ty = dst_datum.ty;\n+    let dst = Load(bcx, dst_datum.val);\n \n-    // Evaluate RHS (source)\n-    let src_datum = unpack_datum!(bcx, trans_to_datum(bcx, src));\n+    // Evaluate RHS\n+    let rhs_datum = unpack_datum!(bcx, trans(bcx, src));\n+    let rhs_ty = rhs_datum.ty;\n+    let rhs = rhs_datum.to_llscalarish(bcx);\n \n     // Perform computation and store the result\n-    let result_datum =\n-        unpack_datum!(bcx,\n-                      trans_eager_binop(\n-                          bcx, expr, dst_datum.ty, op,\n-                          &dst_datum, &src_datum));\n-    return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n+    let result_datum = unpack_datum!(\n+        bcx, trans_eager_binop(bcx, expr, dst_datum.ty, op,\n+                               dst_ty, dst, rhs_ty, rhs));\n+    return result_datum.store_to(bcx, dst_datum.val);\n }\n \n-pub fn trans_log_level<'a>(bcx: &'a Block<'a>) -> DatumBlock<'a> {\n+fn trans_log_level<'a>(bcx: &'a Block<'a>)\n+                       -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_log_level\");\n     let ccx = bcx.ccx();\n \n@@ -1974,6 +1892,193 @@ pub fn trans_log_level<'a>(bcx: &'a Block<'a>) -> DatumBlock<'a> {\n         }\n     };\n \n-    return immediate_rvalue_bcx(bcx, Load(bcx, global), ty::mk_u32());\n+    immediate_rvalue_bcx(bcx, Load(bcx, global), ty::mk_u32()).to_expr_datumblock()\n+}\n+\n+fn deref_multiple<'a>(bcx: &'a Block<'a>,\n+                      expr: &ast::Expr,\n+                      datum: Datum<Expr>,\n+                      times: uint)\n+                      -> DatumBlock<'a, Expr> {\n+    let mut bcx = bcx;\n+    let mut datum = datum;\n+    for i in range(1, times+1) {\n+        datum = unpack_datum!(bcx, deref_once(bcx, expr, datum, i));\n+    }\n+    DatumBlock { bcx: bcx, datum: datum }\n+}\n+\n+fn deref_once<'a>(bcx: &'a Block<'a>,\n+                  expr: &ast::Expr,\n+                  datum: Datum<Expr>,\n+                  derefs: uint)\n+                  -> DatumBlock<'a, Expr> {\n+    let ccx = bcx.ccx();\n+    let bcx = write_guard::root_and_write_guard(&datum, bcx, expr.span,\n+                                                expr.id, derefs);\n+\n+    debug!(\"deref_once(expr={}, datum={}, derefs={})\",\n+           expr.repr(bcx.tcx()),\n+           datum.to_str(ccx),\n+           derefs);\n+\n+    let mut bcx = bcx;\n+\n+    let r = match ty::get(datum.ty).sty {\n+        ty::ty_uniq(content_ty) => {\n+            deref_owned_pointer(bcx, expr, datum, content_ty)\n+        }\n+\n+        ty::ty_box(content_ty) => {\n+            let datum = unpack_datum!(\n+                bcx, datum.to_lvalue_datum(bcx, \"deref\", expr.id));\n+            let llptrref = datum.to_llref();\n+            let llptr = Load(bcx, llptrref);\n+            let llbody = GEPi(bcx, llptr, [0u, abi::box_field_body]);\n+            DatumBlock(bcx, Datum(llbody, content_ty, LvalueExpr))\n+        }\n+\n+        ty::ty_ptr(ty::mt { ty: content_ty, .. }) |\n+        ty::ty_rptr(_, ty::mt { ty: content_ty, .. }) => {\n+            assert!(!ty::type_needs_drop(bcx.tcx(), datum.ty));\n+\n+            let ptr = datum.to_llscalarish(bcx);\n+\n+            // Always generate an lvalue datum, even if datum.mode is\n+            // an rvalue.  This is because datum.mode is only an\n+            // rvalue for non-owning pointers like &T or *T, in which\n+            // case cleanup *is* scheduled elsewhere, by the true\n+            // owner (or, in the case of *T, by the user).\n+            DatumBlock(bcx, Datum(ptr, content_ty, LvalueExpr))\n+        }\n+\n+        ty::ty_enum(..) |\n+        ty::ty_struct(..) => {\n+            // Subtle efficiency note: In the case where we have a\n+            // newtype struct where the struct itself does not have a\n+            // dtor, but the contents do, we could avoid forcing the\n+            // data into Lvalue and instead return an Rvalue. But it\n+            // doesn't seem worth the trouble.\n+            let datum = unpack_datum!(bcx, ensure_cleanup(bcx, expr, datum));\n+\n+            // Unlike the pointer case above, we generate an\n+            // rvalue datum if we are given an rvalue. There are\n+            // two reasons that this makes sense here:\n+            //\n+            // 1. dereferencing a struct does not actually perform a\n+            //    pointer load and hence the resulting value is not\n+            //    naturally by reference, as would be required by an\n+            //    lvalue result.\n+            //\n+            // 2. the struct always owns its contents, and hence and does not\n+            //    itself have a dtor (else it would be in lvalue mode).\n+            let repr = adt::represent_type(ccx, datum.ty);\n+            let ty = adt::deref_ty(ccx, repr);\n+            let Datum { val, kind, .. } = datum;\n+            let r = match kind {\n+                LvalueExpr => {\n+                    Datum {\n+                        val: adt::trans_field_ptr(bcx, repr, val, 0, 0),\n+                        ty: ty,\n+                        kind: LvalueExpr\n+                    }\n+                }\n+                RvalueExpr(Rvalue { mode: ByRef }) => {\n+                    Datum {\n+                        val: adt::trans_field_ptr(bcx, repr, val, 0, 0),\n+                        ty: ty,\n+                        kind: RvalueExpr(Rvalue(ByValue))\n+                    }\n+                }\n+                RvalueExpr(Rvalue { mode: ByValue }) => {\n+                    Datum {\n+                        val: ExtractValue(bcx, val, 0),\n+                        ty: ty,\n+                        kind: RvalueExpr(Rvalue(ByValue))\n+                    }\n+                }\n+            };\n+            DatumBlock(bcx, r)\n+        }\n+\n+        _ => {\n+            bcx.tcx().sess.span_bug(\n+                expr.span,\n+                format!(\"deref invoked on expr of illegal type {}\",\n+                        datum.ty.repr(bcx.tcx())));\n+        }\n+    };\n+\n+    debug!(\"deref_once(expr={}, derefs={}, result={})\",\n+           expr.id, derefs, r.datum.to_str(ccx));\n+\n+    return r;\n+\n+    fn ensure_cleanup<'a>(mut bcx: &'a Block<'a>,\n+                          expr: &ast::Expr,\n+                          datum: Datum<Expr>)\n+                          -> DatumBlock<'a, Expr> {\n+        /*!\n+         * If the datum contains data that needs to be dropped,\n+         * convert it to an lvalue, thus ensuring that cleanup\n+         * is scheduled.\n+         */\n+\n+        if ty::type_needs_drop(bcx.tcx(), datum.ty) {\n+            let lv_datum = unpack_datum!(\n+                bcx, datum.to_lvalue_datum(bcx, \"deref\", expr.id));\n+            DatumBlock(bcx, lv_datum.to_expr_datum())\n+        } else {\n+            DatumBlock(bcx, datum)\n+        }\n+    }\n+\n+    fn deref_owned_pointer<'a>(bcx: &'a Block<'a>,\n+                               expr: &ast::Expr,\n+                               datum: Datum<Expr>,\n+                               content_ty: ty::t)\n+                               -> DatumBlock<'a, Expr> {\n+        /*!\n+         * We microoptimize derefs of owned pointers a bit here.\n+         * Basically, the idea is to make the deref of an rvalue\n+         * result in an rvalue. This helps to avoid intermediate stack\n+         * slots in the resulting LLVM. The idea here is that, if the\n+         * `~T` pointer is an rvalue, then we can schedule a *shallow*\n+         * free of the `~T` pointer, and then return a ByRef rvalue\n+         * into the pointer. Because the free is shallow, it is legit\n+         * to return an rvalue, because we know that the contents are\n+         * not yet scheduled to be freed. The language rules ensure that the\n+         * contents will be used (or moved) before the free occurs.\n+         */\n+\n+        match datum.kind {\n+            RvalueExpr(Rvalue { mode: ByRef }) => {\n+                let scope = cleanup::temporary_scope(bcx.tcx(), expr.id);\n+                let ptr = Load(bcx, datum.val);\n+                bcx.fcx.schedule_free_value(scope, ptr, heap_exchange);\n+            }\n+            RvalueExpr(Rvalue { mode: ByValue }) => {\n+                let scope = cleanup::temporary_scope(bcx.tcx(), expr.id);\n+                bcx.fcx.schedule_free_value(scope, datum.val, heap_exchange);\n+            }\n+            LvalueExpr => { }\n+        }\n+\n+        // If we had an rvalue in, we produce an rvalue out.\n+        let (llptr, kind) = match datum.kind {\n+            LvalueExpr => {\n+                (Load(bcx, datum.val), LvalueExpr)\n+            }\n+            RvalueExpr(Rvalue { mode: ByRef }) => {\n+                (Load(bcx, datum.val), RvalueExpr(Rvalue(ByRef)))\n+            }\n+            RvalueExpr(Rvalue { mode: ByValue }) => {\n+                (datum.val, RvalueExpr(Rvalue(ByRef)))\n+            }\n+        };\n+\n+        let datum = Datum { ty: content_ty, val: llptr, kind: kind };\n+        DatumBlock { bcx: bcx, datum: datum }\n+    }\n }\n "}, {"sha": "ea9f608ff5671476eb473361e0f1013b4d9fbe5f", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -290,12 +290,12 @@ pub fn trans_native_call<'a>(\n     // A function pointer is called without the declaration available, so we have to apply\n     // any attributes with ABI implications directly to the call instruction. Right now, the\n     // only attribute we need to worry about is `sret`.\n-    let attrs;\n-    if fn_type.ret_ty.is_indirect() {\n-        attrs = &[(1, StructRetAttribute)];\n+    let sret_attr = [(1, StructRetAttribute)];\n+    let attrs = if fn_type.ret_ty.is_indirect() {\n+        sret_attr.as_slice()\n     } else {\n-        attrs = &[];\n-    }\n+        &[]\n+    };\n     let llforeign_retval = CallWithConv(bcx, llfn, llargs_foreign, cc, attrs);\n \n     // If the function we just called does not use an outpointer,\n@@ -491,7 +491,6 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                        None,\n                        None,\n                        id,\n-                       None,\n                        []);\n         return llfndecl;\n     }"}, {"sha": "ae03d48dbf0dc3d0d86e2ea5b97b150756a63af4", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -21,9 +21,10 @@ use middle::lang_items::{FreeFnLangItem, ExchangeFreeFnLangItem};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::callee;\n+use middle::trans::cleanup;\n+use middle::trans::cleanup::CleanupMethods;\n use middle::trans::closure;\n use middle::trans::common::*;\n-use middle::trans::datum::immediate_rvalue;\n use middle::trans::build::*;\n use middle::trans::expr;\n use middle::trans::machine::*;\n@@ -269,25 +270,23 @@ fn call_tydesc_glue<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t, field: uint)\n fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n                    -> &'a Block<'a> {\n     let _icx = push_ctxt(\"make_visit_glue\");\n-    with_scope(bcx, None, \"visitor cleanup\", |bcx| {\n-        let mut bcx = bcx;\n-        let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n-                                                                     ty::ReStatic) {\n-            Ok(pair) => pair,\n-            Err(s) => {\n-                bcx.tcx().sess.fatal(s);\n-            }\n-        };\n-        let v = PointerCast(bcx, v, type_of(bcx.ccx(), object_ty).ptr_to());\n-        bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n-        // The visitor is a boxed object and needs to be dropped\n-        add_clean(bcx, v, object_ty);\n-        bcx\n-    })\n+    let mut bcx = bcx;\n+    let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n+                                                                 ty::ReStatic) {\n+        Ok(pair) => pair,\n+        Err(s) => {\n+            bcx.tcx().sess.fatal(s);\n+        }\n+    };\n+    let v = PointerCast(bcx, v, type_of(bcx.ccx(), object_ty).ptr_to());\n+    bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n+    bcx\n }\n \n-pub fn make_free_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-                      -> &'a Block<'a> {\n+pub fn make_free_glue<'a>(bcx: &'a Block<'a>,\n+                          v: ValueRef,\n+                          t: ty::t)\n+                          -> &'a Block<'a> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_free_glue\");\n     match ty::get(t).sty {\n@@ -297,14 +296,13 @@ pub fn make_free_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n         let bcx = drop_ty(bcx, body, body_ty);\n         trans_free(bcx, v)\n       }\n-      ty::ty_uniq(..) => {\n-        let box_datum = immediate_rvalue(Load(bcx, v), t);\n-        let not_null = IsNotNull(bcx, box_datum.val);\n+      ty::ty_uniq(content_ty) => {\n+        let llbox = Load(bcx, v);\n+        let not_null = IsNotNull(bcx, llbox);\n         with_cond(bcx, not_null, |bcx| {\n-            let body_datum = box_datum.box_body(bcx);\n-            let bcx = drop_ty(bcx, body_datum.to_ref_llval(bcx), body_datum.ty);\n-            trans_exchange_free(bcx, box_datum.val)\n-        })\n+                    let bcx = drop_ty(bcx, llbox, content_ty);\n+                    trans_exchange_free(bcx, llbox)\n+                })\n       }\n       ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) |\n       ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) => {\n@@ -362,21 +360,24 @@ pub fn trans_struct_drop<'a>(\n     // Be sure to put all of the fields into a scope so we can use an invoke\n     // instruction to call the user destructor but still call the field\n     // destructors if the user destructor fails.\n-    with_scope(bcx, None, \"field drops\", |bcx| {\n-        let self_arg = PointerCast(bcx, v0, params[0]);\n-        let args = ~[self_arg];\n-\n-        // Add all the fields as a value which needs to be cleaned at the end of\n-        // this scope.\n-        let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n-        for (i, fld) in field_tys.iter().enumerate() {\n-            let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n-            add_clean(bcx, llfld_a, fld.mt.ty);\n-        }\n+    let field_scope = bcx.fcx.push_custom_cleanup_scope();\n+\n+    let self_arg = PointerCast(bcx, v0, params[0]);\n+    let args = ~[self_arg];\n+\n+    // Add all the fields as a value which needs to be cleaned at the end of\n+    // this scope.\n+    let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n+    for (i, fld) in field_tys.iter().enumerate() {\n+        let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n+        bcx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope),\n+                                  llfld_a,\n+                                  fld.mt.ty);\n+    }\n \n-        let (_, bcx) = invoke(bcx, dtor_addr, args, [], None);\n-        bcx\n-    })\n+    let (_, bcx) = invoke(bcx, dtor_addr, args, [], None);\n+\n+    bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, field_scope)\n }\n \n pub fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t)\n@@ -451,11 +452,13 @@ pub fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t)\n fn decr_refcnt_maybe_free<'a>(bcx: &'a Block<'a>, box_ptr_ptr: ValueRef,\n                               t: Option<ty::t>) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n+    let fcx = bcx.fcx;\n     let ccx = bcx.ccx();\n \n-    let decr_bcx = sub_block(bcx, \"decr\");\n-    let free_bcx = sub_block(decr_bcx, \"free\");\n-    let next_bcx = sub_block(bcx, \"next\");\n+    let decr_bcx = fcx.new_temp_block(\"decr\");\n+    let free_bcx = fcx.new_temp_block(\"free\");\n+    let next_bcx = fcx.new_temp_block(\"next\");\n+\n     let box_ptr = Load(bcx, box_ptr_ptr);\n     let llnotnull = IsNotNull(bcx, box_ptr);\n     CondBr(bcx, llnotnull, decr_bcx.llbb, next_bcx.llbb);\n@@ -593,7 +596,7 @@ fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n     let _s = StatRecorder::new(ccx, glue_name);\n \n     let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(), None);\n-    init_function(&fcx, false, ty::mk_nil(), None, None);\n+    init_function(&fcx, false, ty::mk_nil(), None);\n \n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created.set(ccx.stats.n_glues_created.get() + 1u);"}, {"sha": "98e3593a9f15f6f01d984a99010f9771b3f040ff", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -178,7 +178,6 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n                        self_kind,\n                        None,\n                        mth.id,\n-                       Some(&*mth),\n                        []);\n           }\n           local_def(mth.id)"}, {"sha": "81ee292c835eddccf737ae702d41016cb8966b77", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -153,14 +153,14 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n \n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n \n-    let fcx = new_fn_ctxt_w_id(ccx,\n-                               path,\n-                               decl,\n-                               item.id,\n-                               output_type,\n-                               Some(substs),\n-                               Some(item.span));\n-    init_function(&fcx, true, output_type, Some(substs), None);\n+    let fcx = new_fn_ctxt_detailed(ccx,\n+                                   path,\n+                                   decl,\n+                                   item.id,\n+                                   output_type,\n+                                   Some(substs),\n+                                   Some(item.span));\n+    init_function(&fcx, true, output_type, Some(substs));\n \n     set_always_inline(fcx.llfn);\n \n@@ -254,27 +254,18 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)));\n         }\n-        \"move_val\" => {\n+        \"move_val_init\" => {\n             // Create a datum reflecting the value being moved.\n             // Use `appropriate_mode` so that the datum is by ref\n             // if the value is non-immediate. Note that, with\n             // intrinsics, there are no argument cleanups to\n-            // concern ourselves with.\n-            let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(ccx, tp_ty);\n-            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode};\n-            bcx = src.move_to(bcx, DROP_EXISTING,\n-                              get_param(decl, first_real_arg));\n-            RetVoid(bcx);\n-        }\n-        \"move_val_init\" => {\n-            // See comments for `\"move_val\"`.\n+            // concern ourselves with, so we can use an rvalue datum.\n             let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(ccx, tp_ty);\n+            let mode = appropriate_rvalue_mode(ccx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode};\n-            bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n+                             ty: tp_ty,\n+                             kind: Rvalue(mode)};\n+            bcx = src.store_to(bcx, get_param(decl, first_real_arg));\n             RetVoid(bcx);\n         }\n         \"min_align_of\" => {"}, {"sha": "b9f4a9077b06e3e78d3d2a1112fb8965e6ffce13", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -18,6 +18,7 @@ use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee::*;\n use middle::trans::callee;\n+use middle::trans::cleanup;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n use middle::trans::expr::{SaveIn, Ignore};\n@@ -132,7 +133,6 @@ pub fn trans_method(ccx: @CrateContext,\n              self_ty,\n              param_substs,\n              method.id,\n-             Some(method),\n              []);\n     llfn\n }\n@@ -141,7 +141,8 @@ pub fn trans_method_callee<'a>(\n                            bcx: &'a Block<'a>,\n                            callee_id: ast::NodeId,\n                            this: &ast::Expr,\n-                           mentry: typeck::method_map_entry)\n+                           mentry: typeck::method_map_entry,\n+                           arg_cleanup_scope: cleanup::ScopeId)\n                            -> Callee<'a> {\n     let _icx = push_ctxt(\"impl::trans_method_callee\");\n \n@@ -153,9 +154,8 @@ pub fn trans_method_callee<'a>(\n     match mentry.origin {\n         typeck::method_static(did) => {\n             let self_ty = monomorphize_type(bcx, mentry.self_ty);\n-            let mut temp_cleanups = ~[];\n             let Result {bcx, val} = trans_arg_expr(bcx, self_ty, this,\n-                                                   &mut temp_cleanups,\n+                                                   arg_cleanup_scope,\n                                                    DontAutorefArg);\n             // HACK should not need the pointer cast, eventually trans_fn_ref\n             // should return a function type with the right type for self.\n@@ -168,7 +168,6 @@ pub fn trans_method_callee<'a>(\n                 data: Method(MethodData {\n                     llfn: llfn_val,\n                     llself: val,\n-                    temp_cleanup: temp_cleanups.head_opt().map(|v| *v)\n                 })\n             }\n         }\n@@ -186,7 +185,8 @@ pub fn trans_method_callee<'a>(\n \n                     let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n                     trans_monomorphized_callee(bcx, callee_id, this, mentry,\n-                                               trait_id, off, vtbl)\n+                                               trait_id, off, vtbl,\n+                                               arg_cleanup_scope)\n                 }\n                 // how to get rid of this?\n                 None => fail!(\"trans_method_callee: missing param_substs\")\n@@ -197,7 +197,8 @@ pub fn trans_method_callee<'a>(\n             trans_trait_callee(bcx,\n                                callee_id,\n                                mt.real_index,\n-                               this)\n+                               this,\n+                               arg_cleanup_scope)\n         }\n     }\n }\n@@ -319,7 +320,8 @@ pub fn trans_monomorphized_callee<'a>(\n                                   mentry: typeck::method_map_entry,\n                                   trait_id: ast::DefId,\n                                   n_method: uint,\n-                                  vtbl: typeck::vtable_origin)\n+                                  vtbl: typeck::vtable_origin,\n+                                  arg_cleanup_scope: cleanup::ScopeId)\n                                   -> Callee<'a> {\n     let _icx = push_ctxt(\"impl::trans_monomorphized_callee\");\n     return match vtbl {\n@@ -330,9 +332,8 @@ pub fn trans_monomorphized_callee<'a>(\n \n           // obtain the `self` value:\n           let self_ty = monomorphize_type(bcx, mentry.self_ty);\n-          let mut temp_cleanups = ~[];\n           let Result {bcx, val} = trans_arg_expr(bcx, self_ty, base,\n-                                                 &mut temp_cleanups,\n+                                                 arg_cleanup_scope,\n                                                  DontAutorefArg);\n \n           // create a concatenated set of substitutions which includes\n@@ -361,7 +362,6 @@ pub fn trans_monomorphized_callee<'a>(\n               data: Method(MethodData {\n                   llfn: llfn_val,\n                   llself: val,\n-                  temp_cleanup: temp_cleanups.head_opt().map(|v| *v)\n               })\n           }\n       }\n@@ -425,7 +425,8 @@ pub fn trans_trait_callee<'a>(\n                           bcx: &'a Block<'a>,\n                           callee_id: ast::NodeId,\n                           n_method: uint,\n-                          self_expr: &ast::Expr)\n+                          self_expr: &ast::Expr,\n+                          arg_cleanup_scope: cleanup::ScopeId)\n                           -> Callee<'a> {\n     /*!\n      * Create a method callee where the method is coming from a trait\n@@ -443,34 +444,35 @@ pub fn trans_trait_callee<'a>(\n     let self_ty = expr_ty_adjusted(bcx, self_expr);\n     let self_scratch = match ty::get(self_ty).sty {\n         ty::ty_trait(_, _, ty::RegionTraitStore(..), _, _) => {\n-            unpack_datum!(bcx, expr::trans_to_datum(bcx, self_expr))\n+            unpack_datum!(bcx, expr::trans(bcx, self_expr))\n         }\n         _ => {\n-            let d = scratch_datum(bcx, self_ty, \"__trait_callee\", false);\n-            bcx = expr::trans_into(bcx, self_expr, expr::SaveIn(d.val));\n             // Arrange a temporary cleanup for the object in case something\n             // should go wrong before the method is actually *invoked*.\n-            d.add_clean(bcx);\n-            d\n+            let datum = unpack_datum!(\n+                bcx,\n+                lvalue_scratch_datum(\n+                    bcx, self_ty, \"__trait_callee\", false, arg_cleanup_scope, (),\n+                    |(), bcx, llval| expr::trans_into(bcx, self_expr,\n+                                                      expr::SaveIn(llval))));\n+            datum.to_expr_datum()\n         }\n     };\n \n-\n     let callee_ty = node_id_type(bcx, callee_id);\n+    assert!(self_scratch.kind.is_by_ref()); // FIXME why special case above??\n     trans_trait_callee_from_llval(bcx,\n                                   callee_ty,\n                                   n_method,\n-                                  self_scratch.val,\n-                                  Some(self_scratch.val))\n+                                  self_scratch.val)\n }\n \n pub fn trans_trait_callee_from_llval<'a>(\n                                      bcx: &'a Block<'a>,\n                                      callee_ty: ty::t,\n                                      n_method: uint,\n-                                     llpair: ValueRef,\n-                                     temp_cleanup: Option<ValueRef>)\n-                                     -> Callee<'a> {\n+                                     llpair: ValueRef)\n+                                  -> Callee<'a> {\n     /*!\n      * Same as `trans_trait_callee()` above, except that it is given\n      * a by-ref pointer to the object pair.\n@@ -501,7 +503,6 @@ pub fn trans_trait_callee_from_llval<'a>(\n         data: Method(MethodData {\n             llfn: mptr,\n             llself: llself,\n-            temp_cleanup: temp_cleanup\n         })\n     };\n }\n@@ -632,41 +633,38 @@ fn emit_vtable_methods(bcx: &Block,\n     })\n }\n \n-pub fn trans_trait_cast<'a>(\n-                        bcx: &'a Block<'a>,\n-                        val: &ast::Expr,\n-                        id: ast::NodeId,\n-                        dest: expr::Dest,\n-                        obj: Option<Datum>)\n-                        -> &'a Block<'a> {\n+pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n+                            datum: Datum<Expr>,\n+                            id: ast::NodeId,\n+                            dest: expr::Dest)\n+                            -> &'a Block<'a> {\n+    /*!\n+     * Generates the code to convert from a pointer (`~T`, `&T`, etc)\n+     * into an object (`~Trait`, `&Trait`, etc). This means creating a\n+     * pair where the first word is the pointer and the second word is\n+     * an appropriate vtable.\n+     */\n+\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"impl::trans_cast\");\n \n     let lldest = match dest {\n         Ignore => {\n-            return expr::trans_into(bcx, val, Ignore);\n+            return datum.clean(bcx, \"trait_cast\", id);\n         }\n         SaveIn(dest) => dest\n     };\n \n     let ccx = bcx.ccx();\n-    let v_ty = expr_ty(bcx, val);\n+    let v_ty = datum.ty;\n+    let llbox_ty = type_of(bcx.ccx(), datum.ty);\n \n+    // Store the pointer into the first half of pair.\n     let mut llboxdest = GEPi(bcx, lldest, [0u, abi::trt_field_box]);\n-    // Just store the pointer into the pair. (Region/borrowed\n-    // and boxed trait objects are represented as pairs, and\n-    // have no type descriptor field.)\n-    llboxdest = PointerCast(bcx,\n-                            llboxdest,\n-                            type_of(bcx.ccx(), v_ty).ptr_to());\n-    bcx = match obj {\n-        Some(datum) => {\n-            datum.store_to_dest(bcx, SaveIn(llboxdest))\n-        }\n-        None => expr::trans_into(bcx, val, SaveIn(llboxdest))\n-    };\n+    llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n+    bcx = datum.store_to(bcx, llboxdest);\n \n-    // Store the vtable into the pair or triple.\n+    // Store the vtable into the second half of pair.\n     // This is structured a bit funny because of dynamic borrow failures.\n     let origins = {\n         let res = {\n@@ -677,9 +675,9 @@ pub fn trans_trait_cast<'a>(\n         res[0]\n     };\n     let vtable = get_vtable(bcx, v_ty, origins);\n-    Store(bcx, vtable, PointerCast(bcx,\n-                                   GEPi(bcx, lldest, [0u, abi::trt_field_vtable]),\n-                                   val_ty(vtable).ptr_to()));\n+    let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);\n+    let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n+    Store(bcx, vtable, llvtabledest);\n \n     bcx\n }"}, {"sha": "7ac491edfeb2a82cf883b7d8ef8300beb56aafc4", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub mod doc;\n pub mod macros;\n pub mod inline;\n pub mod monomorphize;\n@@ -44,3 +45,4 @@ pub mod type_;\n pub mod value;\n pub mod basic_block;\n pub mod llrepr;\n+pub mod cleanup;"}, {"sha": "a128a953eacff7032fba919df8d4a7514fbda9fa", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -238,7 +238,6 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                          None,\n                          Some(psubsts),\n                          fn_id.node,\n-                         None,\n                          []);\n                 d\n             }"}, {"sha": "c13bb139da759482736df9793ddd8504307734d5", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -61,7 +61,7 @@ impl<'a> Reflector<'a> {\n         let bcx = self.bcx;\n         let str_vstore = ty::vstore_slice(ty::ReStatic);\n         let str_ty = ty::mk_str(bcx.tcx(), str_vstore);\n-        let scratch = scratch_datum(bcx, str_ty, \"\", false);\n+        let scratch = rvalue_scratch_datum(bcx, str_ty, \"\");\n         let len = C_uint(bcx.ccx(), s.len());\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n@@ -90,6 +90,7 @@ impl<'a> Reflector<'a> {\n     }\n \n     pub fn visit(&mut self, ty_name: &str, args: &[ValueRef]) {\n+        let fcx = self.bcx.fcx;\n         let tcx = self.bcx.tcx();\n         let mth_idx = ty::method_idx(\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n@@ -106,14 +107,13 @@ impl<'a> Reflector<'a> {\n         let bool_ty = ty::mk_bool();\n         let result = unpack_result!(bcx, callee::trans_call_inner(\n             self.bcx, None, mth_ty, bool_ty,\n-            |bcx| meth::trans_trait_callee_from_llval(bcx,\n-                                                      mth_ty,\n-                                                      mth_idx,\n-                                                      v,\n-                                                      None),\n+            |bcx, _| meth::trans_trait_callee_from_llval(bcx,\n+                                                         mth_ty,\n+                                                         mth_idx,\n+                                                         v),\n             ArgVals(args), None, DontAutorefArg));\n         let result = bool_to_i1(bcx, result);\n-        let next_bcx = sub_block(bcx, \"next\");\n+        let next_bcx = fcx.new_temp_block(\"next\");\n         CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n         self.bcx = next_bcx\n     }\n@@ -298,7 +298,7 @@ impl<'a> Reflector<'a> {\n                                       llfdecl,\n                                       ty::mk_u64(),\n                                       None);\n-                init_function(&fcx, false, ty::mk_u64(), None, None);\n+                init_function(&fcx, false, ty::mk_u64(), None);\n \n                 let arg = unsafe {\n                     //\n@@ -308,13 +308,13 @@ impl<'a> Reflector<'a> {\n                     //\n                     llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n                 };\n-                let mut bcx = fcx.entry_bcx.get().unwrap();\n+                let bcx = fcx.entry_bcx.get().unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64()));\n                 Store(bcx, ret, fcx.llretptr.get().unwrap());\n                 match fcx.llreturn.get() {\n-                    Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),\n-                    None => bcx = cleanup_block(bcx, Some(bcx.llbb))\n+                    Some(llreturn) => Br(bcx, llreturn),\n+                    None => {}\n                 };\n                 finish_fn(&fcx, bcx);\n                 llfdecl\n@@ -389,7 +389,8 @@ pub fn emit_calls_to_trait_visit_ty<'a>(\n                                     visitor_val: ValueRef,\n                                     visitor_trait_id: DefId)\n                                     -> &'a Block<'a> {\n-    let final = sub_block(bcx, \"final\");\n+    let fcx = bcx.fcx;\n+    let final = fcx.new_temp_block(\"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.ccx().tcx).unwrap();\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n     let mut r = Reflector {"}, {"sha": "c119bed189df1e4747c19c9b9e17aa6d57c91f80", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 109, "deletions": 87, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -17,6 +17,8 @@ use middle::trans::base::*;\n use middle::trans::base;\n use middle::trans::build::*;\n use middle::trans::callee;\n+use middle::trans::cleanup;\n+use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n use middle::trans::expr::{Dest, Ignore, SaveIn};\n@@ -26,7 +28,6 @@ use middle::trans::machine::{llsize_of, nonzero_llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n-use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n use syntax::ast;\n@@ -193,7 +194,6 @@ pub fn trans_fixed_vstore<'a>(\n \n     debug!(\"trans_fixed_vstore(vstore_expr={}, dest={:?})\",\n            bcx.expr_to_str(vstore_expr), dest.to_str(bcx.ccx()));\n-    let _indenter = indenter();\n \n     let vt = vec_types_from_expr(bcx, vstore_expr);\n \n@@ -214,17 +214,18 @@ pub fn trans_slice_vstore<'a>(\n                           content_expr: &ast::Expr,\n                           dest: expr::Dest)\n                           -> &'a Block<'a> {\n-    //!\n-    //\n-    // &[...] allocates memory on the stack and writes the values into it,\n-    // returning a slice (pair of ptr, len).  &\"...\" is similar except that\n-    // the memory can be statically allocated.\n-\n-    let ccx = bcx.ccx();\n+    /*!\n+     * &[...] allocates memory on the stack and writes the values into it,\n+     * returning a slice (pair of ptr, len).  &\"...\" is similar except that\n+     * the memory can be statically allocated.\n+     */\n+\n+    let fcx = bcx.fcx;\n+    let ccx = fcx.ccx;\n+    let mut bcx = bcx;\n \n     debug!(\"trans_slice_vstore(vstore_expr={}, dest={})\",\n            bcx.expr_to_str(vstore_expr), dest.to_str(ccx));\n-    let _indenter = indenter();\n \n     // Handle the &\"...\" case:\n     match content_expr.node {\n@@ -244,21 +245,29 @@ pub fn trans_slice_vstore<'a>(\n     let count = elements_required(bcx, content_expr);\n     debug!(\"vt={}, count={:?}\", vt.to_str(ccx), count);\n \n-    // Make a fixed-length backing array and allocate it on the stack.\n     let llcount = C_uint(ccx, count);\n-    let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n-\n-    // Arrange for the backing array to be cleaned up.\n-    let fixed_ty = ty::mk_vec(bcx.tcx(),\n-                              ty::mt {ty: vt.unit_ty, mutbl: ast::MutMutable},\n-                              ty::vstore_fixed(count));\n-    let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n-    let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n-    add_clean(bcx, llfixed_casted, fixed_ty);\n-\n-    // Generate the content into the backing array.\n-    let bcx = write_content(bcx, &vt, vstore_expr,\n+    let llfixed;\n+    if count == 0 {\n+        // Zero-length array: just use NULL as the data pointer\n+        llfixed = C_null(vt.llunit_ty.ptr_to());\n+    } else {\n+        // Make a fixed-length backing array and allocate it on the stack.\n+        llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n+\n+        // Arrange for the backing array to be cleaned up.\n+        let fixed_ty = ty::mk_vec(bcx.tcx(),\n+                                  ty::mt {ty: vt.unit_ty,\n+                                          mutbl: ast::MutMutable},\n+                                  ty::vstore_fixed(count));\n+        let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n+        let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n+        let cleanup_scope = cleanup::temporary_scope(bcx.tcx(), content_expr.id);\n+        fcx.schedule_drop_mem(cleanup_scope, llfixed_casted, fixed_ty);\n+\n+        // Generate the content into the backing array.\n+        bcx = write_content(bcx, &vt, vstore_expr,\n                             content_expr, SaveIn(llfixed));\n+    }\n \n     // Finally, create the slice pair itself.\n     match dest {\n@@ -278,16 +287,15 @@ pub fn trans_lit_str<'a>(\n                      str_lit: @str,\n                      dest: Dest)\n                      -> &'a Block<'a> {\n-    //!\n-    //\n-    // Literal strings translate to slices into static memory.  This is\n-    // different from trans_slice_vstore() above because it does need to copy\n-    // the content anywhere.\n+    /*!\n+     * Literal strings translate to slices into static memory.  This is\n+     * different from trans_slice_vstore() above because it does need to copy\n+     * the content anywhere.\n+     */\n \n     debug!(\"trans_lit_str(lit_expr={}, dest={})\",\n            bcx.expr_to_str(lit_expr),\n            dest.to_str(bcx.ccx()));\n-    let _indenter = indenter();\n \n     match dest {\n         Ignore => bcx,\n@@ -308,20 +316,19 @@ pub fn trans_lit_str<'a>(\n }\n \n \n-pub fn trans_uniq_or_managed_vstore<'a>(\n-                                    bcx: &'a Block<'a>,\n-                                    heap: heap,\n-                                    vstore_expr: &ast::Expr,\n-                                    content_expr: &ast::Expr)\n-                                    -> DatumBlock<'a> {\n-    //!\n-    //\n-    // @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n-    // appropriate heap and write the array elements into them.\n+pub fn trans_uniq_or_managed_vstore<'a>(bcx: &'a Block<'a>,\n+                                        heap: heap,\n+                                        vstore_expr: &ast::Expr,\n+                                        content_expr: &ast::Expr)\n+                                        -> DatumBlock<'a, Expr> {\n+    /*!\n+     * @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n+     * appropriate heap and write the array elements into them.\n+     */\n \n     debug!(\"trans_uniq_or_managed_vstore(vstore_expr={}, heap={:?})\",\n            bcx.expr_to_str(vstore_expr), heap);\n-    let _indenter = indenter();\n+    let fcx = bcx.fcx;\n \n     // Handle ~\"\".\n     match heap {\n@@ -334,7 +341,7 @@ pub fn trans_uniq_or_managed_vstore<'a>(\n                             let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n                             let llsizeval = C_uint(bcx.ccx(), s.len());\n                             let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n-                            let lldestval = scratch_datum(bcx, typ, \"\", false);\n+                            let lldestval = rvalue_scratch_datum(bcx, typ, \"\");\n                             let alloc_fn = langcall(bcx,\n                                                     Some(lit.span),\n                                                     \"\",\n@@ -343,11 +350,8 @@ pub fn trans_uniq_or_managed_vstore<'a>(\n                                 bcx,\n                                 alloc_fn,\n                                 [ llptrval, llsizeval ],\n-                                Some(expr::SaveIn(lldestval.to_ref_llval(bcx)))).bcx;\n-                            return DatumBlock {\n-                                bcx: bcx,\n-                                datum: lldestval\n-                            };\n+                                Some(expr::SaveIn(lldestval.val))).bcx;\n+                            return DatumBlock(bcx, lldestval).to_expr_datumblock();\n                         }\n                         _ => {}\n                     }\n@@ -364,7 +368,11 @@ pub fn trans_uniq_or_managed_vstore<'a>(\n \n     let Result {bcx, val} = alloc_vec(bcx, vt.unit_ty, count, heap);\n \n-    add_clean_free(bcx, val, heap);\n+    // Create a temporary scope lest execution should fail while\n+    // constructing the vector.\n+    let temp_scope = fcx.push_custom_cleanup_scope();\n+    fcx.schedule_free_value(cleanup::CustomScope(temp_scope), val, heap);\n+\n     let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val, vt.vec_ty));\n \n     debug!(\"alloc_vec() returned val={}, dataptr={}\",\n@@ -373,9 +381,9 @@ pub fn trans_uniq_or_managed_vstore<'a>(\n     let bcx = write_content(bcx, &vt, vstore_expr,\n                             content_expr, SaveIn(dataptr));\n \n-    revoke_clean(bcx, val);\n+    fcx.pop_custom_cleanup_scope(temp_scope);\n \n-    return immediate_rvalue_bcx(bcx, val, vt.vec_ty);\n+    return immediate_rvalue_bcx(bcx, val, vt.vec_ty).to_expr_datumblock();\n }\n \n pub fn write_content<'a>(\n@@ -386,13 +394,13 @@ pub fn write_content<'a>(\n                      dest: Dest)\n                      -> &'a Block<'a> {\n     let _icx = push_ctxt(\"tvec::write_content\");\n+    let fcx = bcx.fcx;\n     let mut bcx = bcx;\n \n     debug!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n            vt.to_str(bcx.ccx()),\n            dest.to_str(bcx.ccx()),\n            bcx.expr_to_str(vstore_expr));\n-    let _indenter = indenter();\n \n     match content_expr.node {\n         ast::ExprLit(lit) => {\n@@ -430,19 +438,19 @@ pub fn write_content<'a>(\n                 }\n \n                 SaveIn(lldest) => {\n-                    let mut temp_cleanups = ~[];\n+                    let temp_scope = fcx.push_custom_cleanup_scope();\n                     for (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n                         debug!(\"writing index {:?} with lleltptr={:?}\",\n                                i, bcx.val_to_str(lleltptr));\n                         bcx = expr::trans_into(bcx, *element,\n                                                SaveIn(lleltptr));\n-                        add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n-                        temp_cleanups.push(lleltptr);\n-                    }\n-                    for cleanup in temp_cleanups.iter() {\n-                        revoke_clean(bcx, *cleanup);\n+                        fcx.schedule_drop_mem(\n+                            cleanup::CustomScope(temp_scope),\n+                            lleltptr,\n+                            vt.unit_ty);\n                     }\n+                    fcx.pop_custom_cleanup_scope(temp_scope);\n                 }\n             }\n             return bcx;\n@@ -463,14 +471,16 @@ pub fn write_content<'a>(\n                     // this can only happen as a result of OOM. So we just skip out on the\n                     // cleanup since things would *probably* be broken at that point anyways.\n \n-                    let elem = unpack_datum!(bcx, {\n-                        expr::trans_to_datum(bcx, element)\n-                    });\n+                    let elem = unpack_datum!(bcx, expr::trans(bcx, element));\n+                    assert!(!ty::type_moves_by_default(bcx.tcx(), elem.ty));\n \n-                    iter_vec_loop(bcx, lldest, vt,\n+                    let bcx = iter_vec_loop(bcx, lldest, vt,\n                                   C_uint(bcx.ccx(), count), |set_bcx, lleltptr, _| {\n-                        elem.copy_to(set_bcx, INIT, lleltptr)\n-                    })\n+                        elem.shallow_copy_and_take(set_bcx, lleltptr)\n+                    });\n+\n+                    elem.add_clean_if_rvalue(bcx, element.id);\n+                    bcx\n                 }\n             }\n         }\n@@ -522,15 +532,16 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_base_and_byte_len(bcx: &Block, llval: ValueRef, vec_ty: ty::t)\n+pub fn get_base_and_byte_len(bcx: &Block,\n+                             llval: ValueRef,\n+                             vec_ty: ty::t)\n                              -> (ValueRef, ValueRef) {\n-    //!\n-    //\n-    // Converts a vector into the slice pair.  The vector should be stored in\n-    // `llval` which should be either immediate or by-ref as appropriate for\n-    // the vector type.  If you have a datum, you would probably prefer to\n-    // call `Datum::get_base_and_byte_len()` which will handle any conversions for\n-    // you.\n+    /*!\n+     * Converts a vector into the slice pair.  The vector should be\n+     * stored in `llval` which should be by ref. If you have a datum,\n+     * you would probably prefer to call\n+     * `Datum::get_base_and_byte_len()`.\n+     */\n \n     let ccx = bcx.ccx();\n     let vt = vec_types(bcx, vec_ty);\n@@ -542,32 +553,38 @@ pub fn get_base_and_byte_len(bcx: &Block, llval: ValueRef, vec_ty: ty::t)\n \n     match vstore {\n         ty::vstore_fixed(n) => {\n+            assert!(!type_is_immediate(bcx.ccx(), vt.vec_ty));\n             let base = GEPi(bcx, llval, [0u, 0u]);\n             let len = Mul(bcx, C_uint(ccx, n), vt.llunit_size);\n             (base, len)\n         }\n         ty::vstore_slice(_) => {\n+            assert!(!type_is_immediate(bcx.ccx(), vt.vec_ty));\n             let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n             let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n             let len = Mul(bcx, count, vt.llunit_size);\n             (base, len)\n         }\n         ty::vstore_uniq | ty::vstore_box => {\n+            assert!(type_is_immediate(bcx.ccx(), vt.vec_ty));\n+            let llval = Load(bcx, llval);\n             let body = get_bodyptr(bcx, llval, vec_ty);\n             (get_dataptr(bcx, body), get_fill(bcx, body))\n         }\n     }\n }\n \n-pub fn get_base_and_len(bcx: &Block, llval: ValueRef, vec_ty: ty::t)\n+pub fn get_base_and_len(bcx: &Block,\n+                        llval: ValueRef,\n+                        vec_ty: ty::t)\n                         -> (ValueRef, ValueRef) {\n-    //!\n-    //\n-    // Converts a vector into the slice pair.  The vector should be stored in\n-    // `llval` which should be either immediate or by-ref as appropriate for\n-    // the vector type.  If you have a datum, you would probably prefer to\n-    // call `Datum::get_base_and_len()` which will handle any conversions for\n-    // you.\n+    /*!\n+     * Converts a vector into the slice pair.  The vector should be\n+     * stored in `llval` which should be by-reference.  If you have a\n+     * datum, you would probably prefer to call\n+     * `Datum::get_base_and_len()` which will handle any conversions\n+     * for you.\n+     */\n \n     let ccx = bcx.ccx();\n     let vt = vec_types(bcx, vec_ty);\n@@ -579,15 +596,19 @@ pub fn get_base_and_len(bcx: &Block, llval: ValueRef, vec_ty: ty::t)\n \n     match vstore {\n         ty::vstore_fixed(n) => {\n+            assert!(!type_is_immediate(bcx.ccx(), vt.vec_ty));\n             let base = GEPi(bcx, llval, [0u, 0u]);\n             (base, C_uint(ccx, n))\n         }\n         ty::vstore_slice(_) => {\n+            assert!(!type_is_immediate(bcx.ccx(), vt.vec_ty));\n             let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n             let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n             (base, count)\n         }\n         ty::vstore_uniq | ty::vstore_box => {\n+            assert!(type_is_immediate(bcx.ccx(), vt.vec_ty));\n+            let llval = Load(bcx, llval);\n             let body = get_bodyptr(bcx, llval, vec_ty);\n             (get_dataptr(bcx, body), UDiv(bcx, get_fill(bcx, body), vt.llunit_size))\n         }\n@@ -606,12 +627,13 @@ pub fn iter_vec_loop<'r,\n                      f: iter_vec_block<'r,'b>)\n                      -> &'b Block<'b> {\n     let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n+    let fcx = bcx.fcx;\n \n-    let next_bcx = sub_block(bcx, \"iter_vec_loop: while next\");\n-    let loop_bcx = loop_scope_block(bcx, next_bcx, None, \"iter_vec_loop\", None);\n-    let cond_bcx = scope_block(loop_bcx, None, \"iter_vec_loop: loop cond\");\n-    let body_bcx = scope_block(loop_bcx, None, \"iter_vec_loop: body: main\");\n-    let inc_bcx = scope_block(loop_bcx, None, \"iter_vec_loop: loop inc\");\n+    let next_bcx = fcx.new_temp_block(\"expr_repeat: while next\");\n+    let loop_bcx = fcx.new_temp_block(\"expr_repeat\");\n+    let cond_bcx = fcx.new_temp_block(\"expr_repeat: loop cond\");\n+    let body_bcx = fcx.new_temp_block(\"expr_repeat: body: set\");\n+    let inc_bcx = fcx.new_temp_block(\"expr_repeat: body: inc\");\n     Br(bcx, loop_bcx.llbb);\n \n     let loop_counter = {\n@@ -663,6 +685,7 @@ pub fn iter_vec_raw<'r,\n                     f: iter_vec_block<'r,'b>)\n                     -> &'b Block<'b> {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n+    let fcx = bcx.fcx;\n \n     let vt = vec_types(bcx, vec_ty);\n     if (vt.llunit_alloc_size == 0) {\n@@ -676,22 +699,21 @@ pub fn iter_vec_raw<'r,\n         let data_end_ptr = pointer_add_byte(bcx, data_ptr, fill);\n \n         // Now perform the iteration.\n-        let header_bcx = base::sub_block(bcx, \"iter_vec_loop_header\");\n+        let header_bcx = fcx.new_temp_block(\"iter_vec_loop_header\");\n         Br(bcx, header_bcx.llbb);\n         let data_ptr =\n             Phi(header_bcx, val_ty(data_ptr), [data_ptr], [bcx.llbb]);\n         let not_yet_at_end =\n             ICmp(header_bcx, lib::llvm::IntULT, data_ptr, data_end_ptr);\n-        let body_bcx = base::sub_block(header_bcx, \"iter_vec_loop_body\");\n-        let next_bcx = base::sub_block(header_bcx, \"iter_vec_next\");\n+        let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n+        let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n         CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n         let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n         AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n                                                [C_int(bcx.ccx(), 1)]),\n                          body_bcx.llbb);\n         Br(body_bcx, header_bcx.llbb);\n         next_bcx\n-\n     }\n }\n "}, {"sha": "5b310feb58db50f9a2f268469d81bc7a2296ef7b", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -16,19 +16,17 @@\n \n \n use middle::borrowck::{RootInfo, root_map_key};\n-use middle::trans::base::*;\n+use middle::trans::cleanup;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n use syntax::codemap::Span;\n use syntax::ast;\n \n-pub fn root_and_write_guard<'a>(\n-                            datum: &Datum,\n-                            bcx: &'a Block<'a>,\n-                            span: Span,\n-                            expr_id: ast::NodeId,\n-                            derefs: uint)\n-                            -> &'a Block<'a> {\n+pub fn root_and_write_guard<'a, K:KindOps>(datum: &Datum<K>,\n+                                           bcx: &'a Block<'a>,\n+                                           span: Span,\n+                                           expr_id: ast::NodeId,\n+                                           derefs: uint) -> &'a Block<'a> {\n     let key = root_map_key { id: expr_id, derefs: derefs };\n     debug!(\"write_guard::root_and_write_guard(key={:?})\", key);\n \n@@ -43,13 +41,11 @@ pub fn root_and_write_guard<'a>(\n     }\n }\n \n-fn root<'a>(\n-        datum: &Datum,\n-        bcx: &'a Block<'a>,\n-        _: Span,\n-        root_key: root_map_key,\n-        root_info: RootInfo)\n-        -> &'a Block<'a> {\n+fn root<'a, K:KindOps>(datum: &Datum<K>,\n+                       bcx: &'a Block<'a>,\n+                       _span: Span,\n+                       root_key: root_map_key,\n+                       root_info: RootInfo) -> &'a Block<'a> {\n     //! In some cases, borrowck will decide that an @T/@[]/@str\n     //! value must be rooted for the program to be safe.  In that\n     //! case, we will call this function, which will stash a copy\n@@ -58,17 +54,12 @@ fn root<'a>(\n     debug!(\"write_guard::root(root_key={:?}, root_info={:?}, datum={:?})\",\n            root_key, root_info, datum.to_str(bcx.ccx()));\n \n-    // First, root the datum. Note that we must zero this value,\n+    // Root the datum. Note that we must zero this value,\n     // because sometimes we root on one path but not another.\n     // See e.g. #4904.\n-    let scratch = scratch_datum(bcx, datum.ty, \"__write_guard\", true);\n-    datum.copy_to_datum(bcx, INIT, scratch);\n-    let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n-    add_clean_temp_mem_in_scope(cleanup_bcx,\n-                                root_info.scope,\n-                                scratch.val,\n-                                scratch.ty);\n-\n-    bcx\n+    lvalue_scratch_datum(\n+        bcx, datum.ty, \"__write_guard\", true,\n+        cleanup::AstScope(root_info.scope), (),\n+        |(), bcx, llval| datum.shallow_copy_and_take(bcx, llval)).bcx\n }\n "}, {"sha": "99cdbacbd5bed155d158657c91f61823e388191c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -3983,8 +3983,31 @@ pub fn ast_expr_vstore_to_vstore(fcx: @FnCtxt,\n         ast::ExprVstoreUniq => ty::vstore_uniq,\n         ast::ExprVstoreBox => ty::vstore_box,\n         ast::ExprVstoreSlice | ast::ExprVstoreMutSlice => {\n-            let r = fcx.infcx().next_region_var(infer::AddrOfSlice(e.span));\n-            ty::vstore_slice(r)\n+            match e.node {\n+                ast::ExprLit(..) |\n+                ast::ExprVec([], _) => {\n+                    // string literals and *empty slices* live in static memory\n+                    ty::vstore_slice(ty::ReStatic)\n+                }\n+                ast::ExprRepeat(..) |\n+                ast::ExprVec(..) => {\n+                    // vector literals are temporaries on the stack\n+                    match fcx.tcx().region_maps.temporary_scope(e.id) {\n+                        Some(scope) => {\n+                            let r = ty::ReScope(scope);\n+                            ty::vstore_slice(r)\n+                        }\n+                        None => {\n+                            // this slice occurs in a static somewhere\n+                            ty::vstore_slice(ty::ReStatic)\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    fcx.ccx.tcx.sess.span_bug(\n+                        e.span, format!(\"vstore with unexpected contents\"))\n+                }\n+            }\n         }\n     }\n }\n@@ -4103,7 +4126,7 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n             \"uninit\" => (1u, ~[], param(ccx, 0u)),\n             \"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n             \"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n-            \"move_val\" | \"move_val_init\" => {\n+            \"move_val_init\" => {\n                 (1u,\n                  ~[\n                     ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), param(ccx, 0)),"}, {"sha": "490a9cb985321fb077bed97c8df82b025ec6a526", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 14, "deletions": 59, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -55,21 +55,26 @@ pub struct Rcx {\n     repeating_scope: ast::NodeId,\n }\n \n-fn encl_region_of_def(fcx: @FnCtxt, def: ast::Def) -> ty::Region {\n+fn region_of_def(fcx: @FnCtxt, def: ast::Def) -> ty::Region {\n+    /*!\n+     * Returns the validity region of `def` -- that is, how long\n+     * is `def` valid?\n+     */\n+\n     let tcx = fcx.tcx();\n     match def {\n         DefLocal(node_id, _) | DefArg(node_id, _) |\n         DefSelf(node_id, _) | DefBinding(node_id, _) => {\n-            tcx.region_maps.encl_region(node_id)\n+            tcx.region_maps.var_region(node_id)\n         }\n         DefUpvar(_, subdef, closure_id, body_id) => {\n             match ty::ty_closure_sigil(fcx.node_ty(closure_id)) {\n-                BorrowedSigil => encl_region_of_def(fcx, *subdef),\n+                BorrowedSigil => region_of_def(fcx, *subdef),\n                 ManagedSigil | OwnedSigil => ReScope(body_id)\n             }\n         }\n         _ => {\n-            tcx.sess.bug(format!(\"unexpected def in encl_region_of_def: {:?}\",\n+            tcx.sess.bug(format!(\"unexpected def in region_of_def: {:?}\",\n                               def))\n         }\n     }\n@@ -193,7 +198,6 @@ fn visit_item(_rcx: &mut Rcx, _item: &ast::Item) {\n }\n \n fn visit_block(rcx: &mut Rcx, b: &ast::Block) {\n-    rcx.fcx.tcx().region_maps.record_cleanup_scope(b.id);\n     visit::walk_block(rcx, b, ());\n }\n \n@@ -239,9 +243,9 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n         // that the lifetime of any regions that appear in a\n         // variable's type enclose at least the variable's scope.\n \n-        let encl_region = tcx.region_maps.encl_region(id);\n+        let var_region = tcx.region_maps.var_region(id);\n         constrain_regions_in_type_of_node(\n-            rcx, id, encl_region,\n+            rcx, id, var_region,\n             infer::BindingTypeIsNotValidAtDecl(span));\n     })\n }\n@@ -255,55 +259,6 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         method_map.get().contains_key(&expr.id)\n     };\n \n-    // Record cleanup scopes, which are used by borrowck to decide the\n-    // maximum lifetime of a temporary rvalue.  These were derived by\n-    // examining where trans creates block scopes, not because this\n-    // reflects some principled decision around temporary lifetimes.\n-    // Ordinarily this would seem like something that should be setup\n-    // in region, but we need to know which uses of operators are\n-    // overloaded.  See #3511.\n-    let tcx = rcx.fcx.tcx();\n-    match expr.node {\n-        // You'd think that x += y where `+=` is overloaded would be a\n-        // cleanup scope. You'd be... kind of right. In fact the\n-        // handling of `+=` and friends in trans for overloaded\n-        // operators is a hopeless mess and I can't figure out how to\n-        // represent it. - ndm\n-        //\n-        // ast::expr_assign_op(..) |\n-\n-        ast::ExprIndex(..) |\n-        ast::ExprBinary(..) |\n-        ast::ExprUnary(..) if has_method_map => {\n-            tcx.region_maps.record_cleanup_scope(expr.id);\n-        }\n-        ast::ExprBinary(_, ast::BiAnd, lhs, rhs) |\n-        ast::ExprBinary(_, ast::BiOr, lhs, rhs) => {\n-            tcx.region_maps.record_cleanup_scope(lhs.id);\n-            tcx.region_maps.record_cleanup_scope(rhs.id);\n-        }\n-        ast::ExprCall(..) |\n-        ast::ExprMethodCall(..) => {\n-            tcx.region_maps.record_cleanup_scope(expr.id);\n-        }\n-        ast::ExprMatch(_, ref arms) => {\n-            tcx.region_maps.record_cleanup_scope(expr.id);\n-            for arm in arms.iter() {\n-                for guard in arm.guard.iter() {\n-                    tcx.region_maps.record_cleanup_scope(guard.id);\n-                }\n-            }\n-        }\n-        ast::ExprLoop(ref body, _) => {\n-            tcx.region_maps.record_cleanup_scope(body.id);\n-        }\n-        ast::ExprWhile(cond, ref body) => {\n-            tcx.region_maps.record_cleanup_scope(cond.id);\n-            tcx.region_maps.record_cleanup_scope(body.id);\n-        }\n-        _ => {}\n-    }\n-\n     // Check any autoderefs or autorefs that appear.\n     {\n         let adjustments = rcx.fcx.inh.adjustments.borrow();\n@@ -701,10 +656,10 @@ fn constrain_free_variables(rcx: &mut Rcx,\n     for freevar in get_freevars(tcx, expr.id).iter() {\n         debug!(\"freevar def is {:?}\", freevar.def);\n         let def = freevar.def;\n-        let en_region = encl_region_of_def(rcx.fcx, def);\n-        debug!(\"en_region = {}\", en_region.repr(tcx));\n+        let def_region = region_of_def(rcx.fcx, def);\n+        debug!(\"def_region = {}\", def_region.repr(tcx));\n         rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span),\n-                        region, en_region);\n+                        region, def_region);\n     }\n }\n "}, {"sha": "b9916749fe9a12c960414a68973ede573bd1d019", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -673,6 +673,14 @@ impl Repr for ast::Item {\n     }\n }\n \n+impl Repr for ast::Stmt {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        format!(\"stmt({}: {})\",\n+                ast_util::stmt_id(self),\n+                pprust::stmt_to_str(self, tcx.sess.intr()))\n+    }\n+}\n+\n impl Repr for ast::Pat {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         format!(\"pat({}: {})\","}, {"sha": "b9a36137db29a0e0b0f354cc790b5cf6349ceeee", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -276,7 +276,8 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         write!(w, \"var allPaths = \\\\{\");\n         for (i, (&id, &(ref fqp, short))) in cache.paths.iter().enumerate() {\n             if i > 0 { write!(w, \",\"); }\n-            write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\", id, short, *fqp.last());\n+            write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n+                   id, short, *fqp.last());\n         }\n         write!(w, \"\\\\};\");\n         w.flush();"}, {"sha": "546f555038756b1dfd58c7c19bb82acb81c0c0f3", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -521,7 +521,8 @@ mod tests {\n \n     #[test]\n     fn test_ascii_vec() {\n-        assert_eq!((&[40u8, 32u8, 59u8]).to_ascii(), v2ascii!([40, 32, 59]));\n+        let test = &[40u8, 32u8, 59u8];\n+        assert_eq!(test.to_ascii(), v2ascii!([40, 32, 59]));\n         assert_eq!(\"( ;\".to_ascii(),                 v2ascii!([40, 32, 59]));\n         // FIXME: #5475 borrowchk error, owned vectors do not live long enough\n         // if chained-from directly\n@@ -587,14 +588,18 @@ mod tests {\n \n         assert_eq!(\"zo\u00e4\u534e\".to_ascii_opt(), None);\n \n-        assert_eq!((&[127u8, 128u8, 255u8]).to_ascii_opt(), None);\n+        let test1 = &[127u8, 128u8, 255u8];\n+        assert_eq!((test1).to_ascii_opt(), None);\n \n         let v = [40u8, 32u8, 59u8];\n-        assert_eq!(v.to_ascii_opt(), Some(v2ascii!(&[40, 32, 59])));\n+        let v2 = v2ascii!(&[40, 32, 59]);\n+        assert_eq!(v.to_ascii_opt(), Some(v2));\n         let v = [127u8, 128u8, 255u8];\n         assert_eq!(v.to_ascii_opt(), None);\n \n-        assert_eq!(\"( ;\".to_ascii_opt(), Some(v2ascii!(&[40, 32, 59])));\n+        let v = \"( ;\";\n+        let v2 = v2ascii!(&[40, 32, 59]);\n+        assert_eq!(v.to_ascii_opt(), Some(v2));\n         assert_eq!(\"zo\u00e4\u534e\".to_ascii_opt(), None);\n \n         assert_eq!((~[40u8, 32u8, 59u8]).into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));"}, {"sha": "a6caa1bfc29520e6443fd7a8746e10986bd69609", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -406,7 +406,8 @@ mod test {\n \n     #[test]\n     fn test_read_char() {\n-        let mut r = BufReader::new(bytes!(\"Vi\u1ec7t\"));\n+        let b = bytes!(\"Vi\u1ec7t\");\n+        let mut r = BufReader::new(b);\n         assert_eq!(r.read_char(), Some('V'));\n         assert_eq!(r.read_char(), Some('i'));\n         assert_eq!(r.read_char(), Some('\u1ec7'));\n@@ -416,7 +417,8 @@ mod test {\n \n     #[test]\n     fn test_read_bad_char() {\n-        let mut r = BufReader::new(bytes!(0x80));\n+        let b = bytes!(0x80);\n+        let mut r = BufReader::new(b);\n         assert_eq!(r.read_char(), None);\n     }\n "}, {"sha": "4c8a640a849c12f3b92b8ccb03d96046135fb5ab", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -181,7 +181,7 @@ mod tests {\n         let io = ~[];\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"true\"],\n+            args: &[~\"-c\", ~\"true\"],\n             env: None,\n             cwd: None,\n             io: io,\n@@ -198,7 +198,7 @@ mod tests {\n         let io = ~[];\n         let args = ProcessConfig {\n             program: \"if-this-is-a-binary-then-the-world-has-ended\",\n-            args: [],\n+            args: &[],\n             env: None,\n             cwd: None,\n             io: io,\n@@ -215,7 +215,7 @@ mod tests {\n         let io = ~[];\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"exit 1\"],\n+            args: &[~\"-c\", ~\"exit 1\"],\n             env: None,\n             cwd: None,\n             io: io,\n@@ -231,7 +231,7 @@ mod tests {\n         let io = ~[];\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"kill -1 $$\"],\n+            args: &[~\"-c\", ~\"kill -1 $$\"],\n             env: None,\n             cwd: None,\n             io: io,\n@@ -274,7 +274,7 @@ mod tests {\n         let io = ~[Ignored, CreatePipe(false, true)];\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"echo foobar\"],\n+            args: &[~\"-c\", ~\"echo foobar\"],\n             env: None,\n             cwd: None,\n             io: io,\n@@ -289,7 +289,7 @@ mod tests {\n         let cwd = Some(\"/\");\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"pwd\"],\n+            args: &[~\"-c\", ~\"pwd\"],\n             env: None,\n             cwd: cwd,\n             io: io,\n@@ -304,7 +304,7 @@ mod tests {\n                    CreatePipe(false, true)];\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n-            args: [~\"-c\", ~\"read line; echo $line\"],\n+            args: &[~\"-c\", ~\"read line; echo $line\"],\n             env: None,\n             cwd: None,\n             io: io,"}, {"sha": "aab98f19e151327cb098064d45822bf7f6c9cac9", "filename": "src/libstd/option.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -48,6 +48,7 @@ use kinds::Send;\n use str::OwnedStr;\n use to_str::ToStr;\n use util;\n+use vec;\n \n /// The option type\n #[deriving(Clone, DeepClone, Eq, Ord, TotalEq, TotalOrd, ToStr)]\n@@ -98,6 +99,24 @@ impl<T> Option<T> {\n         match *self { Some(ref mut x) => Some(x), None => None }\n     }\n \n+    /// Convert from `Option<T>` to `&[T]` (without copying)\n+    #[inline]\n+    pub fn as_slice<'r>(&'r self) -> &'r [T] {\n+        match *self {\n+            Some(ref x) => vec::ref_slice(x),\n+            None => &[]\n+        }\n+    }\n+\n+    /// Convert from `Option<T>` to `&[T]` (without copying)\n+    #[inline]\n+    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n+        match *self {\n+            Some(ref mut x) => vec::mut_ref_slice(x),\n+            None => &mut []\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Getting to contained values\n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "e2ddabc1714b6f8f0b1cac84bf7fb8db7cfedc22", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -237,7 +237,10 @@ impl GenericPath for Path {\n             let mut ita = self.components();\n             let mut itb = other.components();\n             if bytes!(\".\") == self.repr {\n-                return itb.next() != Some(bytes!(\"..\"));\n+                return match itb.next() {\n+                    None => true,\n+                    Some(b) => b != bytes!(\"..\")\n+                };\n             }\n             loop {\n                 match (ita.next(), itb.next()) {\n@@ -463,7 +466,10 @@ mod tests {\n \n     macro_rules! b(\n         ($($arg:expr),+) => (\n-            bytes!($($arg),+)\n+            {\n+                static the_bytes: &'static [u8] = bytes!($($arg),+);\n+                the_bytes\n+            }\n         )\n     )\n \n@@ -689,7 +695,8 @@ mod tests {\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::new($path);\n+                    let arg = $path;\n+                    let path = Path::new(arg);\n                     assert_eq!(path.$op(), $exp);\n                 }\n             );"}, {"sha": "cf2163265e43fced12ff2183d66f3f8d560fdcdc", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -1074,7 +1074,10 @@ mod tests {\n \n     macro_rules! b(\n         ($($arg:expr),+) => (\n-            bytes!($($arg),+)\n+            {\n+                static the_bytes: &'static [u8] = bytes!($($arg),+);\n+                the_bytes\n+            }\n         )\n     )\n \n@@ -1372,20 +1375,23 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::new($path);\n+                    let path = $path;\n+                    let path = Path::new(path);\n                     assert_eq!(path.$op(), Some($exp));\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n-                    let path = Path::new($path);\n+                    let path = $path;\n+                    let path = Path::new(path);\n                     let left = path.$op();\n                     assert_eq!(left, $exp);\n                 }\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::new($path);\n+                    let path = $path;\n+                    let path = Path::new(path);\n                     assert_eq!(path.$op(), $exp);\n                 }\n             )"}, {"sha": "6ea12659e77f249b7767def0ea98db5e2a3014f5", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -130,14 +130,14 @@ mod tests {\n         let child_crate = CrateMap {\n             version: 2,\n             entries: entries,\n-            children: [],\n+            children: &[],\n             event_loop_factory: None,\n         };\n \n         let root_crate = CrateMap {\n             version: 2,\n-            entries: [],\n-            children: [&child_crate, &child_crate],\n+            entries: &[],\n+            children: &[&child_crate, &child_crate],\n             event_loop_factory: None,\n         };\n \n@@ -157,29 +157,29 @@ mod tests {\n         let mut level3: u32 = 3;\n         let child_crate2 = CrateMap {\n             version: 2,\n-            entries: [\n+            entries: &[\n                 ModEntry { name: \"c::m1\", log_level: &mut level2},\n                 ModEntry { name: \"c::m2\", log_level: &mut level3},\n             ],\n-            children: [],\n+            children: &[],\n             event_loop_factory: None,\n         };\n \n         let child_crate1 = CrateMap {\n             version: 2,\n-            entries: [\n+            entries: &[\n                 ModEntry { name: \"t::f1\", log_level: &mut 1},\n             ],\n-            children: [&child_crate2],\n+            children: &[&child_crate2],\n             event_loop_factory: None,\n         };\n \n         let root_crate = CrateMap {\n             version: 2,\n-            entries: [\n+            entries: &[\n                 ModEntry { name: \"t::f2\", log_level: &mut 0},\n             ],\n-            children: [&child_crate1],\n+            children: &[&child_crate1],\n             event_loop_factory: None,\n         };\n "}, {"sha": "63c0d628ce2e3b0aa87270d043998596144ba8ec", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -329,12 +329,6 @@ extern \"rust-intrinsic\" {\n     /// elements.\n     pub fn size_of<T>() -> uint;\n \n-    /// Move a value to a memory location containing a value.\n-    ///\n-    /// Drop glue is run on the destination, which must contain a\n-    /// valid Rust value.\n-    pub fn move_val<T>(dst: &mut T, src: T);\n-\n     /// Move a value to an uninitialized memory location.\n     ///\n     /// Drop glue is not run on the destination."}, {"sha": "22b07d6548f228872fd3e275f70c0fb316d511fa", "filename": "src/libstd/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -134,7 +134,7 @@ mod tests {\n     }\n }\n \n-/// Completely miscellaneous language-construct benchmarks.\n+/// Completely miscellaneous language-constracuct benchmarks.\n #[cfg(test)]\n mod bench {\n "}, {"sha": "fd7640de12694d47eac4eb39e173080bd100f73b", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -168,7 +168,7 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n         let mut v = with_capacity(n_elts);\n         let p = v.as_mut_ptr();\n         let mut i = 0u;\n-        (|| {\n+        (|| { // FIXME what if we fail in the middle of this loop?\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)), t.clone());\n                 i += 1u;\n@@ -239,6 +239,25 @@ pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> ~[A] {\n     vec\n }\n \n+/**\n+ * Converts a pointer to A into a slice of length 1 (without copying).\n+ */\n+pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n+    unsafe {\n+        cast::transmute(Slice { data: s, len: 1 })\n+    }\n+}\n+\n+/**\n+ * Converts a pointer to A into a slice of length 1 (without copying).\n+ */\n+pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n+    unsafe {\n+        let ptr: *A = cast::transmute(s);\n+        cast::transmute(Slice { data: ptr, len: 1 })\n+    }\n+}\n+\n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function.\n pub struct SplitIterator<'a, T> {\n@@ -2175,6 +2194,9 @@ pub trait MutableVector<'a, T> {\n     /// Returns an iterator that allows modifying each value\n     fn mut_iter(self) -> VecMutIterator<'a, T>;\n \n+    /// Returns a mutable pointer to the last item in the vector.\n+    fn mut_last(self) -> &'a mut T;\n+\n     /// Returns a reversed iterator that allows modifying each value\n     fn mut_rev_iter(self) -> MutRevIterator<'a, T>;\n \n@@ -2437,6 +2459,13 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         }\n     }\n \n+    #[inline]\n+    fn mut_last(self) -> &'a mut T {\n+        let len = self.len();\n+        if len == 0 { fail!(\"mut_last: empty vector\") }\n+        &mut self[len - 1]\n+    }\n+\n     #[inline]\n     fn mut_rev_iter(self) -> MutRevIterator<'a, T> {\n         self.mut_iter().invert()"}, {"sha": "8fb18eecd6e0e177a6b670361e23e65d9c92206d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -567,11 +567,7 @@ pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,\n         visited_outermost: false,\n     };\n \n-    match *item {\n-        IIItem(i) => id_visitor.visit_item(i, ()),\n-        IIForeign(i) => id_visitor.visit_foreign_item(i, ()),\n-        IIMethod(_, _, m) => visit::walk_method_helper(&mut id_visitor, m, ()),\n-    }\n+    visit::walk_inlined_item(&mut id_visitor, item, ());\n }\n \n struct IdRangeComputingVisitor {"}, {"sha": "3ad5857395d57744865de2729914c71ccdaad749", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -634,17 +634,24 @@ impl<'a> Context<'a> {\n                                      self.ecx.expr_ident(e.span, lname)));\n         }\n \n+        // Now create a vector containing all the arguments\n+        let slicename = self.ecx.ident_of(\"__args_vec\");\n+        {\n+            let args = names.move_iter().map(|a| a.unwrap());\n+            let mut args = locals.move_iter().chain(args);\n+            let args = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n+            lets.push(self.ecx.stmt_let(self.fmtsp, false, slicename, args));\n+        }\n+\n         // Now create the fmt::Arguments struct with all our locals we created.\n-        let args = names.move_iter().map(|a| a.unwrap());\n-        let mut args = locals.move_iter().chain(args);\n         let fmt = self.ecx.expr_ident(self.fmtsp, static_name);\n-        let args = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n+        let args_slice = self.ecx.expr_ident(self.fmtsp, slicename);\n         let result = self.ecx.expr_call_global(self.fmtsp, ~[\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n                 self.ecx.ident_of(\"Arguments\"),\n                 self.ecx.ident_of(\"new\"),\n-            ], ~[fmt, args]);\n+            ], ~[fmt, args_slice]);\n \n         // We did all the work of making sure that the arguments\n         // structure is safe, so we can safely have an unsafe block."}, {"sha": "326f712d5b2124f245133ece6ffb6c0e7e2878f6", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -42,12 +42,31 @@ impl<T> OptVec<T> {\n                 v.push(t);\n                 return;\n             }\n-            Empty => {}\n+            Empty => {\n+                *self = Vec(~[t]);\n+            }\n         }\n+    }\n+\n+    pub fn pop(&mut self) -> T {\n+        match *self {\n+            Vec(ref mut v) => v.pop(),\n+            Empty => fail!(\"pop from empty opt_vec\")\n+        }\n+    }\n \n-        // FIXME(#5074): flow insensitive means we can't move\n-        // assignment inside `match`\n-        *self = Vec(~[t]);\n+    pub fn last<'a>(&'a self) -> &'a T {\n+        match *self {\n+            Vec(ref v) => v.last(),\n+            Empty => fail!(\"last on empty opt_vec\")\n+        }\n+    }\n+\n+    pub fn mut_last<'a>(&'a mut self) -> &'a mut T {\n+        match *self {\n+            Vec(ref mut v) => v.mut_last(),\n+            Empty => fail!(\"mut_last on empty opt_vec\")\n+        }\n     }\n \n     pub fn map<U>(&self, op: |&T| -> U) -> OptVec<U> {\n@@ -82,6 +101,16 @@ impl<T> OptVec<T> {\n         }\n     }\n \n+    pub fn swap_remove(&mut self, index: uint) {\n+        match *self {\n+            Empty => { fail!(\"Index out of bounds\"); }\n+            Vec(ref mut v) => {\n+                assert!(index < v.len());\n+                v.swap_remove(index);\n+            }\n+        }\n+    }\n+\n     #[inline]\n     pub fn iter<'r>(&'r self) -> OptVecIterator<'r, T> {\n         match *self {\n@@ -166,6 +195,16 @@ impl<'a, T> Iterator<&'a T> for OptVecIterator<'a, T> {\n     }\n }\n \n+impl<'a, T> DoubleEndedIterator<&'a T> for OptVecIterator<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        match self.iter {\n+            Some(ref mut x) => x.next_back(),\n+            None => None\n+        }\n+    }\n+}\n+\n impl<A> FromIterator<A> for OptVec<A> {\n     fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> OptVec<A> {\n         let mut r = Empty;"}, {"sha": "484f8dce1f745c685d4124c258c1d04949c7b392", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -121,6 +121,17 @@ pub trait Visitor<E: Clone> {\n     }\n }\n \n+pub fn walk_inlined_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                  item: &ast::InlinedItem,\n+                                                  env: E) {\n+    match *item {\n+        IIItem(i) => visitor.visit_item(i, env),\n+        IIForeign(i) => visitor.visit_foreign_item(i, env),\n+        IIMethod(_, _, m) => walk_method_helper(visitor, m, env),\n+    }\n+}\n+\n+\n pub fn walk_crate<E: Clone, V: Visitor<E>>(visitor: &mut V, crate: &Crate, env: E) {\n     visitor.visit_mod(&crate.module, crate.span, CRATE_NODE_ID, env)\n }"}, {"sha": "280df8cb10f57d9ce4018a796a95f3d118f905ae", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -522,6 +522,17 @@ extern \"C\" char *LLVMTypeToString(LLVMTypeRef Type) {\n     return strdup(os.str().data());\n }\n \n+extern \"C\" char *LLVMValueToString(LLVMValueRef Value) {\n+    std::string s;\n+    llvm::raw_string_ostream os(s);\n+    os << \"(\";\n+    unwrap<llvm::Value>(Value)->getType()->print(os);\n+    os << \":\";\n+    unwrap<llvm::Value>(Value)->print(os);\n+    os << \")\";\n+    return strdup(os.str().data());\n+}\n+\n extern \"C\" bool\n LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n     Module *Dst = unwrap(dst);"}, {"sha": "a61884d49c853727f12062ffc0cfed72d90a223c", "filename": "src/test/compile-fail/borrowck-reborrow-from-shorter-lived-andmut.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-shorter-lived-andmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-shorter-lived-andmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-shorter-lived-andmut.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that assignments to an `&mut` pointer which is found in a\n+// borrowed (but otherwise non-aliasable) location is illegal.\n+\n+struct S<'a> {\n+    pointer: &'a mut int\n+}\n+\n+fn copy_borrowed_ptr<'a,'b>(p: &'a mut S<'b>) -> S<'b> {\n+    S { pointer: &mut *p.pointer } //~ ERROR lifetime of `p` is too short to guarantee its contents can be safely reborrowed\n+}\n+\n+fn main() {\n+    let mut x = 1;\n+\n+    {\n+        let mut y = S { pointer: &mut x };\n+        let z = copy_borrowed_ptr(&mut y);\n+        *y.pointer += 1;\n+        *z.pointer += 1;\n+    }\n+}"}, {"sha": "10bef907a28a3076e89202fae9927b4d97db8bed", "filename": "src/test/compile-fail/borrowck-rvalues-mutable-bad.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/149fc76698318f8f7cdfaa37a818e347721764e7/src%2Ftest%2Fcompile-fail%2Fborrowck-rvalues-mutable-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/149fc76698318f8f7cdfaa37a818e347721764e7/src%2Ftest%2Fcompile-fail%2Fborrowck-rvalues-mutable-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-rvalues-mutable-bad.rs?ref=149fc76698318f8f7cdfaa37a818e347721764e7", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Tests that rvalue lifetimes is limited to the enclosing trans\n-// cleanup scope. It is unclear that this is the correct lifetime for\n-// rvalues, but that's what it is right now.\n-\n-struct Counter {\n-    value: uint\n-}\n-\n-impl Counter {\n-    fn new(v: uint) -> Counter {\n-        Counter {value: v}\n-    }\n-\n-    fn inc<'a>(&'a mut self) -> &'a mut Counter {\n-        self.value += 1;\n-        self\n-    }\n-\n-    fn get(&self) -> uint {\n-        self.value\n-    }\n-}\n-\n-pub fn main() {\n-    let v = Counter::new(22).inc().inc().get();\n-    //~^ ERROR borrowed value does not live long enough\n-    assert_eq!(v, 24);;\n-}"}, {"sha": "76836a441031252a05c3a57edea3c9cc9f3817e4", "filename": "src/test/compile-fail/cleanup-rvalue-scopes-cf.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Fcompile-fail%2Fcleanup-rvalue-scopes-cf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Fcompile-fail%2Fcleanup-rvalue-scopes-cf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcleanup-rvalue-scopes-cf.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the borrow checker prevents pointers to temporaries\n+// with statement lifetimes from escaping.\n+\n+#[feature(macro_rules)];\n+\n+use std::ops::Drop;\n+\n+static mut FLAGS: u64 = 0;\n+\n+struct Box<T> { f: T }\n+struct AddFlags { bits: u64 }\n+\n+fn AddFlags(bits: u64) -> AddFlags {\n+    AddFlags { bits: bits }\n+}\n+\n+fn arg<'a>(x: &'a AddFlags) -> &'a AddFlags {\n+    x\n+}\n+\n+impl AddFlags {\n+    fn get<'a>(&'a self) -> &'a AddFlags {\n+        self\n+    }\n+}\n+\n+pub fn main() {\n+    let _x = arg(&AddFlags(1)); //~ ERROR value does not live long enough\n+    let _x = AddFlags(1).get(); //~ ERROR value does not live long enough\n+    let _x = &*arg(&AddFlags(1)); //~ ERROR value does not live long enough\n+    let ref _x = *arg(&AddFlags(1)); //~ ERROR value does not live long enough\n+    let &ref _x = arg(&AddFlags(1)); //~ ERROR value does not live long enough\n+    let _x = AddFlags(1).get(); //~ ERROR value does not live long enough\n+    let Box { f: _x } = Box { f: AddFlags(1).get() }; //~ ERROR value does not live long enough\n+}"}, {"sha": "d4de4ef34d39729d821b2a535bd07741e3cc4676", "filename": "src/test/run-pass/borrowck-rvalues-mutable.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fborrowck-rvalues-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fborrowck-rvalues-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-rvalues-mutable.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -17,6 +17,15 @@ impl Counter {\n         Counter {value: v}\n     }\n \n+    fn inc<'a>(&'a mut self) -> &'a mut Counter {\n+        self.value += 1;\n+        self\n+    }\n+\n+    fn get(&self) -> uint {\n+        self.value\n+    }\n+\n     fn get_and_inc(&mut self) -> uint {\n         let v = self.value;\n         self.value += 1;\n@@ -27,4 +36,7 @@ impl Counter {\n pub fn main() {\n     let v = Counter::new(22).get_and_inc();\n     assert_eq!(v, 22);\n+\n+    let v = Counter::new(22).inc().inc().get();\n+    assert_eq!(v, 24);;\n }"}, {"sha": "c87302bc134c19905677068669dbe65cf0c97bd1", "filename": "src/test/run-pass/cleanup-arm-conditional.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fcleanup-arm-conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fcleanup-arm-conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-arm-conditional.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -0,0 +1,43 @@\n+// copyright 2013 the rust project developers. see the copyright\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/copyright.\n+//\n+// licensed under the apache license, version 2.0 <license-apache or\n+// http://www.apache.org/licenses/license-2.0> or the mit license\n+// <license-mit or http://opensource.org/licenses/mit>, at your\n+// option. this file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that cleanup scope for temporaries created in a match\n+// arm is confined to the match arm itself.\n+\n+use std::{os, run};\n+use std::io::process;\n+\n+struct Test { x: int }\n+\n+impl Test {\n+    fn get_x(&self) -> Option<~int> {\n+        Some(~self.x)\n+    }\n+}\n+\n+fn do_something(t: &Test) -> int {\n+\n+    // The cleanup scope for the result of `t.get_x()` should be the\n+    // arm itself and not the match, otherwise we'll (potentially) get\n+    // a crash trying to free an uninitialized stack slot.\n+\n+    match t {\n+        &Test { x: 2 } if t.get_x().is_some() => {\n+            t.x * 2\n+        }\n+        _ => { 22 }\n+    }\n+}\n+\n+pub fn main() {\n+    let t = Test { x: 1 };\n+    do_something(&t);\n+}\n+"}, {"sha": "937b3f81eafa52137a825fa9d5d32f17dc63d608", "filename": "src/test/run-pass/cleanup-rvalue-scopes.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -0,0 +1,138 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that destructors for rvalue temporaries run either at end of\n+// statement or end of block, as appropriate given the temporary\n+// lifetime rules.\n+\n+#[feature(macro_rules)];\n+\n+use std::ops::Drop;\n+\n+static mut FLAGS: u64 = 0;\n+\n+struct Box<T> { f: T }\n+struct AddFlags { bits: u64 }\n+\n+fn AddFlags(bits: u64) -> AddFlags {\n+    AddFlags { bits: bits }\n+}\n+\n+fn arg(exp: u64, _x: &AddFlags) {\n+    check_flags(exp);\n+}\n+\n+fn pass<T>(v: T) -> T {\n+    v\n+}\n+\n+fn check_flags(exp: u64) {\n+    unsafe {\n+        let x = FLAGS;\n+        FLAGS = 0;\n+        println!(\"flags {}, expected {}\", x, exp);\n+        assert_eq!(x, exp);\n+    }\n+}\n+\n+impl AddFlags {\n+    fn check_flags<'a>(&'a self, exp: u64) -> &'a AddFlags {\n+        check_flags(exp);\n+        self\n+    }\n+\n+    fn bits(&self) -> u64 {\n+        self.bits\n+    }\n+}\n+\n+impl Drop for AddFlags {\n+    fn drop(&mut self) {\n+        unsafe {\n+            FLAGS = FLAGS + self.bits;\n+        }\n+    }\n+}\n+\n+macro_rules! end_of_block(\n+    ($pat:pat, $expr:expr) => (\n+        {\n+            println!(\"end_of_block({})\", stringify!({let $pat = $expr;}));\n+\n+            {\n+                // Destructor here does not run until exit from the block,\n+                // because value is assigned to.\n+                let $pat = $expr;\n+                check_flags(0);\n+            }\n+            check_flags(1);\n+        }\n+    )\n+)\n+\n+macro_rules! end_of_stmt(\n+    ($pat:pat, $expr:expr) => (\n+        {\n+            println!(\"end_of_stmt({})\", stringify!($expr));\n+\n+            {\n+                // Destructor here does not run until exit from the block,\n+                // because value is assigned to.\n+                let $pat = $expr;\n+                check_flags(1);\n+            }\n+\n+            check_flags(0);\n+        }\n+    )\n+)\n+\n+pub fn main() {\n+\n+    // In all these cases, we trip over the rules designed to cover\n+    // the case where we are taking addr of rvalue and storing that\n+    // addr into a stack slot, either via `let ref` or via a `&` in\n+    // the initializer.\n+\n+    end_of_block!(_x, AddFlags(1));\n+    end_of_block!(_x, &AddFlags(1));\n+    end_of_block!(_x, & &AddFlags(1));\n+    end_of_block!(_x, Box { f: AddFlags(1) });\n+    end_of_block!(_x, Box { f: &AddFlags(1) });\n+    end_of_block!(_x, Box { f: &AddFlags(1) });\n+    end_of_block!(_x, pass(AddFlags(1)));\n+    end_of_block!(ref _x, AddFlags(1));\n+    end_of_block!(AddFlags { bits: ref _x }, AddFlags(1));\n+    end_of_block!(&AddFlags { bits }, &AddFlags(1));\n+    end_of_block!((_, ref _y), (AddFlags(1), 22));\n+    end_of_block!(~ref _x, ~AddFlags(1));\n+    end_of_block!(~_x, ~AddFlags(1));\n+    end_of_block!(_, { { check_flags(0); &AddFlags(1) } });\n+    end_of_block!(_, &((Box { f: AddFlags(1) }).f));\n+    end_of_block!(_, &(([AddFlags(1)])[0]));\n+    end_of_block!(_, &((&~[AddFlags(1)])[0]));\n+\n+    // LHS does not create a ref binding, so temporary lives as long\n+    // as statement, and we do not move the AddFlags out:\n+    end_of_stmt!(_, AddFlags(1));\n+    end_of_stmt!((_, _), (AddFlags(1), 22));\n+\n+    // `&` operator appears inside an arg to a function,\n+    // so it is not prolonged:\n+    end_of_stmt!(ref _x, arg(0, &AddFlags(1)));\n+\n+    // autoref occurs inside receiver, so temp lifetime is not\n+    // prolonged:\n+    end_of_stmt!(ref _x, AddFlags(1).check_flags(0).bits());\n+\n+    // No reference is created on LHS, thus RHS is moved into\n+    // a temporary that lives just as long as the statement.\n+    end_of_stmt!(AddFlags { bits }, AddFlags(1));\n+}"}, {"sha": "53a009ecc135915419793c310fec0e8ab51647a8", "filename": "src/test/run-pass/cleanup-rvalue-temp-during-incomplete-alloc.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -0,0 +1,39 @@\n+// Test cleanup of rvalue temporary that occurs while `~` construction\n+// is in progress. This scenario revealed a rather terrible bug.  The\n+// ingredients are:\n+//\n+// 1. Partial cleanup of `~` is in scope,\n+// 2. cleanup of return value from `get_bar()` is in scope,\n+// 3. do_it() fails.\n+//\n+// This led to a bug because `the top-most frame that was to be\n+// cleaned (which happens to be the partial cleanup of `~`) required\n+// multiple basic blocks, which led to us dropping part of the cleanup\n+// from the top-most frame.\n+//\n+// It's unclear how likely such a bug is to recur, but it seems like a\n+// scenario worth testing.\n+\n+use std::task;\n+\n+enum Conzabble {\n+    Bickwick(Foo)\n+}\n+\n+struct Foo { field: ~uint }\n+\n+fn do_it(x: &[uint]) -> Foo {\n+    fail!()\n+}\n+\n+fn get_bar(x: uint) -> ~[uint] { ~[x * 2] }\n+\n+pub fn fails() {\n+    let x = 2;\n+    let mut y = ~[];\n+    y.push(~Bickwick(do_it(get_bar(x))));\n+}\n+\n+pub fn main() {\n+    task::try(fails);\n+}"}, {"sha": "f6eeb5a37e6a64454bebd79ba7d9a05fd7597e24", "filename": "src/test/run-pass/cleanup-shortcircuit.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -0,0 +1,30 @@\n+// copyright 2013 the rust project developers. see the copyright\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/copyright.\n+//\n+// licensed under the apache license, version 2.0 <license-apache or\n+// http://www.apache.org/licenses/license-2.0> or the mit license\n+// <license-mit or http://opensource.org/licenses/mit>, at your\n+// option. this file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that cleanups for the RHS of shorcircuiting operators work.\n+\n+use std::{os, run};\n+use std::io::process;\n+\n+pub fn main() {\n+    let args = os::args();\n+\n+    // Here, the rvalue `~\"signal\"` requires cleanup. Older versions\n+    // of the code had a problem that the cleanup scope for this\n+    // expression was the end of the `if`, and as the `~\"signal\"`\n+    // expression was never evaluated, we wound up trying to clean\n+    // uninitialized memory.\n+\n+    if args.len() >= 2 && args[1] == ~\"signal\" {\n+        // Raise a segfault.\n+        unsafe { *(0 as *mut int) = 0; }\n+    }\n+}\n+"}, {"sha": "f42d5ff2e5267b00f48951111397e486b2471f6a", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -8,20 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n+use std::cast::transmute;\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n+        pub fn init<T>() -> T;\n         pub fn move_val_init<T>(dst: &mut T, src: T);\n-        pub fn move_val<T>(dst: &mut T, src: T);\n     }\n }\n \n pub fn main() {\n     unsafe {\n-        let x = @1;\n-        let mut y = @2;\n-        rusti::move_val(&mut y, x);\n+        let x = ~1;\n+        let mut y = rusti::init();\n+        let mut z: *uint = transmute(&x);\n+        rusti::move_val_init(&mut y, x);\n         assert_eq!(*y, 1);\n+        assert_eq!(*z, 0); // `x` is nulled out, not directly visible\n     }\n }"}, {"sha": "4d5ed9f701a394ea85353d0478bc8c84e74b1a32", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -30,10 +30,10 @@ pub fn main () {\n \n     let config = process::ProcessConfig {\n         program : args[0].as_slice(),\n-        args : [~\"child\"],\n+        args : &[~\"child\"],\n         env : None,\n         cwd : None,\n-        io : []\n+        io : &[]\n     };\n \n     let mut p = process::Process::new(config).unwrap();"}, {"sha": "f6bbd8ebef86a68931626115809893873bafa1a3", "filename": "src/test/run-pass/issue-9382.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9382.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -28,10 +28,10 @@ struct Thing2<'a> {\n \n pub fn main() {\n     let _t1_fixed = Thing1 {\n-        baz: [],\n+        baz: &[],\n         bar: ~32,\n     };\n-    let _t1_uniq = Thing1 {\n+    Thing1 {\n         baz: ~[],\n         bar: ~32,\n     };\n@@ -40,10 +40,10 @@ pub fn main() {\n         bar: ~32,\n     };\n     let _t2_fixed = Thing2 {\n-        baz: [],\n+        baz: &[],\n         bar: 32,\n     };\n-    let _t2_uniq = Thing2 {\n+    Thing2 {\n         baz: ~[],\n         bar: 32,\n     };"}, {"sha": "983c701d820319874dcda2080801f016112b040c", "filename": "src/test/run-pass/move-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fmove-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419ac4a1b899ba88fb360b4c71c08f3610564cd4/src%2Ftest%2Frun-pass%2Fmove-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-1.rs?ref=419ac4a1b899ba88fb360b4c71c08f3610564cd4", "patch": "@@ -15,6 +15,7 @@ struct Triple { x: int, y: int, z: int }\n fn test(x: bool, foo: @Triple) -> int {\n     let bar = foo;\n     let mut y: @Triple;\n+    y = bar;\n     if x { y = bar; } else { y = @Triple{x: 4, y: 5, z: 6}; }\n     return y.y;\n }"}]}