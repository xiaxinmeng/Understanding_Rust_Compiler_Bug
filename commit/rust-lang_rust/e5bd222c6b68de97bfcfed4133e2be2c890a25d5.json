{"sha": "e5bd222c6b68de97bfcfed4133e2be2c890a25d5", "node_id": "C_kwDOAAsO6NoAKGU1YmQyMjJjNmI2OGRlOTdiZmNmZWQ0MTMzZTJiZTJjODkwYTI1ZDU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-25T06:30:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-25T06:30:49Z"}, "message": "Rollup merge of #94184 - ssomers:btree_tests, r=Dylan-DPC\n\nBTree: simplify test code\n\nMostly, use `from` & `from_iter`.", "tree": {"sha": "7c05e2262db3ff79efd94882f826344043f59c87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c05e2262db3ff79efd94882f826344043f59c87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5bd222c6b68de97bfcfed4133e2be2c890a25d5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiGHeaCRBK7hj4Ov3rIwAA4I0IAH9ZtvfJyFhnYl5biaJivEb2\ncVLtUEt9i38EO6MVfUDTCau/8RBNe+mo65VB/oxaSIKDgYzgmKoksJCGn6rJrxqh\nbiiSRpcyp9d/2U4R3OzNwLRT0L52X4x0k9yUHvGdCy8ldsw1OlakIyv48MQx41ZT\nqB/4ixgzdWc9tIA6zcQxYH7Hy8J/1gT26MdoQNSuObIWIP3ZRQQr1kVSgZWf/XEU\npz3Yh+QtfKOdQEeySCzmJpiPpsK6yHuOe8C+atuzYzWS1Up9XlUErT4E1uXJH/Ni\nOj4XkczbD7i8qdlnM95JYRhFyDxdOgjrFjdl+4J6/vctrzaTw8kC0fEaW+rOpeo=\n=cQ/E\n-----END PGP SIGNATURE-----\n", "payload": "tree 7c05e2262db3ff79efd94882f826344043f59c87\nparent 10070118add69bd55d8cb0bec574b4dc920c3531\nparent 7950ebcd8e40b27ed1b4952833970e570b0bb44a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645770649 +0100\ncommitter GitHub <noreply@github.com> 1645770649 +0100\n\nRollup merge of #94184 - ssomers:btree_tests, r=Dylan-DPC\n\nBTree: simplify test code\n\nMostly, use `from` & `from_iter`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5bd222c6b68de97bfcfed4133e2be2c890a25d5", "html_url": "https://github.com/rust-lang/rust/commit/e5bd222c6b68de97bfcfed4133e2be2c890a25d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5bd222c6b68de97bfcfed4133e2be2c890a25d5/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10070118add69bd55d8cb0bec574b4dc920c3531", "url": "https://api.github.com/repos/rust-lang/rust/commits/10070118add69bd55d8cb0bec574b4dc920c3531", "html_url": "https://github.com/rust-lang/rust/commit/10070118add69bd55d8cb0bec574b4dc920c3531"}, {"sha": "7950ebcd8e40b27ed1b4952833970e570b0bb44a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7950ebcd8e40b27ed1b4952833970e570b0bb44a", "html_url": "https://github.com/rust-lang/rust/commit/7950ebcd8e40b27ed1b4952833970e570b0bb44a"}], "stats": {"total": 256, "additions": 118, "deletions": 138}, "files": [{"sha": "65468d5fe57166222a53de3fb2ce0efce3dc64ec", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 89, "deletions": 108, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/e5bd222c6b68de97bfcfed4133e2be2c890a25d5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5bd222c6b68de97bfcfed4133e2be2c890a25d5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=e5bd222c6b68de97bfcfed4133e2be2c890a25d5", "patch": "@@ -17,14 +17,10 @@ use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n \n-// Capacity of a tree with a single level,\n-// i.e., a tree who's root is a leaf node at height 0.\n-const NODE_CAPACITY: usize = node::CAPACITY;\n-\n // Minimum number of elements to insert, to guarantee a tree with 2 levels,\n // i.e., a tree who's root is an internal node at height 1, with edges to leaf nodes.\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n-const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n+const MIN_INSERTS_HEIGHT_1: usize = node::CAPACITY + 1;\n \n // Minimum number of elements to insert in ascending order, to guarantee a tree with 3 levels,\n // i.e., a tree who's root is an internal node at height 2, with edges to more internal nodes.\n@@ -180,7 +176,7 @@ fn test_levels() {\n #[should_panic]\n fn test_check_ord_chaos() {\n     let gov = Governor::new();\n-    let map: BTreeMap<_, _> = (0..2).map(|i| (Governed(i, &gov), ())).collect();\n+    let map = BTreeMap::from([(Governed(1, &gov), ()), (Governed(2, &gov), ())]);\n     gov.flip();\n     map.check();\n }\n@@ -189,7 +185,7 @@ fn test_check_ord_chaos() {\n #[test]\n fn test_check_invariants_ord_chaos() {\n     let gov = Governor::new();\n-    let map: BTreeMap<_, _> = (0..2).map(|i| (Governed(i, &gov), ())).collect();\n+    let map = BTreeMap::from([(Governed(1, &gov), ()), (Governed(2, &gov), ())]);\n     gov.flip();\n     map.check_invariants();\n }\n@@ -337,8 +333,7 @@ fn test_basic_small() {\n fn test_iter() {\n     // Miri is too slow\n     let size = if cfg!(miri) { 200 } else { 10000 };\n-\n-    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     fn test<T>(size: usize, mut iter: T)\n     where\n@@ -360,8 +355,7 @@ fn test_iter() {\n fn test_iter_rev() {\n     // Miri is too slow\n     let size = if cfg!(miri) { 200 } else { 10000 };\n-\n-    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     fn test<T>(size: usize, mut iter: T)\n     where\n@@ -386,7 +380,7 @@ where\n     <T as TryFrom<usize>>::Error: Debug,\n {\n     let zero = T::try_from(0).unwrap();\n-    let mut map: BTreeMap<T, T> = (0..size).map(|i| (T::try_from(i).unwrap(), zero)).collect();\n+    let mut map = BTreeMap::from_iter((0..size).map(|i| (T::try_from(i).unwrap(), zero)));\n \n     // Forward and backward iteration sees enough pairs (also tested elsewhere)\n     assert_eq!(map.iter_mut().count(), size);\n@@ -452,7 +446,7 @@ fn test_iter_mut_mutation() {\n \n #[test]\n fn test_values_mut() {\n-    let mut a: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    let mut a = BTreeMap::from_iter((0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)));\n     test_all_refs(&mut 13, a.values_mut());\n     a.check();\n }\n@@ -467,14 +461,14 @@ fn test_values_mut_mutation() {\n         value.push_str(\"!\");\n     }\n \n-    let values: Vec<String> = a.values().cloned().collect();\n+    let values = Vec::from_iter(a.values().cloned());\n     assert_eq!(values, [String::from(\"hello!\"), String::from(\"goodbye!\")]);\n     a.check();\n }\n \n #[test]\n fn test_iter_entering_root_twice() {\n-    let mut map: BTreeMap<_, _> = (0..2).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from([(0, 0), (1, 1)]);\n     let mut it = map.iter_mut();\n     let front = it.next().unwrap();\n     let back = it.next_back().unwrap();\n@@ -491,7 +485,7 @@ fn test_iter_entering_root_twice() {\n \n #[test]\n fn test_iter_descending_to_same_node_twice() {\n-    let mut map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from_iter((0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i)));\n     let mut it = map.iter_mut();\n     // Descend into first child.\n     let front = it.next().unwrap();\n@@ -509,7 +503,7 @@ fn test_iter_mixed() {\n     // Miri is too slow\n     let size = if cfg!(miri) { 200 } else { 10000 };\n \n-    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     fn test<T>(size: usize, mut iter: T)\n     where\n@@ -569,21 +563,19 @@ fn test_iter_min_max() {\n }\n \n fn range_keys(map: &BTreeMap<i32, i32>, range: impl RangeBounds<i32>) -> Vec<i32> {\n-    map.range(range)\n-        .map(|(&k, &v)| {\n-            assert_eq!(k, v);\n-            k\n-        })\n-        .collect()\n+    Vec::from_iter(map.range(range).map(|(&k, &v)| {\n+        assert_eq!(k, v);\n+        k\n+    }))\n }\n \n #[test]\n fn test_range_small() {\n     let size = 4;\n \n-    let map: BTreeMap<_, _> = (1..=size).map(|i| (i, i)).collect();\n-    let all: Vec<_> = (1..=size).collect();\n+    let all = Vec::from_iter(1..=size);\n     let (first, last) = (vec![all[0]], vec![all[size as usize - 1]]);\n+    let map = BTreeMap::from_iter(all.iter().copied().map(|i| (i, i)));\n \n     assert_eq!(range_keys(&map, (Excluded(0), Excluded(size + 1))), all);\n     assert_eq!(range_keys(&map, (Excluded(0), Included(size + 1))), all);\n@@ -638,10 +630,9 @@ fn test_range_small() {\n \n #[test]\n fn test_range_height_1() {\n-    // Tests tree with a root and 2 leaves. The single key in the root node is\n-    // close to the middle among the keys.\n-\n-    let map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n+    // Tests tree with a root and 2 leaves. We test around the middle of the\n+    // keys because one of those is the single key in the root node.\n+    let map = BTreeMap::from_iter((0..MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)));\n     let middle = MIN_INSERTS_HEIGHT_1 as i32 / 2;\n     for root in middle - 2..=middle + 2 {\n         assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n@@ -660,9 +651,9 @@ fn test_range_height_1() {\n fn test_range_large() {\n     let size = 200;\n \n-    let map: BTreeMap<_, _> = (1..=size).map(|i| (i, i)).collect();\n-    let all: Vec<_> = (1..=size).collect();\n+    let all = Vec::from_iter(1..=size);\n     let (first, last) = (vec![all[0]], vec![all[size as usize - 1]]);\n+    let map = BTreeMap::from_iter(all.iter().copied().map(|i| (i, i)));\n \n     assert_eq!(range_keys(&map, (Excluded(0), Excluded(size + 1))), all);\n     assert_eq!(range_keys(&map, (Excluded(0), Included(size + 1))), all);\n@@ -715,9 +706,7 @@ fn test_range_large() {\n         L: IntoIterator<Item = (&'a i32, &'a i32)>,\n         R: IntoIterator<Item = (&'a i32, &'a i32)>,\n     {\n-        let lhs: Vec<_> = lhs.into_iter().collect();\n-        let rhs: Vec<_> = rhs.into_iter().collect();\n-        assert_eq!(lhs, rhs);\n+        assert_eq!(Vec::from_iter(lhs), Vec::from_iter(rhs));\n     }\n \n     check(map.range(..=100), map.range(..101));\n@@ -728,50 +717,49 @@ fn test_range_large() {\n #[test]\n fn test_range_inclusive_max_value() {\n     let max = usize::MAX;\n-    let map: BTreeMap<_, _> = [(max, 0)].into_iter().collect();\n-\n-    assert_eq!(map.range(max..=max).collect::<Vec<_>>(), &[(&max, &0)]);\n+    let map = BTreeMap::from([(max, 0)]);\n+    assert_eq!(Vec::from_iter(map.range(max..=max)), &[(&max, &0)]);\n }\n \n #[test]\n fn test_range_equal_empty_cases() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     assert_eq!(map.range((Included(2), Excluded(2))).next(), None);\n     assert_eq!(map.range((Excluded(2), Included(2))).next(), None);\n }\n \n #[test]\n #[should_panic]\n fn test_range_equal_excluded() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     let _ = map.range((Excluded(2), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_1() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     let _ = map.range((Included(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_2() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     let _ = map.range((Included(3), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_3() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     let _ = map.range((Excluded(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_4() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     let _ = map.range((Excluded(3), Excluded(2)));\n }\n \n@@ -823,15 +811,15 @@ fn test_range_finding_ill_order_in_range_ord() {\n         }\n     }\n \n-    let map = (0..12).map(|i| (CompositeKey(i, EvilTwin(i)), ())).collect::<BTreeMap<_, _>>();\n+    let map = BTreeMap::from_iter((0..12).map(|i| (CompositeKey(i, EvilTwin(i)), ())));\n     let _ = map.range(EvilTwin(5)..=EvilTwin(7));\n }\n \n #[test]\n fn test_range_1000() {\n     // Miri is too slow\n     let size = if cfg!(miri) { MIN_INSERTS_HEIGHT_2 as u32 } else { 1000 };\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n         let mut kvs = map.range((min, max)).map(|(&k, &v)| (k, v));\n@@ -870,7 +858,7 @@ fn test_range() {\n     let size = 200;\n     // Miri is too slow\n     let step = if cfg!(miri) { 66 } else { 1 };\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     for i in (0..size).step_by(step) {\n         for j in (i..size).step_by(step) {\n@@ -891,7 +879,7 @@ fn test_range_mut() {\n     let size = 200;\n     // Miri is too slow\n     let step = if cfg!(miri) { 66 } else { 1 };\n-    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     for i in (0..size).step_by(step) {\n         for j in (i..size).step_by(step) {\n@@ -910,7 +898,7 @@ fn test_range_mut() {\n \n #[test]\n fn test_retain() {\n-    let mut map: BTreeMap<i32, i32> = (0..100).map(|x| (x, x * 10)).collect();\n+    let mut map = BTreeMap::from_iter((0..100).map(|x| (x, x * 10)));\n \n     map.retain(|&k, _| k % 2 == 0);\n     assert_eq!(map.len(), 50);\n@@ -934,7 +922,7 @@ mod test_drain_filter {\n     #[test]\n     fn consumed_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         assert!(map.drain_filter(|_, _| false).eq(iter::empty()));\n         map.check();\n     }\n@@ -943,7 +931,7 @@ mod test_drain_filter {\n     #[test]\n     fn consumed_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+        let mut map = BTreeMap::from_iter(pairs.clone());\n         assert!(map.drain_filter(|_, _| true).eq(pairs));\n         assert!(map.is_empty());\n         map.check();\n@@ -953,7 +941,7 @@ mod test_drain_filter {\n     #[test]\n     fn mutating_and_keeping() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         assert!(\n             map.drain_filter(|_, v| {\n                 *v += 6;\n@@ -970,7 +958,7 @@ mod test_drain_filter {\n     #[test]\n     fn mutating_and_removing() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         assert!(\n             map.drain_filter(|_, v| {\n                 *v += 6;\n@@ -985,7 +973,7 @@ mod test_drain_filter {\n     #[test]\n     fn underfull_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| false);\n         assert!(map.keys().copied().eq(0..3));\n         map.check();\n@@ -995,7 +983,7 @@ mod test_drain_filter {\n     fn underfull_removing_one() {\n         let pairs = (0..3).map(|i| (i, i));\n         for doomed in 0..3 {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i == doomed);\n             assert_eq!(map.len(), 2);\n             map.check();\n@@ -1006,7 +994,7 @@ mod test_drain_filter {\n     fn underfull_keeping_one() {\n         let pairs = (0..3).map(|i| (i, i));\n         for sacred in 0..3 {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n@@ -1016,37 +1004,37 @@ mod test_drain_filter {\n     #[test]\n     fn underfull_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n         map.check();\n     }\n \n     #[test]\n     fn height_0_keeping_all() {\n-        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let pairs = (0..node::CAPACITY).map(|i| (i, i));\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| false);\n-        assert!(map.keys().copied().eq(0..NODE_CAPACITY));\n+        assert!(map.keys().copied().eq(0..node::CAPACITY));\n         map.check();\n     }\n \n     #[test]\n     fn height_0_removing_one() {\n-        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n-        for doomed in 0..NODE_CAPACITY {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+        let pairs = (0..node::CAPACITY).map(|i| (i, i));\n+        for doomed in 0..node::CAPACITY {\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i == doomed);\n-            assert_eq!(map.len(), NODE_CAPACITY - 1);\n+            assert_eq!(map.len(), node::CAPACITY - 1);\n             map.check();\n         }\n     }\n \n     #[test]\n     fn height_0_keeping_one() {\n-        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n-        for sacred in 0..NODE_CAPACITY {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+        let pairs = (0..node::CAPACITY).map(|i| (i, i));\n+        for sacred in 0..node::CAPACITY {\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n@@ -1055,16 +1043,16 @@ mod test_drain_filter {\n \n     #[test]\n     fn height_0_removing_all() {\n-        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let pairs = (0..node::CAPACITY).map(|i| (i, i));\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n         map.check();\n     }\n \n     #[test]\n     fn height_0_keeping_half() {\n-        let mut map: BTreeMap<_, _> = (0..16).map(|i| (i, i)).collect();\n+        let mut map = BTreeMap::from_iter((0..16).map(|i| (i, i)));\n         assert_eq!(map.drain_filter(|i, _| *i % 2 == 0).count(), 8);\n         assert_eq!(map.len(), 8);\n         map.check();\n@@ -1073,7 +1061,7 @@ mod test_drain_filter {\n     #[test]\n     fn height_1_removing_all() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n         map.check();\n@@ -1083,7 +1071,7 @@ mod test_drain_filter {\n     fn height_1_removing_one() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n         for doomed in 0..MIN_INSERTS_HEIGHT_1 {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i == doomed);\n             assert_eq!(map.len(), MIN_INSERTS_HEIGHT_1 - 1);\n             map.check();\n@@ -1094,7 +1082,7 @@ mod test_drain_filter {\n     fn height_1_keeping_one() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n         for sacred in 0..MIN_INSERTS_HEIGHT_1 {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n@@ -1105,7 +1093,7 @@ mod test_drain_filter {\n     fn height_2_removing_one() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         for doomed in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i == doomed);\n             assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n             map.check();\n@@ -1116,7 +1104,7 @@ mod test_drain_filter {\n     fn height_2_keeping_one() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         for sacred in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n@@ -1126,7 +1114,7 @@ mod test_drain_filter {\n     #[test]\n     fn height_2_removing_all() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n         map.check();\n@@ -1287,7 +1275,7 @@ fn test_borrow() {\n fn test_entry() {\n     let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n-    let mut map: BTreeMap<_, _> = xs.iter().cloned().collect();\n+    let mut map = BTreeMap::from(xs);\n \n     // Existing key (insert)\n     match map.entry(1) {\n@@ -1415,7 +1403,7 @@ fn test_bad_zst() {\n #[test]\n fn test_clear() {\n     let mut map = BTreeMap::new();\n-    for &len in &[MIN_INSERTS_HEIGHT_1, MIN_INSERTS_HEIGHT_2, 0, NODE_CAPACITY] {\n+    for &len in &[MIN_INSERTS_HEIGHT_1, MIN_INSERTS_HEIGHT_2, 0, node::CAPACITY] {\n         for i in 0..len {\n             map.insert(i, ());\n         }\n@@ -1485,7 +1473,7 @@ fn test_clone() {\n     }\n \n     // Test a tree with 2 semi-full levels and a tree with 3 levels.\n-    map = (1..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    map = BTreeMap::from_iter((1..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)));\n     assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n     assert_eq!(map, map.clone());\n     map.insert(0, 0);\n@@ -1496,14 +1484,11 @@ fn test_clone() {\n \n fn test_clone_panic_leak(size: usize) {\n     for i in 0..size {\n-        let dummies: Vec<CrashTestDummy> = (0..size).map(|id| CrashTestDummy::new(id)).collect();\n-        let map: BTreeMap<_, ()> = dummies\n-            .iter()\n-            .map(|dummy| {\n-                let panic = if dummy.id == i { Panic::InClone } else { Panic::Never };\n-                (dummy.spawn(panic), ())\n-            })\n-            .collect();\n+        let dummies = Vec::from_iter((0..size).map(|id| CrashTestDummy::new(id)));\n+        let map = BTreeMap::from_iter(dummies.iter().map(|dummy| {\n+            let panic = if dummy.id == i { Panic::InClone } else { Panic::Never };\n+            (dummy.spawn(panic), ())\n+        }));\n \n         catch_unwind(|| map.clone()).unwrap_err();\n         for d in &dummies {\n@@ -1864,24 +1849,24 @@ fn test_first_last_entry() {\n \n #[test]\n fn test_insert_into_full_height_0() {\n-    let size = NODE_CAPACITY;\n+    let size = node::CAPACITY;\n     for pos in 0..=size {\n-        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i * 2 + 1, ())).collect();\n+        let mut map = BTreeMap::from_iter((0..size).map(|i| (i * 2 + 1, ())));\n         assert!(map.insert(pos * 2, ()).is_none());\n         map.check();\n     }\n }\n \n #[test]\n fn test_insert_into_full_height_1() {\n-    let size = NODE_CAPACITY + 1 + NODE_CAPACITY;\n+    let size = node::CAPACITY + 1 + node::CAPACITY;\n     for pos in 0..=size {\n-        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i * 2 + 1, ())).collect();\n+        let mut map = BTreeMap::from_iter((0..size).map(|i| (i * 2 + 1, ())));\n         map.compact();\n         let root_node = map.root.as_ref().unwrap().reborrow();\n         assert_eq!(root_node.len(), 1);\n-        assert_eq!(root_node.first_leaf_edge().into_node().len(), NODE_CAPACITY);\n-        assert_eq!(root_node.last_leaf_edge().into_node().len(), NODE_CAPACITY);\n+        assert_eq!(root_node.first_leaf_edge().into_node().len(), node::CAPACITY);\n+        assert_eq!(root_node.last_leaf_edge().into_node().len(), node::CAPACITY);\n \n         assert!(map.insert(pos * 2, ()).is_none());\n         map.check();\n@@ -2022,7 +2007,7 @@ fn test_split_off_empty_left() {\n #[test]\n fn test_split_off_tiny_left_height_2() {\n     let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n-    let mut left: BTreeMap<_, _> = pairs.clone().collect();\n+    let mut left = BTreeMap::from_iter(pairs.clone());\n     let right = left.split_off(&1);\n     left.check();\n     right.check();\n@@ -2038,7 +2023,7 @@ fn test_split_off_tiny_left_height_2() {\n fn test_split_off_tiny_right_height_2() {\n     let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n     let last = MIN_INSERTS_HEIGHT_2 - 1;\n-    let mut left: BTreeMap<_, _> = pairs.clone().collect();\n+    let mut left = BTreeMap::from_iter(pairs.clone());\n     assert_eq!(*left.last_key_value().unwrap().0, last);\n     let right = left.split_off(&last);\n     left.check();\n@@ -2052,7 +2037,7 @@ fn test_split_off_tiny_right_height_2() {\n #[test]\n fn test_split_off_halfway() {\n     let mut rng = DeterministicRng::new();\n-    for &len in &[NODE_CAPACITY, 25, 50, 75, 100] {\n+    for &len in &[node::CAPACITY, 25, 50, 75, 100] {\n         let mut data = Vec::from_iter((0..len).map(|_| (rng.next(), ())));\n         // Insertion in non-ascending order creates some variation in node length.\n         let mut map = BTreeMap::from_iter(data.iter().copied());\n@@ -2112,13 +2097,11 @@ fn test_into_iter_drop_leak_height_0() {\n fn test_into_iter_drop_leak_height_1() {\n     let size = MIN_INSERTS_HEIGHT_1;\n     for panic_point in vec![0, 1, size - 2, size - 1] {\n-        let dummies: Vec<_> = (0..size).map(|i| CrashTestDummy::new(i)).collect();\n-        let map: BTreeMap<_, _> = (0..size)\n-            .map(|i| {\n-                let panic = if i == panic_point { Panic::InDrop } else { Panic::Never };\n-                (dummies[i].spawn(Panic::Never), dummies[i].spawn(panic))\n-            })\n-            .collect();\n+        let dummies = Vec::from_iter((0..size).map(|i| CrashTestDummy::new(i)));\n+        let map = BTreeMap::from_iter((0..size).map(|i| {\n+            let panic = if i == panic_point { Panic::InDrop } else { Panic::Never };\n+            (dummies[i].spawn(Panic::Never), dummies[i].spawn(panic))\n+        }));\n         catch_unwind(move || drop(map.into_iter())).unwrap_err();\n         for i in 0..size {\n             assert_eq!(dummies[i].dropped(), 2);\n@@ -2128,9 +2111,8 @@ fn test_into_iter_drop_leak_height_1() {\n \n #[test]\n fn test_into_keys() {\n-    let vec = [(1, 'a'), (2, 'b'), (3, 'c')];\n-    let map: BTreeMap<_, _> = vec.into_iter().collect();\n-    let keys: Vec<_> = map.into_keys().collect();\n+    let map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let keys = Vec::from_iter(map.into_keys());\n \n     assert_eq!(keys.len(), 3);\n     assert!(keys.contains(&1));\n@@ -2140,9 +2122,8 @@ fn test_into_keys() {\n \n #[test]\n fn test_into_values() {\n-    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-    let map: BTreeMap<_, _> = vec.into_iter().collect();\n-    let values: Vec<_> = map.into_values().collect();\n+    let map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let values = Vec::from_iter(map.into_values());\n \n     assert_eq!(values.len(), 3);\n     assert!(values.contains(&'a'));"}, {"sha": "3031bf86a7be154a3030a42860bc04adab929344", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5bd222c6b68de97bfcfed4133e2be2c890a25d5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5bd222c6b68de97bfcfed4133e2be2c890a25d5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=e5bd222c6b68de97bfcfed4133e2be2c890a25d5", "patch": "@@ -1539,7 +1539,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (a_len, b_len) = self.0.lens();\n         // No checked_add, because even if a and b refer to the same set,\n-        // and T is an empty type, the storage overhead of sets limits\n+        // and T is a zero-sized type, the storage overhead of sets limits\n         // the number of elements to less than half the range of usize.\n         (0, Some(a_len + b_len))\n     }"}, {"sha": "7865d37ae51f1cde0a29e538d1496c980e3c4d24", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e5bd222c6b68de97bfcfed4133e2be2c890a25d5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5bd222c6b68de97bfcfed4133e2be2c890a25d5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=e5bd222c6b68de97bfcfed4133e2be2c890a25d5", "patch": "@@ -91,7 +91,7 @@ fn test_intersection() {\n         return;\n     }\n \n-    let large = (0..100).collect::<Vec<_>>();\n+    let large = Vec::from_iter(0..100);\n     check_intersection(&[], &large, &[]);\n     check_intersection(&large, &[], &[]);\n     check_intersection(&[-1], &large, &[]);\n@@ -107,8 +107,8 @@ fn test_intersection() {\n \n #[test]\n fn test_intersection_size_hint() {\n-    let x: BTreeSet<i32> = [3, 4].iter().copied().collect();\n-    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let x = BTreeSet::from([3, 4]);\n+    let y = BTreeSet::from([1, 2, 3]);\n     let mut iter = x.intersection(&y);\n     assert_eq!(iter.size_hint(), (1, Some(1)));\n     assert_eq!(iter.next(), Some(&3));\n@@ -145,7 +145,7 @@ fn test_difference() {\n         return;\n     }\n \n-    let large = (0..100).collect::<Vec<_>>();\n+    let large = Vec::from_iter(0..100);\n     check_difference(&[], &large, &[]);\n     check_difference(&[-1], &large, &[-1]);\n     check_difference(&[0], &large, &[]);\n@@ -159,43 +159,43 @@ fn test_difference() {\n \n #[test]\n fn test_difference_size_hint() {\n-    let s246: BTreeSet<i32> = [2, 4, 6].iter().copied().collect();\n-    let s23456: BTreeSet<i32> = (2..=6).collect();\n+    let s246 = BTreeSet::from([2, 4, 6]);\n+    let s23456 = BTreeSet::from_iter(2..=6);\n     let mut iter = s246.difference(&s23456);\n     assert_eq!(iter.size_hint(), (0, Some(3)));\n     assert_eq!(iter.next(), None);\n \n-    let s12345: BTreeSet<i32> = (1..=5).collect();\n+    let s12345 = BTreeSet::from_iter(1..=5);\n     iter = s246.difference(&s12345);\n     assert_eq!(iter.size_hint(), (0, Some(3)));\n     assert_eq!(iter.next(), Some(&6));\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n     assert_eq!(iter.next(), None);\n \n-    let s34567: BTreeSet<i32> = (3..=7).collect();\n+    let s34567 = BTreeSet::from_iter(3..=7);\n     iter = s246.difference(&s34567);\n     assert_eq!(iter.size_hint(), (0, Some(3)));\n     assert_eq!(iter.next(), Some(&2));\n     assert_eq!(iter.size_hint(), (0, Some(2)));\n     assert_eq!(iter.next(), None);\n \n-    let s1: BTreeSet<i32> = (-9..=1).collect();\n+    let s1 = BTreeSet::from_iter(-9..=1);\n     iter = s246.difference(&s1);\n     assert_eq!(iter.size_hint(), (3, Some(3)));\n \n-    let s2: BTreeSet<i32> = (-9..=2).collect();\n+    let s2 = BTreeSet::from_iter(-9..=2);\n     iter = s246.difference(&s2);\n     assert_eq!(iter.size_hint(), (2, Some(2)));\n     assert_eq!(iter.next(), Some(&4));\n     assert_eq!(iter.size_hint(), (1, Some(1)));\n \n-    let s23: BTreeSet<i32> = (2..=3).collect();\n+    let s23 = BTreeSet::from([2, 3]);\n     iter = s246.difference(&s23);\n     assert_eq!(iter.size_hint(), (1, Some(3)));\n     assert_eq!(iter.next(), Some(&4));\n     assert_eq!(iter.size_hint(), (1, Some(1)));\n \n-    let s4: BTreeSet<i32> = (4..=4).collect();\n+    let s4 = BTreeSet::from([4]);\n     iter = s246.difference(&s4);\n     assert_eq!(iter.size_hint(), (2, Some(3)));\n     assert_eq!(iter.next(), Some(&2));\n@@ -204,19 +204,19 @@ fn test_difference_size_hint() {\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n     assert_eq!(iter.next(), None);\n \n-    let s56: BTreeSet<i32> = (5..=6).collect();\n+    let s56 = BTreeSet::from([5, 6]);\n     iter = s246.difference(&s56);\n     assert_eq!(iter.size_hint(), (1, Some(3)));\n     assert_eq!(iter.next(), Some(&2));\n     assert_eq!(iter.size_hint(), (0, Some(2)));\n \n-    let s6: BTreeSet<i32> = (6..=19).collect();\n+    let s6 = BTreeSet::from_iter(6..=19);\n     iter = s246.difference(&s6);\n     assert_eq!(iter.size_hint(), (2, Some(2)));\n     assert_eq!(iter.next(), Some(&2));\n     assert_eq!(iter.size_hint(), (1, Some(1)));\n \n-    let s7: BTreeSet<i32> = (7..=19).collect();\n+    let s7 = BTreeSet::from_iter(7..=19);\n     iter = s246.difference(&s7);\n     assert_eq!(iter.size_hint(), (3, Some(3)));\n }\n@@ -235,8 +235,8 @@ fn test_symmetric_difference() {\n \n #[test]\n fn test_symmetric_difference_size_hint() {\n-    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n-    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let x = BTreeSet::from([2, 4]);\n+    let y = BTreeSet::from([1, 2, 3]);\n     let mut iter = x.symmetric_difference(&y);\n     assert_eq!(iter.size_hint(), (0, Some(5)));\n     assert_eq!(iter.next(), Some(&1));\n@@ -263,8 +263,8 @@ fn test_union() {\n \n #[test]\n fn test_union_size_hint() {\n-    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n-    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let x = BTreeSet::from([2, 4]);\n+    let y = BTreeSet::from([1, 2, 3]);\n     let mut iter = x.union(&y);\n     assert_eq!(iter.size_hint(), (3, Some(5)));\n     assert_eq!(iter.next(), Some(&1));\n@@ -276,17 +276,17 @@ fn test_union_size_hint() {\n #[test]\n // Only tests the simple function definition with respect to intersection\n fn test_is_disjoint() {\n-    let one = [1].iter().collect::<BTreeSet<_>>();\n-    let two = [2].iter().collect::<BTreeSet<_>>();\n+    let one = BTreeSet::from([1]);\n+    let two = BTreeSet::from([2]);\n     assert!(one.is_disjoint(&two));\n }\n \n #[test]\n // Also implicitly tests the trivial function definition of is_superset\n fn test_is_subset() {\n     fn is_subset(a: &[i32], b: &[i32]) -> bool {\n-        let set_a = a.iter().collect::<BTreeSet<_>>();\n-        let set_b = b.iter().collect::<BTreeSet<_>>();\n+        let set_a = BTreeSet::from_iter(a.iter());\n+        let set_b = BTreeSet::from_iter(b.iter());\n         set_a.is_subset(&set_b)\n     }\n \n@@ -310,7 +310,7 @@ fn test_is_subset() {\n         return;\n     }\n \n-    let large = (0..100).collect::<Vec<_>>();\n+    let large = Vec::from_iter(0..100);\n     assert_eq!(is_subset(&[], &large), true);\n     assert_eq!(is_subset(&large, &[]), false);\n     assert_eq!(is_subset(&[-1], &large), false);\n@@ -321,8 +321,7 @@ fn test_is_subset() {\n \n #[test]\n fn test_retain() {\n-    let xs = [1, 2, 3, 4, 5, 6];\n-    let mut set: BTreeSet<i32> = xs.iter().cloned().collect();\n+    let mut set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n     set.retain(|&k| k % 2 == 0);\n     assert_eq!(set.len(), 3);\n     assert!(set.contains(&2));\n@@ -332,8 +331,8 @@ fn test_retain() {\n \n #[test]\n fn test_drain_filter() {\n-    let mut x: BTreeSet<_> = [1].iter().copied().collect();\n-    let mut y: BTreeSet<_> = [1].iter().copied().collect();\n+    let mut x = BTreeSet::from([1]);\n+    let mut y = BTreeSet::from([1]);\n \n     x.drain_filter(|_| true);\n     y.drain_filter(|_| false);\n@@ -417,7 +416,7 @@ fn test_zip() {\n fn test_from_iter() {\n     let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n-    let set: BTreeSet<_> = xs.iter().cloned().collect();\n+    let set = BTreeSet::from_iter(xs.iter());\n \n     for x in &xs {\n         assert!(set.contains(x));"}]}