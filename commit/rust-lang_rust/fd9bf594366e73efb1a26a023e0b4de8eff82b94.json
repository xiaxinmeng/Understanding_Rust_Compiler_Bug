{"sha": "fd9bf594366e73efb1a26a023e0b4de8eff82b94", "node_id": "C_kwDOAAsO6NoAKGZkOWJmNTk0MzY2ZTczZWZiMWEyNmEwMjNlMGI0ZGU4ZWZmODJiOTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-06T01:50:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-06T01:50:28Z"}, "message": "Auto merge of #111999 - scottmcm:codegen-less-memcpy, r=compiler-errors\n\nUse `load`+`store` instead of `memcpy` for small integer arrays\n\nI was inspired by #98892 to see whether, rather than making `mem::swap` do something smart in the library, we could update MIR assignments like `*_1 = *_2` to do something smarter than `memcpy` for sufficiently-small types that doing it inline is going to be better than a `memcpy` call in assembly anyway.  After all, special code may help `mem::swap`, but if the \"obvious\" MIR can just result in the correct thing that helps everything -- other code like `mem::replace`, people doing it manually, and just passing around by value in general -- as well as makes MIR inlining happier since it doesn't need to deal with all the complicated library code if it just sees a couple assignments.\n\nLLVM will turn the short, known-length `memcpy`s into direct instructions in the backend, but that's too late for it to be able to remove `alloca`s.  In general, replacing `memcpy`s with typed instructions is hard in the middle-end -- even for `memcpy.inline` where it knows it won't be a function call -- is hard [due to poison propagation issues](https://rust-lang.zulipchat.com/#narrow/stream/187780-t-compiler.2Fwg-llvm/topic/memcpy.20vs.20load-store.20for.20MIR.20assignments/near/360376712).  So because we know more about the type invariants -- these are typed copies -- rustc can emit something more specific, allowing LLVM to `mem2reg` away the `alloca`s in some situations.\n\n#52051 previously did something like this in the library for `mem::swap`, but it ended up regressing during enabling mir inlining (https://github.com/rust-lang/rust/commit/cbbf06b0cd39dc93033568f1e65f5363cbbdebcd), so this has been suboptimal on stable for \u22485 releases now.\n\nThe code in this PR is narrowly targeted at just integer arrays in LLVM, but works via a new method on the [`LayoutTypeMethods`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/traits/trait.LayoutTypeMethods.html) trait, so specific backends based on cg_ssa can enable this for more situations over time, as we find them.  I don't want to try to bite off too much in this PR, though.  (Transparent newtypes and simple things like the 3\u00d7usize `String` would be obvious candidates for a follow-up.)\n\nCodegen demonstrations: <https://llvm.godbolt.org/z/fK8hT9aqv>\n\nBefore:\n```llvm\ndefine void `@swap_rgb48_old(ptr` noalias nocapture noundef align 2 dereferenceable(6) %x, ptr noalias nocapture noundef align 2 dereferenceable(6) %y) unnamed_addr #1 {\n  %a.i = alloca [3 x i16], align 2\n  call void `@llvm.lifetime.start.p0(i64` 6, ptr nonnull %a.i)\n  call void `@llvm.memcpy.p0.p0.i64(ptr` noundef nonnull align 2 dereferenceable(6) %a.i, ptr noundef nonnull align 2 dereferenceable(6) %x, i64 6, i1 false)\n  tail call void `@llvm.memcpy.p0.p0.i64(ptr` noundef nonnull align 2 dereferenceable(6) %x, ptr noundef nonnull align 2 dereferenceable(6) %y, i64 6, i1 false)\n  call void `@llvm.memcpy.p0.p0.i64(ptr` noundef nonnull align 2 dereferenceable(6) %y, ptr noundef nonnull align 2 dereferenceable(6) %a.i, i64 6, i1 false)\n  call void `@llvm.lifetime.end.p0(i64` 6, ptr nonnull %a.i)\n  ret void\n}\n```\nNote it going to stack:\n```nasm\nswap_rgb48_old:                         # `@swap_rgb48_old`\n        movzx   eax, word ptr [rdi + 4]\n        mov     word ptr [rsp - 4], ax\n        mov     eax, dword ptr [rdi]\n        mov     dword ptr [rsp - 8], eax\n        movzx   eax, word ptr [rsi + 4]\n        mov     word ptr [rdi + 4], ax\n        mov     eax, dword ptr [rsi]\n        mov     dword ptr [rdi], eax\n        movzx   eax, word ptr [rsp - 4]\n        mov     word ptr [rsi + 4], ax\n        mov     eax, dword ptr [rsp - 8]\n        mov     dword ptr [rsi], eax\n        ret\n```\n\nNow:\n```llvm\ndefine void `@swap_rgb48(ptr` noalias nocapture noundef align 2 dereferenceable(6) %x, ptr noalias nocapture noundef align 2 dereferenceable(6) %y) unnamed_addr #0 {\nstart:\n  %0 = load <3 x i16>, ptr %x, align 2\n  %1 = load <3 x i16>, ptr %y, align 2\n  store <3 x i16> %1, ptr %x, align 2\n  store <3 x i16> %0, ptr %y, align 2\n  ret void\n}\n```\nstill lowers to `dword`+`word` operations, but has no stack traffic:\n```nasm\nswap_rgb48:                             # `@swap_rgb48`\n        mov     eax, dword ptr [rdi]\n        movzx   ecx, word ptr [rdi + 4]\n        movzx   edx, word ptr [rsi + 4]\n        mov     r8d, dword ptr [rsi]\n        mov     dword ptr [rdi], r8d\n        mov     word ptr [rdi + 4], dx\n        mov     word ptr [rsi + 4], cx\n        mov     dword ptr [rsi], eax\n        ret\n```\n\nAnd as a demonstration that this isn't just `mem::swap`, a `mem::replace` on a small array (since replace doesn't use swap since #83022), which used to be `memcpy`s in LLVM changes in IR\n```llvm\ndefine void `@replace_short_array(ptr` noalias nocapture noundef sret([3 x i32]) dereferenceable(12) %0, ptr noalias noundef align 4 dereferenceable(12) %r, ptr noalias nocapture noundef readonly dereferenceable(12) %v) unnamed_addr #0 {\nstart:\n  %1 = load <3 x i32>, ptr %r, align 4\n  store <3 x i32> %1, ptr %0, align 4\n  %2 = load <3 x i32>, ptr %v, align 4\n  store <3 x i32> %2, ptr %r, align 4\n  ret void\n}\n```\nbut that lowers to reasonable `dword`+`qword` instructions still\n```nasm\nreplace_short_array:                    # `@replace_short_array`\n        mov     rax, rdi\n        mov     rcx, qword ptr [rsi]\n        mov     edi, dword ptr [rsi + 8]\n        mov     dword ptr [rax + 8], edi\n        mov     qword ptr [rax], rcx\n        mov     rcx, qword ptr [rdx]\n        mov     edx, dword ptr [rdx + 8]\n        mov     dword ptr [rsi + 8], edx\n        mov     qword ptr [rsi], rcx\n        ret\n```", "tree": {"sha": "967f7343876d4b9a1623aaa8d9abb79fa8db2818", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/967f7343876d4b9a1623aaa8d9abb79fa8db2818"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd9bf594366e73efb1a26a023e0b4de8eff82b94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd9bf594366e73efb1a26a023e0b4de8eff82b94", "html_url": "https://github.com/rust-lang/rust/commit/fd9bf594366e73efb1a26a023e0b4de8eff82b94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd9bf594366e73efb1a26a023e0b4de8eff82b94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adc719d7147d5e2578ce08e0b4504be44650256e", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc719d7147d5e2578ce08e0b4504be44650256e", "html_url": "https://github.com/rust-lang/rust/commit/adc719d7147d5e2578ce08e0b4504be44650256e"}, {"sha": "e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "html_url": "https://github.com/rust-lang/rust/commit/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1"}], "stats": {"total": 152, "additions": 146, "deletions": 6}, "files": [{"sha": "4ffa2b9c6a39d809423ffa8304538bb40d91d228", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd9bf594366e73efb1a26a023e0b4de8eff82b94/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9bf594366e73efb1a26a023e0b4de8eff82b94/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=fd9bf594366e73efb1a26a023e0b4de8eff82b94", "patch": "@@ -288,6 +288,9 @@ impl<'ll, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn reg_backend_type(&self, ty: &Reg) -> &'ll Type {\n         ty.llvm_type(self)\n     }\n+    fn scalar_copy_backend_type(&self, layout: TyAndLayout<'tcx>) -> Option<Self::Type> {\n+        layout.scalar_copy_llvm_type(self)\n+    }\n }\n \n impl<'ll, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'ll, 'tcx> {"}, {"sha": "3339e4e07edd38c705309ac7d481c84b9688f4aa", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fd9bf594366e73efb1a26a023e0b4de8eff82b94/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9bf594366e73efb1a26a023e0b4de8eff82b94/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=fd9bf594366e73efb1a26a023e0b4de8eff82b94", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n+use rustc_target::abi::HasDataLayout;\n use rustc_target::abi::{Abi, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{PointeeInfo, Scalar, Size, TyAbiInterface, Variants};\n@@ -192,6 +193,7 @@ pub trait LayoutLlvmExt<'tcx> {\n     ) -> &'a Type;\n     fn llvm_field_index<'a>(&self, cx: &CodegenCx<'a, 'tcx>, index: usize) -> u64;\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size) -> Option<PointeeInfo>;\n+    fn scalar_copy_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<&'a Type>;\n }\n \n impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n@@ -414,4 +416,35 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result\n     }\n+\n+    fn scalar_copy_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<&'a Type> {\n+        debug_assert!(self.is_sized());\n+\n+        // FIXME: this is a fairly arbitrary choice, but 128 bits on WASM\n+        // (matching the 128-bit SIMD types proposal) and 256 bits on x64\n+        // (like AVX2 registers) seems at least like a tolerable starting point.\n+        let threshold = cx.data_layout().pointer_size * 4;\n+        if self.layout.size() > threshold {\n+            return None;\n+        }\n+\n+        // Vectors, even for non-power-of-two sizes, have the same layout as\n+        // arrays but don't count as aggregate types\n+        if let FieldsShape::Array { count, .. } = self.layout.fields()\n+            && let element = self.field(cx, 0)\n+            && element.ty.is_integral()\n+        {\n+            // `cx.type_ix(bits)` is tempting here, but while that works great\n+            // for things that *stay* as memory-to-memory copies, it also ends\n+            // up suppressing vectorization as it introduces shifts when it\n+            // extracts all the individual values.\n+\n+            let ety = element.llvm_type(cx);\n+            return Some(cx.type_vector(ety, *count));\n+        }\n+\n+        // FIXME: The above only handled integer arrays; surely more things\n+        // would also be possible. Be careful about provenance, though!\n+        None\n+    }\n }"}, {"sha": "dc4a28c866ff3ffe24d85c6134d556a4520d0c1f", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd9bf594366e73efb1a26a023e0b4de8eff82b94/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9bf594366e73efb1a26a023e0b4de8eff82b94/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=fd9bf594366e73efb1a26a023e0b4de8eff82b94", "patch": "@@ -380,7 +380,19 @@ pub fn memcpy_ty<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         return;\n     }\n \n-    bx.memcpy(dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n+    if flags == MemFlags::empty()\n+        && let Some(bty) = bx.cx().scalar_copy_backend_type(layout)\n+    {\n+        // I look forward to only supporting opaque pointers\n+        let pty = bx.type_ptr_to(bty);\n+        let src = bx.pointercast(src, pty);\n+        let dst = bx.pointercast(dst, pty);\n+\n+        let temp = bx.load(bty, src, src_align);\n+        bx.store(temp, dst, dst_align);\n+    } else {\n+        bx.memcpy(dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n+    }\n }\n \n pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>("}, {"sha": "e64417e1a4a69873b4d61d3873b035ca5c535167", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fd9bf594366e73efb1a26a023e0b4de8eff82b94/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9bf594366e73efb1a26a023e0b4de8eff82b94/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=fd9bf594366e73efb1a26a023e0b4de8eff82b94", "patch": "@@ -126,6 +126,28 @@ pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n         index: usize,\n         immediate: bool,\n     ) -> Self::Type;\n+\n+    /// A type that can be used in a [`super::BuilderMethods::load`] +\n+    /// [`super::BuilderMethods::store`] pair to implement a *typed* copy,\n+    /// such as a MIR `*_0 = *_1`.\n+    ///\n+    /// It's always legal to return `None` here, as the provided impl does,\n+    /// in which case callers should use [`super::BuilderMethods::memcpy`]\n+    /// instead of the `load`+`store` pair.\n+    ///\n+    /// This can be helpful for things like arrays, where the LLVM backend type\n+    /// `[3 x i16]` optimizes to three separate loads and stores, but it can\n+    /// instead be copied via an `i48` that stays as the single `load`+`store`.\n+    /// (As of 2023-05 LLVM cannot necessarily optimize away a `memcpy` in these\n+    /// cases, due to `poison` handling, but in codegen we have more information\n+    /// about the type invariants, so can emit something better instead.)\n+    ///\n+    /// This *should* return `None` for particularly-large types, where leaving\n+    /// the `memcpy` may well be important to avoid code size explosion.\n+    fn scalar_copy_backend_type(&self, layout: TyAndLayout<'tcx>) -> Option<Self::Type> {\n+        let _ = layout;\n+        None\n+    }\n }\n \n // For backends that support CFI using type membership (i.e., testing whether a given pointer is"}, {"sha": "98488eb92ee0256132a7f8cc5e3a750fd8595a8d", "filename": "tests/codegen/array-codegen.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd9bf594366e73efb1a26a023e0b4de8eff82b94/tests%2Fcodegen%2Farray-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9bf594366e73efb1a26a023e0b4de8eff82b94/tests%2Fcodegen%2Farray-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Farray-codegen.rs?ref=fd9bf594366e73efb1a26a023e0b4de8eff82b94", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+// min-llvm-version: 15.0 (for opaque pointers)\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @array_load\n+#[no_mangle]\n+pub fn array_load(a: &[u8; 4]) -> [u8; 4] {\n+    // CHECK: %0 = alloca [4 x i8], align 1\n+    // CHECK: %[[TEMP1:.+]] = load <4 x i8>, ptr %a, align 1\n+    // CHECK: store <4 x i8> %[[TEMP1]], ptr %0, align 1\n+    // CHECK: %[[TEMP2:.+]] = load i32, ptr %0, align 1\n+    // CHECK: ret i32 %[[TEMP2]]\n+    *a\n+}\n+\n+// CHECK-LABEL: @array_store\n+#[no_mangle]\n+pub fn array_store(a: [u8; 4], p: &mut [u8; 4]) {\n+    // CHECK: %a = alloca [4 x i8]\n+    // CHECK: %[[TEMP:.+]] = load <4 x i8>, ptr %a, align 1\n+    // CHECK-NEXT: store <4 x i8> %[[TEMP]], ptr %p, align 1\n+    *p = a;\n+}\n+\n+// CHECK-LABEL: @array_copy\n+#[no_mangle]\n+pub fn array_copy(a: &[u8; 4], p: &mut [u8; 4]) {\n+    // CHECK: %[[LOCAL:.+]] = alloca [4 x i8], align 1\n+    // CHECK: %[[TEMP1:.+]] = load <4 x i8>, ptr %a, align 1\n+    // CHECK: store <4 x i8> %[[TEMP1]], ptr %[[LOCAL]], align 1\n+    // CHECK: %[[TEMP2:.+]] = load <4 x i8>, ptr %[[LOCAL]], align 1\n+    // CHECK: store <4 x i8> %[[TEMP2]], ptr %p, align 1\n+    *p = *a;\n+}"}, {"sha": "6151177de15b27247ff7de809567c5848d31f6a4", "filename": "tests/codegen/mem-replace-simple-type.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd9bf594366e73efb1a26a023e0b4de8eff82b94/tests%2Fcodegen%2Fmem-replace-simple-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9bf594366e73efb1a26a023e0b4de8eff82b94/tests%2Fcodegen%2Fmem-replace-simple-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-simple-type.rs?ref=fd9bf594366e73efb1a26a023e0b4de8eff82b94", "patch": "@@ -32,3 +32,14 @@ pub fn replace_ref_str<'a>(r: &mut &'a str, v: &'a str) -> &'a str {\n     // CHECK: ret { ptr, i64 } %[[P2]]\n     std::mem::replace(r, v)\n }\n+\n+#[no_mangle]\n+// CHECK-LABEL: @replace_short_array(\n+pub fn replace_short_array(r: &mut [u32; 3], v: [u32; 3]) -> [u32; 3] {\n+    // CHECK-NOT: alloca\n+    // CHECK: %[[R:.+]] = load <3 x i32>, ptr %r, align 4\n+    // CHECK: store <3 x i32> %[[R]], ptr %0\n+    // CHECK: %[[V:.+]] = load <3 x i32>, ptr %v, align 4\n+    // CHECK: store <3 x i32> %[[V]], ptr %r\n+    std::mem::replace(r, v)\n+}"}, {"sha": "3472a42b0e65e2a4f3e61a0c354229d7bb4e0c21", "filename": "tests/codegen/swap-simd-types.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd9bf594366e73efb1a26a023e0b4de8eff82b94/tests%2Fcodegen%2Fswap-simd-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9bf594366e73efb1a26a023e0b4de8eff82b94/tests%2Fcodegen%2Fswap-simd-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fswap-simd-types.rs?ref=fd9bf594366e73efb1a26a023e0b4de8eff82b94", "patch": "@@ -30,3 +30,12 @@ pub fn swap_m256_slice(x: &mut [__m256], y: &mut [__m256]) {\n         x.swap_with_slice(y);\n     }\n }\n+\n+// CHECK-LABEL: @swap_bytes32\n+#[no_mangle]\n+pub fn swap_bytes32(x: &mut [u8; 32], y: &mut [u8; 32]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <32 x i8>{{.+}}align 1\n+// CHECK: store <32 x i8>{{.+}}align 1\n+    swap(x, y)\n+}"}, {"sha": "419645a3fc6bc87822edc46603e1320c2c8ad703", "filename": "tests/codegen/swap-small-types.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fd9bf594366e73efb1a26a023e0b4de8eff82b94/tests%2Fcodegen%2Fswap-small-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9bf594366e73efb1a26a023e0b4de8eff82b94/tests%2Fcodegen%2Fswap-small-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fswap-small-types.rs?ref=fd9bf594366e73efb1a26a023e0b4de8eff82b94", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -O\n+// compile-flags: -O -Z merge-functions=disabled\n // only-x86_64\n // ignore-debug: the debug assertions get in the way\n \n@@ -8,13 +8,28 @@ use std::mem::swap;\n \n type RGB48 = [u16; 3];\n \n+// CHECK-LABEL: @swap_rgb48_manually(\n+#[no_mangle]\n+pub fn swap_rgb48_manually(x: &mut RGB48, y: &mut RGB48) {\n+    // CHECK-NOT: alloca\n+    // CHECK: %[[TEMP0:.+]] = load <3 x i16>, ptr %x, align 2\n+    // CHECK: %[[TEMP1:.+]] = load <3 x i16>, ptr %y, align 2\n+    // CHECK: store <3 x i16> %[[TEMP1]], ptr %x, align 2\n+    // CHECK: store <3 x i16> %[[TEMP0]], ptr %y, align 2\n+\n+    let temp = *x;\n+    *x = *y;\n+    *y = temp;\n+}\n+\n // CHECK-LABEL: @swap_rgb48\n #[no_mangle]\n pub fn swap_rgb48(x: &mut RGB48, y: &mut RGB48) {\n-    // FIXME MIR inlining messes up LLVM optimizations.\n-// WOULD-CHECK-NOT: alloca\n-// WOULD-CHECK: load i48\n-// WOULD-CHECK: store i48\n+    // CHECK-NOT: alloca\n+    // CHECK: load <3 x i16>\n+    // CHECK: load <3 x i16>\n+    // CHECK: store <3 x i16>\n+    // CHECK: store <3 x i16>\n     swap(x, y)\n }\n "}]}