{"sha": "49b315123e6adb35024437ef7ba408456771c062", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YjMxNTEyM2U2YWRiMzUwMjQ0MzdlZjdiYTQwODQ1Njc3MWMwNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-24T01:06:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-24T01:06:36Z"}, "message": "Auto merge of #79589 - tgnottingham:shared_dep_graph, r=michaelwoerister\n\nrustc_query_system: reduce dependency graph memory usage\n\nThis change implements, at a high level, two space optimizations to the dependency graph.\n\nThe first optimization is sharing graph data with the previous dependency graph. Whenever we intern a node, we know whether that node is new (not in the previous graph) or not, and if not, the color of the node in the previous graph.\n\nRed and green nodes have their `DepNode` present in the previous graph, so for that piece of node data, we can just store the index of the node in the previous graph rather than duplicate the `DepNode`. Green nodes additionally have the the same result `Fingerprint`, so we can avoid duplicating that too. Finally, we distinguish between \"light\" and \"dark\" green nodes, where the latter are nodes that were marked green because all of their dependencies were marked green. These nodes can additionally share edges with the previous graph, because we know that their set of dependencies is the same (technically, light green and red nodes can have the same dependencies too, but we don't try to figure out whether or not that's the case).\n\nAlso, some effort is made to pack data tightly, and to avoid storing `DepNode`s as map keys more than once.\n\nThe second optimization is storing edges in a more compact representation, as in the `SerializedDepGraph`, that is, in a single vector, rather than one `EdgesVec` per node. An `EdgesVec` is a `SmallVec` with an inline buffer for 8 elements. Each `EdgesVec` is, at minimum, 40 bytes, and has a per-node overhead of up to 40 bytes. In the ideal case of exactly 8 edges, then 32 bytes are used for edges, and the overhead is 8 bytes. But most of the time, the overhead is higher.\n\nIn contrast, using a single vector to store all edges, and having each node specify its start and end elements as 4 byte indices into the vector has a constant overhead of 8 bytes--the best case scenario for the per-node `EdgesVec` approach.\n\nThe downside of this approach is that `EdgesVec`s built up during query execution have to be copied into the vector, whereas before, we could just take ownership over them. However, we mostly make up for this because the single vector representation enables a more efficient implementation of `DepGraph::serialize`.", "tree": {"sha": "f7c5b5c312b8c462b7d8dddf60f55750b13daf9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7c5b5c312b8c462b7d8dddf60f55750b13daf9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49b315123e6adb35024437ef7ba408456771c062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49b315123e6adb35024437ef7ba408456771c062", "html_url": "https://github.com/rust-lang/rust/commit/49b315123e6adb35024437ef7ba408456771c062", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49b315123e6adb35024437ef7ba408456771c062/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6", "html_url": "https://github.com/rust-lang/rust/commit/3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6"}, {"sha": "03eb75f759a0c027d07b7d6460f630a373b03638", "url": "https://api.github.com/repos/rust-lang/rust/commits/03eb75f759a0c027d07b7d6460f630a373b03638", "html_url": "https://github.com/rust-lang/rust/commit/03eb75f759a0c027d07b7d6460f630a373b03638"}], "stats": {"total": 932, "additions": 686, "deletions": 246}, "files": [{"sha": "605d7ae4af67832eae5f495fad624add4ce0811f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 668, "deletions": 239, "changes": 907, "blob_url": "https://github.com/rust-lang/rust/blob/49b315123e6adb35024437ef7ba408456771c062/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b315123e6adb35024437ef7ba408456771c062/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=49b315123e6adb35024437ef7ba408456771c062", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::QueryInvocationId;\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n+use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, LockGuard, Lrc, Ordering};\n use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -15,6 +15,7 @@ use std::env;\n use std::hash::Hash;\n use std::marker::PhantomData;\n use std::mem;\n+use std::ops::Range;\n use std::sync::atomic::Ordering::Relaxed;\n \n use super::debug::EdgeFilter;\n@@ -68,7 +69,7 @@ struct DepGraphData<K: DepKind> {\n     /// The new encoding of the dependency graph, optimized for red/green\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n-    /// current one anymore.\n+    /// current one anymore, but we do reference shared data to save space.\n     current: CurrentDepGraph<K>,\n \n     /// The dep-graph from the previous compilation session. It contains all\n@@ -134,17 +135,61 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     pub fn query(&self) -> DepGraphQuery<K> {\n-        let data = self.data.as_ref().unwrap().current.data.lock();\n-        let nodes: Vec<_> = data.iter().map(|n| n.node).collect();\n-        let mut edges = Vec::new();\n-        for (from, edge_targets) in data.iter().map(|d| (d.node, &d.edges)) {\n-            for &edge_target in edge_targets.iter() {\n-                let to = data[edge_target].node;\n-                edges.push((from, to));\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n+\n+        // Note locking order: `prev_index_to_index`, then `data`.\n+        let prev_index_to_index = data.current.prev_index_to_index.lock();\n+        let data = data.current.data.lock();\n+        let node_count = data.hybrid_indices.len();\n+        let edge_count = self.edge_count(&data);\n+\n+        let mut nodes = Vec::with_capacity(node_count);\n+        let mut edge_list_indices = Vec::with_capacity(node_count);\n+        let mut edge_list_data = Vec::with_capacity(edge_count);\n+\n+        // See `serialize` for notes on the approach used here.\n+\n+        edge_list_data.extend(data.unshared_edges.iter().map(|i| i.index()));\n+\n+        for &hybrid_index in data.hybrid_indices.iter() {\n+            match hybrid_index.into() {\n+                HybridIndex::New(new_index) => {\n+                    nodes.push(data.new.nodes[new_index]);\n+                    let edges = &data.new.edges[new_index];\n+                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n+                }\n+                HybridIndex::Red(red_index) => {\n+                    nodes.push(previous.index_to_node(data.red.node_indices[red_index]));\n+                    let edges = &data.red.edges[red_index];\n+                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n+                }\n+                HybridIndex::LightGreen(lg_index) => {\n+                    nodes.push(previous.index_to_node(data.light_green.node_indices[lg_index]));\n+                    let edges = &data.light_green.edges[lg_index];\n+                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n+                }\n+                HybridIndex::DarkGreen(prev_index) => {\n+                    nodes.push(previous.index_to_node(prev_index));\n+\n+                    let edges_iter = previous\n+                        .edge_targets_from(prev_index)\n+                        .iter()\n+                        .map(|&dst| prev_index_to_index[dst].unwrap().index());\n+\n+                    let start = edge_list_data.len();\n+                    edge_list_data.extend(edges_iter);\n+                    let end = edge_list_data.len();\n+                    edge_list_indices.push((start, end));\n+                }\n             }\n         }\n \n-        DepGraphQuery::new(&nodes[..], &edges[..])\n+        debug_assert_eq!(nodes.len(), node_count);\n+        debug_assert_eq!(edge_list_indices.len(), node_count);\n+        debug_assert_eq!(edge_list_data.len(), edge_count);\n+\n+        DepGraphQuery::new(&nodes[..], &edge_list_indices[..], &edge_list_data[..])\n     }\n \n     pub fn assert_ignored(&self) {\n@@ -201,7 +246,6 @@ impl<K: DepKind> DepGraph<K> {\n             key,\n             cx,\n             arg,\n-            false,\n             task,\n             |_key| {\n                 Some(TaskDeps {\n@@ -212,7 +256,6 @@ impl<K: DepKind> DepGraph<K> {\n                     phantom_data: PhantomData,\n                 })\n             },\n-            |data, key, fingerprint, task| data.complete_task(key, task.unwrap(), fingerprint),\n             hash_result,\n         )\n     }\n@@ -222,66 +265,69 @@ impl<K: DepKind> DepGraph<K> {\n         key: DepNode<K>,\n         cx: Ctxt,\n         arg: A,\n-        no_tcx: bool,\n         task: fn(Ctxt, A) -> R,\n         create_task: fn(DepNode<K>) -> Option<TaskDeps<K>>,\n-        finish_task_and_alloc_depnode: fn(\n-            &CurrentDepGraph<K>,\n-            DepNode<K>,\n-            Fingerprint,\n-            Option<TaskDeps<K>>,\n-        ) -> DepNodeIndex,\n         hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n         if let Some(ref data) = self.data {\n             let task_deps = create_task(key).map(Lock::new);\n+            let result = K::with_deps(task_deps.as_ref(), || task(cx, arg));\n+            let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n \n-            // In incremental mode, hash the result of the task. We don't\n-            // do anything with the hash yet, but we are computing it\n-            // anyway so that\n-            //  - we make sure that the infrastructure works and\n-            //  - we can get an idea of the runtime cost.\n             let mut hcx = cx.create_stable_hashing_context();\n-\n-            let result = if no_tcx {\n-                task(cx, arg)\n-            } else {\n-                K::with_deps(task_deps.as_ref(), || task(cx, arg))\n-            };\n-\n             let current_fingerprint = hash_result(&mut hcx, &result);\n \n-            let dep_node_index = finish_task_and_alloc_depnode(\n-                &data.current,\n-                key,\n-                current_fingerprint.unwrap_or(Fingerprint::ZERO),\n-                task_deps.map(|lock| lock.into_inner()),\n-            );\n-\n             let print_status = cfg!(debug_assertions) && cx.debug_dep_tasks();\n \n-            // Determine the color of the new DepNode.\n-            if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n-                let prev_fingerprint = data.previous.fingerprint_by_index(prev_index);\n-\n-                let color = if let Some(current_fingerprint) = current_fingerprint {\n-                    if current_fingerprint == prev_fingerprint {\n+            // Intern the new `DepNode`.\n+            let dep_node_index = if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n+                // Determine the color and index of the new `DepNode`.\n+                let (color, dep_node_index) = if let Some(current_fingerprint) = current_fingerprint\n+                {\n+                    if current_fingerprint == data.previous.fingerprint_by_index(prev_index) {\n                         if print_status {\n                             eprintln!(\"[task::green] {:?}\", key);\n                         }\n-                        DepNodeColor::Green(dep_node_index)\n+\n+                        // This is a light green node: it existed in the previous compilation,\n+                        // its query was re-executed, and it has the same result as before.\n+                        let dep_node_index =\n+                            data.current.intern_light_green_node(&data.previous, prev_index, edges);\n+\n+                        (DepNodeColor::Green(dep_node_index), dep_node_index)\n                     } else {\n                         if print_status {\n                             eprintln!(\"[task::red] {:?}\", key);\n                         }\n-                        DepNodeColor::Red\n+\n+                        // This is a red node: it existed in the previous compilation, its query\n+                        // was re-executed, but it has a different result from before.\n+                        let dep_node_index = data.current.intern_red_node(\n+                            &data.previous,\n+                            prev_index,\n+                            edges,\n+                            current_fingerprint,\n+                        );\n+\n+                        (DepNodeColor::Red, dep_node_index)\n                     }\n                 } else {\n                     if print_status {\n                         eprintln!(\"[task::unknown] {:?}\", key);\n                     }\n-                    // Mark the node as Red if we can't hash the result\n-                    DepNodeColor::Red\n+\n+                    // This is a red node, effectively: it existed in the previous compilation\n+                    // session, its query was re-executed, but it doesn't compute a result hash\n+                    // (i.e. it represents a `no_hash` query), so we have no way of determining\n+                    // whether or not the result was the same as before.\n+                    let dep_node_index = data.current.intern_red_node(\n+                        &data.previous,\n+                        prev_index,\n+                        edges,\n+                        Fingerprint::ZERO,\n+                    );\n+\n+                    (DepNodeColor::Red, dep_node_index)\n                 };\n \n                 debug_assert!(\n@@ -292,12 +338,27 @@ impl<K: DepKind> DepGraph<K> {\n                 );\n \n                 data.colors.insert(prev_index, color);\n-            } else if print_status {\n-                eprintln!(\"[task::new] {:?}\", key);\n-            }\n+                dep_node_index\n+            } else {\n+                if print_status {\n+                    eprintln!(\"[task::new] {:?}\", key);\n+                }\n+\n+                // This is a new node: it didn't exist in the previous compilation session.\n+                data.current.intern_new_node(\n+                    &data.previous,\n+                    key,\n+                    edges,\n+                    current_fingerprint.unwrap_or(Fingerprint::ZERO),\n+                )\n+            };\n \n             (result, dep_node_index)\n         } else {\n+            // Incremental compilation is turned off. We just execute the task\n+            // without tracking. We still provide a dep-node index that uniquely\n+            // identifies the task so that we have a cheap way of referring to\n+            // the query for self-profiling.\n             (task(cx, arg), self.next_virtual_depnode_index())\n         }\n     }\n@@ -308,13 +369,36 @@ impl<K: DepKind> DepGraph<K> {\n     where\n         OP: FnOnce() -> R,\n     {\n+        debug_assert!(!dep_kind.is_eval_always());\n+\n         if let Some(ref data) = self.data {\n             let task_deps = Lock::new(TaskDeps::default());\n-\n             let result = K::with_deps(Some(&task_deps), op);\n             let task_deps = task_deps.into_inner();\n \n-            let dep_node_index = data.current.complete_anon_task(dep_kind, task_deps);\n+            // The dep node indices are hashed here instead of hashing the dep nodes of the\n+            // dependencies. These indices may refer to different nodes per session, but this isn't\n+            // a problem here because we that ensure the final dep node hash is per session only by\n+            // combining it with the per session random number `anon_id_seed`. This hash only need\n+            // to map the dependencies to a single value on a per session basis.\n+            let mut hasher = StableHasher::new();\n+            task_deps.reads.hash(&mut hasher);\n+\n+            let target_dep_node = DepNode {\n+                kind: dep_kind,\n+                // Fingerprint::combine() is faster than sending Fingerprint\n+                // through the StableHasher (at least as long as StableHasher\n+                // is so slow).\n+                hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n+            };\n+\n+            let dep_node_index = data.current.intern_new_node(\n+                &data.previous,\n+                target_dep_node,\n+                task_deps.reads,\n+                Fingerprint::ZERO,\n+            );\n+\n             (result, dep_node_index)\n         } else {\n             (op(), self.next_virtual_depnode_index())\n@@ -331,69 +415,106 @@ impl<K: DepKind> DepGraph<K> {\n         task: fn(Ctxt, A) -> R,\n         hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n-        self.with_task_impl(\n-            key,\n-            cx,\n-            arg,\n-            false,\n-            task,\n-            |_| None,\n-            |data, key, fingerprint, _| data.alloc_node(key, smallvec![], fingerprint),\n-            hash_result,\n-        )\n+        self.with_task_impl(key, cx, arg, task, |_| None, hash_result)\n     }\n \n     #[inline]\n-    pub fn read(&self, v: DepNode<K>) {\n+    pub fn read_index(&self, dep_node_index: DepNodeIndex) {\n         if let Some(ref data) = self.data {\n-            let map = data.current.node_to_node_index.get_shard_by_value(&v).lock();\n-            if let Some(dep_node_index) = map.get(&v).copied() {\n-                std::mem::drop(map);\n-                data.read_index(dep_node_index);\n-            } else {\n-                panic!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n-            }\n+            K::read_deps(|task_deps| {\n+                if let Some(task_deps) = task_deps {\n+                    let mut task_deps = task_deps.lock();\n+                    let task_deps = &mut *task_deps;\n+                    if cfg!(debug_assertions) {\n+                        data.current.total_read_count.fetch_add(1, Relaxed);\n+                    }\n+\n+                    // As long as we only have a low number of reads we can avoid doing a hash\n+                    // insert and potentially allocating/reallocating the hashmap\n+                    let new_read = if task_deps.reads.len() < TASK_DEPS_READS_CAP {\n+                        task_deps.reads.iter().all(|other| *other != dep_node_index)\n+                    } else {\n+                        task_deps.read_set.insert(dep_node_index)\n+                    };\n+                    if new_read {\n+                        task_deps.reads.push(dep_node_index);\n+                        if task_deps.reads.len() == TASK_DEPS_READS_CAP {\n+                            // Fill `read_set` with what we have so far so we can use the hashset\n+                            // next time\n+                            task_deps.read_set.extend(task_deps.reads.iter().copied());\n+                        }\n+\n+                        #[cfg(debug_assertions)]\n+                        {\n+                            if let Some(target) = task_deps.node {\n+                                if let Some(ref forbidden_edge) = data.current.forbidden_edge {\n+                                    let src = self.dep_node_of(dep_node_index);\n+                                    if forbidden_edge.test(&src, &target) {\n+                                        panic!(\"forbidden edge {:?} -> {:?} created\", src, target)\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    } else if cfg!(debug_assertions) {\n+                        data.current.total_duplicate_read_count.fetch_add(1, Relaxed);\n+                    }\n+                }\n+            })\n         }\n     }\n \n     #[inline]\n-    pub fn read_index(&self, dep_node_index: DepNodeIndex) {\n-        if let Some(ref data) = self.data {\n-            data.read_index(dep_node_index);\n-        }\n+    pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n+        self.dep_node_index_of_opt(dep_node).unwrap()\n     }\n \n     #[inline]\n-    pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n-        self.data\n-            .as_ref()\n-            .unwrap()\n-            .current\n-            .node_to_node_index\n-            .get_shard_by_value(dep_node)\n-            .lock()\n-            .get(dep_node)\n-            .cloned()\n-            .unwrap()\n+    pub fn dep_node_index_of_opt(&self, dep_node: &DepNode<K>) -> Option<DepNodeIndex> {\n+        let data = self.data.as_ref().unwrap();\n+        let current = &data.current;\n+\n+        if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n+            current.prev_index_to_index.lock()[prev_index]\n+        } else {\n+            current.new_node_to_index.get_shard_by_value(dep_node).lock().get(dep_node).copied()\n+        }\n     }\n \n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n-        if let Some(ref data) = self.data {\n-            data.current\n-                .node_to_node_index\n-                .get_shard_by_value(&dep_node)\n-                .lock()\n-                .contains_key(dep_node)\n-        } else {\n-            false\n+        self.data.is_some() && self.dep_node_index_of_opt(dep_node).is_some()\n+    }\n+\n+    #[inline]\n+    pub fn dep_node_of(&self, dep_node_index: DepNodeIndex) -> DepNode<K> {\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n+        let data = data.current.data.lock();\n+\n+        match data.hybrid_indices[dep_node_index].into() {\n+            HybridIndex::New(new_index) => data.new.nodes[new_index],\n+            HybridIndex::Red(red_index) => previous.index_to_node(data.red.node_indices[red_index]),\n+            HybridIndex::LightGreen(light_green_index) => {\n+                previous.index_to_node(data.light_green.node_indices[light_green_index])\n+            }\n+            HybridIndex::DarkGreen(prev_index) => previous.index_to_node(prev_index),\n         }\n     }\n \n     #[inline]\n     pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n-        let data = self.data.as_ref().expect(\"dep graph enabled\").current.data.lock();\n-        data[dep_node_index].fingerprint\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n+        let data = data.current.data.lock();\n+\n+        match data.hybrid_indices[dep_node_index].into() {\n+            HybridIndex::New(new_index) => data.new.fingerprints[new_index],\n+            HybridIndex::Red(red_index) => data.red.fingerprints[red_index],\n+            HybridIndex::LightGreen(light_green_index) => {\n+                previous.fingerprint_by_index(data.light_green.node_indices[light_green_index])\n+            }\n+            HybridIndex::DarkGreen(prev_index) => previous.fingerprint_by_index(prev_index),\n+        }\n     }\n \n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n@@ -443,30 +564,95 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n-    pub fn serialize(&self) -> SerializedDepGraph<K> {\n-        let data = self.data.as_ref().unwrap().current.data.lock();\n+    fn edge_count(&self, node_data: &LockGuard<'_, DepNodeData<K>>) -> usize {\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n \n-        let fingerprints: IndexVec<SerializedDepNodeIndex, _> =\n-            data.iter().map(|d| d.fingerprint).collect();\n-        let nodes: IndexVec<SerializedDepNodeIndex, _> = data.iter().map(|d| d.node).collect();\n+        let mut edge_count = node_data.unshared_edges.len();\n \n-        let total_edge_count: usize = data.iter().map(|d| d.edges.len()).sum();\n+        for &hybrid_index in node_data.hybrid_indices.iter() {\n+            if let HybridIndex::DarkGreen(prev_index) = hybrid_index.into() {\n+                edge_count += previous.edge_targets_from(prev_index).len()\n+            }\n+        }\n \n-        let mut edge_list_indices = IndexVec::with_capacity(nodes.len());\n-        let mut edge_list_data = Vec::with_capacity(total_edge_count);\n+        edge_count\n+    }\n \n-        for (current_dep_node_index, edges) in data.iter_enumerated().map(|(i, d)| (i, &d.edges)) {\n-            let start = edge_list_data.len() as u32;\n-            // This should really just be a memcpy :/\n-            edge_list_data.extend(edges.iter().map(|i| SerializedDepNodeIndex::new(i.index())));\n-            let end = edge_list_data.len() as u32;\n+    pub fn serialize(&self) -> SerializedDepGraph<K> {\n+        type SDNI = SerializedDepNodeIndex;\n \n-            debug_assert_eq!(current_dep_node_index.index(), edge_list_indices.len());\n-            edge_list_indices.push((start, end));\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n+\n+        // Note locking order: `prev_index_to_index`, then `data`.\n+        let prev_index_to_index = data.current.prev_index_to_index.lock();\n+        let data = data.current.data.lock();\n+        let node_count = data.hybrid_indices.len();\n+        let edge_count = self.edge_count(&data);\n+\n+        let mut nodes = IndexVec::with_capacity(node_count);\n+        let mut fingerprints = IndexVec::with_capacity(node_count);\n+        let mut edge_list_indices = IndexVec::with_capacity(node_count);\n+        let mut edge_list_data = Vec::with_capacity(edge_count);\n+\n+        // `rustc_middle::ty::query::OnDiskCache` expects nodes to be in\n+        // `DepNodeIndex` order. The edges in `edge_list_data`, on the other\n+        // hand, don't need to be in a particular order, as long as each node\n+        // can reference its edges as a contiguous range within it. This is why\n+        // we're able to copy `unshared_edges` directly into `edge_list_data`.\n+        // It meets the above requirements, and each non-dark-green node already\n+        // knows the range of edges to reference within it, which they'll push\n+        // onto `edge_list_indices`. Dark green nodes, however, don't have their\n+        // edges in `unshared_edges`, so need to add them to `edge_list_data`.\n+\n+        edge_list_data.extend(data.unshared_edges.iter().map(|i| SDNI::new(i.index())));\n+\n+        for &hybrid_index in data.hybrid_indices.iter() {\n+            match hybrid_index.into() {\n+                HybridIndex::New(i) => {\n+                    let new = &data.new;\n+                    nodes.push(new.nodes[i]);\n+                    fingerprints.push(new.fingerprints[i]);\n+                    let edges = &new.edges[i];\n+                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n+                }\n+                HybridIndex::Red(i) => {\n+                    let red = &data.red;\n+                    nodes.push(previous.index_to_node(red.node_indices[i]));\n+                    fingerprints.push(red.fingerprints[i]);\n+                    let edges = &red.edges[i];\n+                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n+                }\n+                HybridIndex::LightGreen(i) => {\n+                    let lg = &data.light_green;\n+                    nodes.push(previous.index_to_node(lg.node_indices[i]));\n+                    fingerprints.push(previous.fingerprint_by_index(lg.node_indices[i]));\n+                    let edges = &lg.edges[i];\n+                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n+                }\n+                HybridIndex::DarkGreen(prev_index) => {\n+                    nodes.push(previous.index_to_node(prev_index));\n+                    fingerprints.push(previous.fingerprint_by_index(prev_index));\n+\n+                    let edges_iter = previous\n+                        .edge_targets_from(prev_index)\n+                        .iter()\n+                        .map(|&dst| prev_index_to_index[dst].as_ref().unwrap());\n+\n+                    let start = edge_list_data.len() as u32;\n+                    edge_list_data.extend(edges_iter.map(|i| SDNI::new(i.index())));\n+                    let end = edge_list_data.len() as u32;\n+                    edge_list_indices.push((start, end));\n+                }\n+            }\n         }\n \n+        debug_assert_eq!(nodes.len(), node_count);\n+        debug_assert_eq!(fingerprints.len(), node_count);\n+        debug_assert_eq!(edge_list_indices.len(), node_count);\n+        debug_assert_eq!(edge_list_data.len(), edge_count);\n         debug_assert!(edge_list_data.len() <= u32::MAX as usize);\n-        debug_assert_eq!(edge_list_data.len(), total_edge_count);\n \n         SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data }\n     }\n@@ -540,14 +726,7 @@ impl<K: DepKind> DepGraph<K> {\n \n         #[cfg(not(parallel_compiler))]\n         {\n-            debug_assert!(\n-                !data\n-                    .current\n-                    .node_to_node_index\n-                    .get_shard_by_value(dep_node)\n-                    .lock()\n-                    .contains_key(dep_node)\n-            );\n+            debug_assert!(!self.dep_node_exists(dep_node));\n             debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n         }\n \n@@ -558,13 +737,11 @@ impl<K: DepKind> DepGraph<K> {\n \n         let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n-        let mut current_deps = SmallVec::new();\n-\n         for &dep_dep_node_index in prev_deps {\n             let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n             match dep_dep_node_color {\n-                Some(DepNodeColor::Green(node_index)) => {\n+                Some(DepNodeColor::Green(_)) => {\n                     // This dependency has been marked as green before, we are\n                     // still fine and can continue with checking the other\n                     // dependencies.\n@@ -574,7 +751,6 @@ impl<K: DepKind> DepGraph<K> {\n                         dep_node,\n                         data.previous.index_to_node(dep_dep_node_index)\n                     );\n-                    current_deps.push(node_index);\n                 }\n                 Some(DepNodeColor::Red) => {\n                     // We found a dependency the value of which has changed\n@@ -607,13 +783,12 @@ impl<K: DepKind> DepGraph<K> {\n                             dep_dep_node_index,\n                             dep_dep_node,\n                         );\n-                        if let Some(node_index) = node_index {\n+                        if node_index.is_some() {\n                             debug!(\n                                 \"try_mark_previous_green({:?}) --- managed to MARK \\\n                                     dependency {:?} as green\",\n                                 dep_node, dep_dep_node\n                             );\n-                            current_deps.push(node_index);\n                             continue;\n                         }\n                     }\n@@ -628,13 +803,12 @@ impl<K: DepKind> DepGraph<K> {\n                         let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n                         match dep_dep_node_color {\n-                            Some(DepNodeColor::Green(node_index)) => {\n+                            Some(DepNodeColor::Green(_)) => {\n                                 debug!(\n                                     \"try_mark_previous_green({:?}) --- managed to \\\n                                         FORCE dependency {:?} to green\",\n                                     dep_node, dep_dep_node\n                                 );\n-                                current_deps.push(node_index);\n                             }\n                             Some(DepNodeColor::Red) => {\n                                 debug!(\n@@ -690,13 +864,9 @@ impl<K: DepKind> DepGraph<K> {\n         // There may be multiple threads trying to mark the same dep node green concurrently\n \n         let dep_node_index = {\n-            // Copy the fingerprint from the previous graph,\n-            // so we don't have to recompute it\n-            let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n-\n             // We allocating an entry for the node in the current dependency graph and\n             // adding all the appropriate edges imported from the previous graph\n-            data.current.intern_node(*dep_node, current_deps, fingerprint)\n+            data.current.intern_dark_green_node(&data.previous, prev_dep_node_index)\n         };\n \n         // ... emitting any stored diagnostic ...\n@@ -871,31 +1041,234 @@ pub struct WorkProduct {\n     pub saved_file: Option<String>,\n }\n \n-#[derive(Clone)]\n+// The maximum value of the follow index types leaves the upper two bits unused\n+// so that we can store multiple index types in `CompressedHybridIndex`, and use\n+// those bits to encode which index type it contains.\n+\n+// Index type for `NewDepNodeData`.\n+rustc_index::newtype_index! {\n+    struct NewDepNodeIndex {\n+        MAX = 0x7FFF_FFFF\n+    }\n+}\n+\n+// Index type for `RedDepNodeData`.\n+rustc_index::newtype_index! {\n+    struct RedDepNodeIndex {\n+        MAX = 0x7FFF_FFFF\n+    }\n+}\n+\n+// Index type for `LightGreenDepNodeData`.\n+rustc_index::newtype_index! {\n+    struct LightGreenDepNodeIndex {\n+        MAX = 0x7FFF_FFFF\n+    }\n+}\n+\n+/// Compressed representation of `HybridIndex` enum. Bits unused by the\n+/// contained index types are used to encode which index type it contains.\n+#[derive(Copy, Clone)]\n+struct CompressedHybridIndex(u32);\n+\n+impl CompressedHybridIndex {\n+    const NEW_TAG: u32 = 0b0000_0000_0000_0000_0000_0000_0000_0000;\n+    const RED_TAG: u32 = 0b0100_0000_0000_0000_0000_0000_0000_0000;\n+    const LIGHT_GREEN_TAG: u32 = 0b1000_0000_0000_0000_0000_0000_0000_0000;\n+    const DARK_GREEN_TAG: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n+\n+    const TAG_MASK: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n+    const INDEX_MASK: u32 = !Self::TAG_MASK;\n+}\n+\n+impl From<NewDepNodeIndex> for CompressedHybridIndex {\n+    #[inline]\n+    fn from(index: NewDepNodeIndex) -> Self {\n+        CompressedHybridIndex(Self::NEW_TAG | index.as_u32())\n+    }\n+}\n+\n+impl From<RedDepNodeIndex> for CompressedHybridIndex {\n+    #[inline]\n+    fn from(index: RedDepNodeIndex) -> Self {\n+        CompressedHybridIndex(Self::RED_TAG | index.as_u32())\n+    }\n+}\n+\n+impl From<LightGreenDepNodeIndex> for CompressedHybridIndex {\n+    #[inline]\n+    fn from(index: LightGreenDepNodeIndex) -> Self {\n+        CompressedHybridIndex(Self::LIGHT_GREEN_TAG | index.as_u32())\n+    }\n+}\n+\n+impl From<SerializedDepNodeIndex> for CompressedHybridIndex {\n+    #[inline]\n+    fn from(index: SerializedDepNodeIndex) -> Self {\n+        CompressedHybridIndex(Self::DARK_GREEN_TAG | index.as_u32())\n+    }\n+}\n+\n+/// Contains an index into one of several node data collections. Elsewhere, we\n+/// store `CompressedHyridIndex` instead of this to save space, but convert to\n+/// this type during processing to take advantage of the enum match ergonomics.\n+enum HybridIndex {\n+    New(NewDepNodeIndex),\n+    Red(RedDepNodeIndex),\n+    LightGreen(LightGreenDepNodeIndex),\n+    DarkGreen(SerializedDepNodeIndex),\n+}\n+\n+impl From<CompressedHybridIndex> for HybridIndex {\n+    #[inline]\n+    fn from(hybrid_index: CompressedHybridIndex) -> Self {\n+        let index = hybrid_index.0 & CompressedHybridIndex::INDEX_MASK;\n+\n+        match hybrid_index.0 & CompressedHybridIndex::TAG_MASK {\n+            CompressedHybridIndex::NEW_TAG => HybridIndex::New(NewDepNodeIndex::from_u32(index)),\n+            CompressedHybridIndex::RED_TAG => HybridIndex::Red(RedDepNodeIndex::from_u32(index)),\n+            CompressedHybridIndex::LIGHT_GREEN_TAG => {\n+                HybridIndex::LightGreen(LightGreenDepNodeIndex::from_u32(index))\n+            }\n+            CompressedHybridIndex::DARK_GREEN_TAG => {\n+                HybridIndex::DarkGreen(SerializedDepNodeIndex::from_u32(index))\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+// Index type for `DepNodeData`'s edges.\n+rustc_index::newtype_index! {\n+    struct EdgeIndex { .. }\n+}\n+\n+/// Data for nodes in the current graph, divided into different collections\n+/// based on their presence in the previous graph, and if present, their color.\n+/// We divide nodes this way because different types of nodes are able to share\n+/// more or less data with the previous graph.\n+///\n+/// To enable more sharing, we distinguish between two kinds of green nodes.\n+/// Light green nodes are nodes in the previous graph that have been marked\n+/// green because we re-executed their queries and the results were the same as\n+/// in the previous session. Dark green nodes are nodes in the previous graph\n+/// that have been marked green because we were able to mark all of their\n+/// dependencies green.\n+///\n+/// Both light and dark green nodes can share the dep node and fingerprint with\n+/// the previous graph, but for light green nodes, we can't be sure that the\n+/// edges may be shared without comparing them against the previous edges, so we\n+/// store them directly (an approach in which we compare edges with the previous\n+/// edges to see if they can be shared was evaluated, but was not found to be\n+/// very profitable).\n+///\n+/// For dark green nodes, we can share everything with the previous graph, which\n+/// is why the `HybridIndex::DarkGreen` enum variant contains the index of the\n+/// node in the previous graph, and why we don't have a separate collection for\n+/// dark green node data--the collection is the `PreviousDepGraph` itself.\n+///\n+/// (Note that for dark green nodes, the edges in the previous graph\n+/// (`SerializedDepNodeIndex`s) must be converted to edges in the current graph\n+/// (`DepNodeIndex`s). `CurrentDepGraph` contains `prev_index_to_index`, which\n+/// can perform this conversion. It should always be possible, as by definition,\n+/// a dark green node is one whose dependencies from the previous session have\n+/// all been marked green--which means `prev_index_to_index` contains them.)\n+///\n+/// Node data is stored in parallel vectors to eliminate the padding between\n+/// elements that would be needed to satisfy alignment requirements of the\n+/// structure that would contain all of a node's data. We could group tightly\n+/// packing subsets of node data together and use fewer vectors, but for\n+/// consistency's sake, we use separate vectors for each piece of data.\n struct DepNodeData<K> {\n-    node: DepNode<K>,\n-    edges: EdgesVec,\n-    fingerprint: Fingerprint,\n+    /// Data for nodes not in previous graph.\n+    new: NewDepNodeData<K>,\n+\n+    /// Data for nodes in previous graph that have been marked red.\n+    red: RedDepNodeData,\n+\n+    /// Data for nodes in previous graph that have been marked light green.\n+    light_green: LightGreenDepNodeData,\n+\n+    // Edges for all nodes other than dark-green ones. Edges for each node\n+    // occupy a contiguous region of this collection, which a node can reference\n+    // using two indices. Storing edges this way rather than using an `EdgesVec`\n+    // for each node reduces memory consumption by a not insignificant amount\n+    // when compiling large crates. The downside is that we have to copy into\n+    // this collection the edges from the `EdgesVec`s that are built up during\n+    // query execution. But this is mostly balanced out by the more efficient\n+    // implementation of `DepGraph::serialize` enabled by this representation.\n+    unshared_edges: IndexVec<EdgeIndex, DepNodeIndex>,\n+\n+    /// Mapping from `DepNodeIndex` to an index into a collection above.\n+    /// Indicates which of the above collections contains a node's data.\n+    ///\n+    /// This collection is wasteful in time and space during incr-full builds,\n+    /// because for those, all nodes are new. However, the waste is relatively\n+    /// small, and the maintenance cost of avoiding using this for incr-full\n+    /// builds is somewhat high and prone to bugginess. It does not seem worth\n+    /// it at the time of this writing, but we may want to revisit the idea.\n+    hybrid_indices: IndexVec<DepNodeIndex, CompressedHybridIndex>,\n+}\n+\n+/// Data for nodes not in previous graph. Since we cannot share any data with\n+/// the previous graph, so we must store all of such a node's data here.\n+struct NewDepNodeData<K> {\n+    nodes: IndexVec<NewDepNodeIndex, DepNode<K>>,\n+    edges: IndexVec<NewDepNodeIndex, Range<EdgeIndex>>,\n+    fingerprints: IndexVec<NewDepNodeIndex, Fingerprint>,\n+}\n+\n+/// Data for nodes in previous graph that have been marked red. We can share the\n+/// dep node with the previous graph, but the edges may be different, and the\n+/// fingerprint is known to be different, so we store the latter two directly.\n+struct RedDepNodeData {\n+    node_indices: IndexVec<RedDepNodeIndex, SerializedDepNodeIndex>,\n+    edges: IndexVec<RedDepNodeIndex, Range<EdgeIndex>>,\n+    fingerprints: IndexVec<RedDepNodeIndex, Fingerprint>,\n }\n \n-/// `CurrentDepGraph` stores the dependency graph for the current session.\n-/// It will be populated as we run queries or tasks.\n+/// Data for nodes in previous graph that have been marked green because we\n+/// re-executed their queries and the results were the same as in the previous\n+/// session. We can share the dep node and the fingerprint with the previous\n+/// graph, but the edges may be different, so we store them directly.\n+struct LightGreenDepNodeData {\n+    node_indices: IndexVec<LightGreenDepNodeIndex, SerializedDepNodeIndex>,\n+    edges: IndexVec<LightGreenDepNodeIndex, Range<EdgeIndex>>,\n+}\n+\n+/// `CurrentDepGraph` stores the dependency graph for the current session. It\n+/// will be populated as we run queries or tasks. We never remove nodes from the\n+/// graph: they are only added.\n ///\n-/// The nodes in it are identified by an index (`DepNodeIndex`).\n-/// The data for each node is stored in its `DepNodeData`, found in the `data` field.\n+/// The nodes in it are identified by a `DepNodeIndex`. Internally, this maps to\n+/// a `HybridIndex`, which identifies which collection in the `data` field\n+/// contains a node's data. Which collection is used for a node depends on\n+/// whether the node was present in the `PreviousDepGraph`, and if so, the color\n+/// of the node. Each type of node can share more or less data with the previous\n+/// graph. When possible, we can store just the index of the node in the\n+/// previous graph, rather than duplicating its data in our own collections.\n+/// This is important, because these graph structures are some of the largest in\n+/// the compiler.\n ///\n-/// We never remove nodes from the graph: they are only added.\n+/// For the same reason, we also avoid storing `DepNode`s more than once as map\n+/// keys. The `new_node_to_index` map only contains nodes not in the previous\n+/// graph, and we map nodes in the previous graph to indices via a two-step\n+/// mapping. `PreviousDepGraph` maps from `DepNode` to `SerializedDepNodeIndex`,\n+/// and the `prev_index_to_index` vector (which is more compact and faster than\n+/// using a map) maps from `SerializedDepNodeIndex` to `DepNodeIndex`.\n ///\n-/// This struct uses two locks internally. The `data` and `node_to_node_index` fields are\n-/// locked separately. Operations that take a `DepNodeIndex` typically just access\n-/// the data field.\n+/// This struct uses three locks internally. The `data`, `new_node_to_index`,\n+/// and `prev_index_to_index` fields are locked separately. Operations that take\n+/// a `DepNodeIndex` typically just access the `data` field.\n ///\n-/// The only operation that must manipulate both locks is adding new nodes, in which case\n-/// we first acquire the `node_to_node_index` lock and then, once a new node is to be inserted,\n-/// acquire the lock on `data.`\n+/// We only need to manipulate at most two locks simultaneously:\n+/// `new_node_to_index` and `data`, or `prev_index_to_index` and `data`. When\n+/// manipulating both, we acquire `new_node_to_index` or `prev_index_to_index`\n+/// first, and `data` second.\n pub(super) struct CurrentDepGraph<K> {\n-    data: Lock<IndexVec<DepNodeIndex, DepNodeData<K>>>,\n-    node_to_node_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n+    data: Lock<DepNodeData<K>>,\n+    new_node_to_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n+    prev_index_to_index: Lock<IndexVec<SerializedDepNodeIndex, Option<DepNodeIndex>>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n@@ -944,133 +1317,189 @@ impl<K: DepKind> CurrentDepGraph<K> {\n \n         // Pre-allocate the dep node structures. We over-allocate a little so\n         // that we hopefully don't have to re-allocate during this compilation\n-        // session. The over-allocation is 2% plus a small constant to account\n-        // for the fact that in very small crates 2% might not be enough.\n-        let new_node_count_estimate = (prev_graph_node_count * 102) / 100 + 200;\n+        // session. The over-allocation for new nodes is 2% plus a small\n+        // constant to account for the fact that in very small crates 2% might\n+        // not be enough. The allocation for red and green node data doesn't\n+        // include a constant, as we don't want to allocate anything for these\n+        // structures during full incremental builds, where they aren't used.\n+        //\n+        // These estimates are based on the distribution of node and edge counts\n+        // seen in rustc-perf benchmarks, adjusted somewhat to account for the\n+        // fact that these benchmarks aren't perfectly representative.\n+        //\n+        // FIXME Use a collection type that doesn't copy node and edge data and\n+        // grow multiplicatively on reallocation. Without such a collection or\n+        // solution having the same effect, there is a performance hazard here\n+        // in both time and space, as growing these collections means copying a\n+        // large amount of data and doubling already large buffer capacities. A\n+        // solution for this will also mean that it's less important to get\n+        // these estimates right.\n+        let new_node_count_estimate = (prev_graph_node_count * 2) / 100 + 200;\n+        let red_node_count_estimate = (prev_graph_node_count * 3) / 100;\n+        let light_green_node_count_estimate = (prev_graph_node_count * 25) / 100;\n+        let total_node_count_estimate = prev_graph_node_count + new_node_count_estimate;\n+\n+        let average_edges_per_node_estimate = 6;\n+        let unshared_edge_count_estimate = average_edges_per_node_estimate\n+            * (new_node_count_estimate + red_node_count_estimate + light_green_node_count_estimate);\n+\n+        // We store a large collection of these in `prev_index_to_index` during\n+        // non-full incremental builds, and want to ensure that the element size\n+        // doesn't inadvertently increase.\n+        static_assert_size!(Option<DepNodeIndex>, 4);\n \n         CurrentDepGraph {\n-            data: Lock::new(IndexVec::with_capacity(new_node_count_estimate)),\n-            node_to_node_index: Sharded::new(|| {\n+            data: Lock::new(DepNodeData {\n+                new: NewDepNodeData {\n+                    nodes: IndexVec::with_capacity(new_node_count_estimate),\n+                    edges: IndexVec::with_capacity(new_node_count_estimate),\n+                    fingerprints: IndexVec::with_capacity(new_node_count_estimate),\n+                },\n+                red: RedDepNodeData {\n+                    node_indices: IndexVec::with_capacity(red_node_count_estimate),\n+                    edges: IndexVec::with_capacity(red_node_count_estimate),\n+                    fingerprints: IndexVec::with_capacity(red_node_count_estimate),\n+                },\n+                light_green: LightGreenDepNodeData {\n+                    node_indices: IndexVec::with_capacity(light_green_node_count_estimate),\n+                    edges: IndexVec::with_capacity(light_green_node_count_estimate),\n+                },\n+                unshared_edges: IndexVec::with_capacity(unshared_edge_count_estimate),\n+                hybrid_indices: IndexVec::with_capacity(total_node_count_estimate),\n+            }),\n+            new_node_to_index: Sharded::new(|| {\n                 FxHashMap::with_capacity_and_hasher(\n                     new_node_count_estimate / sharded::SHARDS,\n                     Default::default(),\n                 )\n             }),\n+            prev_index_to_index: Lock::new(IndexVec::from_elem_n(None, prev_graph_node_count)),\n             anon_id_seed: stable_hasher.finish(),\n             forbidden_edge,\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n         }\n     }\n \n-    fn complete_task(\n+    fn intern_new_node(\n         &self,\n-        node: DepNode<K>,\n-        task_deps: TaskDeps<K>,\n+        prev_graph: &PreviousDepGraph<K>,\n+        dep_node: DepNode<K>,\n+        edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        self.alloc_node(node, task_deps.reads, fingerprint)\n-    }\n-\n-    fn complete_anon_task(&self, kind: K, task_deps: TaskDeps<K>) -> DepNodeIndex {\n-        debug_assert!(!kind.is_eval_always());\n-\n-        let mut hasher = StableHasher::new();\n-\n-        // The dep node indices are hashed here instead of hashing the dep nodes of the\n-        // dependencies. These indices may refer to different nodes per session, but this isn't\n-        // a problem here because we that ensure the final dep node hash is per session only by\n-        // combining it with the per session random number `anon_id_seed`. This hash only need\n-        // to map the dependencies to a single value on a per session basis.\n-        task_deps.reads.hash(&mut hasher);\n-\n-        let target_dep_node = DepNode {\n-            kind,\n-\n-            // Fingerprint::combine() is faster than sending Fingerprint\n-            // through the StableHasher (at least as long as StableHasher\n-            // is so slow).\n-            hash: self.anon_id_seed.combine(hasher.finish()).into(),\n-        };\n+        debug_assert!(\n+            prev_graph.node_to_index_opt(&dep_node).is_none(),\n+            \"node in previous graph should be interned using one \\\n+            of `intern_red_node`, `intern_light_green_node`, etc.\"\n+        );\n \n-        self.intern_node(target_dep_node, task_deps.reads, Fingerprint::ZERO)\n+        match self.new_node_to_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n+            Entry::Occupied(entry) => *entry.get(),\n+            Entry::Vacant(entry) => {\n+                let data = &mut *self.data.lock();\n+                let new_index = data.new.nodes.push(dep_node);\n+                add_edges(&mut data.unshared_edges, &mut data.new.edges, edges);\n+                data.new.fingerprints.push(fingerprint);\n+                let dep_node_index = data.hybrid_indices.push(new_index.into());\n+                entry.insert(dep_node_index);\n+                dep_node_index\n+            }\n+        }\n     }\n \n-    fn alloc_node(\n+    fn intern_red_node(\n         &self,\n-        dep_node: DepNode<K>,\n+        prev_graph: &PreviousDepGraph<K>,\n+        prev_index: SerializedDepNodeIndex,\n         edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        debug_assert!(\n-            !self.node_to_node_index.get_shard_by_value(&dep_node).lock().contains_key(&dep_node)\n-        );\n-        self.intern_node(dep_node, edges, fingerprint)\n+        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+\n+        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+        match prev_index_to_index[prev_index] {\n+            Some(dep_node_index) => dep_node_index,\n+            None => {\n+                let data = &mut *self.data.lock();\n+                let red_index = data.red.node_indices.push(prev_index);\n+                add_edges(&mut data.unshared_edges, &mut data.red.edges, edges);\n+                data.red.fingerprints.push(fingerprint);\n+                let dep_node_index = data.hybrid_indices.push(red_index.into());\n+                prev_index_to_index[prev_index] = Some(dep_node_index);\n+                dep_node_index\n+            }\n+        }\n     }\n \n-    fn intern_node(\n+    fn intern_light_green_node(\n         &self,\n-        dep_node: DepNode<K>,\n+        prev_graph: &PreviousDepGraph<K>,\n+        prev_index: SerializedDepNodeIndex,\n         edges: EdgesVec,\n-        fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        match self.node_to_node_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n-            Entry::Occupied(entry) => *entry.get(),\n-            Entry::Vacant(entry) => {\n-                let mut data = self.data.lock();\n-                let dep_node_index = DepNodeIndex::new(data.len());\n-                data.push(DepNodeData { node: dep_node, edges, fingerprint });\n-                entry.insert(dep_node_index);\n+        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+\n+        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+        match prev_index_to_index[prev_index] {\n+            Some(dep_node_index) => dep_node_index,\n+            None => {\n+                let data = &mut *self.data.lock();\n+                let light_green_index = data.light_green.node_indices.push(prev_index);\n+                add_edges(&mut data.unshared_edges, &mut data.light_green.edges, edges);\n+                let dep_node_index = data.hybrid_indices.push(light_green_index.into());\n+                prev_index_to_index[prev_index] = Some(dep_node_index);\n                 dep_node_index\n             }\n         }\n     }\n-}\n \n-impl<K: DepKind> DepGraphData<K> {\n-    #[inline(never)]\n-    fn read_index(&self, source: DepNodeIndex) {\n-        K::read_deps(|task_deps| {\n-            if let Some(task_deps) = task_deps {\n-                let mut task_deps = task_deps.lock();\n-                let task_deps = &mut *task_deps;\n-                if cfg!(debug_assertions) {\n-                    self.current.total_read_count.fetch_add(1, Relaxed);\n-                }\n+    fn intern_dark_green_node(\n+        &self,\n+        prev_graph: &PreviousDepGraph<K>,\n+        prev_index: SerializedDepNodeIndex,\n+    ) -> DepNodeIndex {\n+        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n \n-                // As long as we only have a low number of reads we can avoid doing a hash\n-                // insert and potentially allocating/reallocating the hashmap\n-                let new_read = if task_deps.reads.len() < TASK_DEPS_READS_CAP {\n-                    task_deps.reads.iter().all(|other| *other != source)\n-                } else {\n-                    task_deps.read_set.insert(source)\n-                };\n-                if new_read {\n-                    task_deps.reads.push(source);\n-                    if task_deps.reads.len() == TASK_DEPS_READS_CAP {\n-                        // Fill `read_set` with what we have so far so we can use the hashset next\n-                        // time\n-                        task_deps.read_set.extend(task_deps.reads.iter().copied());\n-                    }\n+        let mut prev_index_to_index = self.prev_index_to_index.lock();\n \n-                    #[cfg(debug_assertions)]\n-                    {\n-                        if let Some(target) = task_deps.node {\n-                            let data = self.current.data.lock();\n-                            if let Some(ref forbidden_edge) = self.current.forbidden_edge {\n-                                let source = data[source].node;\n-                                if forbidden_edge.test(&source, &target) {\n-                                    panic!(\"forbidden edge {:?} -> {:?} created\", source, target)\n-                                }\n-                            }\n-                        }\n-                    }\n-                } else if cfg!(debug_assertions) {\n-                    self.current.total_duplicate_read_count.fetch_add(1, Relaxed);\n-                }\n+        match prev_index_to_index[prev_index] {\n+            Some(dep_node_index) => dep_node_index,\n+            None => {\n+                let mut data = self.data.lock();\n+                let dep_node_index = data.hybrid_indices.push(prev_index.into());\n+                prev_index_to_index[prev_index] = Some(dep_node_index);\n+                dep_node_index\n             }\n-        })\n+        }\n     }\n+\n+    #[inline]\n+    fn debug_assert_not_in_new_nodes(\n+        &self,\n+        prev_graph: &PreviousDepGraph<K>,\n+        prev_index: SerializedDepNodeIndex,\n+    ) {\n+        let node = &prev_graph.index_to_node(prev_index);\n+        debug_assert!(\n+            !self.new_node_to_index.get_shard_by_value(node).lock().contains_key(node),\n+            \"node from previous graph present in new node collection\"\n+        );\n+    }\n+}\n+\n+#[inline]\n+fn add_edges<I: Idx>(\n+    edges: &mut IndexVec<EdgeIndex, DepNodeIndex>,\n+    edge_indices: &mut IndexVec<I, Range<EdgeIndex>>,\n+    new_edges: EdgesVec,\n+) {\n+    let start = edges.next_index();\n+    edges.extend(new_edges);\n+    let end = edges.next_index();\n+    edge_indices.push(start..end);\n }\n \n /// The capacity of the `reads` field `SmallVec`"}, {"sha": "cc25d08cb54f43797fe4f526ed772db7b3e8c833", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/49b315123e6adb35024437ef7ba408456771c062/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b315123e6adb35024437ef7ba408456771c062/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=49b315123e6adb35024437ef7ba408456771c062", "patch": "@@ -9,17 +9,23 @@ pub struct DepGraphQuery<K> {\n }\n \n impl<K: DepKind> DepGraphQuery<K> {\n-    pub fn new(nodes: &[DepNode<K>], edges: &[(DepNode<K>, DepNode<K>)]) -> DepGraphQuery<K> {\n-        let mut graph = Graph::with_capacity(nodes.len(), edges.len());\n+    pub fn new(\n+        nodes: &[DepNode<K>],\n+        edge_list_indices: &[(usize, usize)],\n+        edge_list_data: &[usize],\n+    ) -> DepGraphQuery<K> {\n+        let mut graph = Graph::with_capacity(nodes.len(), edge_list_data.len());\n         let mut indices = FxHashMap::default();\n         for node in nodes {\n             indices.insert(*node, graph.add_node(*node));\n         }\n \n-        for &(ref source, ref target) in edges {\n-            let source = indices[source];\n-            let target = indices[target];\n-            graph.add_edge(source, target, ());\n+        for (source, &(start, end)) in edge_list_indices.iter().enumerate() {\n+            for &target in &edge_list_data[start..end] {\n+                let source = indices[&nodes[source]];\n+                let target = indices[&nodes[target]];\n+                graph.add_edge(source, target, ());\n+            }\n         }\n \n         DepGraphQuery { graph, indices }"}, {"sha": "28e074069185206d840ae103d25930c1fe10defc", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/49b315123e6adb35024437ef7ba408456771c062/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b315123e6adb35024437ef7ba408456771c062/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=49b315123e6adb35024437ef7ba408456771c062", "patch": "@@ -4,8 +4,13 @@ use super::{DepKind, DepNode};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_index::vec::IndexVec;\n \n+// The maximum value of `SerializedDepNodeIndex` leaves the upper two bits\n+// unused so that we can store multiple index types in `CompressedHybridIndex`,\n+// and use those bits to encode which index type it contains.\n rustc_index::newtype_index! {\n-    pub struct SerializedDepNodeIndex { .. }\n+    pub struct SerializedDepNodeIndex {\n+        MAX = 0x7FFF_FFFF\n+    }\n }\n \n /// Data for use when recompiling the **current crate**."}]}