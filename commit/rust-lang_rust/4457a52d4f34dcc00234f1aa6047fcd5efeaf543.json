{"sha": "4457a52d4f34dcc00234f1aa6047fcd5efeaf543", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NTdhNTJkNGYzNGRjYzAwMjM0ZjFhYTYwNDdmY2Q1ZWZlYWY1NDM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-14T03:08:35Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-25T08:22:11Z"}, "message": "Re-do the way locking is done during verification\n\nWe now lock at the \"leaves\" on the types, rather than locking at references.\nIn particular, Validate for sth. of non-reference lvalue will also lock the \"outer\" memory.\nAlso change the way we release write locks, and some refactoring in the memory.", "tree": {"sha": "2b5e469d86816a78355add3092dbac585624dbae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b5e469d86816a78355add3092dbac585624dbae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4457a52d4f34dcc00234f1aa6047fcd5efeaf543", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAll2/7MACgkQpp+NIls6\n19lL2g//TUTEEx/nH6xi4jMdt43lNa9XelHWK4UMhK33kM1I05WDlITGQr2f4++Q\nZ9sa0iWdv6bBiewCHYFCStR9EMectHZUyi3VnV0MoMcEsKFn/fAN5Ss7IikXKEJt\nZ7nR3/6h94nl9QLUdxAMm26CDN/91NW8AtomRN9H2sC77nflOcBRQFY8R6xTG5iP\nniDJ2Pt8Is1KUDd4eGGQGIGLUIyCARIjUdEFl3we0Q1Yc4u20ScLao2NXZIdYLTm\nHyz3Eco1rTXA+XwA4BJpkyGXEgjgsSd6TGLWkryFydHjxbjHeXXXmglH7mQHNvlG\nmJbKtdXuU9ICRTxjz1FOuR7ZC8OcFvcKwR7LADsM7Tt5Bra9JlCTHKiszKZjX2JO\nWVzusQqhoykAMI+HomxAKKUb0AX/GciEGWSv4eMD9v0lDMjd+UaHiRhr8Z18AqZ+\n1VwYHpRG7y0q0yeIsy+vfYTn2c5nCHC4ur5sj+YC2VsHTsf+ed7SqkbidCWnhiKl\ncNfQV8DMPIRHYbv7m47eQaKAkRTTBy5r81wrsOr8LlvWb7rhu3wZhT4i7wO9yS7d\nQTmpuoAz//FPDIPTpm1TgNCYgfRZD0mQuvMoY8PUGtgXEcEXq/sQkbVjSZ9K6YuF\ndWFRvZ74rAKgAHf6+NsahXkdwcx65lYSNOY0vHtZELQzbVBiFDQ=\n=8Ogk\n-----END PGP SIGNATURE-----", "payload": "tree 2b5e469d86816a78355add3092dbac585624dbae\nparent 7c6e6cf4921564c8df713c29e97d88a27a1cff02\nauthor Ralf Jung <post@ralfj.de> 1500001715 -0700\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1500970931 +0200\n\nRe-do the way locking is done during verification\n\nWe now lock at the \"leaves\" on the types, rather than locking at references.\nIn particular, Validate for sth. of non-reference lvalue will also lock the \"outer\" memory.\nAlso change the way we release write locks, and some refactoring in the memory.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4457a52d4f34dcc00234f1aa6047fcd5efeaf543", "html_url": "https://github.com/rust-lang/rust/commit/4457a52d4f34dcc00234f1aa6047fcd5efeaf543", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4457a52d4f34dcc00234f1aa6047fcd5efeaf543/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c6e6cf4921564c8df713c29e97d88a27a1cff02", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c6e6cf4921564c8df713c29e97d88a27a1cff02", "html_url": "https://github.com/rust-lang/rust/commit/7c6e6cf4921564c8df713c29e97d88a27a1cff02"}], "stats": {"total": 209, "additions": 145, "deletions": 64}, "files": [{"sha": "0830db48d9f381fbfdc3aa5b263fa1ac80cc9e8f", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4457a52d4f34dcc00234f1aa6047fcd5efeaf543/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4457a52d4f34dcc00234f1aa6047fcd5efeaf543/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=4457a52d4f34dcc00234f1aa6047fcd5efeaf543", "patch": "@@ -57,11 +57,15 @@ pub enum EvalError<'tcx> {\n         access: AccessKind,\n         lock: LockInfo,\n     },\n-    ValidationFailure(String),\n     InvalidMemoryLockRelease {\n         ptr: MemoryPointer,\n         len: u64,\n     },\n+    DeallocatedLockedMemory {\n+        ptr: MemoryPointer,\n+        lock: LockInfo,\n+    },\n+    ValidationFailure(String),\n     CalledClosureAsFunction,\n     VtableForArgumentlessMethod,\n     ModifiedConstantMemory,\n@@ -70,7 +74,6 @@ pub enum EvalError<'tcx> {\n     TypeNotPrimitive(Ty<'tcx>),\n     ReallocatedWrongMemoryKind(Kind, Kind),\n     DeallocatedWrongMemoryKind(Kind, Kind),\n-    DeallocatedLockedMemory,\n     ReallocateNonBasePtr,\n     DeallocateNonBasePtr,\n     IncorrectAllocationInformation,\n@@ -113,10 +116,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"memory access conflicts with lock\",\n             ValidationFailure(..) =>\n                 \"type validation failed\",\n-            DeallocatedLockedMemory =>\n-                \"deallocated memory while a lock was held\",\n             InvalidMemoryLockRelease { .. } =>\n                 \"memory lock released that was never acquired\",\n+            DeallocatedLockedMemory { .. } =>\n+                \"tried to deallocate memory in conflict with a lock\",\n             ReadPointerAsBytes =>\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n             ReadBytesAsPointer =>\n@@ -221,9 +224,13 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                        access, ptr, len, lock)\n             }\n             InvalidMemoryLockRelease { ptr, len } => {\n-                write!(f, \"tried to release memory write lock at {:?}, size {}, which was not acquired by this function\",\n+                write!(f, \"tried to release memory write lock at {:?}, size {}, but the write lock is held by someone else\",\n                        ptr, len)\n             }\n+            DeallocatedLockedMemory { ptr, lock } => {\n+                write!(f, \"tried to deallocate memory at {:?} in conflict with lock {:?}\",\n+                       ptr, lock)\n+            }\n             ValidationFailure(ref err) => {\n                 write!(f, \"type validation failed: {}\", err)\n             }"}, {"sha": "45dc226af14572dd7154032800a6a3a922b01ba9", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4457a52d4f34dcc00234f1aa6047fcd5efeaf543/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4457a52d4f34dcc00234f1aa6047fcd5efeaf543/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=4457a52d4f34dcc00234f1aa6047fcd5efeaf543", "patch": "@@ -503,27 +503,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn validate_ptr(&mut self, val: Value, pointee_ty: Ty<'tcx>, vctx: ValidationCtx) -> EvalResult<'tcx> {\n-        use self::TyMutability::*;\n-\n         // Check alignment and non-NULLness\n-        let (len, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n+        let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n         let ptr = val.into_ptr(&mut self.memory)?;\n         self.memory.check_align(ptr, align)?;\n \n-        // For ZSTs, do no more\n-        if len == 0 {\n-            return Ok(())\n-        }\n-\n-        // Acquire lock (also establishing that this is in-bounds etc.)\n-        let ptr = ptr.to_ptr()?;\n-        let access = match vctx.mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n-        match vctx.op {\n-            ValidationOp::Acquire => self.memory.acquire_lock(ptr, len, vctx.region, access)?,\n-            ValidationOp::Release => self.memory.release_lock_until(ptr, len, None)?,\n-            ValidationOp::Suspend(region) => self.memory.release_lock_until(ptr, len, Some(region))?,\n-        }\n-\n         // Recurse\n         let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n         self.validate(pointee_lvalue, pointee_ty, vctx)\n@@ -538,14 +522,64 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use self::TyMutability::*;\n \n         trace!(\"Validating {:?} at type {}, context {:?}\", lvalue, ty, vctx);\n+\n+        // Decide whether this type *owns* the memory it covers (like integers), or whether it\n+        // just assembles pieces (that each own their memory) together to a larger whole.\n+        // TODO: Currently, we don't acquire locks for padding and discriminants. We should.\n+        let is_owning = match ty.sty {\n+            TyInt(_) | TyUint(_) | TyRawPtr(_) |\n+            TyBool | TyFloat(_) | TyChar | TyStr |\n+            TyRef(..) => true,\n+            TyAdt(adt, _) if adt.is_box() => true,\n+            TyAdt(_, _) | TyTuple(..) | TyClosure(..) => false,\n+            TyParam(_) | TyInfer(_) => bug!(\"I got an incomplete type for validation\"),\n+            _ => return Err(EvalError::Unimplemented(format!(\"Unimplemented type encountered when checking validity.\"))),\n+        };\n+        if is_owning {\n+            match lvalue {\n+                Lvalue::Ptr { ptr, extra, aligned: _ } => {\n+                    // Determine the size\n+                    // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n+                    let len = match self.type_size(ty)? {\n+                        Some(size) => {\n+                            assert_eq!(extra, LvalueExtra::None, \"Got a fat ptr to a sized type\");\n+                            size\n+                        }\n+                        None => {\n+                            // The only unsized typ we concider \"owning\" is TyStr.\n+                            assert_eq!(ty.sty, TyStr, \"Found a surprising unsized owning type\");\n+                            // The extra must be the length, in bytes.\n+                            match extra {\n+                                LvalueExtra::Length(len) => len,\n+                                _ => bug!(\"TyStr must have a length as extra\"),\n+                            }\n+                        }\n+                    };\n+                    // Handle locking\n+                    if len > 0 {\n+                        let ptr = ptr.to_ptr()?;\n+                        let access = match vctx.mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n+                        match vctx.op {\n+                            ValidationOp::Acquire => self.memory.acquire_lock(ptr, len, vctx.region, access)?,\n+                            ValidationOp::Release => self.memory.release_write_lock_until(ptr, len, None)?,\n+                            ValidationOp::Suspend(region) => self.memory.release_write_lock_until(ptr, len, Some(region))?,\n+                        }\n+                    }\n+                }\n+                Lvalue::Local { ..} | Lvalue::Global(..) => {\n+                    // These are not backed by memory, so we have nothing to do.\n+                }\n+            }\n+        }\n+\n         match ty.sty {\n-            TyChar | TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n+            TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n                 // TODO: Make sure these are not undef.\n                 // We could do a bounds-check and other sanity checks on the lvalue, but it would be a bug in miri for this to ever fail.\n                 Ok(())\n             }\n-            TyBool | TyFloat(_) | TyStr => {\n-                // TODO: Check if these are valid bool/float/UTF-8, respectively (and in particular, not undef).\n+            TyBool | TyFloat(_) | TyChar | TyStr => {\n+                // TODO: Check if these are valid bool/float/codepoint/UTF-8, respectively (and in particular, not undef).\n                 Ok(())\n             }\n             TyNever => {\n@@ -643,8 +677,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 Ok(())\n             }\n-            TyParam(_) | TyInfer(_) => bug!(\"I got an incomplete type for validation\"),\n-            _ => unimplemented!(\"Unimplemented type encountered when checking validity.\")\n+            _ => bug!(\"We already establishd that this is a type we support.\")\n         }\n     }\n }"}, {"sha": "70dfc0aef906c29c257709d9f3dd5c82fb4842e0", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 77, "deletions": 37, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4457a52d4f34dcc00234f1aa6047fcd5efeaf543/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4457a52d4f34dcc00234f1aa6047fcd5efeaf543/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4457a52d4f34dcc00234f1aa6047fcd5efeaf543", "patch": "@@ -39,6 +39,14 @@ mod range {\n             }\n         }\n \n+        pub fn offset(&self) -> u64 {\n+            self.start\n+        }\n+\n+        pub fn len(&self) -> u64 {\n+            self.end - self.start\n+        }\n+\n         pub fn range(offset: u64, len: u64) -> ops::Range<MemoryRange> {\n             assert!(len > 0);\n             // We select all elements that are within\n@@ -141,6 +149,32 @@ pub struct Allocation {\n     locks: BTreeMap<MemoryRange, Vec<LockInfo>>,\n }\n \n+impl Allocation {\n+    fn iter_locks<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=&'a LockInfo> + 'a {\n+        self.locks.range(MemoryRange::range(offset, len))\n+            .filter(move |&(range, _)| range.overlaps(offset, len))\n+            .flat_map(|(_, locks)| locks.iter())\n+    }\n+\n+    fn iter_lock_vecs_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a mut Vec<LockInfo>)> + 'a {\n+        self.locks.range_mut(MemoryRange::range(offset, len))\n+            .filter(move |&(range, _)| range.overlaps(offset, len))\n+    }\n+\n+    fn check_locks<'tcx>(&self, frame: usize, offset: u64, len: u64, access: AccessKind) -> Result<(), LockInfo> {\n+        if len == 0 {\n+            return Ok(())\n+        }\n+        for lock in self.iter_locks(offset, len) {\n+            // Check if the lock is active, and is in conflict with the access.\n+            if lock.status == LockStatus::Held && !lock.access_permitted(frame, access) {\n+                return Err(*lock);\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Copy, Clone)]\n pub enum Kind {\n     /// Error if deallocated any other way than `rust_deallocate`\n@@ -359,13 +393,16 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             Some(alloc) => alloc,\n             None => return Err(EvalError::DoubleFree),\n         };\n+        \n+        // It is okay for us to still holds locks on deallocation -- for example, we could store data we own\n+        // in a local, and the local could be deallocated (from StorageDead) before the function returns.\n+        // However, we must have write access to the entire allocation.\n+        alloc.check_locks(self.cur_frame, 0, alloc.bytes.len() as u64, AccessKind::Write)\n+            .map_err(|lock| EvalError::DeallocatedLockedMemory { ptr, lock })?;\n \n         if alloc.kind != kind {\n             return Err(EvalError::DeallocatedWrongMemoryKind(alloc.kind, kind));\n         }\n-        if alloc.locks.values().any(|locks| !locks.is_empty()) {\n-            return Err(EvalError::DeallocatedLockedMemory);\n-        }\n         if let Some((size, align)) = size_and_align {\n             if size != alloc.bytes.len() as u64 || align != alloc.align {\n                 return Err(EvalError::IncorrectAllocationInformation);\n@@ -510,24 +547,18 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Locking\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub(crate) fn check_locks(&self, ptr: MemoryPointer, len: u64, access: AccessKind) -> EvalResult<'tcx> {\n-        let alloc = self.get(ptr.alloc_id)?;\n-        for (range, locks) in alloc.locks.range(MemoryRange::range(ptr.offset, len)) {\n-            for lock in locks {\n-                // Check if the lock is active, overlaps this access, and is in conflict with the access.\n-                if lock.status == LockStatus::Held  && range.overlaps(ptr.offset, len) && !lock.access_permitted(self.cur_frame, access) {\n-                    return Err(EvalError::MemoryLockViolation { ptr, len, access, lock: *lock });\n-                }\n-            }\n+        if len == 0 {\n+            return Ok(())\n         }\n-        Ok(())\n+        let alloc = self.get(ptr.alloc_id)?;\n+        alloc.check_locks(self.cur_frame, ptr.offset, len, access)\n+            .map_err(|lock| EvalError::MemoryLockViolation { ptr, len, access, lock })\n     }\n \n     /// Acquire the lock for the given lifetime\n     pub(crate) fn acquire_lock(&mut self, ptr: MemoryPointer, len: u64, region: Option<CodeExtent>, kind: AccessKind) -> EvalResult<'tcx> {\n+        assert!(len > 0);\n         trace!(\"Acquiring {:?} lock at {:?}, size {} for region {:?}\", kind, ptr, len, region);\n-        if len == 0 {\n-            return Ok(());\n-        }\n         self.check_bounds(ptr.offset(len, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         self.check_locks(ptr, len, kind)?; // make sure we have the access we are acquiring\n         let lifetime = DynamicLifetime { frame: self.cur_frame, region };\n@@ -536,31 +567,39 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    /// Release a write lock prematurely\n-    pub(crate) fn release_lock_until(&mut self, ptr: MemoryPointer, len: u64, release_until: Option<CodeExtent>) -> EvalResult<'tcx> {\n-        trace!(\"Releasing write lock at {:?}, size {} until {:?}\", ptr, len, release_until);\n-        // Make sure there are no read locks and no *other* write locks here\n-        if let Err(_) = self.check_locks(ptr, len, AccessKind::Write) {\n-            return Err(EvalError::InvalidMemoryLockRelease { ptr, len });\n-        }\n+    /// Release a write lock prematurely. If there's just read locks, do nothing.\n+    pub(crate) fn release_write_lock_until(&mut self, ptr: MemoryPointer, len: u64, release_until: Option<CodeExtent>) -> EvalResult<'tcx> {\n+        assert!(len > 0);\n         let cur_frame = self.cur_frame;\n         let alloc = self.get_mut(ptr.alloc_id)?;\n-        let lock_infos = alloc.locks.get_mut(&MemoryRange::new(ptr.offset, len))\n-            .ok_or(EvalError::InvalidMemoryLockRelease { ptr, len })?;\n-        // Find the lock.  There can only be one active write lock, so this is uniquely defined.\n-        let lock_info_idx = lock_infos.iter().position(|lock_info| lock_info.status == LockStatus::Held)\n-                            .ok_or(EvalError::InvalidMemoryLockRelease { ptr, len })?;\n-        {\n-            let lock_info = &mut lock_infos[lock_info_idx];\n-            assert_eq!(lock_info.lifetime.frame, cur_frame);\n-            if let Some(ce) = release_until {\n-                lock_info.status = LockStatus::RecoverAfter(ce);\n-                return Ok(());\n+\n+        for (range, locks) in alloc.iter_lock_vecs_mut(ptr.offset, len) {\n+            if !range.contains(ptr.offset, len) {\n+                return Err(EvalError::Unimplemented(format!(\"miri does not support release part of a write-locked region\")));\n+            }\n+\n+            // Check all locks in this region; make sure there are no conflicting write locks of other frames.\n+            // Also, if we will recover later, perform our release by changing the lock status.\n+            for lock in locks.iter_mut() {\n+                if lock.kind == AccessKind::Read || lock.status != LockStatus::Held { continue; }\n+                if lock.lifetime.frame != cur_frame {\n+                    return Err(EvalError::InvalidMemoryLockRelease { ptr, len });\n+                }\n+                let ptr = MemoryPointer { alloc_id : ptr.alloc_id, offset: range.offset() };\n+                trace!(\"Releasing write lock at {:?}, size {} until {:?}\", ptr, range.len(), release_until);\n+                if let Some(region) = release_until {\n+                    lock.status = LockStatus::RecoverAfter(region);\n+                }\n+            }\n+\n+            // If we will not recove, we did not do anything above except for some checks. Now, erase the locks from the list.\n+            if let None = release_until {\n+                // Delete everything that's a held write lock.  We already checked above that these are ours.\n+                // Unfortunately, this duplicates the condition from above.  Is there anything we can do about this?\n+                locks.retain(|lock| lock.kind == AccessKind::Read || lock.status != LockStatus::Held);\n             }\n         }\n-        // Falling through to here means we want to entirely remove the lock.  The control-flow is somewhat weird because of lexical lifetimes.\n-        lock_infos.remove(lock_info_idx);\n-        // TODO: It may happen now that we leave an empty vector in the map.  Is it worth getting rid of them?\n+\n         Ok(())\n     }\n \n@@ -581,12 +620,13 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n         for alloc in self.alloc_map.values_mut() {\n             for (_range, locks) in alloc.locks.iter_mut() {\n-                // Delete everything that ends now -- i.e., keep only all the other lifeimes.\n+                // Delete everything that ends now -- i.e., keep only all the other lifetimes.\n                 locks.retain(|lock| !has_ended(lock));\n                 // Activate locks that get recovered now\n                 if let Some(ending_region) = ending_region {\n                     for lock in locks.iter_mut() {\n                         if lock.lifetime.frame == cur_frame && lock.status == LockStatus::RecoverAfter(ending_region) {\n+                            // FIXME: Check if this triggers a conflict between active locks\n                             lock.status = LockStatus::Held;\n                         }\n                     }"}, {"sha": "f1a37b30456ca16ddf208f33dd8a7aaa6b5e5a40", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4457a52d4f34dcc00234f1aa6047fcd5efeaf543/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4457a52d4f34dcc00234f1aa6047fcd5efeaf543/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=4457a52d4f34dcc00234f1aa6047fcd5efeaf543", "patch": "@@ -1,6 +1,7 @@\n #![feature(\n     i128_type,\n     rustc_private,\n+    conservative_impl_trait,\n )]\n \n // From rustc."}]}