{"sha": "0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "node_id": "C_kwDOAAsO6NoAKDBiMDExYjdiN2U1ZDFhMTczN2FhMzMzN2YwMWI3OWZkNWY1NmNmMDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-25T06:02:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-25T06:02:11Z"}, "message": "Auto merge of #111933 - matthiaskrgr:rollup-m10k3ts, r=matthiaskrgr\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #95198 (Add slice::{split_,}{first,last}_chunk{,_mut})\n - #109899 (Use apple-m1 as target CPU for aarch64-apple-darwin.)\n - #111624 (Emit diagnostic for privately uninhabited uncovered witnesses.)\n - #111875 (Don't leak the function that is called on drop)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "687c1a746df87c74af8b0ae892e2cd6876c51e98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/687c1a746df87c74af8b0ae892e2cd6876c51e98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "html_url": "https://github.com/rust-lang/rust/commit/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "776f22292fb5c2cc45f029d4b754662120732a6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/776f22292fb5c2cc45f029d4b754662120732a6a", "html_url": "https://github.com/rust-lang/rust/commit/776f22292fb5c2cc45f029d4b754662120732a6a"}, {"sha": "a9743e108a254809a7235460f9ba9e000776c507", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9743e108a254809a7235460f9ba9e000776c507", "html_url": "https://github.com/rust-lang/rust/commit/a9743e108a254809a7235460f9ba9e000776c507"}], "stats": {"total": 330, "additions": 313, "deletions": 17}, "files": [{"sha": "859e384d8b529c5985c54a419e4b09558d180363", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -102,21 +102,27 @@ pub mod unord;\n pub use ena::undo_log;\n pub use ena::unify;\n \n-pub struct OnDrop<F: Fn()>(pub F);\n+/// Returns a structure that calls `f` when dropped.\n+pub fn defer<F: FnOnce()>(f: F) -> OnDrop<F> {\n+    OnDrop(Some(f))\n+}\n+\n+pub struct OnDrop<F: FnOnce()>(Option<F>);\n \n-impl<F: Fn()> OnDrop<F> {\n-    /// Forgets the function which prevents it from running.\n-    /// Ensure that the function owns no memory, otherwise it will be leaked.\n+impl<F: FnOnce()> OnDrop<F> {\n+    /// Disables on-drop call.\n     #[inline]\n-    pub fn disable(self) {\n-        std::mem::forget(self);\n+    pub fn disable(mut self) {\n+        self.0.take();\n     }\n }\n \n-impl<F: Fn()> Drop for OnDrop<F> {\n+impl<F: FnOnce()> Drop for OnDrop<F> {\n     #[inline]\n     fn drop(&mut self) {\n-        (self.0)();\n+        if let Some(f) = self.0.take() {\n+            f();\n+        }\n     }\n }\n "}, {"sha": "520871a12be99d210ccaa28f3eb323e224e0ecfb", "filename": "compiler/rustc_data_structures/src/owned_slice/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -7,8 +7,8 @@ use std::{\n };\n \n use crate::{\n+    defer,\n     owned_slice::{slice_owned, try_slice_owned, OwnedSlice},\n-    OnDrop,\n };\n \n #[test]\n@@ -66,7 +66,7 @@ fn boxed() {\n fn drop_drops() {\n     let flag = Arc::new(AtomicBool::new(false));\n     let flag_prime = Arc::clone(&flag);\n-    let d = OnDrop(move || flag_prime.store(true, atomic::Ordering::Relaxed));\n+    let d = defer(move || flag_prime.store(true, atomic::Ordering::Relaxed));\n \n     let slice = slice_owned(d, |_| &[]);\n "}, {"sha": "39d56897999d9be18d710686c46474f945545e0a", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -3,9 +3,9 @@ use crate::util;\n use rustc_ast::token;\n use rustc_ast::{self as ast, LitKind, MetaItemKind};\n use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_data_structures::defer;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::OnDrop;\n use rustc_errors::registry::Registry;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_lint::LintStore;\n@@ -325,7 +325,7 @@ pub fn run_compiler<R: Send>(config: Config, f: impl FnOnce(&Compiler) -> R + Se\n \n             rustc_span::set_source_map(compiler.sess.parse_sess.clone_source_map(), move || {\n                 let r = {\n-                    let _sess_abort_error = OnDrop(|| {\n+                    let _sess_abort_error = defer(|| {\n                         compiler.sess.finish_diagnostics(registry);\n                     });\n "}, {"sha": "9de77b9fda11a20372c00507b7f3e5dfcdc95534", "filename": "compiler/rustc_middle/src/ty/context/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -78,7 +78,7 @@ where\n {\n     TLV.with(|tlv| {\n         let old = tlv.replace(erase(context));\n-        let _reset = rustc_data_structures::OnDrop(move || tlv.set(old));\n+        let _reset = rustc_data_structures::defer(move || tlv.set(old));\n         f()\n     })\n }"}, {"sha": "0282492a261c85dfbaa25f8c41037f333165bb3b", "filename": "compiler/rustc_mir_build/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_mir_build%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_mir_build%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fmessages.ftl?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -340,6 +340,8 @@ mir_build_uncovered = {$count ->\n         *[other] patterns `{$witness_1}`, `{$witness_2}`, `{$witness_3}` and {$remainder} more\n     } not covered\n \n+mir_build_privately_uninhabited = pattern `{$witness_1}` is currently uninhabited, but this variant contains private fields which may become inhabited in the future\n+\n mir_build_pattern_not_covered = refutable pattern in {$origin}\n     .pattern_ty = the matched value is of type `{$pattern_ty}`\n "}, {"sha": "7c0df201bc25e96f6f1f43f09c0ba69d6e863c0d", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -781,6 +781,8 @@ pub(crate) struct PatternNotCovered<'s, 'tcx> {\n     pub interpreted_as_const: Option<InterpretedAsConst>,\n     #[subdiagnostic]\n     pub adt_defined_here: Option<AdtDefinedHere<'tcx>>,\n+    #[note(mir_build_privately_uninhabited)]\n+    pub witness_1_is_privately_uninhabited: Option<()>,\n     #[note(mir_build_pattern_ty)]\n     pub _p: (),\n     pub pattern_ty: Ty<'tcx>,"}, {"sha": "5559e8b3940aeb5634685c7fdea98885d0e3e23b", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -479,12 +479,30 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             AdtDefinedHere { adt_def_span, ty, variants }\n         };\n \n+        // Emit an extra note if the first uncovered witness is\n+        // visibly uninhabited anywhere in the current crate.\n+        let witness_1_is_privately_uninhabited =\n+            if cx.tcx.features().exhaustive_patterns\n+                && let Some(witness_1) = witnesses.get(0)\n+                && let ty::Adt(adt, substs) = witness_1.ty().kind()\n+                && adt.is_enum()\n+                && let Constructor::Variant(variant_index) = witness_1.ctor()\n+            {\n+                let variant = adt.variant(*variant_index);\n+                let inhabited = variant.inhabited_predicate(cx.tcx, *adt).subst(cx.tcx, substs);\n+                assert!(inhabited.apply(cx.tcx, cx.param_env, cx.module));\n+                !inhabited.apply_ignore_module(cx.tcx, cx.param_env)\n+            } else {\n+                false\n+            };\n+\n         self.error = Err(self.tcx.sess.emit_err(PatternNotCovered {\n             span: pat.span,\n             origin,\n             uncovered: Uncovered::new(pat.span, &cx, witnesses),\n             inform,\n             interpreted_as_const,\n+            witness_1_is_privately_uninhabited: witness_1_is_privately_uninhabited.then_some(()),\n             _p: (),\n             pattern_ty,\n             let_suggestion,"}, {"sha": "f45f7ca5da6dd9d9dd6330a9898dae9cca078ea8", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -22,7 +22,7 @@ use {\n     rustc_data_structures::fx::FxHashSet,\n     rustc_data_structures::sync::Lock,\n     rustc_data_structures::sync::Lrc,\n-    rustc_data_structures::{jobserver, OnDrop},\n+    rustc_data_structures::{defer, jobserver},\n     rustc_span::DUMMY_SP,\n     std::iter,\n     std::process,\n@@ -530,7 +530,7 @@ fn remove_cycle<D: DepKind>(\n /// all active queries for cycles before finally resuming all the waiters at once.\n #[cfg(parallel_compiler)]\n pub fn deadlock<D: DepKind>(query_map: QueryMap<D>, registry: &rayon_core::Registry) {\n-    let on_panic = OnDrop(|| {\n+    let on_panic = defer(|| {\n         eprintln!(\"deadlock handler panicked, aborting process\");\n         process::abort();\n     });"}, {"sha": "9ac732351411c8df5b65b0816182d29eb85a2068", "filename": "compiler/rustc_target/src/spec/aarch64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -4,7 +4,7 @@ use crate::spec::{FramePointer, SanitizerSet, Target, TargetOptions};\n pub fn target() -> Target {\n     let arch = Arch::Arm64;\n     let mut base = opts(\"macos\", arch);\n-    base.cpu = \"apple-a14\".into();\n+    base.cpu = \"apple-m1\".into();\n     base.max_atomic_width = Some(128);\n \n     // FIXME: The leak sanitizer currently fails the tests, see #88132."}, {"sha": "c787b7288b0607d9332dee509f23126a526b1c10", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -319,6 +319,264 @@ impl<T> [T] {\n         if let [.., last] = self { Some(last) } else { None }\n     }\n \n+    /// Returns the first `N` elements of the slice, or `None` if it has fewer than `N` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let u = [10, 40, 30];\n+    /// assert_eq!(Some(&[10, 40]), u.first_chunk::<2>());\n+    ///\n+    /// let v: &[i32] = &[10];\n+    /// assert_eq!(None, v.first_chunk::<2>());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(Some(&[]), w.first_chunk::<0>());\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn first_chunk<const N: usize>(&self) -> Option<&[T; N]> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   and do not let the reference outlive the slice.\n+            Some(unsafe { &*(self.as_ptr() as *const [T; N]) })\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the first `N` elements of the slice,\n+    /// or `None` if it has fewer than `N` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(first) = x.first_chunk_mut::<2>() {\n+    ///     first[0] = 5;\n+    ///     first[1] = 4;\n+    /// }\n+    /// assert_eq!(x, &[5, 4, 2]);\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn first_chunk_mut<const N: usize>(&mut self) -> Option<&mut [T; N]> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   do not let the reference outlive the slice,\n+            //   and require exclusive access to the entire slice to mutate the chunk.\n+            Some(unsafe { &mut *(self.as_mut_ptr() as *mut [T; N]) })\n+        }\n+    }\n+\n+    /// Returns the first `N` elements of the slice and the remainder,\n+    /// or `None` if it has fewer than `N` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &[0, 1, 2];\n+    ///\n+    /// if let Some((first, elements)) = x.split_first_chunk::<2>() {\n+    ///     assert_eq!(first, &[0, 1]);\n+    ///     assert_eq!(elements, &[2]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn split_first_chunk<const N: usize>(&self) -> Option<(&[T; N], &[T])> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the split.\n+            let (first, tail) = unsafe { self.split_at_unchecked(N) };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   and do not let the references outlive the slice.\n+            Some((unsafe { &*(first.as_ptr() as *const [T; N]) }, tail))\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the first `N` elements of the slice and the remainder,\n+    /// or `None` if it has fewer than `N` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some((first, elements)) = x.split_first_chunk_mut::<2>() {\n+    ///     first[0] = 3;\n+    ///     first[1] = 4;\n+    ///     elements[0] = 5;\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 5]);\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn split_first_chunk_mut<const N: usize>(\n+        &mut self,\n+    ) -> Option<(&mut [T; N], &mut [T])> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the split.\n+            let (first, tail) = unsafe { self.split_at_mut_unchecked(N) };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   do not let the reference outlive the slice,\n+            //   and enforce exclusive mutability of the chunk by the split.\n+            Some((unsafe { &mut *(first.as_mut_ptr() as *mut [T; N]) }, tail))\n+        }\n+    }\n+\n+    /// Returns the last `N` elements of the slice and the remainder,\n+    /// or `None` if it has fewer than `N` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &[0, 1, 2];\n+    ///\n+    /// if let Some((last, elements)) = x.split_last_chunk::<2>() {\n+    ///     assert_eq!(last, &[1, 2]);\n+    ///     assert_eq!(elements, &[0]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn split_last_chunk<const N: usize>(&self) -> Option<(&[T; N], &[T])> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the split.\n+            let (init, last) = unsafe { self.split_at_unchecked(self.len() - N) };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   and do not let the references outlive the slice.\n+            Some((unsafe { &*(last.as_ptr() as *const [T; N]) }, init))\n+        }\n+    }\n+\n+    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some((last, elements)) = x.split_last_chunk_mut::<2>() {\n+    ///     last[0] = 3;\n+    ///     last[1] = 4;\n+    ///     elements[0] = 5;\n+    /// }\n+    /// assert_eq!(x, &[5, 3, 4]);\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn split_last_chunk_mut<const N: usize>(\n+        &mut self,\n+    ) -> Option<(&mut [T; N], &mut [T])> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the split.\n+            let (init, last) = unsafe { self.split_at_mut_unchecked(self.len() - N) };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   do not let the reference outlive the slice,\n+            //   and enforce exclusive mutability of the chunk by the split.\n+            Some((unsafe { &mut *(last.as_mut_ptr() as *mut [T; N]) }, init))\n+        }\n+    }\n+\n+    /// Returns the last element of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let u = [10, 40, 30];\n+    /// assert_eq!(Some(&[40, 30]), u.last_chunk::<2>());\n+    ///\n+    /// let v: &[i32] = &[10];\n+    /// assert_eq!(None, v.last_chunk::<2>());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(Some(&[]), w.last_chunk::<0>());\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn last_chunk<const N: usize>(&self) -> Option<&[T; N]> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the slice.\n+            // FIXME: Without const traits, we need this instead of `get_unchecked`.\n+            let last = unsafe { self.split_at_unchecked(self.len() - N).1 };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   and do not let the references outlive the slice.\n+            Some(unsafe { &*(last.as_ptr() as *const [T; N]) })\n+        }\n+    }\n+\n+    /// Returns a mutable pointer to the last item in the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(last) = x.last_chunk_mut::<2>() {\n+    ///     last[0] = 10;\n+    ///     last[1] = 20;\n+    /// }\n+    /// assert_eq!(x, &[0, 10, 20]);\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn last_chunk_mut<const N: usize>(&mut self) -> Option<&mut [T; N]> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the slice.\n+            // FIXME: Without const traits, we need this instead of `get_unchecked`.\n+            let last = unsafe { self.split_at_mut_unchecked(self.len() - N).1 };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   do not let the reference outlive the slice,\n+            //   and require exclusive access to the entire slice to mutate the chunk.\n+            Some(unsafe { &mut *(last.as_mut_ptr() as *mut [T; N]) })\n+        }\n+    }\n+\n     /// Returns a reference to an element or subslice depending on the type of\n     /// index.\n     ///"}, {"sha": "f7bf8581582316884971f4439c0007fd5b04dbf8", "filename": "tests/ui/never_type/exhaustive_patterns.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -14,6 +14,7 @@ LL | enum Either<A, B> {\n LL |     A(A),\n LL |     B(inner::Wrapper<B>),\n    |     - not covered\n+   = note: pattern `Either::B(_)` is currently uninhabited, but this variant contains private fields which may become inhabited in the future\n    = note: the matched value is of type `Either<(), !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "cfd60a8d903fa0c1945668caf61e3be4893eba3f", "filename": "tests/ui/uninhabited/uninhabited-irrefutable.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -16,7 +16,9 @@ struct NotSoSecretlyEmpty {\n }\n \n enum Foo {\n+    //~^ NOTE `Foo` defined here\n     A(foo::SecretlyEmpty),\n+    //~^ NOTE not covered\n     B(foo::NotSoSecretlyEmpty),\n     C(NotSoSecretlyEmpty),\n     D(u32, u32),\n@@ -27,4 +29,9 @@ fn main() {\n     let Foo::D(_y, _z) = x;\n     //~^ ERROR refutable pattern in local binding\n     //~| `Foo::A(_)` not covered\n+    //~| NOTE `let` bindings require an \"irrefutable pattern\"\n+    //~| NOTE for more information\n+    //~| NOTE pattern `Foo::A(_)` is currently uninhabited\n+    //~| NOTE the matched value is of type `Foo`\n+    //~| HELP you might want to use `let else`\n }"}, {"sha": "daf75f51b5a110a5d8f416ea7a583cec9d388cf7", "filename": "tests/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -1,5 +1,5 @@\n error[E0005]: refutable pattern in local binding\n-  --> $DIR/uninhabited-irrefutable.rs:27:9\n+  --> $DIR/uninhabited-irrefutable.rs:29:9\n    |\n LL |     let Foo::D(_y, _z) = x;\n    |         ^^^^^^^^^^^^^^ pattern `Foo::A(_)` not covered\n@@ -11,8 +11,10 @@ note: `Foo` defined here\n    |\n LL | enum Foo {\n    |      ^^^\n+LL |\n LL |     A(foo::SecretlyEmpty),\n    |     - not covered\n+   = note: pattern `Foo::A(_)` is currently uninhabited, but this variant contains private fields which may become inhabited in the future\n    = note: the matched value is of type `Foo`\n help: you might want to use `let else` to handle the variant that isn't matched\n    |"}]}