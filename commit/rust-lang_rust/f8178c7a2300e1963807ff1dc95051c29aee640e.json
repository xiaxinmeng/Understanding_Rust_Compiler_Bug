{"sha": "f8178c7a2300e1963807ff1dc95051c29aee640e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MTc4YzdhMjMwMGUxOTYzODA3ZmYxZGM5NTA1MWMyOWFlZTY0MGU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-18T20:31:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-19T12:25:50Z"}, "message": "rustc: use LocalDefId instead of DefId in TypeckTables.", "tree": {"sha": "0dbb8593755a9c827f9dbc2f10cd33eea514e599", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dbb8593755a9c827f9dbc2f10cd33eea514e599"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8178c7a2300e1963807ff1dc95051c29aee640e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8178c7a2300e1963807ff1dc95051c29aee640e", "html_url": "https://github.com/rust-lang/rust/commit/f8178c7a2300e1963807ff1dc95051c29aee640e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8178c7a2300e1963807ff1dc95051c29aee640e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c6f982cc908aacc39c3ac97f31c989f81cc213c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c6f982cc908aacc39c3ac97f31c989f81cc213c", "html_url": "https://github.com/rust-lang/rust/commit/3c6f982cc908aacc39c3ac97f31c989f81cc213c"}], "stats": {"total": 219, "additions": 94, "deletions": 125}, "files": [{"sha": "a90a9b933700ecfa7e9426044271904b7be5b85f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 50, "deletions": 77, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f8178c7a2300e1963807ff1dc95051c29aee640e", "patch": "@@ -188,37 +188,37 @@ pub struct CommonConsts<'tcx> {\n }\n \n pub struct LocalTableInContext<'a, V> {\n-    local_id_root: Option<DefId>,\n+    hir_owner: Option<LocalDefId>,\n     data: &'a ItemLocalMap<V>,\n }\n \n /// Validate that the given HirId (respectively its `local_id` part) can be\n /// safely used as a key in the tables of a TypeckTable. For that to be\n /// the case, the HirId must have the same `owner` as all the other IDs in\n-/// this table (signified by `local_id_root`). Otherwise the HirId\n+/// this table (signified by `hir_owner`). Otherwise the HirId\n /// would be in a different frame of reference and using its `local_id`\n /// would result in lookup errors, or worse, in silently wrong data being\n /// stored/returned.\n fn validate_hir_id_for_typeck_tables(\n-    local_id_root: Option<DefId>,\n+    hir_owner: Option<LocalDefId>,\n     hir_id: hir::HirId,\n     mut_access: bool,\n ) {\n-    if let Some(local_id_root) = local_id_root {\n-        if hir_id.owner.to_def_id() != local_id_root {\n+    if let Some(hir_owner) = hir_owner {\n+        if hir_id.owner != hir_owner {\n             ty::tls::with(|tcx| {\n                 bug!(\n                     \"node {} with HirId::owner {:?} cannot be placed in \\\n-                     TypeckTables with local_id_root {:?}\",\n+                     TypeckTables with hir_owner {:?}\",\n                     tcx.hir().node_to_string(hir_id),\n                     hir_id.owner,\n-                    local_id_root\n+                    hir_owner\n                 )\n             });\n         }\n     } else {\n         // We use \"Null Object\" TypeckTables in some of the analysis passes.\n-        // These are just expected to be empty and their `local_id_root` is\n+        // These are just expected to be empty and their `hir_owner` is\n         // `None`. Therefore we cannot verify whether a given `HirId` would\n         // be a valid key for the given table. Instead we make sure that\n         // nobody tries to write to such a Null Object table.\n@@ -230,12 +230,12 @@ fn validate_hir_id_for_typeck_tables(\n \n impl<'a, V> LocalTableInContext<'a, V> {\n     pub fn contains_key(&self, id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.data.contains_key(&id.local_id)\n     }\n \n     pub fn get(&self, id: hir::HirId) -> Option<&V> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.data.get(&id.local_id)\n     }\n \n@@ -253,28 +253,28 @@ impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n }\n \n pub struct LocalTableInContextMut<'a, V> {\n-    local_id_root: Option<DefId>,\n+    hir_owner: Option<LocalDefId>,\n     data: &'a mut ItemLocalMap<V>,\n }\n \n impl<'a, V> LocalTableInContextMut<'a, V> {\n     pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n         self.data.get_mut(&id.local_id)\n     }\n \n     pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n         self.data.entry(id.local_id)\n     }\n \n     pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n         self.data.insert(id.local_id, val)\n     }\n \n     pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n         self.data.remove(&id.local_id)\n     }\n }\n@@ -322,8 +322,8 @@ pub struct GeneratorInteriorTypeCause<'tcx> {\n \n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct TypeckTables<'tcx> {\n-    /// The HirId::owner all ItemLocalIds in this table are relative to.\n-    pub local_id_root: Option<DefId>,\n+    /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n+    pub hir_owner: Option<LocalDefId>,\n \n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n@@ -431,9 +431,9 @@ pub struct TypeckTables<'tcx> {\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n-    pub fn empty(local_id_root: Option<DefId>) -> TypeckTables<'tcx> {\n+    pub fn empty(hir_owner: Option<LocalDefId>) -> TypeckTables<'tcx> {\n         TypeckTables {\n-            local_id_root,\n+            hir_owner,\n             type_dependent_defs: Default::default(),\n             field_indices: Default::default(),\n             user_provided_types: Default::default(),\n@@ -469,11 +469,11 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn type_dependent_defs(\n         &self,\n     ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorReported>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.type_dependent_defs }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.type_dependent_defs }\n     }\n \n     pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n     }\n \n@@ -484,39 +484,33 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn type_dependent_defs_mut(\n         &mut self,\n     ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorReported>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.type_dependent_defs,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.type_dependent_defs }\n     }\n \n     pub fn field_indices(&self) -> LocalTableInContext<'_, usize> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.field_indices }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.field_indices }\n     }\n \n     pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, usize> {\n-        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.field_indices }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n     }\n \n     pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.user_provided_types }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.user_provided_types }\n     }\n \n     pub fn user_provided_types_mut(\n         &mut self,\n     ) -> LocalTableInContextMut<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.user_provided_types,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.user_provided_types }\n     }\n \n     pub fn node_types(&self) -> LocalTableInContext<'_, Ty<'tcx>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.node_types }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.node_types }\n     }\n \n     pub fn node_types_mut(&mut self) -> LocalTableInContextMut<'_, Ty<'tcx>> {\n-        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.node_types }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_types }\n     }\n \n     pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n@@ -526,21 +520,21 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.node_types.get(&id.local_id).cloned()\n     }\n \n     pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, SubstsRef<'tcx>> {\n-        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.node_substs }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_substs }\n     }\n \n     pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n     }\n \n     pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n@@ -573,17 +567,17 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn adjustments(&self) -> LocalTableInContext<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.adjustments }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.adjustments }\n     }\n \n     pub fn adjustments_mut(\n         &mut self,\n     ) -> LocalTableInContextMut<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.adjustments }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.adjustments }\n     }\n \n     pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, expr.hir_id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, expr.hir_id, false);\n         self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n@@ -618,66 +612,51 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.pat_binding_modes }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_binding_modes }\n     }\n \n     pub fn pat_binding_modes_mut(&mut self) -> LocalTableInContextMut<'_, BindingMode> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.pat_binding_modes,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_binding_modes }\n     }\n \n     pub fn pat_adjustments(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.pat_adjustments }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_adjustments }\n     }\n \n     pub fn pat_adjustments_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.pat_adjustments,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n \n     pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, ast::Name)> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.closure_kind_origins }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n     }\n \n     pub fn closure_kind_origins_mut(&mut self) -> LocalTableInContextMut<'_, (Span, ast::Name)> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.closure_kind_origins,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.closure_kind_origins }\n     }\n \n     pub fn liberated_fn_sigs(&self) -> LocalTableInContext<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.liberated_fn_sigs }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.liberated_fn_sigs }\n     }\n \n     pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.liberated_fn_sigs,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.liberated_fn_sigs }\n     }\n \n     pub fn fru_field_types(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.fru_field_types }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.fru_field_types }\n     }\n \n     pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.fru_field_types,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.fru_field_types }\n     }\n \n     pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, hir_id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, hir_id, true);\n         self.coercion_casts.contains(&hir_id.local_id)\n     }\n \n@@ -693,7 +672,7 @@ impl<'tcx> TypeckTables<'tcx> {\n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ty::TypeckTables {\n-            local_id_root,\n+            hir_owner,\n             ref type_dependent_defs,\n             ref field_indices,\n             ref user_provided_types,\n@@ -730,18 +709,12 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             hash_stable_hashmap(hcx, hasher, upvar_capture_map, |up_var_id, hcx| {\n                 let ty::UpvarId { var_path, closure_expr_id } = *up_var_id;\n \n-                let local_id_root = local_id_root.expect(\"trying to hash invalid TypeckTables\");\n+                assert_eq!(Some(var_path.hir_id.owner), hir_owner);\n \n-                let var_owner_def_id = DefId {\n-                    krate: local_id_root.krate,\n-                    index: var_path.hir_id.owner.local_def_index,\n-                };\n-                let closure_def_id =\n-                    DefId { krate: local_id_root.krate, index: closure_expr_id.local_def_index };\n                 (\n-                    hcx.def_path_hash(var_owner_def_id),\n+                    hcx.local_def_path_hash(var_path.hir_id.owner),\n                     var_path.hir_id.local_id,\n-                    hcx.def_path_hash(closure_def_id),\n+                    hcx.local_def_path_hash(closure_expr_id),\n                 )\n             });\n "}, {"sha": "78f97c40cbd1277f3c9a1af4466b63e3231e755a", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f8178c7a2300e1963807ff1dc95051c29aee640e", "patch": "@@ -1784,11 +1784,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // suggest adding an explicit lifetime bound to it.\n         let type_param_span = match (self.in_progress_tables, bound_kind) {\n             (Some(ref table), GenericKind::Param(ref param)) => {\n-                let table = table.borrow();\n-                table.local_id_root.and_then(|did| {\n-                    let generics = self.tcx.generics_of(did);\n-                    // Account for the case where `did` corresponds to `Self`, which doesn't have\n-                    // the expected type argument.\n+                let table_owner = table.borrow().hir_owner;\n+                table_owner.and_then(|table_owner| {\n+                    let generics = self.tcx.generics_of(table_owner.to_def_id());\n+                    // Account for the case where `param` corresponds to `Self`,\n+                    // which doesn't have the expected type argument.\n                     if !(generics.has_self && param.index == 0) {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();"}, {"sha": "70967940e7bf8b8d68768c2e7d2a2b3bda5f0a7b", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=f8178c7a2300e1963807ff1dc95051c29aee640e", "patch": "@@ -29,7 +29,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unify as ut;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_session::config::BorrowckMode;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -559,7 +559,7 @@ impl TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n-    pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n+    pub fn with_fresh_in_progress_tables(mut self, table_owner: LocalDefId) -> Self {\n         self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty(Some(table_owner))));\n         self\n     }"}, {"sha": "fec9ecbd64a2e7d46c452677a003acba175f6833", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f8178c7a2300e1963807ff1dc95051c29aee640e", "patch": "@@ -1105,15 +1105,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let generator_did_root = self.tcx.closure_base_def_id(generator_did);\n         debug!(\n             \"maybe_note_obligation_cause_for_async_await: generator_did={:?} \\\n-             generator_did_root={:?} in_progress_tables.local_id_root={:?} span={:?}\",\n+             generator_did_root={:?} in_progress_tables.hir_owner={:?} span={:?}\",\n             generator_did,\n             generator_did_root,\n-            in_progress_tables.as_ref().map(|t| t.local_id_root),\n+            in_progress_tables.as_ref().map(|t| t.hir_owner),\n             span\n         );\n         let query_tables;\n         let tables: &TypeckTables<'tcx> = match &in_progress_tables {\n-            Some(t) if t.local_id_root == Some(generator_did_root) => t,\n+            Some(t) if t.hir_owner.map(|owner| owner.to_def_id()) == Some(generator_did_root) => t,\n             _ => {\n                 query_tables = self.tcx.typeck_tables_of(generator_did);\n                 &query_tables"}, {"sha": "6178158e4e504c7555c256fdcf004a118fd916d0", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f8178c7a2300e1963807ff1dc95051c29aee640e", "patch": "@@ -213,7 +213,7 @@ fn compare_predicate_entailment<'tcx>(\n     );\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let inh = Inherited::new(infcx, impl_m.def_id);\n+        let inh = Inherited::new(infcx, impl_m.def_id.expect_local());\n         let infcx = &inh.infcx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds);\n@@ -950,7 +950,7 @@ crate fn compare_const_impl<'tcx>(\n \n     tcx.infer_ctxt().enter(|infcx| {\n         let param_env = tcx.param_env(impl_c.def_id);\n-        let inh = Inherited::new(infcx, impl_c.def_id);\n+        let inh = Inherited::new(infcx, impl_c.def_id.expect_local());\n         let infcx = &inh.infcx;\n \n         // The below is for the most part highly similar to the procedure\n@@ -1130,7 +1130,7 @@ fn compare_type_predicate_entailment(\n         normalize_cause.clone(),\n     );\n     tcx.infer_ctxt().enter(|infcx| {\n-        let inh = Inherited::new(infcx, impl_ty.def_id);\n+        let inh = Inherited::new(infcx, impl_ty.def_id.expect_local());\n         let infcx = &inh.infcx;\n \n         debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds);"}, {"sha": "061433bcf6515749cc7305a2e66dddc98de03012", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f8178c7a2300e1963807ff1dc95051c29aee640e", "patch": "@@ -1018,9 +1018,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Obtain the span for `param` and use it for a structured suggestion.\n             let mut suggested = false;\n             if let (Some(ref param), Some(ref table)) = (param_type, self.in_progress_tables) {\n-                let table = table.borrow();\n-                if let Some(did) = table.local_id_root {\n-                    let generics = self.tcx.generics_of(did);\n+                let table_owner = table.borrow().hir_owner;\n+                if let Some(table_owner) = table_owner {\n+                    let generics = self.tcx.generics_of(table_owner.to_def_id());\n                     let type_param = generics.type_param(param, self.tcx);\n                     let hir = &self.tcx.hir();\n                     if let Some(id) = hir.as_local_hir_id(type_param.def_id) {"}, {"sha": "ab99918e00582b5410c968f90af47745b06b2fc8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f8178c7a2300e1963807ff1dc95051c29aee640e", "patch": "@@ -112,7 +112,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n@@ -633,19 +633,15 @@ impl<'a, 'tcx> Deref for FnCtxt<'a, 'tcx> {\n /// `F: for<'b, 'tcx> where 'tcx FnOnce(Inherited<'b, 'tcx>)`.\n pub struct InheritedBuilder<'tcx> {\n     infcx: infer::InferCtxtBuilder<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n }\n \n impl Inherited<'_, 'tcx> {\n-    pub fn build(tcx: TyCtxt<'tcx>, def_id: DefId) -> InheritedBuilder<'tcx> {\n-        let hir_id_root = if let Some(def_id) = def_id.as_local() {\n-            tcx.hir().local_def_id_to_hir_id(def_id).owner.to_def_id()\n-        } else {\n-            def_id\n-        };\n+    pub fn build(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> InheritedBuilder<'tcx> {\n+        let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n \n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(hir_id_root),\n+            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(hir_owner),\n             def_id,\n         }\n     }\n@@ -662,10 +658,10 @@ impl<'tcx> InheritedBuilder<'tcx> {\n }\n \n impl Inherited<'a, 'tcx> {\n-    fn new(infcx: InferCtxt<'a, 'tcx>, def_id: DefId) -> Self {\n+    fn new(infcx: InferCtxt<'a, 'tcx>, def_id: LocalDefId) -> Self {\n         let tcx = infcx.tcx;\n-        let item_id = tcx.hir().as_local_hir_id(def_id);\n-        let body_id = item_id.and_then(|id| tcx.hir().maybe_body_owned_by(id));\n+        let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let body_id = tcx.hir().maybe_body_owned_by(item_id);\n         let implicit_region_bound = body_id.map(|body_id| {\n             let body = tcx.hir().body(body_id);\n             tcx.mk_region(ty::ReScope(region::Scope {\n@@ -1002,7 +998,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n     });\n     let body = tcx.hir().body(body_id);\n \n-    let tables = Inherited::build(tcx, def_id).enter(|inh| {\n+    let tables = Inherited::build(tcx, def_id.expect_local()).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n         let fcx = if let (Some(header), Some(decl)) = (fn_header, fn_decl) {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n@@ -1127,7 +1123,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n \n     // Consistency check our TypeckTables instance can hold all ItemLocalIds\n     // it will need to hold.\n-    assert_eq!(tables.local_id_root, Some(id.owner.to_def_id()));\n+    assert_eq!(tables.hir_owner, Some(id.owner));\n \n     tables\n }"}, {"sha": "72c58af7912fba51ac76e0ecb849e6f45b9367c1", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f8178c7a2300e1963807ff1dc95051c29aee640e", "patch": "@@ -316,12 +316,12 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<\n }\n \n fn for_id(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'_> {\n-    let def_id = tcx.hir().local_def_id(id);\n+    let def_id = tcx.hir().local_def_id(id).expect_local();\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n         id,\n         span,\n-        param_env: tcx.param_env(def_id),\n+        param_env: tcx.param_env(def_id.to_def_id()),\n     }\n }\n "}, {"sha": "65f81ef033dd7288300b46928bb809c83d1569a8", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8178c7a2300e1963807ff1dc95051c29aee640e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f8178c7a2300e1963807ff1dc95051c29aee640e", "patch": "@@ -111,7 +111,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n         WritebackCx {\n             fcx,\n-            tables: ty::TypeckTables::empty(Some(owner.to_def_id())),\n+            tables: ty::TypeckTables::empty(Some(owner)),\n             body,\n             rustc_dump_user_substs,\n         }\n@@ -338,19 +338,19 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_closures(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n-        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n+        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n \n         for (&id, &origin) in fcx_tables.closure_kind_origins().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id: id };\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id: id };\n             self.tables.closure_kind_origins_mut().insert(hir_id, origin);\n         }\n     }\n \n     fn visit_coercion_casts(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         let fcx_coercion_casts = fcx_tables.coercion_casts();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n \n         for local_id in fcx_coercion_casts {\n             self.tables.set_coercion_cast(*local_id);\n@@ -359,12 +359,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_user_provided_tys(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n-        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n+        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n \n         let mut errors_buffer = Vec::new();\n         for (&local_id, c_ty) in fcx_tables.user_provided_types().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id };\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n             if cfg!(debug_assertions) && c_ty.has_local_value() {\n                 span_bug!(hir_id.to_span(self.fcx.tcx), \"writeback: `{:?}` is a local value\", c_ty);\n@@ -397,7 +397,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_user_provided_sigs(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n \n         for (&def_id, c_sig) in fcx_tables.user_provided_sigs.iter() {\n             if cfg!(debug_assertions) && c_sig.has_local_value() {\n@@ -414,7 +414,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_generator_interior_types(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n         self.tables.generator_interior_types = fcx_tables.generator_interior_types.clone();\n     }\n \n@@ -553,23 +553,23 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_liberated_fn_sigs(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n-        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n+        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n \n         for (&local_id, fn_sig) in fcx_tables.liberated_fn_sigs().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id };\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n             self.tables.liberated_fn_sigs_mut().insert(hir_id, fn_sig.clone());\n         }\n     }\n \n     fn visit_fru_field_types(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n-        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n+        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n \n         for (&local_id, ftys) in fcx_tables.fru_field_types().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id };\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let ftys = self.resolve(ftys, &hir_id);\n             self.tables.fru_field_types_mut().insert(hir_id, ftys);\n         }"}]}