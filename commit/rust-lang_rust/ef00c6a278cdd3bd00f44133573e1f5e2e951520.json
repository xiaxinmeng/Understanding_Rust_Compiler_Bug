{"sha": "ef00c6a278cdd3bd00f44133573e1f5e2e951520", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMDBjNmEyNzhjZGQzYmQwMGY0NDEzMzU3M2UxZjVlMmU5NTE1MjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-30T01:39:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T17:32:33Z"}, "message": "extra: Remove io_error usage", "tree": {"sha": "1e74bbc9ca8909aced3cbb4e105bf9e41799b8f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e74bbc9ca8909aced3cbb4e105bf9e41799b8f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef00c6a278cdd3bd00f44133573e1f5e2e951520", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef00c6a278cdd3bd00f44133573e1f5e2e951520", "html_url": "https://github.com/rust-lang/rust/commit/ef00c6a278cdd3bd00f44133573e1f5e2e951520", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef00c6a278cdd3bd00f44133573e1f5e2e951520/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ece8a8f520697be50cbe543bebe065c5198dae4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ece8a8f520697be50cbe543bebe065c5198dae4d", "html_url": "https://github.com/rust-lang/rust/commit/ece8a8f520697be50cbe543bebe065c5198dae4d"}], "stats": {"total": 566, "additions": 324, "deletions": 242}, "files": [{"sha": "1900313ab6c8e7d11bc3b98728680a5e66241417", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -12,6 +12,10 @@\n \n use std::str;\n \n+macro_rules! if_ok( ($e:expr) => (\n+    match $e { Ok(e) => e, Err(e) => { self.last_error = Err(e); return } }\n+) )\n+\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n@@ -595,9 +599,15 @@ pub mod writer {\n \n     // ebml writing\n     pub struct Encoder<'a> {\n-        // FIXME(#5665): this should take a trait object\n+        // FIXME(#5665): this should take a trait object. Note that if you\n+        //               delete this comment you should consider removing the\n+        //               unwrap()'s below of the results of the calls to\n+        //               write(). We're guaranteed that writing into a MemWriter\n+        //               won't fail, but this is not true for all I/O streams in\n+        //               general.\n         writer: &'a mut MemWriter,\n         priv size_positions: ~[uint],\n+        last_error: io::IoResult<()>,\n     }\n \n     fn write_sized_vuint(w: &mut MemWriter, n: uint, size: uint) {\n@@ -609,7 +619,7 @@ pub mod writer {\n             4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                             (n >> 8_u) as u8, n as u8]),\n             _ => fail!(\"vint to write too big: {}\", n)\n-        };\n+        }.unwrap()\n     }\n \n     fn write_vuint(w: &mut MemWriter, n: uint) {\n@@ -624,7 +634,8 @@ pub mod writer {\n         let size_positions: ~[uint] = ~[];\n         Encoder {\n             writer: w,\n-            size_positions: size_positions\n+            size_positions: size_positions,\n+            last_error: Ok(()),\n         }\n     }\n \n@@ -635,6 +646,7 @@ pub mod writer {\n             Encoder {\n                 writer: cast::transmute_copy(&self.writer),\n                 size_positions: self.size_positions.clone(),\n+                last_error: Ok(()),\n             }\n         }\n \n@@ -645,18 +657,18 @@ pub mod writer {\n             write_vuint(self.writer, tag_id);\n \n             // Write a placeholder four-byte size.\n-            self.size_positions.push(self.writer.tell() as uint);\n+            self.size_positions.push(if_ok!(self.writer.tell()) as uint);\n             let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-            self.writer.write(zeroes);\n+            if_ok!(self.writer.write(zeroes));\n         }\n \n         pub fn end_tag(&mut self) {\n             let last_size_pos = self.size_positions.pop().unwrap();\n-            let cur_pos = self.writer.tell();\n-            self.writer.seek(last_size_pos as i64, io::SeekSet);\n+            let cur_pos = if_ok!(self.writer.tell());\n+            if_ok!(self.writer.seek(last_size_pos as i64, io::SeekSet));\n             let size = (cur_pos as uint - last_size_pos - 4);\n             write_sized_vuint(self.writer, size, 4u);\n-            self.writer.seek(cur_pos as i64, io::SeekSet);\n+            if_ok!(self.writer.seek(cur_pos as i64, io::SeekSet));\n \n             debug!(\"End tag (size = {})\", size);\n         }\n@@ -670,7 +682,7 @@ pub mod writer {\n         pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n             write_vuint(self.writer, tag_id);\n             write_vuint(self.writer, b.len());\n-            self.writer.write(b);\n+            self.writer.write(b).unwrap();\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n@@ -723,12 +735,12 @@ pub mod writer {\n \n         pub fn wr_bytes(&mut self, b: &[u8]) {\n             debug!(\"Write {} bytes\", b.len());\n-            self.writer.write(b);\n+            self.writer.write(b).unwrap();\n         }\n \n         pub fn wr_str(&mut self, s: &str) {\n             debug!(\"Write str: {}\", s);\n-            self.writer.write(s.as_bytes());\n+            self.writer.write(s.as_bytes()).unwrap();\n         }\n     }\n "}, {"sha": "ef8e0999521b85567e0d9e148436973893752510", "filename": "src/libextra/json.rs", "status": "modified", "additions": 86, "deletions": 59, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -234,6 +234,10 @@ use serialize::Encodable;\n use serialize;\n use treemap::TreeMap;\n \n+macro_rules! if_ok( ($e:expr) => (\n+    match $e { Ok(e) => e, Err(e) => { self.error = Err(e); return } }\n+) )\n+\n /// Represents a json value\n #[deriving(Clone, Eq)]\n pub enum Json {\n@@ -260,6 +264,14 @@ pub struct Error {\n     priv msg: ~str,\n }\n \n+fn io_error_to_error(io: io::IoError) -> Error {\n+    Error {\n+        line: 0,\n+        col: 0,\n+        msg: format!(\"io error: {}\", io)\n+    }\n+}\n+\n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n     for c in s.chars() {\n@@ -289,13 +301,14 @@ fn spaces(n: uint) -> ~str {\n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n     priv wr: &'a mut io::Writer,\n+    priv error: io::IoResult<()>,\n }\n \n impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n     pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n-        Encoder { wr: wr }\n+        Encoder { wr: wr, error: Ok(()) }\n     }\n \n     /// Encode the specified struct into a json [u8]\n@@ -317,7 +330,7 @@ impl<'a> Encoder<'a> {\n }\n \n impl<'a> serialize::Encoder for Encoder<'a> {\n-    fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n+    fn emit_nil(&mut self) { if_ok!(write!(self.wr, \"null\")) }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n     fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n@@ -333,20 +346,20 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n-            write!(self.wr, \"true\");\n+            if_ok!(write!(self.wr, \"true\"));\n         } else {\n-            write!(self.wr, \"false\");\n+            if_ok!(write!(self.wr, \"false\"));\n         }\n     }\n \n     fn emit_f64(&mut self, v: f64) {\n-        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n+        if_ok!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)))\n     }\n     fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) {\n-        write!(self.wr, \"{}\", escape_str(v))\n+        if_ok!(write!(self.wr, \"{}\", escape_str(v)))\n     }\n \n     fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>|) { f(self) }\n@@ -360,19 +373,19 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n         if cnt == 0 {\n-            write!(self.wr, \"{}\", escape_str(name));\n+            if_ok!(write!(self.wr, \"{}\", escape_str(name)));\n         } else {\n-            write!(self.wr, \"\\\\{\\\"variant\\\":\");\n-            write!(self.wr, \"{}\", escape_str(name));\n-            write!(self.wr, \",\\\"fields\\\":[\");\n+            if_ok!(write!(self.wr, \"\\\\{\\\"variant\\\":\"));\n+            if_ok!(write!(self.wr, \"{}\", escape_str(name)));\n+            if_ok!(write!(self.wr, \",\\\"fields\\\":[\"));\n             f(self);\n-            write!(self.wr, \"]\\\\}\");\n+            if_ok!(write!(self.wr, \"]\\\\}\"));\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         if idx != 0 {\n-            write!(self.wr, \",\");\n+            if_ok!(write!(self.wr, \",\"));\n         }\n         f(self);\n     }\n@@ -393,17 +406,17 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder<'a>|) {\n-        write!(self.wr, r\"\\{\");\n+        if_ok!(write!(self.wr, r\"\\{\"));\n         f(self);\n-        write!(self.wr, r\"\\}\");\n+        if_ok!(write!(self.wr, r\"\\}\"));\n     }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n                          f: |&mut Encoder<'a>|) {\n-        if idx != 0 { write!(self.wr, \",\") }\n-        write!(self.wr, \"{}:\", escape_str(name));\n+        if idx != 0 { if_ok!(write!(self.wr, \",\")) }\n+        if_ok!(write!(self.wr, \"{}:\", escape_str(name)));\n         f(self);\n     }\n \n@@ -429,31 +442,31 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n \n     fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n-        write!(self.wr, \"[\");\n+        if_ok!(write!(self.wr, \"[\"));\n         f(self);\n-        write!(self.wr, \"]\");\n+        if_ok!(write!(self.wr, \"]\"));\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         if idx != 0 {\n-            write!(self.wr, \",\");\n+            if_ok!(write!(self.wr, \",\"));\n         }\n         f(self)\n     }\n \n     fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n-        write!(self.wr, r\"\\{\");\n+        if_ok!(write!(self.wr, r\"\\{\"));\n         f(self);\n-        write!(self.wr, r\"\\}\");\n+        if_ok!(write!(self.wr, r\"\\}\"));\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n-        if idx != 0 { write!(self.wr, \",\") }\n+        if idx != 0 { if_ok!(write!(self.wr, \",\")) }\n         f(self)\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n-        write!(self.wr, \":\");\n+        if_ok!(write!(self.wr, \":\"));\n         f(self)\n     }\n }\n@@ -463,6 +476,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n pub struct PrettyEncoder<'a> {\n     priv wr: &'a mut io::Writer,\n     priv indent: uint,\n+    priv error: io::IoResult<()>,\n }\n \n impl<'a> PrettyEncoder<'a> {\n@@ -471,12 +485,13 @@ impl<'a> PrettyEncoder<'a> {\n         PrettyEncoder {\n             wr: wr,\n             indent: 0,\n+            error: Ok(())\n         }\n     }\n }\n \n impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n-    fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n+    fn emit_nil(&mut self) { if_ok!(write!(self.wr, \"null\")); }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n     fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n@@ -492,19 +507,21 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n-            write!(self.wr, \"true\");\n+            if_ok!(write!(self.wr, \"true\"));\n         } else {\n-            write!(self.wr, \"false\");\n+            if_ok!(write!(self.wr, \"false\"));\n         }\n     }\n \n     fn emit_f64(&mut self, v: f64) {\n-        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n+        if_ok!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)));\n     }\n     fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&mut self, v: &str) { write!(self.wr, \"{}\", escape_str(v)); }\n+    fn emit_str(&mut self, v: &str) {\n+        if_ok!(write!(self.wr, \"{}\", escape_str(v)));\n+    }\n \n     fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder<'a>|) {\n         f(self)\n@@ -516,23 +533,24 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n                          cnt: uint,\n                          f: |&mut PrettyEncoder<'a>|) {\n         if cnt == 0 {\n-            write!(self.wr, \"{}\", escape_str(name));\n+            if_ok!(write!(self.wr, \"{}\", escape_str(name)));\n         } else {\n             self.indent += 2;\n-            write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent), escape_str(name));\n+            if_ok!(write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent),\n+                          escape_str(name)));\n             f(self);\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}]\", spaces(self.indent));\n+            if_ok!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n                              f: |&mut PrettyEncoder<'a>|) {\n         if idx != 0 {\n-            write!(self.wr, \",\\n\");\n+            if_ok!(write!(self.wr, \",\\n\"));\n         }\n-        write!(self.wr, \"{}\", spaces(self.indent));\n+        if_ok!(write!(self.wr, \"{}\", spaces(self.indent)));\n         f(self)\n     }\n \n@@ -557,13 +575,13 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n                    len: uint,\n                    f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n-            write!(self.wr, \"\\\\{\\\\}\");\n+            if_ok!(write!(self.wr, \"\\\\{\\\\}\"));\n         } else {\n-            write!(self.wr, \"\\\\{\");\n+            if_ok!(write!(self.wr, \"\\\\{\"));\n             self.indent += 2;\n             f(self);\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent));\n+            if_ok!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n         }\n     }\n \n@@ -572,11 +590,11 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n                          idx: uint,\n                          f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n-            write!(self.wr, \"\\n\");\n+            if_ok!(write!(self.wr, \"\\n\"));\n         } else {\n-            write!(self.wr, \",\\n\");\n+            if_ok!(write!(self.wr, \",\\n\"));\n         }\n-        write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name));\n+        if_ok!(write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name)));\n         f(self);\n     }\n \n@@ -605,50 +623,50 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n \n     fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n-            write!(self.wr, \"[]\");\n+            if_ok!(write!(self.wr, \"[]\"));\n         } else {\n-            write!(self.wr, \"[\");\n+            if_ok!(write!(self.wr, \"[\"));\n             self.indent += 2;\n             f(self);\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}]\", spaces(self.indent));\n+            if_ok!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n         }\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n-            write!(self.wr, \"\\n\");\n+            if_ok!(write!(self.wr, \"\\n\"));\n         } else {\n-            write!(self.wr, \",\\n\");\n+            if_ok!(write!(self.wr, \",\\n\"));\n         }\n-        write!(self.wr, \"{}\", spaces(self.indent));\n+        if_ok!(write!(self.wr, \"{}\", spaces(self.indent)));\n         f(self)\n     }\n \n     fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n-            write!(self.wr, \"\\\\{\\\\}\");\n+            if_ok!(write!(self.wr, \"\\\\{\\\\}\"));\n         } else {\n-            write!(self.wr, \"\\\\{\");\n+            if_ok!(write!(self.wr, \"\\\\{\"));\n             self.indent += 2;\n             f(self);\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent));\n+            if_ok!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n         }\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n-            write!(self.wr, \"\\n\");\n+            if_ok!(write!(self.wr, \"\\n\"));\n         } else {\n-            write!(self.wr, \",\\n\");\n+            if_ok!(write!(self.wr, \",\\n\"));\n         }\n-        write!(self.wr, \"{}\", spaces(self.indent));\n+        if_ok!(write!(self.wr, \"{}\", spaces(self.indent)));\n         f(self);\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'a>|) {\n-        write!(self.wr, \": \");\n+        if_ok!(write!(self.wr, \": \"));\n         f(self);\n     }\n }\n@@ -668,22 +686,24 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n \n impl Json{\n     /// Encodes a json value into a io::writer.  Uses a single line.\n-    pub fn to_writer(&self, wr: &mut io::Writer) {\n+    pub fn to_writer(&self, wr: &mut io::Writer) -> io::IoResult<()> {\n         let mut encoder = Encoder::new(wr);\n-        self.encode(&mut encoder)\n+        self.encode(&mut encoder);\n+        encoder.error\n     }\n \n     /// Encodes a json value into a io::writer.\n     /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, wr: &mut io::Writer) {\n+    pub fn to_pretty_writer(&self, wr: &mut io::Writer) -> io::IoResult<()> {\n         let mut encoder = PrettyEncoder::new(wr);\n-        self.encode(&mut encoder)\n+        self.encode(&mut encoder);\n+        encoder.error\n     }\n \n     /// Encodes a json value into a string\n     pub fn to_pretty_str(&self) -> ~str {\n         let mut s = MemWriter::new();\n-        self.to_pretty_writer(&mut s as &mut io::Writer);\n+        self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n         str::from_utf8_owned(s.unwrap()).unwrap()\n     }\n }\n@@ -1067,7 +1087,14 @@ impl<T : Iterator<char>> Parser<T> {\n \n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n-    let s = str::from_utf8_owned(rdr.read_to_end()).unwrap();\n+    let contents = match rdr.read_to_end() {\n+        Ok(c) => c,\n+        Err(e) => return Err(io_error_to_error(e))\n+    };\n+    let s = match str::from_utf8_owned(contents) {\n+        Some(s) => s,\n+        None => return Err(Error { line: 0, col: 0, msg: ~\"contents not utf-8\" })\n+    };\n     let mut parser = Parser::new(s.chars());\n     parser.parse()\n }\n@@ -1540,7 +1567,7 @@ impl to_str::ToStr for Json {\n     /// Encodes a json value into a string\n     fn to_str(&self) -> ~str {\n         let mut s = MemWriter::new();\n-        self.to_writer(&mut s as &mut io::Writer);\n+        self.to_writer(&mut s as &mut io::Writer).unwrap();\n         str::from_utf8_owned(s.unwrap()).unwrap()\n     }\n }"}, {"sha": "358dca5e5ac4767c21413faf1a9c283f501c7ae8", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -34,6 +34,11 @@ Rust extras are part of the standard Rust distribution.\n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n \n+#[cfg(stage0)]\n+macro_rules! if_ok (\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)\n+\n // Utility modules\n \n pub mod c_vec;"}, {"sha": "8c7b7f4a736ff049ac615dd59847196409fe0b06", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -322,14 +322,15 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n }\n \n /// Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`.\n-pub fn write_5_number_summary(w: &mut io::Writer, s: &Summary) {\n+pub fn write_5_number_summary(w: &mut io::Writer,\n+                              s: &Summary) -> io::IoResult<()> {\n     let (q1,q2,q3) = s.quartiles;\n     write!(w, \"(min={}, q1={}, med={}, q3={}, max={})\",\n                      s.min,\n                      q1,\n                      q2,\n                      q3,\n-                     s.max);\n+                     s.max)\n }\n \n /// Render a boxplot to the provided writer. The boxplot shows the min, max and quartiles of the\n@@ -344,7 +345,8 @@ pub fn write_5_number_summary(w: &mut io::Writer, s: &Summary) {\n ///   10 |        [--****#******----------]          | 40\n /// ~~~~\n \n-pub fn write_boxplot(w: &mut io::Writer, s: &Summary, width_hint: uint) {\n+pub fn write_boxplot(w: &mut io::Writer, s: &Summary,\n+                     width_hint: uint) -> io::IoResult<()> {\n \n     let (q1,q2,q3) = s.quartiles;\n \n@@ -374,48 +376,49 @@ pub fn write_boxplot(w: &mut io::Writer, s: &Summary, width_hint: uint) {\n     let range_width = width_hint - overhead_width;;\n     let char_step = range / (range_width as f64);\n \n-    write!(w, \"{} |\", lostr);\n+    if_ok!(write!(w, \"{} |\", lostr));\n \n     let mut c = 0;\n     let mut v = lo;\n \n     while c < range_width && v < s.min {\n-        write!(w, \" \");\n+        if_ok!(write!(w, \" \"));\n         v += char_step;\n         c += 1;\n     }\n-    write!(w, \"[\");\n+    if_ok!(write!(w, \"[\"));\n     c += 1;\n     while c < range_width && v < q1 {\n-        write!(w, \"-\");\n+        if_ok!(write!(w, \"-\"));\n         v += char_step;\n         c += 1;\n     }\n     while c < range_width && v < q2 {\n-        write!(w, \"*\");\n+        if_ok!(write!(w, \"*\"));\n         v += char_step;\n         c += 1;\n     }\n-    write!(w, r\"\\#\");\n+    if_ok!(write!(w, r\"\\#\"));\n     c += 1;\n     while c < range_width && v < q3 {\n-        write!(w, \"*\");\n+        if_ok!(write!(w, \"*\"));\n         v += char_step;\n         c += 1;\n     }\n     while c < range_width && v < s.max {\n-        write!(w, \"-\");\n+        if_ok!(write!(w, \"-\"));\n         v += char_step;\n         c += 1;\n     }\n-    write!(w, \"]\");\n+    if_ok!(write!(w, \"]\"));\n     while c < range_width {\n-        write!(w, \" \");\n+        if_ok!(write!(w, \" \"));\n         v += char_step;\n         c += 1;\n     }\n \n-    write!(w, \"| {}\", histr);\n+    if_ok!(write!(w, \"| {}\", histr));\n+    Ok(())\n }\n \n /// Returns a HashMap with the number of occurrences of every element in the"}, {"sha": "5948f356a651d6c0384c691dded84ae711261daf", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -38,7 +38,7 @@ impl TempDir {\n         let mut r = rand::rng();\n         for _ in range(0u, 1000) {\n             let p = tmpdir.join(r.gen_ascii_str(16) + suffix);\n-            match io::result(|| fs::mkdir(&p, io::UserRWX)) {\n+            match fs::mkdir(&p, io::UserRWX) {\n                 Err(..) => {}\n                 Ok(()) => return Some(TempDir { path: Some(p) })\n             }\n@@ -73,7 +73,8 @@ impl Drop for TempDir {\n     fn drop(&mut self) {\n         for path in self.path.iter() {\n             if path.exists() {\n-                fs::rmdir_recursive(path);\n+                // FIXME: is failing the right thing to do?\n+                fs::rmdir_recursive(path).unwrap();\n             }\n         }\n     }"}, {"sha": "f562c50935b8c7f2f9f90ddc17b24b7f4b994aa7", "filename": "src/libextra/test.rs", "status": "modified", "additions": 115, "deletions": 92, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -163,7 +163,11 @@ pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n             Some(Err(msg)) => fail!(\"{}\", msg),\n             None => return\n         };\n-    if !run_tests_console(&opts, tests) { fail!(\"Some tests failed\"); }\n+    match run_tests_console(&opts, tests) {\n+        Ok(true) => {}\n+        Ok(false) => fail!(\"Some tests failed\"),\n+        Err(e) => fail!(\"io error when running tests: {}\", e),\n+    }\n }\n \n // A variant optimized for invocation with a static test vector.\n@@ -359,16 +363,17 @@ struct ConsoleTestState<T> {\n }\n \n impl<T: Writer> ConsoleTestState<T> {\n-    pub fn new(opts: &TestOpts, _: Option<T>) -> ConsoleTestState<StdWriter> {\n+    pub fn new(opts: &TestOpts,\n+               _: Option<T>) -> io::IoResult<ConsoleTestState<StdWriter>> {\n         let log_out = match opts.logfile {\n-            Some(ref path) => File::create(path),\n+            Some(ref path) => Some(if_ok!(File::create(path))),\n             None => None\n         };\n         let out = match term::Terminal::new(io::stdout()) {\n             Err(_) => Raw(io::stdout()),\n             Ok(t) => Pretty(t)\n         };\n-        ConsoleTestState {\n+        Ok(ConsoleTestState {\n             out: out,\n             log_out: log_out,\n             use_color: use_color(),\n@@ -380,100 +385,103 @@ impl<T: Writer> ConsoleTestState<T> {\n             metrics: MetricMap::new(),\n             failures: ~[],\n             max_name_len: 0u,\n-        }\n+        })\n     }\n \n-    pub fn write_ok(&mut self) {\n-        self.write_pretty(\"ok\", term::color::GREEN);\n+    pub fn write_ok(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"ok\", term::color::GREEN)\n     }\n \n-    pub fn write_failed(&mut self) {\n-        self.write_pretty(\"FAILED\", term::color::RED);\n+    pub fn write_failed(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"FAILED\", term::color::RED)\n     }\n \n-    pub fn write_ignored(&mut self) {\n-        self.write_pretty(\"ignored\", term::color::YELLOW);\n+    pub fn write_ignored(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"ignored\", term::color::YELLOW)\n     }\n \n-    pub fn write_metric(&mut self) {\n-        self.write_pretty(\"metric\", term::color::CYAN);\n+    pub fn write_metric(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"metric\", term::color::CYAN)\n     }\n \n-    pub fn write_bench(&mut self) {\n-        self.write_pretty(\"bench\", term::color::CYAN);\n+    pub fn write_bench(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"bench\", term::color::CYAN)\n     }\n \n-    pub fn write_added(&mut self) {\n-        self.write_pretty(\"added\", term::color::GREEN);\n+    pub fn write_added(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"added\", term::color::GREEN)\n     }\n \n-    pub fn write_improved(&mut self) {\n-        self.write_pretty(\"improved\", term::color::GREEN);\n+    pub fn write_improved(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"improved\", term::color::GREEN)\n     }\n \n-    pub fn write_removed(&mut self) {\n-        self.write_pretty(\"removed\", term::color::YELLOW);\n+    pub fn write_removed(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"removed\", term::color::YELLOW)\n     }\n \n-    pub fn write_regressed(&mut self) {\n-        self.write_pretty(\"regressed\", term::color::RED);\n+    pub fn write_regressed(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"regressed\", term::color::RED)\n     }\n \n     pub fn write_pretty(&mut self,\n                         word: &str,\n-                        color: term::color::Color) {\n+                        color: term::color::Color) -> io::IoResult<()> {\n         match self.out {\n             Pretty(ref mut term) => {\n                 if self.use_color {\n-                    term.fg(color);\n+                    if_ok!(term.fg(color));\n                 }\n-                term.write(word.as_bytes());\n+                if_ok!(term.write(word.as_bytes()));\n                 if self.use_color {\n-                    term.reset();\n+                    if_ok!(term.reset());\n                 }\n+                Ok(())\n             }\n             Raw(ref mut stdout) => stdout.write(word.as_bytes())\n         }\n     }\n \n-    pub fn write_plain(&mut self, s: &str) {\n+    pub fn write_plain(&mut self, s: &str) -> io::IoResult<()> {\n         match self.out {\n             Pretty(ref mut term) => term.write(s.as_bytes()),\n             Raw(ref mut stdout) => stdout.write(s.as_bytes())\n         }\n     }\n \n-    pub fn write_run_start(&mut self, len: uint) {\n+    pub fn write_run_start(&mut self, len: uint) -> io::IoResult<()> {\n         self.total = len;\n         let noun = if len != 1 { &\"tests\" } else { &\"test\" };\n-        self.write_plain(format!(\"\\nrunning {} {}\\n\", len, noun));\n+        self.write_plain(format!(\"\\nrunning {} {}\\n\", len, noun))\n     }\n \n-    pub fn write_test_start(&mut self, test: &TestDesc, align: NamePadding) {\n+    pub fn write_test_start(&mut self, test: &TestDesc,\n+                            align: NamePadding) -> io::IoResult<()> {\n         let name = test.padded_name(self.max_name_len, align);\n-        self.write_plain(format!(\"test {} ... \", name));\n+        self.write_plain(format!(\"test {} ... \", name))\n     }\n \n-    pub fn write_result(&mut self, result: &TestResult) {\n-        match *result {\n+    pub fn write_result(&mut self, result: &TestResult) -> io::IoResult<()> {\n+        if_ok!(match *result {\n             TrOk => self.write_ok(),\n             TrFailed => self.write_failed(),\n             TrIgnored => self.write_ignored(),\n             TrMetrics(ref mm) => {\n-                self.write_metric();\n-                self.write_plain(format!(\": {}\", fmt_metrics(mm)));\n+                if_ok!(self.write_metric());\n+                self.write_plain(format!(\": {}\", fmt_metrics(mm)))\n             }\n             TrBench(ref bs) => {\n-                self.write_bench();\n-                self.write_plain(format!(\": {}\", fmt_bench_samples(bs)));\n+                if_ok!(self.write_bench());\n+                self.write_plain(format!(\": {}\", fmt_bench_samples(bs)))\n             }\n-        }\n-        self.write_plain(\"\\n\");\n+        });\n+        self.write_plain(\"\\n\")\n     }\n \n-    pub fn write_log(&mut self, test: &TestDesc, result: &TestResult) {\n+    pub fn write_log(&mut self, test: &TestDesc,\n+                     result: &TestResult) -> io::IoResult<()> {\n         match self.log_out {\n-            None => (),\n+            None => Ok(()),\n             Some(ref mut o) => {\n                 let s = format!(\"{} {}\\n\", match *result {\n                         TrOk => ~\"ok\",\n@@ -482,24 +490,25 @@ impl<T: Writer> ConsoleTestState<T> {\n                         TrMetrics(ref mm) => fmt_metrics(mm),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n                     }, test.name.to_str());\n-                o.write(s.as_bytes());\n+                o.write(s.as_bytes())\n             }\n         }\n     }\n \n-    pub fn write_failures(&mut self) {\n-        self.write_plain(\"\\nfailures:\\n\");\n+    pub fn write_failures(&mut self) -> io::IoResult<()> {\n+        if_ok!(self.write_plain(\"\\nfailures:\\n\"));\n         let mut failures = ~[];\n         for f in self.failures.iter() {\n             failures.push(f.name.to_str());\n         }\n         failures.sort();\n         for name in failures.iter() {\n-            self.write_plain(format!(\"    {}\\n\", name.to_str()));\n+            if_ok!(self.write_plain(format!(\"    {}\\n\", name.to_str())));\n         }\n+        Ok(())\n     }\n \n-    pub fn write_metric_diff(&mut self, diff: &MetricDiff) {\n+    pub fn write_metric_diff(&mut self, diff: &MetricDiff) -> io::IoResult<()> {\n         let mut noise = 0;\n         let mut improved = 0;\n         let mut regressed = 0;\n@@ -511,77 +520,82 @@ impl<T: Writer> ConsoleTestState<T> {\n                 LikelyNoise => noise += 1,\n                 MetricAdded => {\n                     added += 1;\n-                    self.write_added();\n-                    self.write_plain(format!(\": {}\\n\", *k));\n+                    if_ok!(self.write_added());\n+                    if_ok!(self.write_plain(format!(\": {}\\n\", *k)));\n                 }\n                 MetricRemoved => {\n                     removed += 1;\n-                    self.write_removed();\n-                    self.write_plain(format!(\": {}\\n\", *k));\n+                    if_ok!(self.write_removed());\n+                    if_ok!(self.write_plain(format!(\": {}\\n\", *k)));\n                 }\n                 Improvement(pct) => {\n                     improved += 1;\n-                    self.write_plain(format!(\": {}\", *k));\n-                    self.write_improved();\n-                    self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64));\n+                    if_ok!(self.write_plain(format!(\": {}\", *k)));\n+                    if_ok!(self.write_improved());\n+                    if_ok!(self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64)));\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n-                    self.write_plain(format!(\": {}\", *k));\n-                    self.write_regressed();\n-                    self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64));\n+                    if_ok!(self.write_plain(format!(\": {}\", *k)));\n+                    if_ok!(self.write_regressed());\n+                    if_ok!(self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64)));\n                 }\n             }\n         }\n-        self.write_plain(format!(\"result of ratchet: {} matrics added, {} removed, \\\n-                                  {} improved, {} regressed, {} noise\\n\",\n-                                 added, removed, improved, regressed, noise));\n+        if_ok!(self.write_plain(format!(\"result of ratchet: {} matrics added, \\\n+                                        {} removed, {} improved, {} regressed, \\\n+                                        {} noise\\n\",\n+                                       added, removed, improved, regressed,\n+                                       noise)));\n         if regressed == 0 {\n-            self.write_plain(\"updated ratchet file\\n\");\n+            if_ok!(self.write_plain(\"updated ratchet file\\n\"));\n         } else {\n-            self.write_plain(\"left ratchet file untouched\\n\");\n+            if_ok!(self.write_plain(\"left ratchet file untouched\\n\"));\n         }\n+        Ok(())\n     }\n \n     pub fn write_run_finish(&mut self,\n                             ratchet_metrics: &Option<Path>,\n-                            ratchet_pct: Option<f64>) -> bool {\n+                            ratchet_pct: Option<f64>) -> io::IoResult<bool> {\n         assert!(self.passed + self.failed + self.ignored + self.measured == self.total);\n \n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                self.write_plain(format!(\"\\nusing metrics ratcher: {}\\n\", pth.display()));\n+                if_ok!(self.write_plain(format!(\"\\nusing metrics ratcher: {}\\n\",\n+                                        pth.display())));\n                 match ratchet_pct {\n                     None => (),\n                     Some(pct) =>\n-                        self.write_plain(format!(\"with noise-tolerance forced to: {}%\\n\",\n-                                                 pct))\n+                        if_ok!(self.write_plain(format!(\"with noise-tolerance \\\n+                                                         forced to: {}%\\n\",\n+                                                        pct)))\n                 }\n                 let (diff, ok) = self.metrics.ratchet(pth, ratchet_pct);\n-                self.write_metric_diff(&diff);\n+                if_ok!(self.write_metric_diff(&diff));\n                 ok\n             }\n         };\n \n         let test_success = self.failed == 0u;\n         if !test_success {\n-            self.write_failures();\n+            if_ok!(self.write_failures());\n         }\n \n         let success = ratchet_success && test_success;\n \n-        self.write_plain(\"\\ntest result: \");\n+        if_ok!(self.write_plain(\"\\ntest result: \"));\n         if success {\n             // There's no parallelism at this point so it's safe to use color\n-            self.write_ok();\n+            if_ok!(self.write_ok());\n         } else {\n-            self.write_failed();\n+            if_ok!(self.write_failed());\n         }\n         let s = format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n                         self.passed, self.failed, self.ignored, self.measured);\n-        self.write_plain(s);\n-        return success;\n+        if_ok!(self.write_plain(s));\n+        return Ok(success);\n     }\n }\n \n@@ -611,15 +625,16 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n-                         tests: ~[TestDescAndFn]) -> bool {\n-    fn callback<T: Writer>(event: &TestEvent, st: &mut ConsoleTestState<T>) {\n+                         tests: ~[TestDescAndFn]) -> io::IoResult<bool> {\n+    fn callback<T: Writer>(event: &TestEvent,\n+                           st: &mut ConsoleTestState<T>) -> io::IoResult<()> {\n         debug!(\"callback(event={:?})\", event);\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n             TeResult(test, result) => {\n-                st.write_log(&test, &result);\n-                st.write_result(&result);\n+                if_ok!(st.write_log(&test, &result));\n+                if_ok!(st.write_result(&result));\n                 match result {\n                     TrOk => st.passed += 1,\n                     TrIgnored => st.ignored += 1,\n@@ -643,10 +658,11 @@ pub fn run_tests_console(opts: &TestOpts,\n                         st.failures.push(test);\n                     }\n                 }\n+                Ok(())\n             }\n         }\n     }\n-    let mut st = ConsoleTestState::new(opts, None::<StdWriter>);\n+    let mut st = if_ok!(ConsoleTestState::new(opts, None::<StdWriter>));\n     fn len_if_padded(t: &TestDescAndFn) -> uint {\n         match t.testfn.padding() {\n             PadNone => 0u,\n@@ -661,12 +677,13 @@ pub fn run_tests_console(opts: &TestOpts,\n         },\n         None => {}\n     }\n-    run_tests(opts, tests, |x| callback(&x, &mut st));\n+    if_ok!(run_tests(opts, tests, |x| callback(&x, &mut st)));\n     match opts.save_metrics {\n         None => (),\n         Some(ref pth) => {\n-            st.metrics.save(pth);\n-            st.write_plain(format!(\"\\nmetrics saved to: {}\", pth.display()));\n+            if_ok!(st.metrics.save(pth));\n+            if_ok!(st.write_plain(format!(\"\\nmetrics saved to: {}\",\n+                                          pth.display())));\n         }\n     }\n     return st.write_run_finish(&opts.ratchet_metrics, opts.ratchet_noise_percent);\n@@ -728,11 +745,11 @@ pub type MonitorMsg = (TestDesc, TestResult);\n \n fn run_tests(opts: &TestOpts,\n              tests: ~[TestDescAndFn],\n-             callback: |e: TestEvent|) {\n+             callback: |e: TestEvent| -> io::IoResult<()>) -> io::IoResult<()> {\n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.map(|t| t.desc.clone());\n \n-    callback(TeFiltered(filtered_descs));\n+    if_ok!(callback(TeFiltered(filtered_descs)));\n \n     let (filtered_tests, filtered_benchs_and_metrics) =\n         filtered_tests.partition(|e| {\n@@ -760,28 +777,29 @@ fn run_tests(opts: &TestOpts,\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(TeWait(test.desc.clone(), test.testfn.padding()));\n+                if_ok!(callback(TeWait(test.desc.clone(), test.testfn.padding())));\n             }\n             run_test(!opts.run_tests, test, ch.clone());\n             pending += 1;\n         }\n \n         let (desc, result) = p.recv();\n         if concurrency != 1 {\n-            callback(TeWait(desc.clone(), PadNone));\n+            if_ok!(callback(TeWait(desc.clone(), PadNone)));\n         }\n-        callback(TeResult(desc, result));\n+        if_ok!(callback(TeResult(desc, result)));\n         pending -= 1;\n     }\n \n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n     for b in filtered_benchs_and_metrics.move_iter() {\n-        callback(TeWait(b.desc.clone(), b.testfn.padding()));\n+        if_ok!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n-        callback(TeResult(test, result));\n+        if_ok!(callback(TeResult(test, result)));\n     }\n+    Ok(())\n }\n \n fn get_concurrency() -> uint {\n@@ -943,17 +961,22 @@ impl MetricMap {\n     }\n \n     /// Load MetricDiff from a file.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will fail if the path does not exist or the path does not\n+    /// contain a valid metric map.\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(p.exists());\n-        let mut f = File::open(p);\n+        let mut f = File::open(p).unwrap();\n         let value = json::from_reader(&mut f as &mut io::Reader).unwrap();\n         let mut decoder = json::Decoder::new(value);\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n \n     /// Write MetricDiff to a file.\n-    pub fn save(&self, p: &Path) {\n-        let mut file = File::create(p);\n+    pub fn save(&self, p: &Path) -> io::IoResult<()> {\n+        let mut file = if_ok!(File::create(p));\n         let MetricMap(ref map) = *self;\n         map.to_json().to_pretty_writer(&mut file)\n     }\n@@ -1060,7 +1083,7 @@ impl MetricMap {\n \n         if ok {\n             debug!(\"rewriting file '{:?}' with updated metrics\", p);\n-            self.save(p);\n+            self.save(p).unwrap();\n         }\n         return (diff, ok)\n     }"}, {"sha": "0a122ad58bd33a3a728d91fc2cd914e9762dcfcc", "filename": "src/libextra/time.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -766,14 +766,14 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n \n         let mut buf = [0];\n         let c = match rdr.read(buf) {\n-            Some(..) => buf[0] as char,\n-            None => break\n+            Ok(..) => buf[0] as char,\n+            Err(..) => break\n         };\n         match c {\n             '%' => {\n                 let ch = match rdr.read(buf) {\n-                    Some(..) => buf[0] as char,\n-                    None => break\n+                    Ok(..) => buf[0] as char,\n+                    Err(..) => break\n                 };\n                 match parse_type(s, pos, ch, &mut tm) {\n                     Ok(next) => pos = next,\n@@ -787,7 +787,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         }\n     }\n \n-    if pos == len && rdr.tell() as uint == format.len() {\n+    if pos == len && rdr.tell().unwrap() == format.len() as u64 {\n         Ok(Tm {\n             tm_sec: tm.tm_sec,\n             tm_min: tm.tm_min,\n@@ -1017,12 +1017,12 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n     loop {\n         let mut b = [0];\n         let ch = match rdr.read(b) {\n-            Some(..) => b[0],\n-            None => break,\n+            Ok(..) => b[0],\n+            Err(..) => break,\n         };\n         match ch as char {\n             '%' => {\n-                rdr.read(b);\n+                rdr.read(b).unwrap();\n                 let s = parse_type(b[0] as char, tm);\n                 buf.push_all(s.as_bytes());\n             }"}, {"sha": "6138c5416f2b456bb5448c5d2a30617a005e50c7", "filename": "src/libextra/url.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -102,8 +102,8 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            None => break,\n-            Some(..) => buf[0] as char,\n+            Err(..) => break,\n+            Ok(..) => buf[0] as char,\n         };\n \n         match ch {\n@@ -166,14 +166,14 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            None => break,\n-            Some(..) => buf[0] as char\n+            Err(..) => break,\n+            Ok(..) => buf[0] as char\n         };\n         match ch {\n           '%' => {\n             let mut bytes = [0, 0];\n             match rdr.read(bytes) {\n-                Some(2) => {}\n+                Ok(2) => {}\n                 _ => fail!() // FIXME: malformed url?\n             }\n             let ch = uint::parse_bytes(bytes, 16u).unwrap() as u8 as char;\n@@ -228,8 +228,8 @@ fn encode_plus(s: &str) -> ~str {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            Some(..) => buf[0] as char,\n-            None => break,\n+            Ok(..) => buf[0] as char,\n+            Err(..) => break,\n         };\n         match ch {\n           'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n@@ -282,8 +282,8 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            Some(..) => buf[0] as char,\n-            None => break,\n+            Ok(..) => buf[0] as char,\n+            Err(..) => break,\n         };\n         match ch {\n             '&' | ';' => {\n@@ -307,7 +307,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n                     '%' => {\n                         let mut bytes = [0, 0];\n                         match rdr.read(bytes) {\n-                            Some(2) => {}\n+                            Ok(2) => {}\n                             _ => fail!() // FIXME: malformed?\n                         }\n                         uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n@@ -347,12 +347,12 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            Some(..) => buf[0] as char,\n-            None => break,\n+            Ok(..) => buf[0] as char,\n+            Err(..) => break,\n         };\n         if ch == c {\n             // found a match, adjust markers\n-            index = (rdr.tell() as uint) - 1;\n+            index = (rdr.tell().unwrap() as uint) - 1;\n             mat = 1;\n             break;\n         }"}, {"sha": "3d91ccda189a284eb4a885d4a04c056cabc423eb", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -172,20 +172,19 @@ impl Database {\n     }\n \n     // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n-    fn save(&self) {\n+    fn save(&self) -> io::IoResult<()> {\n         let mut f = File::create(&self.db_filename);\n-        self.db_cache.to_json().to_pretty_writer(&mut f);\n+        self.db_cache.to_json().to_pretty_writer(&mut f)\n     }\n \n     fn load(&mut self) {\n         assert!(!self.db_dirty);\n         assert!(self.db_filename.exists());\n-        match io::result(|| File::open(&self.db_filename)) {\n+        match File::open(&self.db_filename) {\n             Err(e) => fail!(\"Couldn't load workcache database {}: {}\",\n                             self.db_filename.display(),\n-                            e.desc),\n-            Ok(r) => {\n-                let mut stream = r.unwrap();\n+                            e),\n+            Ok(mut stream) => {\n                 match json::from_reader(&mut stream) {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n@@ -203,7 +202,8 @@ impl Database {\n impl Drop for Database {\n     fn drop(&mut self) {\n         if self.db_dirty {\n-            self.save();\n+            // FIXME: is failing the right thing to do here\n+            self.save().unwrap();\n         }\n     }\n }"}, {"sha": "98dd2b20a5fa30bb4007f0e0ae94c53b7147b678", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -141,45 +141,48 @@ impl<T: Writer> Terminal<T> {\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n     ///\n-    /// Returns true if the color was set, false otherwise.\n-    pub fn fg(&mut self, color: color::Color) -> bool {\n+    /// Returns Ok(true) if the color was set, Ok(false) otherwise, and Err(e)\n+    /// if there was an I/O error\n+    pub fn fg(&mut self, color: color::Color) -> io::IoResult<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                self.out.write(s.unwrap());\n-                return true\n+                if_ok!(self.out.write(s.unwrap()));\n+                return Ok(true)\n             } else {\n                 warn!(\"{}\", s.unwrap_err());\n             }\n         }\n-        false\n+        Ok(false)\n     }\n     /// Sets the background color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n     ///\n-    /// Returns true if the color was set, false otherwise.\n-    pub fn bg(&mut self, color: color::Color) -> bool {\n+    /// Returns Ok(true) if the color was set, Ok(false) otherwise, and Err(e)\n+    /// if there was an I/O error\n+    pub fn bg(&mut self, color: color::Color) -> io::IoResult<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                self.out.write(s.unwrap());\n-                return true\n+                if_ok!(self.out.write(s.unwrap()));\n+                return Ok(true)\n             } else {\n                 warn!(\"{}\", s.unwrap_err());\n             }\n         }\n-        false\n+        Ok(false)\n     }\n \n     /// Sets the given terminal attribute, if supported.\n-    /// Returns true if the attribute was supported, false otherwise.\n-    pub fn attr(&mut self, attr: attr::Attr) -> bool {\n+    /// Returns Ok(true) if the attribute was supported, Ok(false) otherwise,\n+    /// and Err(e) if there was an I/O error.\n+    pub fn attr(&mut self, attr: attr::Attr) -> io::IoResult<bool> {\n         match attr {\n             attr::ForegroundColor(c) => self.fg(c),\n             attr::BackgroundColor(c) => self.bg(c),\n@@ -189,13 +192,13 @@ impl<T: Writer> Terminal<T> {\n                 if parm.is_some() {\n                     let s = expand(*parm.unwrap(), [], &mut Variables::new());\n                     if s.is_ok() {\n-                        self.out.write(s.unwrap());\n-                        return true\n+                        if_ok!(self.out.write(s.unwrap()));\n+                        return Ok(true)\n                     } else {\n                         warn!(\"{}\", s.unwrap_err());\n                     }\n                 }\n-                false\n+                Ok(false)\n             }\n         }\n     }\n@@ -214,7 +217,7 @@ impl<T: Writer> Terminal<T> {\n     }\n \n     /// Resets all terminal attributes and color to the default.\n-    pub fn reset(&mut self) {\n+    pub fn reset(&mut self) -> io::IoResult<()> {\n         let mut cap = self.ti.strings.find_equiv(&(\"sgr0\"));\n         if cap.is_none() {\n             // are there any terminals that have color/attrs and not sgr0?\n@@ -228,14 +231,15 @@ impl<T: Writer> Terminal<T> {\n             expand(*op, [], &mut Variables::new())\n         });\n         if s.is_ok() {\n-            self.out.write(s.unwrap());\n+            return self.out.write(s.unwrap())\n         } else if self.num_colors > 0 {\n             warn!(\"{}\", s.unwrap_err());\n         } else {\n             // if we support attributes but not color, it would be nice to still warn!()\n             // but it's not worth testing all known attributes just for this.\n             debug!(\"{}\", s.unwrap_err());\n         }\n+        Ok(())\n     }\n \n     fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n@@ -252,11 +256,11 @@ impl<T: Writer> Terminal<T> {\n }\n \n impl<T: Writer> Writer for Terminal<T> {\n-    fn write(&mut self, buf: &[u8]) {\n-        self.out.write(buf);\n+    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+        self.out.write(buf)\n     }\n \n-    fn flush(&mut self) {\n-        self.out.flush();\n+    fn flush(&mut self) -> io::IoResult<()> {\n+        self.out.flush()\n     }\n }"}, {"sha": "31f12bd45e69243093c7862336940c436ebfaaca", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -162,6 +162,10 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n pub fn parse(file: &mut io::Reader,\n              longnames: bool) -> Result<~TermInfo, ~str> {\n+    macro_rules! if_ok( ($e:expr) => (\n+        match $e { Ok(e) => e, Err(e) => return Err(format!(\"{}\", e)) }\n+    ) )\n+\n     let bnames;\n     let snames;\n     let nnames;\n@@ -177,17 +181,17 @@ pub fn parse(file: &mut io::Reader,\n     }\n \n     // Check magic number\n-    let magic = file.read_le_u16();\n+    let magic = if_ok!(file.read_le_u16());\n     if magic != 0x011A {\n         return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n                            0x011A, magic as uint));\n     }\n \n-    let names_bytes          = file.read_le_i16() as int;\n-    let bools_bytes          = file.read_le_i16() as int;\n-    let numbers_count        = file.read_le_i16() as int;\n-    let string_offsets_count = file.read_le_i16() as int;\n-    let string_table_bytes   = file.read_le_i16() as int;\n+    let names_bytes          = if_ok!(file.read_le_i16()) as int;\n+    let bools_bytes          = if_ok!(file.read_le_i16()) as int;\n+    let numbers_count        = if_ok!(file.read_le_i16()) as int;\n+    let string_offsets_count = if_ok!(file.read_le_i16()) as int;\n+    let string_table_bytes   = if_ok!(file.read_le_i16()) as int;\n \n     assert!(names_bytes          > 0);\n \n@@ -216,18 +220,21 @@ pub fn parse(file: &mut io::Reader,\n     }\n \n     // don't read NUL\n-    let names_str = str::from_utf8_owned(file.read_bytes(names_bytes as uint - 1)).unwrap();\n+    let bytes = if_ok!(file.read_bytes(names_bytes as uint - 1));\n+    let names_str = match str::from_utf8_owned(bytes) {\n+        Some(s) => s, None => return Err(~\"input not utf-8\"),\n+    };\n \n     let term_names: ~[~str] = names_str.split('|').map(|s| s.to_owned()).collect();\n \n-    file.read_byte(); // consume NUL\n+    if_ok!(file.read_byte()); // consume NUL\n \n     debug!(\"term names: {:?}\", term_names);\n \n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n         for i in range(0, bools_bytes) {\n-            let b = file.read_byte().unwrap();\n+            let b = if_ok!(file.read_byte());\n             if b < 0 {\n                 error!(\"EOF reading bools after {} entries\", i);\n                 return Err(~\"error: expected more bools but hit EOF\");\n@@ -242,13 +249,13 @@ pub fn parse(file: &mut io::Reader,\n \n     if (bools_bytes + names_bytes) % 2 == 1 {\n         debug!(\"adjusting for padding between bools and numbers\");\n-        file.read_byte(); // compensate for padding\n+        if_ok!(file.read_byte()); // compensate for padding\n     }\n \n     let mut numbers_map = HashMap::new();\n     if numbers_count != 0 {\n         for i in range(0, numbers_count) {\n-            let n = file.read_le_u16();\n+            let n = if_ok!(file.read_le_u16());\n             if n != 0xFFFF {\n                 debug!(\"{}\\\\#{}\", nnames[i], n);\n                 numbers_map.insert(nnames[i].to_owned(), n);\n@@ -263,12 +270,12 @@ pub fn parse(file: &mut io::Reader,\n     if string_offsets_count != 0 {\n         let mut string_offsets = vec::with_capacity(10);\n         for _ in range(0, string_offsets_count) {\n-            string_offsets.push(file.read_le_u16());\n+            string_offsets.push(if_ok!(file.read_le_u16()));\n         }\n \n         debug!(\"offsets: {:?}\", string_offsets);\n \n-        let string_table = file.read_bytes(string_table_bytes as uint);\n+        let string_table = if_ok!(file.read_bytes(string_table_bytes as uint));\n \n         if string_table.len() != string_table_bytes as uint {\n             error!(\"EOF reading string table after {} bytes, wanted {}\", string_table.len(),"}, {"sha": "421f8581b5836f0b238101d6b2836a7fd9d255b1", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00c6a278cdd3bd00f44133573e1f5e2e951520/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=ef00c6a278cdd3bd00f44133573e1f5e2e951520", "patch": "@@ -77,8 +77,8 @@ pub fn open(term: &str) -> Result<File, ~str> {\n     match get_dbpath_for_term(term) {\n         Some(x) => {\n             match File::open(x) {\n-                Some(file) => Ok(file),\n-                None => Err(~\"error opening file\"),\n+                Ok(file) => Ok(file),\n+                Err(e) => Err(format!(\"error opening file: {}\", e)),\n             }\n         }\n         None => Err(format!(\"could not find terminfo entry for {}\", term))"}]}