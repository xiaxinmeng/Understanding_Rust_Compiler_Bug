{"sha": "eb5e63e3f0144d145e85bc0677ea49b97b491896", "node_id": "C_kwDOAAsO6NoAKGViNWU2M2UzZjAxNDRkMTQ1ZTg1YmMwNjc3ZWE0OWI5N2I0OTE4OTY", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2023-01-27T03:57:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-27T03:57:54Z"}, "message": "Rollup merge of #107171 - petrochenkov:encattrs, r=cjgillot\n\nrustc_metadata: Fix `encode_attrs`\n\nThis function didn't do what the authors intended it to do.\n\n- Due to `move` in the closure `is_public` wasn't captured by mutalbe reference and wasn't used as a cache.\n- Due to iterator cloning all the `should_encode_attr` logic run for the second time to calculate `may_have_doc_links`\n\nThis PR fixes these issues, and calculates all the needed attribute flags in one go.\n\n(Noticed while implementing https://github.com/rust-lang/rust/pull/107136.)", "tree": {"sha": "83cbe984f4a375f3351d117ff8b25ec7372eefda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83cbe984f4a375f3351d117ff8b25ec7372eefda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb5e63e3f0144d145e85bc0677ea49b97b491896", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj00vCCRBK7hj4Ov3rIwAA/iQIAFyez6jJ+AYanlnevX0ZznCG\nNDQWJbynIWyUVEGUBcECwv2KgKBeK7T+meWqMQ61VK68VAD6ZNfCNUJKChiFk0OD\ny0pxlthawi5tP01ze4WPIromFxiaAi786n/U17MRf5SvZmBatkuKt5oLaXqHrAQA\nLlt1pD+L7lDCgqSWWRgoQBxZtp/FnkSv8oqo29q0TT2BVcuvk2/muzqbRf9G01vX\nAfDCxtb1UF+4mnH6luXaAqoVpeO2X8iEqkDf/dvEYeYXgH477tKSgfkw1IFoscht\nbEHQTXArMPo/WW36pdSASe2GdtTLa1wI2sO3vcH+ZV6Pv3JlM+pPf+onHxOMv7k=\n=zUBR\n-----END PGP SIGNATURE-----\n", "payload": "tree 83cbe984f4a375f3351d117ff8b25ec7372eefda\nparent bf321ece1e5756493b1ac061cd87a48123cda52c\nparent c70b7aafae283b69762ee809d6b2b5adaf0f3c43\nauthor Yuki Okushi <jtitor@2k36.org> 1674791874 +0900\ncommitter GitHub <noreply@github.com> 1674791874 +0900\n\nRollup merge of #107171 - petrochenkov:encattrs, r=cjgillot\n\nrustc_metadata: Fix `encode_attrs`\n\nThis function didn't do what the authors intended it to do.\n\n- Due to `move` in the closure `is_public` wasn't captured by mutalbe reference and wasn't used as a cache.\n- Due to iterator cloning all the `should_encode_attr` logic run for the second time to calculate `may_have_doc_links`\n\nThis PR fixes these issues, and calculates all the needed attribute flags in one go.\n\n(Noticed while implementing https://github.com/rust-lang/rust/pull/107136.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb5e63e3f0144d145e85bc0677ea49b97b491896", "html_url": "https://github.com/rust-lang/rust/commit/eb5e63e3f0144d145e85bc0677ea49b97b491896", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb5e63e3f0144d145e85bc0677ea49b97b491896/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf321ece1e5756493b1ac061cd87a48123cda52c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf321ece1e5756493b1ac061cd87a48123cda52c", "html_url": "https://github.com/rust-lang/rust/commit/bf321ece1e5756493b1ac061cd87a48123cda52c"}, {"sha": "c70b7aafae283b69762ee809d6b2b5adaf0f3c43", "url": "https://api.github.com/repos/rust-lang/rust/commits/c70b7aafae283b69762ee809d6b2b5adaf0f3c43", "html_url": "https://github.com/rust-lang/rust/commit/c70b7aafae283b69762ee809d6b2b5adaf0f3c43"}], "stats": {"total": 77, "additions": 48, "deletions": 29}, "files": [{"sha": "d57eaf92d0fc68e79feb68f043b356294d61c3c3", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/eb5e63e3f0144d145e85bc0677ea49b97b491896/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5e63e3f0144d145e85bc0677ea49b97b491896/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=eb5e63e3f0144d145e85bc0677ea49b97b491896", "patch": "@@ -3,6 +3,7 @@ use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::TableBuilder;\n use crate::rmeta::*;\n \n+use rustc_ast::util::comments;\n use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n@@ -759,36 +760,54 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n+struct AnalyzeAttrState {\n+    is_exported: bool,\n+    may_have_doc_links: bool,\n+    is_doc_hidden: bool,\n+}\n+\n /// Returns whether an attribute needs to be recorded in metadata, that is, if it's usable and\n /// useful in downstream crates. Local-only attributes are an obvious example, but some\n /// rustdoc-specific attributes can equally be of use while documenting the current crate only.\n ///\n /// Removing these superfluous attributes speeds up compilation by making the metadata smaller.\n ///\n-/// Note: the `is_def_id_public` parameter is used to cache whether the given `DefId` has a public\n+/// Note: the `is_exported` parameter is used to cache whether the given `DefId` has a public\n /// visibility: this is a piece of data that can be computed once per defid, and not once per\n /// attribute. Some attributes would only be usable downstream if they are public.\n #[inline]\n-fn should_encode_attr(\n-    tcx: TyCtxt<'_>,\n-    attr: &Attribute,\n-    def_id: LocalDefId,\n-    is_def_id_public: &mut Option<bool>,\n-) -> bool {\n+fn analyze_attr(attr: &Attribute, state: &mut AnalyzeAttrState) -> bool {\n+    let mut should_encode = false;\n     if rustc_feature::is_builtin_only_local(attr.name_or_empty()) {\n         // Attributes marked local-only don't need to be encoded for downstream crates.\n-        false\n-    } else if attr.doc_str().is_some() {\n-        // We keep all public doc comments because they might be \"imported\" into downstream crates\n-        // if they use `#[doc(inline)]` to copy an item's documentation into their own.\n-        *is_def_id_public.get_or_insert_with(|| tcx.effective_visibilities(()).is_exported(def_id))\n+    } else if let Some(s) = attr.doc_str() {\n+        // We keep all doc comments reachable to rustdoc because they might be \"imported\" into\n+        // downstream crates if they use `#[doc(inline)]` to copy an item's documentation into\n+        // their own.\n+        if state.is_exported {\n+            should_encode = true;\n+            if comments::may_have_doc_links(s.as_str()) {\n+                state.may_have_doc_links = true;\n+            }\n+        }\n     } else if attr.has_name(sym::doc) {\n-        // If this is a `doc` attribute, and it's marked `inline` (as in `#[doc(inline)]`), we can\n-        // remove it. It won't be inlinable in downstream crates.\n-        attr.meta_item_list().map(|l| l.iter().any(|l| !l.has_name(sym::inline))).unwrap_or(false)\n+        // If this is a `doc` attribute that doesn't have anything except maybe `inline` (as in\n+        // `#[doc(inline)]`), then we can remove it. It won't be inlinable in downstream crates.\n+        if let Some(item_list) = attr.meta_item_list() {\n+            for item in item_list {\n+                if !item.has_name(sym::inline) {\n+                    should_encode = true;\n+                    if item.has_name(sym::hidden) {\n+                        state.is_doc_hidden = true;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n     } else {\n-        true\n+        should_encode = true;\n     }\n+    should_encode\n }\n \n fn should_encode_visibility(def_kind: DefKind) -> bool {\n@@ -1108,24 +1127,24 @@ fn should_encode_trait_impl_trait_tys(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_attrs(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx;\n-        let mut is_public: Option<bool> = None;\n-\n-        let hir_attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n-        let mut attrs = hir_attrs\n+        let mut state = AnalyzeAttrState {\n+            is_exported: tcx.effective_visibilities(()).is_exported(def_id),\n+            may_have_doc_links: false,\n+            is_doc_hidden: false,\n+        };\n+        let attr_iter = tcx\n+            .hir()\n+            .attrs(tcx.hir().local_def_id_to_hir_id(def_id))\n             .iter()\n-            .filter(move |attr| should_encode_attr(tcx, attr, def_id, &mut is_public));\n+            .filter(|attr| analyze_attr(attr, &mut state));\n+\n+        record_array!(self.tables.attributes[def_id.to_def_id()] <- attr_iter);\n \n-        record_array!(self.tables.attributes[def_id.to_def_id()] <- attrs.clone());\n         let mut attr_flags = AttrFlags::empty();\n-        if attrs.any(|attr| attr.may_have_doc_links()) {\n+        if state.may_have_doc_links {\n             attr_flags |= AttrFlags::MAY_HAVE_DOC_LINKS;\n         }\n-        if hir_attrs\n-            .iter()\n-            .filter(|attr| attr.has_name(sym::doc))\n-            .filter_map(|attr| attr.meta_item_list())\n-            .any(|items| items.iter().any(|item| item.has_name(sym::hidden)))\n-        {\n+        if state.is_doc_hidden {\n             attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n         }\n         if !attr_flags.is_empty() {"}]}