{"sha": "a89af1fa4cc8548a1c5e0a655a196d94b047ccd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4OWFmMWZhNGNjODU0OGExYzVlMGE2NTVhMTk2ZDk0YjA0N2NjZDc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-09T08:02:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-10T00:31:01Z"}, "message": "Use purely an owned vector for storing TLS data", "tree": {"sha": "7e118f4fc4e420bc6c8100d81d417e64c58328ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e118f4fc4e420bc6c8100d81d417e64c58328ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7", "html_url": "https://github.com/rust-lang/rust/commit/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e388a80c234d628c4d1fab77dc3e3f2c04cbefc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e388a80c234d628c4d1fab77dc3e3f2c04cbefc5", "html_url": "https://github.com/rust-lang/rust/commit/e388a80c234d628c4d1fab77dc3e3f2c04cbefc5"}], "stats": {"total": 94, "additions": 39, "deletions": 55}, "files": [{"sha": "7162afc67051cea56e7c71ee83fc05b46cd3e2c0", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=a89af1fa4cc8548a1c5e0a655a196d94b047ccd7", "patch": "@@ -13,9 +13,10 @@\n use cast;\n use cmp::Eq;\n use libc;\n+use local_data::LocalDataKey;\n use prelude::*;\n+use sys;\n use task::rt;\n-use local_data::LocalDataKey;\n \n use super::rt::rust_task;\n use rt::task::{Task, LocalStorage};\n@@ -61,7 +62,7 @@ impl Eq for @LocalData {\n // proper map.\n type TaskLocalElement = (*libc::c_void, *libc::c_void, @LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = @mut ~[Option<TaskLocalElement>];\n+type TaskLocalMap = ~[Option<TaskLocalElement>];\n \n fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n@@ -74,85 +75,75 @@ fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_local_map(handle: Handle) -> TaskLocalMap {\n+unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n     match handle {\n         OldHandle(task) => get_task_local_map(task),\n         NewHandle(local_storage) => get_newsched_local_map(local_storage)\n     }\n }\n \n-unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n+unsafe fn get_task_local_map(task: *rust_task) -> &mut TaskLocalMap {\n \n     extern fn cleanup_task_local_map_extern_cb(map_ptr: *libc::c_void) {\n         cleanup_task_local_map(map_ptr);\n     }\n \n     // Relies on the runtime initialising the pointer to null.\n-    // Note: The map's box lives in TLS invisibly referenced once. Each time\n-    // we retrieve it for get/set, we make another reference, which get/set\n-    // drop when they finish. No \"re-storing after modifying\" is needed.\n+    // Note: the map is an owned pointer and is \"owned\" by TLS. It is moved\n+    // into the tls slot for this task, and then mutable loans are taken from\n+    // this slot to modify the map.\n     let map_ptr = rt::rust_get_task_local_data(task);\n-    if map_ptr.is_null() {\n-        let map: TaskLocalMap = @mut ~[];\n-        // NB: This bumps the ref count before converting to an unsafe pointer,\n-        // keeping the map alive until TLS is destroyed\n-        rt::rust_set_task_local_data(task, cast::transmute(map));\n+    if (*map_ptr).is_null() {\n+        // First time TLS is used, create a new map and set up the necessary\n+        // TLS information for its safe destruction\n+        let map: TaskLocalMap = ~[];\n+        *map_ptr = cast::transmute(map);\n         rt::rust_task_local_data_atexit(task, cleanup_task_local_map_extern_cb);\n-        map\n-    } else {\n-        let map = cast::transmute(map_ptr);\n-        let nonmut = cast::transmute::<TaskLocalMap,\n-                                       @~[Option<TaskLocalElement>]>(map);\n-        cast::bump_box_refcount(nonmut);\n-        map\n     }\n+    return cast::transmute(map_ptr);\n }\n \n-unsafe fn get_newsched_local_map(local: *mut LocalStorage) -> TaskLocalMap {\n+unsafe fn get_newsched_local_map(local: *mut LocalStorage) -> &mut TaskLocalMap {\n+    // This is based on the same idea as the oldsched code above.\n     match &mut *local {\n-        &LocalStorage(map_ptr, Some(_)) => {\n+        // If the at_exit function is already set, then we just need to take a\n+        // loan out on the TLS map stored inside\n+        &LocalStorage(ref mut map_ptr, Some(_)) => {\n             assert!(map_ptr.is_not_null());\n-            let map = cast::transmute(map_ptr);\n-            let nonmut = cast::transmute::<TaskLocalMap,\n-            @~[Option<TaskLocalElement>]>(map);\n-            cast::bump_box_refcount(nonmut);\n-            return map;\n+            return cast::transmute(map_ptr);\n         }\n+        // If this is the first time we've accessed TLS, perform similar\n+        // actions to the oldsched way of doing things.\n         &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n-            assert!((*map_ptr).is_null());\n-            let map: TaskLocalMap = @mut ~[];\n+            assert!(map_ptr.is_null());\n+            assert!(at_exit.is_none());\n+            let map: TaskLocalMap = ~[];\n             *map_ptr = cast::transmute(map);\n-            let at_exit_fn: ~fn(*libc::c_void) = |p|cleanup_task_local_map(p);\n+            let at_exit_fn: ~fn(*libc::c_void) = |p| cleanup_task_local_map(p);\n             *at_exit = Some(at_exit_fn);\n-            return map;\n+            return cast::transmute(map_ptr);\n         }\n     }\n }\n \n unsafe fn key_to_key_value<T: 'static>(key: LocalDataKey<T>) -> *libc::c_void {\n-    // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n-    // Use reinterpret_cast -- transmute would leak (forget) the closure.\n-    let pair: (*libc::c_void, *libc::c_void) = cast::transmute_copy(&key);\n-    pair.first()\n+    let pair: sys::Closure = cast::transmute(key);\n+    return pair.code as *libc::c_void;\n }\n \n // If returning Some(..), returns with @T with the map's reference. Careful!\n unsafe fn local_data_lookup<T: 'static>(\n-    map: TaskLocalMap, key: LocalDataKey<T>)\n+    map: &mut TaskLocalMap, key: LocalDataKey<T>)\n     -> Option<(uint, *libc::c_void)> {\n \n     let key_value = key_to_key_value(key);\n-    let map_pos = (*map).iter().position(|entry|\n+    for map.iter().enumerate().advance |(i, entry)| {\n         match *entry {\n-            Some((k,_,_)) => k == key_value,\n-            None => false\n+            Some((k, data, _)) if k == key_value => { return Some((i, data)); }\n+            _ => {}\n         }\n-    );\n-    do map_pos.map |index| {\n-        // .get() is guaranteed because of \"None { false }\" above.\n-        let (_, data_ptr, _) = (*map)[*index].get();\n-        (*index, data_ptr)\n     }\n+    return None;\n }\n \n unsafe fn local_get_helper<T: 'static>(\n@@ -215,7 +206,7 @@ pub unsafe fn local_set<T: 'static>(\n         }\n         None => {\n             // Find an empty slot. If not, grow the vector.\n-            match (*map).iter().position(|x| x.is_none()) {\n+            match map.iter().position(|x| x.is_none()) {\n                 Some(empty_index) => { map[empty_index] = new_entry; }\n                 None => { map.push(new_entry); }\n             }"}, {"sha": "76fcad0759af3715875885fe43f05226ce8fa2b0", "filename": "src/libstd/task/rt.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7/src%2Flibstd%2Ftask%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7/src%2Flibstd%2Ftask%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Frt.rs?ref=a89af1fa4cc8548a1c5e0a655a196d94b047ccd7", "patch": "@@ -63,9 +63,7 @@ pub extern {\n     fn rust_task_kill_all(task: *rust_task);\n \n     #[rust_stack]\n-    fn rust_get_task_local_data(task: *rust_task) -> *libc::c_void;\n-    #[rust_stack]\n-    fn rust_set_task_local_data(task: *rust_task, map: *libc::c_void);\n+    fn rust_get_task_local_data(task: *rust_task) -> *mut *libc::c_void;\n     #[rust_stack]\n     fn rust_task_local_data_atexit(task: *rust_task, cleanup_fn: *u8);\n }"}, {"sha": "f240c7fa28ab1e80e8d899eec0c8265d3b831bcb", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=a89af1fa4cc8548a1c5e0a655a196d94b047ccd7", "patch": "@@ -672,14 +672,10 @@ rust_unlock_little_lock(lock_and_signal *lock) {\n     lock->unlock();\n }\n \n-// set/get/atexit task_local_data can run on the rust stack for speed.\n-extern \"C\" void *\n+// get/atexit task_local_data can run on the rust stack for speed.\n+extern \"C\" void **\n rust_get_task_local_data(rust_task *task) {\n-    return task->task_local_data;\n-}\n-extern \"C\" void\n-rust_set_task_local_data(rust_task *task, void *data) {\n-    task->task_local_data = data;\n+    return &task->task_local_data;\n }\n extern \"C\" void\n rust_task_local_data_atexit(rust_task *task, void (*cleanup_fn)(void *data)) {"}, {"sha": "55caf038227399099edeee97b0a1e84c3486db54", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=a89af1fa4cc8548a1c5e0a655a196d94b047ccd7", "patch": "@@ -171,7 +171,6 @@ rust_destroy_little_lock\n rust_lock_little_lock\n rust_unlock_little_lock\n rust_get_task_local_data\n-rust_set_task_local_data\n rust_task_local_data_atexit\n rust_task_ref\n rust_task_deref"}]}