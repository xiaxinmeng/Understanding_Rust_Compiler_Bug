{"sha": "822ad87325d6436a6aea5ae61ca34d9ad45dd839", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMmFkODczMjVkNjQzNmE2YWVhNWFlNjFjYTM0ZDlhZDQ1ZGQ4Mzk=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-05-18T00:15:15Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2020-05-27T01:55:18Z"}, "message": "Add Peekable::next_if\n\nPrior art:\n\n`rust_analyzer` uses\n[`Parser::eat`](https://github.com/rust-analyzer/rust-analyzer/blob/50f4ae798b7c54d417ee88455b87fd0477473150/crates/ra_parser/src/parser.rs#L94), which is `next_if` specialized to\n`|y| next_if(|x| x == y)`.\n\nBasically every other parser I've run into in Rust has an equivalent of\nParser::eat; see for example\n\n- [cranelift](https://github.com/bytecodealliance/wasmtime/blob/94190d57244b26baf36629c88104b0ba516510cf/cranelift/reader/src/parser.rs#L498)\n- [rcc](https://github.com/jyn514/rcc/blob/a8159c3904a0c950fbba817bf9109023fad69033/src/parse/mod.rs#L231)\n- [crunch](https://github.com/Kixiron/crunch-lang/blob/8521874fab8a7d62bfa7dea8bd1da94b63e31be8/crates/crunch-parser/src/parser/mod.rs#L213-L241)", "tree": {"sha": "bd6be2be125a4d6b2d5e23c3595a1419eb83b5eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd6be2be125a4d6b2d5e23c3595a1419eb83b5eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/822ad87325d6436a6aea5ae61ca34d9ad45dd839", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAl7NyIYACgkQ+boUO5X/\nbYLU9hAArIMzja3QnuueoJhM3rmBojqtqujiNmTxJSldbmKjJLvpZlR8FkuIrQb9\nAPB/Afe9eCIGQgzmg2wwhC3Wl2VH5bXdEGPWuUi08TZgNnne90qMFYBKY5Njb9xR\nNX3NidVemc0OVuuVfeLcWIYwgfUvPXaYNwh4CP32IITK5US5JiFHfJ7E/EUQ9IcC\ny0X3jOT9bMKWLeJGiYs3C6eX14+hFIRvDOy87pYMFvUx2hPrJLv7iHhpeogZUYOs\nuMkyZ4pUPgbYbhO0MqJ8W0NkTvg7sh4IR14WJVuTcS5XkPKM1wCoRwVDnK/Udqmu\ncL2WK0plEQilcepTuWma3ryp1oIWygbim0kjCFV4dgTvyqachq+5EhKa/6DhLKDu\nUD45NCCE5qZdfihDXLAfWD7abKzB4NF9cmSxMXfss9tfxS04svXbFl0fL0eIK+2/\nDU7Zd1f/btNg7xO2S5KH02+s8UED09H2+jcVIcE/48zySB8nHhMdT8fbDOaJT7Jp\nuNKGKfeE/u8EF+uCRZ/1jTPARMM/cMvh8NXMsx24XPeNA6nle0QScKcGvAq34/m/\nWpKJWY1R56njnDhShqS9QfEUSKwaUDd1wv8EInVnV1YYW+1EbETlmhT8gK1ksNYz\nZIZUDYVzUeziz/njU/Pqqa2Kf1UunKJ52dtJWk5f44Yc47Xa9CQ=\n=zL0p\n-----END PGP SIGNATURE-----", "payload": "tree bd6be2be125a4d6b2d5e23c3595a1419eb83b5eb\nparent d79f1bd31a1401b5d08096fcdf9a9eb23ddf95df\nauthor Joshua Nelson <jyn514@gmail.com> 1589760915 -0400\ncommitter David Tolnay <dtolnay@gmail.com> 1590544518 -0700\n\nAdd Peekable::next_if\n\nPrior art:\n\n`rust_analyzer` uses\n[`Parser::eat`](https://github.com/rust-analyzer/rust-analyzer/blob/50f4ae798b7c54d417ee88455b87fd0477473150/crates/ra_parser/src/parser.rs#L94), which is `next_if` specialized to\n`|y| next_if(|x| x == y)`.\n\nBasically every other parser I've run into in Rust has an equivalent of\nParser::eat; see for example\n\n- [cranelift](https://github.com/bytecodealliance/wasmtime/blob/94190d57244b26baf36629c88104b0ba516510cf/cranelift/reader/src/parser.rs#L498)\n- [rcc](https://github.com/jyn514/rcc/blob/a8159c3904a0c950fbba817bf9109023fad69033/src/parse/mod.rs#L231)\n- [crunch](https://github.com/Kixiron/crunch-lang/blob/8521874fab8a7d62bfa7dea8bd1da94b63e31be8/crates/crunch-parser/src/parser/mod.rs#L213-L241)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/822ad87325d6436a6aea5ae61ca34d9ad45dd839", "html_url": "https://github.com/rust-lang/rust/commit/822ad87325d6436a6aea5ae61ca34d9ad45dd839", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/822ad87325d6436a6aea5ae61ca34d9ad45dd839/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d79f1bd31a1401b5d08096fcdf9a9eb23ddf95df", "url": "https://api.github.com/repos/rust-lang/rust/commits/d79f1bd31a1401b5d08096fcdf9a9eb23ddf95df", "html_url": "https://github.com/rust-lang/rust/commit/d79f1bd31a1401b5d08096fcdf9a9eb23ddf95df"}], "stats": {"total": 88, "additions": 88, "deletions": 0}, "files": [{"sha": "3c6842b07b3bf284b7510d925a6328b2e655c8fc", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/822ad87325d6436a6aea5ae61ca34d9ad45dd839/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/822ad87325d6436a6aea5ae61ca34d9ad45dd839/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=822ad87325d6436a6aea5ae61ca34d9ad45dd839", "patch": "@@ -1574,6 +1574,69 @@ impl<I: Iterator> Peekable<I> {\n         let iter = &mut self.iter;\n         self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n     }\n+\n+    /// Consume the next value of this iterator if a condition is true.\n+    ///\n+    /// If `func` returns `true` for the next value of this iterator, consume and return it.\n+    /// Otherwise, return `None`.\n+    ///\n+    /// # Examples\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), None);\n+    /// // `next_if` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    ///\n+    /// Consume any number less than 10.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (1..20).peekable();\n+    /// // Consume all numbers less than 10\n+    /// while iter.next_if(|&x| x < 10).is_some() {}\n+    /// // The next value returned will be 10\n+    /// assert_eq!(iter.next(), Some(10));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n+        match self.next() {\n+            Some(matched) if func(&matched) => Some(matched),\n+            other => {\n+                // Since we called `self.next()`, we consumed `self.peeked`.\n+                assert!(self.peeked.is_none());\n+                self.peeked = Some(other);\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Consume the next item if it is equal to `expected`.\n+    ///\n+    /// # Example\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if_eq(&0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if_eq(&0), None);\n+    /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if_eq<R>(&mut self, expected: &R) -> Option<I::Item>\n+    where\n+        R: ?Sized,\n+        I::Item: PartialEq<R>,\n+    {\n+        self.next_if(|next| next == expected)\n+    }\n }\n \n /// An iterator that rejects elements while `predicate` returns `true`."}, {"sha": "0265235a65a35562a5b462982668cf604d4f5c96", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/822ad87325d6436a6aea5ae61ca34d9ad45dd839/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/822ad87325d6436a6aea5ae61ca34d9ad45dd839/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=822ad87325d6436a6aea5ae61ca34d9ad45dd839", "patch": "@@ -813,6 +813,30 @@ fn test_iterator_peekable_rfold() {\n     assert_eq!(i, xs.len());\n }\n \n+#[test]\n+fn test_iterator_peekable_next_if_eq() {\n+    // first, try on references\n+    let xs = vec![\"Heart\", \"of\", \"Gold\"];\n+    let mut it = xs.into_iter().peekable();\n+    // try before `peek()`\n+    assert_eq!(it.next_if_eq(&\"trillian\"), None);\n+    assert_eq!(it.next_if_eq(&\"Heart\"), Some(\"Heart\"));\n+    // try after peek()\n+    assert_eq!(it.peek(), Some(&\"of\"));\n+    assert_eq!(it.next_if_eq(&\"of\"), Some(\"of\"));\n+    assert_eq!(it.next_if_eq(&\"zaphod\"), None);\n+    // make sure `next()` still behaves\n+    assert_eq!(it.next(), Some(\"Gold\"));\n+\n+    // make sure comparison works for owned values\n+    let xs = vec![String::from(\"Ludicrous\"), \"speed\".into()];\n+    let mut it = xs.into_iter().peekable();\n+    // make sure basic functionality works\n+    assert_eq!(it.next_if_eq(\"Ludicrous\"), Some(\"Ludicrous\".into()));\n+    assert_eq!(it.next_if_eq(\"speed\"), Some(\"speed\".into()));\n+    assert_eq!(it.next_if_eq(\"\"), None);\n+}\n+\n /// This is an iterator that follows the Iterator contract,\n /// but it is not fused. After having returned None once, it will start\n /// producing elements if .next() is called again."}, {"sha": "36dba6965fa242c8c02fc28c230d94bfa0731434", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/822ad87325d6436a6aea5ae61ca34d9ad45dd839/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/822ad87325d6436a6aea5ae61ca34d9ad45dd839/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=822ad87325d6436a6aea5ae61ca34d9ad45dd839", "patch": "@@ -44,6 +44,7 @@\n #![feature(leading_trailing_ones)]\n #![feature(const_forget)]\n #![feature(option_unwrap_none)]\n+#![feature(peekable_next_if)]\n \n extern crate test;\n "}]}