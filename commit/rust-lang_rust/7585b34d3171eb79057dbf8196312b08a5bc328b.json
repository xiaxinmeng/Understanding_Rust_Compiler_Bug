{"sha": "7585b34d3171eb79057dbf8196312b08a5bc328b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ODViMzRkMzE3MWViNzkwNTdkYmY4MTk2MzEyYjA4YTViYzMyOGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-14T02:23:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-14T02:23:21Z"}, "message": "auto merge of #8446 : alexcrichton/rust/ifmt++, r=graydon\n\nThis includes a number of improvements to `ifmt!`\r\n\r\n* Implements formatting arguments -- `{:0.5x}` works now\r\n* Formatting now works on all integer widths, not just `int` and `uint`\r\n* Added a large doc block to `std::fmt` which should help explain what `ifmt!` is all about\r\n* Added floating point formatters, although they have the same pitfalls from before (they're just proof-of-concept now)\r\n\r\nClosed a couple of issues along the way, yay! Once this gets into a snapshot, I'll start looking into removing all of `fmt`", "tree": {"sha": "3531f8443816138646d28cd0651e09d9190a8886", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3531f8443816138646d28cd0651e09d9190a8886"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7585b34d3171eb79057dbf8196312b08a5bc328b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7585b34d3171eb79057dbf8196312b08a5bc328b", "html_url": "https://github.com/rust-lang/rust/commit/7585b34d3171eb79057dbf8196312b08a5bc328b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7585b34d3171eb79057dbf8196312b08a5bc328b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "433fbe8fcf13724445cc57c85cc454352c969429", "url": "https://api.github.com/repos/rust-lang/rust/commits/433fbe8fcf13724445cc57c85cc454352c969429", "html_url": "https://github.com/rust-lang/rust/commit/433fbe8fcf13724445cc57c85cc454352c969429"}, {"sha": "36882b3d54043efc9f78459da39471fb8d5e6239", "url": "https://api.github.com/repos/rust-lang/rust/commits/36882b3d54043efc9f78459da39471fb8d5e6239", "html_url": "https://github.com/rust-lang/rust/commit/36882b3d54043efc9f78459da39471fb8d5e6239"}], "stats": {"total": 973, "additions": 805, "deletions": 168}, "files": [{"sha": "a0635f6f12eb29767b1f1faa901dc67dcbfea546", "filename": "src/libstd/char.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=7585b34d3171eb79057dbf8196312b08a5bc328b", "patch": "@@ -20,6 +20,15 @@ use unicode::{derived_property, general_category};\n #[cfg(not(test))] use cmp::{Eq, Ord};\n #[cfg(not(test))] use num::Zero;\n \n+// UTF-8 ranges and tags for encoding characters\n+static TAG_CONT: uint = 128u;\n+static MAX_ONE_B: uint = 128u;\n+static TAG_TWO_B: uint = 192u;\n+static MAX_TWO_B: uint = 2048u;\n+static TAG_THREE_B: uint = 224u;\n+static MAX_THREE_B: uint = 65536u;\n+static TAG_FOUR_B: uint = 240u;\n+\n /*\n     Lu  Uppercase_Letter        an uppercase letter\n     Ll  Lowercase_Letter        a lowercase letter\n@@ -278,6 +287,12 @@ pub trait Char {\n     fn escape_unicode(&self, f: &fn(char));\n     fn escape_default(&self, f: &fn(char));\n     fn len_utf8_bytes(&self) -> uint;\n+\n+    /// Encodes this character as utf-8 into the provided byte-buffer. The\n+    /// buffer must be at least 4 bytes long or a runtime failure will occur.\n+    ///\n+    /// This will then return the number of characters written to the slice.\n+    fn encode_utf8(&self, dst: &mut [u8]) -> uint;\n }\n \n impl Char for char {\n@@ -308,6 +323,29 @@ impl Char for char {\n     fn escape_default(&self, f: &fn(char)) { escape_default(*self, f) }\n \n     fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n+\n+    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> uint {\n+        let code = *self as uint;\n+        if code < MAX_ONE_B {\n+            dst[0] = code as u8;\n+            return 1;\n+        } else if code < MAX_TWO_B {\n+            dst[0] = (code >> 6u & 31u | TAG_TWO_B) as u8;\n+            dst[1] = (code & 63u | TAG_CONT) as u8;\n+            return 2;\n+        } else if code < MAX_THREE_B {\n+            dst[0] = (code >> 12u & 15u | TAG_THREE_B) as u8;\n+            dst[1] = (code >> 6u & 63u | TAG_CONT) as u8;\n+            dst[2] = (code & 63u | TAG_CONT) as u8;\n+            return 3;\n+        } else {\n+            dst[0] = (code >> 18u & 7u | TAG_FOUR_B) as u8;\n+            dst[1] = (code >> 12u & 63u | TAG_CONT) as u8;\n+            dst[2] = (code >> 6u & 63u | TAG_CONT) as u8;\n+            dst[3] = (code & 63u | TAG_CONT) as u8;\n+            return 4;\n+        }\n+    }\n }\n \n #[cfg(not(test))]"}, {"sha": "41e588934b72e00d1451e9e6b3f9f4300324a460", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 549, "deletions": 58, "changes": 607, "blob_url": "https://github.com/rust-lang/rust/blob/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=7585b34d3171eb79057dbf8196312b08a5bc328b", "patch": "@@ -8,16 +8,317 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/**!\n+\n+# The Formatting Module\n+\n+This module contains the runtime support for the `ifmt!` syntax extension. This\n+macro is implemented in the compiler to emit calls to this module in order to\n+format arguments at runtime into strings and streams.\n+\n+The functions contained in this module should not normally be used in everyday\n+use cases of `ifmt!`. The assumptions made by these functions are unsafe for all\n+inputs, and the compiler performs a large amount of validation on the arguments\n+to `ifmt!` in order to ensure safety at runtime. While it is possible to call\n+these functions directly, it is not recommended to do so in the general case.\n+\n+## Usage\n+\n+The `ifmt!` macro is intended to be familiar to those coming from C's\n+printf/sprintf functions or Python's `str.format` function. In its current\n+revision, the `ifmt!` macro returns a `~str` type which is the result of the\n+formatting. In the future it will also be able to pass in a stream to format\n+arguments directly while performing minimal allocations.\n+\n+Some examples of the `ifmt!` extension are:\n+\n+~~~{.rust}\n+ifmt!(\"Hello\")                  // => ~\"Hello\"\n+ifmt!(\"Hello, {:s}!\", \"world\")  // => ~\"Hello, world!\"\n+ifmt!(\"The number is {:d}\", 1)  // => ~\"The number is 1\"\n+ifmt!(\"{}\", ~[3, 4])            // => ~\"~[3, 4]\"\n+ifmt!(\"{value}\", value=4)       // => ~\"4\"\n+ifmt!(\"{} {}\", 1, 2)            // => ~\"1 2\"\n+~~~\n+\n+From these, you can see that the first argument is a format string. It is\n+required by the compiler for this to be a string literal; it cannot be a\n+variable passed in (in order to perform validity checking). The compiler will\n+then parse the format string and determine if the list of arguments provided is\n+suitable to pass to this format string.\n+\n+### Positional parameters\n+\n+Each formatting argument is allowed to specify which value argument it's\n+referencing, and if omitted it is assumed to be \"the next argument\". For\n+example, the format string `{} {} {}` would take three parameters, and they\n+would be formatted in the same order as they're given. The format string\n+`{2} {1} {0}`, however, would format arguments in reverse order.\n+\n+A format string is required to use all of its arguments, otherwise it is a\n+compile-time error. You may refer to the same argument more than once in the\n+format string, although it must always be referred to with the same type.\n+\n+### Named parameters\n+\n+Rust itself does not have a Python-like equivalent of named parameters to a\n+function, but the `ifmt!` macro is a syntax extension which allows it to\n+leverage named parameters. Named parameters are listed at the end of the\n+argument list and have the syntax:\n+\n+~~~\n+identifier '=' expression\n+~~~\n+\n+It is illegal to put positional parameters (those without names) after arguments\n+which have names. Like positional parameters, it is illegal to provided named\n+parameters that are unused by the format string.\n+\n+### Argument types\n+\n+Each argument's type is dictated by the format string. It is a requirement that\n+every argument is only ever referred to by one type. When specifying the format\n+of an argument, however, a string like `{}` indicates no type. This is allowed,\n+and if all references to one argument do not provide a type, then the format `?`\n+is used (the type's rust-representation is printed). For example, this is an\n+invalid format string:\n+\n+~~~\n+{0:d} {0:s}\n+~~~\n+\n+Because the first argument is both referred to as an integer as well as a\n+string.\n+\n+Because formatting is done via traits, there is no requirement that the\n+`d` format actually takes an `int`, but rather it simply requires a type which\n+ascribes to the `Signed` formatting trait. There are various parameters which do\n+require a particular type, however. Namely if the sytnax `{:.*s}` is used, then\n+the number of characters to print from the string precedes the actual string and\n+must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is\n+illegal to reference an argument as such. For example, this is another invalid\n+format string:\n+\n+~~~\n+{:.*s} {0:u}\n+~~~\n+\n+### Formatting traits\n+\n+When requesting that an argument be formatted with a particular type, you are\n+actually requesting that an argument ascribes to a particular trait. This allows\n+multiple actual types to be formatted via `{:d}` (like `i8` as well as `int`).\n+The current mapping of types to traits is:\n+\n+* `?` => Poly\n+* `d` => Signed\n+* `i` => Signed\n+* `u` => Unsigned\n+* `b` => Bool\n+* `c` => Char\n+* `o` => Octal\n+* `x` => LowerHex\n+* `X` => UpperHex\n+* `s` => String\n+* `p` => Pointer\n+* `t` => Binary\n+* `f` => Float\n+\n+What this means is that any type of argument which implements the\n+`std::fmt::Binary` trait can then be formatted with `{:t}`. Implementations are\n+provided for these traits for a number of primitive types by the standard\n+library as well. Again, the default formatting type (if no other is specified)\n+is `?` which is defined for all types by default.\n+\n+When implementing a format trait for your own time, you will have to implement a\n+method of the signature:\n+\n+~~~\n+fn fmt(value: &T, f: &mut std::fmt::Formatter);\n+~~~\n+\n+Your type will be passed by-reference in `value`, and then the function should\n+emit output into the `f.buf` stream. It is up to each format trait\n+implementation to correctly adhere to the requested formatting parameters. The\n+values of these parameters will be listed in the fields of the `Formatter`\n+struct. In order to help with this, the `Formatter` struct also provides some\n+helper methods.\n+\n+## Internationalization\n+\n+The formatting syntax supported by the `ifmt!` extension supports\n+internationalization by providing \"methods\" which execute various differnet\n+outputs depending on the input. The syntax and methods provided are similar to\n+other internationalization systems, so again nothing should seem alien.\n+Currently two methods are supported by this extension: \"select\" and \"plural\".\n+\n+Each method will execute one of a number of clauses, and then the value of the\n+clause will become what's the result of the argument's format. Inside of the\n+cases, nested argument strings may be provided, but all formatting arguments\n+must not be done through implicit positional means. All arguments inside of each\n+case of a method must be explicitly selected by their name or their integer\n+position.\n+\n+Furthermore, whenever a case is running, the special character `#` can be used\n+to reference the string value of the argument which was selected upon. As an\n+example:\n+\n+~~~\n+ifmt!(\"{0, select, other{#}}\", \"hello\") // => ~\"hello\"\n+~~~\n+\n+This example is the equivalent of `{0:s}` essentially.\n+\n+### Select\n+\n+The select method is a switch over a `&str` parameter, and the parameter *must*\n+be of the type `&str`. An example of the syntax is:\n+\n+~~~\n+{0, select, male{...} female{...} other{...}}\n+~~~\n+\n+Breaking this down, the `0`-th argument is selected upon with the `select`\n+method, and then a number of cases follow. Each case is preceded by an\n+identifier which is the match-clause to execute the given arm. In this case,\n+there are two explicit cases, `male` and `female`. The case will be executed if\n+the string argument provided is an exact match to the case selected.\n+\n+The `other` case is also a required case for all `select` methods. This arm will\n+be executed if none of the other arms matched the word being selected over.\n+\n+### Plural\n+\n+The plural method is a switch statement over a `uint` parameter, and the\n+parameter *must* be a `uint`. A plural method in its full glory can be specified\n+as:\n+\n+~~~\n+{0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n+~~~\n+\n+To break this down, the first `0` indicates that this method is selecting over\n+the value of the first positional parameter to the format string. Next, the\n+`plural` method is being executed. An optionally-supplied `offset` is then given\n+which indicates a number to subtract from argument `0` when matching. This is\n+then followed by a list of cases.\n+\n+Each case is allowed to supply a specific value to match upon with the syntax\n+`=N`. This case is executed if the value at argument `0` matches N exactly,\n+without taking the offset into account. A case may also be specified by one of\n+five keywords: `zero`, `one`, `two`, `few`, and `many`. These cases are matched\n+on after argument `0` has the offset taken into account. Currently the\n+definitions of `many` and `few` are hardcoded, but they are in theory defined by\n+the current locale.\n+\n+Finally, all `plural` methods must have an `other` case supplied which will be\n+executed if none of the other cases match.\n+\n+## Syntax\n+\n+The syntax for the formatting language used is drawn from other languages, so it\n+should not be too alien. Arguments are formatted with python-like syntax,\n+meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n+actual grammar for the formatting syntax is:\n+\n+~~~\n+format_string := <text> [ format <text> ] *\n+format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n+argument := integer | identifier\n+\n+format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n+fill := character\n+align := '<' | '>'\n+sign := '+' | '-'\n+width := count\n+precision := count | '*'\n+type := identifier | ''\n+count := parameter | integer\n+parameter := integer '$'\n+\n+function_spec := plural | select\n+select := 'select' ',' ( identifier arm ) *\n+plural := 'plural' ',' [ 'offset:' integer ] ( selector arm ) *\n+selector := '=' integer | keyword\n+keyword := 'zero' | 'one' | 'two' | 'few' | 'many' | 'other'\n+arm := '{' format_string '}'\n+~~~\n+\n+## Formatting Parameters\n+\n+Each argument being formatted can be transformed by a number of formatting\n+parameters (corresponding to `format_spec` in the syntax above). These\n+parameters affect the string representation of what's being formatted. This\n+syntax draws heavily from Python's, so it may seem a bit familiar.\n+\n+### Fill/Alignment\n+\n+The fill character is provided normally in conjunction with the `width`\n+parameter. This indicates that if the value being formatted is smaller than\n+`width` some extra characters will be printed around it. The extra characters\n+are specified by `fill`, and the alignment can be one of two options:\n+\n+* `<` - the argument is left-aligned in `width` columns\n+* `>` - the argument is right-aligned in `width` columns\n+\n+### Sign/#/0\n+\n+These can all be interpreted as flags for a particular formatter.\n+\n+* '+' - This is intended for numeric types and indicates that the sign should\n+        always be printed. Positive signs are never printed by default, and the\n+        negative sign is only printed by default for the `Signed` trait. This\n+        flag indicates that the correct sign (+ or -) should always be printed.\n+* '-' - Currently not used\n+* '#' - This flag is indicates that the \"alternate\" form of printing should be\n+        used. By default, this only applies to the integer formatting traits and\n+        performs like:\n+    * `x` - precedes the argument with a \"0x\"\n+    * `X` - precedes the argument with a \"0x\"\n+    * `t` - precedes the argument with a \"0b\"\n+    * `o` - precedes the argument with a \"0o\"\n+* '0' - This is used to indicate for integer formats that the padding should\n+        both be done with a `0` character as well as be sign-aware. A format\n+        like `{:08d}` would yield `00000001` for the integer `1`, while the same\n+        format would yield `-0000001` for the integer `-1`. Notice that the\n+        negative version has one fewer zero than the positive version.\n+\n+### Width\n+\n+This is a parameter for the \"minimum width\" that the format should take up. If\n+the value's string does not fill up this many characters, then the padding\n+specified by fill/alignment will be used to take up the required space.\n+\n+The default fill/alignment for non-numerics is a space and left-aligned. The\n+defaults for numeric formatters is also a space but with right-alignment. If the\n+'0' flag is specified for numerics, then the implicit fill character is '0'.\n+\n+The value for the width can also be provided as a `uint` in the list of\n+parameters by using the `2$` syntax indicating that the second argument is a\n+`uint` specifying the width.\n+\n+### Precision\n+\n+For non-numeric types, this can be considered a \"maximum width\". If the\n+resulting string is longer than this width, then it is truncated down to this\n+many characters and only those are emitted.\n+\n+For integral types, this has no meaning currently.\n+\n+For floating-point types, this indicates how many digits after the decimal point\n+should be printed.\n+\n+*/\n+\n use prelude::*;\n \n use cast;\n-use int;\n+use char::Char;\n use rt::io::Decorator;\n use rt::io::mem::MemWriter;\n use rt::io;\n use str;\n use sys;\n-use uint;\n use util;\n use vec;\n \n@@ -33,7 +334,7 @@ pub struct Formatter<'self> {\n     /// Character used as 'fill' whenever there is alignment\n     fill: char,\n     /// Boolean indication of whether the output should be left-aligned\n-    alignleft: bool,\n+    align: parse::Alignment,\n     /// Optionally specified integer width that the output should be\n     width: Option<uint>,\n     /// Optionally specified precision for numeric types\n@@ -77,6 +378,8 @@ pub trait String { fn fmt(&Self, &mut Formatter); }\n pub trait Poly { fn fmt(&Self, &mut Formatter); }\n #[allow(missing_doc)]\n pub trait Pointer { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Float { fn fmt(&Self, &mut Formatter); }\n \n /// The sprintf function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n@@ -109,7 +412,7 @@ pub unsafe fn sprintf(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n             precision: None,\n             // FIXME(#8248): shouldn't need a transmute\n             buf: cast::transmute(&output as &io::Writer),\n-            alignleft: false,\n+            align: parse::AlignUnknown,\n             fill: ' ',\n             args: args,\n             curarg: args.iter(),\n@@ -122,6 +425,11 @@ pub unsafe fn sprintf(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n }\n \n impl<'self> Formatter<'self> {\n+\n+    // First up is the collection of functions used to execute a format string\n+    // at runtime. This consumes all of the compile-time statics generated by\n+    // the ifmt! syntax extension.\n+\n     fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n         let setcount = |slot: &mut Option<uint>, cnt: &parse::Count| {\n             match *cnt {\n@@ -144,7 +452,7 @@ impl<'self> Formatter<'self> {\n             rt::Argument(ref arg) => {\n                 // Fill in the format parameters into the formatter\n                 self.fill = arg.format.fill;\n-                self.alignleft = arg.format.alignleft;\n+                self.align = arg.format.align;\n                 self.flags = arg.format.flags;\n                 setcount(&mut self.width, &arg.format.width);\n                 setcount(&mut self.precision, &arg.format.precision);\n@@ -233,13 +541,154 @@ impl<'self> Formatter<'self> {\n     }\n \n     fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n-        do uint::to_str_bytes(value, 10) |buf| {\n+        do ::uint::to_str_bytes(value, 10) |buf| {\n             let valuestr = str::from_bytes_slice(buf);\n             for piece in pieces.iter() {\n                 self.run(piece, Some(valuestr));\n             }\n         }\n     }\n+\n+    // Helper methods used for padding and processing formatting arguments that\n+    // all formatting traits can use.\n+\n+    /// Performs the correct padding for an integer which has already been\n+    /// emitted into a byte-array. The byte-array should *not* contain the sign\n+    /// for the integer, that will be added by this method.\n+    ///\n+    /// # Arguments\n+    ///\n+    ///     * s - the byte array that the number has been formatted into\n+    ///     * alternate_prefix - if the '#' character (FlagAlternate) is\n+    ///       provided, this is the prefix to put in front of the number.\n+    ///       Currently this is 0x/0o/0b/etc.\n+    ///     * positive - whether the original integer was positive or not.\n+    ///\n+    /// This function will correctly account for the flags provided as well as\n+    /// the minimum width. It will not take precision into account.\n+    pub fn pad_integral(&mut self, s: &[u8], alternate_prefix: &str,\n+                        positive: bool) {\n+        use fmt::parse::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n+\n+        let mut actual_len = s.len();\n+        if self.flags & 1 << (FlagAlternate as uint) != 0 {\n+            actual_len += alternate_prefix.len();\n+        }\n+        if self.flags & 1 << (FlagSignPlus as uint) != 0 {\n+            actual_len += 1;\n+        } else if !positive {\n+            actual_len += 1;\n+        }\n+\n+        let mut signprinted = false;\n+        let sign = |this: &mut Formatter| {\n+            if !signprinted {\n+                if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {\n+                    this.buf.write(['+' as u8]);\n+                } else if !positive {\n+                    this.buf.write(['-' as u8]);\n+                }\n+                if this.flags & 1 << (FlagAlternate as uint) != 0 {\n+                    this.buf.write(alternate_prefix.as_bytes());\n+                }\n+                signprinted = true;\n+            }\n+        };\n+\n+        let emit = |this: &mut Formatter| {\n+            sign(this);\n+            this.buf.write(s);\n+        };\n+\n+        match self.width {\n+            None => { emit(self) }\n+            Some(min) if actual_len >= min => { emit(self) }\n+            Some(min) => {\n+                if self.flags & 1 << (FlagSignAwareZeroPad as uint) != 0 {\n+                    self.fill = '0';\n+                    sign(self);\n+                }\n+                do self.with_padding(min - actual_len, parse::AlignRight) |me| {\n+                    emit(me);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// This function takes a string slice and emits it to the internal buffer\n+    /// after applying the relevant formatting flags specified. The flags\n+    /// recognized for generic strings are:\n+    ///\n+    /// * width - the minimum width of what to emit\n+    /// * fill/align - what to emit and where to emit it if the string\n+    ///                provided needs to be padded\n+    /// * precision - the maximum length to emit, the string is truncated if it\n+    ///               is longer than this length\n+    ///\n+    /// Notably this function ignored the `flag` parameters\n+    pub fn pad(&mut self, s: &str) {\n+        // Make sure there's a fast path up front\n+        if self.width.is_none() && self.precision.is_none() {\n+            self.buf.write(s.as_bytes());\n+            return\n+        }\n+        // The `precision` field can be interpreted as a `max-width` for the\n+        // string being formatted\n+        match self.precision {\n+            Some(max) => {\n+                // If there's a maximum width and our string is longer than\n+                // that, then we must always have truncation. This is the only\n+                // case where the maximum length will matter.\n+                let char_len = s.char_len();\n+                if char_len >= max {\n+                    let nchars = ::uint::min(max, char_len);\n+                    self.buf.write(s.slice_chars(0, nchars).as_bytes());\n+                    return\n+                }\n+            }\n+            None => {}\n+        }\n+\n+        // The `width` field is more of a `min-width` parameter at this point.\n+        match self.width {\n+            // If we're under the maximum length, and there's no minimum length\n+            // requirements, then we can just emit the string\n+            None => { self.buf.write(s.as_bytes()) }\n+\n+            // If we're under the maximum width, check if we're over the minimum\n+            // width, if so it's as easy as just emitting the string.\n+            Some(width) if s.char_len() >= width => {\n+                self.buf.write(s.as_bytes())\n+            }\n+\n+            // If we're under both the maximum and the minimum width, then fill\n+            // up the minimum width with the specified string + some alignment.\n+            Some(width) => {\n+                do self.with_padding(width - s.len(), parse::AlignLeft) |me| {\n+                    me.buf.write(s.as_bytes());\n+                }\n+            }\n+        }\n+    }\n+\n+    fn with_padding(&mut self, padding: uint,\n+                    default: parse::Alignment, f: &fn(&mut Formatter)) {\n+        let align = match self.align {\n+            parse::AlignUnknown => default,\n+            parse::AlignLeft | parse::AlignRight => self.align\n+        };\n+        if align == parse::AlignLeft {\n+            f(self);\n+        }\n+        let mut fill = [0u8, ..4];\n+        let len = self.fill.encode_utf8(fill);\n+        for _ in range(0, padding) {\n+            self.buf.write(fill.slice_to(len));\n+        }\n+        if align == parse::AlignRight {\n+            f(self);\n+        }\n+    }\n }\n \n /// This is a function which calls are emitted to by the compiler itself to\n@@ -279,88 +728,130 @@ impl Bool for bool {\n \n impl<'self> String for &'self str {\n     fn fmt(s: & &'self str, f: &mut Formatter) {\n-        // XXX: formatting args\n-        f.buf.write(s.as_bytes())\n+        f.pad(*s);\n     }\n }\n \n impl Char for char {\n     fn fmt(c: &char, f: &mut Formatter) {\n-        // XXX: formatting args\n-        // XXX: shouldn't require an allocation\n-        let mut s = ~\"\";\n-        s.push_char(*c);\n-        f.buf.write(s.as_bytes());\n+        let mut utf8 = [0u8, ..4];\n+        let amt = c.encode_utf8(utf8);\n+        let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };\n+        String::fmt(&s, f);\n     }\n }\n \n-impl Signed for int {\n-    fn fmt(c: &int, f: &mut Formatter) {\n-        // XXX: formatting args\n-        do int::to_str_bytes(*c, 10) |buf| {\n-            f.buf.write(buf);\n+macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n+                       $name:ident, $prefix:expr) => {\n+    impl $name for $ty {\n+        fn fmt(c: &$ty, f: &mut Formatter) {\n+            do ::$into::to_str_bytes(*c as $into, $base) |buf| {\n+                f.pad_integral(buf, $prefix, true);\n+            }\n         }\n     }\n-}\n-\n-impl Unsigned for uint {\n-    fn fmt(c: &uint, f: &mut Formatter) {\n-        // XXX: formatting args\n-        do uint::to_str_bytes(*c, 10) |buf| {\n-            f.buf.write(buf);\n+})\n+macro_rules! upper_hex(($ty:ident, $into:ident) => {\n+    impl UpperHex for $ty {\n+        fn fmt(c: &$ty, f: &mut Formatter) {\n+            do ::$into::to_str_bytes(*c as $into, 16) |buf| {\n+                upperhex(buf, f);\n+            }\n         }\n     }\n-}\n-\n-impl Octal for uint {\n-    fn fmt(c: &uint, f: &mut Formatter) {\n-        // XXX: formatting args\n-        do uint::to_str_bytes(*c, 8) |buf| {\n-            f.buf.write(buf);\n+})\n+// Not sure why, but this causes an \"unresolved enum variant, struct or const\"\n+// when inlined into the above macro...\n+#[doc(hidden)]\n+pub fn upperhex(buf: &[u8], f: &mut Formatter) {\n+    let mut local = [0u8, ..16];\n+    for i in ::iterator::range(0, buf.len()) {\n+        local[i] = match buf[i] as char {\n+            'a' .. 'f' => (buf[i] - 'a' as u8) + 'A' as u8,\n+            c => c as u8,\n         }\n     }\n+    f.pad_integral(local.slice_to(buf.len()), \"0x\", true);\n }\n \n-impl LowerHex for uint {\n-    fn fmt(c: &uint, f: &mut Formatter) {\n-        // XXX: formatting args\n-        do uint::to_str_bytes(*c, 16) |buf| {\n-            f.buf.write(buf);\n+// FIXME(#4375) shouldn't need an inner module\n+macro_rules! integer(($signed:ident, $unsigned:ident) => {\n+    mod $signed {\n+        use super::*;\n+\n+        // Signed is special because it actuall emits the negative sign,\n+        // nothing else should do that, however.\n+        impl Signed for $signed {\n+            fn fmt(c: &$signed, f: &mut Formatter) {\n+                do ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10) |buf| {\n+                    f.pad_integral(buf, \"\", *c >= 0);\n+                }\n+            }\n         }\n+        int_base!($signed, $unsigned, 2, Binary, \"0b\")\n+        int_base!($signed, $unsigned, 8, Octal, \"0o\")\n+        int_base!($signed, $unsigned, 16, LowerHex, \"0x\")\n+        upper_hex!($signed, $unsigned)\n+\n+        int_base!($unsigned, $unsigned, 2, Binary, \"0b\")\n+        int_base!($unsigned, $unsigned, 8, Octal, \"0o\")\n+        int_base!($unsigned, $unsigned, 10, Unsigned, \"\")\n+        int_base!($unsigned, $unsigned, 16, LowerHex, \"0x\")\n+        upper_hex!($unsigned, $unsigned)\n     }\n-}\n-\n-impl UpperHex for uint {\n-    fn fmt(c: &uint, f: &mut Formatter) {\n-        // XXX: formatting args\n-        do uint::to_str_bytes(*c, 16) |buf| {\n-            let mut local = [0u8, ..16];\n-            for (l, &b) in local.mut_iter().zip(buf.iter()) {\n-                *l = match b as char {\n-                    'a' .. 'f' => (b - 'a' as u8) + 'A' as u8,\n-                    _ => b,\n-                };\n-            }\n-            f.buf.write(local.slice_to(buf.len()));\n+})\n+\n+integer!(int, uint)\n+integer!(i8, u8)\n+integer!(i16, u16)\n+integer!(i32, u32)\n+integer!(i64, u64)\n+\n+macro_rules! floating(($ty:ident) => {\n+    impl Float for $ty {\n+        fn fmt(f: &$ty, fmt: &mut Formatter) {\n+            // XXX: this shouldn't perform an allocation\n+            let s = match fmt.precision {\n+                Some(i) => ::$ty::to_str_exact(f.abs(), i),\n+                None => ::$ty::to_str_digits(f.abs(), 6)\n+            };\n+            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n         }\n     }\n-}\n+})\n+floating!(float)\n+floating!(f32)\n+floating!(f64)\n \n impl<T> Poly for T {\n     fn fmt(t: &T, f: &mut Formatter) {\n-        // XXX: formatting args\n-        let s = sys::log_str(t);\n-        f.buf.write(s.as_bytes());\n+        match (f.width, f.precision) {\n+            (None, None) => {\n+                // XXX: sys::log_str should have a variant which takes a stream\n+                //      and we should directly call that (avoids unnecessary\n+                //      allocations)\n+                let s = sys::log_str(t);\n+                f.buf.write(s.as_bytes());\n+            }\n+\n+            // If we have a specified width for formatting, then we have to make\n+            // this allocation of a new string\n+            _ => {\n+                let s = sys::log_str(t);\n+                f.pad(s);\n+            }\n+        }\n     }\n }\n \n // n.b. use 'const' to get an implementation for both '*mut' and '*' at the same\n //      time.\n impl<T> Pointer for *const T {\n     fn fmt(t: &*const T, f: &mut Formatter) {\n-        // XXX: formatting args\n-        f.buf.write(\"0x\".as_bytes());\n-        LowerHex::fmt(&(*t as uint), f);\n+        f.flags |= 1 << (parse::FlagAlternate as uint);\n+        do ::uint::to_str_bytes(*t as uint, 16) |buf| {\n+            f.pad_integral(buf, \"0x\", true);\n+        }\n     }\n }\n "}, {"sha": "0d39ae84a6057432a2887fee8a6ae4961ea52973", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=7585b34d3171eb79057dbf8196312b08a5bc328b", "patch": "@@ -47,7 +47,7 @@ pub struct FormatSpec<'self> {\n     /// Optionally specified character to fill alignment with\n     fill: Option<char>,\n     /// Optionally specified alignment\n-    align: Option<Alignment>,\n+    align: Alignment,\n     /// Packed version of various flags provided\n     flags: uint,\n     /// The integer precision to use\n@@ -68,7 +68,7 @@ pub enum Position<'self> {\n \n /// Enum of alignments which are supoprted.\n #[deriving(Eq)]\n-pub enum Alignment { AlignLeft, AlignRight }\n+pub enum Alignment { AlignLeft, AlignRight, AlignUnknown }\n \n /// Various flags which can be applied to format strings, the meaning of these\n /// flags is defined by the formatters themselves.\n@@ -77,6 +77,7 @@ pub enum Flag {\n     FlagSignPlus,\n     FlagSignMinus,\n     FlagAlternate,\n+    FlagSignAwareZeroPad,\n }\n \n /// A count is used for the precision and width parameters of an integer, and\n@@ -288,7 +289,7 @@ impl<'self> Parser<'self> {\n     fn format(&mut self) -> FormatSpec<'self> {\n         let mut spec = FormatSpec {\n             fill: None,\n-            align: None,\n+            align: AlignUnknown,\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n@@ -311,9 +312,9 @@ impl<'self> Parser<'self> {\n         }\n         // Alignment\n         if self.consume('<') {\n-            spec.align = Some(AlignLeft);\n+            spec.align = AlignLeft;\n         } else if self.consume('>') {\n-            spec.align = Some(AlignRight);\n+            spec.align = AlignRight;\n         }\n         // Sign flags\n         if self.consume('+') {\n@@ -326,6 +327,9 @@ impl<'self> Parser<'self> {\n             spec.flags |= 1 << (FlagAlternate as uint);\n         }\n         // Width and precision\n+        if self.consume('0') {\n+            spec.flags |= 1 << (FlagSignAwareZeroPad as uint);\n+        }\n         spec.width = self.count();\n         if self.consume('.') {\n             if self.consume('*') {\n@@ -597,7 +601,7 @@ mod tests {\n     fn fmtdflt() -> FormatSpec<'static> {\n         return FormatSpec {\n             fill: None,\n-            align: None,\n+            align: AlignUnknown,\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n@@ -656,7 +660,7 @@ mod tests {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -671,7 +675,7 @@ mod tests {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n-                align: Some(AlignRight),\n+                align: AlignRight,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -683,7 +687,7 @@ mod tests {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('0'),\n-                align: Some(AlignLeft),\n+                align: AlignLeft,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -695,7 +699,7 @@ mod tests {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('*'),\n-                align: Some(AlignLeft),\n+                align: AlignLeft,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -710,7 +714,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountIs(10),\n@@ -722,7 +726,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIs(10),\n                 width: CountIsParam(10),\n@@ -734,7 +738,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIsNextParam,\n                 width: CountImplied,\n@@ -746,7 +750,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIsParam(10),\n                 width: CountImplied,\n@@ -761,7 +765,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: (1 << FlagSignMinus as uint),\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -773,7 +777,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: (1 << FlagSignPlus as uint) | (1 << FlagAlternate as uint),\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -788,7 +792,7 @@ mod tests {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountImplied,"}, {"sha": "90763836fc6b6ef03f807949ac08c8f4c9ac365f", "filename": "src/libstd/fmt/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Frt.rs?ref=7585b34d3171eb79057dbf8196312b08a5bc328b", "patch": "@@ -36,7 +36,7 @@ pub struct Argument<'self> {\n \n pub struct FormatSpec {\n     fill: char,\n-    alignleft: bool,\n+    align: parse::Alignment,\n     flags: uint,\n     precision: parse::Count,\n     width: parse::Count,"}, {"sha": "b8e61536941217c20a94369735d150c00235697a", "filename": "src/libstd/str.rs", "status": "modified", "additions": 12, "deletions": 41, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=7585b34d3171eb79057dbf8196312b08a5bc328b", "patch": "@@ -33,6 +33,7 @@ use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n use uint;\n+use unstable::raw::{Repr, Slice};\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n \n@@ -758,15 +759,7 @@ macro_rules! utf8_acc_cont_byte(\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as uint)\n )\n \n-// UTF-8 tags and ranges\n static TAG_CONT_U8: u8 = 128u8;\n-static TAG_CONT: uint = 128u;\n-static MAX_ONE_B: uint = 128u;\n-static TAG_TWO_B: uint = 192u;\n-static MAX_TWO_B: uint = 2048u;\n-static TAG_THREE_B: uint = 224u;\n-static MAX_THREE_B: uint = 65536u;\n-static TAG_FOUR_B: uint = 240u;\n static MAX_UNICODE: uint = 1114112u;\n \n /// Unsafe operations\n@@ -1988,40 +1981,18 @@ impl OwnedStr for ~str {\n     #[inline]\n     fn push_char(&mut self, c: char) {\n         assert!((c as uint) < MAX_UNICODE); // FIXME: #7609: should be enforced on all `char`\n+        let cur_len = self.len();\n+        self.reserve_at_least(cur_len + 4); // may use up to 4 bytes\n+\n+        // Attempt to not use an intermediate buffer by just pushing bytes\n+        // directly onto this string.\n         unsafe {\n-            let code = c as uint;\n-            let nb = if code < MAX_ONE_B { 1u }\n-            else if code < MAX_TWO_B { 2u }\n-            else if code < MAX_THREE_B { 3u }\n-            else { 4u };\n-            let len = self.len();\n-            let new_len = len + nb;\n-            self.reserve_at_least(new_len);\n-            let off = len as int;\n-            do self.as_mut_buf |buf, _len| {\n-                match nb {\n-                    1u => {\n-                        *ptr::mut_offset(buf, off) = code as u8;\n-                    }\n-                    2u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 6u & 31u | TAG_TWO_B) as u8;\n-                        *ptr::mut_offset(buf, off + 1) = (code & 63u | TAG_CONT) as u8;\n-                    }\n-                    3u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 12u & 15u | TAG_THREE_B) as u8;\n-                        *ptr::mut_offset(buf, off + 1) = (code >> 6u & 63u | TAG_CONT) as u8;\n-                        *ptr::mut_offset(buf, off + 2) = (code & 63u | TAG_CONT) as u8;\n-                    }\n-                    4u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 18u & 7u | TAG_FOUR_B) as u8;\n-                        *ptr::mut_offset(buf, off + 1) = (code >> 12u & 63u | TAG_CONT) as u8;\n-                        *ptr::mut_offset(buf, off + 2) = (code >> 6u & 63u | TAG_CONT) as u8;\n-                        *ptr::mut_offset(buf, off + 3) = (code & 63u | TAG_CONT) as u8;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            raw::set_len(self, new_len);\n+            let v = self.repr();\n+            let len = c.encode_utf8(cast::transmute(Slice {\n+                data: ((&(*v).data) as *u8).offset(cur_len as int),\n+                len: 4,\n+            }));\n+            raw::set_len(self, cur_len + len);\n         }\n     }\n "}, {"sha": "bdf84604fb37f852bf3898ba49efe3d800c996b6", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=7585b34d3171eb79057dbf8196312b08a5bc328b", "patch": "@@ -56,6 +56,7 @@ impl<'self, T> Repr<Slice<T>> for &'self [T] {}\n impl<'self> Repr<Slice<u8>> for &'self str {}\n impl<T> Repr<*Box<T>> for @T {}\n impl<T> Repr<*Box<Vec<T>>> for @[T] {}\n+impl Repr<*String> for ~str {}\n \n // sure would be nice to have this\n // impl<T> Repr<*Vec<T>> for ~[T] {}"}, {"sha": "6999f046b7b7aeeee3f4bd442e7e62f44439d6f8", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=7585b34d3171eb79057dbf8196312b08a5bc328b", "patch": "@@ -127,7 +127,13 @@ impl Context {\n                 }\n             }\n             parse::Argument(ref arg) => {\n-                // argument first (it's first in the format string)\n+                // width/precision first, if they have implicit positional\n+                // parameters it makes more sense to consume them first.\n+                self.verify_count(arg.format.width);\n+                self.verify_count(arg.format.precision);\n+\n+                // argument second, if it's an implicit positional parameter\n+                // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n                     parse::ArgumentNext => {\n                         let i = self.next_arg;\n@@ -144,10 +150,6 @@ impl Context {\n                 } else { Known(arg.format.ty.to_managed()) };\n                 self.verify_arg_type(pos, ty);\n \n-                // width/precision next\n-                self.verify_count(arg.format.width);\n-                self.verify_count(arg.format.precision);\n-\n                 // and finally the method being applied\n                 match arg.method {\n                     None => {}\n@@ -315,6 +317,10 @@ impl Context {\n     /// Translate a `parse::Piece` to a static `rt::Piece`\n     fn trans_piece(&mut self, piece: &parse::Piece) -> @ast::expr {\n         let sp = self.fmtsp;\n+        let parsepath = |s: &str| {\n+            ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+              self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n+        };\n         let rtpath = |s: &str| {\n             ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n               self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s)]\n@@ -480,20 +486,24 @@ impl Context {\n                 let fill = self.ecx.expr_lit(sp, ast::lit_int(fill as i64,\n                                                               ast::ty_char));\n                 let align = match arg.format.align {\n-                    None | Some(parse::AlignLeft) => {\n-                        self.ecx.expr_bool(sp, true)\n+                    parse::AlignLeft => {\n+                        self.ecx.path_global(sp, parsepath(\"AlignLeft\"))\n                     }\n-                    Some(parse::AlignRight) => {\n-                        self.ecx.expr_bool(sp, false)\n+                    parse::AlignRight => {\n+                        self.ecx.path_global(sp, parsepath(\"AlignRight\"))\n+                    }\n+                    parse::AlignUnknown => {\n+                        self.ecx.path_global(sp, parsepath(\"AlignUnknown\"))\n                     }\n                 };\n+                let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_uint(sp, arg.format.flags);\n                 let prec = trans_count(arg.format.precision);\n                 let width = trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, rtpath(\"FormatSpec\"));\n                 let fmt = self.ecx.expr_struct(sp, path, ~[\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"alignleft\"), align),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width),\n@@ -627,15 +637,17 @@ impl Context {\n             Known(tyname) => {\n                 let fmt_trait = match tyname.as_slice() {\n                     \"?\" => \"Poly\",\n-                    \"d\" | \"i\" => \"Signed\",\n-                    \"u\" => \"Unsigned\",\n                     \"b\" => \"Bool\",\n                     \"c\" => \"Char\",\n+                    \"d\" | \"i\" => \"Signed\",\n+                    \"f\" => \"Float\",\n                     \"o\" => \"Octal\",\n+                    \"p\" => \"Pointer\",\n+                    \"s\" => \"String\",\n+                    \"t\" => \"Binary\",\n+                    \"u\" => \"Unsigned\",\n                     \"x\" => \"LowerHex\",\n                     \"X\" => \"UpperHex\",\n-                    \"s\" => \"String\",\n-                    \"p\" => \"Pointer\",\n                     _ => {\n                         self.ecx.span_err(sp, fmt!(\"unknown format trait \\\n                                                     `%s`\", tyname));"}, {"sha": "a0d3eb7d803287d3a6dcc1b2d97e6074e0992a4e", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 157, "deletions": 37, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585b34d3171eb79057dbf8196312b08a5bc328b/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=7585b34d3171eb79057dbf8196312b08a5bc328b", "patch": "@@ -22,50 +22,170 @@ impl fmt::Signed for B {\n }\n \n pub fn main() {\n-    fn t(a: ~str, b: &str) { assert_eq!(a, b.to_owned()); }\n+    macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n \n     // Make sure there's a poly formatter that takes anything\n-    t(ifmt!(\"{}\", 1), \"1\");\n-    t(ifmt!(\"{}\", A), \"{}\");\n-    t(ifmt!(\"{}\", ()), \"()\");\n-    t(ifmt!(\"{}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n+    t!(ifmt!(\"{}\", 1), \"1\");\n+    t!(ifmt!(\"{}\", A), \"{}\");\n+    t!(ifmt!(\"{}\", ()), \"()\");\n+    t!(ifmt!(\"{}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n \n     // Various edge cases without formats\n-    t(ifmt!(\"\"), \"\");\n-    t(ifmt!(\"hello\"), \"hello\");\n-    t(ifmt!(\"hello \\\\{\"), \"hello {\");\n+    t!(ifmt!(\"\"), \"\");\n+    t!(ifmt!(\"hello\"), \"hello\");\n+    t!(ifmt!(\"hello \\\\{\"), \"hello {\");\n \n     // At least exercise all the formats\n-    t(ifmt!(\"{:b}\", true), \"true\");\n-    t(ifmt!(\"{:c}\", '\u2603'), \"\u2603\");\n-    t(ifmt!(\"{:d}\", 10), \"10\");\n-    t(ifmt!(\"{:i}\", 10), \"10\");\n-    t(ifmt!(\"{:u}\", 10u), \"10\");\n-    t(ifmt!(\"{:o}\", 10u), \"12\");\n-    t(ifmt!(\"{:x}\", 10u), \"a\");\n-    t(ifmt!(\"{:X}\", 10u), \"A\");\n-    t(ifmt!(\"{:s}\", \"foo\"), \"foo\");\n-    t(ifmt!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n-    t(ifmt!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n-    t(ifmt!(\"{:d}\", A), \"aloha\");\n-    t(ifmt!(\"{:d}\", B), \"adios\");\n-    t(ifmt!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n-    t(ifmt!(\"{1} {0}\", 0, 1), \"1 0\");\n-    t(ifmt!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n-    t(ifmt!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n-    t(ifmt!(\"{} {0:s}\", \"a\"), \"a a\");\n-    t(ifmt!(\"{} {0}\", \"a\"), \"\\\"a\\\" \\\"a\\\"\");\n+    t!(ifmt!(\"{:b}\", true), \"true\");\n+    t!(ifmt!(\"{:c}\", '\u2603'), \"\u2603\");\n+    t!(ifmt!(\"{:d}\", 10), \"10\");\n+    t!(ifmt!(\"{:i}\", 10), \"10\");\n+    t!(ifmt!(\"{:u}\", 10u), \"10\");\n+    t!(ifmt!(\"{:o}\", 10u), \"12\");\n+    t!(ifmt!(\"{:x}\", 10u), \"a\");\n+    t!(ifmt!(\"{:X}\", 10u), \"A\");\n+    t!(ifmt!(\"{:s}\", \"foo\"), \"foo\");\n+    t!(ifmt!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n+    t!(ifmt!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n+    t!(ifmt!(\"{:d}\", A), \"aloha\");\n+    t!(ifmt!(\"{:d}\", B), \"adios\");\n+    t!(ifmt!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n+    t!(ifmt!(\"{1} {0}\", 0, 1), \"1 0\");\n+    t!(ifmt!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n+    t!(ifmt!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n+    t!(ifmt!(\"{} {0:s}\", \"a\"), \"a a\");\n+    t!(ifmt!(\"{} {0}\", \"a\"), \"\\\"a\\\" \\\"a\\\"\");\n \n     // Methods should probably work\n-    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n-    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n-    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n-    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n-    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n-    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n-    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n-    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n-    t(ifmt!(\"{1, select, a{#{0:s}} other{#{1}}}\", \"b\", \"a\"), \"ab\");\n-    t(ifmt!(\"{1, select, a{#{0}} other{#{1}}}\", \"c\", \"b\"), \"bb\");\n+    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n+    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n+    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n+    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n+    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n+    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n+    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n+    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n+    t!(ifmt!(\"{1, select, a{#{0:s}} other{#{1}}}\", \"b\", \"a\"), \"ab\");\n+    t!(ifmt!(\"{1, select, a{#{0}} other{#{1}}}\", \"c\", \"b\"), \"bb\");\n+\n+    // Formatting strings and their arguments\n+    t!(ifmt!(\"{:s}\", \"a\"), \"a\");\n+    t!(ifmt!(\"{:4s}\", \"a\"), \"a   \");\n+    t!(ifmt!(\"{:>4s}\", \"a\"), \"   a\");\n+    t!(ifmt!(\"{:<4s}\", \"a\"), \"a   \");\n+    t!(ifmt!(\"{:.4s}\", \"a\"), \"a\");\n+    t!(ifmt!(\"{:4.4s}\", \"a\"), \"a   \");\n+    t!(ifmt!(\"{:4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:<4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:>4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:>10.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:2.4s}\", \"aaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:2.4s}\", \"aaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:2.4s}\", \"aaa\"), \"aaa\");\n+    t!(ifmt!(\"{:2.4s}\", \"aa\"), \"aa\");\n+    t!(ifmt!(\"{:2.4s}\", \"a\"), \"a \");\n+    t!(ifmt!(\"{:0>2s}\", \"a\"), \"0a\");\n+    t!(ifmt!(\"{:.*s}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:.1$s}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n+    t!(ifmt!(\"{:1$s}\", \"a\", 4), \"a   \");\n+    t!(ifmt!(\"{:-#s}\", \"a\"), \"a\");\n+    t!(ifmt!(\"{:+#s}\", \"a\"), \"a\");\n+\n+    // Formatting integers should select the right implementation based off the\n+    // type of the argument. Also, hex/octal/binary should be defined for\n+    // integers, but they shouldn't emit the negative sign.\n+    t!(ifmt!(\"{:d}\", -1i), \"-1\");\n+    t!(ifmt!(\"{:d}\", -1i8), \"-1\");\n+    t!(ifmt!(\"{:d}\", -1i16), \"-1\");\n+    t!(ifmt!(\"{:d}\", -1i32), \"-1\");\n+    t!(ifmt!(\"{:d}\", -1i64), \"-1\");\n+    t!(ifmt!(\"{:t}\", 1i), \"1\");\n+    t!(ifmt!(\"{:t}\", 1i8), \"1\");\n+    t!(ifmt!(\"{:t}\", 1i16), \"1\");\n+    t!(ifmt!(\"{:t}\", 1i32), \"1\");\n+    t!(ifmt!(\"{:t}\", 1i64), \"1\");\n+    t!(ifmt!(\"{:x}\", 1i), \"1\");\n+    t!(ifmt!(\"{:x}\", 1i8), \"1\");\n+    t!(ifmt!(\"{:x}\", 1i16), \"1\");\n+    t!(ifmt!(\"{:x}\", 1i32), \"1\");\n+    t!(ifmt!(\"{:x}\", 1i64), \"1\");\n+    t!(ifmt!(\"{:X}\", 1i), \"1\");\n+    t!(ifmt!(\"{:X}\", 1i8), \"1\");\n+    t!(ifmt!(\"{:X}\", 1i16), \"1\");\n+    t!(ifmt!(\"{:X}\", 1i32), \"1\");\n+    t!(ifmt!(\"{:X}\", 1i64), \"1\");\n+    t!(ifmt!(\"{:o}\", 1i), \"1\");\n+    t!(ifmt!(\"{:o}\", 1i8), \"1\");\n+    t!(ifmt!(\"{:o}\", 1i16), \"1\");\n+    t!(ifmt!(\"{:o}\", 1i32), \"1\");\n+    t!(ifmt!(\"{:o}\", 1i64), \"1\");\n+\n+    t!(ifmt!(\"{:u}\", 1u), \"1\");\n+    t!(ifmt!(\"{:u}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:u}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:u}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:u}\", 1u64), \"1\");\n+    t!(ifmt!(\"{:t}\", 1u), \"1\");\n+    t!(ifmt!(\"{:t}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:t}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:t}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:t}\", 1u64), \"1\");\n+    t!(ifmt!(\"{:x}\", 1u), \"1\");\n+    t!(ifmt!(\"{:x}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:x}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:x}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:x}\", 1u64), \"1\");\n+    t!(ifmt!(\"{:X}\", 1u), \"1\");\n+    t!(ifmt!(\"{:X}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:X}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:X}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:X}\", 1u64), \"1\");\n+    t!(ifmt!(\"{:o}\", 1u), \"1\");\n+    t!(ifmt!(\"{:o}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:o}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:o}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:o}\", 1u64), \"1\");\n+\n+    // Test the flags for formatting integers\n+    t!(ifmt!(\"{:3d}\", 1),  \"  1\");\n+    t!(ifmt!(\"{:>3d}\", 1),  \"  1\");\n+    t!(ifmt!(\"{:>+3d}\", 1), \" +1\");\n+    t!(ifmt!(\"{:<3d}\", 1), \"1  \");\n+    t!(ifmt!(\"{:#d}\", 1), \"1\");\n+    t!(ifmt!(\"{:#x}\", 10), \"0xa\");\n+    t!(ifmt!(\"{:#X}\", 10), \"0xA\");\n+    t!(ifmt!(\"{:#5x}\", 10), \"  0xa\");\n+    t!(ifmt!(\"{:#o}\", 10), \"0o12\");\n+    t!(ifmt!(\"{:08x}\", 10),  \"0000000a\");\n+    t!(ifmt!(\"{:8x}\", 10),   \"       a\");\n+    t!(ifmt!(\"{:<8x}\", 10),  \"a       \");\n+    t!(ifmt!(\"{:>8x}\", 10),  \"       a\");\n+    t!(ifmt!(\"{:#08x}\", 10), \"0x00000a\");\n+    t!(ifmt!(\"{:08d}\", -10), \"-0000010\");\n+    t!(ifmt!(\"{:x}\", -1u8), \"ff\");\n+    t!(ifmt!(\"{:X}\", -1u8), \"FF\");\n+    t!(ifmt!(\"{:t}\", -1u8), \"11111111\");\n+    t!(ifmt!(\"{:o}\", -1u8), \"377\");\n+    t!(ifmt!(\"{:#x}\", -1u8), \"0xff\");\n+    t!(ifmt!(\"{:#X}\", -1u8), \"0xFF\");\n+    t!(ifmt!(\"{:#t}\", -1u8), \"0b11111111\");\n+    t!(ifmt!(\"{:#o}\", -1u8), \"0o377\");\n+\n+    // Signed combinations\n+    t!(ifmt!(\"{:+5d}\", 1),  \"   +1\");\n+    t!(ifmt!(\"{:+5d}\", -1), \"   -1\");\n+    t!(ifmt!(\"{:05d}\", 1),   \"00001\");\n+    t!(ifmt!(\"{:05d}\", -1),  \"-0001\");\n+    t!(ifmt!(\"{:+05d}\", 1),  \"+0001\");\n+    t!(ifmt!(\"{:+05d}\", -1), \"-0001\");\n+\n+    // Some float stuff\n+    t!(ifmt!(\"{:f}\", 1.0f), \"1\");\n+    t!(ifmt!(\"{:f}\", 1.0f32), \"1\");\n+    t!(ifmt!(\"{:f}\", 1.0f64), \"1\");\n+    t!(ifmt!(\"{:.3f}\", 1.0f), \"1.000\");\n+    t!(ifmt!(\"{:10.3f}\", 1.0f),   \"     1.000\");\n+    t!(ifmt!(\"{:+10.3f}\", 1.0f),  \"    +1.000\");\n+    t!(ifmt!(\"{:+10.3f}\", -1.0f), \"    -1.000\");\n }\n "}]}