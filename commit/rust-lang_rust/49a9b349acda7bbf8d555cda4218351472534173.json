{"sha": "49a9b349acda7bbf8d555cda4218351472534173", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YTliMzQ5YWNkYTdiYmY4ZDU1NWNkYTQyMTgzNTE0NzI1MzQxNzM=", "commit": {"author": {"name": "Christian", "email": "chris_veenman@hotmail.com", "date": "2019-03-21T14:06:16Z"}, "committer": {"name": "Christian", "email": "chris_veenman@hotmail.com", "date": "2019-03-21T14:06:16Z"}, "message": "Reformatted the text such that the line length does not exceed 100.", "tree": {"sha": "d4a409c5830a459783888af4088e3596af6ef6e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4a409c5830a459783888af4088e3596af6ef6e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49a9b349acda7bbf8d555cda4218351472534173", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49a9b349acda7bbf8d555cda4218351472534173", "html_url": "https://github.com/rust-lang/rust/commit/49a9b349acda7bbf8d555cda4218351472534173", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49a9b349acda7bbf8d555cda4218351472534173/comments", "author": null, "committer": null, "parents": [{"sha": "71bdeb022a9403707a17a62f51d9b35e5f76ff85", "url": "https://api.github.com/repos/rust-lang/rust/commits/71bdeb022a9403707a17a62f51d9b35e5f76ff85", "html_url": "https://github.com/rust-lang/rust/commit/71bdeb022a9403707a17a62f51d9b35e5f76ff85"}], "stats": {"total": 37, "additions": 22, "deletions": 15}, "files": [{"sha": "30c3823e0b4bce6fa6a2b2618aff66d631b966f6", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/49a9b349acda7bbf8d555cda4218351472534173/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a9b349acda7bbf8d555cda4218351472534173/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=49a9b349acda7bbf8d555cda4218351472534173", "patch": "@@ -6,8 +6,10 @@\n //! - Implement the [`AsRef`] trait for cheap reference-to-reference conversions\n //! - Implement the [`AsMut`] trait for cheap mutable-to-mutable conversions\n //! - Implement the [`From`] trait for consuming value-to-value conversions\n-//! - Implement the [`Into`] trait for consuming value-to-value conversions to types outside the current crate\n-//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`], but should be implemented when\n+//! - Implement the [`Into`] trait for consuming value-to-value conversions to types\n+//! outside the current crate\n+//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`],\n+//! but should be implemented when\n //! the conversion can fail.\n //!\n //! The traits in this module are often used as trait bounds for generic functions such that to\n@@ -196,9 +198,10 @@ pub trait AsMut<T: ?Sized> {\n /// A value-to-value conversion that consumes the input value. The\n /// opposite of [`From`].\n ///\n-/// One should only implement [`Into`] if a conversion to a type outside the current crate is required.\n-/// Otherwise one should always prefer implementing [`From`] over [`Into`] because implementing [`From`] automatically\n-/// provides one with a implementation of [`Into`] thanks to the blanket implementation in the standard library.\n+/// One should only implement [`Into`] if a conversion to a type outside the current crate is\n+/// required. Otherwise one should always prefer implementing [`From`] over [`Into`] because\n+/// implementing [`From`] automatically provides one with a implementation of [`Into`]\n+/// thanks to the blanket implementation in the standard library.\n /// [`From`] cannot do these type of conversions because of Rust's orphaning rules.\n ///\n /// **Note: This trait must not fail**. If the conversion can fail, use [`TryInto`].\n@@ -209,7 +212,8 @@ pub trait AsMut<T: ?Sized> {\n /// - [`Into`]` is reflexive, which means that `Into<T> for T` is implemented\n ///\n /// # Implementing `Into` for conversions to external types\n-/// If the destination type is not part of the current crate then you can't implement [`From`] directly.\n+/// If the destination type is not part of the current crate\n+/// then you can't implement [`From`] directly.\n /// For example, take this code:\n ///\n /// ```compile_fail\n@@ -233,8 +237,9 @@ pub trait AsMut<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// It is important to understand that ```Into``` does not provide a [`From`] implementation (as [`From`] does with ```Into```).\n-/// Therefore, you should always try to implement [`From`] and then fall back to `Into` if [`From`] can't be implemented.\n+/// It is important to understand that ```Into``` does not provide a [`From`] implementation\n+/// (as [`From`] does with ```Into```). Therefore, you should always try to implement [`From`]\n+/// and then fall back to `Into` if [`From`] can't be implemented.\n /// Prefer using ```Into``` over ```From``` when specifying trait bounds on a generic function\n /// to ensure that types that only implement ```Into``` can be used as well.\n ///\n@@ -274,8 +279,9 @@ pub trait Into<T>: Sized {\n /// Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n /// [`Into`].\n ///\n-/// One should always prefer implementing [`From`] over [`Into`] because implementing [`From`] automatically\n-/// provides one with a implementation of [`Into`] thanks to the blanket implementation in the standard library.\n+/// One should always prefer implementing [`From`] over [`Into`]\n+/// because implementing [`From`] automatically provides one with a implementation of [`Into`]\n+/// thanks to the blanket implementation in the standard library.\n /// Only implement [`Into`] if a conversion to a type outside the current crate is required.\n /// [`From`] cannot do these type of conversions because of Rust's orphaning rules.\n /// See [`Into`] for more details.\n@@ -308,11 +314,12 @@ pub trait Into<T>: Sized {\n /// assert_eq!(string, other_string);\n /// ```\n ///\n-/// While performing error handling it is often useful to implement ```From``` for your own error type.\n-/// By converting underlying error types to our own custom error type that encapsulates the underlying\n-/// error type, we can return a single error type without losing information on the underlying cause.\n-/// The '?' operator automatically converts the underlying error type to our custom error type by\n-/// calling ```Into<CliError>::into``` which is automatically provided when implementing ```From```.\n+/// While performing error handling it is often useful to implement ```From```\n+/// for your own error type. By converting underlying error types to our own custom error type\n+/// that encapsulates the underlying error type, we can return a single error type\n+/// without losing information on the underlying cause. The '?' operator automatically converts\n+/// the underlying error type to our custom error type by calling ```Into<CliError>::into```\n+/// which is automatically provided when implementing ```From```.\n /// The compiler then infers which implementation of ```Into``` should be used.\n ///\n /// ```"}]}