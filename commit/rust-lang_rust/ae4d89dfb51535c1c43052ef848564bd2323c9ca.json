{"sha": "ae4d89dfb51535c1c43052ef848564bd2323c9ca", "node_id": "C_kwDOAAsO6NoAKGFlNGQ4OWRmYjUxNTM1YzFjNDMwNTJlZjg0ODU2NGJkMjMyM2M5Y2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-15T15:07:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-15T15:07:27Z"}, "message": "Auto merge of #106742 - compiler-errors:new-solver-make-it-not-ice, r=lcnr\n\nImplement some FIXME methods in the new trait solver\n\nImplement just enough of the solver's response logic to make it not ICE.\n\nAlso, fix a bug with `no_bound_vars` call failing due to canonical bound vars.\n\nr? `@lcnr`", "tree": {"sha": "e58d5b1bef2947d2d676b2e996992f538ef0596a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e58d5b1bef2947d2d676b2e996992f538ef0596a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae4d89dfb51535c1c43052ef848564bd2323c9ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae4d89dfb51535c1c43052ef848564bd2323c9ca", "html_url": "https://github.com/rust-lang/rust/commit/ae4d89dfb51535c1c43052ef848564bd2323c9ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae4d89dfb51535c1c43052ef848564bd2323c9ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc11ee02ee91b32e23684cd478bca80fe5323b47", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc11ee02ee91b32e23684cd478bca80fe5323b47", "html_url": "https://github.com/rust-lang/rust/commit/fc11ee02ee91b32e23684cd478bca80fe5323b47"}, {"sha": "1de196fef308c236aee8804c7b452ad5f5bbaf88", "url": "https://api.github.com/repos/rust-lang/rust/commits/1de196fef308c236aee8804c7b452ad5f5bbaf88", "html_url": "https://github.com/rust-lang/rust/commit/1de196fef308c236aee8804c7b452ad5f5bbaf88"}], "stats": {"total": 227, "additions": 186, "deletions": 41}, "files": [{"sha": "e49e7e86da08527ec87522011b79e84fd48314f1", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=ae4d89dfb51535c1c43052ef848564bd2323c9ca", "patch": "@@ -7,8 +7,8 @@ use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use crate::ty::visit::ValidateBoundVars;\n use crate::ty::InferTy::*;\n use crate::ty::{\n-    self, AdtDef, DefIdTree, Discr, Term, Ty, TyCtxt, TypeFlags, TypeSuperVisitable, TypeVisitable,\n-    TypeVisitor,\n+    self, AdtDef, DefIdTree, Discr, FallibleTypeFolder, Term, Ty, TyCtxt, TypeFlags, TypeFoldable,\n+    TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use crate::ty::{List, ParamEnv};\n use hir::def::DefKind;\n@@ -1106,6 +1106,17 @@ impl<'tcx, T> Binder<'tcx, T> {\n         if self.0.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }\n     }\n \n+    pub fn no_bound_vars_ignoring_escaping(self, tcx: TyCtxt<'tcx>) -> Option<T>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        if !self.0.has_escaping_bound_vars() {\n+            Some(self.skip_binder())\n+        } else {\n+            self.0.try_fold_with(&mut SkipBindersAt { index: ty::INNERMOST, tcx }).ok()\n+        }\n+    }\n+\n     /// Splits the contents into two things that share the same binder\n     /// level as the original, returning two distinct binders.\n     ///\n@@ -1135,6 +1146,81 @@ impl<'tcx, T: IntoIterator> Binder<'tcx, T> {\n     }\n }\n \n+struct SkipBindersAt<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    index: ty::DebruijnIndex,\n+}\n+\n+impl<'tcx> FallibleTypeFolder<'tcx> for SkipBindersAt<'tcx> {\n+    type Error = ();\n+\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n+    where\n+        T: ty::TypeFoldable<'tcx>,\n+    {\n+        self.index.shift_in(1);\n+        let value = t.try_map_bound(|t| t.try_fold_with(self));\n+        self.index.shift_out(1);\n+        value\n+    }\n+\n+    fn try_fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        if !ty.has_escaping_bound_vars() {\n+            Ok(ty)\n+        } else if let ty::Bound(index, bv) = *ty.kind() {\n+            if index == self.index {\n+                Err(())\n+            } else {\n+                Ok(self.tcx().mk_ty(ty::Bound(index.shifted_out(1), bv)))\n+            }\n+        } else {\n+            ty.try_super_fold_with(self)\n+        }\n+    }\n+\n+    fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n+        if !r.has_escaping_bound_vars() {\n+            Ok(r)\n+        } else if let ty::ReLateBound(index, bv) = r.kind() {\n+            if index == self.index {\n+                Err(())\n+            } else {\n+                Ok(self.tcx().mk_region(ty::ReLateBound(index.shifted_out(1), bv)))\n+            }\n+        } else {\n+            r.try_super_fold_with(self)\n+        }\n+    }\n+\n+    fn try_fold_const(&mut self, ct: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n+        if !ct.has_escaping_bound_vars() {\n+            Ok(ct)\n+        } else if let ty::ConstKind::Bound(index, bv) = ct.kind() {\n+            if index == self.index {\n+                Err(())\n+            } else {\n+                Ok(self.tcx().mk_const(\n+                    ty::ConstKind::Bound(index.shifted_out(1), bv),\n+                    ct.ty().try_fold_with(self)?,\n+                ))\n+            }\n+        } else {\n+            ct.try_super_fold_with(self)\n+        }\n+    }\n+\n+    fn try_fold_predicate(\n+        &mut self,\n+        p: ty::Predicate<'tcx>,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n+        if !p.has_escaping_bound_vars() { Ok(p) } else { p.try_super_fold_with(self) }\n+    }\n+}\n+\n /// Represents the projection of an associated type.\n ///\n /// For a projection, this would be `<Ty as Trait<...>>::N`."}, {"sha": "ba68da0686feaea3aa7c0c5fb845e27f3034eab8", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=ae4d89dfb51535c1c43052ef848564bd2323c9ca", "patch": "@@ -2,8 +2,8 @@\n \n use super::infcx_ext::InferCtxtExt;\n use super::{\n-    fixme_instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty,\n-    EvalCtxt, Goal,\n+    instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty, EvalCtxt,\n+    Goal,\n };\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -121,11 +121,8 @@ impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n             // canonical wrt the caller.\n             for Candidate { source, result } in normalized_candidates {\n                 self.infcx.probe(|_| {\n-                    let candidate_certainty = fixme_instantiate_canonical_query_response(\n-                        &self.infcx,\n-                        &orig_values,\n-                        result,\n-                    );\n+                    let candidate_certainty =\n+                        instantiate_canonical_query_response(&self.infcx, &orig_values, result);\n \n                     // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n                     //"}, {"sha": "f1ee73a5b853f463ad9c77b2104a231bcabd3be2", "filename": "compiler/rustc_trait_selection/src/solve/cache.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs?ref=ae4d89dfb51535c1c43052ef848564bd2323c9ca", "patch": "@@ -9,11 +9,12 @@\n //! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n //! before then or if I still haven't done that before January 2023.\n use super::overflow::OverflowData;\n-use super::CanonicalGoal;\n+use super::{CanonicalGoal, Certainty, MaybeCause, Response};\n use super::{EvalCtxt, QueryResult};\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n+use rustc_middle::ty::{self, TyCtxt};\n use std::{cmp::Ordering, collections::hash_map::Entry};\n \n #[derive(Debug, Clone)]\n@@ -111,11 +112,11 @@ impl<'tcx> EvalCtxt<'tcx> {\n             // No entry, simply push this goal on the stack after dealing with overflow.\n             Entry::Vacant(v) => {\n                 if self.overflow_data.has_overflow(cache.stack.len()) {\n-                    return Err(self.deal_with_overflow());\n+                    return Err(self.deal_with_overflow(goal));\n                 }\n \n                 v.insert(ProvisionalEntry {\n-                    response: fixme_response_yes_no_constraints(),\n+                    response: response_no_constraints(self.tcx, goal, Certainty::Yes),\n                     depth: cache.stack.len(),\n                 });\n                 cache.stack.push(StackElem { goal, has_been_used: false });\n@@ -150,7 +151,11 @@ impl<'tcx> EvalCtxt<'tcx> {\n                 {\n                     Err(entry.response)\n                 } else {\n-                    Err(fixme_response_maybe_no_constraints())\n+                    Err(response_no_constraints(\n+                        self.tcx,\n+                        goal,\n+                        Certainty::Maybe(MaybeCause::Ambiguity),\n+                    ))\n                 }\n             }\n         }\n@@ -248,10 +253,39 @@ impl<'tcx> EvalCtxt<'tcx> {\n     }\n }\n \n-fn fixme_response_yes_no_constraints<'tcx>() -> QueryResult<'tcx> {\n-    unimplemented!()\n-}\n+pub(super) fn response_no_constraints<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    goal: Canonical<'tcx, impl Sized>,\n+    certainty: Certainty,\n+) -> QueryResult<'tcx> {\n+    let var_values = goal\n+        .variables\n+        .iter()\n+        .enumerate()\n+        .map(|(i, info)| match info.kind {\n+            CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => {\n+                tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i).into())).into()\n+            }\n+            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(i),\n+                    kind: ty::BrAnon(i as u32, None),\n+                };\n+                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n+            }\n+            CanonicalVarKind::Const(_, ty) | CanonicalVarKind::PlaceholderConst(_, ty) => tcx\n+                .mk_const(ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i)), ty)\n+                .into(),\n+        })\n+        .collect();\n \n-fn fixme_response_maybe_no_constraints<'tcx>() -> QueryResult<'tcx> {\n-    unimplemented!()\n+    Ok(Canonical {\n+        max_universe: goal.max_universe,\n+        variables: goal.variables,\n+        value: Response {\n+            var_values: CanonicalVarValues { var_values },\n+            external_constraints: Default::default(),\n+            certainty,\n+        },\n+    })\n }"}, {"sha": "dfc2b5ed32947d11a847fd64019b391bf9fc32af", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=ae4d89dfb51535c1c43052ef848564bd2323c9ca", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n         let mut errors = Vec::new();\n         for i in 0.. {\n             if !infcx.tcx.recursion_limit().value_within_limit(i) {\n-                unimplemented!(\"overflow\")\n+                unimplemented!(\"overflowed on pending obligations: {:?}\", self.obligations);\n             }\n \n             let mut has_changed = false;"}, {"sha": "042ba96b379e08ac271a80040fac474e621b233b", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=ae4d89dfb51535c1c43052ef848564bd2323c9ca", "patch": "@@ -19,15 +19,19 @@\n \n use std::mem;\n \n-use rustc_infer::infer::canonical::OriginalQueryValues;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n+use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n+use rustc_middle::infer::canonical::Certainty as OldCertainty;\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{RegionOutlivesPredicate, ToPredicate, TypeOutlivesPredicate};\n use rustc_span::DUMMY_SP;\n \n+use crate::traits::ObligationCause;\n+\n+use self::cache::response_no_constraints;\n use self::infcx_ext::InferCtxtExt;\n \n mod assembly;\n@@ -119,7 +123,7 @@ pub enum MaybeCause {\n }\n \n /// Additional constraints returned on success.\n-#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable)]\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable, Default)]\n pub struct ExternalConstraints<'tcx> {\n     // FIXME: implement this.\n     regions: (),\n@@ -175,7 +179,7 @@ impl<'tcx> EvalCtxt<'tcx> {\n         let canonical_response = self.evaluate_canonical_goal(canonical_goal)?;\n         Ok((\n             true, // FIXME: check whether `var_values` are an identity substitution.\n-            fixme_instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n+            instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n         ))\n     }\n \n@@ -208,7 +212,8 @@ impl<'tcx> EvalCtxt<'tcx> {\n         // of `PredicateKind` this is the case and it is and faster than instantiating and\n         // recanonicalizing.\n         let Goal { param_env, predicate } = canonical_goal.value;\n-        if let Some(kind) = predicate.kind().no_bound_vars() {\n+\n+        if let Some(kind) = predicate.kind().no_bound_vars_ignoring_escaping(self.tcx) {\n             match kind {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => self.compute_trait_goal(\n                     canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n@@ -234,7 +239,10 @@ impl<'tcx> EvalCtxt<'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(_)\n                 | ty::PredicateKind::ConstEquate(_, _)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(_)\n-                | ty::PredicateKind::Ambiguous => unimplemented!(),\n+                | ty::PredicateKind::Ambiguous => {\n+                    // FIXME\n+                    response_no_constraints(self.tcx, canonical_goal, Certainty::Yes)\n+                }\n             }\n         } else {\n             let (infcx, goal, var_values) =\n@@ -248,16 +256,18 @@ impl<'tcx> EvalCtxt<'tcx> {\n \n     fn compute_type_outlives_goal(\n         &mut self,\n-        _goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+        goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        todo!()\n+        // FIXME\n+        response_no_constraints(self.tcx, goal, Certainty::Yes)\n     }\n \n     fn compute_region_outlives_goal(\n         &mut self,\n-        _goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+        goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        todo!()\n+        // FIXME\n+        response_no_constraints(self.tcx, goal, Certainty::Yes)\n     }\n }\n \n@@ -300,10 +310,27 @@ impl<'tcx> EvalCtxt<'tcx> {\n     }\n }\n \n-fn fixme_instantiate_canonical_query_response<'tcx>(\n-    _: &InferCtxt<'tcx>,\n-    _: &OriginalQueryValues<'tcx>,\n-    _: CanonicalResponse<'tcx>,\n+fn instantiate_canonical_query_response<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    original_values: &OriginalQueryValues<'tcx>,\n+    response: CanonicalResponse<'tcx>,\n ) -> Certainty {\n-    unimplemented!()\n+    let Ok(InferOk { value, obligations }) = infcx\n+        .instantiate_query_response_and_region_obligations(\n+            &ObligationCause::dummy(),\n+            ty::ParamEnv::empty(),\n+            original_values,\n+            &response.unchecked_map(|resp| QueryResponse {\n+                var_values: resp.var_values,\n+                region_constraints: QueryRegionConstraints::default(),\n+                certainty: match resp.certainty {\n+                    Certainty::Yes => OldCertainty::Proven,\n+                    Certainty::Maybe(_) => OldCertainty::Ambiguous,\n+                },\n+                opaque_types: resp.external_constraints.opaque_types,\n+                value: resp.certainty,\n+            }),\n+        ) else { bug!(); };\n+    assert!(obligations.is_empty());\n+    value\n }"}, {"sha": "8bbb9f63e78682702ed9fdba111658e8e9ad3539", "filename": "compiler/rustc_trait_selection/src/solve/overflow.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4d89dfb51535c1c43052ef848564bd2323c9ca/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs?ref=ae4d89dfb51535c1c43052ef848564bd2323c9ca", "patch": "@@ -1,7 +1,9 @@\n+use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Limit;\n \n+use super::cache::response_no_constraints;\n use super::{Certainty, EvalCtxt, MaybeCause, QueryResult};\n \n /// When detecting a solver overflow, we return ambiguity. Overflow can be\n@@ -49,9 +51,12 @@ impl OverflowData {\n }\n \n impl<'tcx> EvalCtxt<'tcx> {\n-    pub(super) fn deal_with_overflow(&mut self) -> QueryResult<'tcx> {\n+    pub(super) fn deal_with_overflow(\n+        &mut self,\n+        goal: Canonical<'tcx, impl Sized>,\n+    ) -> QueryResult<'tcx> {\n         self.overflow_data.deal_with_overflow();\n-        fixme_response_overflow_no_constraints()\n+        response_no_constraints(self.tcx, goal, Certainty::Maybe(MaybeCause::Overflow))\n     }\n \n     /// A `while`-loop which tracks overflow.\n@@ -74,7 +79,3 @@ impl<'tcx> EvalCtxt<'tcx> {\n         Ok(Certainty::Maybe(MaybeCause::Overflow))\n     }\n }\n-\n-fn fixme_response_overflow_no_constraints<'tcx>() -> QueryResult<'tcx> {\n-    unimplemented!()\n-}"}]}