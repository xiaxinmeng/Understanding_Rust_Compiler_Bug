{"sha": "293cd3480c10855de68503db36c6cc3ce8988b54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5M2NkMzQ4MGMxMDg1NWRlNjg1MDNkYjM2YzZjYzNjZTg5ODhiNTQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-15T05:36:27Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-15T05:36:27Z"}, "message": "convert ast::{field_,capture_item_,mt} and middle::ty::mt into structs", "tree": {"sha": "34ded4b28bd49ec489bb7499b1fb02fd8767dcad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34ded4b28bd49ec489bb7499b1fb02fd8767dcad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/293cd3480c10855de68503db36c6cc3ce8988b54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/293cd3480c10855de68503db36c6cc3ce8988b54", "html_url": "https://github.com/rust-lang/rust/commit/293cd3480c10855de68503db36c6cc3ce8988b54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/293cd3480c10855de68503db36c6cc3ce8988b54/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "html_url": "https://github.com/rust-lang/rust/commit/4bcd19f6be51d7fb26b0930c8a3354b9222143ff"}], "stats": {"total": 324, "additions": 195, "deletions": 129}, "files": [{"sha": "e7e3a412a9ea4798afd8d61ce7c20426aba11bd7", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -340,13 +340,13 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::Ty {\n          node: ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()),\n          span: dummy_sp()};\n \n-    let vec_mt: ast::mt = {ty: @test_desc_ty, mutbl: ast::m_imm};\n+    let vec_mt = ast::mt {ty: @test_desc_ty, mutbl: ast::m_imm};\n \n     let inner_ty = @{id: cx.sess.next_node_id(),\n                      node: ast::ty_vec(vec_mt),\n                      span: dummy_sp()};\n     return @{id: cx.sess.next_node_id(),\n-          node: ast::ty_uniq({ty: inner_ty, mutbl: ast::m_imm}),\n+          node: ast::ty_uniq(ast::mt {ty: inner_ty, mutbl: ast::m_imm}),\n           span: dummy_sp()};\n }\n \n@@ -389,9 +389,11 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n                      span: dummy_sp()};\n \n \n-    let name_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: cx.sess.ident_of(~\"name\"),\n-                expr: @name_expr});\n+    let name_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"name\"),\n+        expr: @name_expr,\n+    });\n \n     let fn_path = path_node_global(path);\n \n@@ -403,9 +405,11 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n \n     let fn_wrapper_expr = mk_test_wrapper(cx, fn_expr, span);\n \n-    let fn_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: cx.sess.ident_of(~\"testfn\"),\n-                expr: fn_wrapper_expr});\n+    let fn_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"testfn\"),\n+        expr: fn_wrapper_expr,\n+    });\n \n     let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n \n@@ -415,9 +419,11 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n          node: ast::expr_lit(@ignore_lit),\n          span: span};\n \n-    let ignore_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: cx.sess.ident_of(~\"ignore\"),\n-                expr: @ignore_expr});\n+    let ignore_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"ignore\"),\n+        expr: @ignore_expr,\n+    });\n \n     let fail_lit: ast::lit = nospan(ast::lit_bool(test.should_fail));\n \n@@ -427,10 +433,11 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n          node: ast::expr_lit(@fail_lit),\n          span: span};\n \n-    let fail_field: ast::field =\n-        nospan({mutbl: ast::m_imm,\n-                ident: cx.sess.ident_of(~\"should_fail\"),\n-                expr: @fail_expr});\n+    let fail_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"should_fail\"),\n+        expr: @fail_expr,\n+    });\n \n     let test_desc_path =\n         mk_path(cx, ~[cx.sess.ident_of(~\"test\"),"}, {"sha": "9f9e00491461ca1076027b11be3f381b4ddae31c", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -353,7 +353,7 @@ fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n       '?' => { next(st); m = ast::m_const; }\n       _ => { m = ast::m_imm; }\n     }\n-    return {ty: parse_ty(st, conv), mutbl: m};\n+    ty::mt { ty: parse_ty(st, conv), mutbl: m }\n }\n \n fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {"}, {"sha": "13e559e6ce4caf907f3b021e81f62ad7b06fca5a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -728,7 +728,7 @@ impl &mem_categorization_ctxt {\n         // know what type lies at the other end, so we just call it\n         // `()` (the empty tuple).\n \n-        let mt = {ty: ty::mk_tup(self.tcx, ~[]), mutbl: m_imm};\n+        let mt = ty::mt {ty: ty::mk_tup(self.tcx, ~[]), mutbl: m_imm};\n         return self.cat_deref_common(node, base_cmt, deref_cnt, mt);\n     }\n "}, {"sha": "9a5e4cb217684ad70026428f414931cf53f43374", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -857,7 +857,7 @@ fn extract_vec_elems(bcx: block, pat_id: ast::node_id,\n         let tail_begin = tvec::pointer_add(bcx, base, tail_offset);\n         let tail_len = Sub(bcx, len, tail_offset);\n         let tail_ty = ty::mk_evec(bcx.tcx(),\n-            {ty: vt.unit_ty, mutbl: ast::m_imm},\n+            ty::mt {ty: vt.unit_ty, mutbl: ast::m_imm},\n             ty::vstore_slice(ty::re_static)\n         );\n         let scratch = scratch_datum(bcx, tail_ty, false);"}, {"sha": "f66823c808196292f2e318647838cce7b78f0633", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -2184,7 +2184,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef) {\n         let unit_ty = ty::mk_estr(ccx.tcx, ty::vstore_uniq);\n         let vecarg_ty: ty::arg =\n             {mode: ast::expl(ast::by_val),\n-             ty: ty::mk_evec(ccx.tcx, {ty: unit_ty, mutbl: ast::m_imm},\n+             ty: ty::mk_evec(ccx.tcx, ty::mt {ty: unit_ty, mutbl: ast::m_imm},\n                              ty::vstore_uniq)};\n         let nt = ty::mk_nil(ccx.tcx);\n         let llfty = type_of_fn(ccx, ~[vecarg_ty], nt);"}, {"sha": "09d188b6cd2c620327b955af1ea67ef967639707", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -224,7 +224,7 @@ fn store_environment(bcx: block,\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n     // whatever.\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-    let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mutbl:ast::m_imm});\n+    let cboxptr_ty = ty::mk_ptr(tcx, ty::mt {ty:cbox_ty, mutbl:ast::m_imm});\n \n     let llbox = PointerCast(bcx, llbox, type_of(ccx, cboxptr_ty));\n     debug!(\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty));"}, {"sha": "4481deec3c7481fc3ef43b9c9cac44a73addcabd", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -945,7 +945,10 @@ fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n // representation of @T as a tuple (i.e., the ty::t version of what T_box()\n // returns).\n fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n-    let ptr = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm});\n+    let ptr = ty::mk_ptr(\n+        tcx,\n+        ty::mt {ty: ty::mk_nil(tcx), mutbl: ast::m_imm}\n+    );\n     return ty::mk_tup(tcx, ~[ty::mk_uint(tcx), ty::mk_type(tcx),\n                          ptr, ptr,\n                          t]);"}, {"sha": "4c8bb91df4c628aa9d79ffd9c57324d7a589140e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -251,7 +251,8 @@ fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n-        let slice_ty = ty::mk_evec(tcx, {ty: unit_ty, mutbl: ast::m_imm},\n+        let slice_ty = ty::mk_evec(tcx,\n+                                   ty::mt { ty: unit_ty, mutbl: ast::m_imm },\n                                    ty::vstore_slice(ty::re_static));\n \n         let scratch = scratch_datum(bcx, slice_ty, false);"}, {"sha": "5c0498d5a14702e7bfdaeb61304270a44122a54b", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -26,7 +26,7 @@ use syntax::parse::token::special_idents;\n // nominal type that has pointers to itself in it.\n pub fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n     fn nilptr(tcx: ty::ctxt) -> ty::t {\n-        ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm})\n+        ty::mk_ptr(tcx, ty::mt {ty: ty::mk_nil(tcx), mutbl: ast::m_imm})\n     }\n     fn simplifier(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n         match ty::get(typ).sty {\n@@ -45,13 +45,12 @@ pub fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n             let simpl_fields = (if ty::ty_dtor(tcx, did).is_present() {\n                 // remember the drop flag\n                   ~[{ident: special_idents::dtor,\n-                     mt: {ty: ty::mk_u8(tcx),\n-                          mutbl: ast::m_mutbl}}] }\n+                     mt: ty::mt {ty: ty::mk_u8(tcx), mutbl: ast::m_mutbl}}] }\n                 else { ~[] }) +\n                 do ty::lookup_struct_fields(tcx, did).map |f| {\n                  let t = ty::lookup_field_type(tcx, did, f.id, substs);\n                  {ident: f.ident,\n-                  mt: {ty: simplify_type(tcx, t), mutbl: ast::m_const}}\n+                  mt: ty::mt {ty: simplify_type(tcx, t), mutbl: ast::m_const}}\n             };\n             ty::mk_rec(tcx, simpl_fields)\n           }"}, {"sha": "eb2fd91e6051fd8721173495cd61350a28a71cbd", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -214,7 +214,7 @@ fn trans_slice_vstore(bcx: block,\n \n     // Arrange for the backing array to be cleaned up.\n     let fixed_ty = ty::mk_evec(bcx.tcx(),\n-                               {ty: vt.unit_ty, mutbl: ast::m_mutbl},\n+                               ty::mt {ty: vt.unit_ty, mutbl: ast::m_mutbl},\n                                ty::vstore_fixed(count));\n     let llfixed_ty = T_ptr(type_of::type_of(bcx.ccx(), fixed_ty));\n     let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);"}, {"sha": "b84fbd8a38100d8e1a4a58272cef70ec7aab0521", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -258,7 +258,10 @@ type method = {ident: ast::ident,\n                vis: ast::visibility,\n                def_id: ast::def_id};\n \n-type mt = {ty: t, mutbl: ast::mutability};\n+struct mt {\n+    ty: t,\n+    mutbl: ast::mutability,\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -1149,34 +1152,37 @@ fn mk_enum(cx: ctxt, did: ast::def_id, +substs: substs) -> t {\n \n fn mk_box(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_box(tm)) }\n \n-fn mk_imm_box(cx: ctxt, ty: t) -> t { mk_box(cx, {ty: ty,\n-                                                  mutbl: ast::m_imm}) }\n+fn mk_imm_box(cx: ctxt, ty: t) -> t {\n+    mk_box(cx, mt {ty: ty, mutbl: ast::m_imm})\n+}\n \n fn mk_uniq(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_uniq(tm)) }\n \n-fn mk_imm_uniq(cx: ctxt, ty: t) -> t { mk_uniq(cx, {ty: ty,\n-                                                    mutbl: ast::m_imm}) }\n+fn mk_imm_uniq(cx: ctxt, ty: t) -> t {\n+    mk_uniq(cx, mt {ty: ty, mutbl: ast::m_imm})\n+}\n \n fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n \n fn mk_rptr(cx: ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n \n fn mk_mut_rptr(cx: ctxt, r: Region, ty: t) -> t {\n-    mk_rptr(cx, r, {ty: ty, mutbl: ast::m_mutbl})\n+    mk_rptr(cx, r, mt {ty: ty, mutbl: ast::m_mutbl})\n }\n fn mk_imm_rptr(cx: ctxt, r: Region, ty: t) -> t {\n-    mk_rptr(cx, r, {ty: ty, mutbl: ast::m_imm})\n+    mk_rptr(cx, r, mt {ty: ty, mutbl: ast::m_imm})\n }\n \n-fn mk_mut_ptr(cx: ctxt, ty: t) -> t { mk_ptr(cx, {ty: ty,\n-                                                  mutbl: ast::m_mutbl}) }\n+fn mk_mut_ptr(cx: ctxt, ty: t) -> t {\n+    mk_ptr(cx, mt {ty: ty, mutbl: ast::m_mutbl})\n+}\n \n fn mk_imm_ptr(cx: ctxt, ty: t) -> t {\n-    mk_ptr(cx, {ty: ty, mutbl: ast::m_imm})\n+    mk_ptr(cx, mt {ty: ty, mutbl: ast::m_imm})\n }\n \n fn mk_nil_ptr(cx: ctxt) -> t {\n-    mk_ptr(cx, {ty: mk_nil(cx), mutbl: ast::m_imm})\n+    mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::m_imm})\n }\n \n fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n@@ -1187,7 +1193,7 @@ fn mk_unboxed_vec(cx: ctxt, tm: mt) -> t {\n     mk_t(cx, ty_unboxed_vec(tm))\n }\n fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n-    mk_t(cx, ty_unboxed_vec({ty: ty, mutbl: ast::m_imm}))\n+    mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::m_imm}))\n }\n \n fn mk_rec(cx: ctxt, +fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n@@ -1353,19 +1359,19 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n \n     match /*bad*/copy *sty {\n         ty_box(tm) => {\n-            ty_box({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+            ty_box(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_uniq(tm) => {\n-            ty_uniq({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+            ty_uniq(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_ptr(tm) => {\n-            ty_ptr({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+            ty_ptr(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_unboxed_vec(tm) => {\n-            ty_unboxed_vec({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+            ty_unboxed_vec(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_evec(tm, vst) => {\n-            ty_evec({ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n+            ty_evec(mt {ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n         }\n         ty_enum(tid, ref substs) => {\n             ty_enum(tid, fold_substs(substs, fldop))\n@@ -1376,7 +1382,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n         ty_rec(fields) => {\n             let new_fields = do vec::map(fields) |fl| {\n                 let new_ty = fldop(fl.mt.ty);\n-                let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n+                let new_mt = mt {ty: new_ty, mutbl: fl.mt.mutbl};\n                 {ident: fl.ident, mt: new_mt}\n             };\n             ty_rec(new_fields)\n@@ -1390,7 +1396,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n             ty_fn(FnTyBase {meta: f.meta, sig: sig})\n         }\n         ty_rptr(r, tm) => {\n-            ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n+            ty_rptr(r, mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_struct(did, ref substs) => {\n             ty_struct(did, fold_substs(substs, fldop))\n@@ -1446,7 +1452,7 @@ fn fold_regions_and_ty(\n       ty::ty_rptr(r, mt) => {\n         let m_r = fldr(r);\n         let m_t = fldt(mt.ty);\n-        ty::mk_rptr(cx, m_r, {ty: m_t, mutbl: mt.mutbl})\n+        ty::mk_rptr(cx, m_r, mt {ty: m_t, mutbl: mt.mutbl})\n       }\n       ty_estr(vstore_slice(r)) => {\n         let m_r = fldr(r);\n@@ -1455,7 +1461,7 @@ fn fold_regions_and_ty(\n       ty_evec(mt, vstore_slice(r)) => {\n         let m_r = fldr(r);\n         let m_t = fldt(mt.ty);\n-        ty::mk_evec(cx, {ty: m_t, mutbl: mt.mutbl}, vstore_slice(m_r))\n+        ty::mk_evec(cx, mt {ty: m_t, mutbl: mt.mutbl}, vstore_slice(m_r))\n       }\n       ty_enum(def_id, ref substs) => {\n         ty::mk_enum(cx, def_id, fold_substs(substs, fldr, fldt))\n@@ -1527,19 +1533,19 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(Region, bool) -> Region) -> t {\n         let tb = get(t0);\n         if !tbox_has_flag(tb, has_regions) { return t0; }\n         match tb.sty {\n-          ty_rptr(r, {ty: t1, mutbl: m}) => {\n+          ty_rptr(r, mt {ty: t1, mutbl: m}) => {\n             let m_r = fldop(r, under_r);\n             let m_t1 = do_fold(cx, t1, true, fldop);\n-            ty::mk_rptr(cx, m_r, {ty: m_t1, mutbl: m})\n+            ty::mk_rptr(cx, m_r, mt {ty: m_t1, mutbl: m})\n           }\n           ty_estr(vstore_slice(r)) => {\n             let m_r = fldop(r, under_r);\n             ty::mk_estr(cx, vstore_slice(m_r))\n           }\n-          ty_evec({ty: t1, mutbl: m}, vstore_slice(r)) => {\n+          ty_evec(mt {ty: t1, mutbl: m}, vstore_slice(r)) => {\n             let m_r = fldop(r, under_r);\n             let m_t1 = do_fold(cx, t1, true, fldop);\n-            ty::mk_evec(cx, {ty: m_t1, mutbl: m}, vstore_slice(m_r))\n+            ty::mk_evec(cx, mt {ty: m_t1, mutbl: m}, vstore_slice(m_r))\n           }\n           ty_fn(_) => {\n             // do not recurse into functions, which introduce fresh bindings\n@@ -2707,7 +2713,7 @@ fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n         let variants = enum_variants(cx, did);\n         if vec::len(*variants) == 1u && vec::len(variants[0].args) == 1u {\n             let v_t = subst(cx, substs, variants[0].args[0]);\n-            Some({ty: v_t, mutbl: ast::m_imm})\n+            Some(mt {ty: v_t, mutbl: ast::m_imm})\n         } else {\n             None\n         }\n@@ -2717,7 +2723,7 @@ fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n         let fields = struct_fields(cx, did, substs);\n         if fields.len() == 1 && fields[0].ident ==\n                 syntax::parse::token::special_idents::unnamed_field {\n-            Some({ty: fields[0].mt.ty, mutbl: ast::m_imm})\n+            Some(mt {ty: fields[0].mt.ty, mutbl: ast::m_imm})\n         } else {\n             None\n         }\n@@ -2745,7 +2751,7 @@ fn index(cx: ctxt, t: t) -> Option<mt> {\n fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n     match *sty {\n       ty_evec(mt, _) => Some(mt),\n-      ty_estr(_) => Some({ty: mk_u8(cx), mutbl: ast::m_imm}),\n+      ty_estr(_) => Some(mt {ty: mk_u8(cx), mutbl: ast::m_imm}),\n       _ => None\n     }\n }\n@@ -4111,15 +4117,17 @@ fn struct_item_fields(cx:ctxt,\n                      substs: &substs,\n                      frob_mutability: fn(struct_mutability) -> mutability)\n     -> ~[field] {\n-    let mut rslt = ~[];\n-    for lookup_struct_fields(cx, did).each |f| {\n+    do lookup_struct_fields(cx, did).map |f| {\n        // consider all instance vars mut, because the\n        // constructor may mutate all vars\n-       rslt.push({ident: f.ident, mt:\n-               {ty: lookup_field_type(cx, did, f.id, substs),\n-                    mutbl: frob_mutability(f.mutability)}});\n+       {\n+           ident: f.ident,\n+            mt: mt {\n+                ty: lookup_field_type(cx, did, f.id, substs),\n+                mutbl: frob_mutability(f.mutability)\n+            }\n+        }\n     }\n-    rslt\n }\n \n fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n@@ -4199,7 +4207,7 @@ fn ty_params_to_tys(tcx: ty::ctxt, tps: ~[ast::ty_param]) -> ~[t] {\n /// Returns an equivalent type with all the typedefs and self regions removed.\n fn normalize_ty(cx: ctxt, t: t) -> t {\n     fn normalize_mt(cx: ctxt, mt: mt) -> mt {\n-        { ty: normalize_ty(cx, mt.ty), mutbl: mt.mutbl }\n+        mt { ty: normalize_ty(cx, mt.ty), mutbl: mt.mutbl }\n     }\n     fn normalize_vstore(vstore: vstore) -> vstore {\n         match vstore {"}, {"sha": "7e1c5f54134e197cfe3d29ed81e3ff19b6a8eab1", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -185,7 +185,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     fn ast_mt_to_mt<AC: ast_conv, RS: region_scope Copy Durable>(\n         self: AC, rscope: RS, mt: ast::mt) -> ty::mt {\n \n-        return {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n+        ty::mt {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl}\n     }\n \n     // Handle @, ~, and & being able to mean estrs and evecs.\n@@ -204,7 +204,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n             ast::ty_vec(mt) => {\n                 let mut mt = ast_mt_to_mt(self, rscope, mt);\n                 if a_seq_ty.mutbl == ast::m_mutbl {\n-                    mt = { ty: mt.ty, mutbl: ast::m_mutbl };\n+                    mt = ty::mt { ty: mt.ty, mutbl: ast::m_mutbl };\n                 }\n                 return ty::mk_evec(tcx, mt, vst);\n             }"}, {"sha": "9861178afb0ef9c4f03b68b531aa41c4bc2b6a6e", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -377,7 +377,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             let region_var =\n                 fcx.infcx().next_region_var_with_lb(\n                     pat.span, pcx.block_region);\n-            let mt = {ty: expected, mutbl: mutbl};\n+            let mt = ty::mt {ty: expected, mutbl: mutbl};\n             let region_ty = ty::mk_rptr(tcx, region_var, mt);\n             demand::eqtype(fcx, pat.span, region_ty, typ);\n           }\n@@ -575,7 +575,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         match tail {\n             Some(tail_pat) => {\n                 let slice_ty = ty::mk_evec(tcx,\n-                    {ty: elt_type.ty, mutbl: elt_type.mutbl},\n+                    ty::mt {ty: elt_type.ty, mutbl: elt_type.mutbl},\n                     ty::vstore_slice(region_var)\n                 );\n                 check_pat(pcx, tail_pat, slice_ty);"}, {"sha": "a8e834bff435f7f78b9a628304d24ca6d2c8248e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -731,7 +731,7 @@ impl LookupContext {\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [m_const, m_imm, m_mutbl],\n                     |m,r| ty::mk_evec(tcx,\n-                                      {ty:mt.ty, mutbl:m},\n+                                      ty::mt {ty:mt.ty, mutbl:m},\n                                       vstore_slice(r)));\n \n                 if entry.is_some() { return entry; }\n@@ -741,14 +741,14 @@ impl LookupContext {\n                     AutoBorrowVecRef, autoderefs, [m_const, m_imm, m_mutbl],\n                     |m,r| {\n                         let slice_ty = ty::mk_evec(tcx,\n-                                                   {ty:mt.ty, mutbl:m},\n+                                                   ty::mt {ty:mt.ty, mutbl:m},\n                                                    vstore_slice(r));\n                         // NB: we do not try to autoref to a mutable\n                         // pointer. That would be creating a pointer\n                         // to a temporary pointer (the borrowed\n                         // slice), so any update the callee makes to\n                         // it can't be observed.\n-                        ty::mk_rptr(tcx, r, {ty:slice_ty, mutbl:m_imm})\n+                        ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m_imm})\n                     })\n             }\n \n@@ -765,7 +765,7 @@ impl LookupContext {\n                     AutoBorrowVecRef, autoderefs, [m_imm],\n                     |m,r| {\n                         let slice_ty = ty::mk_estr(tcx, vstore_slice(r));\n-                        ty::mk_rptr(tcx, r, {ty:slice_ty, mutbl:m})\n+                        ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n                     })\n             }\n \n@@ -802,7 +802,7 @@ impl LookupContext {\n             ty_trait(*) | ty_fn(*) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [m_const, m_imm, m_mutbl],\n-                    |m,r| ty::mk_rptr(tcx, r, {ty:self_ty, mutbl:m}))\n+                    |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n             }\n \n             ty_err => None,\n@@ -1183,20 +1183,20 @@ fn transform_self_type_for_method(tcx: ty::ctxt,\n       sty_region(mutability) => {\n         mk_rptr(tcx,\n                 self_region.expect(~\"self region missing for &self param\"),\n-                { ty: impl_ty, mutbl: mutability })\n+                ty::mt { ty: impl_ty, mutbl: mutability })\n       }\n       sty_box(mutability) => {\n         match flag {\n             TransformTypeNormally => {\n-                mk_box(tcx, { ty: impl_ty, mutbl: mutability })\n+                mk_box(tcx, ty::mt { ty: impl_ty, mutbl: mutability })\n             }\n             TransformTypeForObject => impl_ty\n         }\n       }\n       sty_uniq(mutability) => {\n         match flag {\n             TransformTypeNormally => {\n-                mk_uniq(tcx, { ty: impl_ty, mutbl: mutability })\n+                mk_uniq(tcx, ty::mt { ty: impl_ty, mutbl: mutability })\n             }\n             TransformTypeForObject => impl_ty\n         }"}, {"sha": "8365c261decee6b03dab76217a71c8faa2985076", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -1936,15 +1936,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             }\n             let t: ty::t = fcx.infcx().next_ty_var();\n             for args.each |e| { bot |= check_expr_with(fcx, *e, t); }\n-            ty::mk_evec(tcx, {ty: t, mutbl: mutability}, tt)\n+            ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n           }\n           ast::expr_repeat(element, count_expr, mutbl) => {\n             let count = ty::eval_repeat_count(tcx, count_expr, expr.span);\n             fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, count, vst);\n             let t: ty::t = fcx.infcx().next_ty_var();\n             bot |= check_expr_with(fcx, element, t);\n-            ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n+            ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl}, tt)\n           }\n           _ =>\n             tcx.sess.span_bug(expr.span, ~\"vstore modifier on non-sequence\")\n@@ -1986,10 +1986,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let mut oprnd_t = fcx.expr_ty(oprnd);\n         match unop {\n           ast::box(mutbl) => {\n-            oprnd_t = ty::mk_box(tcx, {ty: oprnd_t, mutbl: mutbl});\n+            oprnd_t = ty::mk_box(tcx, ty::mt {ty: oprnd_t, mutbl: mutbl});\n           }\n           ast::uniq(mutbl) => {\n-            oprnd_t = ty::mk_uniq(tcx, {ty: oprnd_t, mutbl: mutbl});\n+            oprnd_t = ty::mk_uniq(tcx, ty::mt {ty: oprnd_t, mutbl: mutbl});\n           }\n           ast::deref => {\n             let sty = structure_of(fcx, expr.span, oprnd_t);\n@@ -2075,7 +2075,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // it needs to live.\n         let region = fcx.infcx().next_region_var(expr.span, expr.id);\n \n-        let tm = { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n+        let tm = ty::mt { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = ty::mk_rptr(tcx, region, tm);\n         fcx.write_ty(id, oprnd_t);\n       }\n@@ -2339,7 +2339,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_vec(args, mutbl) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n         for args.each |e| { bot |= check_expr_with(fcx, *e, t); }\n-        let typ = ty::mk_evec(tcx, {ty: t, mutbl: mutbl},\n+        let typ = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n                               ty::vstore_fixed(args.len()));\n         fcx.write_ty(id, typ);\n       }\n@@ -2348,7 +2348,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n         let t: ty::t = fcx.infcx().next_ty_var();\n         bot |= check_expr_with(fcx, element, t);\n-        let t = ty::mk_evec(tcx, {ty: t, mutbl: mutbl},\n+        let t = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n                             ty::vstore_fixed(count));\n         fcx.write_ty(id, t);\n       }\n@@ -2379,7 +2379,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 vec::find(*flds, |tf| tf.ident == f.node.ident)\n             ).map(|tf| tf.mt.ty));\n             let expr_t = fcx.expr_ty(f.node.expr);\n-            let expr_mt = {ty: expr_t, mutbl: f.node.mutbl};\n+            let expr_mt = ty::mt {ty: expr_t, mutbl: f.node.mutbl};\n             // for the most precise error message,\n             // should be f.node.expr.span, not f.span\n             respan(f.node.expr.span, {ident: f.node.ident, mt: expr_mt})\n@@ -2804,7 +2804,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n             region_param: None,\n             ty: ty::mk_ptr(\n                 fcx.ccx.tcx,\n-                {\n+                ty::mt {\n                     ty: ty::mk_mach_uint(fcx.ccx.tcx, ast::ty_u8),\n                     mutbl: ast::m_imm\n                 })\n@@ -3078,8 +3078,8 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n           assert ccx.tcx.intrinsic_defs.contains_key(ty_visitor_name);\n           let (_, tydesc_ty) = tcx.intrinsic_defs.get(tydesc_name);\n           let (_, visitor_trait) = tcx.intrinsic_defs.get(ty_visitor_name);\n-          let td_ptr = ty::mk_ptr(ccx.tcx, {ty: tydesc_ty,\n-                                            mutbl: ast::m_imm});\n+          let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,\n+                                                   mutbl: ast::m_imm});\n           (0u, ~[arg(ast::by_val, td_ptr),\n                  arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n       }"}, {"sha": "b22b061883c73c1117de850ed1eb0331cf341c82", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -63,7 +63,7 @@ pub fn replace_bound_regions_in_fn_sig(\n                                           _}, _}) => {\n         let region = ty::re_bound(ty::br_self);\n         let ty = ty::mk_rptr(tcx, region,\n-                             { ty: ty::mk_self(tcx), mutbl: m });\n+                             ty::mt { ty: ty::mk_self(tcx), mutbl: m });\n         all_tys.push(ty);\n       }\n       _ => {}"}, {"sha": "d25fed274b3e3d539f0ff7c1918cfd270d45c8a8", "filename": "src/librustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -173,14 +173,16 @@ priv impl Assign {\n                     // being assigned to a region pointer:\n                     (ty::ty_box(_), ty::ty_rptr(r_b, mt_b)) => {\n                         let nr_b = ty::mk_box(self.infcx.tcx,\n-                                              {ty: mt_b.ty, mutbl: m_const});\n+                                              ty::mt {ty: mt_b.ty,\n+                                                      mutbl: m_const});\n                         self.try_assign(1, ty::AutoPtr,\n                                         a, nr_b,\n                                         mt_b.mutbl, r_b)\n                     }\n                     (ty::ty_uniq(_), ty::ty_rptr(r_b, mt_b)) => {\n                         let nr_b = ty::mk_uniq(self.infcx.tcx,\n-                                               {ty: mt_b.ty, mutbl: m_const});\n+                                               ty::mt {ty: mt_b.ty,\n+                                                       mutbl: m_const});\n                         self.try_assign(1, ty::AutoPtr,\n                                         a, nr_b,\n                                         mt_b.mutbl, r_b)\n@@ -198,7 +200,8 @@ priv impl Assign {\n                      ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n                     if is_borrowable(vs_a) => {\n                         let nr_b = ty::mk_evec(self.infcx.tcx,\n-                                               {ty: mt_b.ty, mutbl: m_const},\n+                                               ty::mt {ty: mt_b.ty,\n+                                                       mutbl: m_const},\n                                                vs_a);\n                         self.try_assign(0, ty::AutoBorrowVec,\n                                         a, nr_b,"}, {"sha": "aa718cbe36c3d357db781eb9a2351f5d1dc3dcfb", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -50,17 +50,17 @@ impl Glb: Combine {\n           // the precise type from the mut side.\n           (m_mutbl, m_const) => {\n             Sub(*self).tys(a.ty, b.ty).chain(|_t| {\n-                Ok({ty: a.ty, mutbl: m_mutbl})\n+                Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n             })\n           }\n           (m_const, m_mutbl) => {\n             Sub(*self).tys(b.ty, a.ty).chain(|_t| {\n-                Ok({ty: b.ty, mutbl: m_mutbl})\n+                Ok(ty::mt {ty: b.ty, mutbl: m_mutbl})\n             })\n           }\n           (m_mutbl, m_mutbl) => {\n             eq_tys(&self, a.ty, b.ty).then(|| {\n-                Ok({ty: a.ty, mutbl: m_mutbl})\n+                Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n             })\n           }\n \n@@ -70,15 +70,15 @@ impl Glb: Combine {\n           (m_const, m_imm) |\n           (m_imm, m_imm) => {\n             self.tys(a.ty, b.ty).chain(|t| {\n-                Ok({ty: t, mutbl: m_imm})\n+                Ok(ty::mt {ty: t, mutbl: m_imm})\n             })\n           }\n \n           // If both sides are const, then we can use GLB of both\n           // sides and mutbl of only `m_const`.\n           (m_const, m_const) => {\n             self.tys(a.ty, b.ty).chain(|t| {\n-                Ok({ty: t, mutbl: m_const})\n+                Ok(ty::mt {ty: t, mutbl: m_const})\n             })\n           }\n "}, {"sha": "a6ae3cdb4fdbac1a35dadddef2167dd0fd90dc28", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -59,17 +59,17 @@ impl Lub: Combine {\n \n         match m {\n           m_imm | m_const => {\n-            self.tys(a.ty, b.ty).chain(|t| Ok({ty: t, mutbl: m}) )\n+            self.tys(a.ty, b.ty).chain(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n           }\n \n           m_mutbl => {\n             self.infcx.try(|| {\n                 eq_tys(&self, a.ty, b.ty).then(|| {\n-                    Ok({ty: a.ty, mutbl: m})\n+                    Ok(ty::mt {ty: a.ty, mutbl: m})\n                 })\n             }).chain_err(|_e| {\n                 self.tys(a.ty, b.ty).chain(|t| {\n-                    Ok({ty: t, mutbl: m_const})\n+                    Ok(ty::mt {ty: t, mutbl: m_const})\n                 })\n             })\n           }"}, {"sha": "6f2ffe00849717a5d90b971e8757b8bfd5c2dff5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -670,7 +670,11 @@ struct arm {\n \n #[auto_encode]\n #[auto_decode]\n-type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n+struct field_ {\n+    mutbl: mutability,\n+    ident: ident,\n+    expr: @expr,\n+}\n \n type field = spanned<field_>;\n \n@@ -762,12 +766,12 @@ enum expr_ {\n \n #[auto_encode]\n #[auto_decode]\n-type capture_item_ = {\n+struct capture_item_ {\n     id: int,\n     is_move: bool,\n     name: ident, // Currently, can only capture a local var.\n-    span: span\n-};\n+    span: span,\n+}\n \n type capture_item = @capture_item_;\n \n@@ -923,7 +927,10 @@ impl lit_: cmp::Eq {\n // type structure in middle/ty.rs as well.\n #[auto_encode]\n #[auto_decode]\n-type mt = {ty: @Ty, mutbl: mutability};\n+struct mt {\n+    ty: @Ty,\n+    mutbl: mutability,\n+}\n \n #[auto_encode]\n #[auto_decode]"}, {"sha": "e241f6435d3d468d214eec68a4c6edb068a27d62", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -571,7 +571,7 @@ fn mk_ser_method(\n                 id: cx.next_id(),\n                 node: ast::re_anon,\n             },\n-            {\n+            ast::mt {\n                 ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n                 mutbl: ast::m_imm\n             }\n@@ -634,7 +634,7 @@ fn mk_deser_method(\n                 id: cx.next_id(),\n                 node: ast::re_anon,\n             },\n-            {\n+            ast::mt {\n                 ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n                 mutbl: ast::m_imm\n             }\n@@ -908,7 +908,11 @@ fn mk_deser_fields(\n         );\n \n         ast::spanned {\n-            node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n+            node: ast::field_ {\n+                mutbl: field.mutbl,\n+                ident: field.ident,\n+                expr: expr,\n+            },\n             span: span,\n         }\n     }"}, {"sha": "cc4c58f3504ccef4875f025f8df790e94e4e2458", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -145,8 +145,10 @@ fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n }\n fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n     -> ast::field {\n-    ast::spanned { node: {mutbl: ast::m_imm, ident: f.ident, expr: f.ex},\n-                   span: sp }\n+    ast::spanned {\n+        node: ast::field_ { mutbl: ast::m_imm, ident: f.ident, expr: f.ex },\n+        span: sp,\n+    }\n }\n fn mk_fields(sp: span, fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n     ~[ast::field] {"}, {"sha": "83d968bb2ac2af35dd6273ac2811c5a54b364430", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -136,7 +136,10 @@ fn create_eq_method(cx: ext_ctxt,\n                                                      type_ident,\n                                                      ty_params);\n     let arg_region = @{ id: cx.next_id(), node: re_anon };\n-    let arg_type = ty_rptr(arg_region, { ty: arg_path_type, mutbl: m_imm });\n+    let arg_type = ty_rptr(\n+        arg_region,\n+        ast::mt { ty: arg_path_type, mutbl: m_imm }\n+    );\n     let arg_type = @{ id: cx.next_id(), node: move arg_type, span: span };\n \n     // Create the `other` parameter."}, {"sha": "19cbf833c0fae5d3c582a86a415a1ee6b0a4a28f", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -146,8 +146,10 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn field_imm(name: ident, e: @ast::expr) -> ast::field {\n-        spanned { node: { mutbl: ast::m_imm, ident: name, expr: e },\n-                  span: dummy_sp()}\n+        spanned {\n+            node: ast::field_ { mutbl: ast::m_imm, ident: name, expr: e },\n+            span: dummy_sp(),\n+        }\n     }\n \n     fn rec(+fields: ~[ast::field]) -> @ast::expr {\n@@ -158,8 +160,13 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn ty_field_imm(name: ident, ty: @ast::Ty) -> ast::ty_field {\n-        spanned { node: { ident: name, mt: { ty: ty, mutbl: ast::m_imm } },\n-                  span: dummy_sp() }\n+        spanned {\n+            node: {\n+                ident: name,\n+                mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n+            },\n+            span: dummy_sp(),\n+        }\n     }\n \n     fn ty_rec(+fields: ~[ast::ty_field]) -> @ast::Ty {"}, {"sha": "23915ea189bbe00df72bff823640edd12dfbe7af", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -412,10 +412,14 @@ fn wrap<T>(f: fn@(T, ast_fold) -> T)\n \n fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n     fn fold_field_(field: field, fld: ast_fold) -> field {\n-        spanned { node: { mutbl: field.node.mutbl,\n-                          ident: fld.fold_ident(field.node.ident),\n-                          expr: fld.fold_expr(field.node.expr)},\n-                  span: fld.new_span(field.span) }\n+        spanned {\n+            node: ast::field_ {\n+                mutbl: field.node.mutbl,\n+                ident: fld.fold_ident(field.node.ident),\n+                expr: fld.fold_expr(field.node.expr),\n+            },\n+            span: fld.new_span(field.span),\n+        }\n     }\n     let fold_field = |x| fold_field_(x, fld);\n \n@@ -472,17 +476,25 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n                      vec::map((*arms), |x| fld.fold_arm(*x)))\n           }\n           expr_fn(proto, decl, ref body, captures) => {\n+            let captures = do captures.map |cap_item| {\n+                @ast::capture_item_ {\n+                    id: fld.new_id(cap_item.id),\n+                    ..**cap_item\n+                }\n+            };\n             expr_fn(proto, fold_fn_decl(decl, fld),\n                     fld.fold_block((*body)),\n-                    @((*captures).map(|cap_item| {\n-                        @({id: fld.new_id(cap_item.id),\n-                           ..**cap_item})})))\n+                    @captures)\n           }\n           expr_fn_block(decl, ref body, captures) => {\n+            let captures = do captures.map |cap_item| {\n+                @ast::capture_item_ {\n+                    id: fld.new_id(cap_item.id),\n+                    ..**cap_item\n+                }\n+            };\n             expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block((*body)),\n-                          @((*captures).map(|cap_item| {\n-                              @({id: fld.new_id(cap_item.id),\n-                                 ..**cap_item})})))\n+                          @captures)\n           }\n           expr_block(ref blk) => expr_block(fld.fold_block((*blk))),\n           expr_copy(e) => expr_copy(fld.fold_expr(e)),\n@@ -526,7 +538,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n     fn fold_mt(mt: mt, fld: ast_fold) -> mt {\n-        {ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl}\n+        mt { ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl }\n     }\n     fn fold_field(f: ty_field, fld: ast_fold) -> ty_field {\n         spanned { node: { ident: fld.fold_ident(f.node.ident),"}, {"sha": "6fba59d6a84d245eae97daaba09c7092ec75c419", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293cd3480c10855de68503db36c6cc3ce8988b54/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=293cd3480c10855de68503db36c6cc3ce8988b54", "patch": "@@ -455,7 +455,7 @@ impl Parser {\n     fn parse_mt() -> mt {\n         let mutbl = self.parse_mutability();\n         let t = self.parse_ty(false);\n-        return {ty: t, mutbl: mutbl};\n+        mt { ty: t, mutbl: mutbl }\n     }\n \n     fn parse_ty_field() -> ty_field {\n@@ -464,9 +464,14 @@ impl Parser {\n         let id = self.parse_ident();\n         self.expect(token::COLON);\n         let ty = self.parse_ty(false);\n-        return spanned(lo, ty.span.hi, {\n-            ident: id, mt: {ty: ty, mutbl: mutbl}\n-        });\n+        spanned(\n+            lo,\n+            ty.span.hi,\n+            {\n+                ident: id,\n+                mt: ast::mt { ty: ty, mutbl: mutbl }\n+            }\n+        )\n     }\n \n     fn parse_ret_ty() -> (ret_style, @Ty) {\n@@ -673,7 +678,12 @@ impl Parser {\n         fn parse_capture_item(p:Parser, is_move: bool) -> capture_item {\n             let sp = mk_sp(p.span.lo, p.span.hi);\n             let ident = p.parse_ident();\n-            @{id: p.get_id(), is_move: is_move, name: ident, span: sp}\n+            @ast::capture_item_ {\n+                id: p.get_id(),\n+                is_move: is_move,\n+                name: ident,\n+                span: sp,\n+            }\n         }\n \n         if self.eat_keyword(~\"move\") {\n@@ -874,7 +884,7 @@ impl Parser {\n         let i = self.parse_ident();\n         self.expect(sep);\n         let e = self.parse_expr();\n-        return spanned(lo, e.span.hi, {mutbl: m, ident: i, expr: e});\n+        spanned(lo, e.span.hi, ast::field_ { mutbl: m, ident: i, expr: e })\n     }\n \n     fn mk_expr(+lo: BytePos, +hi: BytePos, +node: expr_) -> @expr {"}]}