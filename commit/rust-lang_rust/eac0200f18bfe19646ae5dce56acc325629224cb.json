{"sha": "eac0200f18bfe19646ae5dce56acc325629224cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhYzAyMDBmMThiZmUxOTY0NmFlNWRjZTU2YWNjMzI1NjI5MjI0Y2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-15T15:12:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-15T15:12:57Z"}, "message": "auto merge of #7148 : catamorphism/rust/rustpkg_tests, r=graydon\n\nr? @graydon Automate more tests described in the commands.txt file,\r\nand add infrastructure for running them. Right now, tests shell\r\nout to call rustpkg. This is not ideal.\r\n\r\nGoes part of the way towards addressing #5683", "tree": {"sha": "4040273c7652c538242aa033b4f1846515145de5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4040273c7652c538242aa033b4f1846515145de5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eac0200f18bfe19646ae5dce56acc325629224cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eac0200f18bfe19646ae5dce56acc325629224cb", "html_url": "https://github.com/rust-lang/rust/commit/eac0200f18bfe19646ae5dce56acc325629224cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eac0200f18bfe19646ae5dce56acc325629224cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82f2e4dc9f1078df868bca825315d35a589e5681", "url": "https://api.github.com/repos/rust-lang/rust/commits/82f2e4dc9f1078df868bca825315d35a589e5681", "html_url": "https://github.com/rust-lang/rust/commit/82f2e4dc9f1078df868bca825315d35a589e5681"}, {"sha": "e3c4104d746d87fc0f747005908c0b1ec209b3e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3c4104d746d87fc0f747005908c0b1ec209b3e4", "html_url": "https://github.com/rust-lang/rust/commit/e3c4104d746d87fc0f747005908c0b1ec209b3e4"}], "stats": {"total": 679, "additions": 559, "deletions": 120}, "files": [{"sha": "7f54e265b7baf3df5ea8e1597524f5301f513056", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -441,5 +441,6 @@ pub fn collect_language_items(crate: @crate,\n     let mut collector = LanguageItemCollector(crate, session);\n     collector.collect();\n     let LanguageItemCollector { items, _ } = collector;\n+    session.abort_if_errors();\n     items\n }"}, {"sha": "d3962470e7c84cf6b91e1eba8667c9af317aaacb", "filename": "src/librustpkg/messages.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fmessages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fmessages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fmessages.rs?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use extra::term;\n+use core::io;\n+use core::result::*;\n+\n+pub fn note(msg: &str) {\n+    pretty_message(msg, \"note: \", term::color_green, io::stdout())\n+}\n+\n+pub fn warn(msg: &str) {\n+    pretty_message(msg, \"warning: \", term::color_yellow, io::stdout())\n+}\n+\n+pub fn error(msg: &str) {\n+    pretty_message(msg, \"error: \", term::color_red, io::stdout())\n+}\n+\n+fn pretty_message<'a>(msg: &'a str, prefix: &'a str, color: u8, out: @io::Writer) {\n+    let term = term::Terminal::new(out);\n+    match term {\n+        Ok(ref t) => {\n+            t.fg(color);\n+            out.write_str(prefix);\n+            t.reset();\n+        },\n+        _ => {\n+            out.write_str(prefix);\n+        }\n+    }\n+    out.write_line(msg);\n+}"}, {"sha": "3ff0a6073b6d7facfdf0fe70328effee58189efc", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -69,6 +69,7 @@ impl PkgId {\n             }\n         };\n \n+        debug!(\"local_path = %s, remote_path = %s\", local_path.to_str(), remote_path.to_str());\n         PkgId {\n             local_path: local_path,\n             remote_path: remote_path,\n@@ -90,11 +91,7 @@ impl PkgId {\n \n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n-        let maybe_dash = match self.version {\n-            NoVersion => \"\",\n-            _         => \"-\"\n-        };\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s%s%s\", self.local_path.to_str(), maybe_dash, self.version.to_str())\n+        fmt!(\"%s-%s\", self.local_path.to_str(), self.version.to_str())\n     }\n }"}, {"sha": "01cc48fc037b99f02b1282a45f9166e1e12d7aa2", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -15,8 +15,9 @@ use core::option::*;\n use core::{os, run, str, vec};\n use context::*;\n use crate::Crate;\n+use messages::*;\n use path_util::pkgid_src_in_workspace;\n-use util::{compile_crate, note};\n+use util::compile_crate;\n use version::{ExactRevision, SemanticVersion, NoVersion};\n \n // An enumeration of the unpacked source of a package workspace.\n@@ -95,7 +96,7 @@ impl PkgSrc {\n         };\n \n \n-        note(fmt!(\"git clone %s %s %?\", url, local.to_str(), branch_args));\n+        note(fmt!(\"Fetching package: git clone %s %s %?\", url, local.to_str(), branch_args));\n \n         if run::process_output(\"git\",\n                                ~[~\"clone\", copy url, local.to_str()] + branch_args).status != 0 {"}, {"sha": "e68f48c81629b380a42220a8298bc11e136c4ca4", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 67, "deletions": 22, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -11,12 +11,16 @@\n // rustpkg utilities having to do with paths and directories\n \n use core::prelude::*;\n-pub use package_path::{RemotePath, LocalPath};\n+pub use package_path::{RemotePath, LocalPath, normalize};\n pub use package_id::PkgId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n+pub use version::{Version, NoVersion, split_version_general};\n use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use core::os::mkdir_recursive;\n use core::os;\n+use core::iterator::IteratorUtil;\n+use messages::*;\n+use package_id::*;\n \n /// Returns the value of RUST_PATH, as a list\n /// of Paths. In general this should be read from the\n@@ -38,8 +42,39 @@ pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, u_rwx) }\n /// True if there's a directory in <workspace> with\n /// pkgid's short name\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n-    let pkgpath = workspace.push(\"src\").push(pkgid.remote_path.to_str());\n-    os::path_is_dir(&pkgpath)\n+    let src_dir = workspace.push(\"src\");\n+    for os::list_dir(&src_dir).each |&p| {\n+        let p = Path(p);\n+        debug!(\"=> p = %s\", p.to_str());\n+        if !os::path_is_dir(&src_dir.push_rel(&p)) {\n+            loop;\n+        }\n+        debug!(\"p = %s, remote_path = %s\", p.to_str(), pkgid.remote_path.to_str());\n+\n+        if p == *pkgid.remote_path {\n+            return true;\n+        }\n+        else {\n+            let pf = p.filename();\n+            for pf.iter().advance |&pf| {\n+                let f_ = copy pf;\n+                let g = f_.to_str();\n+                match split_version_general(g, '-') {\n+                    Some((ref might_match, ref vers)) => {\n+                        debug!(\"might_match = %s, vers = %s\", *might_match,\n+                               vers.to_str());\n+                        if *might_match == pkgid.short_name\n+                            && (*vers == pkgid.version || pkgid.version == NoVersion)\n+                        {\n+                            return true;\n+                        }\n+                    }\n+                    None => ()\n+                }\n+            }\n+        }\n+    }\n+    false\n }\n \n /// Returns a list of possible directories\n@@ -114,31 +149,34 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n /// Figure out what the library name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-                        // passing in local_path here sounds fishy\n-    library_in_workspace(pkgid.local_path.to_str(), pkgid.short_name, Build,\n-                         workspace, \"build\")\n+    library_in_workspace(&pkgid.local_path, pkgid.short_name,\n+                         Build, workspace, \"build\")\n }\n \n /// Does the actual searching stuff\n pub fn installed_library_in_workspace(short_name: &str, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(short_name, short_name, Install, workspace, \"lib\")\n+    library_in_workspace(&normalize(RemotePath(Path(short_name))),\n+                         short_name, Install, workspace, \"lib\")\n }\n \n \n /// This doesn't take a PkgId, so we can use it for `extern mod` inference, where we\n /// don't know the entire package ID.\n-/// `full_name` is used to figure out the directory to search.\n+/// `workspace` is used to figure out the directory to search.\n /// `short_name` is taken as the link name of the library.\n-fn library_in_workspace(full_name: &str, short_name: &str, where: Target,\n+pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n                         workspace: &Path, prefix: &str) -> Option<Path> {\n     debug!(\"library_in_workspace: checking whether a library named %s exists\",\n            short_name);\n \n     // We don't know what the hash is, so we have to search through the directory\n     // contents\n \n+    debug!(\"short_name = %s where = %? workspace = %s \\\n+            prefix = %s\", short_name, where, workspace.to_str(), prefix);\n+\n     let dir_to_search = match where {\n-        Build => workspace.push(prefix).push(full_name),\n+        Build => workspace.push(prefix).push_rel(&**path),\n         Install => workspace.push(prefix)\n     };\n     debug!(\"Listing directory %s\", dir_to_search.to_str());\n@@ -193,7 +231,11 @@ fn library_in_workspace(full_name: &str, short_name: &str, where: Target,\n     // Return the filename that matches, which we now know exists\n     // (if result_filename != None)\n     match result_filename {\n-        None => None,\n+        None => {\n+            warn(fmt!(\"library_in_workspace didn't find a library in %s for %s\",\n+                            dir_to_search.to_str(), short_name));\n+            None\n+        }\n         Some(result_filename) => {\n             let absolute_path = dir_to_search.push_rel(&result_filename);\n             debug!(\"result_filename = %s\", absolute_path.to_str());\n@@ -210,17 +252,17 @@ pub fn target_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n }\n \n \n-/// Returns the installed path for <built_library> in <workspace>\n+/// Returns the executable that would be installed for <pkgid>\n+/// in <workspace>\n /// As a side effect, creates the lib-dir if it doesn't exist\n-pub fn target_library_in_workspace(workspace: &Path,\n-                                   built_library: &Path) -> Path {\n+pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n-    let result = workspace.push(\"lib\");\n-    if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n-        cond.raise((copy result, ~\"I couldn't create the library directory\"));\n+    if !os::path_is_dir(workspace) {\n+        cond.raise((copy *workspace,\n+                    fmt!(\"Workspace supplied to target_library_in_workspace \\\n+                          is not a directory! %s\", workspace.to_str())));\n     }\n-    result.push(built_library.filename().expect(fmt!(\"I don't know how to treat %s as a library\",\n-                                                   built_library.to_str())))\n+    target_file_in_workspace(pkgid, workspace, Lib, Install)\n }\n \n /// Returns the test executable that would be installed for <pkgid>\n@@ -249,7 +291,9 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     };\n     let result = workspace.push(subdir);\n     if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n-        cond.raise((copy result, fmt!(\"I couldn't create the %s dir\", subdir)));\n+        cond.raise((copy result, fmt!(\"target_file_in_workspace couldn't \\\n+            create the %s dir (pkgid=%s, workspace=%s, what=%?, where=%?\",\n+            subdir, pkgid.to_str(), workspace.to_str(), what, where)));\n     }\n     mk_output_path(what, where, pkgid, &result)\n }\n@@ -275,7 +319,8 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n /// given whether we're building a library and whether we're building tests\n pub fn mk_output_path(what: OutputType, where: Target,\n                       pkg_id: &PkgId, workspace: &Path) -> Path {\n-    let short_name_with_version = pkg_id.short_name_with_version();\n+    let short_name_with_version = fmt!(\"%s-%s\", pkg_id.short_name,\n+                                       pkg_id.version.to_str());\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n     // the executable blat-0.5 to live under blat/\n     let dir = match where {\n@@ -291,7 +336,7 @@ pub fn mk_output_path(what: OutputType, where: Target,\n         // this code is duplicated from elsewhere; fix this\n         Lib => dir.push(os::dll_filename(short_name_with_version)),\n         // executable names *aren't* versioned\n-        _ => dir.push(fmt!(\"%s%s%s\", copy pkg_id.short_name,\n+        _ => dir.push(fmt!(\"%s%s%s\", pkg_id.short_name,\n                            match what {\n                                Test => \"test\",\n                                Bench => \"bench\","}, {"sha": "9242e450e24991e4b4254dd19c9c0fb56c4754fb", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -36,18 +36,20 @@ use rustc::metadata::filesearch;\n use extra::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n+use messages::*;\n use path_util::{build_pkg_id_in_workspace, first_pkgid_src_in_workspace};\n-use path_util::u_rwx;\n+use path_util::{u_rwx, rust_path};\n use path_util::{built_executable_in_workspace, built_library_in_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n-use workspace::pkg_parent_workspaces;\n+use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces};\n use context::Ctx;\n use package_id::PkgId;\n use package_source::PkgSrc;\n \n mod conditions;\n mod context;\n mod crate;\n+mod messages;\n mod package_id;\n mod package_path;\n mod package_source;\n@@ -189,7 +191,7 @@ impl Ctx {\n                 // The package id is presumed to be the first command-line\n                 // argument\n                 let pkgid = PkgId::new(copy args[0]);\n-                for pkg_parent_workspaces(&pkgid) |workspace| {\n+                for each_pkg_parent_workspace(&pkgid) |workspace| {\n                     self.build(workspace, &pkgid);\n                 }\n             }\n@@ -221,8 +223,19 @@ impl Ctx {\n                 // The package id is presumed to be the first command-line\n                 // argument\n                 let pkgid = PkgId::new(args[0]);\n-                for pkg_parent_workspaces(&pkgid) |workspace| {\n-                    self.install(workspace, &pkgid);\n+                let workspaces = pkg_parent_workspaces(&pkgid);\n+                if workspaces.is_empty() {\n+                    let rp = rust_path();\n+                    assert!(!rp.is_empty());\n+                    let src = PkgSrc::new(&rp[0], &build_pkg_id_in_workspace(&pkgid, &rp[0]),\n+                                          &pkgid);\n+                    src.fetch_git();\n+                    self.install(&rp[0], &pkgid);\n+                }\n+                else {\n+                    for each_pkg_parent_workspace(&pkgid) |workspace| {\n+                        self.install(workspace, &pkgid);\n+                    }\n                 }\n             }\n             \"prefer\" => {\n@@ -259,6 +272,8 @@ impl Ctx {\n     }\n \n     fn build(&self, workspace: &Path, pkgid: &PkgId) {\n+        debug!(\"build: workspace = %s pkgid = %s\", workspace.to_str(),\n+               pkgid.to_str());\n         let src_dir   = first_pkgid_src_in_workspace(pkgid, workspace);\n         let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n         debug!(\"Destination dir = %s\", build_dir.to_str());\n@@ -310,14 +325,14 @@ impl Ctx {\n         // Do something reasonable for now\n \n         let dir = build_pkg_id_in_workspace(id, workspace);\n-        util::note(fmt!(\"Cleaning package %s (removing directory %s)\",\n+        note(fmt!(\"Cleaning package %s (removing directory %s)\",\n                         id.to_str(), dir.to_str()));\n         if os::path_exists(&dir) {\n             os::remove_dir_recursive(&dir);\n-            util::note(fmt!(\"Removed directory %s\", dir.to_str()));\n+            note(fmt!(\"Removed directory %s\", dir.to_str()));\n         }\n \n-        util::note(fmt!(\"Cleaned package %s\", id.to_str()));\n+        note(fmt!(\"Cleaned package %s\", id.to_str()));\n     }\n \n     fn info(&self) {\n@@ -338,7 +353,7 @@ impl Ctx {\n         let maybe_executable = built_executable_in_workspace(id, workspace);\n         let maybe_library = built_library_in_workspace(id, workspace);\n         let target_exec = target_executable_in_workspace(id, workspace);\n-        let target_lib = maybe_library.map(|p| target_library_in_workspace(workspace, p));\n+        let target_lib = maybe_library.map(|_p| target_library_in_workspace(id, workspace));\n \n         debug!(\"target_exec = %s target_lib = %? \\\n                 maybe_executable = %? maybe_library = %?\",\n@@ -392,7 +407,7 @@ pub fn main() {\n     let matches = &match getopts::getopts(args, opts) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n-            util::error(fmt!(\"%s\", getopts::fail_str(f)));\n+            error(fmt!(\"%s\", getopts::fail_str(f)));\n \n             return;\n         }\n@@ -428,8 +443,12 @@ pub fn main() {\n         };\n     }\n \n+    let sroot = match filesearch::get_rustpkg_sysroot() {\n+        Ok(r) => Some(@r.pop().pop()), Err(_) => None\n+    };\n+    debug!(\"Using sysroot: %?\", sroot);\n     Ctx {\n-        sysroot_opt: None, // Currently, only tests override this\n+        sysroot_opt: sroot, // Currently, only tests override this\n         json: json,\n         dep_cache: @mut HashMap::new()\n     }.run(cmd, args);"}, {"sha": "e5ffc5c9d84877e3959832865f7833b4ff88d163", "filename": "src/librustpkg/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -22,4 +22,4 @@ pub fn find_library_in_search_path(sroot_opt: Option<@Path>, short_name: &str) -\n         }\n         None => None\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "6ec14e2aecf62ccd8cdf9a913fe3db90f340b61a", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 375, "deletions": 17, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -12,21 +12,26 @@\n \n use context::Ctx;\n use core::hashmap::HashMap;\n-use core::io;\n-use core::os;\n+use core::{io, libc, os, result, run, str};\n use core::prelude::*;\n-use core::result;\n use extra::tempfile::mkdtemp;\n+use core::run::ProcessOutput;\n use package_path::*;\n-use package_id::PkgId;\n+use package_id::{PkgId};\n use package_source::*;\n use version::{ExactRevision, NoVersion, Version};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n-               make_dir_rwx, u_rwx,\n+               make_dir_rwx, u_rwx, library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n                built_library_in_workspace, built_executable_in_workspace,\n                 installed_library_in_workspace};\n+use target::*;\n+\n+/// Returns the last-modified date as an Option\n+fn datestamp(p: &Path) -> Option<libc::time_t> {\n+    p.stat().map(|stat| stat.st_mtime)\n+}\n \n fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n     Ctx {\n@@ -65,23 +70,34 @@ fn writeFile(file_path: &Path, contents: &str) {\n }\n \n fn mk_empty_workspace(short_name: &LocalPath, version: &Version) -> Path {\n-    let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n+    let workspace_dir = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n+    mk_workspace(&workspace_dir, short_name, version);\n+    workspace_dir\n+}\n+\n+fn mk_workspace(workspace: &Path, short_name: &LocalPath, version: &Version) -> Path {\n     // include version number in directory name\n-    let package_dir = workspace.push(\"src\").push(fmt!(\"%s%s\",\n+    let package_dir = workspace.push(\"src\").push(fmt!(\"%s-%s\",\n                                                       short_name.to_str(), version.to_str()));\n     assert!(os::mkdir_recursive(&package_dir, u_rwx));\n-    package_dir.pop().pop()\n+    package_dir\n }\n \n fn mk_temp_workspace(short_name: &LocalPath, version: &Version) -> Path {\n     let package_dir = mk_empty_workspace(short_name,\n-                                         version).push(\"src\").push(fmt!(\"%s%s\",\n+                                         version).push(\"src\").push(fmt!(\"%s-%s\",\n                                                             short_name.to_str(),\n                                                             version.to_str()));\n \n     debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n+    debug!(\"mk_workspace: creating %s\", package_dir.to_str());\n+    assert!(os::mkdir_recursive(&package_dir, u_rwx));\n+    debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n+          os::path_is_dir(&package_dir));\n+    // Create main, lib, test, and bench files\n+\n     writeFile(&package_dir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&package_dir.push(\"lib.rs\"),\n@@ -90,7 +106,7 @@ fn mk_temp_workspace(short_name: &LocalPath, version: &Version) -> Path {\n               \"#[test] pub fn f() { (); }\");\n     writeFile(&package_dir.push(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n-    package_dir.pop().pop()\n+    package_dir\n }\n \n fn is_rwx(p: &Path) -> bool {\n@@ -113,6 +129,186 @@ fn test_sysroot() -> Path {\n     self_path.pop()\n }\n \n+/// Runs `rustpkg` (based on the directory that this executable was\n+/// invoked from) with the given arguments, in the given working directory.\n+/// Returns the process's output.\n+fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n+    let cmd = test_sysroot().push(\"bin\").push(\"rustpkg\").to_str();\n+    let cwd = normalize(RemotePath(copy *cwd));\n+    debug!(\"About to run command: %? %? in %s\", cmd, args, cwd.to_str());\n+    assert!(os::path_is_dir(&*cwd));\n+    let mut prog = run::Process::new(cmd, args, run::ProcessOptions { env: None,\n+                                                           dir: Some(&*cwd),\n+                                                           in_fd: None,\n+                                                           out_fd: None,\n+                                                           err_fd: None\n+                                                          });\n+    let output = prog.finish_with_output();\n+    io::println(fmt!(\"Output from command %s with args %? was %s {%s}[%?]\",\n+                    cmd, args, str::from_bytes(output.output),\n+                   str::from_bytes(output.error),\n+                   output.status));\n+/*\n+By the way, rustpkg *won't* return a nonzero exit code if it fails --\n+see #4547\n+So tests that use this need to check the existence of a file\n+to make sure the command succeeded\n+*/\n+    if output.status != 0 {\n+        fail!(\"Command %s %? failed with exit code %?\",\n+              cmd, args, output.status);\n+    }\n+    output\n+}\n+\n+fn make_git_repo(short_name: &str) -> Path {\n+    let temp_d = mk_temp_workspace(&normalize(RemotePath(Path(short_name))), &NoVersion);\n+    debug!(\"Dry run: would initialize %s as a git repository\", temp_d.pop().pop().to_str());\n+    temp_d.pop().pop()\n+}\n+\n+fn add_git_tag(repo: &Path, tag: &str) {\n+    debug!(\"Dry run: would add tag %s to repo %s\", tag, repo.to_str());\n+}\n+\n+fn create_local_package(pkgid: &PkgId) -> Path {\n+    let parent_dir = mk_temp_workspace(&pkgid.local_path, &pkgid.version);\n+    debug!(\"Created empty package dir for %s, returning %s\", pkgid.to_str(), parent_dir.to_str());\n+    parent_dir.pop().pop()\n+}\n+\n+fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n+\n+    let package_dir = pkgdir.push(\"src\").push(pkgid.to_str());\n+\n+    // Create main, lib, test, and bench files\n+    assert!(os::mkdir_recursive(&package_dir, u_rwx));\n+    debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n+          os::path_is_dir(&package_dir));\n+    // Create main, lib, test, and bench files\n+\n+    writeFile(&package_dir.push(\"main.rs\"),\n+              \"fn main() { let _x = (); }\");\n+    writeFile(&package_dir.push(\"lib.rs\"),\n+              \"pub fn f() { let _x = (); }\");\n+    writeFile(&package_dir.push(\"test.rs\"),\n+              \"#[test] pub fn f() { (); }\");\n+    writeFile(&package_dir.push(\"bench.rs\"),\n+              \"#[bench] pub fn f() { (); }\");\n+    package_dir\n+}\n+\n+fn create_local_package_with_test(pkgid: &PkgId) -> Path {\n+    debug!(\"Dry run -- would create package %s with test\");\n+    create_local_package(pkgid) // Already has tests???\n+}\n+\n+fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> Path {\n+    let package_dir = create_local_package(pkgid);\n+    create_local_package_in(subord_pkgid, &package_dir);\n+    // Write a main.rs file into pkgid that references subord_pkgid\n+    writeFile(&package_dir.push(\"src\").push(pkgid.to_str()).push(\"main.rs\"),\n+              fmt!(\"extern mod %s;\\nfn main() {}\",\n+                   subord_pkgid.short_name));\n+    // Write a lib.rs file into subord_pkgid that has something in it\n+    writeFile(&package_dir.push(\"src\").push(subord_pkgid.to_str()).push(\"lib.rs\"),\n+              \"pub fn f() {}\");\n+    debug!(\"Dry run -- would create packages %s and %s in %s\",\n+           pkgid.to_str(),\n+           subord_pkgid.to_str(),\n+           package_dir.to_str());\n+    package_dir\n+}\n+\n+fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n+                                               custom_build_hook: &str) -> Path {\n+    debug!(\"Dry run -- would create package %s with custom build hook %s\",\n+           pkgid.to_str(), custom_build_hook);\n+    create_local_package(pkgid)\n+    // actually write the pkg.rs with the custom build hook\n+\n+}\n+\n+fn assert_lib_exists(repo: &Path, short_name: &str) {\n+    debug!(\"assert_lib_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    let lib = target_library_in_workspace(&PkgId::new(short_name), repo);\n+    assert!(os::path_exists(&lib));\n+    assert!(is_rwx(&lib));\n+}\n+\n+fn assert_executable_exists(repo: &Path, short_name: &str) {\n+    debug!(\"assert_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n+    assert!(os::path_exists(&exec));\n+    assert!(is_rwx(&exec));\n+}\n+\n+fn command_line_test_output(args: &[~str]) -> ~[~str] {\n+    let mut result = ~[];\n+    let p_output = command_line_test(args, &os::getcwd());\n+    let test_output = str::from_bytes(p_output.output);\n+    for test_output.split_iter('\\n').advance |s| {\n+        result += [s.to_owned()];\n+    }\n+    result\n+}\n+\n+// assumes short_name and local_path are one and the same -- I should fix\n+fn lib_output_file_name(workspace: &Path, parent: &str, short_name: &str) -> Path {\n+    debug!(\"lib_output_file_name: given %s and parent %s and short name %s\",\n+           workspace.to_str(), parent, short_name);\n+    library_in_workspace(&normalize(RemotePath(Path(short_name))),\n+                         short_name,\n+                         Build,\n+                         workspace,\n+                         \"build\").expect(\"lib_output_file_name\")\n+}\n+\n+fn output_file_name(workspace: &Path, short_name: &str) -> Path {\n+    workspace.push(fmt!(\"%s%s\", short_name, os::EXE_SUFFIX))\n+}\n+\n+fn touch_source_file(workspace: &Path, short_name: &str) {\n+    use conditions::bad_path::cond;\n+    let pkg_src_dir = workspace.push(\"src\").push(short_name);\n+    let contents = os::list_dir(&pkg_src_dir);\n+    for contents.each() |p| {\n+        if Path(copy *p).filetype() == Some(~\".rs\") {\n+            // should be able to do this w/o a process\n+            if run::process_output(\"touch\", [p.to_str()]).status != 0 {\n+                let _ = cond.raise((copy pkg_src_dir, ~\"Bad path\"));\n+            }\n+            break;\n+        }\n+    }\n+}\n+\n+/// Add a blank line at the end\n+fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n+    use conditions::bad_path::cond;\n+    let pkg_src_dir = workspace.push(\"src\").push(pkgid.to_str());\n+    let contents = os::list_dir(&pkg_src_dir);\n+    let mut maybe_p = None;\n+    for contents.each() |p| {\n+        if Path(copy *p).filetype() == Some(~\".rs\") {\n+            maybe_p = Some(p);\n+            break;\n+        }\n+    }\n+    match maybe_p {\n+        Some(p) => {\n+            let p = Path(copy *p);\n+            let w = io::buffered_file_writer(&p);\n+            match w {\n+                Err(s) => { let _ = cond.raise((p, fmt!(\"Bad path: %s\", s))); }\n+                Ok(w)  => w.write_line(\"\")\n+            }\n+        }\n+        None => fail!(fmt!(\"frob_source_file failed to find a source file in %s\",\n+                           pkg_src_dir.to_str()))\n+    }\n+}\n+\n #[test]\n fn test_all() {\n     // FIXME(#7071): these tests use rustc, so they can't be run in parallel\n@@ -144,7 +340,8 @@ fn test_install_valid() {\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = fake_pkg();\n-    let temp_workspace = mk_temp_workspace(&temp_pkg_id.local_path, &NoVersion);\n+    let temp_workspace = mk_temp_workspace(&temp_pkg_id.local_path, &NoVersion).pop().pop();\n+    debug!(\"temp_workspace = %s\", temp_workspace.to_str());\n     // should have test, bench, lib, and main\n     ctxt.install(&temp_workspace, &temp_pkg_id);\n     // Check that all files exist\n@@ -200,10 +397,10 @@ fn test_install_url() {\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n-    let built_lib =\n+    let _built_lib =\n         built_library_in_workspace(&temp_pkg_id,\n                                    &workspace).expect(\"test_install_url: built lib should exist\");\n-    let lib = target_library_in_workspace(&workspace, &built_lib);\n+    let lib = target_library_in_workspace(&temp_pkg_id, &workspace);\n     debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n@@ -238,8 +435,8 @@ fn test_package_ids_must_be_relative_path_like() {\n \n     let whatever = PkgId::new(\"foo\");\n \n-    assert_eq!(~\"foo\", whatever.to_str());\n-    assert!(\"github.com/catamorphism/test_pkg\" ==\n+    assert_eq!(~\"foo-0.1\", whatever.to_str());\n+    assert!(\"github.com/catamorphism/test_pkg-0.1\" ==\n             PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n     do cond.trap(|(p, e)| {\n@@ -248,7 +445,7 @@ fn test_package_ids_must_be_relative_path_like() {\n         copy whatever\n     }).in {\n         let x = PkgId::new(\"\");\n-        assert_eq!(~\"foo\", x.to_str());\n+        assert_eq!(~\"foo-0.1\", x.to_str());\n     }\n \n     do cond.trap(|(p, e)| {\n@@ -257,7 +454,7 @@ fn test_package_ids_must_be_relative_path_like() {\n         copy whatever\n     }).in {\n         let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n-        assert_eq!(~\"foo\", z.to_str());\n+        assert_eq!(~\"foo-0.1\", z.to_str());\n     }\n \n }\n@@ -323,3 +520,164 @@ fn test_package_request_version() {\n             == temp.push(\"bin\").push(\"test_pkg_version\"));\n \n }\n+\n+// Tests above should (maybe) be converted to shell out to rustpkg, too\n+\n+#[test]\n+#[ignore (reason = \"http-client not ported to rustpkg yet\")]\n+fn rustpkg_install_url_2() {\n+    let temp_dir = mkdtemp(&os::tmpdir(), \"rustpkg_install_url_2\").expect(\"rustpkg_install_url_2\");\n+    command_line_test([~\"install\", ~\"github.com/mozilla-servo/rust-http-client\"],\n+                     &temp_dir);\n+}\n+\n+#[test]\n+fn rustpkg_library_target() {\n+    let foo_repo = make_git_repo(\"foo\");\n+    add_git_tag(&foo_repo, \"1.0\");\n+    command_line_test([~\"install\", ~\"foo\"], &foo_repo);\n+    assert_lib_exists(&foo_repo, \"foo\");\n+}\n+\n+#[test]\n+fn rustpkg_local_pkg() {\n+    let dir = create_local_package(&PkgId::new(\"foo\"));\n+    command_line_test([~\"install\", ~\"foo\"], &dir);\n+    assert_executable_exists(&dir, \"foo\");\n+}\n+\n+#[test]\n+#[ignore (reason = \"RUST_PATH not yet implemented -- #5682\")]\n+fn rust_path_test() {\n+    let dir = mk_workspace(&Path(\"/home/more_rust\"),\n+                           &normalize(RemotePath(Path(\"foo\"))),\n+                           &NoVersion);\n+  //  command_line_test(\"RUST_PATH=/home/rust:/home/more_rust rustpkg install foo\");\n+    command_line_test([~\"install\", ~\"foo\"], &dir);\n+}\n+\n+#[test]\n+#[ignore(reason = \"Package database not yet implemented\")]\n+fn install_remove() {\n+    let foo = PkgId::new(\"foo\");\n+    let bar = PkgId::new(\"bar\");\n+    let quux = PkgId::new(\"quux\");\n+    let dir = mkdtemp(&os::tmpdir(), \"install_remove\").expect(\"install_remove\");\n+    create_local_package_in(&foo, &dir);\n+    create_local_package_in(&bar, &dir);\n+    create_local_package_in(&quux, &dir);\n+    command_line_test([~\"install\", ~\"foo\"], &dir);\n+    command_line_test([~\"install\", ~\"bar\"], &dir);\n+    command_line_test([~\"install\", ~\"quux\"], &dir);\n+    let list_output = command_line_test_output([~\"list\"]);\n+    assert!(list_output.contains(&~\"foo\"));\n+    assert!(list_output.contains(&~\"bar\"));\n+    assert!(list_output.contains(&~\"quux\"));\n+    command_line_test([~\"remove\", ~\"foo\"], &dir);\n+    let list_output = command_line_test_output([~\"list\"]);\n+    assert!(!list_output.contains(&~\"foo\"));\n+    assert!(list_output.contains(&~\"bar\"));\n+    assert!(list_output.contains(&~\"quux\"));\n+}\n+\n+#[test]\n+#[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n+fn no_rebuilding() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    let date = datestamp(&built_library_in_workspace(&p_id,\n+                                                    &workspace).expect(\"no_rebuilding\"));\n+    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    let newdate = datestamp(&built_library_in_workspace(&p_id,\n+                                                       &workspace).expect(\"no_rebuilding (2)\"));\n+    assert_eq!(date, newdate);\n+}\n+\n+#[test]\n+#[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n+fn no_rebuilding_dep() {\n+    let p_id = PkgId::new(\"foo\");\n+    let dep_id = PkgId::new(\"bar\");\n+    let workspace = create_local_package_with_dep(&p_id, &dep_id);\n+    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    let bar_date = datestamp(&lib_output_file_name(&workspace,\n+                                                  \".rust\",\n+                                                  \"bar\"));\n+    let foo_date = datestamp(&output_file_name(&workspace, \"foo\"));\n+    assert!(bar_date < foo_date);\n+}\n+\n+#[test]\n+fn do_rebuild_dep_dates_change() {\n+    let p_id = PkgId::new(\"foo\");\n+    let dep_id = PkgId::new(\"bar\");\n+    let workspace = create_local_package_with_dep(&p_id, &dep_id);\n+    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n+    touch_source_file(&workspace, \"bar\");\n+    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    let new_bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n+    assert!(new_bar_date > bar_date);\n+}\n+\n+#[test]\n+fn do_rebuild_dep_only_contents_change() {\n+    let p_id = PkgId::new(\"foo\");\n+    let dep_id = PkgId::new(\"bar\");\n+    let workspace = create_local_package_with_dep(&p_id, &dep_id);\n+    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n+    frob_source_file(&workspace, &dep_id);\n+    // should adjust the datestamp\n+    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    let new_bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n+    assert!(new_bar_date > bar_date);\n+}\n+\n+#[test]\n+#[ignore(reason = \"list not yet implemented\")]\n+fn test_versions() {\n+    let workspace = create_local_package(&PkgId::new(\"foo#0.1\"));\n+    create_local_package(&PkgId::new(\"foo#0.2\"));\n+    command_line_test([~\"install\", ~\"foo#0.1\"], &workspace);\n+    let output = command_line_test_output([~\"list\"]);\n+    // make sure output includes versions\n+    assert!(!output.contains(&~\"foo#0.2\"));\n+}\n+\n+#[test]\n+#[ignore(reason = \"do not yet implemented\")]\n+fn test_build_hooks() {\n+    let workspace = create_local_package_with_custom_build_hook(&PkgId::new(\"foo\"), \"frob\");\n+    command_line_test([~\"do\", ~\"foo\", ~\"frob\"], &workspace);\n+}\n+\n+\n+#[test]\n+#[ignore(reason = \"info not yet implemented\")]\n+fn test_info() {\n+    let expected_info = ~\"package foo\"; // fill in\n+    let workspace = create_local_package(&PkgId::new(\"foo\"));\n+    let output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n+    assert_eq!(str::from_bytes(output.output), expected_info);\n+}\n+\n+#[test]\n+#[ignore(reason = \"test not yet implemented\")]\n+fn test_rustpkg_test() {\n+    let expected_results = ~\"1 out of 1 tests passed\"; // fill in\n+    let workspace = create_local_package_with_test(&PkgId::new(\"foo\"));\n+    let output = command_line_test([~\"test\", ~\"foo\"], &workspace);\n+    assert_eq!(str::from_bytes(output.output), expected_results);\n+}\n+\n+#[test]\n+#[ignore(reason = \"uninstall not yet implemented\")]\n+fn test_uninstall() {\n+    let workspace = create_local_package(&PkgId::new(\"foo\"));\n+    let _output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n+    command_line_test([~\"uninstall\", ~\"foo\"], &workspace);\n+    let output = command_line_test([~\"list\"], &workspace);\n+    assert!(!str::from_bytes(output.output).contains(\"foo\"));\n+}"}, {"sha": "60fe7d52321ae89845a28687a8439bbe8c844398", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 15, "deletions": 41, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use core::prelude::*;\n-use core::{io, libc, os, result, str};\n+use core::{libc, os, result, str};\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use extra::getopts::groups::getopts;\n-use extra::term;\n use syntax::ast_util::*;\n use syntax::codemap::{dummy_sp, spanned};\n use syntax::codemap::dummy_spanned;\n@@ -26,8 +25,8 @@ use rustc::driver::driver::compile_upto;\n use rustc::driver::session::{lib_crate, bin_crate};\n use context::Ctx;\n use package_id::PkgId;\n-use path_util::{target_library_in_workspace, built_library_in_workspace};\n use search::find_library_in_search_path;\n+use path_util::target_library_in_workspace;\n pub use target::{OutputType, Main, Lib, Bench, Test};\n \n static Commands: &'static [&'static str] =\n@@ -160,33 +159,6 @@ pub fn need_dir(s: &Path) {\n     }\n }\n \n-fn pretty_message<'a>(msg: &'a str, prefix: &'a str, color: u8, out: @io::Writer) {\n-    let term = term::Terminal::new(out);\n-    match term {\n-        Ok(ref t) => {\n-            t.fg(color);\n-            out.write_str(prefix);\n-            t.reset();\n-        },\n-        _ => {\n-            out.write_str(prefix);\n-        }\n-    }\n-    out.write_line(msg);\n-}\n-\n-pub fn note(msg: &str) {\n-    pretty_message(msg, \"note: \", term::color_green, io::stdout())\n-}\n-\n-pub fn warn(msg: &str) {\n-    pretty_message(msg, \"warning: \", term::color_yellow, io::stdout())\n-}\n-\n-pub fn error(msg: &str) {\n-    pretty_message(msg, \"error: \", term::color_red, io::stdout())\n-}\n-\n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_input(ctxt: &Ctx,\n                      pkg_id: &PkgId,\n@@ -230,13 +202,18 @@ pub fn compile_input(ctxt: &Ctx,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: what == Test || what == Bench,\n         maybe_sysroot: ctxt.sysroot_opt,\n-        addl_lib_search_paths: @mut ~[copy *out_dir],\n+        addl_lib_search_paths: @mut (~[copy *out_dir]),\n         // output_type should be conditional\n         output_type: output_type_exe, // Use this to get a library? That's weird\n         .. copy *driver::build_session_options(binary, &matches, diagnostic::emit)\n     };\n \n     let addl_lib_search_paths = @mut options.addl_lib_search_paths;\n+    // Make sure all the library directories actually exist, since the linker will complain\n+    // otherwise\n+    for addl_lib_search_paths.each() |p| {\n+        assert!(os::path_is_dir(p));\n+    }\n \n     let sess = driver::build_session(options, diagnostic::emit);\n \n@@ -274,7 +251,7 @@ pub fn compile_input(ctxt: &Ctx,\n                  ~[@dummy_spanned(meta_name_value(@\"name\",\n                                       mk_string_lit(short_name_to_use.to_managed()))),\n                    @dummy_spanned(meta_name_value(@\"vers\",\n-                         mk_string_lit(pkg_id.version.to_str_nonempty().to_managed())))])))],\n+                         mk_string_lit(pkg_id.version.to_str().to_managed())))])))],\n             ..copy crate.node});\n     }\n \n@@ -340,10 +317,11 @@ pub fn compile_crate(ctxt: &Ctx, pkg_id: &PkgId,\n     compile_input(ctxt, pkg_id, crate, dir, flags, cfgs, opt, what)\n }\n \n+\n /// Collect all `extern mod` directives in `c`, then\n /// try to install their targets, failing if any target\n /// can't be found.\n-fn find_and_install_dependencies(ctxt: &Ctx,\n+pub fn find_and_install_dependencies(ctxt: &Ctx,\n                                  sess: session::Session,\n                                  workspace: &Path,\n                                  c: &ast::crate,\n@@ -360,7 +338,7 @@ fn find_and_install_dependencies(ctxt: &Ctx,\n             ast::view_item_extern_mod(lib_ident, _, _) => {\n                 match my_ctxt.sysroot_opt {\n                     Some(ref x) => debug!(\"sysroot: %s\", x.to_str()),\n-                    None => ()\n+                    None => debug!(\"No sysroot given\")\n                 };\n                 let lib_name = sess.str_of(lib_ident);\n                 match find_library_in_search_path(my_ctxt.sysroot_opt, lib_name) {\n@@ -371,14 +349,10 @@ fn find_and_install_dependencies(ctxt: &Ctx,\n                         // Try to install it\n                         let pkg_id = PkgId::new(lib_name);\n                         my_ctxt.install(&my_workspace, &pkg_id);\n-                        let built_lib =\n-                            built_library_in_workspace(&pkg_id,\n-                                &my_workspace).expect(fmt!(\"find_and_install_dependencies: \\\n-                                I thought I already built %s, but the library doesn't seem \\\n-                                to exist\", lib_name));\n                         // Also, add an additional search path\n-                        let installed_path = target_library_in_workspace(&my_workspace,\n-                                                                         &built_lib).pop();\n+                        debug!(\"let installed_path...\")\n+                        let installed_path = target_library_in_workspace(&pkg_id,\n+                                                                         &my_workspace).pop();\n                         debug!(\"Great, I installed %s, and it's in %s\",\n                                lib_name, installed_path.to_str());\n                         save(installed_path);"}, {"sha": "7431b5e4c011cd0b76ecda0f7bb4fbe47992250f", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -23,20 +23,22 @@ use extra::tempfile::mkdtemp;\n pub enum Version {\n     ExactRevision(~str), // Should look like a m.n.(...).x\n     SemanticVersion(semver::Version),\n-    NoVersion // user didn't specify a version\n+    NoVersion // user didn't specify a version -- prints as 0.1\n }\n \n \n impl Ord for Version {\n     fn lt(&self, other: &Version) -> bool {\n         match (self, other) {\n+            (&NoVersion, _) => true,\n             (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 < f2,\n             (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 < v2,\n             _ => false // incomparable, really\n         }\n     }\n     fn le(&self, other: &Version) -> bool {\n         match (self, other) {\n+            (&NoVersion, _) => true,\n             (&ExactRevision(ref f1), &ExactRevision(ref f2)) => f1 <= f2,\n             (&SemanticVersion(ref v1), &SemanticVersion(ref v2)) => v1 <= v2,\n             _ => false // incomparable, really\n@@ -64,23 +66,11 @@ impl ToStr for Version {\n         match *self {\n             ExactRevision(ref n) => fmt!(\"%s\", n.to_str()),\n             SemanticVersion(ref v) => fmt!(\"%s\", v.to_str()),\n-            NoVersion => ~\"\"\n+            NoVersion => ~\"0.1\"\n         }\n     }\n }\n \n-impl Version {\n-    /// Fills in a bogus default version for NoVersion -- for use when\n-    /// injecting link_meta attributes\n-    fn to_str_nonempty(&self) -> ~str {\n-        match *self {\n-            NoVersion => ~\"0.1\",\n-            _ => self.to_str()\n-        }\n-    }\n-}\n-\n-\n pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n     match semver::parse(vers) {\n         Some(vers) => result::Ok(vers),\n@@ -98,15 +88,18 @@ pub fn try_getting_version(remote_path: &RemotePath) -> Option<Version> {\n         debug!(\"Trying to fetch its sources..\");\n         let tmp_dir = mkdtemp(&os::tmpdir(),\n                               \"test\").expect(\"try_getting_version: couldn't create temp dir\");\n-        debug!(\"executing {git clone https://%s %s}\", remote_path.to_str(), tmp_dir.to_str());\n+        debug!(\"(to get version) executing {git clone https://%s %s}\",\n+               remote_path.to_str(),\n+               tmp_dir.to_str());\n         let outp  = run::process_output(\"git\", [~\"clone\", fmt!(\"https://%s\", remote_path.to_str()),\n                                                 tmp_dir.to_str()]);\n         if outp.status == 0 {\n             debug!(\"Cloned it... ( %s, %s )\",\n                    str::from_bytes(outp.output),\n                    str::from_bytes(outp.error));\n             let mut output = None;\n-            debug!(\"executing {git --git-dir=%s tag -l}\", tmp_dir.push(\".git\").to_str());\n+            debug!(\"(getting version, now getting tags) executing {git --git-dir=%s tag -l}\",\n+                   tmp_dir.push(\".git\").to_str());\n             let outp = run::process_output(\"git\",\n                                            [fmt!(\"--git-dir=%s\", tmp_dir.push(\".git\").to_str()),\n                                             ~\"tag\", ~\"-l\"]);\n@@ -169,11 +162,18 @@ fn is_url_like(p: &RemotePath) -> bool {\n /// number, return the prefix before the # and the version.\n /// Otherwise, return None.\n pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n+    split_version_general(s, '#')\n+}\n+\n+pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Version)> {\n     // reject strings with multiple '#'s\n-    if s.splitn_iter('#', 2).count() > 2 {\n+    for s.split_iter(sep).advance |st| {\n+        debug!(\"whole = %s part = %s\", s, st);\n+    }\n+    if s.split_iter(sep).count() > 2 {\n         return None;\n     }\n-    match s.rfind('#') {\n+    match s.rfind(sep) {\n         Some(i) => {\n             debug!(\"in %s, i = %?\", s, i);\n             let path = s.slice(0, i);"}, {"sha": "54144f8e31f286b696602e4814c271bfe4d43d9c", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac0200f18bfe19646ae5dce56acc325629224cb/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=eac0200f18bfe19646ae5dce56acc325629224cb", "patch": "@@ -14,11 +14,10 @@ use path_util::{rust_path, workspace_contains_package_id};\n use package_id::PkgId;\n use core::path::Path;\n \n-pub fn pkg_parent_workspaces(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n+pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n-    let workspaces = rust_path().filtered(|ws|\n-        workspace_contains_package_id(pkgid, ws));\n+    let workspaces = pkg_parent_workspaces(pkgid);\n     if workspaces.is_empty() {\n         // tjc: make this a condition\n         fail!(\"Package %s not found in any of \\\n@@ -33,3 +32,8 @@ pub fn pkg_parent_workspaces(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool\n     }\n     return true;\n }\n+\n+pub fn pkg_parent_workspaces(pkgid: &PkgId) -> ~[Path] {\n+    rust_path().filtered(|ws|\n+        workspace_contains_package_id(pkgid, ws))\n+}\n\\ No newline at end of file"}]}