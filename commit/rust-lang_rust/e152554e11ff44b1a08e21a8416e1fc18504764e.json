{"sha": "e152554e11ff44b1a08e21a8416e1fc18504764e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNTI1NTRlMTFmZjQ0YjFhMDhlMjFhODQxNmUxZmMxODUwNDc2NGU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-18T07:48:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-18T08:01:20Z"}, "message": "resolve/expand: Move expansion info setting to a single earlier point", "tree": {"sha": "0a752397cb76fb97cef534b5a28e410cda16ec6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a752397cb76fb97cef534b5a28e410cda16ec6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e152554e11ff44b1a08e21a8416e1fc18504764e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e152554e11ff44b1a08e21a8416e1fc18504764e", "html_url": "https://github.com/rust-lang/rust/commit/e152554e11ff44b1a08e21a8416e1fc18504764e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e152554e11ff44b1a08e21a8416e1fc18504764e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ff3bce5bbcf3f23ad90266f8f3de1ac13d23623", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff3bce5bbcf3f23ad90266f8f3de1ac13d23623", "html_url": "https://github.com/rust-lang/rust/commit/1ff3bce5bbcf3f23ad90266f8f3de1ac13d23623"}], "stats": {"total": 65, "additions": 30, "deletions": 35}, "files": [{"sha": "d2fec0ed622d1f138a68e76724dfe99a0b56abd2", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e152554e11ff44b1a08e21a8416e1fc18504764e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152554e11ff44b1a08e21a8416e1fc18504764e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e152554e11ff44b1a08e21a8416e1fc18504764e", "patch": "@@ -114,6 +114,22 @@ fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKi\n     candidate.is_none() || requirement.is_none() || candidate == requirement\n }\n \n+// We don't want to format a path using pretty-printing,\n+// `format!(\"{}\", path)`, because that tries to insert\n+// line-breaks and is slow.\n+fn fast_print_path(path: &ast::Path) -> String {\n+    let mut path_str = String::with_capacity(64);\n+    for (i, segment) in path.segments.iter().enumerate() {\n+        if i != 0 {\n+            path_str.push_str(\"::\");\n+        }\n+        if segment.ident.name != kw::PathRoot {\n+            path_str.push_str(&segment.ident.as_str())\n+        }\n+    }\n+    path_str\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -209,14 +225,19 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n         let (res, ext) = match self.resolve_macro_to_res(path, kind, &parent_scope, true, force) {\n             Ok((res, ext)) => (res, ext),\n-            Err(Determinacy::Determined) if kind == MacroKind::Attr => {\n-                // Replace unresolved attributes with used inert attributes for better recovery.\n-                return Ok(Some(self.non_macro_attr(true)));\n-            }\n+            // Replace unresolved attributes with used inert attributes for better recovery.\n+            Err(Determinacy::Determined) if kind == MacroKind::Attr =>\n+                (Res::Err, self.non_macro_attr(true)),\n             Err(determinacy) => return Err(determinacy),\n         };\n \n-        if let Res::Def(DefKind::Macro(_), def_id) = res {\n+        let format = match kind {\n+            MacroKind::Derive => format!(\"derive({})\", fast_print_path(path)),\n+            _ => fast_print_path(path),\n+        };\n+        invoc.expansion_data.mark.set_expn_info(ext.expn_info(invoc.span(), &format));\n+\n+        if let Res::Def(_, def_id) = res {\n             if after_derive {\n                 self.session.span_err(invoc.span(),\n                                       \"macro attributes must be placed before `#[derive]`\");"}, {"sha": "318a5a3a82a2e6010f9a7d1bd2d46d847eb14a2d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152554e11ff44b1a08e21a8416e1fc18504764e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152554e11ff44b1a08e21a8416e1fc18504764e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e152554e11ff44b1a08e21a8416e1fc18504764e", "patch": "@@ -677,7 +677,7 @@ impl SyntaxExtension {\n         }\n     }\n \n-    crate fn expn_info(&self, call_site: Span, format: &str) -> ExpnInfo {\n+    pub fn expn_info(&self, call_site: Span, format: &str) -> ExpnInfo {\n         ExpnInfo {\n             call_site,\n             format: self.expn_format(Symbol::intern(format)),"}, {"sha": "7154cc409f2683d5dd79b3466766b97a238792a6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e152554e11ff44b1a08e21a8416e1fc18504764e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152554e11ff44b1a08e21a8416e1fc18504764e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e152554e11ff44b1a08e21a8416e1fc18504764e", "patch": "@@ -188,22 +188,6 @@ impl AstFragmentKind {\n     }\n }\n \n-// We don't want to format a path using pretty-printing,\n-// `format!(\"{}\", path)`, because that tries to insert\n-// line-breaks and is slow.\n-fn fast_print_path(path: &ast::Path) -> String {\n-    let mut path_str = String::with_capacity(64);\n-    for (i, segment) in path.segments.iter().enumerate() {\n-        if i != 0 {\n-            path_str.push_str(\"::\");\n-        }\n-        if segment.ident.name != kw::PathRoot {\n-            path_str.push_str(&segment.ident.as_str())\n-        }\n-    }\n-    path_str\n-}\n-\n pub struct Invocation {\n     pub kind: InvocationKind,\n     fragment_kind: AstFragmentKind,\n@@ -546,9 +530,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        let expn_info = ext.expn_info(attr.span, &fast_print_path(&attr.path));\n-        invoc.expansion_data.mark.set_expn_info(expn_info);\n-\n         match &ext.kind {\n             SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n                 attr::mark_known(&attr);\n@@ -682,15 +663,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n                          -> Option<AstFragment> {\n-        let (mark, kind) = (invoc.expansion_data.mark, invoc.fragment_kind);\n+        let kind = invoc.fragment_kind;\n         let (mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n             _ => unreachable!(),\n         };\n         let path = &mac.node.path;\n \n         let ident = ident.unwrap_or_else(|| Ident::invalid());\n-        let validate_and_set_expn_info = |this: &mut Self| {\n+        let validate = |this: &mut Self| {\n             // feature-gate the macro invocation\n             if let Some((feature, issue)) = ext.unstable_feature {\n                 let crate_span = this.cx.current_expansion.crate_span.unwrap();\n@@ -715,13 +696,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 this.cx.trace_macros_diag();\n                 return Err(kind.dummy(span));\n             }\n-            mark.set_expn_info(ext.expn_info(span, &fast_print_path(path)));\n             Ok(())\n         };\n \n         let opt_expanded = match &ext.kind {\n             SyntaxExtensionKind::LegacyBang(expander) => {\n-                if let Err(dummy_span) = validate_and_set_expn_info(self) {\n+                if let Err(dummy_span) = validate(self) {\n                     dummy_span\n                 } else {\n                     kind.make_from(expander.expand(\n@@ -757,8 +737,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     kind.dummy(span)\n                 } else {\n                     self.gate_proc_macro_expansion_kind(span, kind);\n-                    let expn_info = ext.expn_info(span, &fast_print_path(path));\n-                    invoc.expansion_data.mark.set_expn_info(expn_info);\n                     let tok_result = expander.expand(self.cx, span, mac.node.stream());\n                     let result = self.parse_ast_fragment(tok_result, kind, path, span);\n                     self.gate_proc_macro_expansion(span, &result);\n@@ -818,10 +796,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         match &ext.kind {\n             SyntaxExtensionKind::Derive(expander) |\n             SyntaxExtensionKind::LegacyDerive(expander) => {\n-                let expn_info =\n-                    ext.expn_info(path.span, &format!(\"derive({})\", fast_print_path(&path)));\n-                invoc.expansion_data.mark.set_expn_info(expn_info);\n-\n                 let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span: path.span, path };\n                 let span = meta.span.with_ctxt(self.cx.backtrace());\n                 let items = expander.expand(self.cx, span, &meta, item);"}]}