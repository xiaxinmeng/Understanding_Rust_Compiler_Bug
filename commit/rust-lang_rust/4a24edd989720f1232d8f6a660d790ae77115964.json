{"sha": "4a24edd989720f1232d8f6a660d790ae77115964", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMjRlZGQ5ODk3MjBmMTIzMmQ4ZjZhNjYwZDc5MGFlNzcxMTU5NjQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-27T14:29:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-27T14:29:10Z"}, "message": "Merge #7677\n\n7677: More enum matching r=yoshuawuyts a=jDomantas\n\n* Renamed existing `generate_enum_match_method` to `generate_enum_is_variant`\r\n* Added two similar assists to generate `into_` and `as_` methods.\r\n* Made all of them general enough to work on record and tuple variants too.\r\n\r\nFor `as_` method generation there's room to improve:\r\n* Right now it always returns `Option<&Field>`, even though `Option<Field>` would be nicer when `Field: Copy`. I don't know how to check if the field type implements `Copy`. If given suggestions I could try to fix this in a follow-up pr.\r\n* `&String` could be replaced with `&str`, `&Box<_>` with `&_`, and probably some more. I don't know what would be a good way to do that.\r\n\r\nCloses #7604\n\nCo-authored-by: Domantas Jadenkus <djadenkus@gmail.com>", "tree": {"sha": "6efdc9d6ce4a1c9e8c886c1b3e70a17d6a19fe7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6efdc9d6ce4a1c9e8c886c1b3e70a17d6a19fe7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a24edd989720f1232d8f6a660d790ae77115964", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgOlc2CRBK7hj4Ov3rIwAAdHIIALIL67dpYtoB0n429F8TlSCx\nHV8Fwl3kj/drJMXs3VCXTsfzMHVY60ZgFzZnIFJzf57Vo01rClVUFwxKleiE+fB5\nT06EhxWVSYc32UVvca+a2jPkFPe1PK9PFx6gG/HoOPNshiql/BY50gM46kry4bxF\nQsKT3XUFSH74TRdSvC8Ev4BASSoUhvLo5gDf7wpcp7pGuWiRJotNVZ87WMG/6nMr\nuEBMJOv8tRNQlfXGzJlDu2ocznGlSUIbioyc1t4kweuiOANhZHXC/olDrjcpbuto\n8fMYGhvbgTI3GsZrqxwZAP92Pull2CKLrn50E93eHuZYlwDJ2y9mHl1HDjdySxk=\n=fswg\n-----END PGP SIGNATURE-----\n", "payload": "tree 6efdc9d6ce4a1c9e8c886c1b3e70a17d6a19fe7b\nparent 2a4076c14d0e3f7ae03908c2b9cd1a52851d401c\nparent 558bcf4e0bf9d94ab51238e59f6fc5c170f38c3e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614436150 +0000\ncommitter GitHub <noreply@github.com> 1614436150 +0000\n\nMerge #7677\n\n7677: More enum matching r=yoshuawuyts a=jDomantas\n\n* Renamed existing `generate_enum_match_method` to `generate_enum_is_variant`\r\n* Added two similar assists to generate `into_` and `as_` methods.\r\n* Made all of them general enough to work on record and tuple variants too.\r\n\r\nFor `as_` method generation there's room to improve:\r\n* Right now it always returns `Option<&Field>`, even though `Option<Field>` would be nicer when `Field: Copy`. I don't know how to check if the field type implements `Copy`. If given suggestions I could try to fix this in a follow-up pr.\r\n* `&String` could be replaced with `&str`, `&Box<_>` with `&_`, and probably some more. I don't know what would be a good way to do that.\r\n\r\nCloses #7604\n\nCo-authored-by: Domantas Jadenkus <djadenkus@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a24edd989720f1232d8f6a660d790ae77115964", "html_url": "https://github.com/rust-lang/rust/commit/4a24edd989720f1232d8f6a660d790ae77115964", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a24edd989720f1232d8f6a660d790ae77115964/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a4076c14d0e3f7ae03908c2b9cd1a52851d401c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a4076c14d0e3f7ae03908c2b9cd1a52851d401c", "html_url": "https://github.com/rust-lang/rust/commit/2a4076c14d0e3f7ae03908c2b9cd1a52851d401c"}, {"sha": "558bcf4e0bf9d94ab51238e59f6fc5c170f38c3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/558bcf4e0bf9d94ab51238e59f6fc5c170f38c3e", "html_url": "https://github.com/rust-lang/rust/commit/558bcf4e0bf9d94ab51238e59f6fc5c170f38c3e"}], "stats": {"total": 552, "additions": 488, "deletions": 64}, "files": [{"sha": "7e181a4801e3184adf07b325d2c6252b77ef74b1", "filename": "crates/ide_assists/src/handlers/generate_enum_is_method.rs", "status": "renamed", "additions": 69, "deletions": 59, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/4a24edd989720f1232d8f6a660d790ae77115964/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24edd989720f1232d8f6a660d790ae77115964/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs?ref=4a24edd989720f1232d8f6a660d790ae77115964", "patch": "@@ -1,14 +1,13 @@\n-use stdx::{format_to, to_lower_snake_case};\n+use stdx::to_lower_snake_case;\n use syntax::ast::VisibilityOwner;\n use syntax::ast::{self, AstNode, NameOwner};\n-use test_utils::mark;\n \n use crate::{\n-    utils::{find_impl_block_end, find_struct_impl, generate_impl_text},\n+    utils::{add_method_to_adt, find_struct_impl},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n \n-// Assist: generate_enum_match_method\n+// Assist: generate_enum_is_method\n //\n // Generate an `is_` method for an enum variant.\n //\n@@ -34,79 +33,52 @@ use crate::{\n //     }\n // }\n // ```\n-pub(crate) fn generate_enum_match_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let variant_name = variant.name()?;\n-    let parent_enum = variant.parent_enum();\n-    if !matches!(variant.kind(), ast::StructKind::Unit) {\n-        mark::hit!(test_gen_enum_match_on_non_unit_variant_not_implemented);\n-        return None;\n-    }\n+    let parent_enum = ast::Adt::Enum(variant.parent_enum());\n+    let pattern_suffix = match variant.kind() {\n+        ast::StructKind::Record(_) => \" { .. }\",\n+        ast::StructKind::Tuple(_) => \"(..)\",\n+        ast::StructKind::Unit => \"\",\n+    };\n \n     let enum_lowercase_name = to_lower_snake_case(&parent_enum.name()?.to_string());\n-    let fn_name = to_lower_snake_case(&variant_name.to_string());\n+    let fn_name = format!(\"is_{}\", &to_lower_snake_case(variant_name.text()));\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(\n-        &ctx,\n-        &ast::Adt::Enum(parent_enum.clone()),\n-        format!(\"is_{}\", fn_name).as_str(),\n-    )?;\n+    let impl_def = find_struct_impl(&ctx, &parent_enum, &fn_name)?;\n \n     let target = variant.syntax().text_range();\n     acc.add(\n-        AssistId(\"generate_enum_match_method\", AssistKind::Generate),\n+        AssistId(\"generate_enum_is_method\", AssistKind::Generate),\n         \"Generate an `is_` method for an enum variant\",\n         target,\n         |builder| {\n-            let mut buf = String::with_capacity(512);\n-\n-            if impl_def.is_some() {\n-                buf.push('\\n');\n-            }\n-\n             let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n-            format_to!(\n-                buf,\n+            let method = format!(\n                 \"    /// Returns `true` if the {} is [`{}`].\n-    {}fn is_{}(&self) -> bool {{\n-        matches!(self, Self::{})\n+    {}fn {}(&self) -> bool {{\n+        matches!(self, Self::{}{})\n     }}\",\n-                enum_lowercase_name,\n-                variant_name,\n-                vis,\n-                fn_name,\n-                variant_name\n+                enum_lowercase_name, variant_name, vis, fn_name, variant_name, pattern_suffix,\n             );\n \n-            let start_offset = impl_def\n-                .and_then(|impl_def| find_impl_block_end(impl_def, &mut buf))\n-                .unwrap_or_else(|| {\n-                    buf = generate_impl_text(&ast::Adt::Enum(parent_enum.clone()), &buf);\n-                    parent_enum.syntax().text_range().end()\n-                });\n-\n-            builder.insert(start_offset, buf);\n+            add_method_to_adt(builder, &parent_enum, impl_def, &method);\n         },\n     )\n }\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n-    fn check_not_applicable(ra_fixture: &str) {\n-        check_assist_not_applicable(generate_enum_match_method, ra_fixture)\n-    }\n-\n     #[test]\n-    fn test_generate_enum_match_from_variant() {\n+    fn test_generate_enum_is_from_variant() {\n         check_assist(\n-            generate_enum_match_method,\n+            generate_enum_is_method,\n             r#\"\n enum Variant {\n     Undefined,\n@@ -129,8 +101,9 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_generate_enum_match_already_implemented() {\n-        check_not_applicable(\n+    fn test_generate_enum_is_already_implemented() {\n+        check_assist_not_applicable(\n+            generate_enum_is_method,\n             r#\"\n enum Variant {\n     Undefined,\n@@ -147,22 +120,59 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_add_from_impl_no_element() {\n-        mark::check!(test_gen_enum_match_on_non_unit_variant_not_implemented);\n-        check_not_applicable(\n+    fn test_generate_enum_is_from_tuple_variant() {\n+        check_assist(\n+            generate_enum_is_method,\n             r#\"\n enum Variant {\n     Undefined,\n     Minor(u32)$0,\n     Major,\n+}\"#,\n+            r#\"enum Variant {\n+    Undefined,\n+    Minor(u32),\n+    Major,\n+}\n+\n+impl Variant {\n+    /// Returns `true` if the variant is [`Minor`].\n+    fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor(..))\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_is_from_record_variant() {\n+        check_assist(\n+            generate_enum_is_method,\n+            r#\"\n+enum Variant {\n+    Undefined,\n+    Minor { foo: i32 }$0,\n+    Major,\n+}\"#,\n+            r#\"enum Variant {\n+    Undefined,\n+    Minor { foo: i32 },\n+    Major,\n+}\n+\n+impl Variant {\n+    /// Returns `true` if the variant is [`Minor`].\n+    fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor { .. })\n+    }\n }\"#,\n         );\n     }\n \n     #[test]\n-    fn test_generate_enum_match_from_variant_with_one_variant() {\n+    fn test_generate_enum_is_from_variant_with_one_variant() {\n         check_assist(\n-            generate_enum_match_method,\n+            generate_enum_is_method,\n             r#\"enum Variant { Undefi$0ned }\"#,\n             r#\"\n enum Variant { Undefined }\n@@ -177,9 +187,9 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_generate_enum_match_from_variant_with_visibility_marker() {\n+    fn test_generate_enum_is_from_variant_with_visibility_marker() {\n         check_assist(\n-            generate_enum_match_method,\n+            generate_enum_is_method,\n             r#\"\n pub(crate) enum Variant {\n     Undefined,\n@@ -202,9 +212,9 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_multiple_generate_enum_match_from_variant() {\n+    fn test_multiple_generate_enum_is_from_variant() {\n         check_assist(\n-            generate_enum_match_method,\n+            generate_enum_is_method,\n             r#\"\n enum Variant {\n     Undefined,", "previous_filename": "crates/ide_assists/src/handlers/generate_enum_match_method.rs"}, {"sha": "871bcab50b0913d4011ebe01aa2b12ae7d7e8075", "filename": "crates/ide_assists/src/handlers/generate_enum_projection_method.rs", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/4a24edd989720f1232d8f6a660d790ae77115964/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24edd989720f1232d8f6a660d790ae77115964/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs?ref=4a24edd989720f1232d8f6a660d790ae77115964", "patch": "@@ -0,0 +1,331 @@\n+use itertools::Itertools;\n+use stdx::to_lower_snake_case;\n+use syntax::ast::VisibilityOwner;\n+use syntax::ast::{self, AstNode, NameOwner};\n+\n+use crate::{\n+    utils::{add_method_to_adt, find_struct_impl},\n+    AssistContext, AssistId, AssistKind, Assists,\n+};\n+\n+// Assist: generate_enum_try_into_method\n+//\n+// Generate an `try_into_` method for an enum variant.\n+//\n+// ```\n+// enum Value {\n+//  Number(i32),\n+//  Text(String)$0,\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Value {\n+//  Number(i32),\n+//  Text(String),\n+// }\n+//\n+// impl Value {\n+//     fn try_into_text(self) -> Result<String, Self> {\n+//         if let Self::Text(v) = self {\n+//             Ok(v)\n+//         } else {\n+//             Err(self)\n+//         }\n+//     }\n+// }\n+// ```\n+pub(crate) fn generate_enum_try_into_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    generate_enum_projection_method(\n+        acc,\n+        ctx,\n+        \"generate_enum_try_into_method\",\n+        \"Generate an `try_into_` method for an enum variant\",\n+        ProjectionProps {\n+            fn_name_prefix: \"try_into\",\n+            self_param: \"self\",\n+            return_prefix: \"Result<\",\n+            return_suffix: \", Self>\",\n+            happy_case: \"Ok\",\n+            sad_case: \"Err(self)\",\n+        },\n+    )\n+}\n+\n+// Assist: generate_enum_as_method\n+//\n+// Generate an `as_` method for an enum variant.\n+//\n+// ```\n+// enum Value {\n+//  Number(i32),\n+//  Text(String)$0,\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Value {\n+//  Number(i32),\n+//  Text(String),\n+// }\n+//\n+// impl Value {\n+//     fn as_text(&self) -> Option<&String> {\n+//         if let Self::Text(v) = self {\n+//             Some(v)\n+//         } else {\n+//             None\n+//         }\n+//     }\n+// }\n+// ```\n+pub(crate) fn generate_enum_as_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    generate_enum_projection_method(\n+        acc,\n+        ctx,\n+        \"generate_enum_as_method\",\n+        \"Generate an `as_` method for an enum variant\",\n+        ProjectionProps {\n+            fn_name_prefix: \"as\",\n+            self_param: \"&self\",\n+            return_prefix: \"Option<&\",\n+            return_suffix: \">\",\n+            happy_case: \"Some\",\n+            sad_case: \"None\",\n+        },\n+    )\n+}\n+\n+struct ProjectionProps {\n+    fn_name_prefix: &'static str,\n+    self_param: &'static str,\n+    return_prefix: &'static str,\n+    return_suffix: &'static str,\n+    happy_case: &'static str,\n+    sad_case: &'static str,\n+}\n+\n+fn generate_enum_projection_method(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+    assist_id: &'static str,\n+    assist_description: &str,\n+    props: ProjectionProps,\n+) -> Option<()> {\n+    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n+    let variant_name = variant.name()?;\n+    let parent_enum = ast::Adt::Enum(variant.parent_enum());\n+\n+    let (pattern_suffix, field_type, bound_name) = match variant.kind() {\n+        ast::StructKind::Record(record) => {\n+            let (field,) = record.fields().collect_tuple()?;\n+            let name = field.name()?.to_string();\n+            let ty = field.ty()?;\n+            let pattern_suffix = format!(\" {{ {} }}\", name);\n+            (pattern_suffix, ty, name)\n+        }\n+        ast::StructKind::Tuple(tuple) => {\n+            let (field,) = tuple.fields().collect_tuple()?;\n+            let ty = field.ty()?;\n+            (\"(v)\".to_owned(), ty, \"v\".to_owned())\n+        }\n+        ast::StructKind::Unit => return None,\n+    };\n+\n+    let fn_name = format!(\"{}_{}\", props.fn_name_prefix, &to_lower_snake_case(variant_name.text()));\n+\n+    // Return early if we've found an existing new fn\n+    let impl_def = find_struct_impl(&ctx, &parent_enum, &fn_name)?;\n+\n+    let target = variant.syntax().text_range();\n+    acc.add(AssistId(assist_id, AssistKind::Generate), assist_description, target, |builder| {\n+        let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+        let method = format!(\n+            \"    {0}fn {1}({2}) -> {3}{4}{5} {{\n+        if let Self::{6}{7} = self {{\n+            {8}({9})\n+        }} else {{\n+            {10}\n+        }}\n+    }}\",\n+            vis,\n+            fn_name,\n+            props.self_param,\n+            props.return_prefix,\n+            field_type.syntax(),\n+            props.return_suffix,\n+            variant_name,\n+            pattern_suffix,\n+            props.happy_case,\n+            bound_name,\n+            props.sad_case,\n+        );\n+\n+        add_method_to_adt(builder, &parent_enum, impl_def, &method);\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_generate_enum_try_into_tuple_variant() {\n+        check_assist(\n+            generate_enum_try_into_method,\n+            r#\"\n+enum Value {\n+    Number(i32),\n+    Text(String)$0,\n+}\"#,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+}\n+\n+impl Value {\n+    fn try_into_text(self) -> Result<String, Self> {\n+        if let Self::Text(v) = self {\n+            Ok(v)\n+        } else {\n+            Err(self)\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_try_into_already_implemented() {\n+        check_assist_not_applicable(\n+            generate_enum_try_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String)$0,\n+}\n+\n+impl Value {\n+    fn try_into_text(self) -> Result<String, Self> {\n+        if let Self::Text(v) = self {\n+            Ok(v)\n+        } else {\n+            Err(self)\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_try_into_unit_variant() {\n+        check_assist_not_applicable(\n+            generate_enum_try_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+    Unit$0,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_try_into_record_with_multiple_fields() {\n+        check_assist_not_applicable(\n+            generate_enum_try_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+    Both { first: i32, second: String }$0,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_try_into_tuple_with_multiple_fields() {\n+        check_assist_not_applicable(\n+            generate_enum_try_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String, String)$0,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_try_into_record_variant() {\n+        check_assist(\n+            generate_enum_try_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text { text: String }$0,\n+}\"#,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text { text: String },\n+}\n+\n+impl Value {\n+    fn try_into_text(self) -> Result<String, Self> {\n+        if let Self::Text { text } = self {\n+            Ok(text)\n+        } else {\n+            Err(self)\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_as_tuple_variant() {\n+        check_assist(\n+            generate_enum_as_method,\n+            r#\"\n+enum Value {\n+    Number(i32),\n+    Text(String)$0,\n+}\"#,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+}\n+\n+impl Value {\n+    fn as_text(&self) -> Option<&String> {\n+        if let Self::Text(v) = self {\n+            Some(v)\n+        } else {\n+            None\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_as_record_variant() {\n+        check_assist(\n+            generate_enum_as_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text { text: String }$0,\n+}\"#,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text { text: String },\n+}\n+\n+impl Value {\n+    fn as_text(&self) -> Option<&String> {\n+        if let Self::Text { text } = self {\n+            Some(text)\n+        } else {\n+            None\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "4c067d45113ecb465a973dcced091de499cb3bea", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a24edd989720f1232d8f6a660d790ae77115964/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24edd989720f1232d8f6a660d790ae77115964/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=4a24edd989720f1232d8f6a660d790ae77115964", "patch": "@@ -128,7 +128,8 @@ mod handlers {\n     mod flip_trait_bound;\n     mod generate_default_from_enum_variant;\n     mod generate_derive;\n-    mod generate_enum_match_method;\n+    mod generate_enum_is_method;\n+    mod generate_enum_projection_method;\n     mod generate_from_impl_for_enum;\n     mod generate_function;\n     mod generate_getter;\n@@ -189,7 +190,9 @@ mod handlers {\n             flip_trait_bound::flip_trait_bound,\n             generate_default_from_enum_variant::generate_default_from_enum_variant,\n             generate_derive::generate_derive,\n-            generate_enum_match_method::generate_enum_match_method,\n+            generate_enum_is_method::generate_enum_is_method,\n+            generate_enum_projection_method::generate_enum_try_into_method,\n+            generate_enum_projection_method::generate_enum_as_method,\n             generate_from_impl_for_enum::generate_from_impl_for_enum,\n             generate_function::generate_function,\n             generate_getter::generate_getter,"}, {"sha": "7f6dbbccf20b2fe564b517690f57ecc28dd7c3a9", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4a24edd989720f1232d8f6a660d790ae77115964/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24edd989720f1232d8f6a660d790ae77115964/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=4a24edd989720f1232d8f6a660d790ae77115964", "patch": "@@ -483,9 +483,38 @@ struct Point {\n }\n \n #[test]\n-fn doctest_generate_enum_match_method() {\n+fn doctest_generate_enum_as_method() {\n     check_doc_test(\n-        \"generate_enum_match_method\",\n+        \"generate_enum_as_method\",\n+        r#####\"\n+enum Value {\n+ Number(i32),\n+ Text(String)$0,\n+}\n+\"#####,\n+        r#####\"\n+enum Value {\n+ Number(i32),\n+ Text(String),\n+}\n+\n+impl Value {\n+    fn as_text(&self) -> Option<&String> {\n+        if let Self::Text(v) = self {\n+            Some(v)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_generate_enum_is_method() {\n+    check_doc_test(\n+        \"generate_enum_is_method\",\n         r#####\"\n enum Version {\n  Undefined,\n@@ -510,6 +539,35 @@ impl Version {\n     )\n }\n \n+#[test]\n+fn doctest_generate_enum_try_into_method() {\n+    check_doc_test(\n+        \"generate_enum_try_into_method\",\n+        r#####\"\n+enum Value {\n+ Number(i32),\n+ Text(String)$0,\n+}\n+\"#####,\n+        r#####\"\n+enum Value {\n+ Number(i32),\n+ Text(String),\n+}\n+\n+impl Value {\n+    fn try_into_text(self) -> Result<String, Self> {\n+        if let Self::Text(v) = self {\n+            Ok(v)\n+        } else {\n+            Err(self)\n+        }\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_generate_from_impl_for_enum() {\n     check_doc_test("}, {"sha": "880ab6fe3eb3426f7b4d7d5b43284553f816acb0", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4a24edd989720f1232d8f6a660d790ae77115964/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24edd989720f1232d8f6a660d790ae77115964/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=4a24edd989720f1232d8f6a660d790ae77115964", "patch": "@@ -21,7 +21,7 @@ use syntax::{\n };\n \n use crate::{\n-    assist_context::AssistContext,\n+    assist_context::{AssistBuilder, AssistContext},\n     ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n };\n \n@@ -464,3 +464,25 @@ fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str\n \n     buf\n }\n+\n+pub(crate) fn add_method_to_adt(\n+    builder: &mut AssistBuilder,\n+    adt: &ast::Adt,\n+    impl_def: Option<ast::Impl>,\n+    method: &str,\n+) {\n+    let mut buf = String::with_capacity(method.len() + 2);\n+    if impl_def.is_some() {\n+        buf.push('\\n');\n+    }\n+    buf.push_str(method);\n+\n+    let start_offset = impl_def\n+        .and_then(|impl_def| find_impl_block_end(impl_def, &mut buf))\n+        .unwrap_or_else(|| {\n+            buf = generate_impl_text(&adt, &buf);\n+            adt.syntax().text_range().end()\n+        });\n+\n+    builder.insert(start_offset, buf);\n+}"}]}