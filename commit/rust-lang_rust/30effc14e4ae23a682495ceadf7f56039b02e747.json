{"sha": "30effc14e4ae23a682495ceadf7f56039b02e747", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZWZmYzE0ZTRhZTIzYTY4MjQ5NWNlYWRmN2Y1NjAzOWIwMmU3NDc=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-06-07T21:54:51Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-06-24T19:27:45Z"}, "message": "Add E0606", "tree": {"sha": "7303ed3017c97298e2679442510a3a67d18bb4c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7303ed3017c97298e2679442510a3a67d18bb4c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30effc14e4ae23a682495ceadf7f56039b02e747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30effc14e4ae23a682495ceadf7f56039b02e747", "html_url": "https://github.com/rust-lang/rust/commit/30effc14e4ae23a682495ceadf7f56039b02e747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30effc14e4ae23a682495ceadf7f56039b02e747/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e4b8ffccdfaa48e7ec61d8f8dc06f15f31c800f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e4b8ffccdfaa48e7ec61d8f8dc06f15f31c800f", "html_url": "https://github.com/rust-lang/rust/commit/0e4b8ffccdfaa48e7ec61d8f8dc06f15f31c800f"}], "stats": {"total": 147, "additions": 83, "deletions": 64}, "files": [{"sha": "5c255364311132eb91492781632481c916d90879", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/30effc14e4ae23a682495ceadf7f56039b02e747/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30effc14e4ae23a682495ceadf7f56039b02e747/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=30effc14e4ae23a682495ceadf7f56039b02e747", "patch": "@@ -40,9 +40,11 @@\n \n use super::{Diverges, FnCtxt};\n \n-use lint;\n+use errors::DiagnosticBuilder;\n use hir::def_id::DefId;\n+use lint;\n use rustc::hir;\n+use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::cast::{CastKind, CastTy};\n@@ -112,6 +114,18 @@ enum CastError {\n     NonScalar,\n }\n \n+fn make_invalid_casting_error<'a, 'gcx, 'tcx>(sess: &'a Session,\n+                                              span: Span,\n+                                              expr_ty: Ty<'tcx>,\n+                                              cast_ty: Ty<'tcx>,\n+                                              fcx: &FnCtxt<'a, 'gcx, 'tcx>)\n+                                              -> DiagnosticBuilder<'a> {\n+    struct_span_err!(sess, span, E0606,\n+                     \"casting `{}` as `{}` is invalid\",\n+                     fcx.ty_to_string(expr_ty),\n+                     fcx.ty_to_string(cast_ty))\n+}\n+\n impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     pub fn new(fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                expr: &'tcx hir::Expr,\n@@ -146,14 +160,9 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         match e {\n             CastError::NeedDeref => {\n                 let error_span = self.span;\n+                let mut err = make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty,\n+                                                         self.cast_ty, fcx);\n                 let cast_ty = fcx.ty_to_string(self.cast_ty);\n-                let mut err = fcx.type_error_struct(error_span,\n-                                       |actual| {\n-                                           format!(\"casting `{}` as `{}` is invalid\",\n-                                                   actual,\n-                                                   cast_ty)\n-                                       },\n-                                       self.expr_ty);\n                 err.span_label(error_span,\n                                format!(\"cannot cast `{}` as `{}`\",\n                                         fcx.ty_to_string(self.expr_ty),\n@@ -166,13 +175,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             }\n             CastError::NeedViaThinPtr |\n             CastError::NeedViaPtr => {\n-                let mut err = fcx.type_error_struct(self.span,\n-                                                    |actual| {\n-                                                        format!(\"casting `{}` as `{}` is invalid\",\n-                                                                actual,\n-                                                                fcx.ty_to_string(self.cast_ty))\n-                                                    },\n-                                                    self.expr_ty);\n+                let mut err = make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty,\n+                                                         self.cast_ty, fcx);\n                 if self.cast_ty.is_uint() {\n                     err.help(&format!(\"cast through {} first\",\n                                       match e {\n@@ -184,20 +188,23 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 err.emit();\n             }\n             CastError::NeedViaInt => {\n-                fcx.type_error_struct(self.span,\n-                                      |actual| {\n-                                          format!(\"casting `{}` as `{}` is invalid\",\n-                                                  actual,\n-                                                  fcx.ty_to_string(self.cast_ty))\n-                                      },\n-                                      self.expr_ty)\n+                make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty, self.cast_ty, fcx)\n                    .help(&format!(\"cast through {} first\",\n                                   match e {\n                                       CastError::NeedViaInt => \"an integer\",\n                                       _ => bug!(),\n                                   }))\n                    .emit();\n             }\n+            CastError::IllegalCast => {\n+                make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty, self.cast_ty, fcx)\n+                    .emit();\n+            }\n+            CastError::DifferingKinds => {\n+                make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty, self.cast_ty, fcx)\n+                    .note(\"vtable kinds may not match\")\n+                    .emit();\n+            }\n             CastError::CastToBool => {\n                 struct_span_err!(fcx.tcx.sess, self.span, E0054, \"cannot cast as `bool`\")\n                     .span_label(self.span, \"unsupported cast\")\n@@ -217,15 +224,6 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                        primitive types. Consider using the `From` trait\")\n                                 .emit();\n             }\n-            CastError::IllegalCast => {\n-                fcx.type_error_message(self.span,\n-                                       |actual| {\n-                                           format!(\"casting `{}` as `{}` is invalid\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty);\n-            }\n             CastError::SizedUnsizedCast => {\n                 fcx.type_error_message(self.span,\n                                        |actual| {\n@@ -236,17 +234,6 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                        },\n                                        self.expr_ty)\n             }\n-            CastError::DifferingKinds => {\n-                fcx.type_error_struct(self.span,\n-                                       |actual| {\n-                                           format!(\"casting `{}` as `{}` is invalid\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty)\n-                    .note(\"vtable kinds may not match\")\n-                    .emit();\n-            }\n         }\n     }\n "}, {"sha": "d3138af978aa7337d417ef329eccb2849e4d65a2", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/30effc14e4ae23a682495ceadf7f56039b02e747/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30effc14e4ae23a682495ceadf7f56039b02e747/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=30effc14e4ae23a682495ceadf7f56039b02e747", "patch": "@@ -4251,6 +4251,25 @@ v as *const i8; // ok!\n ```\n \"##,\n \n+E0606: r##\"\n+An incompatible cast was attempted.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0606\n+let x = &0u8; // Here, `x` is a `&u8`.\n+let y: u32 = x as u32; // error: casting `&u8` as `u32` is invalid\n+```\n+\n+When casting, keep in mind that only primitive types cast be casted into each\n+others. Example:\n+\n+```\n+let x = &0u8;\n+let y: u32 = *x as u32; // We dereference it first and then cast it.\n+```\n+\"##,\n+\n E0609: r##\"\n Attempted to access a non-existent field in a struct.\n "}, {"sha": "55071736bfe51918241beb893a90e3193794e000", "filename": "src/test/compile-fail/E0606.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/30effc14e4ae23a682495ceadf7f56039b02e747/src%2Ftest%2Fcompile-fail%2FE0606.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30effc14e4ae23a682495ceadf7f56039b02e747/src%2Ftest%2Fcompile-fail%2FE0606.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0606.rs?ref=30effc14e4ae23a682495ceadf7f56039b02e747", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    &0u8 as u8; //~ ERROR E0606\n+}"}, {"sha": "b4c3106253e14fbc98382dba32f0950fc009eca2", "filename": "src/test/ui/mismatched_types/cast-rfc0401.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/30effc14e4ae23a682495ceadf7f56039b02e747/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30effc14e4ae23a682495ceadf7f56039b02e747/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr?ref=30effc14e4ae23a682495ceadf7f56039b02e747", "patch": "@@ -1,12 +1,12 @@\n-error: casting `*const U` as `*const V` is invalid\n+error[E0606]: casting `*const U` as `*const V` is invalid\n   --> $DIR/cast-rfc0401.rs:13:5\n    |\n 13 |     u as *const V\n    |     ^^^^^^^^^^^^^\n    |\n    = note: vtable kinds may not match\n \n-error: casting `*const U` as `*const str` is invalid\n+error[E0606]: casting `*const U` as `*const str` is invalid\n   --> $DIR/cast-rfc0401.rs:18:5\n    |\n 18 |     u as *const str\n@@ -60,27 +60,27 @@ error[E0605]: non-scalar cast: `std::option::Option<&*const u8>` as `*const u8`\n    |\n    = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n \n-error: casting `*const u8` as `f32` is invalid\n+error[E0606]: casting `*const u8` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:45:13\n    |\n 45 |     let _ = v as f32;\n    |             ^^^^^^^^\n \n-error: casting `fn() {main}` as `f64` is invalid\n+error[E0606]: casting `fn() {main}` as `f64` is invalid\n   --> $DIR/cast-rfc0401.rs:46:13\n    |\n 46 |     let _ = main as f64;\n    |             ^^^^^^^^^^^\n \n-error: casting `&*const u8` as `usize` is invalid\n+error[E0606]: casting `&*const u8` as `usize` is invalid\n   --> $DIR/cast-rfc0401.rs:47:13\n    |\n 47 |     let _ = &v as usize;\n    |             ^^^^^^^^^^^\n    |\n    = help: cast through a raw pointer first\n \n-error: casting `f32` as `*const u8` is invalid\n+error[E0606]: casting `f32` as `*const u8` is invalid\n   --> $DIR/cast-rfc0401.rs:48:13\n    |\n 48 |     let _ = f as *const u8;\n@@ -108,49 +108,49 @@ error[E0604]: only `u8` can be cast as `char`, not `u32`\n 51 |     let _ = 0x61u32 as char;\n    |             ^^^^^^^^^^^^^^^\n \n-error: casting `bool` as `f32` is invalid\n+error[E0606]: casting `bool` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:53:13\n    |\n 53 |     let _ = false as f32;\n    |             ^^^^^^^^^^^^\n    |\n    = help: cast through an integer first\n \n-error: casting `E` as `f32` is invalid\n+error[E0606]: casting `E` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:54:13\n    |\n 54 |     let _ = E::A as f32;\n    |             ^^^^^^^^^^^\n    |\n    = help: cast through an integer first\n \n-error: casting `char` as `f32` is invalid\n+error[E0606]: casting `char` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:55:13\n    |\n 55 |     let _ = 'a' as f32;\n    |             ^^^^^^^^^^\n    |\n    = help: cast through an integer first\n \n-error: casting `bool` as `*const u8` is invalid\n+error[E0606]: casting `bool` as `*const u8` is invalid\n   --> $DIR/cast-rfc0401.rs:57:13\n    |\n 57 |     let _ = false as *const u8;\n    |             ^^^^^^^^^^^^^^^^^^\n \n-error: casting `E` as `*const u8` is invalid\n+error[E0606]: casting `E` as `*const u8` is invalid\n   --> $DIR/cast-rfc0401.rs:58:13\n    |\n 58 |     let _ = E::A as *const u8;\n    |             ^^^^^^^^^^^^^^^^^\n \n-error: casting `char` as `*const u8` is invalid\n+error[E0606]: casting `char` as `*const u8` is invalid\n   --> $DIR/cast-rfc0401.rs:59:13\n    |\n 59 |     let _ = 'a' as *const u8;\n    |             ^^^^^^^^^^^^^^^^\n \n-error: casting `usize` as `*const [u8]` is invalid\n+error[E0606]: casting `usize` as `*const [u8]` is invalid\n   --> $DIR/cast-rfc0401.rs:61:13\n    |\n 61 |     let _ = 42usize as *const [u8];\n@@ -162,53 +162,53 @@ error: cannot cast thin pointer `*const u8` to fat pointer `*const [u8]`\n 62 |     let _ = v as *const [u8];\n    |             ^^^^^^^^^^^^^^^^\n \n-error: casting `&Foo` as `*const str` is invalid\n+error[E0606]: casting `&Foo` as `*const str` is invalid\n   --> $DIR/cast-rfc0401.rs:64:13\n    |\n 64 |     let _ = foo as *const str;\n    |             ^^^^^^^^^^^^^^^^^\n \n-error: casting `&Foo` as `*mut str` is invalid\n+error[E0606]: casting `&Foo` as `*mut str` is invalid\n   --> $DIR/cast-rfc0401.rs:65:13\n    |\n 65 |     let _ = foo as *mut str;\n    |             ^^^^^^^^^^^^^^^\n \n-error: casting `fn() {main}` as `*mut str` is invalid\n+error[E0606]: casting `fn() {main}` as `*mut str` is invalid\n   --> $DIR/cast-rfc0401.rs:66:13\n    |\n 66 |     let _ = main as *mut str;\n    |             ^^^^^^^^^^^^^^^^\n \n-error: casting `&f32` as `*mut f32` is invalid\n+error[E0606]: casting `&f32` as `*mut f32` is invalid\n   --> $DIR/cast-rfc0401.rs:67:13\n    |\n 67 |     let _ = &f as *mut f32;\n    |             ^^^^^^^^^^^^^^\n \n-error: casting `&f32` as `*const f64` is invalid\n+error[E0606]: casting `&f32` as `*const f64` is invalid\n   --> $DIR/cast-rfc0401.rs:68:13\n    |\n 68 |     let _ = &f as *const f64;\n    |             ^^^^^^^^^^^^^^^^\n \n-error: casting `*const [i8]` as `usize` is invalid\n+error[E0606]: casting `*const [i8]` as `usize` is invalid\n   --> $DIR/cast-rfc0401.rs:69:13\n    |\n 69 |     let _ = fat_sv as usize;\n    |             ^^^^^^^^^^^^^^^\n    |\n    = help: cast through a thin pointer first\n \n-error: casting `*const Foo` as `*const [u16]` is invalid\n+error[E0606]: casting `*const Foo` as `*const [u16]` is invalid\n   --> $DIR/cast-rfc0401.rs:78:13\n    |\n 78 |     let _ = cf as *const [u16];\n    |             ^^^^^^^^^^^^^^^^^^\n    |\n    = note: vtable kinds may not match\n \n-error: casting `*const Foo` as `*const Bar` is invalid\n+error[E0606]: casting `*const Foo` as `*const Bar` is invalid\n   --> $DIR/cast-rfc0401.rs:79:13\n    |\n 79 |     let _ = cf as *const Bar;\n@@ -234,7 +234,7 @@ error[E0277]: the trait bound `str: std::marker::Sized` is not satisfied\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n    = note: required for the cast to the object type `Foo`\n \n-error: casting `&{float}` as `f32` is invalid\n+error[E0606]: casting `&{float}` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:81:30\n    |\n 81 |     vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();"}]}