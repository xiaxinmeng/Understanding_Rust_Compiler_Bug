{"sha": "c38f001db5e16f1e0db47c5aed80394e9df5430a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOGYwMDFkYjVlMTZmMWUwZGI0N2M1YWVkODAzOTRlOWRmNTQzMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-11T09:50:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-11T09:50:19Z"}, "message": "Auto merge of #77743 - bugadani:idl-cleanup, r=bugadani\n\nClean up in intra-doc link collector\n\nThis PR makes the following changes in intra-doc links:\n - clean up hard to follow closure-based logic in `check_full_res`\n - fix a FIXME comment by figuring out that `true` and `false` need to be resolved separately\n - refactor path resolution by extracting common code to a helper method and trying to reduce the number of unnecessary early returns\n - primitive types are now defined by their symbols, not their name strings\n - re-enables a commented-out test case\n\nCloses #77267 (cc `@Stupremee)`\n\nr? `@jyn514`", "tree": {"sha": "5a7322592384583ca0e26a1c07c57e027fba1a5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a7322592384583ca0e26a1c07c57e027fba1a5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c38f001db5e16f1e0db47c5aed80394e9df5430a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c38f001db5e16f1e0db47c5aed80394e9df5430a", "html_url": "https://github.com/rust-lang/rust/commit/c38f001db5e16f1e0db47c5aed80394e9df5430a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c38f001db5e16f1e0db47c5aed80394e9df5430a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6bebc14a14de81848f24353227244860f2ecdaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6bebc14a14de81848f24353227244860f2ecdaf", "html_url": "https://github.com/rust-lang/rust/commit/c6bebc14a14de81848f24353227244860f2ecdaf"}, {"sha": "725e3d1df30bc39fe76510c92679fbcb3536f4cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/725e3d1df30bc39fe76510c92679fbcb3536f4cb", "html_url": "https://github.com/rust-lang/rust/commit/725e3d1df30bc39fe76510c92679fbcb3536f4cb"}], "stats": {"total": 358, "additions": 198, "deletions": 160}, "files": [{"sha": "1e07f8e2eac2455da53ffb99b76c65f86ee5fb91", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c38f001db5e16f1e0db47c5aed80394e9df5430a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c38f001db5e16f1e0db47c5aed80394e9df5430a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=c38f001db5e16f1e0db47c5aed80394e9df5430a", "patch": "@@ -12,6 +12,7 @@ use std::{slice, vec};\n use rustc_ast::attr;\n use rustc_ast::util::comments::beautify_doc_string;\n use rustc_ast::{self as ast, AttrStyle};\n+use rustc_ast::{FloatTy, IntTy, UintTy};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -1279,6 +1280,28 @@ impl GetDefId for Type {\n }\n \n impl PrimitiveType {\n+    pub fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n+        match prim {\n+            hir::PrimTy::Int(IntTy::Isize) => PrimitiveType::Isize,\n+            hir::PrimTy::Int(IntTy::I8) => PrimitiveType::I8,\n+            hir::PrimTy::Int(IntTy::I16) => PrimitiveType::I16,\n+            hir::PrimTy::Int(IntTy::I32) => PrimitiveType::I32,\n+            hir::PrimTy::Int(IntTy::I64) => PrimitiveType::I64,\n+            hir::PrimTy::Int(IntTy::I128) => PrimitiveType::I128,\n+            hir::PrimTy::Uint(UintTy::Usize) => PrimitiveType::Usize,\n+            hir::PrimTy::Uint(UintTy::U8) => PrimitiveType::U8,\n+            hir::PrimTy::Uint(UintTy::U16) => PrimitiveType::U16,\n+            hir::PrimTy::Uint(UintTy::U32) => PrimitiveType::U32,\n+            hir::PrimTy::Uint(UintTy::U64) => PrimitiveType::U64,\n+            hir::PrimTy::Uint(UintTy::U128) => PrimitiveType::U128,\n+            hir::PrimTy::Float(FloatTy::F32) => PrimitiveType::F32,\n+            hir::PrimTy::Float(FloatTy::F64) => PrimitiveType::F64,\n+            hir::PrimTy::Str => PrimitiveType::Str,\n+            hir::PrimTy::Bool => PrimitiveType::Bool,\n+            hir::PrimTy::Char => PrimitiveType::Char,\n+        }\n+    }\n+\n     pub fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n         match s {\n             sym::isize => Some(PrimitiveType::Isize),"}, {"sha": "8be9482acffdea753eec7f10ec8dded7ad75e7b3", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 154, "deletions": 157, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/c38f001db5e16f1e0db47c5aed80394e9df5430a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c38f001db5e16f1e0db47c5aed80394e9df5430a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=c38f001db5e16f1e0db47c5aed80394e9df5430a", "patch": "@@ -16,6 +16,7 @@ use rustc_session::lint::{\n     Lint,\n };\n use rustc_span::hygiene::MacroKind;\n+use rustc_span::symbol::sym;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n@@ -234,6 +235,56 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }\n     }\n \n+    fn resolve_primitive_associated_item(\n+        &self,\n+        prim_ty: hir::PrimTy,\n+        ns: Namespace,\n+        module_id: DefId,\n+        item_name: Symbol,\n+        item_str: &'path str,\n+    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n+        let cx = self.cx;\n+\n+        PrimitiveType::from_hir(prim_ty)\n+            .impls(cx.tcx)\n+            .into_iter()\n+            .find_map(|&impl_| {\n+                cx.tcx\n+                    .associated_items(impl_)\n+                    .find_by_name_and_namespace(\n+                        cx.tcx,\n+                        Ident::with_dummy_span(item_name),\n+                        ns,\n+                        impl_,\n+                    )\n+                    .map(|item| match item.kind {\n+                        ty::AssocKind::Fn => \"method\",\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                    })\n+                    .map(|out| {\n+                        (\n+                            Res::PrimTy(prim_ty),\n+                            Some(format!(\"{}#{}.{}\", prim_ty.name(), out, item_str)),\n+                        )\n+                    })\n+            })\n+            .ok_or_else(|| {\n+                debug!(\n+                    \"returning primitive error for {}::{} in {} namespace\",\n+                    prim_ty.name(),\n+                    item_name,\n+                    ns.descr()\n+                );\n+                ResolutionFailure::NotResolved {\n+                    module_id,\n+                    partial_res: Some(Res::PrimTy(prim_ty)),\n+                    unresolved: item_str.into(),\n+                }\n+                .into()\n+            })\n+    }\n+\n     /// Resolves a string as a macro.\n     fn macro_resolve(\n         &self,\n@@ -275,6 +326,19 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         })\n     }\n \n+    fn resolve_path(&self, path_str: &str, ns: Namespace, module_id: DefId) -> Option<Res> {\n+        let result = self.cx.enter_resolver(|resolver| {\n+            resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n+        });\n+        debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n+        match result.map(|(_, res)| res) {\n+            // resolver doesn't know about true and false so we'll have to resolve them\n+            // manually as bool\n+            Ok(Res::Err) | Err(()) => is_bool_value(path_str, ns).map(|(_, res)| res),\n+            Ok(res) => Some(res.map_id(|_| panic!(\"unexpected node_id\"))),\n+        }\n+    }\n+\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n     fn resolve<'path>(\n@@ -287,22 +351,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n-        let result = cx.enter_resolver(|resolver| {\n-            resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n-        });\n-        debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n-        let result = match result {\n-            Ok((_, Res::Err)) => Err(()),\n-            x => x,\n-        };\n-\n-        if let Ok((_, res)) = result {\n-            let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-            // In case this is a trait item, skip the\n-            // early return and try looking for the trait.\n-            let value = match res {\n-                Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => true,\n-                Res::Def(DefKind::AssocTy, _) => false,\n+        if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n+            match res {\n+                Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => {\n+                    assert_eq!(ns, ValueNS);\n+                    // Fall through: In case this is a trait item, skip the\n+                    // early return and try looking for the trait.\n+                }\n+                Res::Def(DefKind::AssocTy, _) => {\n+                    assert_eq!(ns, TypeNS);\n+                    // Fall through: In case this is a trait item, skip the\n+                    // early return and try looking for the trait.\n+                }\n                 Res::Def(DefKind::Variant, _) => {\n                     return handle_variant(cx, res, extra_fragment);\n                 }\n@@ -321,17 +381,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 _ => {\n                     return Ok((res, extra_fragment.clone()));\n                 }\n-            };\n-\n-            if value != (ns == ValueNS) {\n-                return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n-            }\n-        // FIXME: why is this necessary?\n-        } else if let Some((path, prim)) = is_primitive(path_str, ns) {\n-            if extra_fragment.is_some() {\n-                return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(prim)));\n             }\n-            return Ok((prim, Some(path.to_owned())));\n         }\n \n         // Try looking for methods and associated items.\n@@ -359,70 +409,30 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n             })?;\n \n-        if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n-            let impls =\n-                primitive_impl(cx, &path).ok_or_else(|| ResolutionFailure::NotResolved {\n+        // FIXME: are these both necessary?\n+        let ty_res = if let Some(ty_res) = is_primitive(&path_root, TypeNS)\n+            .map(|(_, res)| res)\n+            .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n+        {\n+            ty_res\n+        } else {\n+            // FIXME: this is duplicated on the end of this function.\n+            return if ns == Namespace::ValueNS {\n+                self.variant_field(path_str, current_item, module_id)\n+            } else {\n+                Err(ResolutionFailure::NotResolved {\n                     module_id,\n-                    partial_res: Some(prim),\n-                    unresolved: item_str.into(),\n-                })?;\n-            for &impl_ in impls {\n-                let link = cx\n-                    .tcx\n-                    .associated_items(impl_)\n-                    .find_by_name_and_namespace(\n-                        cx.tcx,\n-                        Ident::with_dummy_span(item_name),\n-                        ns,\n-                        impl_,\n-                    )\n-                    .map(|item| match item.kind {\n-                        ty::AssocKind::Fn => \"method\",\n-                        ty::AssocKind::Const => \"associatedconstant\",\n-                        ty::AssocKind::Type => \"associatedtype\",\n-                    })\n-                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_str))));\n-                if let Some(link) = link {\n-                    return Ok(link);\n+                    partial_res: None,\n+                    unresolved: path_root.into(),\n                 }\n-            }\n-            debug!(\n-                \"returning primitive error for {}::{} in {} namespace\",\n-                path,\n-                item_name,\n-                ns.descr()\n-            );\n-            return Err(ResolutionFailure::NotResolved {\n-                module_id,\n-                partial_res: Some(prim),\n-                unresolved: item_str.into(),\n-            }\n-            .into());\n-        }\n-\n-        let ty_res = cx\n-            .enter_resolver(|resolver| {\n-                // only types can have associated items\n-                resolver.resolve_str_path_error(DUMMY_SP, &path_root, TypeNS, module_id)\n-            })\n-            .map(|(_, res)| res);\n-        let ty_res = match ty_res {\n-            Err(()) | Ok(Res::Err) => {\n-                return if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, current_item, module_id)\n-                } else {\n-                    Err(ResolutionFailure::NotResolved {\n-                        module_id,\n-                        partial_res: None,\n-                        unresolved: path_root.into(),\n-                    }\n-                    .into())\n-                };\n-            }\n-            Ok(res) => res,\n+                .into())\n+            };\n         };\n-        let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n+\n         let res = match ty_res {\n+            Res::PrimTy(prim) => Some(\n+                self.resolve_primitive_associated_item(prim, ns, module_id, item_name, item_str),\n+            ),\n             Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias, did) => {\n                 debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                 // Checks if item_name belongs to `impl SomeItem`\n@@ -462,7 +472,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     Some(if extra_fragment.is_some() {\n                         Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n                     } else {\n-                        // HACK(jynelson): `clean` expects the type, not the associated item.\n+                        // HACK(jynelson): `clean` expects the type, not the associated item\n                         // but the disambiguator logic expects the associated item.\n                         // Store the kind in a side channel so that only the disambiguator logic looks at it.\n                         self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n@@ -508,13 +518,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         _ => None,\n                     }\n                 } else {\n-                    // We already know this isn't in ValueNS, so no need to check variant_field\n-                    return Err(ResolutionFailure::NotResolved {\n-                        module_id,\n-                        partial_res: Some(ty_res),\n-                        unresolved: item_str.into(),\n-                    }\n-                    .into());\n+                    None\n                 }\n             }\n             Res::Def(DefKind::Trait, did) => cx\n@@ -571,30 +575,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         current_item: &Option<String>,\n         extra_fragment: &Option<String>,\n     ) -> Option<Res> {\n-        let check_full_res_inner = |this: &Self, result: Result<Res, ErrorKind<'_>>| {\n-            let res = match result {\n-                Ok(res) => Some(res),\n-                Err(ErrorKind::Resolve(box kind)) => kind.full_res(),\n-                Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res))) => {\n-                    Some(res)\n-                }\n-                Err(ErrorKind::AnchorFailure(AnchorFailure::MultipleAnchors)) => None,\n-            };\n-            this.kind_side_channel.take().map(|(kind, id)| Res::Def(kind, id)).or(res)\n-        };\n-        // cannot be used for macro namespace\n-        let check_full_res = |this: &Self, ns| {\n-            let result = this.resolve(path_str, ns, current_item, module_id, extra_fragment);\n-            check_full_res_inner(this, result.map(|(res, _)| res))\n+        // resolve() can't be used for macro namespace\n+        let result = match ns {\n+            Namespace::MacroNS => self.macro_resolve(path_str, module_id).map_err(ErrorKind::from),\n+            Namespace::TypeNS | Namespace::ValueNS => self\n+                .resolve(path_str, ns, current_item, module_id, extra_fragment)\n+                .map(|(res, _)| res),\n         };\n-        let check_full_res_macro = |this: &Self| {\n-            let result = this.macro_resolve(path_str, module_id);\n-            check_full_res_inner(this, result.map_err(ErrorKind::from))\n+\n+        let res = match result {\n+            Ok(res) => Some(res),\n+            Err(ErrorKind::Resolve(box kind)) => kind.full_res(),\n+            Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res))) => Some(res),\n+            Err(ErrorKind::AnchorFailure(AnchorFailure::MultipleAnchors)) => None,\n         };\n-        match ns {\n-            Namespace::MacroNS => check_full_res_macro(self),\n-            Namespace::TypeNS | Namespace::ValueNS => check_full_res(self, ns),\n-        }\n+        self.kind_side_channel.take().map(|(kind, id)| Res::Def(kind, id)).or(res)\n     }\n }\n \n@@ -1095,7 +1090,7 @@ impl LinkCollector<'_, '_> {\n                         return None;\n                     }\n                     res = prim;\n-                    fragment = Some(path.to_owned());\n+                    fragment = Some(path.as_str().to_string());\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n@@ -1952,55 +1947,57 @@ fn handle_variant(\n     if extra_fragment.is_some() {\n         return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res)));\n     }\n-    let parent = if let Some(parent) = cx.tcx.parent(res.def_id()) {\n-        parent\n-    } else {\n-        return Err(ResolutionFailure::NoParentItem.into());\n-    };\n-    let parent_def = Res::Def(DefKind::Enum, parent);\n-    let variant = cx.tcx.expect_variant_res(res);\n-    Ok((parent_def, Some(format!(\"variant.{}\", variant.ident.name))))\n+    cx.tcx\n+        .parent(res.def_id())\n+        .map(|parent| {\n+            let parent_def = Res::Def(DefKind::Enum, parent);\n+            let variant = cx.tcx.expect_variant_res(res);\n+            (parent_def, Some(format!(\"variant.{}\", variant.ident.name)))\n+        })\n+        .ok_or_else(|| ResolutionFailure::NoParentItem.into())\n }\n \n-const PRIMITIVES: &[(&str, Res)] = &[\n-    (\"u8\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U8))),\n-    (\"u16\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U16))),\n-    (\"u32\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U32))),\n-    (\"u64\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U64))),\n-    (\"u128\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U128))),\n-    (\"usize\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::Usize))),\n-    (\"i8\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I8))),\n-    (\"i16\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I16))),\n-    (\"i32\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I32))),\n-    (\"i64\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I64))),\n-    (\"i128\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I128))),\n-    (\"isize\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::Isize))),\n-    (\"f32\", Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F32))),\n-    (\"f64\", Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F64))),\n-    (\"str\", Res::PrimTy(hir::PrimTy::Str)),\n-    (\"bool\", Res::PrimTy(hir::PrimTy::Bool)),\n-    (\"true\", Res::PrimTy(hir::PrimTy::Bool)),\n-    (\"false\", Res::PrimTy(hir::PrimTy::Bool)),\n-    (\"char\", Res::PrimTy(hir::PrimTy::Char)),\n+// FIXME: At this point, this is basically a copy of the PrimitiveTypeTable\n+const PRIMITIVES: &[(Symbol, Res)] = &[\n+    (sym::u8, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U8))),\n+    (sym::u16, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U16))),\n+    (sym::u32, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U32))),\n+    (sym::u64, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U64))),\n+    (sym::u128, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U128))),\n+    (sym::usize, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::Usize))),\n+    (sym::i8, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I8))),\n+    (sym::i16, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I16))),\n+    (sym::i32, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I32))),\n+    (sym::i64, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I64))),\n+    (sym::i128, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I128))),\n+    (sym::isize, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::Isize))),\n+    (sym::f32, Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F32))),\n+    (sym::f64, Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F64))),\n+    (sym::str, Res::PrimTy(hir::PrimTy::Str)),\n+    (sym::bool, Res::PrimTy(hir::PrimTy::Bool)),\n+    (sym::char, Res::PrimTy(hir::PrimTy::Char)),\n ];\n \n-fn is_primitive(path_str: &str, ns: Namespace) -> Option<(&'static str, Res)> {\n-    if ns == TypeNS {\n-        PRIMITIVES\n-            .iter()\n-            .filter(|x| x.0 == path_str)\n-            .copied()\n-            .map(|x| if x.0 == \"true\" || x.0 == \"false\" { (\"bool\", x.1) } else { x })\n-            .next()\n+fn is_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n+    is_bool_value(path_str, ns).or_else(|| {\n+        if ns == TypeNS {\n+            // FIXME: this should be replaced by a lookup in PrimitiveTypeTable\n+            let maybe_primitive = Symbol::intern(path_str);\n+            PRIMITIVES.iter().find(|x| x.0 == maybe_primitive).copied()\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+fn is_bool_value(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n+    if ns == TypeNS && (path_str == \"true\" || path_str == \"false\") {\n+        Some((sym::bool, Res::PrimTy(hir::PrimTy::Bool)))\n     } else {\n         None\n     }\n }\n \n-fn primitive_impl(cx: &DocContext<'_>, path_str: &str) -> Option<&'static SmallVec<[DefId; 4]>> {\n-    Some(PrimitiveType::from_symbol(Symbol::intern(path_str))?.impls(cx.tcx))\n-}\n-\n fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<'static>> {\n     let mut stripped_segments = vec![];\n     let mut path = path_str.chars().peekable();"}, {"sha": "f63435337cfbcaed8da4705a1b314460da85e75d", "filename": "src/test/rustdoc-ui/intra-links-ambiguity.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c38f001db5e16f1e0db47c5aed80394e9df5430a/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c38f001db5e16f1e0db47c5aed80394e9df5430a/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.rs?ref=c38f001db5e16f1e0db47c5aed80394e9df5430a", "patch": "@@ -34,3 +34,7 @@ pub mod foo {\n ///\n /// Ambiguous non-implied shortcut link [`foo::bar`]. //~ERROR `foo::bar`\n pub struct Docs {}\n+\n+/// [true] //~ ERROR `true` is both a module and a builtin type\n+/// [primitive@true]\n+pub mod r#true {}"}, {"sha": "21b92a9673755bbea2d24d516478d8f2628bc8ec", "filename": "src/test/rustdoc-ui/intra-links-ambiguity.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c38f001db5e16f1e0db47c5aed80394e9df5430a/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c38f001db5e16f1e0db47c5aed80394e9df5430a/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr?ref=c38f001db5e16f1e0db47c5aed80394e9df5430a", "patch": "@@ -82,5 +82,20 @@ help: to link to the function, add parentheses\n LL | /// Ambiguous non-implied shortcut link [`foo::bar()`].\n    |                                          ^^^^^^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: `true` is both a module and a builtin type\n+  --> $DIR/intra-links-ambiguity.rs:38:6\n+   |\n+LL | /// [true]\n+   |      ^^^^ ambiguous link\n+   |\n+help: to link to the module, prefix with `mod@`\n+   |\n+LL | /// [mod@true]\n+   |      ^^^^^^^^\n+help: to link to the builtin type, prefix with `prim@`\n+   |\n+LL | /// [prim@true]\n+   |      ^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "3041ff77684ca1401f91661c976bd3fcadb6eeea", "filename": "src/test/rustdoc/primitive-link.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c38f001db5e16f1e0db47c5aed80394e9df5430a/src%2Ftest%2Frustdoc%2Fprimitive-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c38f001db5e16f1e0db47c5aed80394e9df5430a/src%2Ftest%2Frustdoc%2Fprimitive-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-link.rs?ref=c38f001db5e16f1e0db47c5aed80394e9df5430a", "patch": "@@ -7,8 +7,7 @@\n // @has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.i32.html\"]' 'std::primitive::i32'\n // @has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\"]' 'std::primitive::str'\n \n-// FIXME: this doesn't resolve\n-// @ has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.i32.html#associatedconstant.MAX\"]' 'std::primitive::i32::MAX'\n+// @has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.i32.html#associatedconstant.MAX\"]' 'std::primitive::i32::MAX'\n \n /// It contains [`u32`] and [i64].\n /// It also links to [std::primitive::i32], [std::primitive::str],"}]}