{"sha": "f320af4d63302d2933b37794826f705f13caf8a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMjBhZjRkNjMzMDJkMjkzM2IzNzc5NDgyNmY3MDVmMTNjYWY4YTA=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-01-20T16:06:47Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-01-20T16:06:47Z"}, "message": "Implement Syntax Highlight inside Macro", "tree": {"sha": "f0f91857370da8b07f293c05d4f918b3197c1c35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0f91857370da8b07f293c05d4f918b3197c1c35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f320af4d63302d2933b37794826f705f13caf8a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f320af4d63302d2933b37794826f705f13caf8a0", "html_url": "https://github.com/rust-lang/rust/commit/f320af4d63302d2933b37794826f705f13caf8a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f320af4d63302d2933b37794826f705f13caf8a0/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "648241ee930de08ba70b0b5c2172dfb3cc7a34c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/648241ee930de08ba70b0b5c2172dfb3cc7a34c6", "html_url": "https://github.com/rust-lang/rust/commit/648241ee930de08ba70b0b5c2172dfb3cc7a34c6"}], "stats": {"total": 319, "additions": 208, "deletions": 111}, "files": [{"sha": "831438c09b1ab9edacd50f84af8451feb2b9b56e", "filename": "crates/ra_ide/src/expand.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f320af4d63302d2933b37794826f705f13caf8a0/crates%2Fra_ide%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f320af4d63302d2933b37794826f705f13caf8a0/crates%2Fra_ide%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand.rs?ref=f320af4d63302d2933b37794826f705f13caf8a0", "patch": "@@ -79,6 +79,14 @@ pub(crate) fn descend_into_macros(\n     let source_analyzer =\n         hir::SourceAnalyzer::new(db, src.with_value(src.value.parent()).as_ref(), None);\n \n+    descend_into_macros_with_analyzer(db, &source_analyzer, src)\n+}\n+\n+pub(crate) fn descend_into_macros_with_analyzer(\n+    db: &RootDatabase,\n+    source_analyzer: &hir::SourceAnalyzer,\n+    src: InFile<SyntaxToken>,\n+) -> InFile<SyntaxToken> {\n     successors(Some(src), |token| {\n         let macro_call = token.value.ancestors().find_map(ast::MacroCall::cast)?;\n         let tt = macro_call.token_tree()?;"}, {"sha": "1cc55e78b51eadb02b057bb3b10b4484860b2e86", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f320af4d63302d2933b37794826f705f13caf8a0/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/f320af4d63302d2933b37794826f705f13caf8a0/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=f320af4d63302d2933b37794826f705f13caf8a0", "patch": "@@ -34,6 +34,16 @@\n     <span class=\"function\">foo</span>::&lt;<span class=\"type.builtin\">i32</span>&gt;();\n }\n \n+<span class=\"macro\">macro_rules</span><span class=\"macro\">!</span> def_fn {\n+    ($($tt:tt)*) =&gt; {$($tt)*}\n+}\n+\n+<span class=\"macro\">def_fn</span><span class=\"macro\">!</span>{\n+    <span class=\"keyword\">fn</span> <span class=\"function\">bar</span>() -&gt; <span class=\"type.builtin\">u32</span> {\n+        <span class=\"literal.numeric\">100</span>\n+    }\n+}\n+\n <span class=\"comment\">// comment</span>\n <span class=\"keyword\">fn</span> <span class=\"function\">main</span>() {\n     <span class=\"macro\">println</span><span class=\"macro\">!</span>(<span class=\"string\">\"Hello, {}!\"</span>, <span class=\"literal.numeric\">92</span>);"}, {"sha": "918fd4b97879bcbb035c4c180b03cf90b97ed2df", "filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f320af4d63302d2933b37794826f705f13caf8a0/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/f320af4d63302d2933b37794826f705f13caf8a0/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=f320af4d63302d2933b37794826f705f13caf8a0", "patch": "@@ -24,14 +24,14 @@\n .keyword\\.control  { color: #F0DFAF; font-weight: bold; }\n </style>\n <pre><code><span class=\"keyword\">fn</span> <span class=\"function\">main</span>() {\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"14702933417323009544\" style=\"color: hsl(108,90%,49%);\">x</span> = <span class=\"variable\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span>.to_string();\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"5443150872754369068\" style=\"color: hsl(215,43%,43%);\">y</span> = <span class=\"variable\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span>.to_string();\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"2217585909179791122\" style=\"color: hsl(280,74%,48%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"4303609361109701698\" style=\"color: hsl(242,75%,88%);\">x</span> = <span class=\"variable\" data-binding-hash=\"2217585909179791122\" style=\"color: hsl(280,74%,48%);\">hello</span>.to_string();\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"13865792086344377029\" style=\"color: hsl(340,64%,86%);\">y</span> = <span class=\"variable\" data-binding-hash=\"2217585909179791122\" style=\"color: hsl(280,74%,48%);\">hello</span>.to_string();\n \n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"17358108296605513516\" style=\"color: hsl(331,46%,60%);\">x</span> = <span class=\"string\">\"other color please!\"</span>;\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"2073121142529774969\" style=\"color: hsl(320,43%,74%);\">y</span> = <span class=\"variable\" data-binding-hash=\"17358108296605513516\" style=\"color: hsl(331,46%,60%);\">x</span>.to_string();\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"7011301204224269512\" style=\"color: hsl(198,45%,40%);\">x</span> = <span class=\"string\">\"other color please!\"</span>;\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"12461245066629867975\" style=\"color: hsl(132,91%,68%);\">y</span> = <span class=\"variable\" data-binding-hash=\"7011301204224269512\" style=\"color: hsl(198,45%,40%);\">x</span>.to_string();\n }\n \n <span class=\"keyword\">fn</span> <span class=\"function\">bar</span>() {\n-    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable.mut\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n+    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable.mut\" data-binding-hash=\"2217585909179791122\" style=\"color: hsl(280,74%,48%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n }</code></pre>\n\\ No newline at end of file"}, {"sha": "530b984fc5190b9a486de4081dd36c6245d64b2b", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 184, "deletions": 105, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/f320af4d63302d2933b37794826f705f13caf8a0/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f320af4d63302d2933b37794826f705f13caf8a0/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=f320af4d63302d2933b37794826f705f13caf8a0", "patch": "@@ -1,14 +1,18 @@\n //! FIXME: write short doc here\n \n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n \n-use hir::{InFile, Name, SourceBinder};\n+use hir::{HirFileId, InFile, Name, SourceAnalyzer, SourceBinder};\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n-use ra_syntax::{ast, AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxKind::*, TextRange, T};\n+use ra_syntax::{\n+    ast, AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxKind::*, SyntaxToken, TextRange,\n+    WalkEvent, T,\n+};\n \n use crate::{\n     db::RootDatabase,\n+    expand::descend_into_macros_with_analyzer,\n     references::{\n         classify_name, classify_name_ref,\n         NameKind::{self, *},\n@@ -72,121 +76,186 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n     let parse = db.parse(file_id);\n     let root = parse.tree().syntax().clone();\n \n-    fn calc_binding_hash(file_id: FileId, name: &Name, shadow_count: u32) -> u64 {\n-        fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n-            use std::{collections::hash_map::DefaultHasher, hash::Hasher};\n+    let mut sb = SourceBinder::new(db);\n+    let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n+    let mut res = Vec::new();\n+    let analyzer = sb.analyze(InFile::new(file_id.into(), &root), None);\n \n-            let mut hasher = DefaultHasher::new();\n-            x.hash(&mut hasher);\n-            hasher.finish()\n+    let mut in_macro_call = None;\n+\n+    for event in root.preorder_with_tokens() {\n+        match event {\n+            WalkEvent::Enter(node) => match node.kind() {\n+                MACRO_CALL => {\n+                    in_macro_call = Some(node.clone());\n+                    if let Some(range) = highlight_macro(InFile::new(file_id.into(), node)) {\n+                        res.push(HighlightedRange { range, tag: tags::MACRO, binding_hash: None });\n+                    }\n+                }\n+                _ if in_macro_call.is_some() => {\n+                    if let Some(token) = node.as_token() {\n+                        if let Some((tag, binding_hash)) = highlight_token_tree(\n+                            db,\n+                            &mut sb,\n+                            &analyzer,\n+                            &mut bindings_shadow_count,\n+                            InFile::new(file_id.into(), token.clone()),\n+                        ) {\n+                            res.push(HighlightedRange {\n+                                range: node.text_range(),\n+                                tag,\n+                                binding_hash,\n+                            });\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    if let Some((tag, binding_hash)) = highlight_node(\n+                        db,\n+                        &mut sb,\n+                        &mut bindings_shadow_count,\n+                        InFile::new(file_id.into(), node.clone()),\n+                    ) {\n+                        res.push(HighlightedRange { range: node.text_range(), tag, binding_hash });\n+                    }\n+                }\n+            },\n+            WalkEvent::Leave(node) => {\n+                if let Some(m) = in_macro_call.as_ref() {\n+                    if *m == node {\n+                        in_macro_call = None;\n+                    }\n+                }\n+            }\n         }\n+    }\n \n-        hash((file_id, name, shadow_count))\n+    res\n+}\n+\n+fn highlight_macro(node: InFile<SyntaxElement>) -> Option<TextRange> {\n+    let macro_call = ast::MacroCall::cast(node.value.as_node()?.clone())?;\n+    let path = macro_call.path()?;\n+    let name_ref = path.segment()?.name_ref()?;\n+\n+    let range_start = name_ref.syntax().text_range().start();\n+    let mut range_end = name_ref.syntax().text_range().end();\n+    for sibling in path.syntax().siblings_with_tokens(Direction::Next) {\n+        match sibling.kind() {\n+            T![!] | IDENT => range_end = sibling.text_range().end(),\n+            _ => (),\n+        }\n     }\n \n-    let mut sb = SourceBinder::new(db);\n+    Some(TextRange::from_to(range_start, range_end))\n+}\n \n-    // Visited nodes to handle highlighting priorities\n-    // FIXME: retain only ranges here\n-    let mut highlighted: FxHashSet<SyntaxElement> = FxHashSet::default();\n-    let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n+fn highlight_token_tree(\n+    db: &RootDatabase,\n+    sb: &mut SourceBinder<RootDatabase>,\n+    analyzer: &SourceAnalyzer,\n+    bindings_shadow_count: &mut FxHashMap<Name, u32>,\n+    token: InFile<SyntaxToken>,\n+) -> Option<(&'static str, Option<u64>)> {\n+    if token.value.parent().kind() != TOKEN_TREE {\n+        return None;\n+    }\n+    let token = descend_into_macros_with_analyzer(db, analyzer, token);\n+    let expanded = {\n+        let parent = token.value.parent();\n+        // We only care Name and Name_ref\n+        match (token.value.kind(), parent.kind()) {\n+            (IDENT, NAME) | (IDENT, NAME_REF) => token.with_value(parent.into()),\n+            _ => token.map(|it| it.into()),\n+        }\n+    };\n \n-    let mut res = Vec::new();\n-    for node in root.descendants_with_tokens() {\n-        if highlighted.contains(&node) {\n-            continue;\n+    highlight_node(db, sb, bindings_shadow_count, expanded)\n+}\n+\n+fn highlight_node(\n+    db: &RootDatabase,\n+    sb: &mut SourceBinder<RootDatabase>,\n+    bindings_shadow_count: &mut FxHashMap<Name, u32>,\n+    node: InFile<SyntaxElement>,\n+) -> Option<(&'static str, Option<u64>)> {\n+    let mut binding_hash = None;\n+    let tag = match node.value.kind() {\n+        FN_DEF => {\n+            bindings_shadow_count.clear();\n+            return None;\n         }\n-        let mut binding_hash = None;\n-        let tag = match node.kind() {\n-            FN_DEF => {\n-                bindings_shadow_count.clear();\n-                continue;\n-            }\n-            COMMENT => tags::LITERAL_COMMENT,\n-            STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => tags::LITERAL_STRING,\n-            ATTR => tags::LITERAL_ATTRIBUTE,\n-            // Special-case field init shorthand\n-            NAME_REF if node.parent().and_then(ast::RecordField::cast).is_some() => tags::FIELD,\n-            NAME_REF if node.ancestors().any(|it| it.kind() == ATTR) => continue,\n-            NAME_REF => {\n-                let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n-                let name_kind = classify_name_ref(&mut sb, InFile::new(file_id.into(), &name_ref))\n-                    .map(|d| d.kind);\n-                match name_kind {\n-                    Some(name_kind) => {\n-                        if let Local(local) = &name_kind {\n-                            if let Some(name) = local.name(db) {\n-                                let shadow_count =\n-                                    bindings_shadow_count.entry(name.clone()).or_default();\n-                                binding_hash =\n-                                    Some(calc_binding_hash(file_id, &name, *shadow_count))\n-                            }\n-                        };\n-\n-                        highlight_name(db, name_kind)\n-                    }\n-                    _ => continue,\n-                }\n-            }\n-            NAME => {\n-                let name = node.as_node().cloned().and_then(ast::Name::cast).unwrap();\n-                let name_kind =\n-                    classify_name(&mut sb, InFile::new(file_id.into(), &name)).map(|d| d.kind);\n-\n-                if let Some(Local(local)) = &name_kind {\n-                    if let Some(name) = local.name(db) {\n-                        let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n-                        *shadow_count += 1;\n-                        binding_hash = Some(calc_binding_hash(file_id, &name, *shadow_count))\n-                    }\n-                };\n-\n-                match name_kind {\n-                    Some(name_kind) => highlight_name(db, name_kind),\n-                    None => name.syntax().parent().map_or(tags::FUNCTION, |x| match x.kind() {\n-                        STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => tags::TYPE,\n-                        TYPE_PARAM => tags::TYPE_PARAM,\n-                        RECORD_FIELD_DEF => tags::FIELD,\n-                        _ => tags::FUNCTION,\n-                    }),\n+        COMMENT => tags::LITERAL_COMMENT,\n+        STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => tags::LITERAL_STRING,\n+        ATTR => tags::LITERAL_ATTRIBUTE,\n+        // Special-case field init shorthand\n+        NAME_REF if node.value.parent().and_then(ast::RecordField::cast).is_some() => tags::FIELD,\n+        NAME_REF if node.value.ancestors().any(|it| it.kind() == ATTR) => return None,\n+        NAME_REF => {\n+            let name_ref = node.value.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n+            let name_kind = classify_name_ref(sb, node.with_value(&name_ref)).map(|d| d.kind);\n+            match name_kind {\n+                Some(name_kind) => {\n+                    if let Local(local) = &name_kind {\n+                        if let Some(name) = local.name(db) {\n+                            let shadow_count =\n+                                bindings_shadow_count.entry(name.clone()).or_default();\n+                            binding_hash =\n+                                Some(calc_binding_hash(node.file_id, &name, *shadow_count))\n+                        }\n+                    };\n+\n+                    highlight_name(db, name_kind)\n                 }\n+                _ => return None,\n             }\n-            INT_NUMBER | FLOAT_NUMBER => tags::LITERAL_NUMERIC,\n-            BYTE => tags::LITERAL_BYTE,\n-            CHAR => tags::LITERAL_CHAR,\n-            LIFETIME => tags::TYPE_LIFETIME,\n-            T![unsafe] => tags::KEYWORD_UNSAFE,\n-            k if is_control_keyword(k) => tags::KEYWORD_CONTROL,\n-            k if k.is_keyword() => tags::KEYWORD,\n-            _ => {\n-                if let Some(macro_call) = node.as_node().cloned().and_then(ast::MacroCall::cast) {\n-                    if let Some(path) = macro_call.path() {\n-                        if let Some(segment) = path.segment() {\n-                            if let Some(name_ref) = segment.name_ref() {\n-                                highlighted.insert(name_ref.syntax().clone().into());\n-                                let range_start = name_ref.syntax().text_range().start();\n-                                let mut range_end = name_ref.syntax().text_range().end();\n-                                for sibling in path.syntax().siblings_with_tokens(Direction::Next) {\n-                                    match sibling.kind() {\n-                                        T![!] | IDENT => range_end = sibling.text_range().end(),\n-                                        _ => (),\n-                                    }\n-                                }\n-                                res.push(HighlightedRange {\n-                                    range: TextRange::from_to(range_start, range_end),\n-                                    tag: tags::MACRO,\n-                                    binding_hash: None,\n-                                })\n-                            }\n-                        }\n-                    }\n+        }\n+        NAME => {\n+            let name = node.value.as_node().cloned().and_then(ast::Name::cast).unwrap();\n+            let name_kind = classify_name(sb, node.with_value(&name)).map(|d| d.kind);\n+\n+            if let Some(Local(local)) = &name_kind {\n+                if let Some(name) = local.name(db) {\n+                    let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n+                    *shadow_count += 1;\n+                    binding_hash = Some(calc_binding_hash(node.file_id, &name, *shadow_count))\n                 }\n-                continue;\n+            };\n+\n+            match name_kind {\n+                Some(name_kind) => highlight_name(db, name_kind),\n+                None => name.syntax().parent().map_or(tags::FUNCTION, |x| match x.kind() {\n+                    STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => tags::TYPE,\n+                    TYPE_PARAM => tags::TYPE_PARAM,\n+                    RECORD_FIELD_DEF => tags::FIELD,\n+                    _ => tags::FUNCTION,\n+                }),\n             }\n-        };\n-        res.push(HighlightedRange { range: node.text_range(), tag, binding_hash })\n+        }\n+        INT_NUMBER | FLOAT_NUMBER => tags::LITERAL_NUMERIC,\n+        BYTE => tags::LITERAL_BYTE,\n+        CHAR => tags::LITERAL_CHAR,\n+        LIFETIME => tags::TYPE_LIFETIME,\n+        T![unsafe] => tags::KEYWORD_UNSAFE,\n+        k if is_control_keyword(k) => tags::KEYWORD_CONTROL,\n+        k if k.is_keyword() => tags::KEYWORD,\n+\n+        _ => return None,\n+    };\n+\n+    return Some((tag, binding_hash));\n+\n+    fn calc_binding_hash(file_id: HirFileId, name: &Name, shadow_count: u32) -> u64 {\n+        fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n+            use std::{collections::hash_map::DefaultHasher, hash::Hasher};\n+\n+            let mut hasher = DefaultHasher::new();\n+            x.hash(&mut hasher);\n+            hasher.finish()\n+        }\n+\n+        hash((file_id, name, shadow_count))\n     }\n-    res\n }\n \n pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: bool) -> String {\n@@ -331,6 +400,16 @@ fn foo<T>() -> T {\n     foo::<i32>();\n }\n \n+macro_rules! def_fn {\n+    ($($tt:tt)*) => {$($tt)*}\n+}\n+\n+def_fn!{\n+    fn bar() -> u32 {\n+        100\n+    }\n+}\n+\n // comment\n fn main() {\n     println!(\"Hello, {}!\", 92);"}]}