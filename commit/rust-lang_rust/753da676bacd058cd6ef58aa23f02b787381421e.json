{"sha": "753da676bacd058cd6ef58aa23f02b787381421e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1M2RhNjc2YmFjZDA1OGNkNmVmNThhYTIzZjAyYjc4NzM4MTQyMWU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-01-14T17:59:13Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-04-13T14:04:57Z"}, "message": "Rustup", "tree": {"sha": "70a955da8ec6a996598db8cd50e7e3f10508fd1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70a955da8ec6a996598db8cd50e7e3f10508fd1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/753da676bacd058cd6ef58aa23f02b787381421e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJgBAABCgBKFiEEvpMjxK4/cnPNfesJHVy0/Fl8MAQFAlrQuQosHGdpdC1uby1y\nZXBseS05ODc5MTY1NzE2NDc5NDEzMTMxQG9saS1vYmsuZGUACgkQHVy0/Fl8MATf\nYw//VIJjx/f9PQbPyfR6AoEnr3hmNwHutQrZ/w71gvt+GxbBsDZpdI+1MGWx4aye\nn079rqpbCZPsisfGZAlHS1uvlcYrz5KgXYgqkSYO8RWRxdhNhK1QaMt8Pf9iSPBu\nPLBSlnckS9Gq3ca0QJqe87WRMpaZEI8b+ztaYWo0dwSJbtC4BqUbrCBzY6RoV4J5\n91RVU5+4WhT8w0hsBSTnjTpOLfB3z+eQ8iMS4ppR0mdhvwrMt1Ob9rS8Zt3NTVIF\nvcZxiCn8jpHaq6dKWhkFYi1V6GlyKTwn4Vzo+G3eMzD8jW6qiTqGxRUBSomhuE6o\nZOPdo1gC2Te5CUhKBkDobeswAOrWn2O4f1NnHjIWG+9h3nLTiPu+NdJSmjkuARtZ\nV09e9GWU6OZjIlVHD8yq4zbgLFECBK2AeAzIZUrh1iqTmhiPVOtw627WFKbwhvKg\nOyp5SZO8IwUvibjUkAn953p3ivc1tsKxpJAsCJc3M7A41BWkZxvPhM9pNmw7DwxT\n71d2Gb8vmuUpEKlpgzHKQ4VjOF4WVk8JAMwp9E5u51BdLqUulWlqAoCdCLTUXtSE\n2unkUykbyBqpNR9hLLDEDVsTp+QAQsy+pqszhcc3SLKyrDBqlGf0vmt8uXWhnopR\n/Zlm8biXZD+gkJTIn4F8sIyIvcB0UhxnWbDjTPrtOFuYcDs=\n=/pvK\n-----END PGP SIGNATURE-----", "payload": "tree 70a955da8ec6a996598db8cd50e7e3f10508fd1e\nparent d289c0f46467fc8abd7b89129116e8dd959c3e34\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1515952753 +0100\ncommitter Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1523628297 +0200\n\nRustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/753da676bacd058cd6ef58aa23f02b787381421e", "html_url": "https://github.com/rust-lang/rust/commit/753da676bacd058cd6ef58aa23f02b787381421e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/753da676bacd058cd6ef58aa23f02b787381421e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d289c0f46467fc8abd7b89129116e8dd959c3e34", "url": "https://api.github.com/repos/rust-lang/rust/commits/d289c0f46467fc8abd7b89129116e8dd959c3e34", "html_url": "https://github.com/rust-lang/rust/commit/d289c0f46467fc8abd7b89129116e8dd959c3e34"}], "stats": {"total": 241, "additions": 113, "deletions": 128}, "files": [{"sha": "bbc8322194fac356a60a30a9de4d2db1a55c9687", "filename": "miri/bin/miri.rs", "status": "modified", "additions": 11, "deletions": 54, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fbin%2Fmiri.rs?ref=753da676bacd058cd6ef58aa23f02b787381421e", "patch": "@@ -5,6 +5,7 @@ extern crate miri;\n extern crate rustc;\n extern crate rustc_driver;\n extern crate rustc_errors;\n+extern crate rustc_trans_utils;\n extern crate env_logger;\n extern crate log_settings;\n extern crate syntax;\n@@ -17,7 +18,8 @@ use rustc_driver::driver::{CompileState, CompileController};\n use rustc::session::config::{self, Input, ErrorOutputType};\n use rustc::hir::{self, itemlikevisit};\n use rustc::ty::TyCtxt;\n-use syntax::ast::{self, MetaItemKind, NestedMetaItemKind};\n+use rustc_trans_utils::trans_crate::TransCrate;\n+use syntax::ast;\n use std::path::PathBuf;\n \n struct MiriCompilerCalls {\n@@ -61,14 +63,15 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n     }\n     fn late_callback(\n         &mut self,\n+        trans: &TransCrate,\n         matches: &getopts::Matches,\n         sess: &Session,\n         cstore: &CrateStore,\n         input: &Input,\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,\n     ) -> Compilation {\n-        self.default.late_callback(matches, sess, cstore, input, odir, ofile)\n+        self.default.late_callback(trans, matches, sess, cstore, input, odir, ofile)\n     }\n     fn build_controller(\n         &mut self,\n@@ -98,11 +101,9 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n     state.session.abort_if_errors();\n \n     let tcx = state.tcx.unwrap();\n-    let limits = resource_limits_from_attributes(state);\n \n     if std::env::args().any(|arg| arg == \"--test\") {\n         struct Visitor<'a, 'tcx: 'a>(\n-            miri::ResourceLimits,\n             TyCtxt<'a, 'tcx, 'tcx>,\n             &'a CompileState<'a, 'tcx>\n         );\n@@ -113,21 +114,21 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n                         attr.name().map_or(false, |n| n == \"test\")\n                     })\n                     {\n-                        let did = self.1.hir.body_owner_def_id(body_id);\n+                        let did = self.0.hir.body_owner_def_id(body_id);\n                         println!(\n                             \"running test: {}\",\n-                            self.1.def_path_debug_str(did),\n+                            self.0.def_path_debug_str(did),\n                         );\n-                        miri::eval_main(self.1, did, None, self.0);\n-                        self.2.session.abort_if_errors();\n+                        miri::eval_main(self.0, did, None);\n+                        self.1.session.abort_if_errors();\n                     }\n                 }\n             }\n             fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n             fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n         }\n         state.hir_crate.unwrap().visit_all_item_likes(\n-            &mut Visitor(limits, tcx, state),\n+            &mut Visitor(tcx, state),\n         );\n     } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n@@ -138,58 +139,14 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n                 None\n             }\n         });\n-        miri::eval_main(tcx, entry_def_id, start_wrapper, limits);\n+        miri::eval_main(tcx, entry_def_id, start_wrapper);\n \n         state.session.abort_if_errors();\n     } else {\n         println!(\"no main function found, assuming auxiliary build\");\n     }\n }\n \n-fn resource_limits_from_attributes(state: &CompileState) -> miri::ResourceLimits {\n-    let mut limits = miri::ResourceLimits::default();\n-    let krate = state.hir_crate.as_ref().unwrap();\n-    let err_msg = \"miri attributes need to be in the form `miri(key = value)`\";\n-    let extract_int = |lit: &syntax::ast::Lit| -> u128 {\n-        match lit.node {\n-            syntax::ast::LitKind::Int(i, _) => i,\n-            _ => {\n-                state.session.span_fatal(\n-                    lit.span,\n-                    \"expected an integer literal\",\n-                )\n-            }\n-        }\n-    };\n-\n-    for attr in krate.attrs.iter().filter(|a| {\n-        a.name().map_or(false, |n| n == \"miri\")\n-    })\n-    {\n-        if let Some(items) = attr.meta_item_list() {\n-            for item in items {\n-                if let NestedMetaItemKind::MetaItem(ref inner) = item.node {\n-                    if let MetaItemKind::NameValue(ref value) = inner.node {\n-                        match &inner.name().as_str()[..] {\n-                            \"memory_size\" => limits.memory_size = extract_int(value) as u64,\n-                            \"step_limit\" => limits.step_limit = extract_int(value) as u64,\n-                            \"stack_limit\" => limits.stack_limit = extract_int(value) as usize,\n-                            _ => state.session.span_err(item.span, \"unknown miri attribute\"),\n-                        }\n-                    } else {\n-                        state.session.span_err(inner.span, err_msg);\n-                    }\n-                } else {\n-                    state.session.span_err(item.span, err_msg);\n-                }\n-            }\n-        } else {\n-            state.session.span_err(attr.span, err_msg);\n-        }\n-    }\n-    limits\n-}\n-\n fn init_logger() {\n     let format = |formatter: &mut env_logger::fmt::Formatter, record: &log::Record| {\n         use std::io::Write;"}, {"sha": "d07929e0d5608285a2bfb7b505a75937565570c4", "filename": "miri/fn_call.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=753da676bacd058cd6ef58aa23f02b787381421e", "patch": "@@ -8,8 +8,6 @@ use syntax::codemap::Span;\n \n use std::mem;\n \n-use rustc::traits;\n-\n use super::*;\n \n use tls::MemoryExt;\n@@ -49,7 +47,7 @@ pub trait EvalContextExt<'tcx> {\n     fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -385,13 +383,17 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                             promoted: None,\n                         };\n                         // compute global if not cached\n-                        let val = match self.tcx.interpret_interner.borrow().get_cached(cid) {\n-                            Some(ptr) => MemoryPointer::new(ptr, 0).into(),\n-                            None => eval_body(self.tcx, instance, ty::ParamEnv::empty(traits::Reveal::All))?.0,\n+                        let value: Value = match self.tcx.interpret_interner.get_cached(instance.def_id()) {\n+                            Some(ptr) => {\n+                                Value::ByRef(MemoryPointer::new(ptr, 0).into(), name_align)\n+                            }\n+                            None => {\n+                                let res: Option<(Value, Pointer, Ty)> = eval_body(self.tcx.tcx, cid, ty::ParamEnv::reveal_all());\n+                                res.ok_or_else(||EvalErrorKind::MachineError(\"<already reported>\".to_string()))?.0\n+                            },\n                         };\n-                        let val = self.value_to_primval(ValTy { value: Value::ByRef(val, name_align),\n-                                                                ty: args[0].ty })?.to_u64()?;\n-                        if val == name {\n+                        let value = self.value_to_primval(ValTy { value, ty: args[0].ty })?.to_u64()?;\n+                        if value == name {\n                             result = Some(path_value);\n                             break;\n                         }\n@@ -420,7 +422,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 };\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_type = args[0].ty.builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                let key_type = args[0].ty.builtin_deref(true)\n                                    .ok_or(EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n                 let key_size = self.layout_of(key_type)?.size;\n \n@@ -502,7 +504,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     for item in mem::replace(&mut items, Default::default()).iter() {\n                         if item.ident.name == *segment {\n                             if path_it.peek().is_none() {\n-                                return Some(ty::Instance::mono(self.tcx, item.def.def_id()));\n+                                return Some(ty::Instance::mono(self.tcx.tcx, item.def.def_id()));\n                             }\n \n                             items = self.tcx.item_children(item.def.def_id());"}, {"sha": "3dd499f7a62e963812d979ccef605b2588c2c495", "filename": "miri/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fhelpers.rs?ref=753da676bacd058cd6ef58aa23f02b787381421e", "patch": "@@ -18,7 +18,7 @@ pub trait EvalContextExt<'tcx> {\n     ) -> EvalResult<'tcx, Pointer>;\n }\n \n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn wrapping_pointer_offset(\n         &self,\n         ptr: Pointer,"}, {"sha": "5047ab5b6ac21deace86f143d8cf99816355dc5c", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=753da676bacd058cd6ef58aa23f02b787381421e", "patch": "@@ -1,5 +1,4 @@\n use rustc::mir;\n-use rustc::traits::Reveal;\n use rustc::ty::layout::{TyLayout, LayoutOf};\n use rustc::ty;\n \n@@ -19,7 +18,7 @@ pub trait EvalContextExt<'tcx> {\n     ) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -349,7 +348,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 match dest {\n                     Place::Local { frame, local } => self.modify_local(frame, local, init)?,\n                     Place::Ptr {\n-                        ptr: ptr,\n+                        ptr,\n                         align: _align,\n                         extra: PlaceExtra::None,\n                     } => self.memory.write_repeat(ptr, 0, size)?,\n@@ -381,8 +380,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n             \"needs_drop\" => {\n                 let ty = substs.type_at(0);\n-                let env = ty::ParamEnv::empty(Reveal::All);\n-                let needs_drop = ty.needs_drop(self.tcx, env);\n+                let env = ty::ParamEnv::reveal_all();\n+                let needs_drop = ty.needs_drop(self.tcx.tcx, env);\n                 self.write_primval(\n                     dest,\n                     PrimVal::from_bool(needs_drop),\n@@ -542,10 +541,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n             \"transmute\" => {\n                 let src_ty = substs.type_at(0);\n-                let src_align = self.layout_of(src_ty)?.align;\n+                let _src_align = self.layout_of(src_ty)?.align;\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n                 let dest_align = self.layout_of(substs.type_at(1))?.align;\n-                self.write_value_to_ptr(args[0].value, ptr.into(), dest_align, src_ty);\n+                self.write_value_to_ptr(args[0].value, ptr.into(), dest_align, src_ty).unwrap();\n             }\n \n             \"unchecked_shl\" => {\n@@ -626,7 +625,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 match dest {\n                     Place::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n                     Place::Ptr {\n-                        ptr: ptr,\n+                        ptr,\n                         align: _align,\n                         extra: PlaceExtra::None,\n                     } => self.memory.mark_definedness(ptr, size, false)?,"}, {"sha": "99bc91a1717764b6bad44ad129b95028c666e668", "filename": "miri/lib.rs", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=753da676bacd058cd6ef58aa23f02b787381421e", "patch": "@@ -22,7 +22,6 @@ use rustc::ty::{self, TyCtxt};\n use rustc::ty::layout::{TyLayout, LayoutOf};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::traits;\n \n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n@@ -56,14 +55,13 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n     start_wrapper: Option<DefId>,\n-    limits: ResourceLimits,\n ) {\n-    fn run_main<'a, 'tcx: 'a>(\n-        ecx: &mut rustc_mir::interpret::EvalContext<'a, 'tcx, Evaluator<'tcx>>,\n+    fn run_main<'a, 'mir: 'a, 'tcx: 'mir>(\n+        ecx: &mut rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>,\n         main_id: DefId,\n         start_wrapper: Option<DefId>,\n     ) -> EvalResult<'tcx> {\n-        let main_instance = ty::Instance::mono(ecx.tcx, main_id);\n+        let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n         let main_mir = ecx.load_mir(main_instance.def)?;\n         let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n \n@@ -78,8 +76,8 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             let main_ret_ty = ecx.tcx.fn_sig(main_id).output();\n             let main_ret_ty = main_ret_ty.no_late_bound_regions().unwrap();\n             let start_instance = ty::Instance::resolve(\n-                ecx.tcx,\n-                ty::ParamEnv::empty(traits::Reveal::All),\n+                ecx.tcx.tcx,\n+                ty::ParamEnv::reveal_all(),\n                 start_id,\n                 ecx.tcx.mk_substs(\n                     ::std::iter::once(ty::subst::Kind::from(main_ret_ty)))).unwrap();\n@@ -112,8 +110,8 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             // First argument: pointer to main()\n             let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n             let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-            let main_ty = main_instance.ty(ecx.tcx);\n-            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx));\n+            let main_ty = main_instance.ty(ecx.tcx.tcx);\n+            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx.tcx));\n             ecx.write_value(\n                 ValTy {\n                     value: Value::ByVal(PrimVal::Ptr(main_ptr)),\n@@ -136,7 +134,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             let ptr_align = ecx.tcx.data_layout.pointer_align;\n             let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, None)?;\n             ecx.memory.write_primval(foo_ptr, ptr_align, PrimVal::Ptr(foo.into()), ptr_size, false)?;\n-            ecx.memory.mark_static_initalized(foo_ptr.alloc_id, Mutability::Immutable)?;\n+            ecx.memory.mark_static_initialized(foo_ptr.alloc_id, Mutability::Immutable)?;\n             ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n \n             assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n@@ -166,7 +164,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         Ok(())\n     }\n \n-    let mut ecx = EvalContext::new(tcx, ty::ParamEnv::empty(traits::Reveal::All), limits, Default::default(), Default::default());\n+    let mut ecx = EvalContext::new(tcx.at(syntax::codemap::DUMMY_SP), ty::ParamEnv::reveal_all(), Default::default(), Default::default());\n     match run_main(&mut ecx, main_id, start_wrapper) {\n         Ok(()) => {\n             let leaks = ecx.memory().leak_report();\n@@ -175,7 +173,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             }\n         }\n         Err(mut e) => {\n-            ecx.report(&mut e);\n+            ecx.report(&mut e, true, None);\n         }\n     }\n }\n@@ -213,13 +211,13 @@ pub struct MemoryData<'tcx> {\n     locks: HashMap<AllocId, RangeMap<LockInfo<'tcx>>>,\n }\n \n-impl<'tcx> Machine<'tcx> for Evaluator<'tcx> {\n+impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryData = MemoryData<'tcx>;\n     type MemoryKinds = memory::MemoryKind;\n \n     /// Returns Ok() when the function was handled, fail otherwise\n     fn eval_fn_call<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Place, mir::BasicBlock)>,\n         args: &[ValTy<'tcx>],\n@@ -230,7 +228,7 @@ impl<'tcx> Machine<'tcx> for Evaluator<'tcx> {\n     }\n \n     fn call_intrinsic<'a>(\n-        ecx: &mut rustc_mir::interpret::EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[ValTy<'tcx>],\n         dest: Place,\n@@ -241,7 +239,7 @@ impl<'tcx> Machine<'tcx> for Evaluator<'tcx> {\n     }\n \n     fn try_ptr_op<'a>(\n-        ecx: &rustc_mir::interpret::EvalContext<'a, 'tcx, Self>,\n+        ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: PrimVal,\n         left_ty: ty::Ty<'tcx>,\n@@ -251,25 +249,43 @@ impl<'tcx> Machine<'tcx> for Evaluator<'tcx> {\n         ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n     }\n \n-    fn mark_static_initialized(m: memory::MemoryKind) -> EvalResult<'tcx> {\n-        use memory::MemoryKind::*;\n+    fn mark_static_initialized<'a>(\n+        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n+        _id: AllocId,\n+        _mutability: Mutability,\n+    ) -> EvalResult<'tcx, bool> {\n+        /*use memory::MemoryKind::*;\n         match m {\n             // FIXME: This could be allowed, but not for env vars set during miri execution\n             Env => err!(Unimplemented(\"statics can't refer to env vars\".to_owned())),\n-            _ => Ok(()),\n-        }\n+            _ => Ok(false), // TODO: What does the bool mean?\n+        }*/\n+        Ok(true)\n+    }\n+\n+    fn init_static<'a>(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        cid: GlobalId<'tcx>,\n+    ) -> EvalResult<'tcx, AllocId> {\n+        let def_id = cid.instance.def_id();\n+        let ty = ecx.tcx.type_of(def_id);\n+        let layout = ecx.tcx.layout_of(ty::ParamEnvAnd {\n+            param_env: ty::ParamEnv::reveal_all(),\n+            value: ty\n+        }).expect(\"Couldn't compute layout for the type of a static\");\n+        ecx.memory.allocate(layout.size.bytes(), layout.align, None).map(|mptr|mptr.alloc_id)\n     }\n \n     fn box_alloc<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         ty: ty::Ty<'tcx>,\n         dest: Place,\n     ) -> EvalResult<'tcx> {\n         let layout = ecx.layout_of(ty)?;\n \n         // Call the `exchange_malloc` lang item\n         let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n-        let malloc = ty::Instance::mono(ecx.tcx, malloc);\n+        let malloc = ty::Instance::mono(ecx.tcx.tcx, malloc);\n         let malloc_mir = ecx.load_mir(malloc.def)?;\n         ecx.push_stack_frame(\n             malloc,\n@@ -311,7 +327,7 @@ impl<'tcx> Machine<'tcx> for Evaluator<'tcx> {\n     }\n \n     fn global_item_with_linkage<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         mutability: Mutability,\n     ) -> EvalResult<'tcx> {\n@@ -325,19 +341,16 @@ impl<'tcx> Machine<'tcx> for Evaluator<'tcx> {\n             None,\n         )?;\n         ecx.memory.write_ptr_sized_unsigned(ptr, ptr_align, PrimVal::Bytes(0))?;\n-        ecx.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n-        ecx.tcx.interpret_interner.borrow_mut().cache(\n-            GlobalId {\n-                instance,\n-                promoted: None,\n-            },\n+        ecx.memory.mark_static_initialized(ptr.alloc_id, mutability)?;\n+        ecx.tcx.interpret_interner.cache(\n+            instance.def_id(),\n             ptr.alloc_id,\n         );\n         Ok(())\n     }\n \n     fn check_locks<'a>(\n-        mem: &Memory<'a, 'tcx, Self>,\n+        mem: &Memory<'a, 'mir, 'tcx, Self>,\n         ptr: MemoryPointer,\n         size: u64,\n         access: AccessKind,\n@@ -346,14 +359,14 @@ impl<'tcx> Machine<'tcx> for Evaluator<'tcx> {\n     }\n \n     fn add_lock<'a>(\n-        mem: &mut Memory<'a, 'tcx, Self>,\n+        mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n         id: AllocId,\n     ) {\n         mem.data.locks.insert(id, RangeMap::new());\n     }\n \n     fn free_lock<'a>(\n-        mem: &mut Memory<'a, 'tcx, Self>,\n+        mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n         id: AllocId,\n         len: u64,\n     ) -> EvalResult<'tcx> {\n@@ -379,14 +392,14 @@ impl<'tcx> Machine<'tcx> for Evaluator<'tcx> {\n     }\n \n     fn end_region<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         reg: Option<::rustc::middle::region::Scope>,\n     ) -> EvalResult<'tcx> {\n         ecx.end_region(reg)\n     }\n \n     fn validation_op<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         op: ::rustc::mir::ValidationOp,\n         operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,\n     ) -> EvalResult<'tcx> {"}, {"sha": "677b0454a546caed2ce4f7e01f7d2670dbe37b9f", "filename": "miri/locks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flocks.rs?ref=753da676bacd058cd6ef58aa23f02b787381421e", "patch": "@@ -99,7 +99,7 @@ pub trait MemoryExt<'tcx> {\n }\n \n \n-impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n     fn check_locks(\n         &self,\n         ptr: MemoryPointer,"}, {"sha": "220f8f9acd5411c51ef75f80bf353dee2d95ea17", "filename": "miri/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Foperator.rs?ref=753da676bacd058cd6ef58aa23f02b787381421e", "patch": "@@ -24,7 +24,7 @@ pub trait EvalContextExt<'tcx> {\n     ) -> EvalResult<'tcx, (PrimVal, bool)>;\n }\n \n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n@@ -42,7 +42,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         match bin_op {\n             Offset if left_kind == Ptr && right_kind == usize => {\n                 let pointee_ty = left_ty\n-                    .builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                    .builtin_deref(true)\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset("}, {"sha": "e55cbede23394697c8fc805b801f01318cc68e06", "filename": "miri/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ftls.rs?ref=753da676bacd058cd6ef58aa23f02b787381421e", "patch": "@@ -18,7 +18,7 @@ pub trait EvalContextExt<'tcx> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n     fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.data.next_thread_local;\n         self.data.next_thread_local += 1;\n@@ -106,7 +106,7 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n     }\n }\n \n-impl<'a, 'tcx: 'a> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n         let mut dtor = self.memory.fetch_tls_dtor(None)?;\n         // FIXME: replace loop by some structure that works with stepping"}, {"sha": "801fd952f666d0882276ea6024f37b5aee1b6977", "filename": "miri/validation.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753da676bacd058cd6ef58aa23f02b787381421e/miri%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fvalidation.rs?ref=753da676bacd058cd6ef58aa23f02b787381421e", "patch": "@@ -1,15 +1,16 @@\n use rustc::hir::{self, Mutability};\n use rustc::hir::Mutability::*;\n use rustc::mir::{self, ValidationOp, ValidationOperand};\n-use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n+use rustc::mir::interpret::GlobalId;\n+use rustc::ty::{self, Ty, TypeFoldable, TyCtxt, Instance};\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::subst::{Substs, Subst};\n use rustc::traits;\n use rustc::infer::InferCtxt;\n-use rustc::traits::Reveal;\n use rustc::middle::region;\n+use rustc::middle::const_val::ConstVal;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_mir::interpret::HasMemory;\n+use rustc_mir::interpret::{HasMemory, eval_body};\n \n use super::{EvalContext, Place, PlaceExtra, ValTy};\n use rustc::mir::interpret::{DynamicLifetime, AccessKind, EvalErrorKind, Value, EvalError, EvalResult};\n@@ -108,7 +109,7 @@ pub(crate) trait EvalContextExt<'tcx> {\n     ) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn abstract_place_projection(&self, proj: &mir::PlaceProjection<'tcx>) -> EvalResult<'tcx, AbsPlaceProjection<'tcx>> {\n         use self::mir::ProjectionElem::*;\n \n@@ -117,7 +118,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             Field(f, _) => Field(f, ()),\n             Index(v) => {\n                 let value = self.frame().get_local(v)?;\n-                let ty = self.tcx.types.usize;\n+                let ty = self.tcx.tcx.types.usize;\n                 let n = self.value_to_primval(ValTy { value, ty })?.to_u64()?;\n                 Index(n)\n             },\n@@ -152,7 +153,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         // because other crates may have been compiled with mir-emit-validate > 0.  Ignore those\n         // commands.  This makes mir-emit-validate also a flag to control whether miri will do\n         // validation or not.\n-        if self.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n+        if self.tcx.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n             return Ok(());\n         }\n         debug_assert!(self.memory.cur_frame == self.cur_frame());\n@@ -187,7 +188,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n         // We need to monomorphize ty *without* erasing lifetimes\n         trace!(\"validation_op1: {:?}\", operand.ty.sty);\n-        let ty = operand.ty.subst(self.tcx, self.substs());\n+        let ty = operand.ty.subst(self.tcx.tcx, self.substs());\n         trace!(\"validation_op2: {:?}\", operand.ty.sty);\n         let place = self.eval_place(&operand.place)?;\n         let abs_place = self.abstract_place(&operand.place)?;\n@@ -250,7 +251,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n     }\n \n     fn normalize_type_unerased(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        return normalize_associated_type(self.tcx, &ty);\n+        return normalize_associated_type(self.tcx.tcx, &ty);\n \n         use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -356,7 +357,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         where\n             T: MyTransNormalize<'tcx>,\n         {\n-            let param_env = ty::ParamEnv::empty(Reveal::All);\n+            let param_env = ty::ParamEnv::reveal_all();\n \n             if !value.has_projections() {\n                 return value.clone();\n@@ -383,7 +384,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             }\n             _ => {}\n         }\n-        let tcx = self.tcx;\n+        let tcx = self.tcx.tcx;\n         Ok(match layout.ty.sty {\n             ty::TyBool |\n             ty::TyChar |\n@@ -393,6 +394,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             ty::TyFnPtr(_) |\n             ty::TyNever |\n             ty::TyFnDef(..) |\n+            ty::TyGeneratorWitness(..) |\n             ty::TyDynamic(..) |\n             ty::TyForeign(..) => {\n                 bug!(\"TyLayout::field_type({:?}): not applicable\", layout)\n@@ -437,7 +439,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 substs.field_tys(def_id, tcx).nth(i).unwrap()\n             }\n \n-            ty::TyTuple(tys, _) => tys[i],\n+            ty::TyTuple(tys) => tys[i],\n \n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n@@ -558,6 +560,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             TyAdt(adt, _) if adt.is_box() => true,\n             TySlice(_) | TyAdt(_, _) | TyTuple(..) | TyClosure(..) | TyArray(..) |\n             TyDynamic(..) | TyGenerator(..) | TyForeign(_) => false,\n+            TyGeneratorWitness(..) => bug!(\"I'm not sure what to return here\"),\n             TyParam(_) | TyInfer(_) | TyProjection(_) | TyAnon(..) | TyError => {\n                 bug!(\"I got an incomplete/unnormalized type for validation\")\n             }\n@@ -725,7 +728,18 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     Ok(())\n                 }\n                 TyArray(elem_ty, len) => {\n-                    let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+                    let len_val = match len.val {\n+                        ConstVal::Unevaluated(def_id, substs) => {\n+                            eval_body(self.tcx.tcx, GlobalId {\n+                                instance: Instance::new(def_id, substs),\n+                                promoted: None,\n+                            }, ty::ParamEnv::reveal_all())\n+                                .ok_or_else(||EvalErrorKind::MachineError(\"<already reported>\".to_string()))?\n+                                .0\n+                        }\n+                        ConstVal::Value(val) => val,\n+                    };\n+                    let len = ConstVal::Value(len_val).unwrap_u64();\n                     for i in 0..len {\n                         let inner_place = self.place_index(query.place.1, query.ty, i as u64)?;\n                         self.validate(\n@@ -759,7 +773,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     Ok(())\n                 }\n                 TyAdt(adt, _) => {\n-                    if Some(adt.did) == self.tcx.lang_items().unsafe_cell_type() &&\n+                    if Some(adt.did) == self.tcx.tcx.lang_items().unsafe_cell_type() &&\n                         query.mutbl == MutImmutable\n                     {\n                         // No locks for shared unsafe cells.  Also no other validation, the only field is private anyway.\n@@ -771,8 +785,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                             let discr = self.read_discriminant_value(query.place.1, query.ty)?;\n \n                             // Get variant index for discriminant\n-                            let variant_idx = adt.discriminants(self.tcx).position(|variant_discr| {\n-                                variant_discr.to_u128_unchecked() == discr\n+                            let variant_idx = adt.discriminants(self.tcx.tcx).position(|variant_discr| {\n+                                variant_discr.val == discr\n                             });\n                             let variant_idx = match variant_idx {\n                                 Some(val) => val,"}]}