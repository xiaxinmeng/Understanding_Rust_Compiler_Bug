{"sha": "32adc0e730636f04d72d31e24fbf1101a495ccb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyYWRjMGU3MzA2MzZmMDRkNzJkMzFlMjRmYmYxMTAxYTQ5NWNjYjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-26T22:13:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-26T22:13:37Z"}, "message": "auto merge of #7382 : msullivan/rust/cleanup, r=bblum", "tree": {"sha": "37e55a00e167489ed19118ab8436a275760fcba5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37e55a00e167489ed19118ab8436a275760fcba5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32adc0e730636f04d72d31e24fbf1101a495ccb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32adc0e730636f04d72d31e24fbf1101a495ccb7", "html_url": "https://github.com/rust-lang/rust/commit/32adc0e730636f04d72d31e24fbf1101a495ccb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32adc0e730636f04d72d31e24fbf1101a495ccb7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23fb2278c7c50cf5785b1c109bc399bf87fdd542", "url": "https://api.github.com/repos/rust-lang/rust/commits/23fb2278c7c50cf5785b1c109bc399bf87fdd542", "html_url": "https://github.com/rust-lang/rust/commit/23fb2278c7c50cf5785b1c109bc399bf87fdd542"}, {"sha": "663f29818310c7aad3b1501fe8eac6ca2379e037", "url": "https://api.github.com/repos/rust-lang/rust/commits/663f29818310c7aad3b1501fe8eac6ca2379e037", "html_url": "https://github.com/rust-lang/rust/commit/663f29818310c7aad3b1501fe8eac6ca2379e037"}], "stats": {"total": 159, "additions": 48, "deletions": 111}, "files": [{"sha": "bfc5d512b3702dfe4fbbd4c549c741f89feff550", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=32adc0e730636f04d72d31e24fbf1101a495ccb7", "patch": "@@ -24,11 +24,6 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::diagnostic::expect;\n \n-pub struct ProvidedTraitMethodInfo {\n-    ty: ty::Method,\n-    def_id: ast::def_id\n-}\n-\n pub struct StaticMethodInfo {\n     ident: ast::ident,\n     def_id: ast::def_id,\n@@ -134,7 +129,7 @@ pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,\n \n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n                                   def: ast::def_id)\n-                               -> ~[ProvidedTraitMethodInfo] {\n+                               -> ~[@ty::Method] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)"}, {"sha": "824f67b074c290e22847b26e3fd181b1c026fb83", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=32adc0e730636f04d72d31e24fbf1101a495ccb7", "patch": "@@ -14,7 +14,7 @@ use core::prelude::*;\n \n use metadata::cstore::crate_metadata;\n use metadata::common::*;\n-use metadata::csearch::{ProvidedTraitMethodInfo, StaticMethodInfo};\n+use metadata::csearch::StaticMethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n use metadata::decoder;\n@@ -752,7 +752,7 @@ pub fn get_trait_method_def_ids(cdata: cmd,\n \n pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n                                   id: ast::node_id, tcx: ty::ctxt) ->\n-        ~[ProvidedTraitMethodInfo] {\n+        ~[@ty::Method] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n@@ -763,13 +763,8 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n \n         if item_method_sort(mth) != 'p' { loop; }\n \n-        let ty_method = get_method(intr, cdata, did.node, tcx);\n-        let provided_trait_method_info = ProvidedTraitMethodInfo {\n-            ty: ty_method,\n-            def_id: did\n-        };\n-\n-        vec::push(&mut result, provided_trait_method_info);\n+        vec::push(&mut result,\n+                  @get_method(intr, cdata, did.node, tcx));\n     }\n \n     return result;"}, {"sha": "3e55934198f558877100f7661d31ade89feba35f", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=32adc0e730636f04d72d31e24fbf1101a495ccb7", "patch": "@@ -1683,21 +1683,20 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n \n     match fcx.llself {\n       Some(slf) => {\n-        // We really should do this regardless of whether self is owned, but\n-        // it doesn't work right with default method impls yet. (FIXME: #2794)\n-        if slf.is_owned {\n-            let self_val = if datum::appropriate_mode(slf.t).is_by_value() {\n-                let tmp = BitCast(bcx, slf.v, type_of(bcx.ccx(), slf.t));\n-                let alloc = alloc_ty(bcx, slf.t);\n-                Store(bcx, tmp, alloc);\n-                alloc\n-            } else {\n-                PointerCast(bcx, slf.v, type_of(bcx.ccx(), slf.t).ptr_to())\n-            };\n-\n-            fcx.llself = Some(ValSelfData {v: self_val, ..slf});\n-            add_clean(bcx, self_val, slf.t);\n-        }\n+          let self_val = if slf.is_owned\n+                  && datum::appropriate_mode(slf.t).is_by_value() {\n+              let tmp = BitCast(bcx, slf.v, type_of(bcx.ccx(), slf.t));\n+              let alloc = alloc_ty(bcx, slf.t);\n+              Store(bcx, tmp, alloc);\n+              alloc\n+          } else {\n+              PointerCast(bcx, slf.v, type_of(bcx.ccx(), slf.t).ptr_to())\n+          };\n+\n+          fcx.llself = Some(ValSelfData {v: self_val, ..slf});\n+          if slf.is_owned {\n+              add_clean(bcx, self_val, slf.t);\n+          }\n       }\n       _ => {}\n     }\n@@ -2110,7 +2109,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n       }\n       ast::item_impl(ref generics, _, _, ref ms) => {\n         meth::trans_impl(ccx, /*bad*/copy *path, item.ident, *ms,\n-                         generics, None, item.id);\n+                         generics, item.id);\n       }\n       ast::item_mod(ref m) => {\n         trans_mod(ccx, m);"}, {"sha": "0e64d7582ac5d51b7852d277002660258550610b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=32adc0e730636f04d72d31e24fbf1101a495ccb7", "patch": "@@ -1051,14 +1051,8 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n             debug!(\"def_self() reference, self_info.t=%s\",\n                    self_info.t.repr(bcx.tcx()));\n \n-            // This cast should not be necessary. We should cast self *once*,\n-            // but right now this conflicts with default methods.\n-            let real_self_ty = monomorphize_type(bcx, self_info.t);\n-            let llselfty = type_of::type_of(bcx.ccx(), real_self_ty).ptr_to();\n-\n-            let casted_val = PointerCast(bcx, self_info.v, llselfty);\n             Datum {\n-                val: casted_val,\n+                val: self_info.v,\n                 ty: self_info.t,\n                 mode: ByRef(ZeroMem)\n             }"}, {"sha": "96f8a1976a68cfa2aad47885e45446d84e98a10e", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=32adc0e730636f04d72d31e24fbf1101a495ccb7", "patch": "@@ -49,13 +49,12 @@ pub fn trans_impl(ccx: @mut CrateContext,\n                   name: ast::ident,\n                   methods: &[@ast::method],\n                   generics: &ast::Generics,\n-                  self_ty: Option<ty::t>,\n                   id: ast::node_id) {\n     let _icx = push_ctxt(\"impl::trans_impl\");\n     let tcx = ccx.tcx;\n \n-    debug!(\"trans_impl(path=%s, name=%s, self_ty=%s, id=%?)\",\n-           path.repr(tcx), name.repr(tcx), self_ty.repr(tcx), id);\n+    debug!(\"trans_impl(path=%s, name=%s, id=%?)\",\n+           path.repr(tcx), name.repr(tcx), id);\n \n     if !generics.ty_params.is_empty() { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n@@ -65,24 +64,10 @@ pub fn trans_impl(ccx: @mut CrateContext,\n             let path = vec::append_one(/*bad*/copy sub_path,\n                                        path_name(method.ident));\n \n-            let param_substs_opt;\n-            match self_ty {\n-                None => param_substs_opt = None,\n-                Some(self_ty) => {\n-                    param_substs_opt = Some(@param_substs {\n-                        tys: ~[],\n-                        vtables: None,\n-                        type_param_defs: @~[],\n-                        self_ty: Some(self_ty)\n-                    });\n-                }\n-            }\n-\n             trans_method(ccx,\n                          path,\n                          *method,\n-                         param_substs_opt,\n-                         self_ty,\n+                         None,\n                          llfn,\n                          ast_util::local_def(id));\n         }\n@@ -98,17 +83,13 @@ Translates a (possibly monomorphized) method body.\n - `method`: the AST node for the method\n - `param_substs`: if this is a generic method, the current values for\n   type parameters and so forth, else none\n-- `base_self_ty`: optionally, the explicit self type for this method. This\n-  will be none if this is not a default method and must always be present\n-  if this is a default method.\n - `llfn`: the LLVM ValueRef for the method\n - `impl_id`: the node ID of the impl this method is inside\n */\n pub fn trans_method(ccx: @mut CrateContext,\n                     path: path,\n                     method: &ast::method,\n                     param_substs: Option<@param_substs>,\n-                    base_self_ty: Option<ty::t>,\n                     llfn: ValueRef,\n                     impl_id: ast::def_id) {\n     // figure out how self is being passed\n@@ -119,18 +100,14 @@ pub fn trans_method(ccx: @mut CrateContext,\n       _ => {\n         // determine the (monomorphized) type that `self` maps to for\n         // this method\n-        let self_ty = match base_self_ty {\n-            None => ty::node_id_to_type(ccx.tcx, method.self_id),\n-            Some(provided_self_ty) => provided_self_ty,\n-        };\n+        let self_ty = ty::node_id_to_type(ccx.tcx, method.self_id);\n         let self_ty = match param_substs {\n             None => self_ty,\n-            Some(@param_substs {tys: ref tys, _}) => {\n-                ty::subst_tps(ccx.tcx, *tys, None, self_ty)\n+            Some(@param_substs {tys: ref tys, self_ty: ref self_sub, _}) => {\n+                ty::subst_tps(ccx.tcx, *tys, *self_sub, self_ty)\n             }\n         };\n-        debug!(\"calling trans_fn with base_self_ty %s, self_ty %s\",\n-               base_self_ty.repr(ccx.tcx),\n+        debug!(\"calling trans_fn with self_ty %s\",\n                self_ty.repr(ccx.tcx));\n         match method.explicit_self.node {\n           ast::sty_value => {"}, {"sha": "1ffe26e3affed09e9d2359122b54fe450a231093", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=32adc0e730636f04d72d31e24fbf1101a495ccb7", "patch": "@@ -233,14 +233,14 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n             Some(override_impl_did) => impl_did = override_impl_did\n         }\n \n-        meth::trans_method(ccx, pt, mth, psubsts, None, d, impl_did);\n+        meth::trans_method(ccx, pt, mth, psubsts, d, impl_did);\n         d\n       }\n       ast_map::node_trait_method(@ast::provided(mth), _, pt) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(/*bad*/copy mth.attrs, d);\n         debug!(\"monomorphic_fn impl_did_opt is %?\", impl_did_opt);\n-        meth::trans_method(ccx, /*bad*/copy *pt, mth, psubsts, None, d,\n+        meth::trans_method(ccx, /*bad*/copy *pt, mth, psubsts, d,\n                            impl_did_opt.get());\n         d\n       }"}, {"sha": "a7a69d51de265cb8803439ec1873f0afd06d0b6c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=32adc0e730636f04d72d31e24fbf1101a495ccb7", "patch": "@@ -3649,21 +3649,21 @@ pub fn def_has_ty_params(def: ast::def) -> bool {\n     }\n }\n \n-pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n+pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[@Method] {\n     if is_local(id) {\n         match cx.items.find(&id.node) {\n             Some(&ast_map::node_item(@ast::item {\n                         node: item_trait(_, _, ref ms),\n                         _\n                     }, _)) =>\n                 match ast_util::split_trait_methods(*ms) {\n-                   (_, p) => p.map(|method| method.ident)\n+                   (_, p) => p.map(|m| method(cx, ast_util::local_def(m.id)))\n                 },\n             _ => cx.sess.bug(fmt!(\"provided_trait_methods: %? is not a trait\",\n                                   id))\n         }\n     } else {\n-        csearch::get_provided_trait_methods(cx, id).map(|ifo| ifo.ty.ident)\n+        csearch::get_provided_trait_methods(cx, id)\n     }\n }\n "}, {"sha": "bd99a8e150b7ca42f5e5fe39fddc25150151d82b", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=32adc0e730636f04d72d31e24fbf1101a495ccb7", "patch": "@@ -333,7 +333,8 @@ impl CoherenceChecker {\n \n         let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n \n-        for self.each_provided_trait_method(trait_ref.def_id) |trait_method| {\n+        let provided = ty::provided_trait_methods(tcx, trait_ref.def_id);\n+        for provided.iter().advance |trait_method| {\n             // Synthesize an ID.\n             let new_id = parse::next_node_id(tcx.sess.parse_sess);\n             let new_did = local_def(new_id);\n@@ -347,7 +348,7 @@ impl CoherenceChecker {\n                     impl_id,\n                     trait_ref,\n                     new_did,\n-                    trait_method);\n+                    *trait_method);\n \n             debug!(\"new_method_ty=%s\", new_method_ty.repr(tcx));\n \n@@ -526,29 +527,6 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn each_provided_trait_method(&self,\n-                                      trait_did: ast::def_id,\n-                                      f: &fn(x: @ty::Method) -> bool)\n-                                      -> bool {\n-        // Make a list of all the names of the provided methods.\n-        // XXX: This is horrible.\n-        let mut provided_method_idents = HashSet::new();\n-        let tcx = self.crate_context.tcx;\n-        let r = ty::provided_trait_methods(tcx, trait_did);\n-        for r.iter().advance |ident| {\n-            provided_method_idents.insert(*ident);\n-        }\n-\n-        for ty::trait_methods(tcx, trait_did).iter().advance |&method| {\n-            if provided_method_idents.contains(&method.ident) {\n-                if !f(method) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n     pub fn polytypes_unify(&self,\n                            polytype_a: ty_param_bounds_and_ty,\n                            polytype_b: ty_param_bounds_and_ty)\n@@ -729,9 +707,9 @@ impl CoherenceChecker {\n         }\n         // Default methods\n         let r = ty::provided_trait_methods(tcx, trait_did);\n-        for r.iter().advance |ident| {\n-            debug!(\"inserting provided method %s\", ident.repr(tcx));\n-            provided_names.insert(*ident);\n+        for r.iter().advance |method| {\n+            debug!(\"inserting provided method %s\", method.ident.repr(tcx));\n+            provided_names.insert(method.ident);\n         }\n \n         let r = ty::trait_methods(tcx, trait_did);"}, {"sha": "19293e31167a0c70546718910b7d80deedbbb20a", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32adc0e730636f04d72d31e24fbf1101a495ccb7/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=32adc0e730636f04d72d31e24fbf1101a495ccb7", "patch": "@@ -268,12 +268,12 @@ fn output_file_name(workspace: &Path, short_name: &str) -> Path {\n     workspace.push(fmt!(\"%s%s\", short_name, os::EXE_SUFFIX))\n }\n \n-fn touch_source_file(workspace: &Path, short_name: &str) {\n+fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.push(\"src\").push(short_name);\n-    let contents = os::list_dir(&pkg_src_dir);\n+    let pkg_src_dir = workspace.push(\"src\").push(pkgid.to_str());\n+    let contents = os::list_dir_path(&pkg_src_dir);\n     for contents.iter().advance |p| {\n-        if Path(copy *p).filetype() == Some(~\".rs\") {\n+        if p.filetype() == Some(~\".rs\") {\n             // should be able to do this w/o a process\n             if run::process_output(\"touch\", [p.to_str()]).status != 0 {\n                 let _ = cond.raise((copy pkg_src_dir, ~\"Bad path\"));\n@@ -287,20 +287,19 @@ fn touch_source_file(workspace: &Path, short_name: &str) {\n fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.push(\"src\").push(pkgid.to_str());\n-    let contents = os::list_dir(&pkg_src_dir);\n+    let contents = os::list_dir_path(&pkg_src_dir);\n     let mut maybe_p = None;\n     for contents.iter().advance |p| {\n-        if Path(copy *p).filetype() == Some(~\".rs\") {\n+        if p.filetype() == Some(~\".rs\") {\n             maybe_p = Some(p);\n             break;\n         }\n     }\n     match maybe_p {\n         Some(p) => {\n-            let p = Path(copy *p);\n-            let w = io::buffered_file_writer(&p);\n+            let w = io::file_writer(*p, &[io::Append]);\n             match w {\n-                Err(s) => { let _ = cond.raise((p, fmt!(\"Bad path: %s\", s))); }\n+                Err(s) => { let _ = cond.raise((copy **p, fmt!(\"Bad path: %s\", s))); }\n                 Ok(w)  => w.write_line(\"\")\n             }\n         }\n@@ -615,7 +614,7 @@ fn do_rebuild_dep_dates_change() {\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n-    touch_source_file(&workspace, \"bar\");\n+    touch_source_file(&workspace, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let new_bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n     assert!(new_bar_date > bar_date);"}]}