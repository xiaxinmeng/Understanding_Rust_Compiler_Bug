{"sha": "2e01e6b4c2d5a84723738575df788823c608dce7", "node_id": "C_kwDOAAsO6NoAKDJlMDFlNmI0YzJkNWE4NDcyMzczODU3NWRmNzg4ODIzYzYwOGRjZTc", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-02-16T01:10:42Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-10-24T20:05:39Z"}, "message": "Also support linting for match", "tree": {"sha": "0eb055757e5a56b3bb94189cfcc4ed78325907d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0eb055757e5a56b3bb94189cfcc4ed78325907d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e01e6b4c2d5a84723738575df788823c608dce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e01e6b4c2d5a84723738575df788823c608dce7", "html_url": "https://github.com/rust-lang/rust/commit/2e01e6b4c2d5a84723738575df788823c608dce7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e01e6b4c2d5a84723738575df788823c608dce7/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f827be92fcdb225738a73051f75cb5e1243fe615", "url": "https://api.github.com/repos/rust-lang/rust/commits/f827be92fcdb225738a73051f75cb5e1243fe615", "html_url": "https://github.com/rust-lang/rust/commit/f827be92fcdb225738a73051f75cb5e1243fe615"}], "stats": {"total": 286, "additions": 257, "deletions": 29}, "files": [{"sha": "98510ee9acdfb330122bb5b48448862d0d66b89b", "filename": "clippy_lints/src/manual_let_else.rs", "status": "modified", "additions": 86, "deletions": 26, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2e01e6b4c2d5a84723738575df788823c608dce7/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e01e6b4c2d5a84723738575df788823c608dce7/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_let_else.rs?ref=2e01e6b4c2d5a84723738575df788823c608dce7", "patch": "@@ -1,12 +1,14 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::{for_each_expr, Descend};\n-use clippy_utils::{higher, meets_msrv, msrvs, peel_blocks};\n+use clippy_utils::{meets_msrv, msrvs, peel_blocks};\n use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, Pat, QPath, Stmt, StmtKind};\n+use rustc_hir::{Expr, ExprKind, MatchSource, Pat, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n use std::ops::ControlFlow;\n \n declare_clippy_lint! {\n@@ -56,29 +58,64 @@ impl_lint_pass!(ManualLetElse => [MANUAL_LET_ELSE]);\n \n impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n     fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &'tcx Stmt<'tcx>) {\n-        if !meets_msrv(self.msrv, msrvs::LET_ELSE) {\n-            return;\n-        }\n-\n-        if in_external_macro(cx.sess(), stmt.span) {\n-            return;\n-        }\n-\n-        if_chain! {\n+        let if_let_or_match = if_chain! {\n+            if meets_msrv(self.msrv, msrvs::LET_ELSE);\n+            if !in_external_macro(cx.sess(), stmt.span);\n             if let StmtKind::Local(local) = stmt.kind;\n             if let Some(init) = local.init;\n-            if let Some(higher::IfLet { let_pat, let_expr: _, if_then, if_else }) = higher::IfLet::hir(cx, init);\n-            if if_then_simple_identity(let_pat, if_then);\n-            if let Some(if_else) = if_else;\n-            if expr_diverges(cx, if_else);\n+            if !from_different_macros(init.span, stmt.span);\n+            if let Some(if_let_or_match) = IfLetOrMatch::parse(cx, init);\n             then {\n-                span_lint(\n-                    cx,\n-                    MANUAL_LET_ELSE,\n-                    stmt.span,\n-                    \"this could be rewritten as `let else`\",\n-                );\n+                if_let_or_match\n+            } else {\n+                return;\n             }\n+        };\n+\n+        match if_let_or_match {\n+            IfLetOrMatch::IfLet(_let_expr, let_pat, if_then, if_else) => if_chain! {\n+                if expr_is_simple_identity(let_pat, if_then);\n+                if let Some(if_else) = if_else;\n+                if expr_diverges(cx, if_else);\n+                then {\n+                    span_lint(\n+                        cx,\n+                        MANUAL_LET_ELSE,\n+                        stmt.span,\n+                        \"this could be rewritten as `let else`\",\n+                    );\n+                }\n+            },\n+            IfLetOrMatch::Match(_match_expr, arms, source) => {\n+                if source != MatchSource::Normal {\n+                    return;\n+                }\n+                // Any other number than two arms doesn't (neccessarily)\n+                // have a trivial mapping to let else.\n+                if arms.len() != 2 {\n+                    return;\n+                }\n+                // We iterate over both arms, trying to find one that is an identity,\n+                // one that diverges. Our check needs to work regardless of the order\n+                // of both arms.\n+                let mut found_identity_arm = false;\n+                let mut found_diverging_arm = false;\n+                for arm in arms {\n+                    // Guards don't give us an easy mapping to let else\n+                    if arm.guard.is_some() {\n+                        return;\n+                    }\n+                    if expr_is_simple_identity(arm.pat, arm.body) {\n+                        found_identity_arm = true;\n+                    } else if expr_diverges(cx, arm.body) && pat_has_no_bindings(arm.pat) {\n+                        found_diverging_arm = true;\n+                    }\n+                }\n+                if !(found_identity_arm && found_diverging_arm) {\n+                    return;\n+                }\n+                span_lint(cx, MANUAL_LET_ELSE, stmt.span, \"this could be rewritten as `let else`\");\n+            },\n         }\n     }\n \n@@ -139,16 +176,39 @@ fn expr_diverges(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     .is_some()\n }\n \n-/// Checks if the passed `if_then` is a simple identity\n-fn if_then_simple_identity(let_pat: &'_ Pat<'_>, if_then: &'_ Expr<'_>) -> bool {\n+/// Returns true if the two spans come from different macro sites,\n+/// or one comes from an invocation and the other is not from a macro at all.\n+fn from_different_macros(span_a: Span, span_b: Span) -> bool {\n+    // This pre-check is a speed up so that we don't build outer_expn_data unless needed.\n+    match (span_a.from_expansion(), span_b.from_expansion()) {\n+        (false, false) => return false,\n+        (true, false) | (false, true) => return true,\n+        // We need to determine if both are from the same macro\n+        (true, true) => (),\n+    }\n+    let data_for_comparison = |sp: Span| {\n+        let expn_data = sp.ctxt().outer_expn_data();\n+        (expn_data.kind, expn_data.call_site)\n+    };\n+    data_for_comparison(span_a) != data_for_comparison(span_b)\n+}\n+\n+fn pat_has_no_bindings(pat: &'_ Pat<'_>) -> bool {\n+    let mut has_no_bindings = true;\n+    pat.each_binding_or_first(&mut |_, _, _, _| has_no_bindings = false);\n+    has_no_bindings\n+}\n+\n+/// Checks if the passed block is a simple identity referring to bindings created by the pattern\n+fn expr_is_simple_identity(pat: &'_ Pat<'_>, expr: &'_ Expr<'_>) -> bool {\n     // TODO support patterns with multiple bindings and tuples, like:\n-    //   let (foo, bar) = if let (Some(foo), bar) = g() { (foo, bar) } else { ... }\n+    //   let ... = if let (Some(foo), bar) = g() { (foo, bar) } else { ... }\n     if_chain! {\n-        if let ExprKind::Path(QPath::Resolved(_ty, path)) = &peel_blocks(if_then).kind;\n+        if let ExprKind::Path(QPath::Resolved(_ty, path)) = &peel_blocks(expr).kind;\n         if let [path_seg] = path.segments;\n         then {\n             let mut pat_bindings = Vec::new();\n-            let_pat.each_binding(|_ann, _hir_id, _sp, ident| {\n+            pat.each_binding_or_first(&mut |_ann, _hir_id, _sp, ident| {\n                 pat_bindings.push(ident);\n             });\n             if let [binding] = &pat_bindings[..] {"}, {"sha": "782f9f394fedebe39e46eb96ec2a616a9cd56777", "filename": "tests/ui/manual_let_else.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2e01e6b4c2d5a84723738575df788823c608dce7/tests%2Fui%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e01e6b4c2d5a84723738575df788823c608dce7/tests%2Fui%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.rs?ref=2e01e6b4c2d5a84723738575df788823c608dce7", "patch": "@@ -2,8 +2,8 @@\n #![allow(\n     clippy::collapsible_else_if,\n     clippy::unused_unit,\n-    clippy::never_loop,\n-    clippy::let_unit_value\n+    clippy::let_unit_value,\n+    clippy::never_loop\n )]\n #![warn(clippy::manual_let_else)]\n \n@@ -87,6 +87,14 @@ fn fire() {\n     } else {\n         return;\n     };\n+\n+    // entirely inside macro lints\n+    macro_rules! create_binding_if_some {\n+        ($n:ident, $e:expr) => {\n+            let $n = if let Some(v) = $e { v } else { return };\n+        };\n+    }\n+    create_binding_if_some!(w, g());\n }\n \n fn not_fire() {\n@@ -164,4 +172,20 @@ fn not_fire() {\n         };\n         Some(v)\n     }\n+\n+    // Macro boundary inside let\n+    macro_rules! some_or_return {\n+        ($e:expr) => {\n+            if let Some(v) = $e { v } else { return }\n+        };\n+    }\n+    let v = some_or_return!(g());\n+\n+    // Also macro boundary inside let, but inside a macro\n+    macro_rules! create_binding_if_some_nf {\n+        ($n:ident, $e:expr) => {\n+            let $n = some_or_return!($e);\n+        };\n+    }\n+    create_binding_if_some_nf!(v, g());\n }"}, {"sha": "9a2c548c5aa2309627ec68fec455e036937c5d8c", "filename": "tests/ui/manual_let_else.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e01e6b4c2d5a84723738575df788823c608dce7/tests%2Fui%2Fmanual_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e01e6b4c2d5a84723738575df788823c608dce7/tests%2Fui%2Fmanual_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.stderr?ref=2e01e6b4c2d5a84723738575df788823c608dce7", "patch": "@@ -100,5 +100,16 @@ LL | |         return;\n LL | |     };\n    | |______^\n \n-error: aborting due to 11 previous errors\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else.rs:94:13\n+   |\n+LL |             let $n = if let Some(v) = $e { v } else { return };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     create_binding_if_some!(w, g());\n+   |     ------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `create_binding_if_some` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "56da1db49f216f607cf0042483564a07eb5b7547", "filename": "tests/ui/manual_let_else_match.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2e01e6b4c2d5a84723738575df788823c608dce7/tests%2Fui%2Fmanual_let_else_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e01e6b4c2d5a84723738575df788823c608dce7/tests%2Fui%2Fmanual_let_else_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else_match.rs?ref=2e01e6b4c2d5a84723738575df788823c608dce7", "patch": "@@ -0,0 +1,93 @@\n+#![allow(unused_braces, unused_variables, dead_code)]\n+#![allow(clippy::collapsible_else_if, clippy::let_unit_value)]\n+#![warn(clippy::manual_let_else)]\n+// Ensure that we don't conflict with match -> if let lints\n+#![warn(clippy::single_match_else, clippy::single_match)]\n+\n+enum Variant {\n+    Foo,\n+    Bar(u32),\n+    Baz(u32),\n+}\n+\n+fn f() -> Result<u32, u32> {\n+    Ok(0)\n+}\n+\n+fn g() -> Option<()> {\n+    None\n+}\n+\n+fn h() -> Variant {\n+    Variant::Foo\n+}\n+\n+fn main() {}\n+\n+fn fire() {\n+    let v = match g() {\n+        Some(v_some) => v_some,\n+        None => return,\n+    };\n+\n+    let v = match g() {\n+        Some(v_some) => v_some,\n+        _ => return,\n+    };\n+\n+    loop {\n+        // More complex pattern for the identity arm\n+        let v = match h() {\n+            Variant::Foo => continue,\n+            Variant::Bar(v) | Variant::Baz(v) => v,\n+        };\n+    }\n+\n+    // There is a _ in the diverging arm\n+    // TODO also support unused bindings aka _v\n+    let v = match f() {\n+        Ok(v) => v,\n+        Err(_) => return,\n+    };\n+}\n+\n+fn not_fire() {\n+    // Multiple diverging arms\n+    let v = match h() {\n+        Variant::Foo => panic!(),\n+        Variant::Bar(_v) => return,\n+        Variant::Baz(v) => v,\n+    };\n+\n+    // Multiple identity arms\n+    let v = match h() {\n+        Variant::Foo => panic!(),\n+        Variant::Bar(v) => v,\n+        Variant::Baz(v) => v,\n+    };\n+\n+    // No diverging arm at all, only identity arms.\n+    // This is no case for let else, but destructuring assignment.\n+    let v = match f() {\n+        Ok(v) => v,\n+        Err(e) => e,\n+    };\n+\n+    // The identity arm has a guard\n+    let v = match h() {\n+        Variant::Bar(v) if g().is_none() => v,\n+        _ => return,\n+    };\n+\n+    // The diverging arm has a guard\n+    let v = match f() {\n+        Err(v) if v > 0 => panic!(),\n+        Ok(v) | Err(v) => v,\n+    };\n+\n+    // The diverging arm creates a binding\n+    let v = match f() {\n+        Ok(v) => v,\n+        Err(e) => panic!(\"error: {e}\"),\n+    };\n+}"}, {"sha": "2dae1d15ad425878537eecbd3354b2f0f0768de3", "filename": "tests/ui/manual_let_else_match.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2e01e6b4c2d5a84723738575df788823c608dce7/tests%2Fui%2Fmanual_let_else_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e01e6b4c2d5a84723738575df788823c608dce7/tests%2Fui%2Fmanual_let_else_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else_match.stderr?ref=2e01e6b4c2d5a84723738575df788823c608dce7", "patch": "@@ -0,0 +1,40 @@\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else_match.rs:28:5\n+   |\n+LL | /     let v = match g() {\n+LL | |         Some(v_some) => v_some,\n+LL | |         None => return,\n+LL | |     };\n+   | |______^\n+   |\n+   = note: `-D clippy::manual-let-else` implied by `-D warnings`\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else_match.rs:33:5\n+   |\n+LL | /     let v = match g() {\n+LL | |         Some(v_some) => v_some,\n+LL | |         _ => return,\n+LL | |     };\n+   | |______^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else_match.rs:40:9\n+   |\n+LL | /         let v = match h() {\n+LL | |             Variant::Foo => continue,\n+LL | |             Variant::Bar(v) | Variant::Baz(v) => v,\n+LL | |         };\n+   | |__________^\n+\n+error: this could be rewritten as `let else`\n+  --> $DIR/manual_let_else_match.rs:48:5\n+   |\n+LL | /     let v = match f() {\n+LL | |         Ok(v) => v,\n+LL | |         Err(_) => return,\n+LL | |     };\n+   | |______^\n+\n+error: aborting due to 4 previous errors\n+"}]}