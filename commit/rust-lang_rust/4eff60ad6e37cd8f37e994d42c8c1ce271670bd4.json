{"sha": "4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "node_id": "C_kwDOAAsO6NoAKDRlZmY2MGFkNmUzN2NkOGYzN2U5OTRkNDJjOGMxY2UyNzE2NzBiZDQ", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-12T00:54:31Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-13T01:03:54Z"}, "message": "Rearrange and document the new implementation\n\nstacked_borrow now has an item module, and its own FrameExtra. These\nserve to protect the implementation of Item (which is a bunch of\nbit-packing tricks) from the primary logic of Stacked Borrows, and the\nFrameExtra we have separates Stacked Borrows more cleanly from the\ninterpreter itself.\n\nThe new strategy for checking protectors also makes some subtle\nperformance tradeoffs, so they are now documented in Stack::item_popped\nbecause that function primarily benefits from them, and it also touches\nevery aspect of them.\n\nAlso separating the actual CallId that is protecting a Tag from the Tag\nmakes it inconvienent to reproduce exactly the same protector errors, so\nthis also takes the opportunity to use some slightly cleaner English in\nthose errors. We need to make some change, might as well make it good.", "tree": {"sha": "cc61fe13b7c8854295b65a243c6d11a86bb98772", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc61fe13b7c8854295b65a243c6d11a86bb98772"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "html_url": "https://github.com/rust-lang/rust/commit/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afa1dddcf97cf6008cfb447739b4b61e04f86660", "url": "https://api.github.com/repos/rust-lang/rust/commits/afa1dddcf97cf6008cfb447739b4b61e04f86660", "html_url": "https://github.com/rust-lang/rust/commit/afa1dddcf97cf6008cfb447739b4b61e04f86660"}], "stats": {"total": 367, "additions": 206, "deletions": 161}, "files": [{"sha": "b3d408a6dc07244945073a84014a923dd2d350e4", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -90,8 +90,8 @@ pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    stack::Stack, CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag,\n-    SbTagExtra, Stacks,\n+    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, SbTagExtra, Stack,\n+    Stacks,\n };\n pub use crate::sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId};\n pub use crate::thread::{"}, {"sha": "e31d7ba0105d611e5ff38d599a06d8cd8a5dfa86", "filename": "src/machine.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -5,7 +5,6 @@ use std::borrow::Cow;\n use std::cell::RefCell;\n use std::collections::HashSet;\n use std::fmt;\n-use std::num::NonZeroU64;\n use std::time::Instant;\n \n use rand::rngs::StdRng;\n@@ -43,7 +42,7 @@ pub const NUM_CPUS: u64 = 1;\n /// Extra data stored with each stack frame\n pub struct FrameData<'tcx> {\n     /// Extra data for Stacked Borrows.\n-    pub call_id: stacked_borrows::CallId,\n+    pub stacked_borrows: Option<stacked_borrows::FrameExtra>,\n \n     /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of `try_fn`\n     /// called by `try`). When this frame is popped during unwinding a panic,\n@@ -54,18 +53,15 @@ pub struct FrameData<'tcx> {\n     /// for the start of this frame. When we finish executing this frame,\n     /// we use this to register a completed event with `measureme`.\n     pub timing: Option<measureme::DetachedTiming>,\n-\n-    pub protected_tags: Vec<SbTag>,\n }\n \n impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { call_id, catch_unwind, timing: _, protected_tags } = self;\n+        let FrameData { stacked_borrows, catch_unwind, timing: _ } = self;\n         f.debug_struct(\"FrameData\")\n-            .field(\"call_id\", call_id)\n+            .field(\"stacked_borrows\", stacked_borrows)\n             .field(\"catch_unwind\", catch_unwind)\n-            .field(\"protected_tags\", protected_tags)\n             .finish()\n     }\n }\n@@ -894,11 +890,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         };\n \n         let stacked_borrows = ecx.machine.stacked_borrows.as_ref();\n-        let call_id = stacked_borrows.map_or(NonZeroU64::new(1).unwrap(), |stacked_borrows| {\n-            stacked_borrows.borrow_mut().new_call()\n-        });\n \n-        let extra = FrameData { call_id, catch_unwind: None, timing, protected_tags: Vec::new() };\n+        let extra = FrameData {\n+            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame()),\n+            catch_unwind: None,\n+            timing,\n+        };\n         Ok(frame.with_extra(extra))\n     }\n "}, {"sha": "4cae27ecd2192a67ba85e9fd8459865c5714f96e", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 65, "deletions": 122, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -16,15 +16,18 @@ use rustc_middle::ty::{\n };\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n+use smallvec::SmallVec;\n use std::collections::HashSet;\n \n use crate::*;\n \n pub mod diagnostics;\n use diagnostics::{AllocHistory, TagHistory};\n \n-pub mod stack;\n-use stack::Stack;\n+mod item;\n+pub use item::{Item, Permission};\n+mod stack;\n+pub use stack::Stack;\n \n pub type CallId = NonZeroU64;\n \n@@ -78,113 +81,21 @@ impl SbTagExtra {\n     }\n }\n \n-/// Indicates which permission is granted (by this item to some pointers)\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Permission {\n-    /// Grants unique mutable access.\n-    Unique,\n-    /// Grants shared mutable access.\n-    SharedReadWrite,\n-    /// Grants shared read-only access.\n-    SharedReadOnly,\n-    /// Grants no access, but separates two groups of SharedReadWrite so they are not\n-    /// all considered mutually compatible.\n-    Disabled,\n-}\n-\n-impl Permission {\n-    const UNIQUE: u64 = 0;\n-    const SHARED_READ_WRITE: u64 = 1;\n-    const SHARED_READ_ONLY: u64 = 2;\n-    const DISABLED: u64 = 3;\n-\n-    fn to_bits(self) -> u64 {\n-        match self {\n-            Permission::Unique => Self::UNIQUE,\n-            Permission::SharedReadWrite => Self::SHARED_READ_WRITE,\n-            Permission::SharedReadOnly => Self::SHARED_READ_ONLY,\n-            Permission::Disabled => Self::DISABLED,\n-        }\n-    }\n-\n-    fn from_bits(perm: u64) -> Self {\n-        match perm {\n-            Self::UNIQUE => Permission::Unique,\n-            Self::SHARED_READ_WRITE => Permission::SharedReadWrite,\n-            Self::SHARED_READ_ONLY => Permission::SharedReadOnly,\n-            Self::DISABLED => Permission::Disabled,\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-mod item {\n-    use super::{Permission, SbTag};\n-    use std::fmt;\n-    use std::num::NonZeroU64;\n-\n-    /// An item in the per-location borrow stack.\n-    #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-    pub struct Item(u64);\n-\n-    // An Item contains 3 bitfields:\n-    // * Bits 0-61 store an SbTag\n-    // * Bits 61-63 store a Permission\n-    // * Bit 64 stores a flag which indicates if we have a protector\n-    const TAG_MASK: u64 = u64::MAX >> 3;\n-    const PERM_MASK: u64 = 0x3 << 61;\n-    const PROTECTED_MASK: u64 = 0x1 << 63;\n-\n-    const PERM_SHIFT: u64 = 61;\n-    const PROTECTED_SHIFT: u64 = 63;\n-\n-    impl Item {\n-        pub fn new(tag: SbTag, perm: Permission, protected: bool) -> Self {\n-            assert!(tag.0.get() <= TAG_MASK);\n-            let packed_tag = tag.0.get();\n-            let packed_perm = perm.to_bits() << PERM_SHIFT;\n-            let packed_protected = (protected as u64) << PROTECTED_SHIFT;\n-\n-            let new = Self(packed_tag | packed_perm | packed_protected);\n-\n-            debug_assert!(new.tag() == tag);\n-            debug_assert!(new.perm() == perm);\n-            debug_assert!(new.protected() == protected);\n-\n-            new\n-        }\n-\n-        /// The pointers the permission is granted to.\n-        pub fn tag(self) -> SbTag {\n-            SbTag(NonZeroU64::new(self.0 & TAG_MASK).unwrap())\n-        }\n-\n-        /// The permission this item grants.\n-        pub fn perm(self) -> Permission {\n-            Permission::from_bits((self.0 & PERM_MASK) >> PERM_SHIFT)\n-        }\n-\n-        /// Whether or not there is a protector for this tag\n-        pub fn protected(self) -> bool {\n-            self.0 & PROTECTED_MASK > 0\n-        }\n-\n-        /// Set the Permission stored in this Item to Permission::Disabled\n-        pub fn set_disabled(&mut self) {\n-            // Clear the current set permission\n-            self.0 &= !PERM_MASK;\n-            // Write Permission::Disabled to the Permission bits\n-            self.0 |= Permission::Disabled.to_bits() << PERM_SHIFT;\n-        }\n-    }\n-\n-    impl fmt::Debug for Item {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            write!(f, \"[{:?} for {:?}]\", self.perm(), self.tag())\n-        }\n-    }\n+#[derive(Debug)]\n+pub struct FrameExtra {\n+    /// The ID of the call this frame corresponds to.\n+    call_id: CallId,\n+\n+    /// If this frame is protecting any tags, they are listed here. We use this list to do\n+    /// incremental updates of the global list of protected tags stored in the\n+    /// `stacked_borrows::GlobalState` upon function return, and if we attempt to pop a protected\n+    /// tag, to identify which call is responsible for protecting the tag.\n+    /// See `Stack::item_popped` for more explanation.\n+    ///\n+    /// This will contain one tag per reference passed to the function, so\n+    /// a size of 2 is enough for the vast majority of functions.\n+    protected_tags: SmallVec<[SbTag; 2]>,\n }\n-pub use item::Item;\n \n /// Extra per-allocation state.\n #[derive(Clone, Debug)]\n@@ -208,7 +119,11 @@ pub struct GlobalStateInner {\n     base_ptr_tags: FxHashMap<AllocId, SbTag>,\n     /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n-    /// All tags currently protected\n+    /// All currently protected tags.\n+    /// An item is protected if its tag is in this set, *and* it has the \"protected\" bit set.\n+    /// We add tags to this when they are created with a protector in `reborrow`, and\n+    /// we remove tags from this when the call which is protecting them returns, in\n+    /// `GlobalStateInner::end_call`. See `Stack::item_popped` for more details.\n     protected_tags: FxHashSet<SbTag>,\n     /// The pointer ids to trace\n     tracked_pointer_tags: HashSet<SbTag>,\n@@ -287,18 +202,23 @@ impl GlobalStateInner {\n         id\n     }\n \n-    pub fn new_call(&mut self) -> CallId {\n-        let id = self.next_call_id;\n-        trace!(\"new_call: Assigning ID {}\", id);\n-        if self.tracked_call_ids.contains(&id) {\n-            register_diagnostic(NonHaltingDiagnostic::CreatedCallId(id));\n+    pub fn new_frame(&mut self) -> FrameExtra {\n+        let call_id = self.next_call_id;\n+        trace!(\"new_frame: Assigning call ID {}\", call_id);\n+        if self.tracked_call_ids.contains(&call_id) {\n+            register_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n         }\n-        self.next_call_id = NonZeroU64::new(id.get() + 1).unwrap();\n-        id\n+        self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n+        FrameExtra { call_id, protected_tags: SmallVec::new() }\n     }\n \n     pub fn end_call(&mut self, frame: &machine::FrameData<'_>) {\n-        for tag in &frame.protected_tags {\n+        for tag in &frame\n+            .stacked_borrows\n+            .as_ref()\n+            .expect(\"we should have Stacked Borrows data\")\n+            .protected_tags\n+        {\n             self.protected_tags.remove(tag);\n         }\n     }\n@@ -407,17 +327,40 @@ impl<'tcx> Stack {\n             return Ok(());\n         }\n \n+        // We store tags twice, once in global.protected_tags and once in each call frame.\n+        // We do this because consulting a single global set in this function is faster\n+        // than attempting to search all call frames in the program for the `FrameExtra`\n+        // (if any) which is protecting the popped tag.\n+        //\n+        // This duplication trades off making `end_call` slower to make this function faster. This\n+        // trade-off is profitable in practice for a combination of two reasons.\n+        // 1. A single protected tag can (and does in some programs) protect thousands of `Item`s.\n+        //    Therefore, adding overhead to in function call/return is profitable even if it only\n+        //    saves a little work in this function.\n+        // 2. Most frames protect only one or two tags. So this duplicative global turns a search\n+        //    which ends up about linear in the number of protected tags in the program into a\n+        //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n         if global.protected_tags.contains(&item.tag()) {\n+            // This path is cold because it is fatal to the program. So here it is fine to do the\n+            // more expensive search to figure out which call is responsible for protecting this\n+            // tag.\n             let call_id = threads\n                 .all_stacks()\n                 .flatten()\n-                .find(|t| t.extra.protected_tags.contains(&item.tag()))\n-                .map(|frame| frame.extra.call_id)\n+                .map(|frame| {\n+                    frame\n+                        .extra\n+                        .stacked_borrows\n+                        .as_ref()\n+                        .expect(\"we should have Stacked Borrows data\")\n+                })\n+                .find(|frame| frame.protected_tags.contains(&item.tag()))\n+                .map(|frame| frame.call_id)\n                 .unwrap(); // FIXME: Surely we should find something, but a panic seems wrong here?\n             if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n                 Err(err_sb_ub(\n                     format!(\n-                        \"not granting access to tag {:?} because incompatible item is protected: {:?} (call {:?})\",\n+                        \"not granting access to tag {:?} because incompatible item {:?} is protected by call {:?}\",\n                         tag, item, call_id\n                     ),\n                     None,\n@@ -426,7 +369,7 @@ impl<'tcx> Stack {\n             } else {\n                 Err(err_sb_ub(\n                     format!(\n-                        \"deallocating while item is protected: {:?} (call {:?})\",\n+                        \"deallocating while item {:?} is protected by call {:?}\",\n                         item, call_id\n                     ),\n                     None,\n@@ -904,7 +847,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         );\n \n         if protect {\n-            this.frame_mut().extra.protected_tags.push(new_tag);\n+            this.frame_mut().extra.stacked_borrows.as_mut().unwrap().protected_tags.push(new_tag);\n             this.machine.stacked_borrows.as_mut().unwrap().get_mut().protected_tags.insert(new_tag);\n         }\n         // FIXME: can't hold the current span handle across the borrows of self above"}, {"sha": "ad1b9b075b40fce12dd96baaa0e0eeec8c26afb0", "filename": "src/stacked_borrows/item.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/src%2Fstacked_borrows%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/src%2Fstacked_borrows%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fitem.rs?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -0,0 +1,104 @@\n+use crate::stacked_borrows::SbTag;\n+use std::fmt;\n+use std::num::NonZeroU64;\n+\n+/// An item in the per-location borrow stack.\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Item(u64);\n+\n+// An Item contains 3 bitfields:\n+// * Bits 0-61 store an SbTag\n+// * Bits 61-63 store a Permission\n+// * Bit 64 stores a flag which indicates if we have a protector\n+const TAG_MASK: u64 = u64::MAX >> 3;\n+const PERM_MASK: u64 = 0x3 << 61;\n+const PROTECTED_MASK: u64 = 0x1 << 63;\n+\n+const PERM_SHIFT: u64 = 61;\n+const PROTECTED_SHIFT: u64 = 63;\n+\n+impl Item {\n+    pub fn new(tag: SbTag, perm: Permission, protected: bool) -> Self {\n+        assert!(tag.0.get() <= TAG_MASK);\n+        let packed_tag = tag.0.get();\n+        let packed_perm = perm.to_bits() << PERM_SHIFT;\n+        let packed_protected = (protected as u64) << PROTECTED_SHIFT;\n+\n+        let new = Self(packed_tag | packed_perm | packed_protected);\n+\n+        debug_assert!(new.tag() == tag);\n+        debug_assert!(new.perm() == perm);\n+        debug_assert!(new.protected() == protected);\n+\n+        new\n+    }\n+\n+    /// The pointers the permission is granted to.\n+    pub fn tag(self) -> SbTag {\n+        SbTag(NonZeroU64::new(self.0 & TAG_MASK).unwrap())\n+    }\n+\n+    /// The permission this item grants.\n+    pub fn perm(self) -> Permission {\n+        Permission::from_bits((self.0 & PERM_MASK) >> PERM_SHIFT)\n+    }\n+\n+    /// Whether or not there is a protector for this tag\n+    pub fn protected(self) -> bool {\n+        self.0 & PROTECTED_MASK > 0\n+    }\n+\n+    /// Set the Permission stored in this Item\n+    pub fn set_permission(&mut self, perm: Permission) {\n+        // Clear the current set permission\n+        self.0 &= !PERM_MASK;\n+        // Write Permission::Disabled to the Permission bits\n+        self.0 |= perm.to_bits() << PERM_SHIFT;\n+    }\n+}\n+\n+impl fmt::Debug for Item {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"[{:?} for {:?}]\", self.perm(), self.tag())\n+    }\n+}\n+\n+/// Indicates which permission is granted (by this item to some pointers)\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Permission {\n+    /// Grants unique mutable access.\n+    Unique,\n+    /// Grants shared mutable access.\n+    SharedReadWrite,\n+    /// Grants shared read-only access.\n+    SharedReadOnly,\n+    /// Grants no access, but separates two groups of SharedReadWrite so they are not\n+    /// all considered mutually compatible.\n+    Disabled,\n+}\n+\n+impl Permission {\n+    const UNIQUE: u64 = 0;\n+    const SHARED_READ_WRITE: u64 = 1;\n+    const SHARED_READ_ONLY: u64 = 2;\n+    const DISABLED: u64 = 3;\n+\n+    fn to_bits(self) -> u64 {\n+        match self {\n+            Permission::Unique => Self::UNIQUE,\n+            Permission::SharedReadWrite => Self::SHARED_READ_WRITE,\n+            Permission::SharedReadOnly => Self::SHARED_READ_ONLY,\n+            Permission::Disabled => Self::DISABLED,\n+        }\n+    }\n+\n+    fn from_bits(perm: u64) -> Self {\n+        match perm {\n+            Self::UNIQUE => Permission::Unique,\n+            Self::SHARED_READ_WRITE => Permission::SharedReadWrite,\n+            Self::SHARED_READ_ONLY => Permission::SharedReadOnly,\n+            Self::DISABLED => Permission::Disabled,\n+            _ => unreachable!(),\n+        }\n+    }\n+}"}, {"sha": "1b05471618a52bc4f2507ee9c0f40e88b513a696", "filename": "src/stacked_borrows/stack.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/src%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/src%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fstack.rs?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -303,10 +303,11 @@ impl<'tcx> Stack {\n                 if item.perm() == Permission::Unique {\n                     log::trace!(\"access: disabling item {:?}\", item);\n                     visitor(*item)?;\n-                    item.set_disabled();\n-                    for t in &mut self.cache.items {\n-                        if t.tag() == item.tag() {\n-                            t.set_disabled();\n+                    item.set_permission(Permission::Disabled);\n+                    // Also update all copies of this item in the cache.\n+                    for it in &mut self.cache.items {\n+                        if it.tag() == item.tag() {\n+                            it.set_permission(Permission::Disabled);\n                         }\n                     }\n                 }"}, {"sha": "c568d1c50434c30fdb97c01ac4db1e35ca006aa4", "filename": "tests/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -97,7 +97,7 @@ regexes! {\n     // erase specific alignments\n     \"alignment [0-9]+\"               => \"alignment ALIGN\",\n     // erase thread caller ids\n-    r\"\\(call [0-9]+\\)\"              => \"(call ID)\",\n+    r\"call [0-9]+\"                  => \"call ID\",\n     // erase platform module paths\n     \"sys::[a-z]+::\"                  => \"sys::PLATFORM::\",\n     // Windows file paths"}, {"sha": "b821d1e6edb42ef5177a3167c28919dd5b680c1c", "filename": "tests/fail/stacked_borrows/aliasing_mut1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n   --> $DIR/aliasing_mut1.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &mut i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "594b578fc09a7235c737be067bee54f51711bc0e", "filename": "tests/fail/stacked_borrows/aliasing_mut2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n   --> $DIR/aliasing_mut2.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "0c7d85ae5756c1c63fde4b042fec3db640080404", "filename": "tests/fail/stacked_borrows/aliasing_mut4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n   --> $DIR/aliasing_mut4.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut Cell<i32>) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "20e026df7b9b226146698319ebf4c79b944b0ff7", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.rs?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: deallocating while item is protected\n+//@error-pattern: deallocating while item\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}, {"sha": "689c0a5deae68c9755fc0d5204e80d5ee37f977e", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.stderr?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item is protected: [Unique for <TAG>] (call ID)\n+error: Undefined Behavior: deallocating while item [Unique for <TAG>] is protected by call ID\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item is protected: [Unique for <TAG>] (call ID)\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [Unique for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "9cb2d52bf2e9af989f526599a1043b3c311fd8c6", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: deallocating while item is protected\n+//@error-pattern: deallocating while item\n use std::marker::PhantomPinned;\n \n pub struct NotUnpin(i32, PhantomPinned);"}, {"sha": "a1a7ce0c6bb681a662c3de52f73ea76c1a53899c", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item is protected: [SharedReadWrite for <TAG>] (call ID)\n+error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is protected by call ID\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item is protected: [SharedReadWrite for <TAG>] (call ID)\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "42f7b3f8b54bfbb9b192695eb66e9e87d144b1f5", "filename": "tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     unsafe { *y = 2 };\n-   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n+   |              ^^^^^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "4a1b14e460941dccd2414dc8aaf6efd5519a3d7a", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n   --> $DIR/invalidate_against_barrier1.rs:LL:CC\n    |\n LL |     let _val = unsafe { *x };\n-   |                         ^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n+   |                         ^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "c6f158316f51294cee00729f48ff85a0f938b198", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n   --> $DIR/invalidate_against_barrier2.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n+   |              ^^^^^^ not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "f9cceb761af3e6f2fcee46b164b028f32222bf3b", "filename": "tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,5 +1,5 @@\n //@compile-flags: -Zmiri-retag-fields\n-//@error-pattern: incompatible item is protected\n+//@error-pattern: is protected by call\n struct Newtype<'a>(&'a mut i32);\n \n fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {"}, {"sha": "d9aebecfda731bbaf883e0be56f47bb58ac7debf", "filename": "tests/fail/stacked_borrows/newtype_retagging.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr?ref=4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n   --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n    |\n LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}]}