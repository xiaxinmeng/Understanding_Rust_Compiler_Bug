{"sha": "f011f928dd69a5b770b348aea2c547431c34e11a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMTFmOTI4ZGQ2OWE1Yjc3MGIzNDhhZWEyYzU0NzQzMWMzNGUxMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-22T17:18:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-22T17:18:53Z"}, "message": "auto merge of #5463 : alexcrichton/rust/faster-fmt, r=graydon\n\nThis is a minor step towards #3571, although I'm sure there's still more work to be done. Previously, `fmt!` collected a bunch of strings in a vector and then called `str::concat`. This changes the behavior by maintaining only one buffer and appending directly into that buffer. This avoids doubly-allocating memory, and it has the added bonus of reducing some allocations in `core::unstable::extfmt`\r\n\r\nOne of the unfortunate side effects of this is that the `rt` module in `extfmt.rs` had to be duplicated to avoid `stage0` errors. Dealing with the change in conversion functions may require a bit of a dance when a snapshot happens, but I think it's doable.\r\n\r\nIf the second speedup commit isn't deemed necessary, I got about a 15% speedup with just the first patch which doesn't require any modification of `extfmt.rs`, so no snapshot weirdness.\r\n\r\nHere's some other things I ran into when looking at `fmt!`:\r\n* I don't think that #2249 is relevant any more except for maybe removing one of `%i` or `%d`\r\n* I'm not sure what was in mind for using traits with #3571, but I thought that formatters like `%u` could invoke the `to_uint()` method on the `NumCast` trait, but I ran into some problems like those in #5462\r\n\r\nI'm having trouble thinking of other wins for `fmt!`, but if there's some suggestions I'd be more than willing to look into if they'd work out or not.", "tree": {"sha": "b389e0437a91eb9917c5fe7166ebb9c46692f62a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b389e0437a91eb9917c5fe7166ebb9c46692f62a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f011f928dd69a5b770b348aea2c547431c34e11a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f011f928dd69a5b770b348aea2c547431c34e11a", "html_url": "https://github.com/rust-lang/rust/commit/f011f928dd69a5b770b348aea2c547431c34e11a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f011f928dd69a5b770b348aea2c547431c34e11a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1616ffd0c2627502b1015b6388480ed7429ef042", "url": "https://api.github.com/repos/rust-lang/rust/commits/1616ffd0c2627502b1015b6388480ed7429ef042", "html_url": "https://github.com/rust-lang/rust/commit/1616ffd0c2627502b1015b6388480ed7429ef042"}, {"sha": "e93654c96d0288e6f2f00075d95dd4958b4cb4dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e93654c96d0288e6f2f00075d95dd4958b4cb4dc", "html_url": "https://github.com/rust-lang/rust/commit/e93654c96d0288e6f2f00075d95dd4958b4cb4dc"}], "stats": {"total": 342, "additions": 281, "deletions": 61}, "files": [{"sha": "7527a6afb557526e8f8ac24e3b373e1f0cb33cd7", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=f011f928dd69a5b770b348aea2c547431c34e11a", "patch": "@@ -470,6 +470,215 @@ pub mod ct {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it this way, I think.\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+#[doc(hidden)]\n+pub mod rt {\n+    use float;\n+    use str;\n+    use sys;\n+    use int;\n+    use uint;\n+    use vec;\n+    use option::{Some, None, Option};\n+\n+    pub const flag_none : u32 = 0u32;\n+    pub const flag_left_justify   : u32 = 0b00000000000001u32;\n+    pub const flag_left_zero_pad  : u32 = 0b00000000000010u32;\n+    pub const flag_space_for_sign : u32 = 0b00000000000100u32;\n+    pub const flag_sign_always    : u32 = 0b00000000001000u32;\n+    pub const flag_alternate      : u32 = 0b00000000010000u32;\n+\n+    pub enum Count { CountIs(uint), CountImplied, }\n+\n+    pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n+\n+    pub struct Conv {\n+        flags: u32,\n+        width: Count,\n+        precision: Count,\n+        ty: Ty,\n+    }\n+\n+    pub pure fn conv_int(cv: Conv, i: int, buf: &mut ~str) {\n+        let radix = 10;\n+        let prec = get_int_precision(cv);\n+        let mut s : ~str = uint_to_str_prec(int::abs(i) as uint, radix, prec);\n+\n+        let head = if i >= 0 {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                Some('+')\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                Some(' ')\n+            } else {\n+                None\n+            }\n+        } else { Some('-') };\n+        unsafe { pad(cv, s, head, PadSigned, buf) };\n+    }\n+    pub pure fn conv_uint(cv: Conv, u: uint, buf: &mut ~str) {\n+        let prec = get_int_precision(cv);\n+        let mut rs =\n+            match cv.ty {\n+              TyDefault => uint_to_str_prec(u, 10, prec),\n+              TyHexLower => uint_to_str_prec(u, 16, prec),\n+              TyHexUpper => str::to_upper(uint_to_str_prec(u, 16, prec)),\n+              TyBits => uint_to_str_prec(u, 2, prec),\n+              TyOctal => uint_to_str_prec(u, 8, prec)\n+            };\n+        unsafe { pad(cv, rs, None, PadUnsigned, buf) };\n+    }\n+    pub pure fn conv_bool(cv: Conv, b: bool, buf: &mut ~str) {\n+        let s = if b { \"true\" } else { \"false\" };\n+        // run the boolean conversion through the string conversion logic,\n+        // giving it the same rules for precision, etc.\n+        conv_str(cv, s, buf);\n+    }\n+    pub pure fn conv_char(cv: Conv, c: char, buf: &mut ~str) {\n+        unsafe { pad(cv, \"\", Some(c), PadNozero, buf) };\n+    }\n+    pub pure fn conv_str(cv: Conv, s: &str, buf: &mut ~str) {\n+        // For strings, precision is the maximum characters\n+        // displayed\n+        let mut unpadded = match cv.precision {\n+          CountImplied => s,\n+          CountIs(max) => if (max as uint) < str::char_len(s) {\n+            str::slice(s, 0, max as uint)\n+          } else {\n+            s\n+          }\n+        };\n+        unsafe { pad(cv, unpadded, None, PadNozero, buf) };\n+    }\n+    pub pure fn conv_float(cv: Conv, f: float, buf: &mut ~str) {\n+        let (to_str, digits) = match cv.precision {\n+              CountIs(c) => (float::to_str_exact, c as uint),\n+              CountImplied => (float::to_str_digits, 6u)\n+        };\n+        let mut s = unsafe { to_str(f, digits) };\n+        let head = if 0.0 <= f {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                Some('+')\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                Some(' ')\n+            } else {\n+                None\n+            }\n+        } else { None };\n+        unsafe { pad(cv, s, head, PadFloat, buf) };\n+    }\n+    pub pure fn conv_poly<T>(cv: Conv, v: &T, buf: &mut ~str) {\n+        let s = sys::log_str(v);\n+        conv_str(cv, s, buf);\n+    }\n+\n+    // Convert a uint to string with a minimum number of digits.  If precision\n+    // is 0 and num is 0 then the result is the empty string. Could move this\n+    // to uint: but it doesn't seem all that useful.\n+    pub pure fn uint_to_str_prec(num: uint, radix: uint,\n+                                 prec: uint) -> ~str {\n+        return if prec == 0u && num == 0u {\n+                ~\"\"\n+            } else {\n+                let s = uint::to_str_radix(num, radix);\n+                let len = str::char_len(s);\n+                if len < prec {\n+                    let diff = prec - len;\n+                    let pad = str::from_chars(vec::from_elem(diff, '0'));\n+                    pad + s\n+                } else { s }\n+            };\n+    }\n+    pub pure fn get_int_precision(cv: Conv) -> uint {\n+        return match cv.precision {\n+              CountIs(c) => c as uint,\n+              CountImplied => 1u\n+            };\n+    }\n+\n+    #[deriving(Eq)]\n+    pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n+\n+    pub fn pad(cv: Conv, mut s: &str, head: Option<char>, mode: PadMode,\n+               buf: &mut ~str) {\n+        let headsize = match head { Some(_) => 1, _ => 0 };\n+        let uwidth : uint = match cv.width {\n+            CountImplied => {\n+                for head.each |&c| {\n+                    buf.push_char(c);\n+                }\n+                return buf.push_str(s);\n+            }\n+            CountIs(width) => { width as uint }\n+        };\n+        let strlen = str::char_len(s) + headsize;\n+        if uwidth <= strlen {\n+            for head.each |&c| {\n+                buf.push_char(c);\n+            }\n+            return buf.push_str(s);\n+        }\n+        let mut padchar = ' ';\n+        let diff = uwidth - strlen;\n+        if have_flag(cv.flags, flag_left_justify) {\n+            for head.each |&c| {\n+                buf.push_char(c);\n+            }\n+            buf.push_str(s);\n+            for diff.times {\n+                buf.push_char(padchar);\n+            }\n+            return;\n+        }\n+        let (might_zero_pad, signed) = match mode {\n+          PadNozero   => (false, true),\n+          PadSigned   => (true, true),\n+          PadFloat    => (true, true),\n+          PadUnsigned => (true, false)\n+        };\n+        pure fn have_precision(cv: Conv) -> bool {\n+            return match cv.precision { CountImplied => false, _ => true };\n+        }\n+        let zero_padding = {\n+            if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n+                (!have_precision(cv) || mode == PadFloat) {\n+                padchar = '0';\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+        let padstr = str::from_chars(vec::from_elem(diff, padchar));\n+        // This is completely heinous. If we have a signed value then\n+        // potentially rip apart the intermediate result and insert some\n+        // zeros. It may make sense to convert zero padding to a precision\n+        // instead.\n+\n+        if signed && zero_padding {\n+            for head.each |&head| {\n+                if head == '+' || head == '-' || head == ' ' {\n+                    buf.push_char(head);\n+                    buf.push_str(padstr);\n+                    buf.push_str(s);\n+                    return;\n+                }\n+            }\n+        }\n+        buf.push_str(padstr);\n+        for head.each |&c| {\n+            buf.push_char(c);\n+        }\n+        buf.push_str(s);\n+    }\n+    #[inline(always)]\n+    pub pure fn have_flag(flags: u32, f: u32) -> bool {\n+        flags & f != 0\n+    }\n+}\n+\n+// XXX: remove after a snapshot of the above changes have gone in\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub mod rt {\n     use float;"}, {"sha": "6682082bd18f949602ef6f5f6e2ef763b769cfd5", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f011f928dd69a5b770b348aea2c547431c34e11a", "patch": "@@ -32,7 +32,6 @@ use core::prelude::*;\n use middle::freevars::get_freevars;\n use middle::pat_util::{pat_bindings, pat_is_binding};\n use middle::ty::{encl_region, re_scope};\n-use middle::ty::{vstore_box, vstore_fixed, vstore_slice};\n use middle::ty;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::check::lookup_def;"}, {"sha": "abbefd1f7e6f9e8c8cae81bd67fa886e60e0b0a0", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=f011f928dd69a5b770b348aea2c547431c34e11a", "patch": "@@ -20,8 +20,6 @@ use util::ppaux::region_to_str;\n use util::ppaux;\n \n use std::list::Cons;\n-use syntax::ast;\n-use syntax::codemap;\n \n // Helper functions related to manipulating region types.\n "}, {"sha": "7724b43b50f85323b1f83a521c74bf3cf46676ac", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=f011f928dd69a5b770b348aea2c547431c34e11a", "patch": "@@ -51,7 +51,6 @@ independently:\n use core::prelude::*;\n \n use middle::resolve;\n-use middle::ty::{ty_param_substs_and_ty, vstore_uniq};\n use middle::ty;\n use util::common::time;\n use util::ppaux;"}, {"sha": "c2f4cbf3db2465efc1353449df29c534ff63b8d2", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f011f928dd69a5b770b348aea2c547431c34e11a", "patch": "@@ -108,6 +108,9 @@ pub fn mk_access(cx: @ext_ctxt, sp: span, +p: ~[ast::ident], m: ast::ident)\n pub fn mk_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n }\n+pub fn mk_mut_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+    return mk_expr(cx, sp, ast::expr_addr_of(ast::m_mutbl, e));\n+}\n pub fn mk_call_(cx: @ext_ctxt, sp: span, fn_expr: @ast::expr,\n                 +args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))"}, {"sha": "3ebe844950a40cd2599fe93b49c52b4d466df44e", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 69, "deletions": 57, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f011f928dd69a5b770b348aea2c547431c34e11a/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=f011f928dd69a5b770b348aea2c547431c34e11a", "patch": "@@ -139,19 +139,17 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         make_conv_struct(cx, sp, rt_conv_flags, rt_conv_width,\n                          rt_conv_precision, rt_conv_ty)\n     }\n-    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: ~str, cnv: &Conv,\n-                      arg: @ast::expr) -> @ast::expr {\n+    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: &str, cnv: &Conv,\n+                      arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(cx, @fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n-        let args = ~[cnv_expr, arg];\n+        let args = ~[cnv_expr, arg, buf];\n         return mk_call_global(cx, arg.span, path, args);\n     }\n \n-    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: &Conv, arg: @ast::expr) ->\n-       @ast::expr {\n-        // FIXME: Move validation code into core::extfmt (Issue #2249)\n-\n+    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: &Conv,\n+                     arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         fn is_signed_type(cnv: &Conv) -> bool {\n             match cnv.ty {\n               TyInt(s) => match s {\n@@ -198,29 +196,20 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n           CountIs(_) => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n-        match cnv.ty {\n-          TyStr => return make_conv_call(cx, arg.span, ~\"str\", cnv, arg),\n-          TyInt(sign) => match sign {\n-            Signed => return make_conv_call(cx, arg.span, ~\"int\", cnv, arg),\n-            Unsigned => {\n-                return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg)\n-            }\n-          },\n-          TyBool => return make_conv_call(cx, arg.span, ~\"bool\", cnv, arg),\n-          TyChar => return make_conv_call(cx, arg.span, ~\"char\", cnv, arg),\n-          TyHex(_) => {\n-            return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n-          }\n-          TyBits => return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg),\n-          TyOctal => return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg),\n-          TyFloat => {\n-            return make_conv_call(cx, arg.span, ~\"float\", cnv, arg);\n-          }\n-          TyPoly => return make_conv_call(cx, arg.span, ~\"poly\", cnv,\n-                       mk_addr_of(cx, sp, arg))\n-        }\n+        let (name, actual_arg) = match cnv.ty {\n+            TyStr => (\"str\", arg),\n+            TyInt(Signed) => (\"int\", arg),\n+            TyBool => (\"bool\", arg),\n+            TyChar => (\"char\", arg),\n+            TyBits | TyOctal | TyHex(_) | TyInt(Unsigned) => (\"uint\", arg),\n+            TyFloat => (\"float\", arg),\n+            TyPoly => (\"poly\", mk_addr_of(cx, sp, arg))\n+        };\n+        return make_conv_call(cx, arg.span, name, cnv, actual_arg,\n+                              mk_mut_addr_of(cx, arg.span, buf));\n     }\n     fn log_conv(c: &Conv) {\n+        debug!(\"Building conversion:\");\n         match c.param {\n           Some(p) => { debug!(\"param: %s\", p.to_str()); }\n           _ => debug!(\"param: none\")\n@@ -268,49 +257,72 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n           TyPoly => debug!(\"type: poly\")\n         }\n     }\n+\n     let fmt_sp = args[0].span;\n     let mut n = 0u;\n-    let mut piece_exprs = ~[];\n     let nargs = args.len();\n-    for pieces.each |pc| {\n-        match *pc {\n-          PieceString(ref s) => {\n-            piece_exprs.push(mk_uniq_str(cx, fmt_sp, copy *s))\n-          }\n-          PieceConv(ref conv) => {\n-            n += 1u;\n-            if n >= nargs {\n-                cx.span_fatal(sp,\n-                              ~\"not enough arguments to fmt! \" +\n+\n+    /* 'ident' is the local buffer building up the result of fmt! */\n+    let ident = cx.parse_sess().interner.intern(@~\"__fmtbuf\");\n+    let buf = || mk_path(cx, fmt_sp, ~[ident]);\n+    let str_ident = cx.parse_sess().interner.intern(@~\"str\");\n+    let push_ident = cx.parse_sess().interner.intern(@~\"push_str\");\n+    let mut stms = ~[];\n+\n+    /* Translate each piece (portion of the fmt expression) by invoking the\n+       corresponding function in core::unstable::extfmt. Each function takes a\n+       buffer to insert data into along with the data being formatted. */\n+    do vec::consume(pieces) |i, pc| {\n+        match pc {\n+            /* Raw strings get appended via str::push_str */\n+            PieceString(s) => {\n+                let portion = mk_uniq_str(cx, fmt_sp, s);\n+\n+                /* If this is the first portion, then initialize the local\n+                   buffer with it directly */\n+                if i == 0 {\n+                    stms.push(mk_local(cx, fmt_sp, true, ident, portion));\n+                } else {\n+                    let args = ~[mk_mut_addr_of(cx, fmt_sp, buf()), portion];\n+                    let call = mk_call_global(cx,\n+                                              fmt_sp,\n+                                              ~[str_ident, push_ident],\n+                                              args);\n+                    stms.push(mk_stmt(cx, fmt_sp, call));\n+                }\n+            }\n+\n+            /* Invoke the correct conv function in extfmt */\n+            PieceConv(ref conv) => {\n+                n += 1u;\n+                if n >= nargs {\n+                    cx.span_fatal(sp,\n+                                  ~\"not enough arguments to fmt! \" +\n                                   ~\"for the given format string\");\n+                }\n+\n+                log_conv(conv);\n+                /* If the first portion is a conversion, then the local buffer\n+                   must be initialized as an empty string */\n+                if i == 0 {\n+                    stms.push(mk_local(cx, fmt_sp, true, ident,\n+                                       mk_uniq_str(cx, fmt_sp, ~\"\")));\n+                }\n+                stms.push(mk_stmt(cx, fmt_sp,\n+                                  make_new_conv(cx, fmt_sp, conv,\n+                                                args[n], buf())));\n             }\n-            debug!(\"Building conversion:\");\n-            log_conv(conv);\n-            let arg_expr = args[n];\n-            let c_expr = make_new_conv(\n-                cx,\n-                fmt_sp,\n-                conv,\n-                arg_expr\n-            );\n-            piece_exprs.push(c_expr);\n-          }\n         }\n     }\n-    let expected_nargs = n + 1u; // n conversions + the fmt string\n \n+    let expected_nargs = n + 1u; // n conversions + the fmt string\n     if expected_nargs < nargs {\n         cx.span_fatal\n             (sp, fmt!(\"too many arguments to fmt!. found %u, expected %u\",\n                            nargs, expected_nargs));\n     }\n \n-    let arg_vec = mk_fixed_vec_e(cx, fmt_sp, piece_exprs);\n-    return mk_call_global(cx,\n-                          fmt_sp,\n-                          ~[cx.parse_sess().interner.intern(@~\"str\"),\n-                            cx.parse_sess().interner.intern(@~\"concat\")],\n-                          ~[arg_vec]);\n+    return mk_block(cx, fmt_sp, ~[], stms, Some(buf()));\n }\n //\n // Local Variables:"}]}