{"sha": "09147c3303f0ffe607c0decb2979980f9a296a5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MTQ3YzMzMDNmMGZmZTYwN2MwZGVjYjI5Nzk5ODBmOWEyOTZhNWM=", "commit": {"author": {"name": "Comonad", "email": "comonad@foxmail.com", "date": "2021-04-21T11:33:45Z"}, "committer": {"name": "Comonad", "email": "comonad@foxmail.com", "date": "2021-04-21T11:33:45Z"}, "message": "Add support for fill match arms of boolean values\n\n- Add support for boolean inside tuple", "tree": {"sha": "bc0b13766f35ee23cf4bdd8603d24d83ebdc7231", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc0b13766f35ee23cf4bdd8603d24d83ebdc7231"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09147c3303f0ffe607c0decb2979980f9a296a5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09147c3303f0ffe607c0decb2979980f9a296a5c", "html_url": "https://github.com/rust-lang/rust/commit/09147c3303f0ffe607c0decb2979980f9a296a5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09147c3303f0ffe607c0decb2979980f9a296a5c/comments", "author": {"login": "komonad", "id": 69359480, "node_id": "MDQ6VXNlcjY5MzU5NDgw", "avatar_url": "https://avatars.githubusercontent.com/u/69359480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/komonad", "html_url": "https://github.com/komonad", "followers_url": "https://api.github.com/users/komonad/followers", "following_url": "https://api.github.com/users/komonad/following{/other_user}", "gists_url": "https://api.github.com/users/komonad/gists{/gist_id}", "starred_url": "https://api.github.com/users/komonad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/komonad/subscriptions", "organizations_url": "https://api.github.com/users/komonad/orgs", "repos_url": "https://api.github.com/users/komonad/repos", "events_url": "https://api.github.com/users/komonad/events{/privacy}", "received_events_url": "https://api.github.com/users/komonad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "komonad", "id": 69359480, "node_id": "MDQ6VXNlcjY5MzU5NDgw", "avatar_url": "https://avatars.githubusercontent.com/u/69359480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/komonad", "html_url": "https://github.com/komonad", "followers_url": "https://api.github.com/users/komonad/followers", "following_url": "https://api.github.com/users/komonad/following{/other_user}", "gists_url": "https://api.github.com/users/komonad/gists{/gist_id}", "starred_url": "https://api.github.com/users/komonad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/komonad/subscriptions", "organizations_url": "https://api.github.com/users/komonad/orgs", "repos_url": "https://api.github.com/users/komonad/repos", "events_url": "https://api.github.com/users/komonad/events{/privacy}", "received_events_url": "https://api.github.com/users/komonad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ae0bc1bd40286200f5e5b7a4d3b086312055ed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ae0bc1bd40286200f5e5b7a4d3b086312055ed5", "html_url": "https://github.com/rust-lang/rust/commit/7ae0bc1bd40286200f5e5b7a4d3b086312055ed5"}], "stats": {"total": 230, "additions": 207, "deletions": 23}, "files": [{"sha": "be927cc1c4728b6d006fb3ce5e40f810f5ea0f53", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 199, "deletions": 23, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/09147c3303f0ffe607c0decb2979980f9a296a5c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09147c3303f0ffe607c0decb2979980f9a296a5c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=09147c3303f0ffe607c0decb2979980f9a296a5c", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         .iter()\n         .filter_map(ast::MatchArm::pat)\n         .flat_map(|pat| match pat {\n-            // Special casee OrPat as separate top-level pats\n+            // Special case OrPat as separate top-level pats\n             Pat::OrPat(or_pat) => Either::Left(or_pat.pats()),\n             _ => Either::Right(iter::once(pat)),\n         })\n@@ -72,7 +72,11 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n             .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n             .collect::<Vec<_>>();\n-        if Some(enum_def) == FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option() {\n+        if Some(enum_def)\n+            == FamousDefs(&ctx.sema, Some(module.krate()))\n+                .core_option_Option()\n+                .map(|x| lift_enum(x))\n+        {\n             // Match `Some` variant first.\n             cov_mark::hit!(option_order);\n             variants.reverse()\n@@ -151,49 +155,99 @@ fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n     }\n }\n \n-fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<hir::Enum> {\n+#[derive(Eq, PartialEq, Clone)]\n+enum ExtendedEnum {\n+    Bool,\n+    Enum(hir::Enum),\n+}\n+\n+#[derive(Eq, PartialEq, Clone)]\n+enum ExtendedVariant {\n+    True,\n+    False,\n+    Variant(hir::Variant),\n+}\n+\n+fn lift_enum(e: hir::Enum) -> ExtendedEnum {\n+    ExtendedEnum::Enum(e)\n+}\n+\n+impl ExtendedEnum {\n+    fn variants(&self, db: &RootDatabase) -> Vec<ExtendedVariant> {\n+        match self {\n+            ExtendedEnum::Enum(e) => {\n+                e.variants(db).into_iter().map(|x| ExtendedVariant::Variant(x)).collect::<Vec<_>>()\n+            }\n+            ExtendedEnum::Bool => {\n+                Vec::<ExtendedVariant>::from([ExtendedVariant::True, ExtendedVariant::False])\n+            }\n+        }\n+    }\n+}\n+\n+fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<ExtendedEnum> {\n     sema.type_of_expr(&expr)?.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n-        Some(Adt::Enum(e)) => Some(e),\n-        _ => None,\n+        Some(Adt::Enum(e)) => Some(ExtendedEnum::Enum(e)),\n+        _ => {\n+            if ty.is_bool() {\n+                Some(ExtendedEnum::Bool)\n+            } else {\n+                None\n+            }\n+        }\n     })\n }\n \n fn resolve_tuple_of_enum_def(\n     sema: &Semantics<RootDatabase>,\n     expr: &ast::Expr,\n-) -> Option<Vec<hir::Enum>> {\n+) -> Option<Vec<ExtendedEnum>> {\n     sema.type_of_expr(&expr)?\n         .tuple_fields(sema.db)\n         .iter()\n         .map(|ty| {\n             ty.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n-                Some(Adt::Enum(e)) => Some(e),\n+                Some(Adt::Enum(e)) => Some(lift_enum(e)),\n                 // For now we only handle expansion for a tuple of enums. Here\n                 // we map non-enum items to None and rely on `collect` to\n                 // convert Vec<Option<hir::Enum>> into Option<Vec<hir::Enum>>.\n-                _ => None,\n+                _ => {\n+                    if ty.is_bool() {\n+                        Some(ExtendedEnum::Bool)\n+                    } else {\n+                        None\n+                    }\n+                }\n             })\n         })\n         .collect()\n }\n \n-fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::Variant) -> Option<ast::Pat> {\n-    let path = mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var))?);\n+fn build_pat(db: &RootDatabase, module: hir::Module, var: ExtendedVariant) -> Option<ast::Pat> {\n+    match var {\n+        ExtendedVariant::Variant(var) => {\n+            let path = mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var))?);\n+\n+            // FIXME: use HIR for this; it doesn't currently expose struct vs. tuple vs. unit variants though\n+            let pat: ast::Pat = match var.source(db)?.value.kind() {\n+                ast::StructKind::Tuple(field_list) => {\n+                    let pats =\n+                        iter::repeat(make::wildcard_pat().into()).take(field_list.fields().count());\n+                    make::tuple_struct_pat(path, pats).into()\n+                }\n+                ast::StructKind::Record(field_list) => {\n+                    let pats =\n+                        field_list.fields().map(|f| make::ident_pat(f.name().unwrap()).into());\n+                    make::record_pat(path, pats).into()\n+                }\n+                ast::StructKind::Unit => make::path_pat(path),\n+            };\n \n-    // FIXME: use HIR for this; it doesn't currently expose struct vs. tuple vs. unit variants though\n-    let pat: ast::Pat = match var.source(db)?.value.kind() {\n-        ast::StructKind::Tuple(field_list) => {\n-            let pats = iter::repeat(make::wildcard_pat().into()).take(field_list.fields().count());\n-            make::tuple_struct_pat(path, pats).into()\n-        }\n-        ast::StructKind::Record(field_list) => {\n-            let pats = field_list.fields().map(|f| make::ident_pat(f.name().unwrap()).into());\n-            make::record_pat(path, pats).into()\n+            Some(pat)\n         }\n-        ast::StructKind::Unit => make::path_pat(path),\n-    };\n-\n-    Some(pat)\n+        ExtendedVariant::True => Some(ast::Pat::from(make::literal_pat(\"true\"))),\n+        ExtendedVariant::False => Some(ast::Pat::from(make::literal_pat(\"false\"))),\n+    }\n }\n \n #[cfg(test)]\n@@ -225,6 +279,21 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn all_boolean_match_arms_provided() {\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match a$0 {\n+                    true => {}\n+                    false => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n     #[test]\n     fn tuple_of_non_enum() {\n         // for now this case is not handled, although it potentially could be\n@@ -240,6 +309,113 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn fill_match_arms_boolean() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match a$0 {\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn foo(a: bool) {\n+                match a {\n+                    $0true => {}\n+                    false => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn partial_fill_boolean() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match a$0 {\n+                    true => {}\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn foo(a: bool) {\n+                match a {\n+                    true => {}\n+                    $0false => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn all_boolean_tuple_arms_provided() {\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match (a, a)$0 {\n+                    (true, true) => {}\n+                    (true, false) => {}\n+                    (false, true) => {}\n+                    (false, false) => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn fill_boolean_tuple() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match (a, a)$0 {\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn foo(a: bool) {\n+                match (a, a) {\n+                    $0(true, true) => {}\n+                    (true, false) => {}\n+                    (false, true) => {}\n+                    (false, false) => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn partial_fill_boolean_tuple() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            fn foo(a: bool) {\n+                match (a, a)$0 {\n+                    (false, true) => {}\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn foo(a: bool) {\n+                match (a, a) {\n+                    (false, true) => {}\n+                    $0(true, true) => {}\n+                    (true, false) => {}\n+                    (false, false) => {}\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n     #[test]\n     fn partial_fill_record_tuple() {\n         check_assist("}, {"sha": "4cf6f871e2c92a9cc3cd7001bea8654da9ef41b7", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09147c3303f0ffe607c0decb2979980f9a296a5c/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09147c3303f0ffe607c0decb2979980f9a296a5c/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=09147c3303f0ffe607c0decb2979980f9a296a5c", "patch": "@@ -294,6 +294,14 @@ pub fn wildcard_pat() -> ast::WildcardPat {\n     }\n }\n \n+pub fn literal_pat(lit: &str) -> ast::LiteralPat {\n+    return from_text(lit);\n+\n+    fn from_text(text: &str) -> ast::LiteralPat {\n+        ast_from_text(&format!(\"fn f() {{ match x {{ {} => {{}} }} }}\", text))\n+    }\n+}\n+\n /// Creates a tuple of patterns from an iterator of patterns.\n ///\n /// Invariant: `pats` must be length > 0"}]}