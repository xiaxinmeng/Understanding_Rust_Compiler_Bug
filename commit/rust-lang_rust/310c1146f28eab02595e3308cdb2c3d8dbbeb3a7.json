{"sha": "310c1146f28eab02595e3308cdb2c3d8dbbeb3a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMGMxMTQ2ZjI4ZWFiMDI1OTVlMzMwOGNkYjJjM2Q4ZGJiZWIzYTc=", "commit": {"author": {"name": "David Lukes", "email": "dafydd.lukes@gmail.com", "date": "2018-02-26T11:49:12Z"}, "committer": {"name": "David Lukes", "email": "dafydd.lukes@gmail.com", "date": "2018-03-05T12:13:55Z"}, "message": "Move license template parsing into submodule", "tree": {"sha": "b8482efcd0439701bb5448db0cf4e1a3eb8bbfd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8482efcd0439701bb5448db0cf4e1a3eb8bbfd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7", "html_url": "https://github.com/rust-lang/rust/commit/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7/comments", "author": {"login": "dlukes", "id": 2734517, "node_id": "MDQ6VXNlcjI3MzQ1MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2734517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlukes", "html_url": "https://github.com/dlukes", "followers_url": "https://api.github.com/users/dlukes/followers", "following_url": "https://api.github.com/users/dlukes/following{/other_user}", "gists_url": "https://api.github.com/users/dlukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlukes/subscriptions", "organizations_url": "https://api.github.com/users/dlukes/orgs", "repos_url": "https://api.github.com/users/dlukes/repos", "events_url": "https://api.github.com/users/dlukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dlukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dlukes", "id": 2734517, "node_id": "MDQ6VXNlcjI3MzQ1MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2734517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlukes", "html_url": "https://github.com/dlukes", "followers_url": "https://api.github.com/users/dlukes/followers", "following_url": "https://api.github.com/users/dlukes/following{/other_user}", "gists_url": "https://api.github.com/users/dlukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlukes/subscriptions", "organizations_url": "https://api.github.com/users/dlukes/orgs", "repos_url": "https://api.github.com/users/dlukes/repos", "events_url": "https://api.github.com/users/dlukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dlukes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e48d7f3ebb3ee16d24ec8351f16768ea8f6ed9b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e48d7f3ebb3ee16d24ec8351f16768ea8f6ed9b0", "html_url": "https://github.com/rust-lang/rust/commit/e48d7f3ebb3ee16d24ec8351f16768ea8f6ed9b0"}], "stats": {"total": 352, "additions": 177, "deletions": 175}, "files": [{"sha": "4563f8a7809faa9e49a943495515188be4eed8d0", "filename": "rustfmt-config/src/license.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7/rustfmt-config%2Fsrc%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7/rustfmt-config%2Fsrc%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Flicense.rs?ref=310c1146f28eab02595e3308cdb2c3d8dbbeb3a7", "patch": "@@ -0,0 +1,174 @@\n+use regex;\n+\n+/// Convert the license template into a string which can be turned into a regex.\n+///\n+/// The license template could use regex syntax directly, but that would require a lot of manual\n+/// escaping, which is inconvenient. It is therefore literal by default, with optional regex\n+/// subparts delimited by `{` and `}`. Additionally:\n+///\n+/// - to insert literal `{`, `}` or `\\`, escape it with `\\`\n+/// - an empty regex placeholder (`{}`) is shorthand for `{.*?}`\n+///\n+/// This function parses this input format and builds a properly escaped *string* representation of\n+/// the equivalent regular expression. It **does not** however guarantee that the returned string is\n+/// a syntactically valid regular expression.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # use rustfmt_config::license;\n+/// assert_eq!(\n+///     license::parse_template(\n+///         r\"\n+/// // Copyright {\\d+} The \\} Rust \\\\ Project \\{ Developers. See the {([A-Z]+)}\n+/// // file at the top-level directory of this distribution and at\n+/// // {}.\n+/// //\n+/// // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+/// // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+/// // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+/// // option. This file may not be copied, modified, or distributed\n+/// // except according to those terms.\n+/// \"\n+///     ).unwrap(),\n+///     r\"^\n+/// // Copyright \\d+ The \\} Rust \\\\ Project \\{ Developers\\. See the ([A-Z]+)\n+/// // file at the top\\-level directory of this distribution and at\n+/// // .*?\\.\n+/// //\n+/// // Licensed under the Apache License, Version 2\\.0 <LICENSE\\-APACHE or\n+/// // http://www\\.apache\\.org/licenses/LICENSE\\-2\\.0> or the MIT license\n+/// // <LICENSE\\-MIT or http://opensource\\.org/licenses/MIT>, at your\n+/// // option\\. This file may not be copied, modified, or distributed\n+/// // except according to those terms\\.\n+/// \"\n+/// );\n+/// ```\n+pub fn parse_template(template: &str) -> Result<String, String> {\n+    // the template is parsed using a state machine\n+    enum State {\n+        Lit,\n+        LitEsc,\n+        // the u32 keeps track of brace nesting\n+        Re(u32),\n+        ReEsc(u32),\n+    }\n+\n+    let mut parsed = String::from(\"^\");\n+    let mut buffer = String::new();\n+    let mut state = State::Lit;\n+    let mut linum = 1;\n+    // keeps track of last line on which a regex placeholder was started\n+    let mut open_brace_line = 0;\n+    for chr in template.chars() {\n+        if chr == '\\n' {\n+            linum += 1;\n+        }\n+        state = match state {\n+            State::Lit => match chr {\n+                '{' => {\n+                    parsed.push_str(&regex::escape(&buffer));\n+                    buffer.clear();\n+                    open_brace_line = linum;\n+                    State::Re(1)\n+                }\n+                '}' => return Err(format!(\"escape or balance closing brace on l. {}\", linum)),\n+                '\\\\' => State::LitEsc,\n+                _ => {\n+                    buffer.push(chr);\n+                    State::Lit\n+                }\n+            },\n+            State::LitEsc => {\n+                buffer.push(chr);\n+                State::Lit\n+            }\n+            State::Re(brace_nesting) => {\n+                match chr {\n+                    '{' => {\n+                        buffer.push(chr);\n+                        State::Re(brace_nesting + 1)\n+                    }\n+                    '}' => {\n+                        match brace_nesting {\n+                            1 => {\n+                                // default regex for empty placeholder {}\n+                                if buffer.is_empty() {\n+                                    buffer = \".*?\".to_string();\n+                                }\n+                                parsed.push_str(&buffer);\n+                                buffer.clear();\n+                                State::Lit\n+                            }\n+                            _ => {\n+                                buffer.push(chr);\n+                                State::Re(brace_nesting - 1)\n+                            }\n+                        }\n+                    }\n+                    '\\\\' => {\n+                        buffer.push(chr);\n+                        State::ReEsc(brace_nesting)\n+                    }\n+                    _ => {\n+                        buffer.push(chr);\n+                        State::Re(brace_nesting)\n+                    }\n+                }\n+            }\n+            State::ReEsc(brace_nesting) => {\n+                buffer.push(chr);\n+                State::Re(brace_nesting)\n+            }\n+        }\n+    }\n+    match state {\n+        State::Re(_) | State::ReEsc(_) => {\n+            return Err(format!(\n+                \"escape or balance opening brace on l. {}\",\n+                open_brace_line\n+            ));\n+        }\n+        State::LitEsc => return Err(format!(\"incomplete escape sequence on l. {}\", linum)),\n+        _ => (),\n+    }\n+    parsed.push_str(&regex::escape(&buffer));\n+\n+    Ok(parsed)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::parse_template;\n+\n+    #[test]\n+    fn test_parse_license_template() {\n+        assert_eq!(\n+            parse_template(\"literal (.*)\").unwrap(),\n+            r\"^literal \\(\\.\\*\\)\"\n+        );\n+        assert_eq!(parse_template(r\"escaping \\}\").unwrap(), r\"^escaping \\}\");\n+        assert!(parse_template(\"unbalanced } without escape\").is_err());\n+        assert_eq!(\n+            parse_template(r\"{\\d+} place{-?}holder{s?}\").unwrap(),\n+            r\"^\\d+ place-?holders?\"\n+        );\n+        assert_eq!(parse_template(\"default {}\").unwrap(), \"^default .*?\");\n+        assert_eq!(\n+            parse_template(r\"unbalanced nested braces {\\{{3}}\").unwrap(),\n+            r\"^unbalanced nested braces \\{{3}\"\n+        );\n+        assert_eq!(\n+            parse_template(\"parsing error }\").unwrap_err(),\n+            \"escape or balance closing brace on l. 1\"\n+        );\n+        assert_eq!(\n+            parse_template(\"parsing error {\\nsecond line\").unwrap_err(),\n+            \"escape or balance opening brace on l. 1\"\n+        );\n+        assert_eq!(\n+            parse_template(r\"parsing error \\\").unwrap_err(),\n+            \"incomplete escape sequence on l. 1\"\n+        );\n+    }\n+}"}, {"sha": "fe0e4c309e2528dd4ff83a3270946ca9fe1350fb", "filename": "src/config/config_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7/src%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7/src%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fconfig_type.rs?ref=310c1146f28eab02595e3308cdb2c3d8dbbeb3a7", "patch": "@@ -408,7 +408,7 @@ macro_rules! create_config {\n                                 license_template_path, e);\n                         return;\n                     };\n-                    let license_template_parsed = match parse_license_template(&license_template_str) {\n+                    let license_template_parsed = match license::parse_template(&license_template_str) {\n                         Ok(string) => string,\n                         Err(e) => {\n                             eprintln!(\"Warning: unable to parse license template file {:?}: {}\","}, {"sha": "0d4ec8557d383f334b617dec15f346ab927fd9c4", "filename": "src/config/mod.rs", "status": "modified", "additions": 2, "deletions": 174, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=310c1146f28eab02595e3308cdb2c3d8dbbeb3a7", "patch": "@@ -25,6 +25,7 @@ mod options;\n pub mod file_lines;\n pub mod lists;\n pub mod summary;\n+pub mod license;\n \n use config::config_type::ConfigType;\n use config::file_lines::FileLines;\n@@ -174,145 +175,9 @@ pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n     Ok(None)\n }\n \n-/// Convert the license template into a string which can be turned into a regex.\n-///\n-/// The license template could use regex syntax directly, but that would require a lot of manual\n-/// escaping, which is inconvenient. It is therefore literal by default, with optional regex\n-/// subparts delimited by `{` and `}`. Additionally:\n-///\n-/// - to insert literal `{`, `}` or `\\`, escape it with `\\`\n-/// - an empty regex placeholder (`{}`) is shorthand for `{.*?}`\n-///\n-/// This function parses this input format and builds a properly escaped *string* representation of\n-/// the equivalent regular expression. It **does not** however guarantee that the returned string is\n-/// a syntactically valid regular expression.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// assert_eq!(\n-///     rustfmt_config::parse_license_template(\n-///         r\"\n-/// // Copyright {\\d+} The \\} Rust \\\\ Project \\{ Developers. See the {([A-Z]+)}\n-/// // file at the top-level directory of this distribution and at\n-/// // {}.\n-/// //\n-/// // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-/// // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-/// // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-/// // option. This file may not be copied, modified, or distributed\n-/// // except according to those terms.\n-/// \"\n-///     ).unwrap(),\n-///     r\"^\n-/// // Copyright \\d+ The \\} Rust \\\\ Project \\{ Developers\\. See the ([A-Z]+)\n-/// // file at the top\\-level directory of this distribution and at\n-/// // .*?\\.\n-/// //\n-/// // Licensed under the Apache License, Version 2\\.0 <LICENSE\\-APACHE or\n-/// // http://www\\.apache\\.org/licenses/LICENSE\\-2\\.0> or the MIT license\n-/// // <LICENSE\\-MIT or http://opensource\\.org/licenses/MIT>, at your\n-/// // option\\. This file may not be copied, modified, or distributed\n-/// // except according to those terms\\.\n-/// \"\n-/// );\n-/// ```\n-pub fn parse_license_template(template: &str) -> Result<String, String> {\n-    // the template is parsed using a state machine\n-    enum State {\n-        Lit,\n-        LitEsc,\n-        // the u32 keeps track of brace nesting\n-        Re(u32),\n-        ReEsc(u32),\n-    }\n-\n-    let mut parsed = String::from(\"^\");\n-    let mut buffer = String::new();\n-    let mut state = State::Lit;\n-    let mut linum = 1;\n-    // keeps track of last line on which a regex placeholder was started\n-    let mut open_brace_line = 0;\n-    for chr in template.chars() {\n-        if chr == '\\n' {\n-            linum += 1;\n-        }\n-        state = match state {\n-            State::Lit => match chr {\n-                '{' => {\n-                    parsed.push_str(&regex::escape(&buffer));\n-                    buffer.clear();\n-                    open_brace_line = linum;\n-                    State::Re(1)\n-                }\n-                '}' => return Err(format!(\"escape or balance closing brace on l. {}\", linum)),\n-                '\\\\' => State::LitEsc,\n-                _ => {\n-                    buffer.push(chr);\n-                    State::Lit\n-                }\n-            },\n-            State::LitEsc => {\n-                buffer.push(chr);\n-                State::Lit\n-            }\n-            State::Re(brace_nesting) => {\n-                match chr {\n-                    '{' => {\n-                        buffer.push(chr);\n-                        State::Re(brace_nesting + 1)\n-                    }\n-                    '}' => {\n-                        match brace_nesting {\n-                            1 => {\n-                                // default regex for empty placeholder {}\n-                                if buffer.is_empty() {\n-                                    buffer = \".*?\".to_string();\n-                                }\n-                                parsed.push_str(&buffer);\n-                                buffer.clear();\n-                                State::Lit\n-                            }\n-                            _ => {\n-                                buffer.push(chr);\n-                                State::Re(brace_nesting - 1)\n-                            }\n-                        }\n-                    }\n-                    '\\\\' => {\n-                        buffer.push(chr);\n-                        State::ReEsc(brace_nesting)\n-                    }\n-                    _ => {\n-                        buffer.push(chr);\n-                        State::Re(brace_nesting)\n-                    }\n-                }\n-            }\n-            State::ReEsc(brace_nesting) => {\n-                buffer.push(chr);\n-                State::Re(brace_nesting)\n-            }\n-        }\n-    }\n-    match state {\n-        State::Re(_) | State::ReEsc(_) => {\n-            return Err(format!(\n-                \"escape or balance opening brace on l. {}\",\n-                open_brace_line\n-            ));\n-        }\n-        State::LitEsc => return Err(format!(\"incomplete escape sequence on l. {}\", linum)),\n-        _ => (),\n-    }\n-    parsed.push_str(&regex::escape(&buffer));\n-\n-    Ok(parsed)\n-}\n-\n #[cfg(test)]\n mod test {\n-    use super::{parse_license_template, Config};\n+    use super::Config;\n \n     #[test]\n     fn test_config_set() {\n@@ -349,43 +214,6 @@ mod test {\n         assert_eq!(config.was_set().verbose(), false);\n     }\n \n-    #[test]\n-    fn test_parse_license_template() {\n-        assert_eq!(\n-            parse_license_template(\"literal (.*)\").unwrap(),\n-            r\"^literal \\(\\.\\*\\)\"\n-        );\n-        assert_eq!(\n-            parse_license_template(r\"escaping \\}\").unwrap(),\n-            r\"^escaping \\}\"\n-        );\n-        assert!(parse_license_template(\"unbalanced } without escape\").is_err());\n-        assert_eq!(\n-            parse_license_template(r\"{\\d+} place{-?}holder{s?}\").unwrap(),\n-            r\"^\\d+ place-?holders?\"\n-        );\n-        assert_eq!(\n-            parse_license_template(\"default {}\").unwrap(),\n-            \"^default .*?\"\n-        );\n-        assert_eq!(\n-            parse_license_template(r\"unbalanced nested braces {\\{{3}}\").unwrap(),\n-            r\"^unbalanced nested braces \\{{3}\"\n-        );\n-        assert_eq!(\n-            parse_license_template(\"parsing error }\").unwrap_err(),\n-            \"escape or balance closing brace on l. 1\"\n-        );\n-        assert_eq!(\n-            parse_license_template(\"parsing error {\\nsecond line\").unwrap_err(),\n-            \"escape or balance opening brace on l. 1\"\n-        );\n-        assert_eq!(\n-            parse_license_template(r\"parsing error \\\").unwrap_err(),\n-            \"incomplete escape sequence on l. 1\"\n-        );\n-    }\n-\n     // FIXME(#2183) these tests cannot be run in parallel because they use env vars\n     // #[test]\n     // fn test_as_not_nightly_channel() {"}]}