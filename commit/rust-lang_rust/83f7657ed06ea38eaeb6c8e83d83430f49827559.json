{"sha": "83f7657ed06ea38eaeb6c8e83d83430f49827559", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZjc2NTdlZDA2ZWEzOGVhZWI2YzhlODNkODM0MzBmNDk4Mjc1NTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-28T13:19:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-28T13:19:25Z"}, "message": "Auto merge of #1603 - RalfJung:track-raw, r=oli-obk\n\nadd an option to track raw pointer tags in Stacked Borrows\n\nAlso make error messages more informative by printing the affected memory location", "tree": {"sha": "fbcf7ed4dce1764e2d9da5cc4de1836f6ddb7a52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbcf7ed4dce1764e2d9da5cc4de1836f6ddb7a52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83f7657ed06ea38eaeb6c8e83d83430f49827559", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83f7657ed06ea38eaeb6c8e83d83430f49827559", "html_url": "https://github.com/rust-lang/rust/commit/83f7657ed06ea38eaeb6c8e83d83430f49827559", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83f7657ed06ea38eaeb6c8e83d83430f49827559/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "606436753abeb7d0251d17f8e0c91d4ec162765a", "url": "https://api.github.com/repos/rust-lang/rust/commits/606436753abeb7d0251d17f8e0c91d4ec162765a", "html_url": "https://github.com/rust-lang/rust/commit/606436753abeb7d0251d17f8e0c91d4ec162765a"}, {"sha": "bf54607ba03cf12a015e7027be6d5ffdf08cc3ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf54607ba03cf12a015e7027be6d5ffdf08cc3ca", "html_url": "https://github.com/rust-lang/rust/commit/bf54607ba03cf12a015e7027be6d5ffdf08cc3ca"}], "stats": {"total": 188, "additions": 106, "deletions": 82}, "files": [{"sha": "42ea9b8448be474280be1736993752f51d5a8964", "filename": "README.md", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83f7657ed06ea38eaeb6c8e83d83430f49827559/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/83f7657ed06ea38eaeb6c8e83d83430f49827559/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=83f7657ed06ea38eaeb6c8e83d83430f49827559", "patch": "@@ -230,13 +230,20 @@ environment variable:\n * `-Zmiri-track-alloc-id=<id>` shows a backtrace when the given allocation is\n   being allocated or freed.  This helps in debugging memory leaks and\n   use after free bugs.\n+* `-Zmiri-track-call-id=<id>` shows a backtrace when the given call id is\n+  assigned to a stack frame.  This helps in debugging UB related to Stacked\n+  Borrows \"protectors\".\n * `-Zmiri-track-pointer-tag=<tag>` shows a backtrace when the given pointer tag\n   is popped from a borrow stack (which is where the tag becomes invalid and any\n   future use of it will error).  This helps you in finding out why UB is\n   happening and where in your code would be a good place to look for it.\n-* `-Zmiri-track-call-id=<id>` shows a backtrace when the given call id is\n-  assigned to a stack frame.  This helps in debugging UB related to Stacked\n-  Borrows \"protectors\".\n+* `-Zmiri-track-raw-pointers` makes Stacked Borrows track a pointer tag even for\n+  raw pointers. This can make valid code fail to pass the checks, but also can\n+  help identify latent aliasing issues in code that Miri accepts by default. You\n+  can recognize false positives by \"<untagged>\" occurring in the message -- this\n+  indicates a pointer that was cast from an integer, so Miri was unable to track\n+  this pointer. Make sure to use a non-Windows target with this flag, as the\n+  Windows runtime makes use of integer-pointer casts.\n \n Some native rustc `-Z` flags are also very relevant for Miri:\n "}, {"sha": "ef1429a35020aa8674720b386bdb22bd44005af1", "filename": "src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83f7657ed06ea38eaeb6c8e83d83430f49827559/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f7657ed06ea38eaeb6c8e83d83430f49827559/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=83f7657ed06ea38eaeb6c8e83d83430f49827559", "patch": "@@ -207,6 +207,9 @@ fn main() {\n                 \"-Zmiri-ignore-leaks\" => {\n                     miri_config.ignore_leaks = true;\n                 }\n+                \"-Zmiri-track-raw-pointers\" => {\n+                    miri_config.track_raw = true;\n+                }\n                 \"--\" => {\n                     after_dashdash = true;\n                 }"}, {"sha": "54d06feec36dd256925afbb36f3b30eccfa38773", "filename": "src/eval.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83f7657ed06ea38eaeb6c8e83d83430f49827559/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f7657ed06ea38eaeb6c8e83d83430f49827559/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=83f7657ed06ea38eaeb6c8e83d83430f49827559", "patch": "@@ -3,8 +3,6 @@\n use std::convert::TryFrom;\n use std::ffi::OsStr;\n \n-use rand::rngs::StdRng;\n-use rand::SeedableRng;\n use log::info;\n \n use rustc_hir::def_id::DefId;\n@@ -48,6 +46,8 @@ pub struct MiriConfig {\n     pub tracked_call_id: Option<CallId>,\n     /// The allocation id to report about.\n     pub tracked_alloc_id: Option<AllocId>,\n+    /// Whether to track raw pointers in stacked borrows.\n+    pub track_raw: bool,\n }\n \n impl Default for MiriConfig {\n@@ -64,6 +64,7 @@ impl Default for MiriConfig {\n             tracked_pointer_tag: None,\n             tracked_call_id: None,\n             tracked_alloc_id: None,\n+            track_raw: false,\n         }\n     }\n }\n@@ -84,14 +85,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         rustc_span::source_map::DUMMY_SP,\n         param_env,\n         Evaluator::new(config.communicate, config.validate, layout_cx),\n-        MemoryExtra::new(\n-            StdRng::seed_from_u64(config.seed.unwrap_or(0)),\n-            config.stacked_borrows,\n-            config.tracked_pointer_tag,\n-            config.tracked_call_id,\n-            config.tracked_alloc_id,\n-            config.check_alignment,\n-        ),\n+        MemoryExtra::new(&config),\n     );\n     // Complete initialization.\n     EnvVars::init(&mut ecx, config.excluded_env_vars)?;"}, {"sha": "e9f9298e566c8d3d6a192e207d4cbee0b2258ba0", "filename": "src/machine.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/83f7657ed06ea38eaeb6c8e83d83430f49827559/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f7657ed06ea38eaeb6c8e83d83430f49827559/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=83f7657ed06ea38eaeb6c8e83d83430f49827559", "patch": "@@ -10,6 +10,7 @@ use std::fmt;\n \n use log::trace;\n use rand::rngs::StdRng;\n+use rand::SeedableRng;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::{\n@@ -132,16 +133,14 @@ pub struct MemoryExtra {\n }\n \n impl MemoryExtra {\n-    pub fn new(\n-        rng: StdRng,\n-        stacked_borrows: bool,\n-        tracked_pointer_tag: Option<PtrId>,\n-        tracked_call_id: Option<CallId>,\n-        tracked_alloc_id: Option<AllocId>,\n-        check_alignment: AlignmentCheck,\n-    ) -> Self {\n-        let stacked_borrows = if stacked_borrows {\n-            Some(Rc::new(RefCell::new(stacked_borrows::GlobalState::new(tracked_pointer_tag, tracked_call_id))))\n+    pub fn new(config: &MiriConfig) -> Self {\n+        let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n+        let stacked_borrows = if config.stacked_borrows {\n+            Some(Rc::new(RefCell::new(stacked_borrows::GlobalState::new(\n+                config.tracked_pointer_tag,\n+                config.tracked_call_id,\n+                config.track_raw,\n+            ))))\n         } else {\n             None\n         };\n@@ -150,8 +149,8 @@ impl MemoryExtra {\n             intptrcast: Default::default(),\n             extern_statics: FxHashMap::default(),\n             rng: RefCell::new(rng),\n-            tracked_alloc_id,\n-            check_alignment,\n+            tracked_alloc_id: config.tracked_alloc_id,\n+            check_alignment: config.check_alignment,\n         }\n     }\n "}, {"sha": "607c830530e1f15f63fb6a093c6b01fe8466f34d", "filename": "src/range_map.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/83f7657ed06ea38eaeb6c8e83d83430f49827559/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f7657ed06ea38eaeb6c8e83d83430f49827559/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=83f7657ed06ea38eaeb6c8e83d83430f49827559", "patch": "@@ -61,7 +61,9 @@ impl<T> RangeMap<T> {\n     /// Provides read-only iteration over everything in the given range. This does\n     /// *not* split items if they overlap with the edges. Do not use this to mutate\n     /// through interior mutability.\n-    pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = &'a T> + 'a {\n+    ///\n+    /// The iterator also provides the offset of the given element.\n+    pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = (Size, &'a T)> + 'a {\n         let offset = offset.bytes();\n         let len = len.bytes();\n         // Compute a slice starting with the elements we care about.\n@@ -75,7 +77,7 @@ impl<T> RangeMap<T> {\n         };\n         // The first offset that is not included any more.\n         let end = offset + len;\n-        slice.iter().take_while(move |elem| elem.range.start < end).map(|elem| &elem.data)\n+        slice.iter().take_while(move |elem| elem.range.start < end).map(|elem| (Size::from_bytes(elem.range.start), &elem.data))\n     }\n \n     pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n@@ -112,11 +114,13 @@ impl<T> RangeMap<T> {\n     /// this will split entries in the map that are only partially hit by the given range,\n     /// to make sure that when they are mutated, the effect is constrained to the given range.\n     /// Moreover, this will opportunistically merge neighbouring equal blocks.\n+    ///\n+    /// The iterator also provides the offset of the given element.\n     pub fn iter_mut<'a>(\n         &'a mut self,\n         offset: Size,\n         len: Size,\n-    ) -> impl Iterator<Item = &'a mut T> + 'a\n+    ) -> impl Iterator<Item = (Size, &'a mut T)> + 'a\n     where\n         T: Clone + PartialEq,\n     {\n@@ -197,7 +201,7 @@ impl<T> RangeMap<T> {\n             // Now we yield the slice. `end` is inclusive.\n             &mut self.v[first_idx..=end_idx]\n         };\n-        slice.iter_mut().map(|elem| &mut elem.data)\n+        slice.iter_mut().map(|elem| (Size::from_bytes(elem.range.start), &mut elem.data))\n     }\n }\n \n@@ -209,26 +213,26 @@ mod tests {\n     fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n         (offset..offset + len)\n             .into_iter()\n-            .map(|i| map.iter(Size::from_bytes(i), Size::from_bytes(1)).next().map(|&t| t).unwrap())\n+            .map(|i| map.iter(Size::from_bytes(i), Size::from_bytes(1)).next().map(|(_, &t)| t).unwrap())\n             .collect()\n     }\n \n     #[test]\n     fn basic_insert() {\n         let mut map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n         // Insert.\n-        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(1)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(10), Size::from_bytes(1)) {\n             *x = 42;\n         }\n         // Check.\n         assert_eq!(to_vec(&map, 10, 1), vec![42]);\n         assert_eq!(map.v.len(), 3);\n \n         // Insert with size 0.\n-        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n             *x = 19;\n         }\n-        for x in map.iter_mut(Size::from_bytes(11), Size::from_bytes(0)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(11), Size::from_bytes(0)) {\n             *x = 19;\n         }\n         assert_eq!(to_vec(&map, 10, 2), vec![42, -1]);\n@@ -238,16 +242,16 @@ mod tests {\n     #[test]\n     fn gaps() {\n         let mut map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n-        for x in map.iter_mut(Size::from_bytes(11), Size::from_bytes(1)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(11), Size::from_bytes(1)) {\n             *x = 42;\n         }\n-        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(1)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(15), Size::from_bytes(1)) {\n             *x = 43;\n         }\n         assert_eq!(map.v.len(), 5);\n         assert_eq!(to_vec(&map, 10, 10), vec![-1, 42, -1, -1, -1, 43, -1, -1, -1, -1]);\n \n-        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(10)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(10), Size::from_bytes(10)) {\n             if *x < 42 {\n                 *x = 23;\n             }\n@@ -256,14 +260,14 @@ mod tests {\n         assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]);\n         assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 43, 23, 23]);\n \n-        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {\n             *x = 19;\n         }\n         assert_eq!(map.v.len(), 6);\n         assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]);\n         // Should be seeing two blocks with 19.\n         assert_eq!(\n-            map.iter(Size::from_bytes(15), Size::from_bytes(2)).map(|&t| t).collect::<Vec<_>>(),\n+            map.iter(Size::from_bytes(15), Size::from_bytes(2)).map(|(_, &t)| t).collect::<Vec<_>>(),\n             vec![19, 19]\n         );\n "}, {"sha": "616950eb0a0a44a5ca923ae78a7a68c3c2c6e9e3", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/83f7657ed06ea38eaeb6c8e83d83430f49827559/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f7657ed06ea38eaeb6c8e83d83430f49827559/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=83f7657ed06ea38eaeb6c8e83d83430f49827559", "patch": "@@ -108,6 +108,8 @@ pub struct GlobalState {\n     tracked_pointer_tag: Option<PtrId>,\n     /// The call id to trace\n     tracked_call_id: Option<CallId>,\n+    /// Whether to track raw pointers.\n+    track_raw: bool,\n }\n /// Memory extra state gives us interior mutable access to the global state.\n pub type MemoryExtra = Rc<RefCell<GlobalState>>;\n@@ -155,14 +157,15 @@ impl fmt::Display for RefKind {\n \n /// Utilities for initialization and ID generation\n impl GlobalState {\n-    pub fn new(tracked_pointer_tag: Option<PtrId>, tracked_call_id: Option<CallId>) -> Self {\n+    pub fn new(tracked_pointer_tag: Option<PtrId>, tracked_call_id: Option<CallId>, track_raw: bool) -> Self {\n         GlobalState {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n             base_ptr_ids: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n             active_calls: FxHashSet::default(),\n             tracked_pointer_tag,\n             tracked_call_id,\n+            track_raw,\n         }\n     }\n \n@@ -309,14 +312,14 @@ impl<'tcx> Stack {\n \n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n     /// If yes, return the index of the item that granted it.\n-    fn access(&mut self, access: AccessKind, tag: Tag, global: &GlobalState) -> InterpResult<'tcx> {\n+    fn access(&mut self, access: AccessKind, ptr: Pointer<Tag>, global: &GlobalState) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n+        let granting_idx = self.find_granting(access, ptr.tag).ok_or_else(|| {\n             err_sb_ub(format!(\n-                \"no item granting {} to tag {:?} found in borrow stack.\",\n-                access, tag\n+                \"no item granting {} to tag {:?} at {} found in borrow stack.\",\n+                access, ptr.tag, ptr.erase_tag(),\n             ))\n         })?;\n \n@@ -328,7 +331,7 @@ impl<'tcx> Stack {\n             let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n-                Stack::check_protector(&item, Some(tag), global)?;\n+                Stack::check_protector(&item, Some(ptr.tag), global)?;\n             }\n         } else {\n             // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n@@ -343,7 +346,7 @@ impl<'tcx> Stack {\n                 let item = &mut self.borrows[idx];\n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n-                    Stack::check_protector(item, Some(tag), global)?;\n+                    Stack::check_protector(item, Some(ptr.tag), global)?;\n                     item.perm = Permission::Disabled;\n                 }\n             }\n@@ -355,12 +358,12 @@ impl<'tcx> Stack {\n \n     /// Deallocate a location: Like a write access, but also there must be no\n     /// active protectors at all because we will remove all items.\n-    fn dealloc(&mut self, tag: Tag, global: &GlobalState) -> InterpResult<'tcx> {\n+    fn dealloc(&mut self, ptr: Pointer<Tag>, global: &GlobalState) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n-        self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n+        self.find_granting(AccessKind::Write, ptr.tag).ok_or_else(|| {\n             err_sb_ub(format!(\n-                \"no item granting write access for deallocation to tag {:?} found in borrow stack\",\n-                tag,\n+                \"no item granting write access for deallocation to tag {:?} at {} found in borrow stack\",\n+                ptr.tag, ptr.erase_tag(),\n             ))\n         })?;\n \n@@ -372,20 +375,20 @@ impl<'tcx> Stack {\n         Ok(())\n     }\n \n-    /// Derived a new pointer from one with the given tag.\n+    /// Derive a new pointer from one with the given tag.\n     /// `weak` controls whether this operation is weak or strong: weak granting does not act as\n     /// an access, and they add the new item directly on top of the one it is derived\n     /// from instead of all the way at the top of the stack.\n-    fn grant(&mut self, derived_from: Tag, new: Item, global: &GlobalState) -> InterpResult<'tcx> {\n+    fn grant(&mut self, derived_from: Pointer<Tag>, new: Item, global: &GlobalState) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let granting_idx = self.find_granting(access, derived_from)\n+        let granting_idx = self.find_granting(access, derived_from.tag)\n             .ok_or_else(|| err_sb_ub(format!(\n-                \"trying to reborrow for {:?}, but parent tag {:?} does not have an appropriate item in the borrow stack\",\n-                new.perm, derived_from,\n+                \"trying to reborrow for {:?} at {}, but parent tag {:?} does not have an appropriate item in the borrow stack\",\n+                new.perm, derived_from.erase_tag(), derived_from.tag,\n             )))?;\n \n         // Compute where to put the new item.\n@@ -443,12 +446,14 @@ impl<'tcx> Stacks {\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        f: impl Fn(&mut Stack, &GlobalState) -> InterpResult<'tcx>,\n+        f: impl Fn(Pointer<Tag>, &mut Stack, &GlobalState) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let global = self.global.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n-            f(stack, &*global)?;\n+        for (offset, stack) in stacks.iter_mut(ptr.offset, size) {\n+            let mut cur_ptr = ptr;\n+            cur_ptr.offset = offset;\n+            f(cur_ptr, stack, &*global)?;\n         }\n         Ok(())\n     }\n@@ -477,29 +482,26 @@ impl Stacks {\n             // The base pointer is not unique, so the base permission is `SharedReadWrite`.\n             MemoryKind::Machine(MiriMemoryKind::Global | MiriMemoryKind::ExternStatic | MiriMemoryKind::Tls | MiriMemoryKind::Env) =>\n                 (extra.borrow_mut().global_base_ptr(id), Permission::SharedReadWrite),\n-            // Everything else we handle entirely untagged for now.\n-            // FIXME: experiment with more precise tracking.\n-            _ => (Tag::Untagged, Permission::SharedReadWrite),\n+            // Everything else we handle like raw pointers for now.\n+            _ => {\n+                let mut extra = extra.borrow_mut();\n+                let tag = if extra.track_raw { Tag::Tagged(extra.new_ptr()) } else { Tag::Untagged };\n+                (tag, Permission::SharedReadWrite)\n+            }\n         };\n         (Stacks::new(size, perm, tag, extra), tag)\n     }\n \n     #[inline(always)]\n     pub fn memory_read<'tcx>(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |stack, global| {\n-            stack.access(AccessKind::Read, ptr.tag, global)?;\n-            Ok(())\n-        })\n+        self.for_each(ptr, size, |ptr, stack, global| stack.access(AccessKind::Read, ptr, global))\n     }\n \n     #[inline(always)]\n     pub fn memory_written<'tcx>(&mut self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |stack, global| {\n-            stack.access(AccessKind::Write, ptr.tag, global)?;\n-            Ok(())\n-        })\n+        self.for_each(ptr, size, |ptr, stack, global| stack.access(AccessKind::Write, ptr, global))\n     }\n \n     #[inline(always)]\n@@ -509,7 +511,7 @@ impl Stacks {\n         size: Size,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |stack, global| stack.dealloc(ptr.tag, global))\n+        self.for_each(ptr, size, |ptr, stack, global| stack.dealloc(ptr, global))\n     }\n }\n \n@@ -561,14 +563,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Permission::SharedReadWrite\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n-                        stack.grant(cur_ptr.tag, item, global)\n+                    stacked_borrows.for_each(cur_ptr, size, |cur_ptr, stack, global| {\n+                        stack.grant(cur_ptr, item, global)\n                     })\n                 });\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        stacked_borrows.for_each(ptr, size, |stack, global| stack.grant(ptr.tag, item, global))\n+        stacked_borrows.for_each(ptr, size, |ptr, stack, global| stack.grant(ptr, item, global))\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n@@ -597,16 +599,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         // Compute new borrow.\n-        let new_tag = match kind {\n-            // Give up tracking for raw pointers.\n-            // FIXME: Experiment with more precise tracking. Blocked on `&raw`\n-            // because `Rc::into_raw` currently creates intermediate references,\n-            // breaking `Rc::from_raw`.\n-            RefKind::Raw { .. } => Tag::Untagged,\n-            // All other pointesr are properly tracked.\n-            _ => Tag::Tagged(\n-                this.memory.extra.stacked_borrows.as_ref().unwrap().borrow_mut().new_ptr(),\n-            ),\n+        let new_tag = {\n+            let mut mem_extra = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow_mut();\n+            match kind {\n+                // Give up tracking for raw pointers.\n+                RefKind::Raw { .. } if !mem_extra.track_raw => Tag::Untagged,\n+                // All other pointers are properly tracked.\n+                _ => Tag::Tagged(mem_extra.new_ptr()),\n+            }\n         };\n \n         // Reborrow."}, {"sha": "b9ddee328f7a6f72ef7b1104373b3b48be939000", "filename": "tests/compile-fail/stacked_borrows/raw_tracking.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83f7657ed06ea38eaeb6c8e83d83430f49827559/tests%2Fcompile-fail%2Fstacked_borrows%2Fraw_tracking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f7657ed06ea38eaeb6c8e83d83430f49827559/tests%2Fcompile-fail%2Fstacked_borrows%2Fraw_tracking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fraw_tracking.rs?ref=83f7657ed06ea38eaeb6c8e83d83430f49827559", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: -Zmiri-track-raw-pointers\n+// ignore-windows (FIXME: tracking raw pointers does not work on Windows)\n+//! This demonstrates a provenance problem that requires tracking of raw pointers to be detected.\n+\n+fn main() {\n+    let mut l = 13;\n+    let raw1 = &mut l as *mut _;\n+    let raw2 = &mut l as *mut _; // invalidates raw1\n+    // Without raw pointer tracking, Stacked Borrows cannot distinguish raw1 and raw2, and thus\n+    // fails to realize that raw1 should not be used any more.\n+    unsafe { *raw1 = 13; } //~ ERROR no item granting write access to tag\n+    unsafe { *raw2 = 13; }\n+}"}, {"sha": "ad6c5363ac1f4ead35b9b29a80c99e34daa9cf77", "filename": "tests/run-pass/vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83f7657ed06ea38eaeb6c8e83d83430f49827559/tests%2Frun-pass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f7657ed06ea38eaeb6c8e83d83430f49827559/tests%2Frun-pass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvec.rs?ref=83f7657ed06ea38eaeb6c8e83d83430f49827559", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmiri-track-raw-pointers\n+// ignore-windows (FIXME: tracking raw pointers does not work on Windows)\n // Gather all references from a mutable iterator and make sure Miri notices if\n // using them is dangerous.\n fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>) {"}, {"sha": "55b47f622fde368a1d0ccc4d7d23c56d683314c1", "filename": "tests/run-pass/vecdeque.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83f7657ed06ea38eaeb6c8e83d83430f49827559/tests%2Frun-pass%2Fvecdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f7657ed06ea38eaeb6c8e83d83430f49827559/tests%2Frun-pass%2Fvecdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvecdeque.rs?ref=83f7657ed06ea38eaeb6c8e83d83430f49827559", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmiri-track-raw-pointers\n+// ignore-windows (FIXME: tracking raw pointers does not work on Windows)\n use std::collections::VecDeque;\n \n fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>) {"}]}