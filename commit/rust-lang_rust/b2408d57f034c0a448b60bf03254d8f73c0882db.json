{"sha": "b2408d57f034c0a448b60bf03254d8f73c0882db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNDA4ZDU3ZjAzNGMwYTQ0OGI2MGJmMDMyNTRkOGY3M2MwODgyZGI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-25T05:13:16Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:43Z"}, "message": "Convert portions of rustc to istrs. Recover a lot of performance.\n\nIssue #855", "tree": {"sha": "91a357adc8eb380341861196f0782be05a1c3824", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91a357adc8eb380341861196f0782be05a1c3824"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2408d57f034c0a448b60bf03254d8f73c0882db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2408d57f034c0a448b60bf03254d8f73c0882db", "html_url": "https://github.com/rust-lang/rust/commit/b2408d57f034c0a448b60bf03254d8f73c0882db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2408d57f034c0a448b60bf03254d8f73c0882db/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "html_url": "https://github.com/rust-lang/rust/commit/fcc031c5b4dc8f64c497b8dd1e066068e862bd72"}], "stats": {"total": 126, "additions": 66, "deletions": 60}, "files": [{"sha": "2a4da724fba337462274877e41388b228a1b0ab9", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=b2408d57f034c0a448b60bf03254d8f73c0882db", "patch": "@@ -412,7 +412,7 @@ fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t, link_meta: &link_meta) ->\n     // FIXME: This wants to be link_meta.meta_hash\n     sha.input_str(istr::from_estr(link_meta.name));\n     sha.input_str(~\"-\");\n-    sha.input_str(istr::from_estr(encoder::encoded_ty(tcx, t)));\n+    sha.input_str(encoder::encoded_ty(tcx, t));\n     let hash = truncated_sha1_result(sha);\n     // Prefix with _ so that it never blends into adjacent digits\n \n@@ -458,7 +458,7 @@ fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: ty::t, name: &str)\n    -> str {\n     let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n-    ret mangle([name, s, hash]);\n+    ret mangle([name, istr::to_estr(s), hash]);\n }\n \n fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &[str],"}, {"sha": "02f434c5c501c4dcab4f109d829e1959f8532440", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=b2408d57f034c0a448b60bf03254d8f73c0882db", "patch": "@@ -1,6 +1,6 @@\n // EBML tag definitions and utils shared by the encoder and decoder\n \n-import std::str;\n+import std::istr;\n \n const tag_paths: uint = 0x01u;\n \n@@ -67,9 +67,9 @@ const tag_items_data_item_inlineness: uint = 0x27u;\n // djb's cdb hashes.\n fn hash_node_id(node_id: &int) -> uint { ret 177573u ^ (node_id as uint); }\n \n-fn hash_path(s: &str) -> uint {\n+fn hash_path(s: &istr) -> uint {\n     let h = 5381u;\n-    for ch: u8 in str::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n+    for ch: u8 in istr::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n     ret h;\n }\n "}, {"sha": "97010e0d521d7a55b023642558a942eeda3e4bd8", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=b2408d57f034c0a448b60bf03254d8f73c0882db", "patch": "@@ -158,7 +158,8 @@ fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n     let result: [ast::def_id] = [];\n-    for doc: ebml::doc in lookup_hash(paths, eqer, hash_path(s)) {\n+    for doc: ebml::doc in lookup_hash(paths, eqer,\n+                                      hash_path(istr::from_estr(s))) {\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n         result += [parse_def_id(ebml::doc_data(did_doc))];\n     }"}, {"sha": "1aa89d9a91406e147288d5b73158c33545ede82c", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=b2408d57f034c0a448b60bf03254d8f73c0882db", "patch": "@@ -27,9 +27,9 @@ type abbrev_map = map::hashmap<ty::t, tyencode::ty_abbrev>;\n type encode_ctxt = {ccx: @crate_ctxt, type_abbrevs: abbrev_map};\n \n // Path table encoding\n-fn encode_name(ebml_w: &ebml::writer, name: &str) {\n+fn encode_name(ebml_w: &ebml::writer, name: &istr) {\n     ebml::start_tag(ebml_w, tag_paths_data_name);\n-    ebml_w.writer.write(str::bytes(name));\n+    ebml_w.writer.write(istr::bytes(name));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -42,117 +42,121 @@ fn encode_def_id(ebml_w: &ebml::writer, id: &def_id) {\n type entry<T> = {val: T, pos: uint};\n \n fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n-                            path: &[str], index: &mutable [entry<str>]) {\n+                            path: &[istr], index: &mutable [entry<istr>]) {\n     for variant: variant in variants {\n-        add_to_index(ebml_w, path, index, variant.node.name);\n+        add_to_index(ebml_w, path, index, istr::from_estr(variant.node.name));\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n-        encode_name(ebml_w, variant.node.name);\n+        encode_name(ebml_w, istr::from_estr(variant.node.name));\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         ebml::end_tag(ebml_w);\n     }\n }\n \n-fn add_to_index(ebml_w: &ebml::writer, path: &[str],\n-                index: &mutable [entry<str>], name: &str) {\n+fn add_to_index(ebml_w: &ebml::writer, path: &[istr],\n+                index: &mutable [entry<istr>], name: &istr) {\n     let full_path = path + [name];\n     index +=\n-        [{val: str::connect(full_path, \"::\"), pos: ebml_w.writer.tell()}];\n+        [{val: istr::connect(full_path, ~\"::\"), pos: ebml_w.writer.tell()}];\n }\n \n fn encode_native_module_item_paths(ebml_w: &ebml::writer, nmod: &native_mod,\n-                                   path: &[str],\n-                                   index: &mutable [entry<str>]) {\n+                                   path: &[istr],\n+                                   index: &mutable [entry<istr>]) {\n     for nitem: @native_item in nmod.items {\n-        add_to_index(ebml_w, path, index, nitem.ident);\n+        add_to_index(ebml_w, path, index, istr::from_estr(nitem.ident));\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n-        encode_name(ebml_w, nitem.ident);\n+        encode_name(ebml_w, istr::from_estr(nitem.ident));\n         encode_def_id(ebml_w, local_def(nitem.id));\n         ebml::end_tag(ebml_w);\n     }\n }\n \n fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n-                            path: &[str], index: &mutable [entry<str>]) {\n+                            path: &[istr], index: &mutable [entry<istr>]) {\n     for it: @item in module.items {\n         if !ast_util::is_exported(it.ident, module) { cont; }\n         alt it.node {\n           item_const(_, _) {\n-            add_to_index(ebml_w, path, index, it.ident);\n+            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n+            encode_name(ebml_w, istr::from_estr(it.ident));\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n           item_fn(_, tps) {\n-            add_to_index(ebml_w, path, index, it.ident);\n+            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n+            encode_name(ebml_w, istr::from_estr(it.ident));\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n           item_mod(_mod) {\n-            add_to_index(ebml_w, path, index, it.ident);\n+            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n             ebml::start_tag(ebml_w, tag_paths_data_mod);\n-            encode_name(ebml_w, it.ident);\n+            encode_name(ebml_w, istr::from_estr(it.ident));\n             encode_def_id(ebml_w, local_def(it.id));\n-            encode_module_item_paths(ebml_w, _mod, path + [it.ident], index);\n+            encode_module_item_paths(ebml_w, _mod,\n+                                     path + [istr::from_estr(it.ident)],\n+                                     index);\n             ebml::end_tag(ebml_w);\n           }\n           item_native_mod(nmod) {\n-            add_to_index(ebml_w, path, index, it.ident);\n+            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n             ebml::start_tag(ebml_w, tag_paths_data_mod);\n-            encode_name(ebml_w, it.ident);\n+            encode_name(ebml_w, istr::from_estr(it.ident));\n             encode_def_id(ebml_w, local_def(it.id));\n-            encode_native_module_item_paths(ebml_w, nmod, path + [it.ident],\n-                                            index);\n+            encode_native_module_item_paths(\n+                ebml_w, nmod,\n+                path + [istr::from_estr(it.ident)],\n+                index);\n             ebml::end_tag(ebml_w);\n           }\n           item_ty(_, tps) {\n-            add_to_index(ebml_w, path, index, it.ident);\n+            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n+            encode_name(ebml_w, istr::from_estr(it.ident));\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n           item_res(_, _, tps, ctor_id) {\n-            add_to_index(ebml_w, path, index, it.ident);\n+            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n+            encode_name(ebml_w, istr::from_estr(it.ident));\n             encode_def_id(ebml_w, local_def(ctor_id));\n             ebml::end_tag(ebml_w);\n-            add_to_index(ebml_w, path, index, it.ident);\n+            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n+            encode_name(ebml_w, istr::from_estr(it.ident));\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n           item_tag(variants, tps) {\n-            add_to_index(ebml_w, path, index, it.ident);\n+            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n+            encode_name(ebml_w, istr::from_estr(it.ident));\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n             encode_tag_variant_paths(ebml_w, variants, path, index);\n           }\n           item_obj(_, tps, ctor_id) {\n-            add_to_index(ebml_w, path, index, it.ident);\n+            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n+            encode_name(ebml_w, istr::from_estr(it.ident));\n             encode_def_id(ebml_w, local_def(ctor_id));\n             ebml::end_tag(ebml_w);\n-            add_to_index(ebml_w, path, index, it.ident);\n+            add_to_index(ebml_w, path, index, istr::from_estr(it.ident));\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n+            encode_name(ebml_w, istr::from_estr(it.ident));\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n         }\n     }\n }\n \n-fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) -> [entry<str>] {\n-    let index: [entry<str>] = [];\n-    let path: [str] = [];\n+fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) -> [entry<istr>] {\n+    let index: [entry<istr>] = [];\n+    let path: [istr] = [];\n     ebml::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n     ebml::end_tag(ebml_w);\n@@ -436,8 +440,8 @@ fn encode_index<T>(ebml_w: &ebml::writer, buckets: &[@[entry<T>]],\n     ebml::end_tag(ebml_w);\n }\n \n-fn write_str(writer: &io::writer, s: &str) {\n-    writer.write_str(istr::from_estr(s));\n+fn write_str(writer: &io::writer, s: &istr) {\n+    writer.write_str(s);\n }\n \n fn write_int(writer: &io::writer, n: &int) {\n@@ -623,11 +627,11 @@ fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n }\n \n // Get the encoded string for a type\n-fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> str {\n+fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> istr {\n     let cx = @{ds: def_to_str, tcx: tcx, abbrevs: tyencode::ac_no_abbrevs};\n     let sw = io::string_writer();\n     tyencode::enc_ty(sw.get_writer(), cx, t);\n-    ret istr::to_estr(sw.get_str());\n+    ret sw.get_str();\n }\n \n "}, {"sha": "bdb5db6758d095bdc88bb096ad3d03e0edba734d", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=b2408d57f034c0a448b60bf03254d8f73c0882db", "patch": "@@ -26,7 +26,7 @@ type ctxt =\n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n-type ty_abbrev = {pos: uint, len: uint, s: str};\n+type ty_abbrev = {pos: uint, len: uint, s: @istr};\n \n tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap<ty::t, ty_abbrev>); }\n \n@@ -40,21 +40,21 @@ fn cx_uses_abbrevs(cx: &@ctxt) -> bool {\n fn enc_ty(w: &io::writer, cx: &@ctxt, t: ty::t) {\n     alt cx.abbrevs {\n       ac_no_abbrevs. {\n-        let result_str;\n+        let result_str: @istr;\n         alt cx.tcx.short_names_cache.find(t) {\n           some(s) { result_str = s; }\n           none. {\n             let sw = io::string_writer();\n             enc_sty(sw.get_writer(), cx, ty::struct(cx.tcx, t));\n-            result_str = istr::to_estr(sw.get_str());\n+            result_str = @sw.get_str();\n             cx.tcx.short_names_cache.insert(t, result_str);\n           }\n         }\n-        w.write_str(istr::from_estr(result_str));\n+        w.write_str(*result_str);\n       }\n       ac_use_abbrevs(abbrevs) {\n         alt abbrevs.find(t) {\n-          some(a) { w.write_str(istr::from_estr(a.s)); ret; }\n+          some(a) { w.write_str(*a.s); ret; }\n           none. {\n             let pos = w.get_buf_writer().tell();\n             enc_sty(w, cx, ty::struct(cx.tcx, t));\n@@ -73,7 +73,7 @@ fn enc_ty(w: &io::writer, cx: &@ctxt, t: ty::t) {\n                 let s =\n                     ~\"#\" + uint::to_str(pos, 16u) + ~\":\" +\n                     uint::to_str(len, 16u) + ~\"#\";\n-                let a = {pos: pos, len: len, s: istr::to_estr(s)};\n+                let a = {pos: pos, len: len, s: @s};\n                 abbrevs.insert(t, a);\n             }\n             ret;"}, {"sha": "649d3a7eb53df37da8705ec9c6d95b4c8599abf5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b2408d57f034c0a448b60bf03254d8f73c0882db", "patch": "@@ -1232,7 +1232,8 @@ fn make_generic_glue(cx: &@local_ctxt, sp: &span, t: ty::t, llfn: ValueRef,\n     let start = time::get_time();\n     let llval = make_generic_glue_inner(cx, sp, t, llfn, helper, ty_params);\n     let end = time::get_time();\n-    log_fn_time(cx.ccx, \"glue \" + name + \" \" + ty_to_short_str(cx.ccx.tcx, t),\n+    log_fn_time(cx.ccx, \"glue \" + name + \" \" +\n+                istr::to_estr(ty_to_short_str(cx.ccx.tcx, t)),\n                 start, end);\n     ret llval;\n }"}, {"sha": "b6ce008b0c71c2c8521090f4fc8e9a70f237f9c5", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b2408d57f034c0a448b60bf03254d8f73c0882db", "patch": "@@ -223,7 +223,7 @@ type ctxt =\n       freevars: freevars::freevar_map,\n       tcache: type_cache,\n       rcache: creader_cache,\n-      short_names_cache: hashmap<t, str>,\n+      short_names_cache: hashmap<t, @istr>,\n       has_pointer_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, ast::kind>,\n       owns_heap_mem_cache: hashmap<t, bool>,"}, {"sha": "259482bc9b3efa405ebeb1301dde208b8404b842", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2408d57f034c0a448b60bf03254d8f73c0882db/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=b2408d57f034c0a448b60bf03254d8f73c0882db", "patch": "@@ -147,13 +147,13 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n           ty_param(id, _) {\n             \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])\n           }\n-          _ { ty_to_short_str(cx, typ) }\n+          _ { istr::to_estr(ty_to_short_str(cx, typ)) }\n         }\n }\n \n-fn ty_to_short_str(cx: &ctxt, typ: t) -> str {\n+fn ty_to_short_str(cx: &ctxt, typ: t) -> istr {\n     let s = encoder::encoded_ty(cx, typ);\n-    if str::byte_len(s) >= 32u { s = str::substr(s, 0u, 32u); }\n+    if istr::byte_len(s) >= 32u { s = istr::substr(s, 0u, 32u); }\n     ret s;\n }\n "}]}