{"sha": "dbd8220891d229f9092e623b8a1dcadbddeb12fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiZDgyMjA4OTFkMjI5ZjkwOTJlNjIzYjhhMWRjYWRiZGRlYjEyZmM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-04T22:44:03Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-13T23:50:59Z"}, "message": "Avoid `base_parser`, it's not needed.", "tree": {"sha": "f8273225dc3542a4e1d9ce26c48da5ae3be60306", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8273225dc3542a4e1d9ce26c48da5ae3be60306"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbd8220891d229f9092e623b8a1dcadbddeb12fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbd8220891d229f9092e623b8a1dcadbddeb12fc", "html_url": "https://github.com/rust-lang/rust/commit/dbd8220891d229f9092e623b8a1dcadbddeb12fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbd8220891d229f9092e623b8a1dcadbddeb12fc/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d538b80ad77949e46989cd355cdec193b574f052", "url": "https://api.github.com/repos/rust-lang/rust/commits/d538b80ad77949e46989cd355cdec193b574f052", "html_url": "https://github.com/rust-lang/rust/commit/d538b80ad77949e46989cd355cdec193b574f052"}], "stats": {"total": 25, "additions": 11, "deletions": 14}, "files": [{"sha": "da4309c3b3d352cf6f0d54dc2e109d237e8c1369", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dbd8220891d229f9092e623b8a1dcadbddeb12fc/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd8220891d229f9092e623b8a1dcadbddeb12fc/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=dbd8220891d229f9092e623b8a1dcadbddeb12fc", "patch": "@@ -191,9 +191,9 @@ fn generic_extension<'cx>(\n     let mut best_failure: Option<(Token, &str)> = None;\n \n     // We create a base parser that can be used for the \"black box\" parts.\n-    // Every iteration needs a fresh copy of that base parser. However, the\n-    // parser is not mutated on many of the iterations, particularly when\n-    // dealing with macros like this:\n+    // Every iteration needs a fresh copy of that parser. However, the parser\n+    // is not mutated on many of the iterations, particularly when dealing with\n+    // macros like this:\n     //\n     // macro_rules! foo {\n     //     (\"a\") => (A);\n@@ -209,11 +209,9 @@ fn generic_extension<'cx>(\n     // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n-    let base_parser = base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+    let parser = parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n \n     for (i, lhs) in lhses.iter().enumerate() {\n-        let mut parser = Cow::Borrowed(&base_parser);\n-\n         // try each arm's matchers\n         let lhs_tt = match *lhs {\n             mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n@@ -226,7 +224,7 @@ fn generic_extension<'cx>(\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snaphot = mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n \n-        match parse_tt(&mut parser, lhs_tt) {\n+        match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n@@ -293,7 +291,7 @@ fn generic_extension<'cx>(\n         // Restore to the state before snapshotting and maybe try again.\n         mem::swap(&mut gated_spans_snaphot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n     }\n-    drop(base_parser);\n+    drop(parser);\n \n     let (token, label) = best_failure.expect(\"ran no matchers\");\n     let span = token.span.substitute_dummy(sp);\n@@ -311,9 +309,8 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n-            let base_parser =\n-                base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n-            match parse_tt(&mut Cow::Borrowed(&base_parser), lhs_tt) {\n+            let parser = parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+            match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n                 Success(_) => {\n                     if comma_span.is_dummy() {\n                         err.note(\"you might be missing a comma\");\n@@ -395,8 +392,8 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let base_parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n-    let argument_map = match parse_tt(&mut Cow::Borrowed(&base_parser), &argument_gram) {\n+    let parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n+    let argument_map = match parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n@@ -1212,7 +1209,7 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-fn base_parser_from_cx<'cx>(\n+fn parser_from_cx<'cx>(\n     current_expansion: &'cx ExpansionData,\n     sess: &'cx ParseSess,\n     tts: TokenStream,"}]}