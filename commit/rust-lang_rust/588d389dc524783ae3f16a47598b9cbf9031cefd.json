{"sha": "588d389dc524783ae3f16a47598b9cbf9031cefd", "node_id": "C_kwDOAAsO6NoAKDU4OGQzODlkYzUyNDc4M2FlM2YxNmE0NzU5OGI5Y2JmOTAzMWNlZmQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-03-18T04:21:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-18T04:21:55Z"}, "message": "Rollup merge of #95039 - spastorino:overlap-super-predicates, r=nikomatsakis\n\nMake negative coherence work when there's impl negative on super predicates\n\nr? `@nikomatsakis`", "tree": {"sha": "ebeb62acda3776305a157764f8257c317cb7f98b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebeb62acda3776305a157764f8257c317cb7f98b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/588d389dc524783ae3f16a47598b9cbf9031cefd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiNAjkCRBK7hj4Ov3rIwAA/QEIALAwMoCTCl2YrSDRSB6ECc7b\nAD6oWVBOGrq2GcFKqWZ3o2q9eXlCGiYQJl8L/Of9NpiSQV4/C2JZDYCPk3fa1Wrj\nIl4AiZw3XF7yeZQkocdDE3MjwJePRn81FpxaMsH01U354WOybTL0Q40SbFmqLDL/\nRZrAEMj/pskCSl0gjx6hEDaAtS1g8AvDYXEabhKY2hOtJeUpt7NowDDaTga3pxz5\ny0R16Q0mhxtVYQ07VA4GIEg7/3QDQg02M3x7fGhtIb8pe9eD2fs+ZBr/XMWCSmfu\n58fI1t1sAVvBAN3Jw0RXjBVn3rWMhD6+4q0Fp7L8bk5sWwwk4+rceMGm7NhetXg=\n=jlyJ\n-----END PGP SIGNATURE-----\n", "payload": "tree ebeb62acda3776305a157764f8257c317cb7f98b\nparent 0e1b897d91e8b30d411f1a95ed58e6a58527fb86\nparent 89a00cc8ae92f159325a7b5cb06a6d7802a4f3c5\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1647577315 +0100\ncommitter GitHub <noreply@github.com> 1647577315 +0100\n\nRollup merge of #95039 - spastorino:overlap-super-predicates, r=nikomatsakis\n\nMake negative coherence work when there's impl negative on super predicates\n\nr? `@nikomatsakis`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/588d389dc524783ae3f16a47598b9cbf9031cefd", "html_url": "https://github.com/rust-lang/rust/commit/588d389dc524783ae3f16a47598b9cbf9031cefd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/588d389dc524783ae3f16a47598b9cbf9031cefd/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e1b897d91e8b30d411f1a95ed58e6a58527fb86", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e1b897d91e8b30d411f1a95ed58e6a58527fb86", "html_url": "https://github.com/rust-lang/rust/commit/0e1b897d91e8b30d411f1a95ed58e6a58527fb86"}, {"sha": "89a00cc8ae92f159325a7b5cb06a6d7802a4f3c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/89a00cc8ae92f159325a7b5cb06a6d7802a4f3c5", "html_url": "https://github.com/rust-lang/rust/commit/89a00cc8ae92f159325a7b5cb06a6d7802a4f3c5"}], "stats": {"total": 142, "additions": 97, "deletions": 45}, "files": [{"sha": "83ab761aa55a4a4b9f733ac569631313ae440afe", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/588d389dc524783ae3f16a47598b9cbf9031cefd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588d389dc524783ae3f16a47598b9cbf9031cefd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=588d389dc524783ae3f16a47598b9cbf9031cefd", "patch": "@@ -748,6 +748,13 @@ pub struct TraitPredicate<'tcx> {\n \n     pub constness: BoundConstness,\n \n+    /// If polarity is Positive: we are proving that the trait is implemented.\n+    ///\n+    /// If polarity is Negative: we are proving that a negative impl of this trait\n+    /// exists. (Note that coherence also checks whether negative impls of supertraits\n+    /// exist via a series of predicates.)\n+    ///\n+    /// If polarity is Reserved: that's a bug.\n     pub polarity: ImplPolarity,\n }\n "}, {"sha": "94a4001bbb91ac143d5c1da88b00b6766e81e2c2", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/588d389dc524783ae3f16a47598b9cbf9031cefd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588d389dc524783ae3f16a47598b9cbf9031cefd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=588d389dc524783ae3f16a47598b9cbf9031cefd", "patch": "@@ -17,8 +17,8 @@ use crate::traits::{\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::CRATE_HIR_ID;\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngine;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::{util, TraitEngine};\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{self, TreatParams};\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -353,49 +353,75 @@ fn negative_impl<'cx, 'tcx>(\n     })\n }\n \n+/// Try to prove that a negative impl exist for the given obligation and their super predicates.\n+#[instrument(level = \"debug\", skip(selcx))]\n fn negative_impl_exists<'cx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     region_context: DefId,\n     o: &PredicateObligation<'tcx>,\n ) -> bool {\n     let infcx = &selcx.infcx().fork();\n+\n+    if resolve_negative_obligation(infcx, param_env, region_context, o) {\n+        return true;\n+    }\n+\n+    // Try to prove a negative obligation exist for super predicates\n+    for o in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n+        if resolve_negative_obligation(infcx, param_env, region_context, &o) {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n+#[instrument(level = \"debug\", skip(infcx))]\n+fn resolve_negative_obligation<'cx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    region_context: DefId,\n+    o: &PredicateObligation<'tcx>,\n+) -> bool {\n     let tcx = infcx.tcx;\n-    o.flip_polarity(tcx)\n-        .map(|o| {\n-            let mut fulfillment_cx = FulfillmentContext::new();\n-            fulfillment_cx.register_predicate_obligation(infcx, o);\n-\n-            let errors = fulfillment_cx.select_all_or_error(infcx);\n-            if !errors.is_empty() {\n-                return false;\n-            }\n \n-            let mut outlives_env = OutlivesEnvironment::new(param_env);\n-            // FIXME -- add \"assumed to be well formed\" types into the `outlives_env`\n+    let Some(o) = o.flip_polarity(tcx) else {\n+        return false;\n+    };\n \n-            // \"Save\" the accumulated implied bounds into the outlives environment\n-            // (due to the FIXME above, there aren't any, but this step is still needed).\n-            // The \"body id\" is given as `CRATE_HIR_ID`, which is the same body-id used\n-            // by the \"dummy\" causes elsewhere (body-id is only relevant when checking\n-            // function bodies with closures).\n-            outlives_env.save_implied_bounds(CRATE_HIR_ID);\n+    let mut fulfillment_cx = FulfillmentContext::new();\n+    fulfillment_cx.register_predicate_obligation(infcx, o);\n \n-            infcx.process_registered_region_obligations(\n-                outlives_env.region_bound_pairs_map(),\n-                Some(tcx.lifetimes.re_root_empty),\n-                param_env,\n-            );\n+    let errors = fulfillment_cx.select_all_or_error(infcx);\n \n-            let errors =\n-                infcx.resolve_regions(region_context, &outlives_env, RegionckMode::default());\n-            if !errors.is_empty() {\n-                return false;\n-            }\n+    if !errors.is_empty() {\n+        return false;\n+    }\n \n-            true\n-        })\n-        .unwrap_or(false)\n+    let mut outlives_env = OutlivesEnvironment::new(param_env);\n+    // FIXME -- add \"assumed to be well formed\" types into the `outlives_env`\n+\n+    // \"Save\" the accumulated implied bounds into the outlives environment\n+    // (due to the FIXME above, there aren't any, but this step is still needed).\n+    // The \"body id\" is given as `CRATE_HIR_ID`, which is the same body-id used\n+    // by the \"dummy\" causes elsewhere (body-id is only relevant when checking\n+    // function bodies with closures).\n+    outlives_env.save_implied_bounds(CRATE_HIR_ID);\n+\n+    infcx.process_registered_region_obligations(\n+        outlives_env.region_bound_pairs_map(),\n+        Some(tcx.lifetimes.re_root_empty),\n+        param_env,\n+    );\n+\n+    let errors = infcx.resolve_regions(region_context, &outlives_env, RegionckMode::default());\n+\n+    if !errors.is_empty() {\n+        return false;\n+    }\n+\n+    true\n }\n \n pub fn trait_ref_is_knowable<'tcx>("}, {"sha": "1ea0ddc7430e1c3bf5db8b2d6fc212bab2b8a92c", "filename": "src/test/ui/coherence/coherence-overlap-double-negative.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/588d389dc524783ae3f16a47598b9cbf9031cefd/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-double-negative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588d389dc524783ae3f16a47598b9cbf9031cefd/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-double-negative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-double-negative.rs?ref=588d389dc524783ae3f16a47598b9cbf9031cefd", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![feature(negative_impls)]\n+#![feature(with_negative_coherence)]\n+\n+trait A {}\n+trait B: A {}\n+\n+impl !A for u32 {}\n+impl !B for u32 {}\n+\n+fn main() {}"}, {"sha": "48dffc921a31bb0fa2015996673ca62b1369e1d9", "filename": "src/test/ui/coherence/coherence-overlap-negate-alias-strict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/588d389dc524783ae3f16a47598b9cbf9031cefd/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588d389dc524783ae3f16a47598b9cbf9031cefd/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.rs?ref=588d389dc524783ae3f16a47598b9cbf9031cefd", "patch": "@@ -1,3 +1,5 @@\n+// check-pass\n+\n #![feature(negative_impls)]\n #![feature(rustc_attrs)]\n #![feature(trait_alias)]\n@@ -13,7 +15,5 @@ impl !A for u32 {}\n trait C {}\n impl<T: AB> C for T {}\n impl C for u32 {}\n-//~^ ERROR: conflicting implementations of trait `C` for type `u32` [E0119]\n-// FIXME this should work, we should implement an `assemble_neg_candidates` fn\n \n fn main() {}"}, {"sha": "30d837a5c5019d28dd3af83857354089f5be01d2", "filename": "src/test/ui/coherence/coherence-overlap-negate-alias-strict.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e1b897d91e8b30d411f1a95ed58e6a58527fb86/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e1b897d91e8b30d411f1a95ed58e6a58527fb86/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.stderr?ref=0e1b897d91e8b30d411f1a95ed58e6a58527fb86", "patch": "@@ -1,11 +0,0 @@\n-error[E0119]: conflicting implementations of trait `C` for type `u32`\n-  --> $DIR/coherence-overlap-negate-alias-strict.rs:15:1\n-   |\n-LL | impl<T: AB> C for T {}\n-   | ------------------- first implementation here\n-LL | impl C for u32 {}\n-   | ^^^^^^^^^^^^^^ conflicting implementation for `u32`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0119`."}, {"sha": "d296a094a37046920af49bcff1d06b794d44da33", "filename": "src/test/ui/coherence/coherence-overlap-super-negative.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/588d389dc524783ae3f16a47598b9cbf9031cefd/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-super-negative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588d389dc524783ae3f16a47598b9cbf9031cefd/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-super-negative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-super-negative.rs?ref=588d389dc524783ae3f16a47598b9cbf9031cefd", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+#![feature(negative_impls)]\n+#![feature(rustc_attrs)]\n+#![feature(with_negative_coherence)]\n+\n+trait Trait1: Trait2 {}\n+trait Trait2 {}\n+\n+struct MyType {}\n+impl !Trait2 for MyType {}\n+\n+#[rustc_strict_coherence]\n+trait Foo {}\n+impl<T: Trait1> Foo for T {}\n+impl Foo for MyType {}\n+\n+fn main() {}"}]}