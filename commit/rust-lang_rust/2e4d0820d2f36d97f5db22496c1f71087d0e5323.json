{"sha": "2e4d0820d2f36d97f5db22496c1f71087d0e5323", "node_id": "C_kwDOAAsO6NoAKDJlNGQwODIwZDJmMzZkOTdmNWRiMjI0OTZjMWY3MTA4N2QwZTUzMjM", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-09-02T22:26:15Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:14Z"}, "message": "Add more documentation", "tree": {"sha": "b999e47ade5fda9fc87aeb3b8c5e714bdad9a71f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b999e47ade5fda9fc87aeb3b8c5e714bdad9a71f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e4d0820d2f36d97f5db22496c1f71087d0e5323", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e4d0820d2f36d97f5db22496c1f71087d0e5323", "html_url": "https://github.com/rust-lang/rust/commit/2e4d0820d2f36d97f5db22496c1f71087d0e5323", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e4d0820d2f36d97f5db22496c1f71087d0e5323/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "895181b962cf39b7674023dc329c5c6d387a435f", "url": "https://api.github.com/repos/rust-lang/rust/commits/895181b962cf39b7674023dc329c5c6d387a435f", "html_url": "https://github.com/rust-lang/rust/commit/895181b962cf39b7674023dc329c5c6d387a435f"}], "stats": {"total": 31, "additions": 29, "deletions": 2}, "files": [{"sha": "355b7728e0cb6f879bbd014e24455590eb3247de", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2e4d0820d2f36d97f5db22496c1f71087d0e5323/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4d0820d2f36d97f5db22496c1f71087d0e5323/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=2e4d0820d2f36d97f5db22496c1f71087d0e5323", "patch": "@@ -193,6 +193,8 @@ pub trait ValueAnalysis<'tcx> {\n         Self::Value::top()\n     }\n \n+    /// The effect of a successful function call return should not be\n+    /// applied here, see [`Analysis::apply_terminator_effect`].\n     fn handle_terminator(&self, terminator: &Terminator<'tcx>, state: &mut State<Self::Value>) {\n         self.super_terminator(terminator, state)\n     }\n@@ -267,6 +269,8 @@ impl<'tcx, T: ValueAnalysis<'tcx>> AnalysisDomain<'tcx> for ValueAnalysisWrapper\n     }\n \n     fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n+        // The initial state maps all tracked places of argument projections to \u22a4 and the rest to \u22a5.\n+        // This utilizes that reading from an uninitialized place is UB.\n         assert!(matches!(state.0, StateData::Unreachable));\n         let values = IndexVec::from_elem_n(T::Value::bottom(), self.0.map().value_count);\n         *state = State(StateData::Reachable(values));\n@@ -325,20 +329,38 @@ where\n }\n \n rustc_index::newtype_index!(\n+    /// This index uniquely identifies a place.\n+    ///\n+    /// Not every place has a `PlaceIndex`, and not every `PlaceIndex` correspondends to a tracked\n+    /// place. However, every tracked place and all places along its projection have a `PlaceIndex`.\n     pub struct PlaceIndex {}\n );\n \n rustc_index::newtype_index!(\n+    /// This index uniquely identifies a tracked place and therefore a slot in [`State`].\n+    ///\n+    /// It is an implementation detail of this module.\n     struct ValueIndex {}\n );\n \n+/// See [`State`].\n #[derive(PartialEq, Eq, Clone, Debug)]\n enum StateData<V> {\n     Reachable(IndexVec<ValueIndex, V>),\n     Unreachable,\n }\n \n-/// All operations on unreachable states are ignored.\n+/// The dataflow state for an instance of [`ValueAnalysis`].\n+///\n+/// Every instance specifies a lattice that represents the possible values of a single tracked\n+/// place. If we call this lattice `V` and set set of tracked places `P`, then a [`State`] is an\n+/// element of `{unreachable} \u222a (P -> V)`. This again forms a lattice, where the bottom element is\n+/// `unreachable` and the top element is the mapping `p \u21a6 \u22a4`. Note that the mapping `p \u21a6 \u22a5` is not\n+/// the bottom element (because joining an unreachable and any other reachable state yields a\n+/// reachable state). All operations on unreachable states are ignored.\n+///\n+/// Flooding means assigning a value (by default `\u22a4`) to all tracked projections of a given place.\n+/// Assigning a place (or reference thereof) to another place assumes that\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct State<V>(StateData<V>);\n \n@@ -383,8 +405,13 @@ impl<V: Clone + HasTop> State<V> {\n         self.flood_idx_with(place, map, V::top())\n     }\n \n+    /// This method assumes that the given places are not overlapping, and that we can therefore\n+    /// copy all entries one after another.\n     pub fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n+        // If both places are tracked, we copy the value to the target. If the target is tracked,\n+        // but the source is not, we have to invalidate the value in target. If the target is not\n+        // tracked, then we don't have to do anything.\n         if let Some(target_value) = map.places[target].value_index {\n             if let Some(source_value) = map.places[source].value_index {\n                 values[target_value] = values[source_value].clone();\n@@ -393,7 +420,7 @@ impl<V: Clone + HasTop> State<V> {\n             }\n         }\n         for target_child in map.children(target) {\n-            // Try to find corresponding child in source.\n+            // Try to find corresponding child and recurse. Reasoning is similar as above.\n             let projection = map.places[target_child].proj_elem.unwrap();\n             if let Some(source_child) = map.projections.get(&(source, projection)) {\n                 self.assign_place_idx(target_child, *source_child, map);"}]}