{"sha": "055158d05191000384b490399c104394cbc0c838", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NTE1OGQwNTE5MTAwMDM4NGI0OTAzOTljMTA0Mzk0Y2JjMGM4Mzg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-06T18:39:00Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-06T18:39:19Z"}, "message": "Revert \"Merge pull request #2516 from mozilla/incoming\" due to failures\n\nThis reverts commit adb717b5fa3500c50ced39266c76fc909808c189, reversing\nchanges made to aabf84cdd81351cc63ebdc9e2427203621d19950.", "tree": {"sha": "c815388b08db1db3bc81b375e77488da076348b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c815388b08db1db3bc81b375e77488da076348b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/055158d05191000384b490399c104394cbc0c838", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/055158d05191000384b490399c104394cbc0c838", "html_url": "https://github.com/rust-lang/rust/commit/055158d05191000384b490399c104394cbc0c838", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/055158d05191000384b490399c104394cbc0c838/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adb717b5fa3500c50ced39266c76fc909808c189", "url": "https://api.github.com/repos/rust-lang/rust/commits/adb717b5fa3500c50ced39266c76fc909808c189", "html_url": "https://github.com/rust-lang/rust/commit/adb717b5fa3500c50ced39266c76fc909808c189"}], "stats": {"total": 214, "additions": 116, "deletions": 98}, "files": [{"sha": "aea97cf1649f539042a10d9a72c622e15a3ce158", "filename": "src/libcore/cmp.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adb717b5fa3500c50ced39266c76fc909808c189/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb717b5fa3500c50ced39266c76fc909808c189/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=adb717b5fa3500c50ced39266c76fc909808c189", "patch": "@@ -1,10 +0,0 @@\n-#[doc=\"Interfaces used for comparison.\"]\n-\n-iface ord {\n-    fn lt(&&other: self) -> bool;\n-}\n-\n-iface eq {\n-    fn eq(&&other: self) -> bool;\n-}\n-"}, {"sha": "6b4c7ad7d3ca08078bc65ff55abab1a155da3e30", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -44,7 +44,6 @@ export extfmt;\n export tuple;\n export to_str;\n export dvec, dvec_iter;\n-export cmp;\n \n // NDM seems to be necessary for resolve to work\n export option_iter;\n@@ -153,7 +152,6 @@ mod tuple;\n \n // Ubiquitous-utility-type modules\n \n-mod cmp;\n mod either;\n mod iter;\n mod logging;"}, {"sha": "156724cb06170bdc6f95cf59151c93f6c767315f", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -1,5 +1,4 @@\n import T = inst::T;\n-import cmp::{eq, ord};\n \n export min_value, max_value;\n export min, max;\n@@ -11,7 +10,6 @@ export range;\n export compl;\n export abs;\n export parse_buf, from_str, to_str, to_str_bytes, str;\n-export ord, eq;\n \n const min_value: T = -1 as T << (inst::bits - 1 as T);\n const max_value: T = min_value - 1 as T;\n@@ -110,18 +108,6 @@ fn to_str_bytes<U>(n: T, radix: uint, f: fn([u8]/&) -> U) -> U {\n #[doc = \"Convert to a string\"]\n fn str(i: T) -> str { ret to_str(i, 10u); }\n \n-impl ord of ord for T {\n-    fn lt(&&other: T) -> bool {\n-        ret self < other;\n-    }\n-}\n-\n-impl eq of eq for T {\n-    fn eq(&&other: T) -> bool {\n-        ret self == other;\n-    }\n-}\n-\n \n // FIXME: Has alignment issues on windows and 32-bit linux\n #[test]"}, {"sha": "a63d01e6e8e08c45ffdb1b7954ec2cbc38678321", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -1,5 +1,4 @@\n import T = inst::T;\n-import cmp::{eq, ord};\n \n export min_value, max_value;\n export min, max;\n@@ -11,7 +10,6 @@ export range;\n export compl;\n export to_str, to_str_bytes;\n export from_str, from_str_radix, str, parse_buf;\n-export ord, eq;\n \n const min_value: T = 0 as T;\n const max_value: T = 0 as T - 1 as T;\n@@ -51,18 +49,6 @@ pure fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n-impl ord of ord for T {\n-    fn lt(&&other: T) -> bool {\n-        ret self < other;\n-    }\n-}\n-\n-impl eq of eq for T {\n-    fn eq(&&other: T) -> bool {\n-        ret self == other;\n-    }\n-}\n-\n #[doc = \"\n Parse a buffer of bytes\n "}, {"sha": "7e16578fd9c8850a518485c780d8eb68dc59dc07", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -1,6 +1,5 @@\n #[doc = \"Sorting methods\"];\n import vec::len;\n-import int::{eq, ord};\n \n export le;\n export merge_sort;\n@@ -142,6 +141,7 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n+// FIXME: This should take lt and eq types (#2348)\n #[doc = \"\n Fancy quicksort. Sorts a mut vector in place.\n \n@@ -152,17 +152,22 @@ According to these slides this is the algorithm of choice for\n \n This is an unstable sort.\n \"]\n-fn quick_sort3<T: copy ord eq>(arr: [mut T]) {\n+fn quick_sort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n+                       arr: [mut T]) {\n     if len::<T>(arr) == 0u { ret; }\n-    qsort3::<T>({ |x, y| x.lt(y) }, { |x, y| x.eq(y) }, arr, 0,\n+    qsort3::<T>(compare_func_lt, compare_func_eq, arr, 0,\n                 (len::<T>(arr) as int) - 1);\n }\n \n #[cfg(test)]\n mod test_qsort3 {\n     fn check_sort(v1: [mut int], v2: [mut int]) {\n         let len = vec::len::<int>(v1);\n-        quick_sort3::<int>(v1);\n+        fn lt(&&a: int, &&b: int) -> bool { ret a < b; }\n+        fn equal(&&a: int, &&b: int) -> bool { ret a == b; }\n+        let f1 = lt;\n+        let f2 = equal;\n+        quick_sort3::<int>(f1, f2, v1);\n         let mut i = 0u;\n         while i < len {\n             log(debug, v2[i]);"}, {"sha": "6d4f48595d2511ebfe6e6f0702416a13892adfc1", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -194,7 +194,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n          bind middle::check_loop::check_crate(ty_cx, crate));\n     time(time_passes, \"alt checking\",\n          bind middle::check_alt::check_crate(ty_cx, crate));\n-    let last_use_map =\n+    let (last_use_map, spill_map) =\n         time(time_passes, \"liveness checking\",\n              bind middle::liveness::check_crate(ty_cx, method_map, crate));\n     time(time_passes, \"typestate checking\",\n@@ -216,7 +216,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let maps = {mutbl_map: mutbl_map, root_map: root_map,\n                 copy_map: copy_map, last_use_map: last_use_map,\n                 impl_map: impl_map, method_map: method_map,\n-                vtable_map: vtable_map};\n+                vtable_map: vtable_map, spill_map: spill_map};\n \n     let (llmod, link_meta) =\n         time(time_passes, \"translation\","}, {"sha": "db185215bea54e72320d70880e5c6d202c35deea", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -15,8 +15,7 @@ import std::map::hashmap;\n import getopts::{opt_present};\n import rustc::driver::driver::*;\n import syntax::codemap;\n-import syntax::diagnostic;\n-import rustc::driver::session;\n+import rustc::driver::{diagnostic, session};\n import rustc::middle::lint;\n import io::reader_util;\n "}, {"sha": "644d519fc0f283e36bf71e4d0da043f69d8d57d0", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -7,14 +7,14 @@ import syntax::{ast, ast_util};\n import syntax::attr;\n import middle::ty;\n import syntax::ast_map;\n+import common::*;\n import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n         parse_ident};\n import syntax::print::pprust;\n import cmd=cstore::crate_metadata;\n import util::ppaux::ty_to_str;\n import ebml::deserializer;\n import syntax::diagnostic::span_handler;\n-import common::*;\n \n export class_dtor;\n export get_class_fields;"}, {"sha": "2fd59cb2166255dc335a54e0eba0a9de97bd2b62", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -57,6 +57,7 @@ type maps = {\n     impl_map: middle::resolve::impl_map,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n+    spill_map: middle::liveness::spill_map\n };\n \n type decode_ctxt = @{\n@@ -838,6 +839,12 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n+    option::iter(maps.spill_map.find(id)) {|_m|\n+        ebml_w.tag(c::tag_table_spill) {||\n+            ebml_w.id(id);\n+        }\n+    }\n+\n     option::iter(maps.last_use_map.find(id)) {|m|\n         ebml_w.tag(c::tag_table_last_use) {||\n             ebml_w.id(id);\n@@ -946,6 +953,8 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.maps.mutbl_map.insert(id, ());\n         } else if tag == (c::tag_table_copy as uint) {\n             dcx.maps.copy_map.insert(id, ());\n+        } else if tag == (c::tag_table_spill as uint) {\n+            dcx.maps.spill_map.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val];\n             let val_dsr = ebml::ebml_deserializer(val_doc);"}, {"sha": "3f82e647ab6b9c9fcec01d9901cedaca62e2975b", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -57,6 +57,7 @@ import capture::{cap_move, cap_drop, cap_copy, cap_ref};\n \n export check_crate;\n export last_use_map;\n+export spill_map;\n \n // Maps from an expr id to a list of variable ids for which this expr\n // is the last use.  Typically, the expr is a path and the node id is\n@@ -65,6 +66,13 @@ export last_use_map;\n // list of closed over variables that can be moved into the closure.\n type last_use_map = hashmap<node_id, @dvec<node_id>>;\n \n+// A set of variable ids which must be spilled (stored on the stack).\n+// We add in any variables or arguments where:\n+// (1) the variables are moved;\n+// (2) the address of the variable/argument is taken;\n+// or (3) we find a last use (as they may be moved).\n+type spill_map = hashmap<node_id, ()>;\n+\n enum variable = uint;\n enum live_node = uint;\n \n@@ -77,7 +85,7 @@ enum live_node_kind {\n \n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n-               crate: @crate) -> last_use_map {\n+               crate: @crate) -> (last_use_map, spill_map) {\n     let visitor = visit::mk_vt(@{\n         visit_fn: visit_fn,\n         visit_local: visit_local,\n@@ -86,11 +94,12 @@ fn check_crate(tcx: ty::ctxt,\n     });\n \n     let last_use_map = int_hash();\n+    let spill_map = int_hash();\n     let initial_maps = @ir_maps(tcx, method_map,\n-                                last_use_map);\n+                                last_use_map, spill_map);\n     visit::visit_crate(*crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n-    ret last_use_map;\n+    ret (last_use_map, spill_map);\n }\n \n impl of to_str::to_str for live_node {\n@@ -153,6 +162,7 @@ class ir_maps {\n     let tcx: ty::ctxt;\n     let method_map: typeck::method_map;\n     let last_use_map: last_use_map;\n+    let spill_map: spill_map;\n \n     let mut num_live_nodes: uint;\n     let mut num_vars: uint;\n@@ -164,10 +174,11 @@ class ir_maps {\n     let mut lnks: [live_node_kind];\n \n     new(tcx: ty::ctxt, method_map: typeck::method_map,\n-        last_use_map: last_use_map) {\n+        last_use_map: last_use_map, spill_map: spill_map) {\n         self.tcx = tcx;\n         self.method_map = method_map;\n         self.last_use_map = last_use_map;\n+        self.spill_map = spill_map;\n \n         self.num_live_nodes = 0u;\n         self.num_vars = 0u;\n@@ -253,6 +264,17 @@ class ir_maps {\n         self.lnks[*ln]\n     }\n \n+    fn add_spill(var: variable) {\n+        let vk = self.var_kinds[*var];\n+        alt vk {\n+          vk_local(id, _) | vk_arg(id, _, by_val) {\n+            #debug[\"adding spill for %?\", vk];\n+            self.spill_map.insert(id, ());\n+          }\n+          vk_arg(*) | vk_field(_) | vk_self | vk_implicit_ret {}\n+        }\n+    }\n+\n     fn add_last_use(expr_id: node_id, var: variable) {\n         let vk = self.var_kinds[*var];\n         #debug[\"Node %d is a last use of variable %?\", expr_id, vk];\n@@ -286,7 +308,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n \n     // swap in a new set of IR maps for this function body:\n     let fn_maps = @ir_maps(self.tcx, self.method_map,\n-                           self.last_use_map);\n+                           self.last_use_map, self.spill_map);\n \n     #debug[\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint];\n \n@@ -1385,7 +1407,11 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n         vt.visit_expr(f, self, vt);\n         vec::iter2(args, targs) { |arg_expr, arg_ty|\n             alt ty::resolved_mode(self.tcx, arg_ty.mode) {\n-              by_val | by_copy | by_ref | by_mutbl_ref{\n+              by_val | by_copy {\n+                vt.visit_expr(arg_expr, self, vt);\n+              }\n+              by_ref | by_mutbl_ref {\n+                self.spill_expr(arg_expr);\n                 vt.visit_expr(arg_expr, self, vt);\n               }\n               by_move {\n@@ -1395,6 +1421,10 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n         }\n       }\n \n+      expr_addr_of(_, arg_expr) {\n+        self.spill_expr(arg_expr);\n+      }\n+\n       // no correctness conditions related to liveness\n       expr_if_check(*) | expr_if(*) | expr_alt(*) |\n       expr_while(*) | expr_loop(*) |\n@@ -1404,7 +1434,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       expr_assert(*) | expr_check(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_cast(*) | expr_unary(*) | expr_fail(*) |\n       expr_ret(*) | expr_break | expr_cont | expr_lit(_) |\n-      expr_block(*) | expr_swap(*) | expr_mac(*) | expr_addr_of(*) {\n+      expr_block(*) | expr_swap(*) | expr_mac(*) {\n         visit::visit_expr(expr, self, vt);\n       }\n     }\n@@ -1471,7 +1501,10 @@ impl check_methods for @liveness {\n                ln.to_str(), var.to_str()];\n \n         alt (*self).live_on_exit(ln, var) {\n-          none { }\n+          none {\n+            // update spill map to include this variable, as it is moved:\n+            (*self.ir).add_spill(var);\n+          }\n           some(lnk) {\n             self.report_illegal_move(span, lnk, var);\n           }\n@@ -1483,10 +1516,20 @@ impl check_methods for @liveness {\n           some(_) {}\n           none {\n             (*self.ir).add_last_use(expr.id, var);\n+\n+            // update spill map to include this variable, as it may be moved:\n+            (*self.ir).add_spill(var);\n           }\n        }\n     }\n \n+    fn spill_expr(expr: @expr) {\n+        alt (*self).variable_from_path(expr) {\n+          some(var) {(*self.ir).add_spill(var)}\n+          none {}\n+        }\n+    }\n+\n     fn check_move_from_expr(expr: @expr, vt: vt<@liveness>) {\n         #debug[\"check_move_from_expr(node %d: %s)\",\n                expr.id, expr_to_str(expr)];\n@@ -1732,4 +1775,4 @@ impl check_methods for @liveness {\n             }\n         }\n     }\n- }\n+ }\n\\ No newline at end of file"}, {"sha": "1eef30a17826e7bc61f4ce7029ba5b507002f3f1", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -3749,8 +3749,6 @@ fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let ty = expr_ty(bcx, e);\n     let lv = trans_lval(bcx, e);\n     let last_use = (lv.kind == owned && last_use_map.contains_key(e.id));\n-    #debug[\"is last use (%s) = %b, %d\", expr_to_str(e), last_use,\n-           lv.kind as int];\n     lval_result_to_dps(lv, ty, last_use, dest)\n }\n \n@@ -4041,10 +4039,29 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n     let ty = node_id_type(bcx, local.node.id);\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       some(local_mem(v)) { v }\n-      _ { bcx.tcx().sess.span_bug(local.span,\n+      some(_) { bcx.tcx().sess.span_bug(local.span,\n                         \"init_local: Someone forgot to document why it's\\\n                          safe to assume local.node.init must be local_mem!\");\n+      }\n+      // This is a local that is kept immediate\n+      none {\n+        let initexpr = alt local.node.init {\n+                some({expr, _}) { expr }\n+                none { bcx.tcx().sess.span_bug(local.span,\n+                        \"init_local: late-initialized var appears to \\\n+                 be an immediate -- possibly init_local was called \\\n+                 without calling alloc_local\"); }\n+            };\n+        let mut {bcx, val, kind} = trans_temp_lval(bcx, initexpr);\n+        if kind != temporary {\n+            if kind == owned { val = Load(bcx, val); }\n+            let rs = take_ty_immediate(bcx, val, ty);\n+            bcx = rs.bcx; val = rs.val;\n+            add_clean_temp(bcx, val, ty);\n         }\n+        bcx.fcx.lllocals.insert(local.node.pat.id, local_imm(val));\n+        ret bcx;\n+      }\n     };\n \n     let mut bcx = bcx;\n@@ -4324,6 +4341,17 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n       ast::pat_ident(pth, none) { some(path_to_ident(pth)) }\n       _ { none }\n     };\n+    // Do not allocate space for locals that can be kept immediate.\n+    let ccx = cx.ccx();\n+    if option::is_some(simple_name) &&\n+       !ccx.maps.mutbl_map.contains_key(local.node.pat.id) &&\n+       !ccx.maps.spill_map.contains_key(local.node.pat.id) &&\n+       ty::type_is_immediate(t) {\n+        alt local.node.init {\n+          some({op: ast::init_assign, _}) { ret cx; }\n+          _ {}\n+        }\n+    }\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n         option::iter(simple_name) {|name|"}, {"sha": "c34953ac33e6f5c3c907bf26101d2eb3d525df97", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -13,8 +13,9 @@ import tstate::ann::{pre_and_post, pre_and_post_state, empty_ann, prestate,\n                      set_postcondition, ts_ann,\n                      clear_in_postcond,\n                      clear_in_poststate_};\n+import tritv::*;\n+import bitvectors::promises_;\n import driver::session::session;\n-import tritv::{dont_care, tfalse, tritv_get, ttrue};\n \n import syntax::print::pprust::{constr_args_to_str, lit_to_str};\n \n@@ -810,7 +811,7 @@ fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n         // dest def_id\n         let insts = find_instances(fcx, subst, val);\n         for insts.each {|p|\n-            if bitvectors::promises_(p.from, src_post) {\n+            if promises_(p.from, src_post) {\n                 set_in_poststate_(p.to, target_post);\n             }\n         }"}, {"sha": "3b32bca1e5f86ac61038b8f5bfd057474cfa14dc", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -4,19 +4,19 @@ import std::map::hashmap;\n import driver::session;\n import session::session;\n import syntax::{ast, ast_map};\n+import syntax::ast::*;\n import syntax::ast_util;\n import syntax::ast_util::{is_local, local_def, split_class_items,\n                           new_def_hash};\n import syntax::codemap::span;\n import metadata::csearch;\n+import util::common::*;\n import util::ppaux::region_to_str;\n import util::ppaux::vstore_to_str;\n import util::ppaux::{ty_to_str, tys_to_str, ty_constr_to_str};\n+import syntax::print::pprust::*;\n import middle::lint::{get_warning_level, vecs_not_implicitly_copyable,\n                       ignore};\n-import syntax::ast::*;\n-import syntax::print::pprust::*;\n-\n export ty_vid, region_vid, vid;\n export br_hashmap;\n export is_instantiable;"}, {"sha": "d8ce3d83a60351d41dfb4478baf0e606d72a6a0f", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -45,8 +45,7 @@ an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \"];\n \n import check::fn_ctxt;\n-import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n-import rscope::{in_binding_rscope, region_scope, type_rscope};\n+import rscope::*;\n \n iface ast_conv {\n     fn tcx() -> ty::ctxt;"}, {"sha": "2649dc6c6756b8834b2800a00b3d3f1e11118fe9", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -71,8 +71,7 @@ import collect::{methods}; // ccx.to_ty()\n import method::{methods};  // methods for method::lookup\n import middle::ty::tys_in_fn_ty;\n import regionmanip::{replace_bound_regions_in_fn_ty, region_of};\n-import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n-import rscope::{in_binding_rscope, region_scope, type_rscope};\n+import rscope::*;\n \n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n@@ -387,12 +386,6 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           };\n           // typecheck the members\n           for members.each {|m| check_class_member(class_ccx, class_t, m); }\n-          // Check that there's at least one field\n-          let (fields,_) = split_class_items(members);\n-          if fields.len() < 1u {\n-              ccx.tcx.sess.span_err(it.span, \"A class must have at least one \\\n-                field\");\n-          }\n           // Check that the class is instantiable\n           check_instantiable(ccx.tcx, it.span, it.id);\n       }"}, {"sha": "60f4ea8dabffa3a3f1e9d38b2592144d0ced239f", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -1,14 +1,6 @@\n import std::map::hashmap;\n import middle::ty;\n-import middle::ty::{arg, bound_region, br_anon, br_named, canon_mode};\n-import middle::ty::{ck_block, ck_box, ck_uniq, constr, ctxt, field, method};\n-import middle::ty::{mt, re_bound, re_free, re_scope, re_var, region, t};\n-import middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_constr, ty_enum};\n-import middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_iface, ty_int};\n-import middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n-import middle::ty::{ty_ptr, ty_rec, ty_res, ty_rptr, ty_self, ty_str, ty_tup};\n-import middle::ty::{ty_type, ty_uniq, ty_uint, ty_var, ty_var_integral};\n-import middle::ty::{ty_vec, vid};\n+import middle::ty::*;\n import metadata::encoder;\n import syntax::codemap;\n import syntax::print::pprust;"}, {"sha": "a500d249c07a8aa0071d35868d01090e788f32cb", "filename": "src/test/compile-fail/issue-2509-a.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adb717b5fa3500c50ced39266c76fc909808c189/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb717b5fa3500c50ced39266c76fc909808c189/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs?ref=adb717b5fa3500c50ced39266c76fc909808c189", "patch": "@@ -1,9 +0,0 @@\n-class c { //! ERROR A class must have at least one field\n-    new() { }\n-}\n-\n-fn main() {\n-    let a = c();\n-    let x = [a];\n-    let _y = x[0];\n-}"}, {"sha": "8f4bd22f75dde8473157ac1b1ade88ae4e84230f", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/055158d05191000384b490399c104394cbc0c838/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055158d05191000384b490399c104394cbc0c838/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=055158d05191000384b490399c104394cbc0c838", "patch": "@@ -26,13 +26,11 @@ enum tg { bar, }\n \n #[cfg(bogus)]\n class r {\n-  let i: int;\n-  new(i:int) { self.i = i; }\n+  new(i:int) {}\n }\n \n class r {\n-  let i: int;\n-  new(i:int) { self.i = i; }\n+  new(i:int) {}\n }\n \n #[cfg(bogus)]"}]}