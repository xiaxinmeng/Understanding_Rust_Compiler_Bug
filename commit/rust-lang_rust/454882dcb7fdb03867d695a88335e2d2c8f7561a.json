{"sha": "454882dcb7fdb03867d695a88335e2d2c8f7561a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NDg4MmRjYjdmZGIwMzg2N2Q2OTVhODgzMzVlMmQyYzhmNzU2MWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-05T03:02:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-06T23:48:56Z"}, "message": "Remove std::condition\n\nThis has been a long time coming. Conditions in rust were initially envisioned\nas being a good alternative to error code return pattern. The idea is that all\nerrors are fatal-by-default, and you can opt-in to handling the error by\nregistering an error handler.\n\nWhile sounding nice, conditions ended up having some unforseen shortcomings:\n\n* Actually handling an error has some very awkward syntax:\n\n    let mut result = None;\n    let mut answer = None;\n    io::io_error::cond.trap(|e| { result = Some(e) }).inside(|| {\n        answer = Some(some_io_operation());\n    });\n    match result {\n        Some(err) => { /* hit an I/O error */ }\n        None => {\n            let answer = answer.unwrap();\n            /* deal with the result of I/O */\n        }\n    }\n\n  This pattern can certainly use functions like io::result, but at its core\n  actually handling conditions is fairly difficult\n\n* The \"zero value\" of a function is often confusing. One of the main ideas\n  behind using conditions was to change the signature of I/O functions. Instead\n  of read_be_u32() returning a result, it returned a u32. Errors were notified\n  via a condition, and if you caught the condition you understood that the \"zero\n  value\" returned is actually a garbage value. These zero values are often\n  difficult to understand, however.\n\n  One case of this is the read_bytes() function. The function takes an integer\n  length of the amount of bytes to read, and returns an array of that size. The\n  array may actually be shorter, however, if an error occurred.\n\n  Another case is fs::stat(). The theoretical \"zero value\" is a blank stat\n  struct, but it's a little awkward to create and return a zero'd out stat\n  struct on a call to stat().\n\n  In general, the return value of functions that can raise error are much more\n  natural when using a Result as opposed to an always-usable zero-value.\n\n* Conditions impose a necessary runtime requirement on *all* I/O. In theory I/O\n  is as simple as calling read() and write(), but using conditions imposed the\n  restriction that a rust local task was required if you wanted to catch errors\n  with I/O. While certainly an surmountable difficulty, this was always a bit of\n  a thorn in the side of conditions.\n\n* Functions raising conditions are not always clear that they are raising\n  conditions. This suffers a similar problem to exceptions where you don't\n  actually know whether a function raises a condition or not. The documentation\n  likely explains, but if someone retroactively adds a condition to a function\n  there's nothing forcing upstream users to acknowledge a new point of task\n  failure.\n\n* Libaries using I/O are not guaranteed to correctly raise on conditions when an\n  error occurs. In developing various I/O libraries, it's much easier to just\n  return `None` from a read rather than raising an error. The silent contract of\n  \"don't raise on EOF\" was a little difficult to understand and threw a wrench\n  into the answer of the question \"when do I raise a condition?\"\n\nMany of these difficulties can be overcome through documentation, examples, and\ngeneral practice. In the end, all of these difficulties added together ended up\nbeing too overwhelming and improving various aspects didn't end up helping that\nmuch.\n\nA result-based I/O error handling strategy also has shortcomings, but the\ncognitive burden is much smaller. The tooling necessary to make this strategy as\nusable as conditions were is much smaller than the tooling necessary for\nconditions.\n\nPerhaps conditions may manifest themselves as a future entity, but for now\nwe're going to remove them from the standard library.\n\nCloses #9795\nCloses #8968", "tree": {"sha": "467d0884fb80c987d234d2762f392c64e19d7570", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/467d0884fb80c987d234d2762f392c64e19d7570"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/454882dcb7fdb03867d695a88335e2d2c8f7561a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/454882dcb7fdb03867d695a88335e2d2c8f7561a", "html_url": "https://github.com/rust-lang/rust/commit/454882dcb7fdb03867d695a88335e2d2c8f7561a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/454882dcb7fdb03867d695a88335e2d2c8f7561a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "html_url": "https://github.com/rust-lang/rust/commit/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a"}], "stats": {"total": 1866, "additions": 93, "deletions": 1773}, "files": [{"sha": "28d2fd80627584c34aa41c491e7f6859a0285e91", "filename": "mk/docs.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -205,12 +205,6 @@ doc/guide-tasks.html: $(D)/guide-tasks.md $(HTML_DEPS)\n \t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n \t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n \n-DOCS += doc/guide-conditions.html\n-doc/guide-conditions.html: $(D)/guide-conditions.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(D)/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n DOCS += doc/guide-pointers.html\n doc/guide-pointers.html: $(D)/guide-pointers.md $(HTML_DEPS)\n \t@$(call E, pandoc: $@)"}, {"sha": "a1e0446e645f2481a52fa4cd1143a378aba1e4d4", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -21,7 +21,7 @@ TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n # Markdown files under doc/ that should have their code extracted and run\n DOC_TEST_NAMES = tutorial guide-ffi guide-macros guide-lifetimes \\\n-                 guide-tasks guide-conditions guide-container guide-pointers \\\n+                 guide-tasks guide-container guide-pointers \\\n                  complement-cheatsheet guide-runtime \\\n                  rust\n "}, {"sha": "5b7494c06187913732e6d3339445ea1e81d66824", "filename": "src/doc/guide-conditions.md", "status": "removed", "additions": 0, "deletions": 837, "changes": 837, "blob_url": "https://github.com/rust-lang/rust/blob/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Fdoc%2Fguide-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Fdoc%2Fguide-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-conditions.md?ref=f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "patch": "@@ -1,837 +0,0 @@\n-% The Rust Condition and Error-handling Guide\n-\n-# Introduction\n-\n-Rust does not provide exception handling[^why-no-exceptions]\n-in the form most commonly seen in other programming languages such as C++ or Java.\n-Instead, it provides four mechanisms that work together to handle errors or other rare events.\n-The four mechanisms are:\n-\n-  - Options\n-  - Results\n-  - Failure\n-  - Conditions\n-\n-This guide will lead you through use of these mechanisms\n-in order to understand the trade-offs of each and relationships between them.\n-\n-# Example program\n-\n-This guide will be based around an example program\n-that attempts to read lines from a file\n-consisting of pairs of numbers,\n-and then print them back out with slightly different formatting.\n-The input to the program might look like this:\n-\n-~~~~ {.notrust}\n-$ cat numbers.txt\n-1 2\n-34 56\n-789 123\n-45 67\n-~~~~\n-\n-For which the intended output looks like this:\n-\n-~~~~ {.notrust}\n-$ ./example numbers.txt\n-0001, 0002\n-0034, 0056\n-0789, 0123\n-0045, 0067\n-~~~~\n-\n-An example program that does this task reads like this:\n-\n-~~~~\n-# #[allow(unused_imports)];\n-use std::io::{BufferedReader, File};\n-# mod BufferedReader {\n-#     use std::io::{File, IoResult};\n-#     use std::io::MemReader;\n-#     use std::io::BufferedReader;\n-#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                        34 56\\n\\\n-#                                        789 123\\n\\\n-#                                        45 67\\n\\\n-#                                        \");\n-#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n-#           BufferedReader::new(MemReader::new(s.to_owned()))\n-#     }\n-# }\n-\n-fn main() {\n-    let pairs = read_int_pairs();\n-    for &(a,b) in pairs.iter() {\n-        println!(\"{:4.4d}, {:4.4d}\", a, b);\n-    }\n-}\n-\n-fn read_int_pairs() -> ~[(int,int)] {\n-    let mut pairs = ~[];\n-\n-    // Path takes a generic by-value, rather than by reference\n-    let path = Path::new(&\"foo.txt\");\n-    let mut reader = BufferedReader::new(File::open(&path));\n-\n-    // 1. Iterate over the lines of our file.\n-    for line in reader.lines() {\n-        // 2. Split the line into fields (\"words\").\n-        let fields = line.words().to_owned_vec();\n-        // 3. Match the vector of fields against a vector pattern.\n-        match fields {\n-\n-            // 4. When the line had two fields:\n-            [a, b] => {\n-                // 5. Try parsing both fields as ints.\n-                match (from_str::<int>(a), from_str::<int>(b)) {\n-\n-                    // 6. If parsing succeeded for both, push both.\n-                    (Some(a), Some(b)) => pairs.push((a,b)),\n-                    // 7. Ignore non-int fields.\n-                    _ => ()\n-                }\n-            }\n-            // 8. Ignore lines that don't have 2 fields.\n-            _ => ()\n-        }\n-    }\n-    pairs\n-}\n-~~~~\n-\n-This example shows the use of `Option`,\n-along with some other forms of error-handling (and non-handling).\n-We will look at these mechanisms\n-and then modify parts of the example to perform \"better\" error handling.\n-\n-# Options\n-\n-The simplest and most lightweight mechanism in Rust for indicating an error is the type `std::option::Option<T>`.\n-This type is a general purpose `enum`\n-for conveying a value of type `T`, represented as `Some(T)`\n-_or_ the sentinel `None`, to indicate the absence of a `T` value.\n-For simple APIs, it may be sufficient to encode errors as `Option<T>`,\n-returning `Some(T)` on success and `None` on error.\n-In the example program, the call to `from_str::<int>` returns `Option<int>`\n-with the understanding that \"all parse errors\" result in `None`.\n-The resulting `Option<int>` values are matched against the pattern `(Some(a), Some(b))`\n-in steps 5 and 6 in the example program,\n-to handle the case in which both fields were parsed successfully.\n-\n-Using `Option` as in this API has some advantages:\n-\n-  - Simple API, users can read it and guess how it works.\n-  - Very efficient, only an extra `enum` tag on return values.\n-  - Caller has flexibility in handling or propagating errors.\n-  - Caller is forced to acknowledge existence of possible-error before using value.\n-\n-However, it has serious disadvantages too:\n-\n-  - Verbose, requires matching results or calling `Option::unwrap` everywhere.\n-  - Infects caller: if caller doesn't know how to handle the error, must propagate (or force).\n-  - Temptation to do just that: force the `Some(T)` case by blindly calling `unwrap`,\n-    which hides the error from the API without providing any way to make the program robust against the error.\n-  - Collapses all errors into one:\n-    - Caller can't handle different errors differently.\n-    - Caller can't even report a very precise error message\n-\n-Note that in order to keep the example code reasonably compact,\n-several unwanted cases are silently ignored:\n-lines that do not contain two fields, as well as fields that do not parse as ints.\n-To propagate these cases to the caller using `Option` would require even more verbose code.\n-\n-# Results\n-\n-Before getting into _trapping_ the error,\n-we will look at a slight refinement on the `Option` type above.\n-This second mechanism for indicating an error is called a `Result`.\n-The type `std::result::Result<T,E>` is another simple `enum` type with two forms, `Ok(T)` and `Err(E)`.\n-The `Result` type is not substantially different from the `Option` type in terms of its ergonomics.\n-Its main advantage is that the error constructor `Err(E)` can convey _more detail_ about the error.\n-For example, the `from_str` API could be reformed\n-to return a `Result` carrying an informative description of a parse error,\n-like this:\n-\n-~~~~ {.ignore}\n-enum IntParseErr {\n-     EmptyInput,\n-     Overflow,\n-     BadChar(char)\n-}\n-\n-fn from_str(&str) -> Result<int,IntParseErr> {\n-  // ...\n-}\n-~~~~\n-\n-This would give the caller more information for both handling and reporting the error,\n-but would otherwise retain the verbosity problems of using `Option`.\n-In particular, it would still be necessary for the caller to return a further `Result` to _its_ caller if it did not want to handle the error.\n-Manually propagating result values this way can be attractive in certain circumstances\n-&mdash; for example when processing must halt on the very first error, or backtrack &mdash;\n-but as we will see later, many cases have simpler options available.\n-\n-# Failure\n-\n-The third and arguably easiest mechanism for handling errors is called \"failure\".\n-In fact it was hinted at earlier by suggesting that one can choose to propagate `Option` or `Result` types _or \"force\" them_.\n-\"Forcing\" them, in this case, means calling a method like `Option<T>::unwrap`,\n-which contains the following code:\n-\n-~~~~ {.ignore}\n-pub fn unwrap(self) -> T {\n-    match self {\n-      Some(x) => return x,\n-      None => fail!(\"option::unwrap `None`\")\n-    }\n-}\n-~~~~\n-\n-That is, it returns `T` when `self` is `Some(T)`, and  _fails_ when `self` is `None`.\n-\n-Every Rust task can _fail_, either indirectly due to a kill signal or other asynchronous event,\n-or directly by failing an `assert!` or calling the `fail!` macro.\n-Failure is an _unrecoverable event_ at the task level:\n-it causes the task to halt normal execution and unwind its control stack,\n-freeing all task-local resources (the local heap as well as any task-owned values from the global heap)\n-and running destructors (the `drop` method of the `Drop` trait)\n-as frames are unwound and heap values destroyed.\n-A failing task is not permitted to \"catch\" the unwinding during failure and recover,\n-it is only allowed to clean up and exit.\n-\n-Failure has advantages:\n-\n-  - Simple and non-verbose. Suitable for programs that can't reasonably continue past an error anyways.\n-  - _All_ errors (except memory-safety errors) can be uniformly trapped in a supervisory task outside the failing task.\n-    For a large program to be robust against a variety of errors,\n-    often some form of task-level partitioning to contain pervasive errors (arithmetic overflow, division by zero,\n-    logic bugs) is necessary anyways.\n-\n-As well as obvious disadvantages:\n-\n-  - A blunt instrument, terminates the containing task entirely.\n-\n-Recall that in the first two approaches to error handling,\n-the example program was only handling success cases, and ignoring error cases.\n-That is, if the input is changed to contain a malformed line:\n-\n-~~~~ {.notrust}\n-$ cat bad.txt\n-1 2\n-34 56\n-ostrich\n-789 123\n-45 67\n-~~~~\n-\n-Then the program would give the same output as if there was no error:\n-\n-~~~~ {.notrust}\n-$ ./example bad.txt\n-0001, 0002\n-0034, 0056\n-0789, 0123\n-0045, 0067\n-~~~~\n-\n-If the example is rewritten to use failure, these error cases can be trapped.\n-In this rewriting, failures are trapped by placing the I/O logic in a sub-task,\n-and trapping its exit status using `task::try`:\n-\n-~~~~\n-# #[allow(unused_imports)];\n-use std::io::{BufferedReader, File};\n-use std::task;\n-# mod BufferedReader {\n-#     use std::io::{File, IoResult};\n-#     use std::io::MemReader;\n-#     use std::io::BufferedReader;\n-#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                        34 56\\n\\\n-#                                        789 123\\n\\\n-#                                        45 67\\n\\\n-#                                        \");\n-#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n-#           BufferedReader::new(MemReader::new(s.to_owned()))\n-#     }\n-# }\n-\n-fn main() {\n-\n-    // Isolate failure within a subtask.\n-    let result = task::try(proc() {\n-\n-        // The protected logic.\n-        let pairs = read_int_pairs();\n-        for &(a,b) in pairs.iter() {\n-            println!(\"{:4.4d}, {:4.4d}\", a, b);\n-        }\n-\n-    });\n-    if result.is_err() {\n-            println!(\"parsing failed\");\n-    }\n-}\n-\n-fn read_int_pairs() -> ~[(int,int)] {\n-    let mut pairs = ~[];\n-    let path = Path::new(&\"foo.txt\");\n-\n-    let mut reader = BufferedReader::new(File::open(&path));\n-    for line in reader.lines() {\n-        match line.words().to_owned_vec() {\n-            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n-                                  from_str::<int>(b).unwrap())),\n-\n-            // Explicitly fail on malformed lines.\n-            _ => fail!()\n-        }\n-    }\n-    pairs\n-}\n-~~~~\n-\n-With these changes in place, running the program on malformed input gives a different answer:\n-\n-~~~~ {.notrust}\n-$ ./example bad.txt\n-rust: task failed at 'explicit failure', ./example.rs:44\n-parsing failed\n-~~~~\n-\n-Note that while failure unwinds the sub-task performing I/O in `read_int_pairs`,\n-control returns to `main` and can easily continue uninterrupted.\n-In this case, control simply prints out `parsing failed` and then exits `main` (successfully).\n-Failure of a (sub-)task is analogous to calling `exit(1)` or `abort()` in a unix C program:\n-all the state of a sub-task is cleanly discarded on exit,\n-and a supervisor task can take appropriate action\n-without worrying about its own state having been corrupted.\n-\n-# Conditions\n-\n-The final mechanism for handling errors is called a \"condition\".\n-Conditions are less blunt than failure, and less cumbersome than the `Option` or `Result` types;\n-indeed they are designed to strike just the right balance between the two.\n-Conditions require some care to use effectively, but give maximum flexibility with minimum verbosity.\n-While conditions use exception-like terminology (\"trap\", \"raise\") they are significantly different:\n-\n-  - Like exceptions and failure, conditions separate the site at which the error is raised from the site where it is trapped.\n-  - Unlike exceptions and unlike failure, when a condition is raised and trapped, _no unwinding occurs_.\n-  - A successfully trapped condition causes execution to continue _at the site of the error_, as though no error occurred.\n-\n-Conditions are declared with the `condition!` macro.\n-Each condition has a name, an input type and an output type, much like a function.\n-In fact, conditions are implemented as dynamically-scoped functions held in task local storage.\n-\n-The `condition!` macro declares a module with the name of the condition;\n-the module contains a single static value called `cond`, of type `std::condition::Condition`.\n-The `cond` value within the module is the rendezvous point\n-between the site of error and the site that handles the error.\n-It has two methods of interest: `raise` and `trap`.\n-\n-The `raise` method maps a value of the condition's input type to its output type.\n-The input type should therefore convey all relevant information to the condition handler.\n-The output type should convey all relevant information _for continuing execution at the site of error_.\n-When the error site raises a condition handler,\n-the `Condition::raise` method searches for the innermost installed task-local condition _handler_,\n-and if any such handler is found, calls it with the provided input value.\n-If no handler is found, `Condition::raise` will fail the task with an appropriate error message.\n-\n-Rewriting the example to use a condition in place of ignoring malformed lines makes it slightly longer,\n-but similarly clear as the version that used `fail!` in the logic where the error occurs:\n-\n-~~~~\n-# #[allow(unused_imports)];\n-use std::io::{BufferedReader, File};\n-# mod BufferedReader {\n-#     use std::io::{File, IoResult};\n-#     use std::io::MemReader;\n-#     use std::io::BufferedReader;\n-#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                        34 56\\n\\\n-#                                        789 123\\n\\\n-#                                        45 67\\n\\\n-#                                        \");\n-#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n-#           BufferedReader::new(MemReader::new(s.to_owned()))\n-#     }\n-# }\n-\n-// Introduce a new condition.\n-condition! {\n-    pub malformed_line : ~str -> (int,int);\n-}\n-\n-fn main() {\n-    let pairs = read_int_pairs();\n-    for &(a,b) in pairs.iter() {\n-        println!(\"{:4.4d}, {:4.4d}\", a, b);\n-    }\n-}\n-\n-fn read_int_pairs() -> ~[(int,int)] {\n-    let mut pairs = ~[];\n-    let path = Path::new(&\"foo.txt\");\n-\n-    let mut reader = BufferedReader::new(File::open(&path));\n-    for line in reader.lines() {\n-        match line.words().to_owned_vec() {\n-            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n-                                  from_str::<int>(b).unwrap())),\n-            // On malformed lines, call the condition handler and\n-            // push whatever the condition handler returns.\n-            _ => pairs.push(malformed_line::cond.raise(line.clone()))\n-        }\n-    }\n-    pairs\n-}\n-~~~~\n-\n-When this is run on malformed input, it still fails,\n-but with a slightly different failure message than before:\n-\n-~~~~ {.notrust}\n-$ ./example bad.txt\n-rust: task failed at 'Unhandled condition: malformed_line: ~\"ostrich\"', .../libstd/condition.rs:43\n-~~~~\n-\n-While this superficially resembles the trapped `fail!` call before,\n-it is only because the example did not install a handler for the condition.\n-The different failure message is indicating, among other things,\n-that the condition-handling system is being invoked and failing\n-only due to the absence of a _handler_ that traps the condition.\n-\n-# Trapping a condition\n-\n-To trap a condition, use `Condition::trap` in some caller of the site that calls `Condition::raise`.\n-For example, this version of the program traps the `malformed_line` condition\n-and replaces bad input lines with the pair `(-1,-1)`:\n-\n-~~~~\n-# #[allow(unused_imports)];\n-use std::io::{BufferedReader, File};\n-# mod BufferedReader {\n-#     use std::io::{File, IoResult};\n-#     use std::io::MemReader;\n-#     use std::io::BufferedReader;\n-#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                        34 56\\n\\\n-#                                        789 123\\n\\\n-#                                        45 67\\n\\\n-#                                        \");\n-#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n-#           BufferedReader::new(MemReader::new(s.to_owned()))\n-#     }\n-# }\n-\n-condition! {\n-    pub malformed_line : ~str -> (int,int);\n-}\n-\n-fn main() {\n-    // Trap the condition:\n-    malformed_line::cond.trap(|_| (-1,-1)).inside(|| {\n-\n-        // The protected logic.\n-        let pairs = read_int_pairs();\n-        for &(a,b) in pairs.iter() {\n-                println!(\"{:4.4d}, {:4.4d}\", a, b);\n-        }\n-\n-    })\n-}\n-\n-fn read_int_pairs() -> ~[(int,int)] {\n-    let mut pairs = ~[];\n-    let path = Path::new(&\"foo.txt\");\n-\n-    let mut reader = BufferedReader::new(File::open(&path));\n-    for line in reader.lines() {\n-        match line.words().to_owned_vec() {\n-            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n-                                  from_str::<int>(b).unwrap())),\n-            _ => pairs.push(malformed_line::cond.raise(line.clone()))\n-        }\n-    }\n-    pairs\n-}\n-~~~~\n-\n-Note that the remainder of the program is _unchanged_ with this trap in place;\n-only the caller that installs the trap changed.\n-Yet when the condition-trapping variant runs on the malformed input,\n-it continues execution past the malformed line, substituting the handler's return value.\n-\n-~~~~ {.notrust}\n-$ ./example bad.txt\n-0001, 0002\n-0034, 0056\n--0001, -0001\n-0789, 0123\n-0045, 0067\n-~~~~\n-\n-# Refining a condition\n-\n-As you work with a condition, you may find that the original set of options you present for recovery is insufficient.\n-This is no different than any other issue of API design:\n-a condition handler is an API for recovering from the condition, and sometimes APIs need to be enriched.\n-In the example program, the first form of the `malformed_line` API implicitly assumes that recovery involves a substitute value.\n-This assumption may not be correct; some callers may wish to skip malformed lines, for example.\n-Changing the condition's return type from `(int,int)` to `Option<(int,int)>` will suffice to support this type of recovery:\n-\n-~~~~\n-# #[allow(unused_imports)];\n-use std::io::{BufferedReader, File};\n-# mod BufferedReader {\n-#     use std::io::{IoResult, File};\n-#     use std::io::MemReader;\n-#     use std::io::BufferedReader;\n-#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                        34 56\\n\\\n-#                                        789 123\\n\\\n-#                                        45 67\\n\\\n-#                                        \");\n-#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n-#           BufferedReader::new(MemReader::new(s.to_owned()))\n-#     }\n-# }\n-\n-// Modify the condition signature to return an Option.\n-condition! {\n-    pub malformed_line : ~str -> Option<(int,int)>;\n-}\n-\n-fn main() {\n-    // Trap the condition and return `None`\n-    malformed_line::cond.trap(|_| None).inside(|| {\n-\n-        // The protected logic.\n-        let pairs = read_int_pairs();\n-        for &(a,b) in pairs.iter() {\n-            println!(\"{:4.4d}, {:4.4d}\", a, b);\n-        }\n-\n-    })\n-}\n-\n-fn read_int_pairs() -> ~[(int,int)] {\n-    let mut pairs = ~[];\n-    let path = Path::new(&\"foo.txt\");\n-\n-    let mut reader = BufferedReader::new(File::open(&path));\n-    for line in reader.lines() {\n-        match line.words().to_owned_vec() {\n-            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n-                                  from_str::<int>(b).unwrap())),\n-\n-            // On malformed lines, call the condition handler and\n-            // either ignore the line (if the handler returns `None`)\n-            // or push any `Some(pair)` value returned instead.\n-            _ => {\n-                match malformed_line::cond.raise(line.clone()) {\n-                    Some(pair) => pairs.push(pair),\n-                    None => ()\n-                }\n-            }\n-        }\n-    }\n-    pairs\n-}\n-~~~~\n-\n-Again, note that the remainder of the program is _unchanged_,\n-in particular the signature of `read_int_pairs` is unchanged,\n-even though the innermost part of its reading-loop has a new way of handling a malformed line.\n-When the example is run with the `None` trap in place,\n-the line is ignored as it was in the first example,\n-but the choice of whether to ignore or use a substitute value has been moved to some caller,\n-possibly a distant caller.\n-\n-~~~~ {.notrust}\n-$ ./example bad.txt\n-0001, 0002\n-0034, 0056\n-0789, 0123\n-0045, 0067\n-~~~~\n-\n-# Further refining a condition\n-\n-Like with any API, the process of refining argument and return types of a condition will continue,\n-until all relevant combinations encountered in practice are encoded.\n-In the example, suppose a third possible recovery form arose: reusing the previous value read.\n-This can be encoded in the handler API by introducing a helper type: `enum MalformedLineFix`.\n-\n-~~~~\n-# #[allow(unused_imports)];\n-use std::io::{BufferedReader, File};\n-# mod BufferedReader {\n-#     use std::io::{File, IoResult};\n-#     use std::io::MemReader;\n-#     use std::io::BufferedReader;\n-#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                        34 56\\n\\\n-#                                        789 123\\n\\\n-#                                        45 67\\n\\\n-#                                        \");\n-#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n-#           BufferedReader::new(MemReader::new(s.to_owned()))\n-#     }\n-# }\n-\n-// Introduce a new enum to convey condition-handling strategy to error site.\n-pub enum MalformedLineFix {\n-     UsePair(int,int),\n-     IgnoreLine,\n-     UsePreviousLine\n-}\n-\n-// Modify the condition signature to return the new enum.\n-// Note: a condition introduces a new module, so the enum must be\n-// named with the `super::` prefix to access it.\n-condition! {\n-    pub malformed_line : ~str -> super::MalformedLineFix;\n-}\n-\n-fn main() {\n-    // Trap the condition and return `UsePreviousLine`\n-    malformed_line::cond.trap(|_| UsePreviousLine).inside(|| {\n-\n-        // The protected logic.\n-        let pairs = read_int_pairs();\n-        for &(a,b) in pairs.iter() {\n-            println!(\"{:4.4d}, {:4.4d}\", a, b);\n-        }\n-\n-    })\n-}\n-\n-fn read_int_pairs() -> ~[(int,int)] {\n-    let mut pairs = ~[];\n-    let path = Path::new(&\"foo.txt\");\n-\n-    let mut reader = BufferedReader::new(File::open(&path));\n-    for line in reader.lines() {\n-        match line.words().to_owned_vec() {\n-            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n-                                  from_str::<int>(b).unwrap())),\n-\n-            // On malformed lines, call the condition handler and\n-            // take action appropriate to the enum value returned.\n-            _ => {\n-                match malformed_line::cond.raise(line.clone()) {\n-                    UsePair(a,b) => pairs.push((a,b)),\n-                    IgnoreLine => (),\n-                    UsePreviousLine => {\n-                        let prev = pairs[pairs.len() - 1];\n-                        pairs.push(prev)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    pairs\n-}\n-~~~~\n-\n-Running the example with `UsePreviousLine` as the fix code returned from the handler\n-gives the expected result:\n-\n-~~~~ {.notrust}\n-$ ./example bad.txt\n-0001, 0002\n-0034, 0056\n-0034, 0056\n-0789, 0123\n-0045, 0067\n-~~~~\n-\n-At this point the example has a rich variety of recovery options,\n-none of which is visible to casual users of the `read_int_pairs` function.\n-This is intentional: part of the purpose of using a condition\n-is to free intermediate callers from the burden of having to write repetitive error-propagation logic,\n-and/or having to change function call and return types as error-handling strategies are refined.\n-\n-# Multiple conditions, intermediate callers\n-\n-So far the function trapping the condition and the function raising it have been immediately adjacent in the call stack.\n-That is, the caller traps and its immediate callee raises.\n-In most programs, the function that traps may be separated by very many function calls from the function that raises.\n-Again, this is part of the point of using conditions:\n-to support that separation without having to thread multiple error values and recovery strategies all the way through the program's main logic.\n-\n-Careful readers will notice that there is a remaining failure mode in the example program: the call to `.unwrap()` when parsing each integer.\n-For example, when presented with a file that has the correct number of fields on a line,\n-but a non-numeric value in one of them, such as this:\n-\n-~~~~ {.notrust}\n-$ cat bad.txt\n-1 2\n-34 56\n-7 marmot\n-789 123\n-45 67\n-~~~~\n-\n-\n-Then the program fails once more:\n-\n-~~~~ {.notrust}\n-$ ./example bad.txt\n-task <unnamed> failed at 'called `Option::unwrap()` on a `None` value', .../libstd/option.rs:314\n-~~~~\n-\n-To make the program robust &mdash; or at least flexible &mdash; in the face of this potential failure,\n-a second condition and a helper function will suffice:\n-\n-~~~~\n-# #[allow(unused_imports)];\n-use std::io::{BufferedReader, File};\n-# mod BufferedReader {\n-#     use std::io::{File, IoResult};\n-#     use std::io::MemReader;\n-#     use std::io::BufferedReader;\n-#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                        34 56\\n\\\n-#                                        789 123\\n\\\n-#                                        45 67\\n\\\n-#                                        \");\n-#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n-#           BufferedReader::new(MemReader::new(s.to_owned()))\n-#     }\n-# }\n-\n-pub enum MalformedLineFix {\n-     UsePair(int,int),\n-     IgnoreLine,\n-     UsePreviousLine\n-}\n-\n-condition! {\n-    pub malformed_line : ~str -> ::MalformedLineFix;\n-}\n-\n-// Introduce a second condition.\n-condition! {\n-    pub malformed_int : ~str -> int;\n-}\n-\n-fn main() {\n-    // Trap the `malformed_int` condition and return -1\n-    malformed_int::cond.trap(|_| -1).inside(|| {\n-\n-        // Trap the `malformed_line` condition and return `UsePreviousLine`\n-        malformed_line::cond.trap(|_| UsePreviousLine).inside(|| {\n-\n-            // The protected logic.\n-            let pairs = read_int_pairs();\n-            for &(a,b) in pairs.iter() {\n-                println!(\"{:4.4d}, {:4.4d}\", a, b);\n-            }\n-\n-        })\n-    })\n-}\n-\n-// Parse an int; if parsing fails, call the condition handler and\n-// return whatever it returns.\n-fn parse_int(x: &str) -> int {\n-    match from_str::<int>(x) {\n-        Some(v) => v,\n-        None => malformed_int::cond.raise(x.to_owned())\n-    }\n-}\n-\n-fn read_int_pairs() -> ~[(int,int)] {\n-    let mut pairs = ~[];\n-    let path = Path::new(&\"foo.txt\");\n-\n-    let mut reader = BufferedReader::new(File::open(&path));\n-    for line in reader.lines() {\n-        match line.words().to_owned_vec() {\n-            // Delegate parsing ints to helper function that will\n-            // handle parse errors by calling `malformed_int`.\n-            [a, b] => pairs.push((parse_int(a), parse_int(b))),\n-\n-            _ => {\n-                match malformed_line::cond.raise(line.clone()) {\n-                    UsePair(a,b) => pairs.push((a,b)),\n-                    IgnoreLine => (),\n-                    UsePreviousLine => {\n-                        let prev = pairs[pairs.len() - 1];\n-                        pairs.push(prev)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    pairs\n-}\n-~~~~\n-\n-Again, note that `read_int_pairs` has not changed signature,\n-nor has any of the machinery for trapping or raising `malformed_line`,\n-but now the program can handle the \"right number of fields, non-integral field\" form of bad input:\n-\n-~~~~ {.notrust}\n-$ ./example bad.txt\n-0001, 0002\n-0034, 0056\n-0007, -0001\n-0789, 0123\n-0045, 0067\n-~~~~\n-\n-There are three other things to note in this variant of the example program:\n-\n-  - It traps multiple conditions simultaneously,\n-    nesting the protected logic of one `trap` call inside the other.\n-\n-  - There is a function in between the `trap` site and `raise` site for the `malformed_int` condition.\n-    There could be any number of calls between them:\n-    so long as the `raise` occurs within a callee (of any depth) of the logic protected by the `trap` call,\n-    it will invoke the handler.\n-\n-  - This variant insulates callers from a design choice in the library:\n-    the `from_str` function was designed to return an `Option<int>`,\n-    but this program insulates callers from that choice,\n-    routing all `None` values that arise from parsing integers in this file into the condition.\n-\n-\n-# When to use which technique\n-\n-This guide explored several techniques for handling errors.\n-Each is appropriate to different circumstances:\n-\n-  - If an error may be extremely frequent, expected, and very likely dealt with by an immediate caller,\n-    then returning an `Option` or `Result` type is best. These types force the caller to handle the error,\n-    and incur the lowest speed overhead, usually only returning one extra word to tag the return value.\n-    Between `Option` and `Result`: use an `Option` when there is only one kind of error,\n-    otherwise make an `enum FooErr` to represent the possible error codes and use `Result<T,FooErr>`.\n-\n-  - If an error can reasonably be handled at the site it occurs by one of a few strategies &mdash; possibly including failure &mdash;\n-    and it is not clear which strategy a caller would want to use, a condition is best.\n-    For many errors, the only reasonable \"non-stop\" recovery strategies are to retry some number of times,\n-    create or substitute an empty or sentinel value, ignore the error, or fail.\n-\n-  - If an error cannot reasonably be handled at the site it occurs,\n-    and the only reasonable response is to abandon a large set of operations in progress,\n-    then directly failing is best.\n-\n-Note that an unhandled condition will cause failure (along with a more-informative-than-usual message),\n-so if there is any possibility that a caller might wish to \"ignore and keep going\",\n-it is usually harmless to use a condition in place of a direct call to `fail!()`.\n-\n-\n-[^why-no-exceptions]: Exceptions in languages like C++ and Java permit unwinding, like Rust's failure system,\n-but with the option to halt unwinding partway through the process and continue execution.\n-This behavior unfortunately means that the _heap_ may be left in an inconsistent but accessible state,\n-if an exception is thrown part way through the process of initializing or modifying memory.\n-To compensate for this risk, correct C++ and Java code must program in an extremely elaborate and difficult \"exception-safe\" style\n-&mdash; effectively transactional style against heap structures &mdash;\n-or else risk introducing silent and very difficult-to-debug errors due to control resuming in a corrupted heap after a caught exception.\n-These errors are frequently memory-safety errors, which Rust strives to eliminate,\n-and so Rust unwinding is unrecoverable within a single task:\n-once unwinding starts, the entire local heap of a task is destroyed and the task is terminated."}, {"sha": "6fc31b673acf6e74739a1f150fd6a017f67ee307", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 6, "deletions": 44, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -75,24 +75,11 @@ use ptr::RawPtr;\n use ptr;\n use str::StrSlice;\n use str;\n-use vec::{CloneableVector, ImmutableVector, MutableVector};\n+use vec::{ImmutableVector, MutableVector};\n use vec;\n use unstable::intrinsics;\n use rt::global_heap::malloc_raw;\n \n-/// Resolution options for the `null_byte` condition\n-pub enum NullByteResolution {\n-    /// Truncate at the null byte\n-    Truncate,\n-    /// Use a replacement byte\n-    ReplaceWith(libc::c_char)\n-}\n-\n-condition! {\n-    // This should be &[u8] but there's a lifetime issue (#5370).\n-    pub null_byte: (~[u8]) -> NullByteResolution;\n-}\n-\n /// The representation of a C String.\n ///\n /// This structure wraps a `*libc::c_char`, and will automatically free the\n@@ -252,7 +239,7 @@ pub trait ToCStr {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the receiver has an interior null.\n+    /// Fails the task if the receiver has an interior null.\n     fn to_c_str(&self) -> CString;\n \n     /// Unsafe variant of `to_c_str()` that doesn't check for nulls.\n@@ -273,7 +260,7 @@ pub trait ToCStr {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the receiver has an interior null.\n+    /// Fails the task if the receiver has an interior null.\n     #[inline]\n     fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n         self.to_c_str().with_ref(f)\n@@ -362,12 +349,7 @@ fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n     for i in range(0, v.len()) {\n         unsafe {\n             let p = buf.offset(i as int);\n-            if *p == 0 {\n-                match null_byte::cond.raise(v.to_owned()) {\n-                    Truncate => break,\n-                    ReplaceWith(c) => *p = c\n-                }\n-            }\n+            assert!(*p != 0);\n         }\n     }\n }\n@@ -541,29 +523,9 @@ mod tests {\n \n     #[test]\n     fn test_to_c_str_fail() {\n-        use c_str::null_byte::cond;\n-\n+        use task;\n         let mut error_happened = false;\n-        cond.trap(|err| {\n-            assert_eq!(err, bytes!(\"he\", 0, \"llo\").to_owned())\n-            error_happened = true;\n-            Truncate\n-        }).inside(|| \"he\\x00llo\".to_c_str());\n-        assert!(error_happened);\n-\n-        cond.trap(|_| {\n-            ReplaceWith('?' as libc::c_char)\n-        }).inside(|| \"he\\x00llo\".to_c_str()).with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-                assert_eq!(*buf.offset(2), '?' as libc::c_char);\n-                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n-                assert_eq!(*buf.offset(6), 0);\n-            }\n-        })\n+        assert!(task::try(proc() { \"he\\x00llo\".to_c_str() }).is_err());\n     }\n \n     #[test]"}, {"sha": "e0dc5c8b65d694d9a5d238bd31e27df21b5aa6b0", "filename": "src/libstd/condition.rs", "status": "removed", "additions": 0, "deletions": 349, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "patch": "@@ -1,349 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Condition handling\n-\n-Conditions are a utility used to deal with handling error conditions. The syntax\n-of a condition handler strikes a resemblance to try/catch blocks in other\n-languages, but condition handlers are *not* a form of exception handling in the\n-same manner.\n-\n-A condition is declared through the `condition!` macro provided by the compiler:\n-\n-```rust\n-condition! {\n-    pub my_error: int -> ~str;\n-}\n-# fn main() {}\n-```\n-\n-This macro declares an inner module called `my_error` with one static variable,\n-`cond` that is a static `Condition` instance. To help understand what the other\n-parameters are used for, an example usage of this condition would be:\n-\n-```rust\n-# condition! { pub my_error: int -> ~str; }\n-# fn main() {\n-\n-my_error::cond.trap(|raised_int| {\n-\n-    // the condition `my_error` was raised on, and the value it raised is stored\n-    // in `raised_int`. This closure must return a `~str` type (as specified in\n-    // the declaration of the condition\n-    if raised_int == 3 { ~\"three\" } else { ~\"oh well\" }\n-\n-}).inside(|| {\n-\n-    // The condition handler above is installed for the duration of this block.\n-    // That handler will override any previous handler, but the previous handler\n-    // is restored when this block returns (handlers nest)\n-    //\n-    // If any code from this block (or code from another block) raises on the\n-    // condition, then the above handler will be invoked (so long as there's no\n-    // other nested handler).\n-\n-    println!(\"{}\", my_error::cond.raise(3)); // prints \"three\"\n-    println!(\"{}\", my_error::cond.raise(4)); // prints \"oh well\"\n-\n-})\n-\n-# }\n- ```\n-\n-Condition handling is useful in cases where propagating errors is either to\n-cumbersome or just not necessary in the first place. It should also be noted,\n-though, that if there is not handler installed when a condition is raised, then\n-the task invokes `fail!()` and will terminate.\n-\n-## More Info\n-\n-Condition handlers as an error strategy is well explained in the [conditions\n-tutorial](http://static.rust-lang.org/doc/master/tutorial-conditions.html),\n-along with comparing and contrasting it with other error handling strategies.\n-\n-*/\n-\n-use local_data;\n-use prelude::*;\n-use unstable::raw::Closure;\n-\n-#[doc(hidden)]\n-pub struct Handler<T, U> {\n-    priv handle: Closure,\n-    priv prev: Option<@Handler<T, U>>,\n-}\n-\n-/// This struct represents the state of a condition handler. It contains a key\n-/// into TLS which holds the currently install handler, along with the name of\n-/// the condition (useful for debugging).\n-///\n-/// This struct should never be created directly, but rather only through the\n-/// `condition!` macro provided to all libraries using `std`.\n-pub struct Condition<T, U> {\n-    /// Name of the condition handler\n-    name: &'static str,\n-    /// TLS key used to insert/remove values in TLS.\n-    key: local_data::Key<@Handler<T, U>>\n-}\n-\n-impl<T, U> Condition<T, U> {\n-    /// Creates an object which binds the specified handler. This will also save\n-    /// the current handler *on creation* such that when the `Trap` is consumed,\n-    /// it knows which handler to restore.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// condition! { my_error: int -> int; }\n-    ///\n-    /// # fn main() {\n-    /// let trap = my_error::cond.trap(|error| error + 3);\n-    ///\n-    /// // use `trap`'s inside method to register the handler and then run a\n-    /// // block of code with the handler registered\n-    /// # }\n-    /// ```\n-    pub fn trap<'a>(&'a self, h: 'a |T| -> U) -> Trap<'a, T, U> {\n-        let h: Closure = unsafe { ::cast::transmute(h) };\n-        let prev = local_data::get(self.key, |k| k.map(|x| *x));\n-        let h = @Handler { handle: h, prev: prev };\n-        Trap { cond: self, handler: h }\n-    }\n-\n-    /// Raises on this condition, invoking any handler if one has been\n-    /// registered, or failing the current task otherwise.\n-    ///\n-    /// While a condition handler is being run, the condition will have no\n-    /// handler listed, so a task failure will occur if the condition is\n-    /// re-raised during the handler.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * t - The argument to pass along to the condition handler.\n-    ///\n-    /// # Return value\n-    ///\n-    /// If a handler is found, its return value is returned, otherwise this\n-    /// function will not return.\n-    pub fn raise(&self, t: T) -> U {\n-        let msg = format!(\"Unhandled condition: {}: {:?}\", self.name, t);\n-        self.raise_default(t, || fail!(\"{}\", msg.clone()))\n-    }\n-\n-    /// Performs the same functionality as `raise`, except that when no handler\n-    /// is found the `default` argument is called instead of failing the task.\n-    pub fn raise_default(&self, t: T, default: || -> U) -> U {\n-        match local_data::pop(self.key) {\n-            None => {\n-                debug!(\"Condition.raise: found no handler\");\n-                default()\n-            }\n-            Some(handler) => {\n-                debug!(\"Condition.raise: found handler\");\n-                match handler.prev {\n-                    None => {}\n-                    Some(hp) => local_data::set(self.key, hp)\n-                }\n-                let handle : |T| -> U = unsafe {\n-                    ::cast::transmute(handler.handle)\n-                };\n-                let u = handle(t);\n-                local_data::set(self.key, handler);\n-                u\n-            }\n-        }\n-    }\n-}\n-\n-/// A `Trap` is created when the `trap` method is invoked on a `Condition`, and\n-/// it is used to actually bind a handler into the TLS slot reserved for this\n-/// condition.\n-///\n-/// Normally this object is not dealt with directly, but rather it's directly\n-/// used after being returned from `trap`\n-pub struct Trap<'a, T, U> {\n-    priv cond: &'a Condition<T, U>,\n-    priv handler: @Handler<T, U>\n-}\n-\n-impl<'a, T, U> Trap<'a, T, U> {\n-    /// Execute a block of code with this trap handler's exception handler\n-    /// registered.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// condition! { my_error: int -> int; }\n-    ///\n-    /// # fn main() {\n-    /// let result = my_error::cond.trap(|error| error + 3).inside(|| {\n-    ///     my_error::cond.raise(4)\n-    /// });\n-    /// assert_eq!(result, 7);\n-    /// # }\n-    /// ```\n-    pub fn inside<V>(&self, inner: 'a || -> V) -> V {\n-        let _g = Guard { cond: self.cond };\n-        debug!(\"Trap: pushing handler to TLS\");\n-        local_data::set(self.cond.key, self.handler);\n-        inner()\n-    }\n-\n-    /// Returns a guard that will automatically reset the condition upon\n-    /// exit of the scope. This is useful if you want to use conditions with\n-    /// an RAII pattern.\n-    pub fn guard(&self) -> Guard<'a,T,U> {\n-        let guard = Guard {\n-            cond: self.cond\n-        };\n-        debug!(\"Guard: pushing handler to TLS\");\n-        local_data::set(self.cond.key, self.handler);\n-        guard\n-    }\n-}\n-\n-/// A guard that will automatically reset the condition handler upon exit of\n-/// the scope. This is useful if you want to use conditions with an RAII\n-/// pattern.\n-pub struct Guard<'a, T, U> {\n-    priv cond: &'a Condition<T, U>\n-}\n-\n-#[unsafe_destructor]\n-impl<'a, T, U> Drop for Guard<'a, T, U> {\n-    fn drop(&mut self) {\n-        debug!(\"Guard: popping handler from TLS\");\n-        let curr = local_data::pop(self.cond.key);\n-        match curr {\n-            None => {}\n-            Some(h) => match h.prev {\n-                None => {}\n-                Some(hp) => local_data::set(self.cond.key, hp)\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    condition! {\n-        sadness: int -> int;\n-    }\n-\n-    fn trouble(i: int) {\n-        debug!(\"trouble: raising condition\");\n-        let j = sadness::cond.raise(i);\n-        debug!(\"trouble: handler recovered with {}\", j);\n-    }\n-\n-    fn nested_trap_test_inner() {\n-        let mut inner_trapped = false;\n-\n-        sadness::cond.trap(|_j| {\n-            debug!(\"nested_trap_test_inner: in handler\");\n-            inner_trapped = true;\n-            0\n-        }).inside(|| {\n-            debug!(\"nested_trap_test_inner: in protected block\");\n-            trouble(1);\n-        });\n-\n-        assert!(inner_trapped);\n-    }\n-\n-    #[test]\n-    fn nested_trap_test_outer() {\n-        let mut outer_trapped = false;\n-\n-        sadness::cond.trap(|_j| {\n-            debug!(\"nested_trap_test_outer: in handler\");\n-            outer_trapped = true; 0\n-        }).inside(|| {\n-            debug!(\"nested_guard_test_outer: in protected block\");\n-            nested_trap_test_inner();\n-            trouble(1);\n-        });\n-\n-        assert!(outer_trapped);\n-    }\n-\n-    fn nested_reraise_trap_test_inner() {\n-        let mut inner_trapped = false;\n-\n-        sadness::cond.trap(|_j| {\n-            debug!(\"nested_reraise_trap_test_inner: in handler\");\n-            inner_trapped = true;\n-            let i = 10;\n-            debug!(\"nested_reraise_trap_test_inner: handler re-raising\");\n-            sadness::cond.raise(i)\n-        }).inside(|| {\n-            debug!(\"nested_reraise_trap_test_inner: in protected block\");\n-            trouble(1);\n-        });\n-\n-        assert!(inner_trapped);\n-    }\n-\n-    #[test]\n-    fn nested_reraise_trap_test_outer() {\n-        let mut outer_trapped = false;\n-\n-        sadness::cond.trap(|_j| {\n-            debug!(\"nested_reraise_trap_test_outer: in handler\");\n-            outer_trapped = true; 0\n-        }).inside(|| {\n-            debug!(\"nested_reraise_trap_test_outer: in protected block\");\n-            nested_reraise_trap_test_inner();\n-        });\n-\n-        assert!(outer_trapped);\n-    }\n-\n-    #[test]\n-    fn test_default() {\n-        let mut trapped = false;\n-\n-        sadness::cond.trap(|j| {\n-            debug!(\"test_default: in handler\");\n-            sadness::cond.raise_default(j, || { trapped=true; 5 })\n-        }).inside(|| {\n-            debug!(\"test_default: in protected block\");\n-            trouble(1);\n-        });\n-\n-        assert!(trapped);\n-    }\n-\n-    // Issue #6009\n-    mod m {\n-        condition! {\n-            // #6009, #8215: should this truly need a `pub` for access from n?\n-            pub sadness: int -> int;\n-        }\n-\n-        mod n {\n-            use super::sadness;\n-\n-            #[test]\n-            fn test_conditions_are_public() {\n-                let mut trapped = false;\n-                sadness::cond.trap(|_| {\n-                    trapped = true;\n-                    0\n-                }).inside(|| {\n-                    sadness::cond.raise(0);\n-                });\n-                assert!(trapped);\n-            }\n-        }\n-    }\n-}"}, {"sha": "555fe29bed004d52262548cc5835a525c4122044", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -19,8 +19,6 @@ use prelude::*;\n use char;\n use str;\n \n-condition! { pub parse_error: ~str -> (); }\n-\n /// A piece is a portion of the format string which represents the next part to\n /// emit. These are emitted as a stream by the `Parser` class.\n #[deriving(Eq)]\n@@ -170,6 +168,8 @@ pub struct Parser<'a> {\n     priv input: &'a str,\n     priv cur: str::CharOffsets<'a>,\n     priv depth: uint,\n+    /// Error messages accumulated during parsing\n+    errors: ~[~str],\n }\n \n impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n@@ -207,14 +207,15 @@ impl<'a> Parser<'a> {\n             input: s,\n             cur: s.char_indices(),\n             depth: 0,\n+            errors: ~[],\n         }\n     }\n \n     /// Notifies of an error. The message doesn't actually need to be of type\n     /// ~str, but I think it does when this eventually uses conditions so it\n     /// might as well start using it now.\n-    fn err(&self, msg: &str) {\n-        parse_error::cond.raise(\"invalid format string: \" + msg);\n+    fn err(&mut self, msg: &str) {\n+        self.errors.push(msg.to_owned());\n     }\n \n     /// Optionally consumes the specified character. If the character is not at\n@@ -671,7 +672,9 @@ mod tests {\n     }\n \n     fn musterr(s: &str) {\n-        Parser::new(s).next();\n+        let mut p = Parser::new(s);\n+        p.next();\n+        assert!(p.errors.len() != 0);\n     }\n \n     #[test]\n@@ -684,12 +687,12 @@ mod tests {\n         same(\"\\\\}\", ~[String(\"}\")]);\n     }\n \n-    #[test] #[should_fail] fn invalid01() { musterr(\"{\") }\n-    #[test] #[should_fail] fn invalid02() { musterr(\"\\\\\") }\n-    #[test] #[should_fail] fn invalid03() { musterr(\"\\\\a\") }\n-    #[test] #[should_fail] fn invalid04() { musterr(\"{3a}\") }\n-    #[test] #[should_fail] fn invalid05() { musterr(\"{:|}\") }\n-    #[test] #[should_fail] fn invalid06() { musterr(\"{:>>>}\") }\n+    #[test] fn invalid01() { musterr(\"{\") }\n+    #[test] fn invalid02() { musterr(\"\\\\\") }\n+    #[test] fn invalid03() { musterr(\"\\\\a\") }\n+    #[test] fn invalid04() { musterr(\"{3a}\") }\n+    #[test] fn invalid05() { musterr(\"{:|}\") }\n+    #[test] fn invalid06() { musterr(\"{:>>>}\") }\n \n     #[test]\n     fn format_nothing() {\n@@ -916,36 +919,16 @@ mod tests {\n         })]);\n     }\n \n-    #[test] #[should_fail] fn badselect01() {\n-        musterr(\"{select, }\")\n-    }\n-    #[test] #[should_fail] fn badselect02() {\n-        musterr(\"{1, select}\")\n-    }\n-    #[test] #[should_fail] fn badselect03() {\n-        musterr(\"{1, select, }\")\n-    }\n-    #[test] #[should_fail] fn badselect04() {\n-        musterr(\"{1, select, a {}}\")\n-    }\n-    #[test] #[should_fail] fn badselect05() {\n-        musterr(\"{1, select, other }}\")\n-    }\n-    #[test] #[should_fail] fn badselect06() {\n-        musterr(\"{1, select, other {}\")\n-    }\n-    #[test] #[should_fail] fn badselect07() {\n-        musterr(\"{select, other {}\")\n-    }\n-    #[test] #[should_fail] fn badselect08() {\n-        musterr(\"{1 select, other {}\")\n-    }\n-    #[test] #[should_fail] fn badselect09() {\n-        musterr(\"{:d select, other {}\")\n-    }\n-    #[test] #[should_fail] fn badselect10() {\n-        musterr(\"{1:d select, other {}\")\n-    }\n+    #[test] fn badselect01() { musterr(\"{select, }\") }\n+    #[test] fn badselect02() { musterr(\"{1, select}\") }\n+    #[test] fn badselect03() { musterr(\"{1, select, }\") }\n+    #[test] fn badselect04() { musterr(\"{1, select, a {}}\") }\n+    #[test] fn badselect05() { musterr(\"{1, select, other }}\") }\n+    #[test] fn badselect06() { musterr(\"{1, select, other {}\") }\n+    #[test] fn badselect07() { musterr(\"{select, other {}\") }\n+    #[test] fn badselect08() { musterr(\"{1 select, other {}\") }\n+    #[test] fn badselect09() { musterr(\"{:d select, other {}\") }\n+    #[test] fn badselect10() { musterr(\"{1:d select, other {}\") }\n \n     #[test]\n     fn plural_simple() {"}, {"sha": "0398af9c1c1b4c8566f9ee451621cbb058d80125", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -178,8 +178,6 @@ pub mod run;\n pub mod cast;\n pub mod fmt;\n pub mod cleanup;\n-#[deprecated]\n-pub mod condition;\n pub mod logging;\n pub mod util;\n pub mod mem;\n@@ -216,7 +214,6 @@ mod std {\n     pub use clone;\n     pub use cmp;\n     pub use comm;\n-    pub use condition;\n     pub use fmt;\n     pub use io;\n     pub use kinds;"}, {"sha": "cd81d6037e64e5411f260e6dddcc218032fe4a7c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -123,50 +123,6 @@ macro_rules! unreachable (() => (\n     fail!(\"internal error: entered unreachable code\");\n ))\n \n-#[macro_export]\n-macro_rules! condition (\n-\n-    { pub $c:ident: $input:ty -> $out:ty; } => {\n-\n-        pub mod $c {\n-            #[allow(unused_imports)];\n-            #[allow(non_uppercase_statics)];\n-            #[allow(missing_doc)];\n-\n-            use super::*;\n-\n-            local_data_key!(key: @::std::condition::Handler<$input, $out>)\n-\n-            pub static cond :\n-                ::std::condition::Condition<$input,$out> =\n-                ::std::condition::Condition {\n-                    name: stringify!($c),\n-                    key: key\n-                };\n-        }\n-    };\n-\n-    { $c:ident: $input:ty -> $out:ty; } => {\n-\n-        mod $c {\n-            #[allow(unused_imports)];\n-            #[allow(non_uppercase_statics)];\n-            #[allow(dead_code)];\n-\n-            use super::*;\n-\n-            local_data_key!(key: @::std::condition::Handler<$input, $out>)\n-\n-            pub static cond :\n-                ::std::condition::Condition<$input,$out> =\n-                ::std::condition::Condition {\n-                    name: stringify!($c),\n-                    key: key\n-                };\n-        }\n-    }\n-)\n-\n #[macro_export]\n macro_rules! format(($($arg:tt)*) => (\n     format_args!(::std::fmt::format, $($arg)*)"}, {"sha": "f3f70c263ece924e8a572ac7084cbfb96ab6bd32", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 23, "deletions": 62, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -147,31 +147,20 @@ pub use is_sep_byte = self::windows::is_sep_byte;\n pub mod posix;\n pub mod windows;\n \n-// Condition that is raised when a NUL is found in a byte vector given to a Path function\n-condition! {\n-    // this should be a &[u8] but there's a lifetime issue\n-    null_byte: ~[u8] -> ~[u8];\n-}\n-\n /// A trait that represents the generic operations available on paths\n pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Creates a new Path from a byte vector or string.\n     /// The resulting Path will always be normalized.\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the path contains a NUL.\n+    /// Fails the task if the path contains a NUL.\n     ///\n     /// See individual Path impls for additional restrictions.\n     #[inline]\n     fn new<T: BytesContainer>(path: T) -> Self {\n-        if contains_nul(path.container_as_bytes()) {\n-            let path = self::null_byte::cond.raise(path.container_into_owned_bytes());\n-            assert!(!contains_nul(path));\n-            unsafe { GenericPathUnsafe::new_unchecked(path) }\n-        } else {\n-            unsafe { GenericPathUnsafe::new_unchecked(path) }\n-        }\n+        assert!(!contains_nul(path.container_as_bytes()));\n+        unsafe { GenericPathUnsafe::new_unchecked(path) }\n     }\n \n     /// Creates a new Path from a byte vector or string, if possible.\n@@ -283,16 +272,11 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the filename contains a NUL.\n+    /// Fails the task if the filename contains a NUL.\n     #[inline]\n     fn set_filename<T: BytesContainer>(&mut self, filename: T) {\n-        if contains_nul(filename.container_as_bytes()) {\n-            let filename = self::null_byte::cond.raise(filename.container_into_owned_bytes());\n-            assert!(!contains_nul(filename));\n-            unsafe { self.set_filename_unchecked(filename) }\n-        } else {\n-            unsafe { self.set_filename_unchecked(filename) }\n-        }\n+        assert!(!contains_nul(filename.container_as_bytes()));\n+        unsafe { self.set_filename_unchecked(filename) }\n     }\n     /// Replaces the extension with the given byte vector or string.\n     /// If there is no extension in `self`, this adds one.\n@@ -301,8 +285,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the extension contains a NUL.\n+    /// Fails the task if the extension contains a NUL.\n     fn set_extension<T: BytesContainer>(&mut self, extension: T) {\n+        assert!(!contains_nul(extension.container_as_bytes()));\n         // borrowck causes problems here too\n         let val = {\n             match self.filename() {\n@@ -315,21 +300,11 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                                 None\n                             } else {\n                                 let mut v;\n-                                if contains_nul(extension.container_as_bytes()) {\n-                                    let ext = extension.container_into_owned_bytes();\n-                                    let extension = self::null_byte::cond.raise(ext);\n-                                    assert!(!contains_nul(extension));\n-                                    v = vec::with_capacity(name.len() + extension.len() + 1);\n-                                    v.push_all(name);\n-                                    v.push(dot);\n-                                    v.push_all(extension);\n-                                } else {\n-                                    let extension = extension.container_as_bytes();\n-                                    v = vec::with_capacity(name.len() + extension.len() + 1);\n-                                    v.push_all(name);\n-                                    v.push(dot);\n-                                    v.push_all(extension);\n-                                }\n+                                let extension = extension.container_as_bytes();\n+                                v = vec::with_capacity(name.len() + extension.len() + 1);\n+                                v.push_all(name);\n+                                v.push(dot);\n+                                v.push_all(extension);\n                                 Some(v)\n                             }\n                         }\n@@ -338,19 +313,10 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                                 Some(name.slice_to(idx).to_owned())\n                             } else {\n                                 let mut v;\n-                                if contains_nul(extension.container_as_bytes()) {\n-                                    let ext = extension.container_into_owned_bytes();\n-                                    let extension = self::null_byte::cond.raise(ext);\n-                                    assert!(!contains_nul(extension));\n-                                    v = vec::with_capacity(idx + extension.len() + 1);\n-                                    v.push_all(name.slice_to(idx+1));\n-                                    v.push_all(extension);\n-                                } else {\n-                                    let extension = extension.container_as_bytes();\n-                                    v = vec::with_capacity(idx + extension.len() + 1);\n-                                    v.push_all(name.slice_to(idx+1));\n-                                    v.push_all(extension);\n-                                }\n+                                let extension = extension.container_as_bytes();\n+                                v = vec::with_capacity(idx + extension.len() + 1);\n+                                v.push_all(name.slice_to(idx+1));\n+                                v.push_all(extension);\n                                 Some(v)\n                             }\n                         }\n@@ -370,7 +336,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the filename contains a NUL.\n+    /// Fails the task if the filename contains a NUL.\n     #[inline]\n     fn with_filename<T: BytesContainer>(&self, filename: T) -> Self {\n         let mut p = self.clone();\n@@ -383,7 +349,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the extension contains a NUL.\n+    /// Fails the task if the extension contains a NUL.\n     #[inline]\n     fn with_extension<T: BytesContainer>(&self, extension: T) -> Self {\n         let mut p = self.clone();\n@@ -408,16 +374,11 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the path contains a NUL.\n+    /// Fails the task if the path contains a NUL.\n     #[inline]\n     fn push<T: BytesContainer>(&mut self, path: T) {\n-        if contains_nul(path.container_as_bytes()) {\n-            let path = self::null_byte::cond.raise(path.container_into_owned_bytes());\n-            assert!(!contains_nul(path));\n-            unsafe { self.push_unchecked(path) }\n-        } else {\n-            unsafe { self.push_unchecked(path) }\n-        }\n+        assert!(!contains_nul(path.container_as_bytes()));\n+        unsafe { self.push_unchecked(path) }\n     }\n     /// Pushes multiple paths (as byte vectors or strings) onto `self`.\n     /// See `push` for details.\n@@ -445,7 +406,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the path contains a NUL.\n+    /// Fails the task if the path contains a NUL.\n     #[inline]\n     fn join<T: BytesContainer>(&self, path: T) -> Self {\n         let mut p = self.clone();"}, {"sha": "6970ebfb15d7026d1011ed2ab31eb416eefc3daa", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 12, "deletions": 74, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -318,7 +318,7 @@ impl Path {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the vector contains a NUL.\n+    /// Fails the task if the vector contains a NUL.\n     #[inline]\n     pub fn new<T: BytesContainer>(path: T) -> Path {\n         GenericPath::new(path)\n@@ -527,83 +527,21 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use path::null_byte::cond;\n-\n-        let mut handled = false;\n-        let mut p = cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"foo/bar\", 0));\n-            (b!(\"/bar\").to_owned())\n-        }).inside(|| {\n+        use task;\n+        let result = task::try(proc() {\n             Path::new(b!(\"foo/bar\", 0))\n         });\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"/bar\"));\n-\n-        handled = false;\n-        cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n-            (b!(\"foo\").to_owned())\n-        }).inside(|| {\n-            p.set_filename(b!(\"f\", 0, \"o\"))\n-        });\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"/foo\"));\n-\n-        handled = false;\n-        cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n-            (b!(\"foo\").to_owned())\n-        }).inside(|| {\n-            p.push(b!(\"f\", 0, \"o\"));\n-        });\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"/foo/foo\"));\n-    }\n-\n-    #[test]\n-    fn test_null_byte_fail() {\n-        use path::null_byte::cond;\n-        use task;\n+        assert!(result.is_err());\n \n-        macro_rules! t(\n-            ($name:expr => $code:expr) => (\n-                {\n-                    let mut t = task::task();\n-                    t.name($name);\n-                    let res = t.try(proc() $code);\n-                    assert!(res.is_err());\n-                }\n-            )\n-        )\n+        let result = task::try(proc() {\n+            Path::new(\"test\").set_filename(b!(\"f\", 0, \"o\"))\n+        });\n+        assert!(result.is_err());\n \n-        t!(~\"new() w/nul\" => {\n-            cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside(|| {\n-                Path::new(b!(\"foo/bar\", 0))\n-            });\n-        })\n-\n-        t!(~\"set_filename w/nul\" => {\n-            let mut p = Path::new(b!(\"foo/bar\"));\n-            cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside(|| {\n-                p.set_filename(b!(\"foo\", 0))\n-            });\n-        })\n-\n-        t!(~\"push w/nul\" => {\n-            let mut p = Path::new(b!(\"foo/bar\"));\n-            cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside(|| {\n-                p.push(b!(\"foo\", 0))\n-            });\n-        })\n+        let result = task::try(proc() {\n+            Path::new(\"test\").push(b!(\"f\", 0, \"o\"));\n+        });\n+        assert!(result.is_err());\n     }\n \n     #[test]"}, {"sha": "90154adb7fef7650355c516f10025fd159c7b2be", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 13, "deletions": 75, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -590,7 +590,7 @@ impl Path {\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `null_byte` condition if the vector contains a NUL.\n+    /// Fails the task if the vector contains a NUL.\n     /// Fails if invalid UTF-8.\n     #[inline]\n     pub fn new<T: BytesContainer>(path: T) -> Path {\n@@ -1248,83 +1248,21 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use path::null_byte::cond;\n-\n-        let mut handled = false;\n-        let mut p = cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"foo\\\\bar\", 0));\n-            (b!(\"\\\\bar\").to_owned())\n-        }).inside(|| {\n-            Path::new(b!(\"foo\\\\bar\", 0))\n-        });\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"\\\\bar\"));\n-\n-        handled = false;\n-        cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n-            (b!(\"foo\").to_owned())\n-        }).inside(|| {\n-            p.set_filename(b!(\"f\", 0, \"o\"))\n-        });\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"\\\\foo\"));\n-\n-        handled = false;\n-        cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n-            (b!(\"foo\").to_owned())\n-        }).inside(|| {\n-            p.push(b!(\"f\", 0, \"o\"));\n-        });\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"\\\\foo\\\\foo\"));\n-    }\n-\n-    #[test]\n-    fn test_null_byte_fail() {\n-        use path::null_byte::cond;\n         use task;\n+        let result = task::try(proc() {\n+            Path::new(b!(\"foo/bar\", 0))\n+        });\n+        assert!(result.is_err());\n \n-        macro_rules! t(\n-            ($name:expr => $code:expr) => (\n-                {\n-                    let mut t = task::task();\n-                    t.name($name);\n-                    let res = t.try(proc() $code);\n-                    assert!(res.is_err());\n-                }\n-            )\n-        )\n-\n-        t!(~\"from_vec() w\\\\nul\" => {\n-            cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside(|| {\n-                Path::new(b!(\"foo\\\\bar\", 0))\n-            });\n-        })\n-\n-        t!(~\"set_filename w\\\\nul\" => {\n-            let mut p = Path::new(b!(\"foo\\\\bar\"));\n-            cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside(|| {\n-                p.set_filename(b!(\"foo\", 0))\n-            });\n-        })\n+        let result = task::try(proc() {\n+            Path::new(\"test\").set_filename(b!(\"f\", 0, \"o\"))\n+        });\n+        assert!(result.is_err());\n \n-        t!(~\"push w\\\\nul\" => {\n-            let mut p = Path::new(b!(\"foo\\\\bar\"));\n-            cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside(|| {\n-                p.push(b!(\"foo\", 0))\n-            });\n-        })\n+        let result = task::try(proc() {\n+            Path::new(\"test\").push(b!(\"f\", 0, \"o\"));\n+        });\n+        assert!(result.is_err());\n     }\n \n     #[test]"}, {"sha": "376d685c8ac3cb219fc4703628d4994acdde0763", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -44,7 +44,6 @@ Several modules in `core` are clients of `rt`:\n * `std::local_data` - The interface to local data.\n * `std::gc` - The garbage collector.\n * `std::unstable::lang` - Miscellaneous lang items, some of which rely on `std::rt`.\n-* `std::condition` - Uses local data.\n * `std::cleanup` - Local heap destruction.\n * `std::io` - In the future `std::io` will use an `rt` implementation.\n * `std::logging`"}, {"sha": "9d2a891bf6b97302692e4e352bd4c188b804a5af", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -786,22 +786,25 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n         None => return MacResult::dummy_expr()\n     };\n \n-    let mut err = false;\n-    parse::parse_error::cond.trap(|m| {\n-        if !err {\n-            err = true;\n-            cx.ecx.span_err(efmt.span, m);\n-        }\n-    }).inside(|| {\n-        for piece in parse::Parser::new(fmt.get()) {\n-            if !err {\n+    let mut parser = parse::Parser::new(fmt.get());\n+    loop {\n+        match parser.next() {\n+            Some(piece) => {\n+                if parser.errors.len() > 0 { break }\n                 cx.verify_piece(&piece);\n                 let piece = cx.trans_piece(&piece);\n                 cx.pieces.push(piece);\n             }\n+            None => break\n+        }\n+    }\n+    match parser.errors.shift() {\n+        Some(error) => {\n+            cx.ecx.span_err(efmt.span, \"invalid format string: \" + error);\n+            return MRExpr(efmt);\n         }\n-    });\n-    if err { return MRExpr(efmt) }\n+        None => {}\n+    }\n \n     // Make sure that all arguments were used and all arguments have types.\n     for (i, ty) in cx.arg_types.iter().enumerate() {"}, {"sha": "927602de1698903f429ef2330b07a15b96ab1f54", "filename": "src/test/auxiliary/xc_conditions.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Fauxiliary%2Fxc_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Fauxiliary%2Fxc_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxc_conditions.rs?ref=f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[crate_type=\"lib\"];\n-\n-condition! {\n-    pub oops: int -> int;\n-}\n-\n-pub fn trouble() -> int {\n-    oops::cond.raise(1)\n-}"}, {"sha": "16a5bb563434196c1ff4fdc8ba6f95930a5c6c77", "filename": "src/test/auxiliary/xc_conditions_2.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Fauxiliary%2Fxc_conditions_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Fauxiliary%2Fxc_conditions_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxc_conditions_2.rs?ref=f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[crate_type=\"lib\"];\n-\n-condition! {\n-    pub oops: int -> int;\n-}"}, {"sha": "afe9de7abb969f86d2cd9abaf47682ee3493e736", "filename": "src/test/auxiliary/xc_conditions_3.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Fauxiliary%2Fxc_conditions_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Fauxiliary%2Fxc_conditions_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxc_conditions_3.rs?ref=f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[crate_type=\"lib\"];\n-\n-condition! {\n-    pub oops: int -> int;\n-}\n-\n-pub fn guard(k: extern fn() -> int, x: int) -> int {\n-    oops::cond.trap(|i| i*x).inside(|| {\n-        k()\n-    })\n-}"}, {"sha": "569f22d364417282aa1ed5b22913d7d373b143a7", "filename": "src/test/auxiliary/xc_conditions_4.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Fauxiliary%2Fxc_conditions_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Fauxiliary%2Fxc_conditions_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxc_conditions_4.rs?ref=f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[crate_type=\"lib\"];\n-\n-#[deriving(Eq)]\n-pub enum Color {\n-    Red, Green, Blue\n-}\n-\n-condition! {\n-    pub oops: (int,f64,~str) -> Color;\n-}\n-\n-pub trait Thunk<T> {\n-    fn call(self) -> T;\n-}\n-\n-pub fn callback<T,TH:Thunk<T>>(t:TH) -> T {\n-    t.call()\n-}"}, {"sha": "b6cbae2d2afedbf7261fa1fd34ca08f4baae771b", "filename": "src/test/auxiliary/xcrate_static_addresses.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -24,9 +24,3 @@ pub fn verify_same2(a: &'static int) {\n     let b = global2 as *int as uint;\n     assert_eq!(a, b);\n }\n-\n-condition!{ pub test: int -> (); }\n-\n-pub fn raise() {\n-    test::cond.raise(3);\n-}"}, {"sha": "99df4b771c5ee5a24c9d9bf515648cd5f4eb2491", "filename": "src/test/run-pass/xc_conditions_client.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Frun-pass%2Fxc_conditions_client.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Frun-pass%2Fxc_conditions_client.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxc_conditions_client.rs?ref=f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "patch": "@@ -1,40 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-// aux-build:xc_conditions.rs\n-\n-extern mod xc_conditions;\n-use xc_conditions::oops;\n-use xc_conditions::trouble;\n-\n-// Tests of cross-crate conditions; the condition is\n-// defined in lib, and we test various combinations\n-// of `trap` and `raise` in the client or the lib where\n-// the condition was defined. Also in test #4 we use\n-// more complex features (generics, traits) in\n-// combination with the condition.\n-//\n-//                    trap   raise\n-//                    ------------\n-// xc_conditions  :   client   lib\n-// xc_conditions_2:   client   client\n-// xc_conditions_3:   lib      client\n-// xc_conditions_4:   client   client  (with traits)\n-//\n-// the trap=lib, raise=lib case isn't tested since\n-// there's no cross-crate-ness to test in that case.\n-\n-pub fn main() {\n-    oops::cond.trap(|_i| 12345).inside(|| {\n-        let x = trouble();\n-        assert_eq!(x,12345);\n-    })\n-}"}, {"sha": "b3164f1f0aa5daba0333bd0ee11832616cc3fd74", "filename": "src/test/run-pass/xc_conditions_client_2.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Frun-pass%2Fxc_conditions_client_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Frun-pass%2Fxc_conditions_client_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxc_conditions_client_2.rs?ref=f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-// aux-build:xc_conditions_2.rs\n-\n-extern mod xc_conditions_2;\n-use xcc = xc_conditions_2;\n-\n-pub fn main() {\n-    xcc::oops::cond.trap(|_| 1).inside(|| xcc::oops::cond.raise(1));\n-}"}, {"sha": "7d16572c139ce61725a77d268a0f7f28f52f727e", "filename": "src/test/run-pass/xc_conditions_client_3.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Frun-pass%2Fxc_conditions_client_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Frun-pass%2Fxc_conditions_client_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxc_conditions_client_3.rs?ref=f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-// aux-build:xc_conditions_3.rs\n-\n-extern mod xc_conditions_3;\n-use xcc = xc_conditions_3;\n-\n-pub fn main() {\n-    assert_eq!(xcc::guard(a, 1), 40);\n-}\n-\n-pub fn a() -> int {\n-    assert_eq!(xcc::oops::cond.raise(7), 7);\n-    xcc::guard(b, 2)\n-}\n-\n-pub fn b() -> int {\n-    assert_eq!(xcc::oops::cond.raise(8), 16);\n-    xcc::guard(c, 3)\n-}\n-\n-pub fn c() -> int {\n-    assert_eq!(xcc::oops::cond.raise(9), 27);\n-    xcc::guard(d, 4)\n-}\n-\n-pub fn d() -> int {\n-    xcc::oops::cond.raise(10)\n-}"}, {"sha": "e8eea00e4924947f862c6bfe3bf146cc5dc6c70c", "filename": "src/test/run-pass/xc_conditions_client_4.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Frun-pass%2Fxc_conditions_client_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a/src%2Ftest%2Frun-pass%2Fxc_conditions_client_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxc_conditions_client_4.rs?ref=f039d10cf73d8bc9a57fcdfe38c5f0b0a3a98b5a", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-// aux-build:xc_conditions_4.rs\n-\n-extern mod xc_conditions_4;\n-use xcc = xc_conditions_4;\n-\n-struct SThunk {\n-    x: int\n-}\n-\n-impl xcc::Thunk<xcc::Color> for SThunk {\n-    fn call(self) -> xcc::Color {\n-        xcc::oops::cond.raise((self.x, 1.23, ~\"oh no\"))\n-    }\n-}\n-\n-pub fn main() {\n-    xcc::oops::cond.trap(|_| xcc::Red).inside(|| {\n-        let t = SThunk { x : 10 };\n-        assert_eq!(xcc::callback(t), xcc::Red)\n-    })\n-}"}, {"sha": "8fdeba84fb78f0a18e49a9cfe025bfb6b49d8ee6", "filename": "src/test/run-pass/xcrate-static-addresses.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Ftest%2Frun-pass%2Fxcrate-static-addresses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454882dcb7fdb03867d695a88335e2d2c8f7561a/src%2Ftest%2Frun-pass%2Fxcrate-static-addresses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-static-addresses.rs?ref=454882dcb7fdb03867d695a88335e2d2c8f7561a", "patch": "@@ -18,11 +18,4 @@ use other = xcrate_static_addresses;\n pub fn main() {\n     other::verify_same(&other::global);\n     other::verify_same2(other::global2);\n-\n-    // Previously this fail'd because there were two addresses that were being\n-    // used when declaring constants.\n-    other::test::cond.trap(|_| {\n-    }).inside(|| {\n-        other::raise();\n-    })\n }"}]}