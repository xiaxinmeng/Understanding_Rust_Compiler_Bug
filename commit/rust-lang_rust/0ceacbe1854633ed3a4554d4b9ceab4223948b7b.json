{"sha": "0ceacbe1854633ed3a4554d4b9ceab4223948b7b", "node_id": "C_kwDOAAsO6NoAKDBjZWFjYmUxODU0NjMzZWQzYTQ1NTRkNGI5Y2VhYjQyMjM5NDhiN2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-03T07:05:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-03T07:05:51Z"}, "message": "Auto merge of #8730 - tamaroning:fix8724, r=Alexendoo\n\n[FP] identity_op in front of if\n\nfix #8724\n\nchangelog: FP: [`identity_op`]: is now allowed in front of if statements, blocks and other expressions where the suggestion would be invalid.\n\nResolved simular problems with blocks, mathces, and loops.\nidentity_op always does NOT suggest reducing `0 + if b { 1 } else { 2 } + 3` into  `if b { 1 } else { 2 } + 3` even in the case that the expression is in `f(expr)` or `let x = expr;` for now.", "tree": {"sha": "383bb9046e10100d530077623bfad684a2371848", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/383bb9046e10100d530077623bfad684a2371848"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ceacbe1854633ed3a4554d4b9ceab4223948b7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ceacbe1854633ed3a4554d4b9ceab4223948b7b", "html_url": "https://github.com/rust-lang/rust/commit/0ceacbe1854633ed3a4554d4b9ceab4223948b7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ceacbe1854633ed3a4554d4b9ceab4223948b7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95f8b2600240022f0a82e703b35d4bc14a42eb1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/95f8b2600240022f0a82e703b35d4bc14a42eb1b", "html_url": "https://github.com/rust-lang/rust/commit/95f8b2600240022f0a82e703b35d4bc14a42eb1b"}, {"sha": "6ad810f94eec6b49af026d44c70066284120612d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad810f94eec6b49af026d44c70066284120612d", "html_url": "https://github.com/rust-lang/rust/commit/6ad810f94eec6b49af026d44c70066284120612d"}], "stats": {"total": 204, "additions": 180, "deletions": 24}, "files": [{"sha": "40cc5cd4bcf9df4111d202591fde32e8fb4339e6", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0ceacbe1854633ed3a4554d4b9ceab4223948b7b/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ceacbe1854633ed3a4554d4b9ceab4223948b7b/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=0ceacbe1854633ed3a4554d4b9ceab4223948b7b", "patch": "@@ -1,3 +1,4 @@\n+use clippy_utils::get_parent_expr;\n use clippy_utils::source::snippet;\n use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -22,6 +23,11 @@ declare_clippy_lint! {\n     /// # let x = 1;\n     /// x / 1 + 0 * 1 - 0 | 0;\n     /// ```\n+    ///\n+    /// ### Known problems\n+    /// False negatives: `f(0 + if b { 1 } else { 2 } + 3);` is reducible to\n+    /// `f(if b { 1 } else { 2 } + 3);`. But the lint doesn't trigger for the code.\n+    /// See [#8724](https://github.com/rust-lang/rust-clippy/issues/8724)\n     #[clippy::version = \"pre 1.29.0\"]\n     pub IDENTITY_OP,\n     complexity,\n@@ -31,36 +37,66 @@ declare_clippy_lint! {\n declare_lint_pass!(IdentityOp => [IDENTITY_OP]);\n \n impl<'tcx> LateLintPass<'tcx> for IdentityOp {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if e.span.from_expansion() {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(cmp, left, right) = e.kind {\n-            if is_allowed(cx, cmp, left, right) {\n-                return;\n-            }\n-            match cmp.node {\n-                BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n-                    check(cx, left, 0, e.span, right.span);\n-                    check(cx, right, 0, e.span, left.span);\n-                },\n-                BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => check(cx, right, 0, e.span, left.span),\n-                BinOpKind::Mul => {\n-                    check(cx, left, 1, e.span, right.span);\n-                    check(cx, right, 1, e.span, left.span);\n-                },\n-                BinOpKind::Div => check(cx, right, 1, e.span, left.span),\n-                BinOpKind::BitAnd => {\n-                    check(cx, left, -1, e.span, right.span);\n-                    check(cx, right, -1, e.span, left.span);\n-                },\n-                BinOpKind::Rem => check_remainder(cx, left, right, e.span, left.span),\n-                _ => (),\n+        if let ExprKind::Binary(cmp, left, right) = &expr.kind {\n+            if !is_allowed(cx, *cmp, left, right) {\n+                match cmp.node {\n+                    BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n+                        if reducible_to_right(cx, expr, right) {\n+                            check(cx, left, 0, expr.span, right.span);\n+                        }\n+                        check(cx, right, 0, expr.span, left.span);\n+                    },\n+                    BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => {\n+                        check(cx, right, 0, expr.span, left.span);\n+                    },\n+                    BinOpKind::Mul => {\n+                        if reducible_to_right(cx, expr, right) {\n+                            check(cx, left, 1, expr.span, right.span);\n+                        }\n+                        check(cx, right, 1, expr.span, left.span);\n+                    },\n+                    BinOpKind::Div => check(cx, right, 1, expr.span, left.span),\n+                    BinOpKind::BitAnd => {\n+                        if reducible_to_right(cx, expr, right) {\n+                            check(cx, left, -1, expr.span, right.span);\n+                        }\n+                        check(cx, right, -1, expr.span, left.span);\n+                    },\n+                    BinOpKind::Rem => {\n+                        // Don't call reducible_to_right because N % N is always reducible to 1\n+                        check_remainder(cx, left, right, expr.span, left.span);\n+                    },\n+                    _ => (),\n+                }\n             }\n         }\n     }\n }\n \n+/// Checks if `left op ..right` can be actually reduced to `right`\n+/// e.g. `0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }`\n+/// cannot be reduced to `if b { 1 } else { 2 } +  if b { 3 } else { 4 }`\n+/// See #8724\n+fn reducible_to_right(cx: &LateContext<'_>, binary: &Expr<'_>, right: &Expr<'_>) -> bool {\n+    if let ExprKind::If(..) | ExprKind::Match(..) | ExprKind::Block(..) | ExprKind::Loop(..) = right.kind {\n+        is_toplevel_binary(cx, binary)\n+    } else {\n+        true\n+    }\n+}\n+\n+fn is_toplevel_binary(cx: &LateContext<'_>, must_be_binary: &Expr<'_>) -> bool {\n+    if let Some(parent) = get_parent_expr(cx, must_be_binary) && let ExprKind::Binary(..) = &parent.kind {\n+        false\n+    } else {\n+        true\n+    }\n+}\n+\n fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n     // This lint applies to integers\n     !cx.typeck_results().expr_ty(left).peel_refs().is_integral()"}, {"sha": "fec54d00ccb4b8869b90a7c4cdb55e510f8ff543", "filename": "tests/ui/identity_op.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0ceacbe1854633ed3a4554d4b9ceab4223948b7b/tests%2Fui%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ceacbe1854633ed3a4554d4b9ceab4223948b7b/tests%2Fui%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_op.rs?ref=0ceacbe1854633ed3a4554d4b9ceab4223948b7b", "patch": "@@ -77,4 +77,34 @@ fn main() {\n     (x + 1) % 3; // no error\n     4 % 3; // no error\n     4 % -3; // no error\n+\n+    // See #8724\n+    let a = 0;\n+    let b = true;\n+    0 + if b { 1 } else { 2 };\n+    0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }; // no error\n+    0 + match a { 0 => 10, _ => 20 };\n+    0 + match a { 0 => 10, _ => 20 } + match a { 0 => 30, _ => 40 }; // no error\n+    0 + if b { 1 } else { 2 } + match a { 0 => 30, _ => 40 }; // no error\n+    0 + match a { 0 => 10, _ => 20 } + if b { 3 } else { 4 }; // no error\n+    \n+    0 + if b { 0 + 1 } else { 2 };\n+    0 + match a { 0 =>  0 + 10, _ => 20 };\n+    0 + if b { 0 + 1 } else { 2 } + match a { 0 => 0 + 30, _ => 40 };\n+\n+    let _ = 0 + if 0 + 1 > 0 { 1 } else { 2 } + if 0 + 1 > 0 { 3 } else { 4 };\n+    let _ = 0 + match 0 + 1 { 0 => 10, _ => 20 } + match 0 + 1  { 0 => 30, _ => 40 };\n+\n+    0 + if b { 1 } else { 2 } + if b { 3 } else { 4 } + 0;\n+    \n+    0 + { a } + 3; // no error\n+    0 + loop { let mut c = 0; if c == 10 { break c; } c += 1; } + { a * 2 }; // no error\n+    \n+    fn f(_: i32) {\n+        todo!();\n+    }\n+    f(1 * a + { 8 * 5 });\n+    f(0 + if b { 1 } else { 2 } + 3); // no error\n+    const _: i32 = { 2 * 4 } + 0 + 3;\n+    const _: i32 = 0 + { 1 + 2 * 3 } + 3; // no error\n }"}, {"sha": "d8cb65839cbba5595b6c1cc422427ca30603983b", "filename": "tests/ui/identity_op.stderr", "status": "modified", "additions": 91, "deletions": 1, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0ceacbe1854633ed3a4554d4b9ceab4223948b7b/tests%2Fui%2Fidentity_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0ceacbe1854633ed3a4554d4b9ceab4223948b7b/tests%2Fui%2Fidentity_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_op.stderr?ref=0ceacbe1854633ed3a4554d4b9ceab4223948b7b", "patch": "@@ -108,5 +108,95 @@ error: the operation is ineffective. Consider reducing it to `1`\n LL |     x + 1 % 3;\n    |         ^^^^^\n \n-error: aborting due to 18 previous errors\n+error: the operation is ineffective. Consider reducing it to `if b { 1 } else { 2 }`\n+  --> $DIR/identity_op.rs:84:5\n+   |\n+LL |     0 + if b { 1 } else { 2 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `match a { 0 => 10, _ => 20 }`\n+  --> $DIR/identity_op.rs:86:5\n+   |\n+LL |     0 + match a { 0 => 10, _ => 20 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `if b { 0 + 1 } else { 2 }`\n+  --> $DIR/identity_op.rs:91:5\n+   |\n+LL |     0 + if b { 0 + 1 } else { 2 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:91:16\n+   |\n+LL |     0 + if b { 0 + 1 } else { 2 };\n+   |                ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `match a { 0 =>  0 + 10, _ => 20 }`\n+  --> $DIR/identity_op.rs:92:5\n+   |\n+LL |     0 + match a { 0 =>  0 + 10, _ => 20 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `10`\n+  --> $DIR/identity_op.rs:92:25\n+   |\n+LL |     0 + match a { 0 =>  0 + 10, _ => 20 };\n+   |                         ^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:93:16\n+   |\n+LL |     0 + if b { 0 + 1 } else { 2 } + match a { 0 => 0 + 30, _ => 40 };\n+   |                ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `30`\n+  --> $DIR/identity_op.rs:93:52\n+   |\n+LL |     0 + if b { 0 + 1 } else { 2 } + match a { 0 => 0 + 30, _ => 40 };\n+   |                                                    ^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:95:20\n+   |\n+LL |     let _ = 0 + if 0 + 1 > 0 { 1 } else { 2 } + if 0 + 1 > 0 { 3 } else { 4 };\n+   |                    ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:95:52\n+   |\n+LL |     let _ = 0 + if 0 + 1 > 0 { 1 } else { 2 } + if 0 + 1 > 0 { 3 } else { 4 };\n+   |                                                    ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:96:23\n+   |\n+LL |     let _ = 0 + match 0 + 1 { 0 => 10, _ => 20 } + match 0 + 1  { 0 => 30, _ => 40 };\n+   |                       ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:96:58\n+   |\n+LL |     let _ = 0 + match 0 + 1 { 0 => 10, _ => 20 } + match 0 + 1  { 0 => 30, _ => 40 };\n+   |                                                          ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }`\n+  --> $DIR/identity_op.rs:98:5\n+   |\n+LL |     0 + if b { 1 } else { 2 } + if b { 3 } else { 4 } + 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `a`\n+  --> $DIR/identity_op.rs:106:7\n+   |\n+LL |     f(1 * a + { 8 * 5 });\n+   |       ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `{ 2 * 4 }`\n+  --> $DIR/identity_op.rs:108:20\n+   |\n+LL |     const _: i32 = { 2 * 4 } + 0 + 3;\n+   |                    ^^^^^^^^^^^^^\n+\n+error: aborting due to 33 previous errors\n "}]}