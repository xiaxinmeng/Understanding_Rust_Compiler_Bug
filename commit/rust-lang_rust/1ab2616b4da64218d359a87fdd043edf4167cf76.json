{"sha": "1ab2616b4da64218d359a87fdd043edf4167cf76", "node_id": "C_kwDOAAsO6NoAKDFhYjI2MTZiNGRhNjQyMThkMzU5YTg3ZmRkMDQzZWRmNDE2N2NmNzY", "commit": {"author": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2021-10-29T12:08:30Z"}, "committer": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2021-10-29T12:08:30Z"}, "message": "Add feature trigger and correct `is_struct` check", "tree": {"sha": "d0233fe9d87bd86ca10ff3891cc91b6156f4e22f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0233fe9d87bd86ca10ff3891cc91b6156f4e22f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ab2616b4da64218d359a87fdd043edf4167cf76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ab2616b4da64218d359a87fdd043edf4167cf76", "html_url": "https://github.com/rust-lang/rust/commit/1ab2616b4da64218d359a87fdd043edf4167cf76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ab2616b4da64218d359a87fdd043edf4167cf76/comments", "author": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3679bc23e0ae5998d5f0141a51b3d084fd66eab", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3679bc23e0ae5998d5f0141a51b3d084fd66eab", "html_url": "https://github.com/rust-lang/rust/commit/f3679bc23e0ae5998d5f0141a51b3d084fd66eab"}], "stats": {"total": 210, "additions": 129, "deletions": 81}, "files": [{"sha": "1d4a43c07b1e6b37857636d54d7c1c1c28da3bfb", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 112, "deletions": 65, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/1ab2616b4da64218d359a87fdd043edf4167cf76/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab2616b4da64218d359a87fdd043edf4167cf76/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=1ab2616b4da64218d359a87fdd043edf4167cf76", "patch": "@@ -36,11 +36,12 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::InferOk;\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n-use rustc_middle::ty::error::TypeError::{FieldMisMatch, Mismatch};\n+use rustc_middle::ty::error::TypeError::FieldMisMatch;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n+use rustc_session::parse::feature_err;\n use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n@@ -1374,78 +1375,124 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(base_expr) = base_expr {\n-            // FIXME: We are currently creating two branches here in order to maintain\n-            // consistency. But they should be merged as much as possible.\n-            let fru_tys = if self.tcx.features().type_changing_struct_update {\n-                let base_ty = self.check_expr(base_expr);\n-                match (adt_ty.kind(), base_ty.kind()) {\n-                    (ty::Adt(adt, substs), ty::Adt(base_adt, base_subs)) if adt == base_adt => {\n-                        if !adt.is_struct() {\n-                            self.tcx.sess.emit_err(FunctionalRecordUpdateOnNonStruct {\n-                                span: base_expr.span,\n-                            });\n-                        };\n+            let expected = if self.tcx.features().type_changing_struct_update {\n+                NoExpectation\n+            } else {\n+                ExpectHasType(adt_ty)\n+            };\n+            let mut ty = self.check_expr_with_expectation(base_expr, expected);\n+\n+            let expected_ty = expected.to_option(&self).unwrap_or(adt_ty);\n+            // While we don't allow *arbitrary* coercions here, we *do* allow\n+            // coercions from ! to `expected`.\n+            if ty.is_never() {\n+                assert!(\n+                    !self.typeck_results.borrow().adjustments().contains_key(base_expr.hir_id),\n+                    \"expression with never type wound up being adjusted\"\n+                );\n+                let adj_ty = self.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::AdjustmentType,\n+                    span: base_expr.span,\n+                });\n+                self.apply_adjustments(\n+                    base_expr,\n+                    vec![Adjustment { kind: Adjust::NeverToAny, target: adj_ty }],\n+                );\n+                ty = adj_ty;\n+            }\n+            let cause = self.misc(base_expr.span);\n+            let mut fru_tys = None;\n+            let mut err = None;\n+            let is_struct;\n+\n+            if let ty::Adt(adt, substs) = expected_ty.kind() {\n+                match ty.kind() {\n+                    ty::Adt(base_adt, base_subs) if adt == base_adt => {\n+                        if self.tcx.features().type_changing_struct_update {\n+                            let tys = variant\n+                                .fields\n+                                .iter()\n+                                .map(|f| {\n+                                    let fru_ty = self.normalize_associated_types_in(\n+                                        expr_span,\n+                                        self.field_ty(base_expr.span, f, base_subs),\n+                                    );\n+                                    let ident = self.tcx.adjust_ident(f.ident, variant.def_id);\n+                                    if let Some(_) = remaining_fields.remove(&ident) {\n+                                        let target_ty = self.field_ty(base_expr.span, f, substs);\n+                                        match self.at(&cause, self.param_env).sup(target_ty, fru_ty)\n+                                        {\n+                                            Ok(InferOk { obligations, value: () }) => {\n+                                                self.register_predicates(obligations)\n+                                            }\n+                                            // FIXME: Need better diagnostics for `FieldMisMatch` error\n+                                            Err(_) => {\n+                                                if err.is_none() {\n+                                                    err = Some(self.report_mismatched_types(\n+                                                        &cause,\n+                                                        target_ty,\n+                                                        fru_ty,\n+                                                        FieldMisMatch(\n+                                                            variant.ident.name,\n+                                                            ident.name,\n+                                                        ),\n+                                                    ))\n+                                                }\n+                                            }\n+                                        }\n+                                    }\n+                                    fru_ty\n+                                })\n+                                .collect();\n+                            fru_tys = Some(tys);\n+                        } else {\n+                            err = self.demand_suptype_diag(base_expr.span, expected_ty, ty);\n+                            if err.is_some() && self.tcx.sess.is_nightly_build() {\n+                                feature_err(\n+                                    &self.tcx.sess.parse_sess,\n+                                    sym::type_changing_struct_update,\n+                                    base_expr.span,\n+                                    \"type changing struct updating is experimental\",\n+                                )\n+                                .emit();\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        err = self.demand_suptype_diag(base_expr.span, expected_ty, ty);\n+                    }\n+                }\n+                is_struct = adt.is_struct();\n+                if is_struct && fru_tys.is_none() {\n+                    fru_tys = Some(\n                         variant\n                             .fields\n                             .iter()\n                             .map(|f| {\n-                                let fru_ty = self.normalize_associated_types_in(\n+                                self.normalize_associated_types_in(\n                                     expr_span,\n-                                    self.field_ty(base_expr.span, f, base_subs),\n-                                );\n-                                let ident = self.tcx.adjust_ident(f.ident, variant.def_id);\n-                                if let Some(_) = remaining_fields.remove(&ident) {\n-                                    let target_ty = self.field_ty(base_expr.span, f, substs);\n-                                    let cause = self.misc(base_expr.span);\n-                                    match self.at(&cause, self.param_env).sup(target_ty, fru_ty) {\n-                                        Ok(InferOk { obligations, value: () }) => {\n-                                            self.register_predicates(obligations)\n-                                        }\n-                                        // FIXME: Need better diagnostics for `FieldMisMatch` error\n-                                        Err(_) => self\n-                                            .report_mismatched_types(\n-                                                &cause,\n-                                                target_ty,\n-                                                fru_ty,\n-                                                FieldMisMatch(variant.ident.name, ident.name),\n-                                            )\n-                                            .emit(),\n-                                    }\n-                                }\n-                                fru_ty\n+                                    f.ty(self.tcx, substs),\n+                                )\n                             })\n-                            .collect()\n-                    }\n-                    _ => {\n-                        return self\n-                            .report_mismatched_types(\n-                                &self.misc(base_expr.span),\n-                                adt_ty,\n-                                base_ty,\n-                                Mismatch,\n-                            )\n-                            .emit();\n-                    }\n+                            .collect(),\n+                    )\n                 }\n             } else {\n-                self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {});\n-                match adt_ty.kind() {\n-                    ty::Adt(adt, substs) if adt.is_struct() => variant\n-                        .fields\n-                        .iter()\n-                        .map(|f| {\n-                            self.normalize_associated_types_in(expr_span, f.ty(self.tcx, substs))\n-                        })\n-                        .collect(),\n-                    _ => {\n-                        return self\n-                            .tcx\n-                            .sess\n-                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n-                    }\n-                }\n-            };\n-            self.typeck_results.borrow_mut().fru_field_types_mut().insert(expr_id, fru_tys);\n+                err = self.demand_suptype_diag(base_expr.span, expected_ty, ty);\n+                is_struct = false;\n+            }\n+            if let Some(mut err) = err {\n+                let expr = base_expr.peel_drop_temps();\n+                self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty, None);\n+                err.emit();\n+            }\n+            if let Some(fru_tys) = fru_tys {\n+                self.typeck_results.borrow_mut().fru_field_types_mut().insert(expr_id, fru_tys);\n+            }\n+            if !is_struct {\n+                let e = FunctionalRecordUpdateOnNonStruct { span: base_expr.span };\n+                self.tcx.sess.emit_err(e);\n+            }\n         } else if kind_name != \"union\" && !remaining_fields.is_empty() {\n             let inaccessible_remaining_fields = remaining_fields.iter().any(|(_, (_, field))| {\n                 !field.vis.is_accessible_from(tcx.parent_module(expr_id).to_def_id(), tcx)"}, {"sha": "1e8b99ba5647a1bcedbed27fc508a0ed0f17d64f", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/feature-gate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ab2616b4da64218d359a87fdd043edf4167cf76/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab2616b4da64218d359a87fdd043edf4167cf76/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.rs?ref=1ab2616b4da64218d359a87fdd043edf4167cf76", "patch": "@@ -17,10 +17,11 @@ fn update_to_state2() {\n         common_field1: \"hello\",\n         common_field2: 2,\n     };\n-    // FIXME: this should trigger feature gate\n     let m2: Machine<State2> = Machine {\n         state: State2,\n-        ..m1 //~ ERROR mismatched types\n+        ..m1\n+        //~^ ERROR type changing struct updating is experimental [E0658]\n+        //~| ERROR mismatched types [E0308]\n     };\n     assert_eq!(State2, m2.state);\n }"}, {"sha": "2217b8c049863e1c00389f75911005aca059e461", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/feature-gate.stderr", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ab2616b4da64218d359a87fdd043edf4167cf76/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ab2616b4da64218d359a87fdd043edf4167cf76/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.stderr?ref=1ab2616b4da64218d359a87fdd043edf4167cf76", "patch": "@@ -1,12 +1,22 @@\n+error[E0658]: type changing struct updating is experimental\n+  --> $DIR/feature-gate.rs:22:11\n+   |\n+LL |         ..m1\n+   |           ^^\n+   |\n+   = note: see issue #86555 <https://github.com/rust-lang/rust/issues/86555> for more information\n+   = help: add `#![feature(type_changing_struct_update)]` to the crate attributes to enable\n+\n error[E0308]: mismatched types\n-  --> $DIR/feature-gate.rs:23:11\n+  --> $DIR/feature-gate.rs:22:11\n    |\n LL |         ..m1\n    |           ^^ expected struct `State2`, found struct `State1`\n    |\n    = note: expected struct `Machine<State2>`\n               found struct `Machine<State1>`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0308, E0658.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "dae1241d35a5fc12f6aff1ba378b190b3be26eb2", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/type-generic-update.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ab2616b4da64218d359a87fdd043edf4167cf76/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab2616b4da64218d359a87fdd043edf4167cf76/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs?ref=1ab2616b4da64218d359a87fdd043edf4167cf76", "patch": "@@ -50,7 +50,6 @@ fn fail_update() {\n     let m3 = Machine::<i32, i32> {\n         ..m1\n         //~^ ERROR mismatched types [E0308]\n-        //~| ERROR mismatched types [E0308]\n     };\n }\n "}, {"sha": "631c8f83c91e75e33b26fddb3d06d54d51ff9e12", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/type-generic-update.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1ab2616b4da64218d359a87fdd043edf4167cf76/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ab2616b4da64218d359a87fdd043edf4167cf76/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr?ref=1ab2616b4da64218d359a87fdd043edf4167cf76", "patch": "@@ -16,15 +16,6 @@ LL |         ..m1\n    = note: expected type `i32`\n               found type `f64`\n \n-error[E0308]: mismatched types\n-  --> $DIR/type-generic-update.rs:51:11\n-   |\n-LL |         ..m1\n-   |           ^^ field type mismatch: Machine.message\n-   |\n-   = note: expected type `i32`\n-              found type `f64`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}