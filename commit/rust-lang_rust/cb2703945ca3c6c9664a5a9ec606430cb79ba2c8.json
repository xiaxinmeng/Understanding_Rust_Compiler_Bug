{"sha": "cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMjcwMzk0NWNhM2M2Yzk2NjRhNWE5ZWM2MDY0MzBjYjc5YmEyYzg=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-04-19T11:34:00Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-04-26T15:27:13Z"}, "message": "Use min_specialization in liballoc\n\n- Remove a type parameter from `[A]RcFromIter`.\n- Remove an implementation of `[A]RcFromIter` that didn't actually\n  specialize anything.\n- Remove unused implementation of `IsZero` for `Option<&mut T>`.\n- Change specializations of `[A]RcEqIdent` to use a marker trait version\nof `Eq`.\n- Remove `BTreeClone`. I couldn't find a way to make this work with\n  `min_specialization`.\n- Add `rustc_unsafe_specialization_marker` to `Copy` and `TrustedLen`.", "tree": {"sha": "f3779f0c94126d9d406a0e59e8d7eb0d9ef0b763", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3779f0c94126d9d406a0e59e8d7eb0d9ef0b763"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "html_url": "https://github.com/rust-lang/rust/commit/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec1f28f9614292c36b371d3758afffdd52cb9786", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1f28f9614292c36b371d3758afffdd52cb9786", "html_url": "https://github.com/rust-lang/rust/commit/ec1f28f9614292c36b371d3758afffdd52cb9786"}], "stats": {"total": 171, "additions": 51, "deletions": 120}, "files": [{"sha": "61d2295ba8c1c408cd15b9514b3565de6d8c5100", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "patch": "@@ -215,59 +215,6 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             clone_subtree(self.root.as_ref().unwrap().as_ref())\n         }\n     }\n-\n-    fn clone_from(&mut self, other: &Self) {\n-        BTreeClone::clone_from(self, other);\n-    }\n-}\n-\n-trait BTreeClone {\n-    fn clone_from(&mut self, other: &Self);\n-}\n-\n-impl<K: Clone, V: Clone> BTreeClone for BTreeMap<K, V> {\n-    default fn clone_from(&mut self, other: &Self) {\n-        *self = other.clone();\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n-    fn clone_from(&mut self, other: &Self) {\n-        // This truncates `self` to `other.len()` by calling `split_off` on\n-        // the first key after `other.len()` elements if it exists.\n-        let split_off_key = if self.len() > other.len() {\n-            let diff = self.len() - other.len();\n-            if diff <= other.len() {\n-                self.iter().nth_back(diff - 1).map(|pair| (*pair.0).clone())\n-            } else {\n-                self.iter().nth(other.len()).map(|pair| (*pair.0).clone())\n-            }\n-        } else {\n-            None\n-        };\n-        if let Some(key) = split_off_key {\n-            self.split_off(&key);\n-        }\n-\n-        let mut siter = self.range_mut(..);\n-        let mut oiter = other.iter();\n-        // After truncation, `self` is at most as long as `other` so this loop\n-        // replaces every key-value pair in `self`. Since `oiter` is in sorted\n-        // order and the structure of the `BTreeMap` stays the same,\n-        // the BTree invariants are maintained at the end of the loop.\n-        while !siter.is_empty() {\n-            if let Some((ok, ov)) = oiter.next() {\n-                // SAFETY: This is safe because `siter` is nonempty.\n-                let (sk, sv) = unsafe { siter.next_unchecked() };\n-                sk.clone_from(ok);\n-                sv.clone_from(ov);\n-            } else {\n-                break;\n-            }\n-        }\n-        // If `other` is longer than `self`, the remaining elements are inserted.\n-        self.extend(oiter.map(|(k, v)| ((*k).clone(), (*v).clone())));\n-    }\n }\n \n impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>"}, {"sha": "3ebb5662350a7d9c5845ac2c8a9c6c57e131ec6a", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "patch": "@@ -108,7 +108,7 @@\n #![feature(ptr_offset_from)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n-#![feature(specialization)]\n+#![feature(min_specialization)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(str_internals)]"}, {"sha": "307f6714f323061c997a86ec7d55af325f42fcee", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "patch": "@@ -249,7 +249,7 @@ use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::{self, from_raw_parts_mut};\n+use core::slice::from_raw_parts_mut;\n \n use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n use crate::string::String;\n@@ -1221,6 +1221,12 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n     }\n }\n \n+// Hack to allow specializing on `Eq` even though `Eq` has a method.\n+#[rustc_unsafe_specialization_marker]\n+pub(crate) trait MarkerEq: PartialEq<Self> {}\n+\n+impl<T: Eq> MarkerEq for T {}\n+\n /// We're doing this specialization here, and not as a more general optimization on `&T`, because it\n /// would otherwise add a cost to all equality checks on refs. We assume that `Rc`s are used to\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n@@ -1229,7 +1235,7 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n ///\n /// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n+impl<T: ?Sized + MarkerEq> RcEqIdent<T> for Rc<T> {\n     #[inline]\n     fn eq(&self, other: &Rc<T>) -> bool {\n         Rc::ptr_eq(self, other) || **self == **other\n@@ -1548,25 +1554,25 @@ impl<T> iter::FromIterator<T> for Rc<[T]> {\n     /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n     /// ```\n     fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n-        RcFromIter::from_iter(iter.into_iter())\n+        ToRcSlice::to_rc_slice(iter.into_iter())\n     }\n }\n \n /// Specialization trait used for collecting into `Rc<[T]>`.\n-trait RcFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n+trait ToRcSlice<T>: Iterator<Item = T> + Sized {\n+    fn to_rc_slice(self) -> Rc<[T]>;\n }\n \n-impl<T, I: Iterator<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n-        iter.collect::<Vec<T>>().into()\n+impl<T, I: Iterator<Item = T>> ToRcSlice<T> for I {\n+    default fn to_rc_slice(self) -> Rc<[T]> {\n+        self.collect::<Vec<T>>().into()\n     }\n }\n \n-impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n+impl<T, I: iter::TrustedLen<Item = T>> ToRcSlice<T> for I {\n+    fn to_rc_slice(self) -> Rc<[T]> {\n         // This is the case for a `TrustedLen` iterator.\n-        let (low, high) = iter.size_hint();\n+        let (low, high) = self.size_hint();\n         if let Some(high) = high {\n             debug_assert_eq!(\n                 low,\n@@ -1577,29 +1583,15 @@ impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n \n             unsafe {\n                 // SAFETY: We need to ensure that the iterator has an exact length and we have.\n-                Rc::from_iter_exact(iter, low)\n+                Rc::from_iter_exact(self, low)\n             }\n         } else {\n             // Fall back to normal implementation.\n-            iter.collect::<Vec<T>>().into()\n+            self.collect::<Vec<T>>().into()\n         }\n     }\n }\n \n-impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n-    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n-        // Delegate to `impl<T: Clone> From<&[T]> for Rc<[T]>`.\n-        //\n-        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n-        // which is even more performant.\n-        //\n-        // In the fall-back case we have `T: Clone`. This is still better\n-        // than the `TrustedLen` implementation as slices have a known length\n-        // and so we get to avoid calling `size_hint` and avoid the branching.\n-        iter.as_slice().into()\n-    }\n-}\n-\n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n /// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`."}, {"sha": "2b71378619c05fe0c23766b0a70e353bb226aa44", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "patch": "@@ -20,7 +20,7 @@ use core::mem::{self, align_of, align_of_val, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::{self, from_raw_parts_mut};\n+use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n@@ -1779,7 +1779,7 @@ impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n ///\n /// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n+impl<T: ?Sized + crate::rc::MarkerEq> ArcEqIdent<T> for Arc<T> {\n     #[inline]\n     fn eq(&self, other: &Arc<T>) -> bool {\n         Arc::ptr_eq(self, other) || **self == **other\n@@ -2105,25 +2105,25 @@ impl<T> iter::FromIterator<T> for Arc<[T]> {\n     /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n     /// ```\n     fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n-        ArcFromIter::from_iter(iter.into_iter())\n+        ToArcSlice::to_arc_slice(iter.into_iter())\n     }\n }\n \n /// Specialization trait used for collecting into `Arc<[T]>`.\n-trait ArcFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n+trait ToArcSlice<T>: Iterator<Item = T> + Sized {\n+    fn to_arc_slice(self) -> Arc<[T]>;\n }\n \n-impl<T, I: Iterator<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n-        iter.collect::<Vec<T>>().into()\n+impl<T, I: Iterator<Item = T>> ToArcSlice<T> for I {\n+    default fn to_arc_slice(self) -> Arc<[T]> {\n+        self.collect::<Vec<T>>().into()\n     }\n }\n \n-impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n+impl<T, I: iter::TrustedLen<Item = T>> ToArcSlice<T> for I {\n+    fn to_arc_slice(self) -> Arc<[T]> {\n         // This is the case for a `TrustedLen` iterator.\n-        let (low, high) = iter.size_hint();\n+        let (low, high) = self.size_hint();\n         if let Some(high) = high {\n             debug_assert_eq!(\n                 low,\n@@ -2134,29 +2134,15 @@ impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n \n             unsafe {\n                 // SAFETY: We need to ensure that the iterator has an exact length and we have.\n-                Arc::from_iter_exact(iter, low)\n+                Arc::from_iter_exact(self, low)\n             }\n         } else {\n             // Fall back to normal implementation.\n-            iter.collect::<Vec<T>>().into()\n+            self.collect::<Vec<T>>().into()\n         }\n     }\n }\n \n-impl<'a, T: 'a + Clone> ArcFromIter<&'a T, slice::Iter<'a, T>> for Arc<[T]> {\n-    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n-        // Delegate to `impl<T: Clone> From<&[T]> for Arc<[T]>`.\n-        //\n-        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n-        // which is even more performant.\n-        //\n-        // In the fall-back case we have `T: Clone`. This is still better\n-        // than the `TrustedLen` implementation as slices have a known length\n-        // and so we get to avoid calling `size_hint` and avoid the branching.\n-        iter.as_slice().into()\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n     fn borrow(&self) -> &T {"}, {"sha": "624ca2820d7586bd3259a37b271e43f8ef13a7cc", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "patch": "@@ -1619,8 +1619,8 @@ impl<T: Default> Vec<T> {\n     #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n     #[rustc_deprecated(\n         reason = \"This is moving towards being removed in favor \\\n-        of `.resize_with(Default::default)`.  If you disagree, please comment \\\n-        in the tracking issue.\",\n+                  of `.resize_with(Default::default)`.  If you disagree, please comment \\\n+                  in the tracking issue.\",\n         since = \"1.33.0\"\n     )]\n     pub fn resize_default(&mut self, new_len: usize) {\n@@ -1825,6 +1825,7 @@ impl<T: Clone + IsZero> SpecFromElem for T {\n     }\n }\n \n+#[rustc_specialization_trait]\n unsafe trait IsZero {\n     /// Whether this value is zero\n     fn is_zero(&self) -> bool;\n@@ -1874,9 +1875,12 @@ unsafe impl<T> IsZero for *mut T {\n     }\n }\n \n-// `Option<&T>`, `Option<&mut T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n-// For fat pointers, the bytes that would be the pointer metadata in the `Some` variant\n-// are padding in the `None` variant, so ignoring them and zero-initializing instead is ok.\n+// `Option<&T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n+// For fat pointers, the bytes that would be the pointer metadata in the `Some`\n+// variant are padding in the `None` variant, so ignoring them and\n+// zero-initializing instead is ok.\n+// `Option<&mut T>` never implements `Clone`, so there's no need for an impl of\n+// `SpecFromElem`.\n \n unsafe impl<T: ?Sized> IsZero for Option<&T> {\n     #[inline]\n@@ -1885,13 +1889,6 @@ unsafe impl<T: ?Sized> IsZero for Option<&T> {\n     }\n }\n \n-unsafe impl<T: ?Sized> IsZero for Option<&mut T> {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        self.is_none()\n-    }\n-}\n-\n unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n     #[inline]\n     fn is_zero(&self) -> bool {"}, {"sha": "a9ba3908c38982a1e4014e0bf6efb09e4c068456", "filename": "src/libcore/iter/traits/marker.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs?ref=cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "patch": "@@ -13,6 +13,7 @@\n /// [`Iterator::fuse`]: ../../std/iter/trait.Iterator.html#method.fuse\n /// [`Fuse`]: ../../std/iter/struct.Fuse.html\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n+#[rustc_unsafe_specialization_marker]\n pub trait FusedIterator: Iterator {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -38,6 +39,7 @@ impl<I: FusedIterator + ?Sized> FusedIterator for &mut I {}\n /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n /// [`.size_hint`]: ../../std/iter/trait.Iterator.html#method.size_hint\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+#[rustc_unsafe_specialization_marker]\n pub unsafe trait TrustedLen: Iterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]"}, {"sha": "339b07119c6d59f1de428ecfeda7fcd05486554f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2703945ca3c6c9664a5a9ec606430cb79ba2c8/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=cb2703945ca3c6c9664a5a9ec606430cb79ba2c8", "patch": "@@ -363,6 +363,13 @@ pub trait StructuralEq {\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n+// FIXME(matthewjasper) This allows copying a type that doesn't implement\n+// `Copy` because of unsatisfied lifetime bounds (copying `A<'_>` when only\n+// `A<'static>: Copy` and `A<'_>: Clone`).\n+// We have this attribute here for now only because there are quite a few\n+// existing specializations on `Copy` that already exist in the standard\n+// library, and there's no way to safely have this behavior right now.\n+#[rustc_unsafe_specialization_marker]\n pub trait Copy: Clone {\n     // Empty.\n }"}]}