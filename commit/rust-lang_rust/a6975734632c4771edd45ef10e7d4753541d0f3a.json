{"sha": "a6975734632c4771edd45ef10e7d4753541d0f3a", "node_id": "C_kwDOAAsO6NoAKGE2OTc1NzM0NjMyYzQ3NzFlZGQ0NWVmMTBlN2Q0NzUzNTQxZDBmM2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-10T03:21:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-10T03:21:39Z"}, "message": "Auto merge of #101680 - jackh726:implied-cleanup, r=lcnr\n\nFix implied outlives bounds logic for projections\n\nThe logic here is subtly wrong. I put a bit of an explanation in a767d7b5165cea8ee5cbe494a4a636c50ef67c9c.\n\nTL;DR: we register outlives predicates to be proved, because wf code normalizes projections (from the unnormalized types) to type variables. This causes us to register those as constraints instead of implied. This was \"fine\", because we later added that implied bound in the normalized type, and delayed registering constraints. When I went to cleanup `free_region_relations` to *not* delay adding constraints, this bug was uncovered.\n\ncc. `@aliemjay` because this caused your test failure in #99832 (I only realized as I was writing this)\n\nr? `@nikomatsakis`", "tree": {"sha": "e6ccc1382187c2deedfd2294f771eeb78afd36f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6ccc1382187c2deedfd2294f771eeb78afd36f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6975734632c4771edd45ef10e7d4753541d0f3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6975734632c4771edd45ef10e7d4753541d0f3a", "html_url": "https://github.com/rust-lang/rust/commit/a6975734632c4771edd45ef10e7d4753541d0f3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6975734632c4771edd45ef10e7d4753541d0f3a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a12d31d5a681d70f277b4fbf6cafe22bae876ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a12d31d5a681d70f277b4fbf6cafe22bae876ea7", "html_url": "https://github.com/rust-lang/rust/commit/a12d31d5a681d70f277b4fbf6cafe22bae876ea7"}, {"sha": "0637b6b4718bcaa273b55f83ca4be893a86b1f83", "url": "https://api.github.com/repos/rust-lang/rust/commits/0637b6b4718bcaa273b55f83ca4be893a86b1f83", "html_url": "https://github.com/rust-lang/rust/commit/0637b6b4718bcaa273b55f83ca4be893a86b1f83"}], "stats": {"total": 250, "additions": 144, "deletions": 106}, "files": [{"sha": "6a3748fded5549497501ea1a067af2b8c2d259f6", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=a6975734632c4771edd45ef10e7d4753541d0f3a", "patch": "@@ -187,6 +187,7 @@ pub(crate) struct PlaceholderIndices {\n }\n \n impl PlaceholderIndices {\n+    /// Returns the `PlaceholderIndex` for the inserted `PlaceholderRegion`\n     pub(crate) fn insert(&mut self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n         let (index, _) = self.indices.insert_full(placeholder);\n         index.into()"}, {"sha": "2dd24fe03403840eb5c7166f9871956b6d17c160", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 87, "deletions": 68, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=a6975734632c4771edd45ef10e7d4753541d0f3a", "patch": "@@ -8,6 +8,7 @@ use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::query::OutlivesBound;\n use rustc_middle::ty::{self, RegionVid, Ty};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOp};\n use std::rc::Rc;\n use type_op::TypeOpOutput;\n@@ -217,8 +218,27 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         self.inverse_outlives.add(fr_b, fr_a);\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn create(mut self) -> CreateResult<'tcx> {\n         let span = self.infcx.tcx.def_span(self.universal_regions.defining_ty.def_id());\n+\n+        // Insert the facts we know from the predicates. Why? Why not.\n+        let param_env = self.param_env;\n+        self.add_outlives_bounds(outlives::explicit_outlives_bounds(param_env));\n+\n+        // - outlives is reflexive, so `'r: 'r` for every region `'r`\n+        // - `'static: 'r` for every region `'r`\n+        // - `'r: 'fn_body` for every (other) universally quantified\n+        //   region `'r`, all of which are provided by our caller\n+        let fr_static = self.universal_regions.fr_static;\n+        let fr_fn_body = self.universal_regions.fr_fn_body;\n+        for fr in self.universal_regions.universal_regions() {\n+            debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n+            self.relate_universal_regions(fr, fr);\n+            self.relate_universal_regions(fr_static, fr);\n+            self.relate_universal_regions(fr, fr_fn_body);\n+        }\n+\n         let unnormalized_input_output_tys = self\n             .universal_regions\n             .unnormalized_input_tys\n@@ -236,78 +256,58 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         //   the `relations` is built.\n         let mut normalized_inputs_and_output =\n             Vec::with_capacity(self.universal_regions.unnormalized_input_tys.len() + 1);\n-        let constraint_sets: Vec<_> = unnormalized_input_output_tys\n-            .flat_map(|ty| {\n-                debug!(\"build: input_or_output={:?}\", ty);\n-                // We add implied bounds from both the unnormalized and normalized ty.\n-                // See issue #87748\n-                let constraints_implied1 = self.add_implied_bounds(ty);\n-                let TypeOpOutput { output: norm_ty, constraints: constraints1, .. } = self\n-                    .param_env\n-                    .and(type_op::normalize::Normalize::new(ty))\n-                    .fully_perform(self.infcx)\n-                    .unwrap_or_else(|_| {\n-                        let reported = self\n-                            .infcx\n-                            .tcx\n-                            .sess\n-                            .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n-                        TypeOpOutput {\n-                            output: self.infcx.tcx.ty_error_with_guaranteed(reported),\n-                            constraints: None,\n-                            error_info: None,\n-                        }\n-                    });\n-                // Note: we need this in examples like\n-                // ```\n-                // trait Foo {\n-                //   type Bar;\n-                //   fn foo(&self) -> &Self::Bar;\n-                // }\n-                // impl Foo for () {\n-                //   type Bar = ();\n-                //   fn foo(&self) -> &() {}\n-                // }\n-                // ```\n-                // Both &Self::Bar and &() are WF\n-                let constraints_implied2 =\n-                    if ty != norm_ty { self.add_implied_bounds(norm_ty) } else { None };\n-                normalized_inputs_and_output.push(norm_ty);\n-                constraints1.into_iter().chain(constraints_implied1).chain(constraints_implied2)\n-            })\n-            .collect();\n+        let mut constraints = vec![];\n+        for ty in unnormalized_input_output_tys {\n+            debug!(\"build: input_or_output={:?}\", ty);\n+            // We add implied bounds from both the unnormalized and normalized ty.\n+            // See issue #87748\n+            let constraints_unnorm = self.add_implied_bounds(ty);\n+            if let Some(c) = constraints_unnorm {\n+                constraints.push(c)\n+            }\n+            let TypeOpOutput { output: norm_ty, constraints: constraints_normalize, .. } = self\n+                .param_env\n+                .and(type_op::normalize::Normalize::new(ty))\n+                .fully_perform(self.infcx)\n+                .unwrap_or_else(|_| {\n+                    self.infcx\n+                        .tcx\n+                        .sess\n+                        .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n+                    TypeOpOutput {\n+                        output: self.infcx.tcx.ty_error(),\n+                        constraints: None,\n+                        error_info: None,\n+                    }\n+                });\n+            if let Some(c) = constraints_normalize {\n+                constraints.push(c)\n+            }\n \n-        // Insert the facts we know from the predicates. Why? Why not.\n-        let param_env = self.param_env;\n-        self.add_outlives_bounds(outlives::explicit_outlives_bounds(param_env));\n+            // Note: we need this in examples like\n+            // ```\n+            // trait Foo {\n+            //   type Bar;\n+            //   fn foo(&self) -> &Self::Bar;\n+            // }\n+            // impl Foo for () {\n+            //   type Bar = ();\n+            //   fn foo(&self) ->&() {}\n+            // }\n+            // ```\n+            // Both &Self::Bar and &() are WF\n+            if ty != norm_ty {\n+                let constraints_norm = self.add_implied_bounds(norm_ty);\n+                if let Some(c) = constraints_norm {\n+                    constraints.push(c)\n+                }\n+            }\n \n-        // Finally:\n-        // - outlives is reflexive, so `'r: 'r` for every region `'r`\n-        // - `'static: 'r` for every region `'r`\n-        // - `'r: 'fn_body` for every (other) universally quantified\n-        //   region `'r`, all of which are provided by our caller\n-        let fr_static = self.universal_regions.fr_static;\n-        let fr_fn_body = self.universal_regions.fr_fn_body;\n-        for fr in self.universal_regions.universal_regions() {\n-            debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n-            self.relate_universal_regions(fr, fr);\n-            self.relate_universal_regions(fr_static, fr);\n-            self.relate_universal_regions(fr, fr_fn_body);\n+            normalized_inputs_and_output.push(norm_ty);\n         }\n \n-        for data in &constraint_sets {\n-            constraint_conversion::ConstraintConversion::new(\n-                self.infcx,\n-                &self.universal_regions,\n-                &self.region_bound_pairs,\n-                self.implicit_region_bound,\n-                self.param_env,\n-                Locations::All(span),\n-                span,\n-                ConstraintCategory::Internal,\n-                &mut self.constraints,\n-            )\n-            .convert_all(data);\n+        for c in constraints {\n+            self.push_region_constraints(c, span);\n         }\n \n         CreateResult {\n@@ -321,6 +321,24 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, data), level = \"debug\")]\n+    fn push_region_constraints(&mut self, data: &QueryRegionConstraints<'tcx>, span: Span) {\n+        debug!(\"constraints generated: {:#?}\", data);\n+\n+        constraint_conversion::ConstraintConversion::new(\n+            self.infcx,\n+            &self.universal_regions,\n+            &self.region_bound_pairs,\n+            self.implicit_region_bound,\n+            self.param_env,\n+            Locations::All(span),\n+            span,\n+            ConstraintCategory::Internal,\n+            &mut self.constraints,\n+        )\n+        .convert_all(data);\n+    }\n+\n     /// Update the type of a single local, which should represent\n     /// either the return type of the MIR or one of its arguments. At\n     /// the same time, compute and add any implied bounds that come\n@@ -332,6 +350,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n             .fully_perform(self.infcx)\n             .unwrap_or_else(|_| bug!(\"failed to compute implied bounds {:?}\", ty));\n+        debug!(?bounds, ?constraints);\n         self.add_outlives_bounds(bounds);\n         constraints\n     }"}, {"sha": "64c96281ed98380c256f472438c92a68ff322921", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=a6975734632c4771edd45ef10e7d4753541d0f3a", "patch": "@@ -910,6 +910,8 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n }\n \n impl<'tcx> MirTypeckRegionConstraints<'tcx> {\n+    /// Creates a `Region` for a given `PlaceholderRegion`, or returns the\n+    /// region that corresponds to a previously created one.\n     fn placeholder_region(\n         &mut self,\n         infcx: &InferCtxt<'tcx>,"}, {"sha": "bae246418b05ac7a167ab9bd794fd6ab12771b50", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=a6975734632c4771edd45ef10e7d4753541d0f3a", "patch": "@@ -207,6 +207,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     ///\n     /// In some cases, such as when `erased_ty` represents a `ty::Param`, however,\n     /// the result is precise.\n+    #[instrument(level = \"debug\", skip(self))]\n     fn declared_generic_bounds_from_env_for_erased_ty(\n         &self,\n         erased_ty: Ty<'tcx>,"}, {"sha": "2c6c77072e60e4d7896d1ddc349f96cc7868bede", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 50, "deletions": 36, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=a6975734632c4771edd45ef10e7d4753541d0f3a", "patch": "@@ -70,47 +70,61 @@ fn compute_implied_outlives_bounds<'tcx>(\n         let obligations = wf::obligations(ocx.infcx, param_env, CRATE_DEF_ID, 0, arg, DUMMY_SP)\n             .unwrap_or_default();\n \n-        // While these predicates should all be implied by other parts of\n-        // the program, they are still relevant as they may constrain\n-        // inference variables, which is necessary to add the correct\n-        // implied bounds in some cases, mostly when dealing with projections.\n-        ocx.register_obligations(\n-            obligations.iter().filter(|o| o.predicate.has_non_region_infer()).cloned(),\n-        );\n-\n-        // From the full set of obligations, just filter down to the\n-        // region relationships.\n-        outlives_bounds.extend(obligations.into_iter().filter_map(|obligation| {\n+        for obligation in obligations {\n+            debug!(?obligation);\n             assert!(!obligation.has_escaping_bound_vars());\n-            match obligation.predicate.kind().no_bound_vars() {\n-                None => None,\n-                Some(pred) => match pred {\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(..))\n-                    | ty::PredicateKind::Subtype(..)\n-                    | ty::PredicateKind::Coerce(..)\n-                    | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-                    | ty::PredicateKind::ClosureKind(..)\n-                    | ty::PredicateKind::ObjectSafe(..)\n-                    | ty::PredicateKind::ConstEvaluatable(..)\n-                    | ty::PredicateKind::ConstEquate(..)\n-                    | ty::PredicateKind::Ambiguous\n-                    | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n-                    ty::PredicateKind::WellFormed(arg) => {\n-                        wf_args.push(arg);\n-                        None\n+\n+            // While these predicates should all be implied by other parts of\n+            // the program, they are still relevant as they may constrain\n+            // inference variables, which is necessary to add the correct\n+            // implied bounds in some cases, mostly when dealing with projections.\n+            //\n+            // Another important point here: we only register `Projection`\n+            // predicates, since otherwise we might register outlives\n+            // predicates containing inference variables, and we don't\n+            // learn anything new from those.\n+            if obligation.predicate.has_non_region_infer() {\n+                match obligation.predicate.kind().skip_binder() {\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(..)) => {\n+                        ocx.register_obligation(obligation.clone());\n                     }\n+                    _ => {}\n+                }\n+            }\n \n-                    ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n-                        ty::OutlivesPredicate(r_a, r_b),\n-                    )) => Some(ty::OutlivesPredicate(r_a.into(), r_b)),\n+            let pred = match obligation.predicate.kind().no_bound_vars() {\n+                None => continue,\n+                Some(pred) => pred,\n+            };\n+            match pred {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::Ambiguous\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n+\n+                // We need to search through *all* WellFormed predicates\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    wf_args.push(arg);\n+                }\n+\n+                // We need to register region relationships\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                    r_a,\n+                    r_b,\n+                ))) => outlives_bounds.push(ty::OutlivesPredicate(r_a.into(), r_b)),\n \n-                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_a,\n-                        r_b,\n-                    ))) => Some(ty::OutlivesPredicate(ty_a.into(), r_b)),\n-                },\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    ty_a,\n+                    r_b,\n+                ))) => outlives_bounds.push(ty::OutlivesPredicate(ty_a.into(), r_b)),\n             }\n-        }));\n+        }\n     }\n \n     // This call to `select_all_or_error` is necessary to constrain inference variables, which we"}, {"sha": "8bea5588ae75e6b653b93bed2e6e1b1c6ee2e585", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6975734632c4771edd45ef10e7d4753541d0f3a/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=a6975734632c4771edd45ef10e7d4753541d0f3a", "patch": "@@ -4,6 +4,7 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n #![feature(let_chains)]\n+#![feature(drain_filter)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "5991c1104c8a2875110b636b5fe950ff002393b4", "filename": "tests/ui/nll/issue-52057.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6975734632c4771edd45ef10e7d4753541d0f3a/tests%2Fui%2Fnll%2Fissue-52057.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6975734632c4771edd45ef10e7d4753541d0f3a/tests%2Fui%2Fnll%2Fissue-52057.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-52057.rs?ref=a6975734632c4771edd45ef10e7d4753541d0f3a", "patch": "@@ -1,6 +1,6 @@\n // Regression test for #52057. There is an implied bound\n-// that `I: 'a` where `'a` is the lifetime of `self` in `parse_first`;\n-// but to observe that, one must normalize first.\n+// that `I: 'x` where `'x` is the lifetime of the reference `&mut Self::Input`\n+// in `parse_first`; but to observe that, one must normalize first.\n //\n // run-pass\n "}]}