{"sha": "8405770b5196914dd397877c0447756a6b41fb2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MDU3NzBiNTE5NjkxNGRkMzk3ODc3YzA0NDc3NTZhNmI0MWZiMmI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-02T12:11:33Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-02T12:11:33Z"}, "message": "Rustup to rustc 1.17.0-nightly (be760566c 2017-02-28)", "tree": {"sha": "8cd175d0288dae44c929b076578e8236243d58c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cd175d0288dae44c929b076578e8236243d58c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8405770b5196914dd397877c0447756a6b41fb2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8405770b5196914dd397877c0447756a6b41fb2b", "html_url": "https://github.com/rust-lang/rust/commit/8405770b5196914dd397877c0447756a6b41fb2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8405770b5196914dd397877c0447756a6b41fb2b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8878a4030acf5285a48e7e248e5f96e4d01060ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/8878a4030acf5285a48e7e248e5f96e4d01060ec", "html_url": "https://github.com/rust-lang/rust/commit/8878a4030acf5285a48e7e248e5f96e4d01060ec"}], "stats": {"total": 175, "additions": 71, "deletions": 104}, "files": [{"sha": "34b672dda91e19ac9d1e37c8670a7b4c99e32bd4", "filename": "src/error.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8405770b5196914dd397877c0447756a6b41fb2b/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8405770b5196914dd397877c0447756a6b41fb2b/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=8405770b5196914dd397877c0447756a6b41fb2b", "patch": "@@ -1,15 +1,14 @@\n use std::error::Error;\n use std::fmt;\n use rustc::mir;\n-use rustc::ty::{BareFnTy, Ty, FnSig, layout};\n-use syntax::abi::Abi;\n+use rustc::ty::{PolyFnSig, Ty, layout};\n use memory::{Pointer, Function};\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n #[derive(Clone, Debug)]\n pub enum EvalError<'tcx> {\n-    FunctionPointerTyMismatch(Abi, &'tcx FnSig<'tcx>, &'tcx BareFnTy<'tcx>),\n+    FunctionPointerTyMismatch(PolyFnSig<'tcx>, PolyFnSig<'tcx>),\n     NoMirFor(String),\n     UnterminatedCString(Pointer),\n     DanglingPointerDeref,\n@@ -151,8 +150,8 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                        ptr.offset, ptr.offset + size, ptr.alloc_id, allocation_size)\n             },\n             EvalError::NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n-            EvalError::FunctionPointerTyMismatch(abi, sig, got) =>\n-                write!(f, \"tried to call a function with abi {:?} and sig {:?} through a function pointer of type {:?}\", abi, sig, got),\n+            EvalError::FunctionPointerTyMismatch(sig, got) =>\n+                write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig.skip_binder(), got.skip_binder()),\n             EvalError::ArrayIndexOutOfBounds(span, len, index) =>\n                 write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n             EvalError::Math(span, ref err) =>"}, {"sha": "9b23b849fc9b785193653958b0b3d1c90a88b3f2", "filename": "src/eval_context.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8405770b5196914dd397877c0447756a6b41fb2b/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8405770b5196914dd397877c0447756a6b41fb2b/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=8405770b5196914dd397877c0447756a6b41fb2b", "patch": "@@ -181,8 +181,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Float(ConstFloat::F32(f)) => PrimVal::from_f32(f),\n             Float(ConstFloat::F64(f)) => PrimVal::from_f64(f),\n-            Float(ConstFloat::FInfer { .. }) =>\n-                bug!(\"uninferred constants only exist before typeck\"),\n \n             Bool(b) => PrimVal::from_bool(b),\n             Char(c) => PrimVal::from_char(c),\n@@ -196,7 +194,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Struct(_)    => unimplemented!(),\n             Tuple(_)     => unimplemented!(),\n-            Function(_)  => unimplemented!(),\n+            Function(_, _)  => unimplemented!(),\n             Array(_)     => unimplemented!(),\n             Repeat(_, _) => unimplemented!(),\n         };\n@@ -457,7 +455,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     General { discr, ref variants, .. } => {\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n-                            let discr_val = adt_def.variants[variant].disr_val;\n+                            let discr_val = adt_def.discriminants(self.tcx)\n+                                .nth(variant)\n+                                .expect(\"broken mir: Adt variant id invalid\")\n+                                .to_u128_unchecked();\n                             let discr_size = discr.size().bytes();\n                             if variants[variant].packed {\n                                 let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0;\n@@ -530,7 +531,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     CEnum { .. } => {\n                         assert_eq!(operands.len(), 0);\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n-                            let n = adt_def.variants[variant].disr_val;\n+                            let n = adt_def.discriminants(self.tcx)\n+                                .nth(variant)\n+                                .expect(\"broken mir: Adt variant index invalid\")\n+                                .to_u128_unchecked();\n                             self.write_primval(dest, PrimVal::Bytes(n), dest_ty)?;\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::CEnum\", kind);\n@@ -640,9 +644,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     ReifyFnPointer => match self.operand_ty(operand).sty {\n-                        ty::TyFnDef(def_id, substs, fn_ty) => {\n-                            let fn_ty = self.tcx.erase_regions(&fn_ty);\n-                            let fn_ptr = self.memory.create_fn_ptr(self.tcx,def_id, substs, fn_ty);\n+                        ty::TyFnDef(def_id, substs, sig) => {\n+                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs, sig);\n                             self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n@@ -658,8 +661,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     ClosureFnPointer => match self.operand_ty(operand).sty {\n                         ty::TyClosure(def_id, substs) => {\n-                            let fn_ty = self.tcx.closure_type(def_id, substs);\n-                            let fn_ptr = self.memory.create_fn_ptr_from_noncapture_closure(self.tcx, def_id, substs, fn_ty);\n+                            let fn_ty = self.tcx.closure_type(def_id);\n+                            let fn_ptr = self.memory.create_fn_ptr_from_noncapture_closure(def_id, substs, fn_ty);\n                             self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n@@ -673,7 +676,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = self.force_allocation(lval)?.to_ptr();\n                 let discr_val = self.read_discriminant_value(ptr, ty)?;\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n-                    if adt_def.variants.iter().all(|v| discr_val != v.disr_val) {\n+                    if adt_def.discriminants(self.tcx).all(|v| discr_val != v.to_u128_unchecked()) {\n                         return Err(EvalError::InvalidDiscriminant);\n                     }\n                 } else {"}, {"sha": "44959ea6728607d6c73c2656bd9d571549c8ff15", "filename": "src/memory.rs", "status": "modified", "additions": 14, "deletions": 46, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8405770b5196914dd397877c0447756a6b41fb2b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8405770b5196914dd397877c0447756a6b41fb2b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=8405770b5196914dd397877c0447756a6b41fb2b", "patch": "@@ -3,12 +3,10 @@ use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque, BTreeSet\n use std::{fmt, iter, ptr, mem, io};\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, BareFnTy, ClosureTy, ClosureSubsts, TyCtxt};\n+use rustc::ty::{self, PolyFnSig, ClosureSubsts};\n use rustc::ty::subst::Substs;\n use rustc::ty::layout::{self, TargetDataLayout};\n \n-use syntax::abi::Abi;\n-\n use error::{EvalError, EvalResult};\n use value::PrimVal;\n \n@@ -109,8 +107,7 @@ impl Pointer {\n pub struct FunctionDefinition<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n-    pub abi: Abi,\n-    pub sig: &'tcx ty::FnSig<'tcx>,\n+    pub sig: PolyFnSig<'tcx>,\n }\n \n /// Either a concrete function, or a glue function\n@@ -127,7 +124,7 @@ pub enum Function<'tcx> {\n     DropGlue(ty::Ty<'tcx>),\n     /// Glue required to treat the ptr part of a fat pointer\n     /// as a function pointer\n-    FnPtrAsTraitObject(&'tcx ty::FnSig<'tcx>),\n+    FnPtrAsTraitObject(PolyFnSig<'tcx>),\n     /// Glue for Closures\n     Closure(FunctionDefinition<'tcx>),\n     /// Glue for noncapturing closures casted to function pointers\n@@ -217,67 +214,43 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.alloc_map.iter()\n     }\n \n-    pub fn create_closure_ptr(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: ClosureSubsts<'tcx>, fn_ty: ClosureTy<'tcx>) -> Pointer {\n-        // FIXME: this is a hack\n-        let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: fn_ty.unsafety,\n-            abi: fn_ty.abi,\n-            sig: fn_ty.sig,\n-        });\n+    pub fn create_closure_ptr(&mut self, def_id: DefId, substs: ClosureSubsts<'tcx>, sig: PolyFnSig<'tcx>) -> Pointer {\n         self.create_fn_alloc(Function::Closure(FunctionDefinition {\n             def_id,\n             substs: substs.substs,\n-            abi: fn_ty.abi,\n-            // FIXME: why doesn't this compile?\n-            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n-            sig: fn_ty.sig.skip_binder(),\n+            sig,\n         }))\n     }\n \n-    pub fn create_fn_ptr_from_noncapture_closure(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: ClosureSubsts<'tcx>, fn_ty: ClosureTy<'tcx>) -> Pointer {\n-        // FIXME: this is a hack\n-        let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: fn_ty.unsafety,\n-            abi: fn_ty.abi,\n-            sig: fn_ty.sig,\n-        });\n+    pub fn create_fn_ptr_from_noncapture_closure(&mut self, def_id: DefId, substs: ClosureSubsts<'tcx>, sig: PolyFnSig<'tcx>) -> Pointer {\n         self.create_fn_alloc(Function::NonCaptureClosureAsFnPtr(FunctionDefinition {\n             def_id,\n             substs: substs.substs,\n-            abi: Abi::Rust, // adjust abi\n-            // FIXME: why doesn't this compile?\n-            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n-            sig: fn_ty.sig.skip_binder(),\n+            sig,\n         }))\n     }\n \n-    pub fn create_fn_as_trait_glue(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n+    pub fn create_fn_as_trait_glue(&mut self, def_id: DefId, substs: &'tcx Substs, sig: PolyFnSig<'tcx>) -> Pointer {\n         self.create_fn_alloc(Function::FnDefAsTraitObject(FunctionDefinition {\n             def_id,\n             substs,\n-            abi: fn_ty.abi,\n-            // FIXME: why doesn't this compile?\n-            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n-            sig: fn_ty.sig.skip_binder(),\n+            sig,\n         }))\n     }\n \n-    pub fn create_fn_ptr_as_trait_glue(&mut self, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::FnPtrAsTraitObject(fn_ty.sig.skip_binder()))\n+    pub fn create_fn_ptr_as_trait_glue(&mut self, sig: PolyFnSig<'tcx>) -> Pointer {\n+        self.create_fn_alloc(Function::FnPtrAsTraitObject(sig))\n     }\n \n     pub fn create_drop_glue(&mut self, ty: ty::Ty<'tcx>) -> Pointer {\n         self.create_fn_alloc(Function::DropGlue(ty))\n     }\n \n-    pub fn create_fn_ptr(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n+    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs, sig: PolyFnSig<'tcx>) -> Pointer {\n         self.create_fn_alloc(Function::Concrete(FunctionDefinition {\n             def_id,\n             substs,\n-            abi: fn_ty.abi,\n-            // FIXME: why doesn't this compile?\n-            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n-            sig: fn_ty.sig.skip_binder(),\n+            sig,\n         }))\n     }\n \n@@ -623,12 +596,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n fn dump_fn_def<'tcx>(fn_def: FunctionDefinition<'tcx>) -> String {\n     let name = ty::tls::with(|tcx| tcx.item_path_str(fn_def.def_id));\n-    let abi = if fn_def.abi == Abi::Rust {\n-        format!(\"\")\n-    } else {\n-        format!(\"extern {} \", fn_def.abi)\n-    };\n-    format!(\"function pointer: {}: {}{}\", name, abi, fn_def.sig)\n+    format!(\"function pointer: {}: {}\", name, fn_def.sig.skip_binder())\n }\n \n /// Byte accessors"}, {"sha": "e8bd2164b84a28f2a7dd4220116fc7eeec7389b2", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8405770b5196914dd397877c0447756a6b41fb2b/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8405770b5196914dd397877c0447756a6b41fb2b/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=8405770b5196914dd397877c0447756a6b41fb2b", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (adt_ptr, extra) = lval.to_ptr_and_extra();\n \n                 // run drop impl before the fields' drop impls\n-                if let Some(drop_def_id) = adt_def.destructor() {\n+                if let Some(drop_def_id) = adt_def.destructor(self.tcx) {\n                     let trait_ref = ty::Binder(ty::TraitRef {\n                         def_id: self.tcx.lang_items.drop_trait().unwrap(),\n                         substs: self.tcx.mk_substs_trait(ty, &[]),\n@@ -121,7 +121,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Layout::General { .. } => {\n                         let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n                         let ptr = self.force_allocation(lval)?.to_ptr();\n-                        match adt_def.variants.iter().position(|v| discr_val == v.disr_val) {\n+                        match adt_def.discriminants(self.tcx).position(|v| discr_val == v.to_u128_unchecked()) {\n                             Some(i) => {\n                                 lval = Lvalue::Ptr {\n                                     ptr,"}, {"sha": "14392eda32623c9225158c8cd3407afa40ed4f68", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8405770b5196914dd397877c0447756a6b41fb2b/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8405770b5196914dd397877c0447756a6b41fb2b/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=8405770b5196914dd397877c0447756a6b41fb2b", "patch": "@@ -3,8 +3,10 @@ use rustc::mir;\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n+use rustc_const_math::ConstInt;\n use syntax::codemap::Span;\n use syntax::attr;\n+use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n@@ -62,33 +64,31 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let func_ty = self.operand_ty(func);\n                 let fn_def = match func_ty.sty {\n-                    ty::TyFnPtr(bare_fn_ty) => {\n+                    ty::TyFnPtr(bare_sig) => {\n                         let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n                         let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?;\n-                        let bare_sig = self.tcx.erase_late_bound_regions_and_normalize(&bare_fn_ty.sig);\n-                        let bare_sig = self.tcx.erase_regions(&bare_sig);\n                         match fn_def {\n                             Function::Concrete(fn_def) => {\n                                 // transmuting function pointers in miri is fine as long as the number of\n                                 // arguments and the abi don't change.\n                                 // FIXME: also check the size of the arguments' type and the return type\n                                 // Didn't get it to work, since that triggers an assertion in rustc which\n                                 // checks whether the type has escaping regions\n-                                if fn_def.abi != bare_fn_ty.abi ||\n-                                    fn_def.sig.variadic != bare_sig.variadic ||\n-                                    fn_def.sig.inputs().len() != bare_sig.inputs().len() {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(fn_def.abi, fn_def.sig, bare_fn_ty));\n+                                if fn_def.sig.abi() != bare_sig.abi() ||\n+                                    fn_def.sig.variadic() != bare_sig.variadic() ||\n+                                    fn_def.sig.inputs().skip_binder().len() != bare_sig.inputs().skip_binder().len() {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(fn_def.sig, bare_sig));\n                                 }\n                             },\n                             Function::NonCaptureClosureAsFnPtr(fn_def) => {\n-                                if fn_def.abi != bare_fn_ty.abi ||\n-                                    fn_def.sig.variadic != bare_sig.variadic ||\n-                                    fn_def.sig.inputs().len() != 1 {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(fn_def.abi, fn_def.sig, bare_fn_ty));\n+                                assert_eq!(fn_def.sig.abi(), Abi::RustCall);\n+                                if fn_def.sig.variadic() != bare_sig.variadic() ||\n+                                    fn_def.sig.inputs().skip_binder().len() != 1 {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(fn_def.sig, bare_sig));\n                                 }\n-                                if let ty::TyTuple(fields, _) = fn_def.sig.inputs()[0].sty {\n-                                    if fields.len() != bare_sig.inputs().len() {\n-                                        return Err(EvalError::FunctionPointerTyMismatch(fn_def.abi, fn_def.sig, bare_fn_ty));\n+                                if let ty::TyTuple(fields, _) = fn_def.sig.inputs().skip_binder()[0].sty {\n+                                    if fields.len() != bare_sig.inputs().skip_binder().len() {\n+                                        return Err(EvalError::FunctionPointerTyMismatch(fn_def.sig, bare_sig));\n                                     }\n                                 }\n                             },\n@@ -99,8 +99,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     ty::TyFnDef(def_id, substs, fn_ty) => Function::Concrete(FunctionDefinition {\n                         def_id,\n                         substs,\n-                        abi: fn_ty.abi,\n-                        sig: fn_ty.sig.skip_binder(),\n+                        sig: fn_ty,\n                     }),\n \n                     _ => {\n@@ -165,8 +164,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use syntax::abi::Abi;\n         match fn_def {\n             // Intrinsics can only be addressed directly\n-            Function::Concrete(FunctionDefinition { def_id, substs, abi: Abi::RustIntrinsic, sig }) => {\n-                let ty = sig.output();\n+            Function::Concrete(FunctionDefinition { def_id, substs, sig }) if sig.abi() == Abi::RustIntrinsic => {\n+                let ty = *sig.output().skip_binder();\n                 let layout = self.type_layout(ty)?;\n                 let (ret, target) = match destination {\n                     Some(dest) if is_inhabited(self.tcx, ty) => dest,\n@@ -177,17 +176,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(())\n             },\n             // C functions can only be addressed directly\n-            Function::Concrete(FunctionDefinition { def_id, abi: Abi::C, sig, ..}) => {\n-                let ty = sig.output();\n+            Function::Concrete(FunctionDefinition { def_id, sig, ..}) if sig.abi() == Abi::C => {\n+                let ty = *sig.output().skip_binder();\n                 let (ret, target) = destination.unwrap();\n                 self.call_c_abi(def_id, arg_operands, ret, ty)?;\n                 self.dump_local(ret);\n                 self.goto_block(target);\n                 Ok(())\n             },\n             Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n-            Function::Concrete(FunctionDefinition { def_id, abi: Abi::RustCall, sig, substs }) |\n-            Function::Concrete(FunctionDefinition { def_id, abi: Abi::Rust, sig, substs }) => {\n+            Function::Concrete(FunctionDefinition { def_id, sig, substs }) if sig.abi() == Abi::Rust || sig.abi() == Abi::RustCall => {\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n@@ -204,20 +202,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     };\n \n                 // FIXME(eddyb) Detect ADT constructors more efficiently.\n-                if let Some(adt_def) = sig.output().ty_adt_def() {\n-                    if let Some(v) = adt_def.variants.iter().find(|v| resolved_def_id == v.did) {\n+                if let Some(adt_def) = sig.output().skip_binder().ty_adt_def() {\n+                    let dids = adt_def.variants.iter().map(|v| v.did);\n+                    let discrs = adt_def.discriminants(self.tcx).map(ConstInt::to_u128_unchecked);\n+                    if let Some((_, disr_val)) = dids.zip(discrs).find(|&(did, _)| resolved_def_id == did) {\n                         let (lvalue, target) = destination.expect(\"tuple struct constructors can't diverge\");\n                         let dest_ty = self.tcx.item_type(adt_def.did);\n                         let dest_layout = self.type_layout(dest_ty)?;\n                         trace!(\"layout({:?}) = {:#?}\", dest_ty, dest_layout);\n                         match *dest_layout {\n                             Layout::Univariant { .. } => {\n-                                let disr_val = v.disr_val;\n                                 assert_eq!(disr_val, 0);\n                                 self.assign_fields(lvalue, dest_ty, args)?;\n                             },\n                             Layout::General { discr, ref variants, .. } => {\n-                                let disr_val = v.disr_val;\n                                 let discr_size = discr.size().bytes();\n                                 self.assign_discr_and_fields(\n                                     lvalue,\n@@ -230,7 +228,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 )?;\n                             },\n                             Layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-                                let disr_val = v.disr_val;\n                                 if nndiscr as u128 == disr_val {\n                                     self.assign_fields(lvalue, dest_ty, args)?;\n                                 } else {\n@@ -268,7 +265,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     span,\n                 )\n             },\n-            Function::NonCaptureClosureAsFnPtr(FunctionDefinition { def_id, abi: Abi::Rust, substs, sig }) => {\n+            Function::NonCaptureClosureAsFnPtr(FunctionDefinition { def_id, substs, sig }) if sig.abi() == Abi::RustCall => {\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n@@ -277,7 +274,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 args.insert(0, (\n                     Value::ByVal(PrimVal::Undef),\n-                    sig.inputs()[0],\n+                    sig.inputs().skip_binder()[0],\n                 ));\n                 self.eval_fn_call_inner(\n                     def_id,"}, {"sha": "986efc987de35529b05f1de3cc1d596eb0f4f1d5", "filename": "src/traits.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8405770b5196914dd397877c0447756a6b41fb2b/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8405770b5196914dd397877c0447756a6b41fb2b/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=8405770b5196914dd397877c0447756a6b41fb2b", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match self.memory.get_fn(fn_ptr.alloc_id)? {\n                     Function::FnDefAsTraitObject(fn_def) => {\n                         trace!(\"sig: {:#?}\", fn_def.sig);\n-                        assert!(fn_def.abi != abi::Abi::RustCall);\n+                        assert!(fn_def.sig.abi() != abi::Abi::RustCall);\n                         assert_eq!(args.len(), 2);\n                         // a function item turned into a closure trait object\n                         // the first arg is just there to give use the vtable\n@@ -126,14 +126,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         trace!(\"sig: {:#?}\", fn_def.sig);\n                         args[0] = (\n                             Value::ByVal(PrimVal::Ptr(self_ptr)),\n-                            fn_def.sig.inputs()[0],\n+                            fn_def.sig.inputs().skip_binder()[0],\n                         );\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     },\n                     Function::NonCaptureClosureAsFnPtr(fn_def) => {\n                         args.insert(0, (\n                             Value::ByVal(PrimVal::Undef),\n-                            fn_def.sig.inputs()[0],\n+                            fn_def.sig.inputs().skip_binder()[0],\n                         ));\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     }\n@@ -155,7 +155,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             Function::NonCaptureClosureAsFnPtr(fn_def) => {\n                                 args.insert(0, (\n                                     Value::ByVal(PrimVal::Undef),\n-                                    fn_def.sig.inputs()[0],\n+                                    fn_def.sig.inputs().skip_binder()[0],\n                                 ));\n                                 fn_def\n                             },\n@@ -220,7 +220,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 _ => bug!(\"bad function type: {}\", fn_ty),\n                             };\n                             let fn_ty = self.tcx.erase_regions(&fn_ty);\n-                            self.memory.create_fn_ptr(self.tcx, mth.method.def_id, mth.substs, fn_ty)\n+                            self.memory.create_fn_ptr(mth.method.def_id, mth.substs, fn_ty)\n                         }))\n                         .collect::<Vec<_>>()\n                         .into_iter()\n@@ -233,15 +233,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ..\n                     }\n                 ) => {\n-                    let closure_type = self.tcx.closure_type(closure_def_id, substs);\n-                    vec![Some(self.memory.create_closure_ptr(self.tcx, closure_def_id, substs, closure_type))].into_iter()\n+                    let closure_type = self.tcx.closure_type(closure_def_id);\n+                    vec![Some(self.memory.create_closure_ptr(closure_def_id, substs, closure_type))].into_iter()\n                 }\n \n                 // turn a function definition into a Fn trait object\n                 traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, .. }) => {\n                     match fn_ty.sty {\n                         ty::TyFnDef(did, substs, bare_fn_ty) => {\n-                            vec![Some(self.memory.create_fn_as_trait_glue(self.tcx, did, substs, bare_fn_ty))].into_iter()\n+                            vec![Some(self.memory.create_fn_as_trait_glue(did, substs, bare_fn_ty))].into_iter()\n                         },\n                         ty::TyFnPtr(bare_fn_ty) => {\n                             vec![Some(self.memory.create_fn_ptr_as_trait_glue(bare_fn_ty))].into_iter()\n@@ -275,13 +275,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // in case there is no drop function to be called, this still needs to be initialized\n         self.memory.write_usize(vtable, 0)?;\n         if let ty::TyAdt(adt_def, substs) = trait_ref.self_ty().sty {\n-            if let Some(drop_def_id) = adt_def.destructor() {\n+            if let Some(drop_def_id) = adt_def.destructor(self.tcx) {\n                 let fn_ty = match self.tcx.item_type(drop_def_id).sty {\n                     ty::TyFnDef(_, _, fn_ty) => self.tcx.erase_regions(&fn_ty),\n                     _ => bug!(\"drop method is not a TyFnDef\"),\n                 };\n                 // The real type is taken from the self argument in `fn drop(&mut self)`\n-                let real_ty = match fn_ty.sig.skip_binder().inputs()[0].sty {\n+                let real_ty = match fn_ty.inputs().skip_binder()[0].sty {\n                     ty::TyRef(_, mt) => self.monomorphize(mt.ty, substs),\n                     _ => bug!(\"first argument of Drop::drop must be &mut T\"),\n                 };"}, {"sha": "7509ae6ed77cb5de14fc77cc85aea86d432d7b60", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8405770b5196914dd397877c0447756a6b41fb2b/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8405770b5196914dd397877c0447756a6b41fb2b/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=8405770b5196914dd397877c0447756a6b41fb2b", "patch": "@@ -5,5 +5,5 @@ fn main() {\n         std::mem::transmute::<fn(), fn(i32)>(f)\n     };\n \n-    g(42) //~ ERROR tried to call a function with abi Rust and sig\n+    g(42) //~ ERROR tried to call a function with sig fn() through a function pointer of type fn(i32)\n }"}]}