{"sha": "8867ba19de71f437956440eeda9cd45ca8f1dc8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NjdiYTE5ZGU3MWY0Mzc5NTY0NDBlZWRhOWNkNDVjYThmMWRjOGY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-03T23:38:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-03T23:38:49Z"}, "message": "Rollup merge of #62258 - petrochenkov:idclean, r=Centril\n\nsyntax: Unsupport `foo! bar { ... }` macros in the parser\n\nTheir support in expansion was removed in https://github.com/rust-lang/rust/pull/61606.\n\nAlso un-reserve `macro_rules` as a macro name, there's no ambiguity between `macro_rules` definitions and macro calls (it also wasn't reserved correctly).\n\ncc https://github.com/rust-lang-nursery/wg-grammar/issues/51", "tree": {"sha": "7317b5b94dd9f662f97812282e7f901eb6ffe45d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7317b5b94dd9f662f97812282e7f901eb6ffe45d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8867ba19de71f437956440eeda9cd45ca8f1dc8f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdHTyJCRBK7hj4Ov3rIwAAdHIIAKXTmVT1aQYa0x+DwOIlcrbI\nDiULSPT9GiJEsUIin5hM5kVHGT01/S0lJST1Qh7L5kqLMtdEoIeu1NgtQotwWVcq\nZz91Fa4J3tF82RJzQXT7L5uIuwXemhFfx3C/srpbjzGD2jJD7Cgsz2gPMIzD2OWg\n6kB5tbF3FGVgCyqH3pmbYtOgulq2H3vVuQbmnjhb/gFtOXT3f2FxENu4WlK0sQ0x\nI90OSwIkYE+B2UIAT3rtIPaa4ZmyDY0hGGKeJXD6iwndvA0ZPjp/2KUKwNY43jON\nSkwDty5dtn6c3nJx7lS9JwDJLzYp9dj2HoGFL4Viok1KRzjfqAR34ptxG5/TQJI=\n=LhnM\n-----END PGP SIGNATURE-----\n", "payload": "tree 7317b5b94dd9f662f97812282e7f901eb6ffe45d\nparent 944bda9abb4b80aa383223ea98e230224df76a8b\nparent d0dc41a2bdd45531e9d5ef9364027763158b4b85\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562197129 +0200\ncommitter GitHub <noreply@github.com> 1562197129 +0200\n\nRollup merge of #62258 - petrochenkov:idclean, r=Centril\n\nsyntax: Unsupport `foo! bar { ... }` macros in the parser\n\nTheir support in expansion was removed in https://github.com/rust-lang/rust/pull/61606.\n\nAlso un-reserve `macro_rules` as a macro name, there's no ambiguity between `macro_rules` definitions and macro calls (it also wasn't reserved correctly).\n\ncc https://github.com/rust-lang-nursery/wg-grammar/issues/51\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8867ba19de71f437956440eeda9cd45ca8f1dc8f", "html_url": "https://github.com/rust-lang/rust/commit/8867ba19de71f437956440eeda9cd45ca8f1dc8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8867ba19de71f437956440eeda9cd45ca8f1dc8f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "944bda9abb4b80aa383223ea98e230224df76a8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/944bda9abb4b80aa383223ea98e230224df76a8b", "html_url": "https://github.com/rust-lang/rust/commit/944bda9abb4b80aa383223ea98e230224df76a8b"}, {"sha": "d0dc41a2bdd45531e9d5ef9364027763158b4b85", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0dc41a2bdd45531e9d5ef9364027763158b4b85", "html_url": "https://github.com/rust-lang/rust/commit/d0dc41a2bdd45531e9d5ef9364027763158b4b85"}], "stats": {"total": 341, "additions": 111, "deletions": 230}, "files": [{"sha": "ec2855f826a46cc9a0a458f828da5e6d2c35a561", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=8867ba19de71f437956440eeda9cd45ca8f1dc8f", "patch": "@@ -6,7 +6,7 @@ use rustc::util::nodemap::FxHashMap;\n \n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, NamedSyntaxExtension};\n use syntax::ext::base::MacroExpanderFn;\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::Symbol;\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n use syntax_pos::Span;\n@@ -85,9 +85,6 @@ impl<'a> Registry<'a> {\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n     pub fn register_syntax_extension(&mut self, name: ast::Name, mut extension: SyntaxExtension) {\n-        if name == sym::macro_rules {\n-            panic!(\"user-defined macros may not be named `macro_rules`\");\n-        }\n         if extension.def_info.is_none() {\n             extension.def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n         }"}, {"sha": "d8d08107b826a7c649888bf8c8dde7faab76fad0", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8867ba19de71f437956440eeda9cd45ca8f1dc8f", "patch": "@@ -1109,9 +1109,6 @@ impl<'a> Resolver<'a> {\n                         current_legacy_scope: &mut LegacyScope<'a>) {\n         self.local_macro_def_scopes.insert(item.id, self.current_module);\n         let ident = item.ident;\n-        if ident.name == sym::macro_rules {\n-            self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n-        }\n \n         let def_id = self.definitions.local_def_id(item.id);\n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,"}, {"sha": "c71fa61443c4360243196973997ac32a30db2d13", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8867ba19de71f437956440eeda9cd45ca8f1dc8f", "patch": "@@ -13,8 +13,7 @@ use crate::parse::{DirectoryOwnership, PResult, ParseSess};\n use crate::parse::token;\n use crate::parse::parser::Parser;\n use crate::ptr::P;\n-use crate::symbol::Symbol;\n-use crate::symbol::{kw, sym};\n+use crate::symbol::{sym, Symbol};\n use crate::tokenstream::{TokenStream, TokenTree};\n use crate::visit::{self, Visitor};\n use crate::util::map_in_place::MapInPlace;\n@@ -197,7 +196,6 @@ pub struct Invocation {\n pub enum InvocationKind {\n     Bang {\n         mac: ast::Mac,\n-        ident: Option<Ident>,\n         span: Span,\n     },\n     Attr {\n@@ -664,13 +662,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                          ext: &SyntaxExtension)\n                          -> Option<AstFragment> {\n         let kind = invoc.fragment_kind;\n-        let (mac, ident, span) = match invoc.kind {\n-            InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n+        let (mac, span) = match invoc.kind {\n+            InvocationKind::Bang { mac, span } => (mac, span),\n             _ => unreachable!(),\n         };\n         let path = &mac.node.path;\n \n-        let ident = ident.unwrap_or_else(|| Ident::invalid());\n         let validate = |this: &mut Self| {\n             // feature-gate the macro invocation\n             if let Some((feature, issue)) = ext.unstable_feature {\n@@ -690,12 +687,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n             }\n \n-            if ident.name != kw::Invalid {\n-                let msg = format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n-                this.cx.span_err(path.span, &msg);\n-                this.cx.trace_macros_diag();\n-                return Err(kind.dummy(span));\n-            }\n             Ok(())\n         };\n \n@@ -729,19 +720,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n \n             SyntaxExtensionKind::Bang(expander) => {\n-                if ident.name != kw::Invalid {\n-                    let msg =\n-                        format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n-                    self.cx.span_err(path.span, &msg);\n-                    self.cx.trace_macros_diag();\n-                    kind.dummy(span)\n-                } else {\n-                    self.gate_proc_macro_expansion_kind(span, kind);\n-                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n-                    let result = self.parse_ast_fragment(tok_result, kind, path, span);\n-                    self.gate_proc_macro_expansion(span, &result);\n-                    result\n-                }\n+                self.gate_proc_macro_expansion_kind(span, kind);\n+                let tok_result = expander.expand(self.cx, span, mac.node.stream());\n+                let result = self.parse_ast_fragment(tok_result, kind, path, span);\n+                self.gate_proc_macro_expansion(span, &result);\n+                result\n             }\n         };\n \n@@ -944,7 +927,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n \n     fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: AstFragmentKind) -> AstFragment {\n-        self.collect(kind, InvocationKind::Bang { mac, ident: None, span })\n+        self.collect(kind, InvocationKind::Bang { mac, span })\n     }\n \n     fn collect_attr(&mut self,\n@@ -1179,13 +1162,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             ast::ItemKind::Mac(..) => {\n                 self.check_attributes(&item.attrs);\n                 item.and_then(|item| match item.node {\n-                    ItemKind::Mac(mac) => {\n-                        self.collect(AstFragmentKind::Items, InvocationKind::Bang {\n-                            mac,\n-                            ident: Some(item.ident),\n-                            span: item.span,\n-                        }).make_items()\n-                    }\n+                    ItemKind::Mac(mac) => self.collect(\n+                        AstFragmentKind::Items, InvocationKind::Bang { mac, span: item.span }\n+                    ).make_items(),\n                     _ => unreachable!(),\n                 })\n             }"}, {"sha": "9c1796000938fd03f46d3fd3a39ee65c2ce21761", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 77, "deletions": 137, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8867ba19de71f437956440eeda9cd45ca8f1dc8f", "patch": "@@ -4324,51 +4324,49 @@ impl<'a> Parser<'a> {\n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility, lo: Span)\n                      -> PResult<'a, Option<P<Item>>> {\n         let token_lo = self.token.span;\n-        let (ident, def) = match self.token.kind {\n-            token::Ident(name, false) if name == kw::Macro => {\n-                self.bump();\n-                let ident = self.parse_ident()?;\n-                let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n-                    match self.parse_token_tree() {\n-                        TokenTree::Delimited(_, _, tts) => tts,\n-                        _ => unreachable!(),\n-                    }\n-                } else if self.check(&token::OpenDelim(token::Paren)) {\n-                    let args = self.parse_token_tree();\n-                    let body = if self.check(&token::OpenDelim(token::Brace)) {\n-                        self.parse_token_tree()\n-                    } else {\n-                        self.unexpected()?;\n-                        unreachable!()\n-                    };\n-                    TokenStream::new(vec![\n-                        args.into(),\n-                        TokenTree::token(token::FatArrow, token_lo.to(self.prev_span)).into(),\n-                        body.into(),\n-                    ])\n+        let (ident, def) = if self.eat_keyword(kw::Macro) {\n+            let ident = self.parse_ident()?;\n+            let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n+                match self.parse_token_tree() {\n+                    TokenTree::Delimited(_, _, tts) => tts,\n+                    _ => unreachable!(),\n+                }\n+            } else if self.check(&token::OpenDelim(token::Paren)) {\n+                let args = self.parse_token_tree();\n+                let body = if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.parse_token_tree()\n                 } else {\n                     self.unexpected()?;\n                     unreachable!()\n                 };\n+                TokenStream::new(vec![\n+                    args.into(),\n+                    TokenTree::token(token::FatArrow, token_lo.to(self.prev_span)).into(),\n+                    body.into(),\n+                ])\n+            } else {\n+                self.unexpected()?;\n+                unreachable!()\n+            };\n \n-                (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n-            }\n-            token::Ident(name, _) if name == sym::macro_rules &&\n-                                     self.look_ahead(1, |t| *t == token::Not) => {\n-                let prev_span = self.prev_span;\n-                self.complain_if_pub_macro(&vis.node, prev_span);\n-                self.bump();\n-                self.bump();\n-\n-                let ident = self.parse_ident()?;\n-                let (delim, tokens) = self.expect_delimited_token_tree()?;\n-                if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n-                    self.report_invalid_macro_expansion_item();\n-                }\n+            (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n+        } else if self.check_keyword(sym::macro_rules) &&\n+                  self.look_ahead(1, |t| *t == token::Not) &&\n+                  self.look_ahead(2, |t| t.is_ident()) {\n+            let prev_span = self.prev_span;\n+            self.complain_if_pub_macro(&vis.node, prev_span);\n+            self.bump();\n+            self.bump();\n \n-                (ident, ast::MacroDef { tokens, legacy: true })\n+            let ident = self.parse_ident()?;\n+            let (delim, tokens) = self.expect_delimited_token_tree()?;\n+            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+                self.report_invalid_macro_expansion_item();\n             }\n-            _ => return Ok(None),\n+\n+            (ident, ast::MacroDef { tokens, legacy: true })\n+        } else {\n+            return Ok(None);\n         };\n \n         let span = lo.to(self.prev_span);\n@@ -4412,14 +4410,14 @@ impl<'a> Parser<'a> {\n                   !self.is_existential_type_decl() &&\n                   !self.is_auto_trait_item() &&\n                   !self.is_async_fn() {\n-            let pth = self.parse_path(PathStyle::Expr)?;\n+            let path = self.parse_path(PathStyle::Expr)?;\n \n             if !self.eat(&token::Not) {\n                 let expr = if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.parse_struct_expr(lo, pth, ThinVec::new())?\n+                    self.parse_struct_expr(lo, path, ThinVec::new())?\n                 } else {\n                     let hi = self.prev_span;\n-                    self.mk_expr(lo.to(hi), ExprKind::Path(None, pth), ThinVec::new())\n+                    self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new())\n                 };\n \n                 let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n@@ -4434,34 +4432,6 @@ impl<'a> Parser<'a> {\n                 }));\n             }\n \n-            // it's a macro invocation\n-            let id = match self.token.kind {\n-                token::OpenDelim(_) => Ident::invalid(), // no special identifier\n-                _ => self.parse_ident()?,\n-            };\n-\n-            // check that we're pointing at delimiters (need to check\n-            // again after the `if`, because of `parse_ident`\n-            // consuming more tokens).\n-            match self.token.kind {\n-                token::OpenDelim(_) => {}\n-                _ => {\n-                    // we only expect an ident if we didn't parse one\n-                    // above.\n-                    let ident_str = if id.name == kw::Invalid {\n-                        \"identifier, \"\n-                    } else {\n-                        \"\"\n-                    };\n-                    let tok_str = self.this_token_descr();\n-                    let mut err = self.fatal(&format!(\"expected {}`(` or `{{`, found {}\",\n-                                                      ident_str,\n-                                                      tok_str));\n-                    err.span_label(self.token.span, format!(\"expected {}`(` or `{{`\", ident_str));\n-                    return Err(err)\n-                },\n-            }\n-\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n             let hi = self.prev_span;\n \n@@ -4471,59 +4441,38 @@ impl<'a> Parser<'a> {\n                 MacStmtStyle::NoBraces\n             };\n \n-            if id.name == kw::Invalid {\n-                let mac = respan(lo.to(hi), Mac_ { path: pth, tts, delim });\n-                let node = if delim == MacDelimiter::Brace ||\n-                              self.token == token::Semi || self.token == token::Eof {\n-                    StmtKind::Mac(P((mac, style, attrs.into())))\n-                }\n-                // We used to incorrectly stop parsing macro-expanded statements here.\n-                // If the next token will be an error anyway but could have parsed with the\n-                // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n-                else if macro_legacy_warnings &&\n-                        self.token.can_begin_expr() &&\n-                        match self.token.kind {\n-                    // These can continue an expression, so we can't stop parsing and warn.\n-                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n-                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n-                    token::BinOp(token::And) | token::BinOp(token::Or) |\n-                    token::AndAnd | token::OrOr |\n-                    token::DotDot | token::DotDotDot | token::DotDotEq => false,\n-                    _ => true,\n-                } {\n-                    self.warn_missing_semicolon();\n-                    StmtKind::Mac(P((mac, style, attrs.into())))\n-                } else {\n-                    let e = self.mk_expr(mac.span, ExprKind::Mac(mac), ThinVec::new());\n-                    let e = self.maybe_recover_from_bad_qpath(e, true)?;\n-                    let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n-                    let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                    StmtKind::Expr(e)\n-                };\n-                Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: lo.to(hi),\n-                    node,\n-                }\n+            let mac = respan(lo.to(hi), Mac_ { path, tts, delim });\n+            let node = if delim == MacDelimiter::Brace ||\n+                          self.token == token::Semi || self.token == token::Eof {\n+                StmtKind::Mac(P((mac, style, attrs.into())))\n+            }\n+            // We used to incorrectly stop parsing macro-expanded statements here.\n+            // If the next token will be an error anyway but could have parsed with the\n+            // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n+            else if macro_legacy_warnings &&\n+                    self.token.can_begin_expr() &&\n+                    match self.token.kind {\n+                // These can continue an expression, so we can't stop parsing and warn.\n+                token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n+                token::BinOp(token::Minus) | token::BinOp(token::Star) |\n+                token::BinOp(token::And) | token::BinOp(token::Or) |\n+                token::AndAnd | token::OrOr |\n+                token::DotDot | token::DotDotDot | token::DotDotEq => false,\n+                _ => true,\n+            } {\n+                self.warn_missing_semicolon();\n+                StmtKind::Mac(P((mac, style, attrs.into())))\n             } else {\n-                // if it has a special ident, it's definitely an item\n-                //\n-                // Require a semicolon or braces.\n-                if style != MacStmtStyle::Braces && !self.eat(&token::Semi) {\n-                    self.report_invalid_macro_expansion_item();\n-                }\n-                let span = lo.to(hi);\n-                Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    span,\n-                    node: StmtKind::Item({\n-                        self.mk_item(\n-                            span, id /*id is good here*/,\n-                            ItemKind::Mac(respan(span, Mac_ { path: pth, tts, delim })),\n-                            respan(lo, VisibilityKind::Inherited),\n-                            attrs)\n-                    }),\n-                }\n+                let e = self.mk_expr(mac.span, ExprKind::Mac(mac), ThinVec::new());\n+                let e = self.maybe_recover_from_bad_qpath(e, true)?;\n+                let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n+                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                StmtKind::Expr(e)\n+            };\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                span: lo.to(hi),\n+                node,\n             }\n         } else {\n             // FIXME: Bad copy of attrs\n@@ -7619,26 +7568,17 @@ impl<'a> Parser<'a> {\n             let mac_lo = self.token.span;\n \n             // item macro.\n-            let pth = self.parse_path(PathStyle::Mod)?;\n+            let path = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n-\n-            // a 'special' identifier (like what `macro_rules!` uses)\n-            // is optional. We should eventually unify invoc syntax\n-            // and remove this.\n-            let id = if self.token.is_ident() {\n-                self.parse_ident()?\n-            } else {\n-                Ident::invalid() // no special identifier\n-            };\n-            // eat a matched-delimiter token tree:\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n             if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n                 self.report_invalid_macro_expansion_item();\n             }\n \n             let hi = self.prev_span;\n-            let mac = respan(mac_lo.to(hi), Mac_ { path: pth, tts, delim });\n-            let item = self.mk_item(lo.to(hi), id, ItemKind::Mac(mac), visibility, attrs);\n+            let mac = respan(mac_lo.to(hi), Mac_ { path, tts, delim });\n+            let item =\n+                self.mk_item(lo.to(hi), Ident::invalid(), ItemKind::Mac(mac), visibility, attrs);\n             return Ok(Some(item));\n         }\n \n@@ -7664,9 +7604,9 @@ impl<'a> Parser<'a> {\n                 !(self.is_async_fn() && self.token.span.rust_2015()) {\n             let prev_span = self.prev_span;\n             let lo = self.token.span;\n-            let pth = self.parse_path(PathStyle::Mod)?;\n+            let path = self.parse_path(PathStyle::Mod)?;\n \n-            if pth.segments.len() == 1 {\n+            if path.segments.len() == 1 {\n                 if !self.eat(&token::Not) {\n                     return Err(self.missing_assoc_item_kind_err(item_kind, prev_span));\n                 }\n@@ -7686,7 +7626,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Semi)?;\n             }\n \n-            Ok(Some(respan(lo.to(self.prev_span), Mac_ { path: pth, tts, delim })))\n+            Ok(Some(respan(lo.to(self.prev_span), Mac_ { path, tts, delim })))\n         } else {\n             Ok(None)\n         }"}, {"sha": "0ab7e17f87b5a156a738fc3c37fa8b9f5e92b010", "filename": "src/test/run-pass/rfcs/rfc-2151-raw-identifiers/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2151-raw-identifiers%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2151-raw-identifiers%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2151-raw-identifiers%2Fmacros.rs?ref=8867ba19de71f437956440eeda9cd45ca8f1dc8f", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n #![feature(decl_macro)]\n \n-r#macro_rules! r#struct {\n+macro_rules! r#struct {\n     ($r#struct:expr) => { $r#struct }\n }\n "}, {"sha": "111078abb37007a5a7538a71247c3c304365f864", "filename": "src/test/ui/issues/issue-10536.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs?ref=8867ba19de71f437956440eeda9cd45ca8f1dc8f", "patch": "@@ -11,13 +11,9 @@ macro_rules! foo{\n pub fn main() {\n     foo!();\n \n-    assert!({one! two()});\n-    //~^ ERROR macros that expand to items\n-    //~| ERROR cannot find macro `one!` in this scope\n-    //~| ERROR mismatched types\n+    assert!({one! two()}); //~ ERROR expected open delimiter\n \n     // regardless of whether nested macro_rules works, the following should at\n     // least throw a conventional error.\n-    assert!({one! two});\n-    //~^ ERROR expected `(` or `{`, found `}`\n+    assert!({one! two}); //~ ERROR expected open delimiter\n }"}, {"sha": "73f948107f185fe2950ac2b4f1e6fd8beb2881ae", "filename": "src/test/ui/issues/issue-10536.stderr", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr?ref=8867ba19de71f437956440eeda9cd45ca8f1dc8f", "patch": "@@ -1,38 +1,14 @@\n-error: macros that expand to items must be delimited with braces or followed by a semicolon\n-  --> $DIR/issue-10536.rs:14:22\n+error: expected open delimiter\n+  --> $DIR/issue-10536.rs:14:19\n    |\n LL |     assert!({one! two()});\n-   |                      ^^\n-help: change the delimiters to curly braces\n-   |\n-LL |     assert!({one! two {}});\n-   |                       ^^\n-help: add a semicolon\n-   |\n-LL |     assert!({one! two();});\n-   |                        ^\n+   |                   ^^^ expected open delimiter\n \n-error: expected `(` or `{`, found `}`\n-  --> $DIR/issue-10536.rs:21:22\n+error: expected open delimiter\n+  --> $DIR/issue-10536.rs:18:19\n    |\n LL |     assert!({one! two});\n-   |                      ^ expected `(` or `{`\n-\n-error: cannot find macro `one!` in this scope\n-  --> $DIR/issue-10536.rs:14:14\n-   |\n-LL |     assert!({one! two()});\n-   |              ^^^\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-10536.rs:14:13\n-   |\n-LL |     assert!({one! two()});\n-   |             ^^^^^^^^^^^^ expected bool, found ()\n-   |\n-   = note: expected type `bool`\n-              found type `()`\n+   |                   ^^^ expected open delimiter\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "13dec95435be0344b0683df81fac3c3f7de3b4f3", "filename": "src/test/ui/parser/macro-bad-delimiter-ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.rs?ref=8867ba19de71f437956440eeda9cd45ca8f1dc8f", "patch": "@@ -1,3 +1,3 @@\n fn main() {\n-    foo! bar < //~ ERROR expected `(` or `{`, found `<`\n+    foo! bar < //~ ERROR expected open delimiter\n }"}, {"sha": "e97839a4f4a5232eb7622302248d3d49d6b973c4", "filename": "src/test/ui/parser/macro-bad-delimiter-ident.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.stderr?ref=8867ba19de71f437956440eeda9cd45ca8f1dc8f", "patch": "@@ -1,8 +1,8 @@\n-error: expected `(` or `{`, found `<`\n-  --> $DIR/macro-bad-delimiter-ident.rs:2:14\n+error: expected open delimiter\n+  --> $DIR/macro-bad-delimiter-ident.rs:2:10\n    |\n LL |     foo! bar <\n-   |              ^ expected `(` or `{`\n+   |          ^^^ expected open delimiter\n \n error: aborting due to previous error\n "}, {"sha": "09e071ec45420d6500047f485892a5ba71ca9eff", "filename": "src/test/ui/user-defined-macro-rules.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Fui%2Fuser-defined-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8867ba19de71f437956440eeda9cd45ca8f1dc8f/src%2Ftest%2Fui%2Fuser-defined-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuser-defined-macro-rules.rs?ref=8867ba19de71f437956440eeda9cd45ca8f1dc8f", "patch": "@@ -1,5 +1,9 @@\n-#![allow(unused_macros)]\n+// check-pass\n \n-macro_rules! macro_rules { () => {} } //~ ERROR user-defined macros may not be named `macro_rules`\n+macro_rules! macro_rules { () => { struct S; } } // OK\n \n-fn main() {}\n+macro_rules! {} // OK, calls the macro defined above\n+\n+fn main() {\n+    let s = S;\n+}"}, {"sha": "057515228e0d1f43faa3255e35e33895aa8daf44", "filename": "src/test/ui/user-defined-macro-rules.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/944bda9abb4b80aa383223ea98e230224df76a8b/src%2Ftest%2Fui%2Fuser-defined-macro-rules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/944bda9abb4b80aa383223ea98e230224df76a8b/src%2Ftest%2Fui%2Fuser-defined-macro-rules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuser-defined-macro-rules.stderr?ref=944bda9abb4b80aa383223ea98e230224df76a8b", "patch": "@@ -1,8 +0,0 @@\n-error: user-defined macros may not be named `macro_rules`\n-  --> $DIR/user-defined-macro-rules.rs:3:1\n-   |\n-LL | macro_rules! macro_rules { () => {} }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}]}