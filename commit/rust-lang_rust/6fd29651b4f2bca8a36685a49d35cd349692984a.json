{"sha": "6fd29651b4f2bca8a36685a49d35cd349692984a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmZDI5NjUxYjRmMmJjYThhMzY2ODVhNDlkMzVjZDM0OTY5Mjk4NGE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-29T11:06:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-29T11:06:18Z"}, "message": "Merge #2931\n\n2931: Added documentation to test_utils r=matklad a=Veetaha\n\nAdded some doc comments to test_utils functions while studying this crate. They should be all stable enough to document them.\r\nAlso some minor code relocation in `parse_fixture()` closer to its usage according to the advice of @matklad.\n\nCo-authored-by: Veetaha <gerzoh1@gmail.com>", "tree": {"sha": "1707b85d6e57054d3ac9bb0d089779b2d9e6da73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1707b85d6e57054d3ac9bb0d089779b2d9e6da73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fd29651b4f2bca8a36685a49d35cd349692984a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeMWcqCRBK7hj4Ov3rIwAAdHIIABcs44R7pxgaQew5Vgc9j0vB\nqpQ5DXAab7QBHwFXo4lmX0qQokC4xS8jc0/WX5+eBmyptQ35968Kp6sNZpqJT1+N\nMZ53iTgsVnq2S3SQfUU1NDAla9GF1KhzgrrhwjySr3JPNFGL9b/NMkqFFpoI21Oz\ni/avhK2oBHMovXY8urh0yrQ/QYBTwiwSZms0anJOjBpZYoCNrNxSqXmg6oKhWanb\nUvlcMoFL0Jj39flsHfzQ/MPtB0DGZJP/YHPR1GLi/53PslSiJKjXuzFJpSQA/EpI\nQ9zUm+qX1TppKPSbAF49FqvpHfPzQg/8RCgFMwkT/cjJzBAJLsaF599om+xrPJ0=\n=y93K\n-----END PGP SIGNATURE-----\n", "payload": "tree 1707b85d6e57054d3ac9bb0d089779b2d9e6da73\nparent 7a2b87db734162f02f554f7876f3ae0f21a36a60\nparent 5e1ae1d7aa9d83406de4881be37b39ed457e3bda\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1580295978 +0000\ncommitter GitHub <noreply@github.com> 1580295978 +0000\n\nMerge #2931\n\n2931: Added documentation to test_utils r=matklad a=Veetaha\n\nAdded some doc comments to test_utils functions while studying this crate. They should be all stable enough to document them.\r\nAlso some minor code relocation in `parse_fixture()` closer to its usage according to the advice of @matklad.\n\nCo-authored-by: Veetaha <gerzoh1@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fd29651b4f2bca8a36685a49d35cd349692984a", "html_url": "https://github.com/rust-lang/rust/commit/6fd29651b4f2bca8a36685a49d35cd349692984a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fd29651b4f2bca8a36685a49d35cd349692984a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a2b87db734162f02f554f7876f3ae0f21a36a60", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a2b87db734162f02f554f7876f3ae0f21a36a60", "html_url": "https://github.com/rust-lang/rust/commit/7a2b87db734162f02f554f7876f3ae0f21a36a60"}, {"sha": "5e1ae1d7aa9d83406de4881be37b39ed457e3bda", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1ae1d7aa9d83406de4881be37b39ed457e3bda", "html_url": "https://github.com/rust-lang/rust/commit/5e1ae1d7aa9d83406de4881be37b39ed457e3bda"}], "stats": {"total": 80, "additions": 56, "deletions": 24}, "files": [{"sha": "265fcf8da088fa2f13c005af6d7e82a26d5b4b8d", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6fd29651b4f2bca8a36685a49d35cd349692984a/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd29651b4f2bca8a36685a49d35cd349692984a/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=6fd29651b4f2bca8a36685a49d35cd349692984a", "patch": "@@ -21,6 +21,12 @@ pub use difference::Changeset as __Changeset;\n \n pub const CURSOR_MARKER: &str = \"<|>\";\n \n+/// Asserts that two strings are equal, otherwise displays a rich diff between them.\n+///\n+/// The diff shows changes from the \"original\" left string to the \"actual\" right string.\n+///\n+/// All arguments starting from and including the 3rd one are passed to\n+/// `eprintln!()` macro in case of text inequality.\n #[macro_export]\n macro_rules! assert_eq_text {\n     ($left:expr, $right:expr) => {\n@@ -42,13 +48,16 @@ macro_rules! assert_eq_text {\n     }};\n }\n \n+/// Infallible version of `try_extract_offset()`.\n pub fn extract_offset(text: &str) -> (TextUnit, String) {\n     match try_extract_offset(text) {\n         None => panic!(\"text should contain cursor marker\"),\n         Some(result) => result,\n     }\n }\n \n+/// Returns the offset of the first occurence of `<|>` marker and the copy of `text`\n+/// without the marker.\n fn try_extract_offset(text: &str) -> Option<(TextUnit, String)> {\n     let cursor_pos = text.find(CURSOR_MARKER)?;\n     let mut new_text = String::with_capacity(text.len() - CURSOR_MARKER.len());\n@@ -58,13 +67,16 @@ fn try_extract_offset(text: &str) -> Option<(TextUnit, String)> {\n     Some((cursor_pos, new_text))\n }\n \n+/// Infallible version of `try_extract_range()`.\n pub fn extract_range(text: &str) -> (TextRange, String) {\n     match try_extract_range(text) {\n         None => panic!(\"text should contain cursor marker\"),\n         Some(result) => result,\n     }\n }\n \n+/// Returns `TextRange` between the first two markers `<|>...<|>` and the copy\n+/// of `text` without both of these markers.\n fn try_extract_range(text: &str) -> Option<(TextRange, String)> {\n     let (start, text) = try_extract_offset(text)?;\n     let (end, text) = try_extract_offset(&text)?;\n@@ -85,6 +97,11 @@ impl From<RangeOrOffset> for TextRange {\n     }\n }\n \n+/// Extracts `TextRange` or `TextUnit` depending on the amount of `<|>` markers\n+/// found in `text`.\n+///\n+/// # Panics\n+/// Panics if no `<|>` marker is present in the `text`.\n pub fn extract_range_or_offset(text: &str) -> (RangeOrOffset, String) {\n     if let Some((range, text)) = try_extract_range(text) {\n         return (RangeOrOffset::Range(range), text);\n@@ -93,7 +110,7 @@ pub fn extract_range_or_offset(text: &str) -> (RangeOrOffset, String) {\n     (RangeOrOffset::Offset(offset), text)\n }\n \n-/// Extracts ranges, marked with `<tag> </tag>` paris from the `text`\n+/// Extracts ranges, marked with `<tag> </tag>` pairs from the `text`\n pub fn extract_ranges(mut text: &str, tag: &str) -> (Vec<TextRange>, String) {\n     let open = format!(\"<{}>\", tag);\n     let close = format!(\"</{}>\", tag);\n@@ -127,9 +144,9 @@ pub fn extract_ranges(mut text: &str, tag: &str) -> (Vec<TextRange>, String) {\n     (ranges, res)\n }\n \n+/// Inserts `<|>` marker into the `text` at `offset`.\n pub fn add_cursor(text: &str, offset: TextUnit) -> String {\n-    let offset: u32 = offset.into();\n-    let offset: usize = offset as usize;\n+    let offset: usize = offset.to_usize();\n     let mut res = String::new();\n     res.push_str(&text[..offset]);\n     res.push_str(\"<|>\");\n@@ -152,19 +169,6 @@ pub struct FixtureEntry {\n ///  // - other meta\n ///  ```\n pub fn parse_fixture(fixture: &str) -> Vec<FixtureEntry> {\n-    let mut res = Vec::new();\n-    let mut buf = String::new();\n-    let mut meta: Option<&str> = None;\n-\n-    macro_rules! flush {\n-        () => {\n-            if let Some(meta) = meta {\n-                res.push(FixtureEntry { meta: meta.to_string(), text: buf.clone() });\n-                buf.clear();\n-            }\n-        };\n-    };\n-\n     let margin = fixture\n         .lines()\n         .filter(|it| it.trim_start().starts_with(\"//-\"))\n@@ -184,6 +188,19 @@ pub fn parse_fixture(fixture: &str) -> Vec<FixtureEntry> {\n             }\n         });\n \n+    let mut res = Vec::new();\n+    let mut buf = String::new();\n+    let mut meta: Option<&str> = None;\n+\n+    macro_rules! flush {\n+        () => {\n+            if let Some(meta) = meta {\n+                res.push(FixtureEntry { meta: meta.to_string(), text: buf.clone() });\n+                buf.clear();\n+            }\n+        };\n+    };\n+\n     for line in lines {\n         if line.starts_with(\"//-\") {\n             flush!();\n@@ -236,11 +253,10 @@ fn lines_match_works() {\n     assert!(!lines_match(\"b\", \"cb\"));\n }\n \n-// Compares JSON object for approximate equality.\n-// You can use `[..]` wildcard in strings (useful for OS dependent things such\n-// as paths).  You can use a `\"{...}\"` string literal as a wildcard for\n-// arbitrary nested JSON (useful for parts of object emitted by other programs\n-// (e.g. rustc) rather than Cargo itself).  Arrays are sorted before comparison.\n+/// Compares JSON object for approximate equality.\n+/// You can use `[..]` wildcard in strings (useful for OS dependent things such\n+/// as paths). You can use a `\"{...}\"` string literal as a wildcard for\n+/// arbitrary nested JSON. Arrays are sorted before comparison.\n pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a Value, &'a Value)> {\n     use serde_json::Value::*;\n     match (expected, actual) {\n@@ -286,6 +302,14 @@ pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a\n     }\n }\n \n+/// Calls callback `f` with input code and file paths of all `.rs` files from `test_data_dir`\n+/// subdirectories defined by `paths`.\n+///\n+/// If the content of the matching `.txt` file differs from the output of `f()`\n+/// the test will fail.\n+///\n+/// If there is no matching `.txt` file it will be created and filled with the\n+/// output of `f()`, but the test will fail.\n pub fn dir_tests<F>(test_data_dir: &Path, paths: &[&str], f: F)\n where\n     F: Fn(&str, &Path) -> String,\n@@ -307,6 +331,7 @@ where\n     }\n }\n \n+/// Collects all `.rs` files from `test_data_dir` subdirectories defined by `paths`.\n pub fn collect_tests(test_data_dir: &Path, paths: &[&str]) -> Vec<(PathBuf, String)> {\n     paths\n         .iter()\n@@ -321,6 +346,7 @@ pub fn collect_tests(test_data_dir: &Path, paths: &[&str]) -> Vec<(PathBuf, Stri\n         .collect()\n }\n \n+/// Collects paths to all `.rs` files from `dir` in a sorted `Vec<PathBuf>`.\n fn test_from_dir(dir: &Path) -> Vec<PathBuf> {\n     let mut acc = Vec::new();\n     for file in fs::read_dir(&dir).unwrap() {\n@@ -334,6 +360,7 @@ fn test_from_dir(dir: &Path) -> Vec<PathBuf> {\n     acc\n }\n \n+/// Returns the path to the root directory of `rust-analyzer` project.\n pub fn project_dir() -> PathBuf {\n     let dir = env!(\"CARGO_MANIFEST_DIR\");\n     PathBuf::from(dir).parent().unwrap().parent().unwrap().to_owned()\n@@ -356,6 +383,9 @@ pub fn read_text(path: &Path) -> String {\n         .replace(\"\\r\\n\", \"\\n\")\n }\n \n+/// Returns `false` if slow tests should not run, otherwise returns `true` and\n+/// also creates a file at `./target/.slow_tests_cookie` which serves as a flag\n+/// that slow tests did run.\n pub fn skip_slow_tests() -> bool {\n     let should_skip = std::env::var(\"CI\").is_err() && std::env::var(\"RUN_SLOW_TESTS\").is_err();\n     if should_skip {\n@@ -367,8 +397,9 @@ pub fn skip_slow_tests() -> bool {\n     should_skip\n }\n \n-const REWRITE: bool = false;\n-\n+/// Asserts that `expected` and `actual` strings are equal. If they differ only\n+/// in trailing or leading whitespace the test won't fail and\n+/// the contents of `actual` will be written to the file located at `path`.\n fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n     if expected == actual {\n         return;\n@@ -381,6 +412,7 @@ fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n         fs::write(path, actual).unwrap();\n         return;\n     }\n+    const REWRITE: bool = false;\n     if REWRITE {\n         println!(\"rewriting {}\", pretty_path.display());\n         fs::write(path, actual).unwrap();"}, {"sha": "f8fabfaff90324a327858bb04d24b4a053ce5213", "filename": "crates/test_utils/src/marks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fd29651b4f2bca8a36685a49d35cd349692984a/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd29651b4f2bca8a36685a49d35cd349692984a/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmarks.rs?ref=6fd29651b4f2bca8a36685a49d35cd349692984a", "patch": "@@ -1,4 +1,4 @@\n-//! This module implements manually tracked test coverage, which useful for\n+//! This module implements manually tracked test coverage, which is useful for\n //! quickly finding a test responsible for testing a particular bit of code.\n //!\n //! See <https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html>"}]}