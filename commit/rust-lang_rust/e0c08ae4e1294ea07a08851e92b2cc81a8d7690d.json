{"sha": "e0c08ae4e1294ea07a08851e92b2cc81a8d7690d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwYzA4YWU0ZTEyOTRlYTA3YTA4ODUxZTkyYjJjYzgxYThkNzY5MGQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-26T02:08:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-26T02:08:56Z"}, "message": "Rollup merge of #74477 - chansuke:sys-wasm-unsafe-op-in-unsafe-fn, r=Mark-Simulacrum\n\n`#[deny(unsafe_op_in_unsafe_fn)]` in sys/wasm\n\nThis is part of #73904.\n\nThis encloses unsafe operations in unsafe fn in `libstd/sys/wasm`.\n\n@rustbot modify labels: F-unsafe-block-in-unsafe-fn", "tree": {"sha": "f9822440b5f0302afe9c13a290568b11ed17adc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9822440b5f0302afe9c13a290568b11ed17adc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfli+5CRBK7hj4Ov3rIwAAdHIIAABrIWSI1OcHBhp/TsiaWbPH\ntVt2YiBc8Ve7n8d8mVi+sMlRXN2bd+y/uW7IfJ+ClN0xTXiIn9fZDwlVIH/K/uMT\nGkVs+eq1h/nhvDWC6d3XUtjjGdCfCrSImyyVH7pSnRW0uUFfVctPer7yUdfCZCYM\nO27uyT3srTWWx0OLeXD5hNuk/nmWnNIR6zOjcsDGlsZk3NQkD+g0Ppa6EEjcq86e\nRwNt+c77wXnxMU2jGRu1kj7CgAlhbi06mkFrmWeSk8CQxGsWkbGiiPc/0TCah2Im\n80+93d7U4JXYi+tMOJbL1JH2XVUDPUwCvPe+XO8SI5sctOweA1I/CGdn6b1I2Uw=\n=xlw4\n-----END PGP SIGNATURE-----\n", "payload": "tree f9822440b5f0302afe9c13a290568b11ed17adc8\nparent b6ac411f45d38d867ce9f689bbd5c3e7456d0f65\nparent d37b8cf729187e5dcabb3650031eb806d1f79770\nauthor Dylan DPC <dylan.dpc@gmail.com> 1603678136 +0100\ncommitter GitHub <noreply@github.com> 1603678136 +0100\n\nRollup merge of #74477 - chansuke:sys-wasm-unsafe-op-in-unsafe-fn, r=Mark-Simulacrum\n\n`#[deny(unsafe_op_in_unsafe_fn)]` in sys/wasm\n\nThis is part of #73904.\n\nThis encloses unsafe operations in unsafe fn in `libstd/sys/wasm`.\n\n@rustbot modify labels: F-unsafe-block-in-unsafe-fn\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d", "html_url": "https://github.com/rust-lang/rust/commit/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6ac411f45d38d867ce9f689bbd5c3e7456d0f65", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6ac411f45d38d867ce9f689bbd5c3e7456d0f65", "html_url": "https://github.com/rust-lang/rust/commit/b6ac411f45d38d867ce9f689bbd5c3e7456d0f65"}, {"sha": "d37b8cf729187e5dcabb3650031eb806d1f79770", "url": "https://api.github.com/repos/rust-lang/rust/commits/d37b8cf729187e5dcabb3650031eb806d1f79770", "html_url": "https://github.com/rust-lang/rust/commit/d37b8cf729187e5dcabb3650031eb806d1f79770"}], "stats": {"total": 53, "additions": 38, "deletions": 15}, "files": [{"sha": "b61a7872265f350a8b82a3779bc2b8cc64dd2281", "filename": "library/std/src/sys/wasm/alloc.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Falloc.rs?ref=e0c08ae4e1294ea07a08851e92b2cc81a8d7690d", "patch": "@@ -24,26 +24,34 @@ static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n unsafe impl GlobalAlloc for System {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n+        // Calling malloc() is safe because preconditions on this function match the trait method preconditions.\n         let _lock = lock::lock();\n-        DLMALLOC.malloc(layout.size(), layout.align())\n+        unsafe { DLMALLOC.malloc(layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n+        // Calling calloc() is safe because preconditions on this function match the trait method preconditions.\n         let _lock = lock::lock();\n-        DLMALLOC.calloc(layout.size(), layout.align())\n+        unsafe { DLMALLOC.calloc(layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n+        // Calling free() is safe because preconditions on this function match the trait method preconditions.\n         let _lock = lock::lock();\n-        DLMALLOC.free(ptr, layout.size(), layout.align())\n+        unsafe { DLMALLOC.free(ptr, layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n+        // Calling realloc() is safe because preconditions on this function match the trait method preconditions.\n         let _lock = lock::lock();\n-        DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n+        unsafe { DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size) }\n     }\n }\n "}, {"sha": "0c1c076cc914241baa16f13bce8a9e057500842d", "filename": "library/std/src/sys/wasm/condvar_atomics.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs?ref=e0c08ae4e1294ea07a08851e92b2cc81a8d7690d", "patch": "@@ -44,13 +44,19 @@ impl Condvar {\n \n     pub unsafe fn notify_one(&self) {\n         self.cnt.fetch_add(1, SeqCst);\n-        wasm32::memory_atomic_notify(self.ptr(), 1);\n+        // SAFETY: ptr() is always valid\n+        unsafe {\n+            wasm32::memory_atomic_notify(self.ptr(), 1);\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn notify_all(&self) {\n         self.cnt.fetch_add(1, SeqCst);\n-        wasm32::memory_atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n+        // SAFETY: ptr() is always valid\n+        unsafe {\n+            wasm32::memory_atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n+        }\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {"}, {"sha": "82683c0f624cf88487ca777b748493eb5a4d4d4a", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=e0c08ae4e1294ea07a08851e92b2cc81a8d7690d", "patch": "@@ -14,6 +14,8 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n pub mod alloc;\n pub mod args;\n #[path = \"../unsupported/cmath.rs\"]"}, {"sha": "479182ffa44d5eec624d026a1bc8f786cf5ba1b4", "filename": "library/std/src/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0c08ae4e1294ea07a08851e92b2cc81a8d7690d/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=e0c08ae4e1294ea07a08851e92b2cc81a8d7690d", "patch": "@@ -28,11 +28,14 @@ impl Mutex {\n \n     pub unsafe fn lock(&self) {\n         while !self.try_lock() {\n-            let val = wasm32::memory_atomic_wait32(\n-                self.ptr(),\n-                1,  // we expect our mutex is locked\n-                -1, // wait infinitely\n-            );\n+            // SAFETY: the caller must uphold the safety contract for `memory_atomic_wait32`.\n+            let val = unsafe {\n+                wasm32::memory_atomic_wait32(\n+                    self.ptr(),\n+                    1,  // we expect our mutex is locked\n+                    -1, // wait infinitely\n+                )\n+            };\n             // we should have either woke up (0) or got a not-equal due to a\n             // race (1). We should never time out (2)\n             debug_assert!(val == 0 || val == 1);\n@@ -93,19 +96,20 @@ impl ReentrantMutex {\n     pub unsafe fn lock(&self) {\n         let me = thread::my_id();\n         while let Err(owner) = self._try_lock(me) {\n-            let val = wasm32::memory_atomic_wait32(self.ptr(), owner as i32, -1);\n+            // SAFETY: the caller must gurantee that `self.ptr()` and `owner` are valid i32.\n+            let val = unsafe { wasm32::memory_atomic_wait32(self.ptr(), owner as i32, -1) };\n             debug_assert!(val == 0 || val == 1);\n         }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        self._try_lock(thread::my_id()).is_ok()\n+        unsafe { self._try_lock(thread::my_id()).is_ok() }\n     }\n \n     #[inline]\n     unsafe fn _try_lock(&self, id: u32) -> Result<(), u32> {\n-        let id = id.checked_add(1).unwrap(); // make sure `id` isn't 0\n+        let id = id.checked_add(1).unwrap();\n         match self.owner.compare_exchange(0, id, SeqCst, SeqCst) {\n             // we transitioned from unlocked to locked\n             Ok(_) => {\n@@ -132,7 +136,10 @@ impl ReentrantMutex {\n         match *self.recursions.get() {\n             0 => {\n                 self.owner.swap(0, SeqCst);\n-                wasm32::memory_atomic_notify(self.ptr() as *mut i32, 1); // wake up one waiter, if any\n+                // SAFETY: the caller must gurantee that `self.ptr()` is valid i32.\n+                unsafe {\n+                    wasm32::atomic_notify(self.ptr() as *mut i32, 1);\n+                } // wake up one waiter, if any\n             }\n             ref mut n => *n -= 1,\n         }"}]}