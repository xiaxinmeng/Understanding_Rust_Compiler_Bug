{"sha": "c848ed1e9862a527e0a6f16ef235b41f98baa419", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NDhlZDFlOTg2MmE1MjdlMGE2ZjE2ZWYyMzViNDFmOThiYWE0MTk=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-02-01T01:27:38Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-02-01T01:27:38Z"}, "message": "Merge branch 'master' into forgraydon-elseif", "tree": {"sha": "3ad344301bdcff06081a1a38d7cb709c08d66668", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ad344301bdcff06081a1a38d7cb709c08d66668"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c848ed1e9862a527e0a6f16ef235b41f98baa419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c848ed1e9862a527e0a6f16ef235b41f98baa419", "html_url": "https://github.com/rust-lang/rust/commit/c848ed1e9862a527e0a6f16ef235b41f98baa419", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c848ed1e9862a527e0a6f16ef235b41f98baa419/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "214c32393a9d28436dd782c9ea6e3e32d3baba2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/214c32393a9d28436dd782c9ea6e3e32d3baba2e", "html_url": "https://github.com/rust-lang/rust/commit/214c32393a9d28436dd782c9ea6e3e32d3baba2e"}, {"sha": "784b2decf2ce4233a022cf221b1ec744b755c3ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/784b2decf2ce4233a022cf221b1ec744b755c3ed", "html_url": "https://github.com/rust-lang/rust/commit/784b2decf2ce4233a022cf221b1ec744b755c3ed"}], "stats": {"total": 324, "additions": 194, "deletions": 130}, "files": [{"sha": "fbc2920fd60854422f354205bbfadc411b941be6", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -30,6 +30,7 @@\n *.tp\n *.vr\n *.swp\n+*.tmp\n .hg/\n .hgignore\n .cproject"}, {"sha": "ac7dfcbbb719188a24030e0391c7b0acb4f934f1", "filename": "src/Makefile", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -510,18 +510,25 @@ TEST_XFAILS_RUSTC := $(filter-out \\\n                         writealias.rs \\\n                         ) \\\n                       $(addprefix test/compile-fail/, \\\n+                        alt-tag-nullary.rs \\\n+                        alt-tag-unary.rs \\\n                         arg-count-mismatch.rs \\\n                         arg-type-mismatch.rs \\\n                         bad-expr-path.rs \\\n                         bad-expr-path2.rs \\\n+                        bogus-tag.rs \\\n                         import.rs \\\n                         import2.rs \\\n                         import3.rs \\\n                         import4.rs \\\n                         import-loop.rs \\\n                         import-loop-2.rs \\\n                         multiline-comment-line-tracking.rs \\\n+                        output-type-mismatch.rs \\\n+                        rec-missing-fields.rs \\\n+                        type-shadow.rs \\\n                         while-type-error.rs \\\n+                        wrong-ret-type.rs \\\n                         ), \\\n                       $(wildcard test/*/*.rs test/*/*.rc))\n "}, {"sha": "8eb614e5da385b8f2eb711cc47caa44396861d60", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 163, "deletions": 107, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -63,6 +63,7 @@ type tag_info = rec(type_handle th,\n state type crate_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n                             target_data td,\n+                            ValueRef crate_ptr,\n                             hashmap[str, ValueRef] upcalls,\n                             hashmap[str, ValueRef] intrinsics,\n                             hashmap[str, ValueRef] item_names,\n@@ -687,25 +688,25 @@ fn llalign_of(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntCast(lib.llvm.llvm.LLVMAlignOf(t), T_int(), False);\n }\n \n-fn size_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+fn size_of(@block_ctxt cx, @ty.t t) -> result {\n     if (!ty.type_has_dynamic_size(t)) {\n-        ret llsize_of(type_of(cx.fcx.ccx, t));\n+        ret res(cx, llsize_of(type_of(cx.fcx.ccx, t)));\n     }\n     ret dynamic_size_of(cx, t);\n }\n \n-fn align_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+fn align_of(@block_ctxt cx, @ty.t t) -> result {\n     if (!ty.type_has_dynamic_size(t)) {\n-        ret llalign_of(type_of(cx.fcx.ccx, t));\n+        ret res(cx, llalign_of(type_of(cx.fcx.ccx, t)));\n     }\n     ret dynamic_align_of(cx, t);\n }\n \n-fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n     alt (t.struct) {\n         case (ty.ty_param(?p)) {\n             auto szptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n-            ret cx.build.Load(szptr);\n+            ret res(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n         }\n         case (ty.ty_tup(?elts)) {\n             //\n@@ -718,51 +719,63 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n             //\n             auto off = C_int(0);\n             auto max_align = C_int(1);\n+            auto bcx = cx;\n             for (@ty.t e in elts) {\n-                auto elt_align = align_of(cx, e);\n-                auto elt_size = size_of(cx, e);\n-                auto aligned_off = align_to(cx, off, elt_align);\n-                off = cx.build.Add(aligned_off, elt_size);\n-                max_align = umax(cx, max_align, elt_align);\n+                auto elt_align = align_of(bcx, e);\n+                bcx = elt_align.bcx;\n+                auto elt_size = size_of(bcx, e);\n+                bcx = elt_size.bcx;\n+                auto aligned_off = align_to(bcx, off, elt_align.val);\n+                off = cx.build.Add(aligned_off, elt_size.val);\n+                max_align = umax(bcx, max_align, elt_align.val);\n             }\n-            off = align_to(cx, off, max_align);\n-            ret off;\n+            off = align_to(bcx, off, max_align);\n+            ret res(bcx, off);\n         }\n         case (ty.ty_rec(?flds)) {\n             auto off = C_int(0);\n             auto max_align = C_int(1);\n+            auto bcx = cx;\n             for (ty.field f in flds) {\n-                auto elt_align = align_of(cx, f.ty);\n-                auto elt_size = size_of(cx, f.ty);\n-                auto aligned_off = align_to(cx, off, elt_align);\n-                off = cx.build.Add(aligned_off, elt_size);\n-                max_align = umax(cx, max_align, elt_align);\n+                auto elt_align = align_of(bcx, f.ty);\n+                bcx = elt_align.bcx;\n+                auto elt_size = size_of(bcx, f.ty);\n+                bcx = elt_size.bcx;\n+                auto aligned_off = align_to(bcx, off, elt_align.val);\n+                off = cx.build.Add(aligned_off, elt_size.val);\n+                max_align = umax(bcx, max_align, elt_align.val);\n             }\n-            off = align_to(cx, off, max_align);\n-            ret off;\n+            off = align_to(bcx, off, max_align);\n+            ret res(bcx, off);\n         }\n     }\n }\n \n-fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n     alt (t.struct) {\n         case (ty.ty_param(?p)) {\n             auto aptr = field_of_tydesc(cx, t, abi.tydesc_field_align);\n-            ret cx.build.Load(aptr);\n+            ret res(aptr.bcx, aptr.bcx.build.Load(aptr.val));\n         }\n         case (ty.ty_tup(?elts)) {\n             auto a = C_int(1);\n+            auto bcx = cx;\n             for (@ty.t e in elts) {\n-                a = umax(cx, a, align_of(cx, e));\n+                auto align = align_of(bcx, e);\n+                bcx = align.bcx;\n+                a = umax(bcx, a, align.val);\n             }\n-            ret a;\n+            ret res(bcx, a);\n         }\n         case (ty.ty_rec(?flds)) {\n             auto a = C_int(1);\n+            auto bcx = cx;\n             for (ty.field f in flds) {\n-                a = umax(cx, a, align_of(cx, f.ty));\n+                auto align = align_of(bcx, f.ty);\n+                bcx = align.bcx;\n+                a = umax(bcx, a, align.val);\n             }\n-            ret a;\n+            ret res(bcx, a);\n         }\n     }\n }\n@@ -774,7 +787,7 @@ fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n // align_of, above.\n \n fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n-                ValueRef base, vec[int] ixs) -> ValueRef {\n+                ValueRef base, vec[int] ixs) -> result {\n \n     check (ty.type_is_tup_like(t));\n \n@@ -785,7 +798,7 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n         for (int i in ixs) {\n             v += C_int(i);\n         }\n-        ret cx.build.GEP(base, v);\n+        ret res(cx, cx.build.GEP(base, v));\n     }\n \n     // It is a dynamic-containing type that, if we convert directly to an LLVM\n@@ -856,14 +869,16 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n \n     auto s = split_type(t, ixs, 0u);\n     auto prefix_ty = ty.plain_ty(ty.ty_tup(s.prefix));\n-    auto sz = size_of(cx, prefix_ty);\n-    auto raw = cx.build.PointerCast(base, T_ptr(T_i8()));\n-    auto bumped = cx.build.GEP(raw, vec(sz));\n+    auto bcx = cx;\n+    auto sz = size_of(bcx, prefix_ty);\n+    bcx = sz.bcx;\n+    auto raw = bcx.build.PointerCast(base, T_ptr(T_i8()));\n+    auto bumped = bcx.build.GEP(raw, vec(sz.val));\n     alt (s.target.struct) {\n-        case (ty.ty_param(_)) { ret bumped; }\n+        case (ty.ty_param(_)) { ret res(bcx, bumped); }\n         case (_) {\n-            auto ty = T_ptr(type_of(cx.fcx.ccx, s.target));\n-            ret cx.build.PointerCast(bumped, ty);\n+            auto ty = T_ptr(type_of(bcx.fcx.ccx, s.target));\n+            ret res(bcx, bcx.build.PointerCast(bumped, ty));\n         }\n     }\n }\n@@ -893,9 +908,10 @@ fn trans_malloc(@block_ctxt cx, @ty.t t) -> result {\n // Given a type and a field index into its corresponding type descriptor,\n // returns an LLVM ValueRef of that field from the tydesc, generating the\n // tydesc if necessary.\n-fn field_of_tydesc(@block_ctxt cx, @ty.t t, int field) -> ValueRef {\n+fn field_of_tydesc(@block_ctxt cx, @ty.t t, int field) -> result {\n     auto tydesc = get_tydesc(cx, t);\n-    ret cx.build.GEP(tydesc, vec(C_int(0), C_int(field)));\n+    ret res(tydesc.bcx,\n+            tydesc.bcx.build.GEP(tydesc.val, vec(C_int(0), C_int(field))));\n }\n \n // Given a type containing ty params, build a vector containing a ValueRef for\n@@ -940,10 +956,12 @@ fn linearize_ty_params(@block_ctxt cx, @ty.t t)\n     ret tup(x.defs, x.vals);\n }\n \n-fn get_tydesc(&@block_ctxt cx, @ty.t t) -> ValueRef {\n+fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt (ty.type_param(t)) {\n-        case (some[ast.def_id](?id)) { ret cx.fcx.lltydescs.get(id); }\n+        case (some[ast.def_id](?id)) {\n+            ret res(cx, cx.fcx.lltydescs.get(id));\n+        }\n         case (none[ast.def_id])      { /* fall through */ }\n     }\n \n@@ -953,21 +971,44 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> ValueRef {\n     if (ty.count_ty_params(t) > 0u) {\n         auto tys = linearize_ty_params(cx, t);\n \n+        check (n_params == _vec.len[ast.def_id](tys._0));\n+        check (n_params == _vec.len[ValueRef](tys._1));\n+\n         if (!cx.fcx.ccx.tydescs.contains_key(t)) {\n             make_tydesc(cx.fcx.ccx, t, tys._0);\n         }\n \n         auto root = cx.fcx.ccx.tydescs.get(t);\n \n-        cx.fcx.ccx.sess.unimpl(\"derived type descriptors\");\n+        auto tydescs = cx.build.Alloca(T_array(T_ptr(T_tydesc()), n_params));\n+        auto i = 0;\n+        for (ValueRef td in tys._1) {\n+            auto tdp = cx.build.GEP(tydescs, vec(C_int(0), C_int(i)));\n+            cx.build.Store(td, tdp);\n+        }\n+\n+        auto bcx = cx;\n+        auto sz = size_of(bcx, t);\n+        bcx = sz.bcx;\n+        auto align = align_of(bcx, t);\n+        bcx = align.bcx;\n+\n+        auto v = trans_upcall(bcx, \"upcall_get_type_desc\",\n+                              vec(p2i(bcx.fcx.ccx.crate_ptr),\n+                                  sz.val,\n+                                  align.val,\n+                                  C_int(n_params as int),\n+                                  bcx.build.PtrToInt(tydescs, T_int())));\n+\n+        ret res(v.bcx, v.bcx.build.IntToPtr(v.val, T_ptr(T_tydesc())));\n     }\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n     if (!cx.fcx.ccx.tydescs.contains_key(t)) {\n         let vec[ast.def_id] defs = vec();\n         make_tydesc(cx.fcx.ccx, t, defs);\n     }\n-    ret cx.fcx.ccx.tydescs.get(t);\n+    ret res(cx, cx.fcx.ccx.tydescs.get(t));\n }\n \n fn make_tydesc(@crate_ctxt cx, @ty.t t, vec[ast.def_id] typaram_defs) {\n@@ -1437,20 +1478,20 @@ fn iter_sequence(@block_ctxt cx,\n                                           C_int(abi.vec_elt_fill)));\n \n         auto llunit_ty = type_of(cx.fcx.ccx, elt_ty);\n-        auto unit_sz = size_of(cx, elt_ty);\n+        auto bcx = cx;\n+        auto unit_sz = size_of(bcx, elt_ty);\n+        bcx = unit_sz.bcx;\n \n-        auto len = cx.build.Load(lenptr);\n+        auto len = bcx.build.Load(lenptr);\n         if (trailing_null) {\n-            len = cx.build.Sub(len, unit_sz);\n+            len = bcx.build.Sub(len, unit_sz.val);\n         }\n \n-        auto r = res(cx, C_nil());\n-\n         auto cond_cx = new_scope_block_ctxt(cx, \"sequence-iter cond\");\n         auto body_cx = new_scope_block_ctxt(cx, \"sequence-iter body\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n \n-        cx.build.Br(cond_cx.llbb);\n+        bcx.build.Br(cond_cx.llbb);\n \n         auto ix = cond_cx.build.Phi(T_int(), vec(C_int(0)), vec(cx.llbb));\n         auto scaled_ix = cond_cx.build.Phi(T_int(),\n@@ -1465,7 +1506,7 @@ fn iter_sequence(@block_ctxt cx,\n                           load_scalar_or_boxed(body_cx, elt, elt_ty),\n                           elt_ty);\n         auto next_ix = body_res.bcx.build.Add(ix, C_int(1));\n-        auto next_scaled_ix = body_res.bcx.build.Add(scaled_ix, unit_sz);\n+        auto next_scaled_ix = body_res.bcx.build.Add(scaled_ix, unit_sz.val);\n \n         cond_cx.build.AddIncomingToPhi(ix, vec(next_ix),\n                                        vec(body_res.bcx.llbb));\n@@ -1504,7 +1545,8 @@ fn call_tydesc_glue_full(@block_ctxt cx, ValueRef v,\n }\n \n fn call_tydesc_glue(@block_ctxt cx, ValueRef v, @ty.t t, int field) {\n-    call_tydesc_glue_full(cx, v, get_tydesc(cx, t), field);\n+    auto td = get_tydesc(cx, t);\n+    call_tydesc_glue_full(td.bcx, v, td.val, field);\n }\n \n fn incr_all_refcnts(@block_ctxt cx,\n@@ -1565,8 +1607,8 @@ fn memcpy_ty(@block_ctxt cx,\n              @ty.t t) -> result {\n     if (ty.type_has_dynamic_size(t)) {\n         auto llszptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n-        auto llsz = cx.build.Load(llszptr);\n-        ret call_memcpy(cx, dst, src, llsz);\n+        auto llsz = llszptr.bcx.build.Load(llszptr.val);\n+        ret call_memcpy(llszptr.bcx, dst, src, llsz);\n \n     } else {\n         ret res(cx, cx.build.Store(cx.build.Load(src), dst));\n@@ -2182,14 +2224,17 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     auto tys = ty.resolve_ty_params(fn_item, monoty);\n \n                     if (_vec.len[@ty.t](tys) != 0u) {\n+                        auto bcx = cx;\n                         let vec[ValueRef] tydescs = vec();\n                         for (@ty.t t in tys) {\n-                            append[ValueRef](tydescs,\n-                                             get_tydesc(cx, t));\n+                            auto td = get_tydesc(bcx, t);\n+                            bcx = td.bcx;\n+                            append[ValueRef](tydescs, td.val);\n                         }\n                         auto gen = rec( item_type = ty.item_ty(fn_item)._1,\n                                         tydescs = tydescs );\n-                        lv = rec(generic = some[generic_info](gen)\n+                        lv = rec(res = res(bcx, lv.res.val),\n+                                 generic = some[generic_info](gen)\n                                  with lv);\n                     }\n \n@@ -2236,12 +2281,12 @@ fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n         case (ty.ty_tup(?fields)) {\n             let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n-            ret lval_mem(r.bcx, v);\n+            ret lval_mem(v.bcx, v.val);\n         }\n         case (ty.ty_rec(?fields)) {\n             let uint ix = ty.field_idx(cx.fcx.ccx.sess, sp, field, fields);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n-            ret lval_mem(r.bcx, v);\n+            ret lval_mem(v.bcx, v.val);\n         }\n         case (ty.ty_obj(?methods)) {\n             let uint ix = ty.method_idx(cx.fcx.ccx.sess, sp, field, methods);\n@@ -2267,20 +2312,22 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     lv = autoderef(lv.bcx, lv.val, ty.expr_ty(base));\n     auto ix = trans_expr(lv.bcx, idx);\n     auto v = lv.val;\n+    auto bcx = ix.bcx;\n \n     auto llunit_ty = node_type(cx.fcx.ccx, ann);\n-    auto unit_sz = size_of(cx, node_ann_type(cx.fcx.ccx, ann));\n-    auto scaled_ix = ix.bcx.build.Mul(ix.val, unit_sz);\n+    auto unit_sz = size_of(bcx, node_ann_type(cx.fcx.ccx, ann));\n+    bcx = unit_sz.bcx;\n+    auto scaled_ix = bcx.build.Mul(ix.val, unit_sz.val);\n \n-    auto lim = ix.bcx.build.GEP(v, vec(C_int(0), C_int(abi.vec_elt_fill)));\n-    lim = ix.bcx.build.Load(lim);\n+    auto lim = bcx.build.GEP(v, vec(C_int(0), C_int(abi.vec_elt_fill)));\n+    lim = bcx.build.Load(lim);\n \n-    auto bounds_check = ix.bcx.build.ICmp(lib.llvm.LLVMIntULT,\n-                                          scaled_ix, lim);\n+    auto bounds_check = bcx.build.ICmp(lib.llvm.LLVMIntULT,\n+                                       scaled_ix, lim);\n \n-    auto fail_cx = new_sub_block_ctxt(ix.bcx, \"fail\");\n-    auto next_cx = new_sub_block_ctxt(ix.bcx, \"next\");\n-    ix.bcx.build.CondBr(bounds_check, next_cx.llbb, fail_cx.llbb);\n+    auto fail_cx = new_sub_block_ctxt(bcx, \"fail\");\n+    auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+    bcx.build.CondBr(bounds_check, next_cx.llbb, fail_cx.llbb);\n \n     // fail: bad bounds check.\n     auto fail_res = trans_fail(fail_cx, sp, \"bounds check\");\n@@ -2590,7 +2637,8 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                               vec(C_int(0),\n                                   C_int(abi.closure_elt_tydesc)));\n             auto bindings_tydesc = get_tydesc(bcx, bindings_ty);\n-            bcx.build.Store(bindings_tydesc, bound_tydesc);\n+            bcx = bindings_tydesc.bcx;\n+            bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n \n             // Store thunk-target.\n             auto bound_target =\n@@ -2740,16 +2788,18 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     }\n \n     auto llunit_ty = type_of(cx.fcx.ccx, unit_ty);\n-    auto unit_sz = size_of(cx, unit_ty);\n+    auto bcx = cx;\n+    auto unit_sz = size_of(bcx, unit_ty);\n+    bcx = unit_sz.bcx;\n     auto data_sz = llvm.LLVMConstMul(C_int(_vec.len[@ast.expr](args) as int),\n-                                     unit_sz);\n+                                     unit_sz.val);\n \n     // FIXME: pass tydesc properly.\n-    auto sub = trans_upcall(cx, \"upcall_new_vec\", vec(data_sz, C_int(0)));\n+    auto sub = trans_upcall(bcx, \"upcall_new_vec\", vec(data_sz, C_int(0)));\n \n-    auto llty = type_of(cx.fcx.ccx, t);\n+    auto llty = type_of(bcx.fcx.ccx, t);\n     auto vec_val = sub.bcx.build.IntToPtr(sub.val, llty);\n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, vec_val, t));\n+    find_scope_cx(bcx).cleanups += clean(bind drop_ty(_, vec_val, t));\n \n     auto body = sub.bcx.build.GEP(vec_val, vec(C_int(0),\n                                                C_int(abi.vec_elt_data)));\n@@ -3044,8 +3094,8 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n         }\n         case (_) {\n             if (middle.ty.type_has_dynamic_size(ty)) {\n-                auto llsz = size_of(cx, ty);\n-                bcx = call_bzero(cx, llptr, llsz).bcx;\n+                auto llsz = size_of(bcx, ty);\n+                bcx = call_bzero(llsz.bcx, llptr, llsz.val).bcx;\n \n             } else {\n                 auto llty = type_of(bcx.fcx.ccx, ty);\n@@ -3145,7 +3195,10 @@ fn trans_block_cleanups(@block_ctxt cx,\n         check (_vec.len[cleanup](cleanup_cx.cleanups) == 0u);\n     }\n \n-    for (cleanup c in cleanup_cx.cleanups) {\n+    auto i = _vec.len[cleanup](cleanup_cx.cleanups);\n+    while (i > 0u) {\n+        i -= 1u;\n+        auto c = cleanup_cx.cleanups.(i);\n         alt (c) {\n             case (clean(?cfn)) {\n                 bcx = cfn(bcx).bcx;\n@@ -3176,14 +3229,16 @@ iter block_locals(&ast.block b) -> @ast.local {\n fn alloc_local(@block_ctxt cx, @ast.local local) -> result {\n     auto t = node_ann_type(cx.fcx.ccx, local.ann);\n     auto val = C_int(0);\n+    auto bcx = cx;\n     if (ty.type_has_dynamic_size(t)) {\n-        auto n = size_of(cx, t);\n-        val = cx.build.ArrayAlloca(T_i8(), n);\n+        auto n = size_of(bcx, t);\n+        bcx = n.bcx;\n+        val = bcx.build.ArrayAlloca(T_i8(), n.val);\n     } else {\n-        val = cx.build.Alloca(type_of(cx.fcx.ccx, t));\n+        val = bcx.build.Alloca(type_of(cx.fcx.ccx, t));\n     }\n-    cx.fcx.lllocals.insert(local.id, val);\n-    ret res(cx, val);\n+    bcx.fcx.lllocals.insert(local.id, val);\n+    ret res(bcx, val);\n }\n \n fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n@@ -3523,43 +3578,45 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n \n         // Malloc a box for the body.\n         auto r = trans_malloc_inner(bcx, llobj_body_ty);\n+        bcx = r.bcx;\n         auto box = r.val;\n-        auto rc = r.bcx.build.GEP(box,\n+        auto rc = bcx.build.GEP(box,\n+                                vec(C_int(0),\n+                                    C_int(abi.box_rc_field_refcnt)));\n+        auto body = bcx.build.GEP(box,\n                                   vec(C_int(0),\n-                                      C_int(abi.box_rc_field_refcnt)));\n-        auto body = r.bcx.build.GEP(box,\n-                                    vec(C_int(0),\n-                                        C_int(abi.box_rc_field_body)));\n-        r.bcx.build.Store(C_int(1), rc);\n+                                      C_int(abi.box_rc_field_body)));\n+        bcx.build.Store(C_int(1), rc);\n \n         // Store body tydesc.\n         auto body_tydesc =\n-            r.bcx.build.GEP(body,\n-                            vec(C_int(0),\n-                                C_int(abi.obj_body_elt_tydesc)));\n+            bcx.build.GEP(body,\n+                          vec(C_int(0),\n+                              C_int(abi.obj_body_elt_tydesc)));\n \n         auto fields_tydesc = get_tydesc(r.bcx, fields_ty);\n-        r.bcx.build.Store(fields_tydesc, body_tydesc);\n+        bcx = fields_tydesc.bcx;\n+        bcx.build.Store(fields_tydesc.val, body_tydesc);\n \n         // Copy args into body fields.\n         auto body_fields =\n-            r.bcx.build.GEP(body,\n-                            vec(C_int(0),\n-                                C_int(abi.obj_body_elt_fields)));\n+            bcx.build.GEP(body,\n+                          vec(C_int(0),\n+                              C_int(abi.obj_body_elt_fields)));\n \n         let int i = 0;\n         for (ast.obj_field f in ob.fields) {\n-            auto arg = r.bcx.fcx.llargs.get(f.id);\n-            arg = load_scalar_or_boxed(r.bcx, arg, arg_tys.(i).ty);\n-            auto field = r.bcx.build.GEP(body_fields,\n+            auto arg = bcx.fcx.llargs.get(f.id);\n+            arg = load_scalar_or_boxed(bcx, arg, arg_tys.(i).ty);\n+            auto field = bcx.build.GEP(body_fields,\n                                          vec(C_int(0),C_int(i)));\n-            r = copy_ty(r.bcx, INIT, field, arg, arg_tys.(i).ty);\n+            bcx = copy_ty(bcx, INIT, field, arg, arg_tys.(i).ty).bcx;\n             i += 1;\n         }\n \n         // Store box ptr in outer pair.\n-        auto p = r.bcx.build.PointerCast(box, llbox_ty);\n-        r.bcx.build.Store(p, pair_box);\n+        auto p = bcx.build.PointerCast(box, llbox_ty);\n+        bcx.build.Store(p, pair_box);\n     }\n     bcx.build.Ret(bcx.build.Load(pair));\n }\n@@ -3980,13 +4037,9 @@ fn create_typedefs(@crate_ctxt cx) {\n     llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"rust_tydesc\"), T_tydesc());\n }\n \n-fn crate_constant(@crate_ctxt cx) -> ValueRef {\n-\n-    let ValueRef crate_ptr =\n-        llvm.LLVMAddGlobal(cx.llmod, T_crate(),\n-                           _str.buf(\"rust_crate\"));\n+fn create_crate_constant(@crate_ctxt cx) {\n \n-    let ValueRef crate_addr = p2i(crate_ptr);\n+    let ValueRef crate_addr = p2i(cx.crate_ptr);\n \n     let ValueRef activate_glue_off =\n         llvm.LLVMConstSub(p2i(cx.glues.activate_glue), crate_addr);\n@@ -3999,7 +4052,7 @@ fn crate_constant(@crate_ctxt cx) -> ValueRef {\n \n     let ValueRef crate_val =\n         C_struct(vec(C_null(T_int()),     // ptrdiff_t image_base_off\n-                     p2i(crate_ptr),      // uintptr_t self_addr\n+                     p2i(cx.crate_ptr),   // uintptr_t self_addr\n                      C_null(T_int()),     // ptrdiff_t debug_abbrev_off\n                      C_null(T_int()),     // size_t debug_abbrev_sz\n                      C_null(T_int()),     // ptrdiff_t debug_info_off\n@@ -4014,8 +4067,7 @@ fn crate_constant(@crate_ctxt cx) -> ValueRef {\n                      C_null(T_int())      // int n_libs\n                      ));\n \n-    llvm.LLVMSetInitializer(crate_ptr, crate_val);\n-    ret crate_ptr;\n+    llvm.LLVMSetInitializer(cx.crate_ptr, crate_val);\n }\n \n fn trans_main_fn(@crate_ctxt cx, ValueRef llcrate) {\n@@ -4204,6 +4256,8 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     llvm.LLVMSetDataLayout(llmod, _str.buf(x86.get_data_layout()));\n     llvm.LLVMSetTarget(llmod, _str.buf(x86.get_target_triple()));\n     auto td = mk_target_data(x86.get_data_layout());\n+    let ValueRef crate_ptr =\n+        llvm.LLVMAddGlobal(llmod, T_crate(), _str.buf(\"rust_crate\"));\n \n     llvm.LLVMSetModuleInlineAsm(llmod, _str.buf(x86.get_module_asm()));\n \n@@ -4218,6 +4272,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     auto cx = @rec(sess = sess,\n                    llmod = llmod,\n                    td = td,\n+                   crate_ptr = crate_ptr,\n                    upcalls = new_str_hash[ValueRef](),\n                    intrinsics = intrinsics,\n                    item_names = new_str_hash[ValueRef](),\n@@ -4242,8 +4297,9 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n \n     trans_mod(cx, crate.node.module);\n     trans_exit_task_glue(cx);\n+    create_crate_constant(cx);\n     if (!shared) {\n-        trans_main_fn(cx, crate_constant(cx));\n+        trans_main_fn(cx, cx.crate_ptr);\n     }\n \n     check_module(llmod);"}, {"sha": "9315488b0562e769542b61b64cc6266db5789af5", "filename": "src/test/compile-fail/infinite-vec-type-recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n \n-// error-pattern: Infinite type recursion\n+// error-pattern: infinite recursive type definition\n \n type x = vec[x];\n "}, {"sha": "2c3d642523e61105e87dc39c778c3ab35a710ccb", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n \n-io fn sub(chan[int] parent, int id) {\n+impure fn sub(chan[int] parent, int id) {\n   if (id == 0) {\n     parent <| 0;\n   } else {\n@@ -11,7 +11,7 @@ io fn sub(chan[int] parent, int id) {\n   }\n }\n \n-io fn main() {\n+impure fn main() {\n   let port[int] p = port();\n   auto child = spawn sub(chan(p), 500);\n   let int y <- p;"}, {"sha": "e0164596390da809978b6e70b649c8dee81bbd64", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -1,11 +1,11 @@\n-io fn start(chan[chan[str]] c) {\n+impure fn start(chan[chan[str]] c) {\n     let port[str] p = port();\n     c <| chan(p);\n     auto a <- p;\n     // auto b <- p; // Never read the second string.\n }\n \n-io fn main() {\n+impure fn main() {\n     let port[chan[str]] p = port();\n     auto child = spawn \"start\" start(chan(p));\n     auto c <- p;"}, {"sha": "b5bd733144c338332d68c392391bdb3c6a800ff7", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -1,4 +1,4 @@\n-io fn start(chan[int] c, int n) {\n+impure fn start(chan[int] c, int n) {\n     let int i = n;\n \n     while(i > 0) {\n@@ -7,7 +7,7 @@ io fn start(chan[int] c, int n) {\n     }\n }\n \n-io fn main() {\n+impure fn main() {\n     let port[int] p = port();\n     // Spawn a task that sends us back messages. The parent task\n     // is likely to terminate before the child completes, so from"}, {"sha": "d833c3a5810332af85f7b46eeec713ef94f0425c", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -1,11 +1,11 @@\n-io fn main() -> () {\n+impure fn main() -> () {\n    log \"===== WITHOUT THREADS =====\";\n    test00(false);\n    log \"====== WITH THREADS ======\";\n    test00(true);\n }\n \n-io fn test00_start(chan[int] ch, int message, int count) {\n+impure fn test00_start(chan[int] ch, int message, int count) {\n     log \"Starting test00_start\";\n     let int i = 0;\n     while (i < count) {\n@@ -16,7 +16,7 @@ io fn test00_start(chan[int] ch, int message, int count) {\n     log \"Ending test00_start\";\n }\n \n-io fn test00(bool is_multithreaded) {\n+impure fn test00(bool is_multithreaded) {\n     let int number_of_tasks = 16;\n     let int number_of_messages = 4;\n     "}, {"sha": "87fa3d895489d9214a8d9381b1d9964eee42e668", "filename": "src/test/run-pass/task-comm-8.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -1,16 +1,16 @@\n-io fn main() -> () {\n+impure fn main() -> () {\n    test00();\n }\n \n-io fn test00_start(chan[int] c, int start, int number_of_messages) {\n+impure fn test00_start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;\n     while (i < number_of_messages) {\n         c <| start + i;\n         i += 1;\n     }    \n }\n \n-io fn test00() {\n+impure fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "370a36e34b83d926d9d1dd043116a1f77e4d03af", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -1,16 +1,16 @@\n-io fn main() -> () {\n+impure fn main() -> () {\n    test00();\n }\n \n-io fn test00_start(chan[int] c, int number_of_messages) {\n+impure fn test00_start(chan[int] c, int number_of_messages) {\n     let int i = 0;\n     while (i < number_of_messages) {\n         c <| i;\n         i += 1;\n     }    \n }\n \n-io fn test00() {\n+impure fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "d5f9a3a0dae2030df0c0ce9824a7ca4711bdce8b", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c848ed1e9862a527e0a6f16ef235b41f98baa419/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=c848ed1e9862a527e0a6f16ef235b41f98baa419", "patch": "@@ -1,5 +1,5 @@\n \n-io fn main() -> () {\n+impure fn main() -> () {\n     test00(true);\n     // test01();\n     test02();\n@@ -9,7 +9,7 @@ io fn main() -> () {\n     test06();\n }\n \n-io fn test00_start(chan[int] ch, int message, int count) {\n+impure fn test00_start(chan[int] ch, int message, int count) {\n     log \"Starting test00_start\";\n     let int i = 0;\n     while (i < count) {\n@@ -20,7 +20,7 @@ io fn test00_start(chan[int] ch, int message, int count) {\n     log \"Ending test00_start\";\n }\n \n-io fn test00(bool is_multithreaded) {\n+impure fn test00(bool is_multithreaded) {\n     let int number_of_tasks = 1;\n     let int number_of_messages = 4;\n     log \"Creating tasks\";\n@@ -60,14 +60,14 @@ io fn test00(bool is_multithreaded) {\n            (number_of_tasks * number_of_tasks + number_of_tasks) / 2);\n }\n \n-io fn test01() {\n+impure fn test01() {\n     let port[int] p = port();\n     log \"Reading from a port that is never written to.\";\n     let int value <- p;\n     log value;\n }\n \n-io fn test02() {\n+impure fn test02() {\n     let port[int] p = port();\n     let chan[int] c = chan(p);\n     log \"Writing to a local task channel.\";\n@@ -111,15 +111,15 @@ fn test04() {\n     log \"Finishing up.\";\n }\n \n-io fn test05_start(chan[int] ch) {\n+impure fn test05_start(chan[int] ch) {\n     ch <| 10;\n     ch <| 20;\n     ch <| 30;\n     ch <| 30;\n     ch <| 30;    \n }\n \n-io fn test05() {\n+impure fn test05() {\n     let port[int] po = port();\n     let chan[int] ch = chan(po);\n     spawn thread test05_start(ch);"}]}