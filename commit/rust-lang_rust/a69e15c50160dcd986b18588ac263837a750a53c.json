{"sha": "a69e15c50160dcd986b18588ac263837a750a53c", "node_id": "C_kwDOAAsO6NoAKGE2OWUxNWM1MDE2MGRjZDk4NmIxODU4OGFjMjYzODM3YTc1MGE1M2M", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-06T05:37:00Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-06T20:49:29Z"}, "message": "Remove the side channel\n\nHooray! It was no longer used, so it can just be deleted.", "tree": {"sha": "b673a12f766f1cf4315db5ef6d384f644556a73b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b673a12f766f1cf4315db5ef6d384f644556a73b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a69e15c50160dcd986b18588ac263837a750a53c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a69e15c50160dcd986b18588ac263837a750a53c", "html_url": "https://github.com/rust-lang/rust/commit/a69e15c50160dcd986b18588ac263837a750a53c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a69e15c50160dcd986b18588ac263837a750a53c/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54a14e844c6a5ed51741e039e6376822f88ac121", "url": "https://api.github.com/repos/rust-lang/rust/commits/54a14e844c6a5ed51741e039e6376822f88ac121", "html_url": "https://github.com/rust-lang/rust/commit/54a14e844c6a5ed51741e039e6376822f88ac121"}], "stats": {"total": 55, "additions": 11, "deletions": 44}, "files": [{"sha": "7aa2f1588107483abe61efe686e6ae71c2f6968f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 44, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a69e15c50160dcd986b18588ac263837a750a53c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a69e15c50160dcd986b18588ac263837a750a53c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a69e15c50160dcd986b18588ac263837a750a53c", "patch": "@@ -25,7 +25,6 @@ use smallvec::{smallvec, SmallVec};\n use pulldown_cmark::LinkType;\n \n use std::borrow::Cow;\n-use std::cell::Cell;\n use std::convert::{TryFrom, TryInto};\n use std::fmt::Write;\n use std::mem;\n@@ -48,12 +47,8 @@ crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n };\n \n fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    let mut collector = LinkCollector {\n-        cx,\n-        mod_ids: Vec::new(),\n-        kind_side_channel: Cell::new(None),\n-        visited_links: FxHashMap::default(),\n-    };\n+    let mut collector =\n+        LinkCollector { cx, mod_ids: Vec::new(), visited_links: FxHashMap::default() };\n     collector.visit_crate(&krate);\n     krate\n }\n@@ -319,7 +314,6 @@ struct DiagnosticInfo<'a> {\n #[derive(Clone, Debug, Hash)]\n struct CachedLink {\n     pub res: (Res, Option<UrlFragment>),\n-    pub side_channel: Option<(DefKind, DefId)>,\n }\n \n struct LinkCollector<'a, 'tcx> {\n@@ -329,10 +323,6 @@ struct LinkCollector<'a, 'tcx> {\n     /// The last module will be used if the parent scope of the current item is\n     /// unknown.\n     mod_ids: Vec<DefId>,\n-    /// This is used to store the kind of associated items,\n-    /// because `clean` and the disambiguator code expect them to be different.\n-    /// See the code for associated items on inherent impls for details.\n-    kind_side_channel: Cell<Option<(DefKind, DefId)>>,\n     /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link.\n     /// The link will be `None` if it could not be resolved (i.e. the error was cached).\n     visited_links: FxHashMap<ResolutionInfo, Option<CachedLink>>,\n@@ -430,7 +420,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n         item_name: Symbol,\n-    ) -> Option<(Res, UrlFragment, Option<(DefKind, DefId)>)> {\n+    ) -> Option<(Res, UrlFragment)> {\n         let tcx = self.cx.tcx;\n \n         prim_ty.impls(tcx).into_iter().find_map(|&impl_| {\n@@ -439,7 +429,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 .map(|item| {\n                     let kind = item.kind;\n                     let fragment = UrlFragment::from_assoc_item(item.def_id, kind, false);\n-                    (Res::Primitive(prim_ty), fragment, Some((kind.as_def_kind(), item.def_id)))\n+                    (Res::Primitive(prim_ty), fragment)\n                 })\n         })\n     }\n@@ -580,15 +570,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n             .and_then(|ty_res| {\n-                let (res, fragment, side_channel) =\n+                let (res, fragment) =\n                     self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n \n-                // HACK(jynelson): `clean` expects the type, not the associated item\n-                // but the disambiguator logic expects the associated item.\n-                // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                if let Some((kind, id)) = side_channel {\n-                    self.kind_side_channel.set(Some((kind, id)));\n-                }\n                 Some(Ok((res, Some(fragment))))\n             })\n             .unwrap_or_else(|| {\n@@ -686,7 +670,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Option<(Res, UrlFragment, Option<(DefKind, DefId)>)> {\n+    ) -> Option<(Res, UrlFragment)> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n@@ -702,10 +686,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     assoc_item.map(|item| {\n                         let kind = item.kind;\n                         let fragment = UrlFragment::from_assoc_item(item.def_id, kind, false);\n-                        // HACK(jynelson): `clean` expects the type, not the associated item\n-                        // but the disambiguator logic expects the associated item.\n-                        // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                        (root_res, fragment, Some((kind.as_def_kind(), item.def_id)))\n+                        (root_res, fragment)\n                     })\n                 })\n             }\n@@ -756,10 +737,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 if let Some(item) = assoc_item {\n                     let kind = item.kind;\n                     let fragment = UrlFragment::from_assoc_item(item.def_id, kind, false);\n-                    // HACK(jynelson): `clean` expects the type, not the associated item\n-                    // but the disambiguator logic expects the associated item.\n-                    // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                    return Some((root_res, fragment, Some((kind.as_def_kind(), item.def_id))));\n+                    return Some((root_res, fragment));\n                 }\n \n                 if ns != Namespace::ValueNS {\n@@ -790,11 +768,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .fields\n                     .iter()\n                     .find(|item| item.ident.name == item_name)?;\n-                Some((\n-                    root_res,\n-                    UrlFragment::Def(FragmentKind::StructField, field.did),\n-                    Some((DefKind::Field, field.did)),\n-                ))\n+                Some((root_res, UrlFragment::Def(FragmentKind::StructField, field.did)))\n             }\n             Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n@@ -806,7 +780,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         !item.defaultness.has_value(),\n                     );\n                     let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                    (res, fragment, None)\n+                    (res, fragment)\n                 }),\n             _ => None,\n         }\n@@ -1436,7 +1410,6 @@ impl LinkCollector<'_, '_> {\n         if let Some(ref cached) = self.visited_links.get(&key) {\n             match cached {\n                 Some(cached) => {\n-                    self.kind_side_channel.set(cached.side_channel);\n                     return Some(cached.res.clone());\n                 }\n                 None if cache_resolution_failure => return None,\n@@ -1453,13 +1426,7 @@ impl LinkCollector<'_, '_> {\n         // Cache only if resolved successfully - don't silence duplicate errors\n         if let Some(res) = res {\n             // Store result for the actual namespace\n-            self.visited_links.insert(\n-                key,\n-                Some(CachedLink {\n-                    res: res.clone(),\n-                    side_channel: self.kind_side_channel.clone().into_inner(),\n-                }),\n-            );\n+            self.visited_links.insert(key, Some(CachedLink { res: res.clone() }));\n \n             Some(res)\n         } else {"}]}