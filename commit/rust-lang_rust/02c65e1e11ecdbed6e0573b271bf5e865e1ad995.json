{"sha": "02c65e1e11ecdbed6e0573b271bf5e865e1ad995", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYzY1ZTFlMTFlY2RiZWQ2ZTA1NzNiMjcxYmY1ZTg2NWUxYWQ5OTU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-03-29T21:17:53Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-09T19:48:31Z"}, "message": "Use new utility in `transform/generator.rs`", "tree": {"sha": "4905042b98f3010438a6058faf5e309ca67f69a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4905042b98f3010438a6058faf5e309ca67f69a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02c65e1e11ecdbed6e0573b271bf5e865e1ad995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02c65e1e11ecdbed6e0573b271bf5e865e1ad995", "html_url": "https://github.com/rust-lang/rust/commit/02c65e1e11ecdbed6e0573b271bf5e865e1ad995", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02c65e1e11ecdbed6e0573b271bf5e865e1ad995/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "335fd6b456ac75f5a5bd34d71855dc892bdd8e2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/335fd6b456ac75f5a5bd34d71855dc892bdd8e2f", "html_url": "https://github.com/rust-lang/rust/commit/335fd6b456ac75f5a5bd34d71855dc892bdd8e2f"}], "stats": {"total": 74, "additions": 40, "deletions": 34}, "files": [{"sha": "25e879b01e2987700b39ad2c56209b2ac7b0a1ff", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/02c65e1e11ecdbed6e0573b271bf5e865e1ad995/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c65e1e11ecdbed6e0573b271bf5e865e1ad995/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=02c65e1e11ecdbed6e0573b271bf5e865e1ad995", "patch": "@@ -56,12 +56,13 @@ use crate::transform::simplify;\n use crate::transform::{MirPass, MirSource};\n use crate::util::dump_mir;\n use crate::util::liveness;\n+use crate::util::storage;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitMatrix, BitSet};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext};\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::GeneratorSubsts;\n@@ -222,6 +223,9 @@ struct TransformVisitor<'tcx> {\n     // A list of suspension points, generated during the transform\n     suspension_points: Vec<SuspensionPoint<'tcx>>,\n \n+    // The set of locals that have no `StorageLive`/`StorageDead` annotations.\n+    always_live_locals: storage::AlwaysLiveLocals,\n+\n     // The original RETURN_PLACE local\n     new_ret_local: Local,\n }\n@@ -416,19 +420,6 @@ fn replace_local<'tcx>(\n     new_local\n }\n \n-struct StorageIgnored(liveness::LiveVarSet);\n-\n-impl<'tcx> Visitor<'tcx> for StorageIgnored {\n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, _location: Location) {\n-        match statement.kind {\n-            StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => {\n-                self.0.remove(l);\n-            }\n-            _ => (),\n-        }\n-    }\n-}\n-\n struct LivenessInfo {\n     /// Which locals are live across any suspension point.\n     ///\n@@ -454,23 +445,19 @@ fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'tcx>,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n     source: MirSource<'tcx>,\n+    always_live_locals: &storage::AlwaysLiveLocals,\n     movable: bool,\n ) -> LivenessInfo {\n     let def_id = source.def_id();\n     let body_ref: &Body<'_> = &body;\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n-    let mut storage_live = MaybeStorageLive\n+    let mut storage_live = MaybeStorageLive::new(always_live_locals.clone())\n         .into_engine(tcx, body_ref, def_id)\n         .iterate_to_fixpoint()\n         .into_results_cursor(body_ref);\n \n-    // Find the MIR locals which do not use StorageLive/StorageDead statements.\n-    // The storage of these locals are always live.\n-    let mut ignored = StorageIgnored(BitSet::new_filled(body.local_decls.len()));\n-    ignored.visit_body(&body);\n-\n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n     let borrowed_locals_results =\n@@ -515,11 +502,13 @@ fn locals_live_across_suspend_points(\n             }\n \n             storage_live.seek_before(loc);\n-            let storage_liveness = storage_live.get();\n+            let mut storage_liveness = storage_live.get().clone();\n+\n+            storage_liveness.remove(SELF_ARG);\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n-            storage_liveness_map.insert(block, storage_liveness.clone());\n+            storage_liveness_map.insert(block, storage_liveness);\n \n             requires_storage_cursor.seek_before(loc);\n             let storage_required = requires_storage_cursor.get().clone();\n@@ -551,8 +540,12 @@ fn locals_live_across_suspend_points(\n         .map(|live_here| renumber_bitset(&live_here, &live_locals))\n         .collect();\n \n-    let storage_conflicts =\n-        compute_storage_conflicts(body_ref, &live_locals, &ignored, requires_storage_results);\n+    let storage_conflicts = compute_storage_conflicts(\n+        body_ref,\n+        &live_locals,\n+        always_live_locals.clone(),\n+        requires_storage_results,\n+    );\n \n     LivenessInfo {\n         live_locals,\n@@ -590,18 +583,18 @@ fn renumber_bitset(\n fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n     stored_locals: &liveness::LiveVarSet,\n-    ignored: &StorageIgnored,\n+    always_live_locals: storage::AlwaysLiveLocals,\n     requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n-    assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n+\n     debug!(\"compute_storage_conflicts({:?})\", body.span);\n-    debug!(\"ignored = {:?}\", ignored.0);\n+    debug!(\"always_live = {:?}\", always_live_locals);\n \n-    // Storage ignored locals are not eligible for overlap, since their storage\n-    // is always live.\n-    let mut ineligible_locals = ignored.0.clone();\n-    ineligible_locals.intersect(&stored_locals);\n+    // Locals that are always live or ones that need to be stored across\n+    // suspension points are not eligible for overlap.\n+    let mut ineligible_locals = always_live_locals.into_inner();\n+    ineligible_locals.intersect(stored_locals);\n \n     // Compute the storage conflicts for all eligible locals.\n     let mut visitor = StorageConflictVisitor {\n@@ -697,6 +690,7 @@ fn compute_layout<'tcx>(\n     source: MirSource<'tcx>,\n     upvars: &Vec<Ty<'tcx>>,\n     interior: Ty<'tcx>,\n+    always_live_locals: &storage::AlwaysLiveLocals,\n     movable: bool,\n     body: &mut BodyAndCache<'tcx>,\n ) -> (\n@@ -710,7 +704,13 @@ fn compute_layout<'tcx>(\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness,\n-    } = locals_live_across_suspend_points(tcx, read_only!(body), source, movable);\n+    } = locals_live_across_suspend_points(\n+        tcx,\n+        read_only!(body),\n+        source,\n+        always_live_locals,\n+        movable,\n+    );\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n@@ -1180,7 +1180,10 @@ fn create_cases<'tcx>(\n                     }\n \n                     let l = Local::new(i);\n-                    if point.storage_liveness.contains(l) && !transform.remap.contains_key(&l) {\n+                    let needs_storage_live = point.storage_liveness.contains(l)\n+                        && !transform.remap.contains_key(&l)\n+                        && !transform.always_live_locals.contains(l);\n+                    if needs_storage_live {\n                         statements\n                             .push(Statement { source_info, kind: StatementKind::StorageLive(l) });\n                     }\n@@ -1276,11 +1279,13 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             },\n         );\n \n+        let always_live_locals = storage::AlwaysLiveLocals::new(&body);\n+\n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n         // `storage_liveness` tells us which locals have live storage at suspension points\n         let (remap, layout, storage_liveness) =\n-            compute_layout(tcx, source, &upvars, interior, movable, body);\n+            compute_layout(tcx, source, &upvars, interior, &always_live_locals, movable, body);\n \n         let can_return = can_return(tcx, body);\n \n@@ -1294,6 +1299,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             state_substs,\n             remap,\n             storage_liveness,\n+            always_live_locals,\n             suspension_points: Vec::new(),\n             new_ret_local,\n             discr_ty,"}]}