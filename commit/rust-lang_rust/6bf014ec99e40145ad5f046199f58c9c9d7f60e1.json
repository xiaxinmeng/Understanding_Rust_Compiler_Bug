{"sha": "6bf014ec99e40145ad5f046199f58c9c9d7f60e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZjAxNGVjOTllNDAxNDVhZDVmMDQ2MTk5ZjU4YzljOWQ3ZjYwZTE=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-02-13T11:18:57Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-02-19T15:01:46Z"}, "message": "Make `try_get_cached` take closures", "tree": {"sha": "032990f3aae8e1c7b21b127a39347f05e1cd89a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/032990f3aae8e1c7b21b127a39347f05e1cd89a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bf014ec99e40145ad5f046199f58c9c9d7f60e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf014ec99e40145ad5f046199f58c9c9d7f60e1", "html_url": "https://github.com/rust-lang/rust/commit/6bf014ec99e40145ad5f046199f58c9c9d7f60e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bf014ec99e40145ad5f046199f58c9c9d7f60e1/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "545e290a93b3c51a60c33ccb4c0d9576f797cf29", "url": "https://api.github.com/repos/rust-lang/rust/commits/545e290a93b3c51a60c33ccb4c0d9576f797cf29", "html_url": "https://github.com/rust-lang/rust/commit/545e290a93b3c51a60c33ccb4c0d9576f797cf29"}], "stats": {"total": 86, "additions": 47, "deletions": 39}, "files": [{"sha": "ba2d1e0361c02cb4504fba0969878114ef050c38", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6bf014ec99e40145ad5f046199f58c9c9d7f60e1/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf014ec99e40145ad5f046199f58c9c9d7f60e1/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=6bf014ec99e40145ad5f046199f58c9c9d7f60e1", "patch": "@@ -159,7 +159,11 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                 return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));\n             }\n \n-            let cached = tcx.try_get_cached::<Q>(key).0.unwrap();\n+            let cached = tcx.try_get_cached::<Q, _, _, _>(\n+                (*key).clone(),\n+                |value, index| (value.clone(), index),\n+                |_, _| panic!(\"value must be in cache after waiting\"),\n+            );\n \n             if let Some(prof_timer) = _query_blocked_prof_timer.take() {\n                 prof_timer.finish_with_query_invocation_id(cached.1.into());\n@@ -374,10 +378,18 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n     #[inline(always)]\n-    fn try_get_cached<Q: QueryDescription<'tcx>>(\n+    fn try_get_cached<Q, R, OnHit, OnMiss>(\n         self,\n-        key: &Q::Key,\n-    ) -> (Option<(Q::Value, DepNodeIndex)>, QueryLookup<'tcx, Q>) {\n+        key: Q::Key,\n+        // `on_hit` can be called while holding a lock to the query cache\n+        on_hit: OnHit,\n+        on_miss: OnMiss,\n+    ) -> R\n+    where\n+        Q: QueryDescription<'tcx> + 'tcx,\n+        OnHit: FnOnce(&Q::Value, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(Q::Key, QueryLookup<'tcx, Q>) -> R,\n+    {\n         let cache = Q::query_cache(self);\n \n         // We compute the key's hash once and then use it for both the\n@@ -391,23 +403,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut lock_guard = cache.get_shard_by_index(shard).lock();\n         let lock = &mut *lock_guard;\n \n-        let result =\n-            lock.results.raw_entry().from_key_hashed_nocheck(key_hash, key).map(|(_, value)| {\n-                if unlikely!(self.prof.enabled()) {\n-                    self.prof.query_cache_hit(value.index.into());\n-                }\n+        let result = lock.results.raw_entry().from_key_hashed_nocheck(key_hash, &key);\n \n-                (value.value.clone(), value.index)\n-            });\n-\n-        #[cfg(debug_assertions)]\n-        {\n-            if result.is_some() {\n-                lock.cache_hits += 1;\n+        if let Some((_, value)) = result {\n+            if unlikely!(self.prof.enabled()) {\n+                self.prof.query_cache_hit(value.index.into());\n             }\n-        }\n \n-        (result, QueryLookup { lock: lock_guard, shard })\n+            on_hit(&value.value, value.index)\n+        } else {\n+            on_miss(key, QueryLookup { lock: lock_guard, shard })\n+        }\n     }\n \n     #[inline(never)]\n@@ -418,14 +424,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> Q::Value {\n         debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n \n-        let (cached, lookup) = self.try_get_cached::<Q>(&key);\n-\n-        if let Some((v, index)) = cached {\n-            self.dep_graph.read_index(index);\n-            return v;\n-        }\n-\n-        self.try_execute_query(span, key, lookup)\n+        self.try_get_cached::<Q, _, _, _>(\n+            key,\n+            |value, index| {\n+                self.dep_graph.read_index(index);\n+                value.clone()\n+            },\n+            |key, lookup| self.try_execute_query(span, key, lookup),\n+        )\n     }\n \n     #[inline(always)]\n@@ -688,19 +694,21 @@ impl<'tcx> TyCtxt<'tcx> {\n         // We may be concurrently trying both execute and force a query.\n         // Ensure that only one of them runs the query.\n \n-        let (cached, lookup) = self.try_get_cached::<Q>(&key);\n-\n-        if cached.is_some() {\n-            return;\n-        }\n-\n-        let job = match JobOwner::try_start(self, span, &key, lookup) {\n-            TryGetJob::NotYetStarted(job) => job,\n-            TryGetJob::Cycle(_) => return,\n-            #[cfg(parallel_compiler)]\n-            TryGetJob::JobCompleted(_) => return,\n-        };\n-        self.force_query_with_job::<Q>(key, job, dep_node);\n+        self.try_get_cached::<Q, _, _, _>(\n+            key,\n+            |_, _| {\n+                // Cache hit, do nothing\n+            },\n+            |key, lookup| {\n+                let job = match JobOwner::try_start(self, span, &key, lookup) {\n+                    TryGetJob::NotYetStarted(job) => job,\n+                    TryGetJob::Cycle(_) => return,\n+                    #[cfg(parallel_compiler)]\n+                    TryGetJob::JobCompleted(_) => return,\n+                };\n+                self.force_query_with_job::<Q>(key, job, dep_node);\n+            },\n+        );\n     }\n }\n "}]}