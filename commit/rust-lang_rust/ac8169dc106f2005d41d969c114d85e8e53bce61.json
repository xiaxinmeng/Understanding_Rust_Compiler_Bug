{"sha": "ac8169dc106f2005d41d969c114d85e8e53bce61", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjODE2OWRjMTA2ZjIwMDVkNDFkOTY5YzExNGQ4NWU4ZTUzYmNlNjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-26T10:58:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-26T10:58:17Z"}, "message": "Rollup merge of #77093 - lcnr:const-generics-infer-warning, r=varkor\n\nmerge `need_type_info_err(_const)`\n\nI hoped that this would automatically solve #76737 but it doesn't quite seem like it\n\nfixes #77092\n\nr? @varkor", "tree": {"sha": "8c48ca9c65f5818808b16ea9c60b54b7015a418e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c48ca9c65f5818808b16ea9c60b54b7015a418e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac8169dc106f2005d41d969c114d85e8e53bce61", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfbx7KCRBK7hj4Ov3rIwAAdHIIADDamnQx/gfnDYBGmJcEsdlY\nNhzBVOu5qw6hN801a8ZMn//NYJ24haj4t8Vp76TND7A8I2cPCKeyhyoQuoJcMRnI\ndRomKxOrJle8qoWB+7Rc+YAdNvyDgrn4FsOQIHeGdJapoeyZGZ3Z3GTBbVvvXHJ7\nB+vvzjY0wR+dgpUuw6VQogOnvBUviQLsfe8MfjSWmk8pcs6RGMwVZNyRCBmr0fn7\nJaWoRTi5TiIJAToMDN8bynDs+Wl5VIbXvNQN+6G9GYqonTV5RvEDNIBJAPb+T6p2\nPu5JKX+8z2Ltvh+Kb2hchgPWKVE+VJp8hiika3T81vEWr6oTvGpfkhuKUgHq6VQ=\n=u7kF\n-----END PGP SIGNATURE-----\n", "payload": "tree 8c48ca9c65f5818808b16ea9c60b54b7015a418e\nparent 31fd0ad69f0a007e02df1d562c78c60ed9be3292\nparent 9a607c0a2781197b88ff2535b852b53d3f0e4145\nauthor Ralf Jung <post@ralfj.de> 1601117897 +0200\ncommitter GitHub <noreply@github.com> 1601117897 +0200\n\nRollup merge of #77093 - lcnr:const-generics-infer-warning, r=varkor\n\nmerge `need_type_info_err(_const)`\n\nI hoped that this would automatically solve #76737 but it doesn't quite seem like it\n\nfixes #77092\n\nr? @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac8169dc106f2005d41d969c114d85e8e53bce61", "html_url": "https://github.com/rust-lang/rust/commit/ac8169dc106f2005d41d969c114d85e8e53bce61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac8169dc106f2005d41d969c114d85e8e53bce61/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31fd0ad69f0a007e02df1d562c78c60ed9be3292", "url": "https://api.github.com/repos/rust-lang/rust/commits/31fd0ad69f0a007e02df1d562c78c60ed9be3292", "html_url": "https://github.com/rust-lang/rust/commit/31fd0ad69f0a007e02df1d562c78c60ed9be3292"}, {"sha": "9a607c0a2781197b88ff2535b852b53d3f0e4145", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a607c0a2781197b88ff2535b852b53d3f0e4145", "html_url": "https://github.com/rust-lang/rust/commit/9a607c0a2781197b88ff2535b852b53d3f0e4145"}], "stats": {"total": 409, "additions": 254, "deletions": 155}, "files": [{"sha": "2f3089f1a92c10d9e7c9b5ad40c03e5cb16c2868", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 174, "deletions": 103, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -176,7 +176,10 @@ fn closure_return_type_suggestion(\n         suggestion,\n         Applicability::HasPlaceholders,\n     );\n-    err.span_label(span, InferCtxt::missing_type_msg(&name, &descr, parent_name, parent_descr));\n+    err.span_label(\n+        span,\n+        InferCtxt::cannot_infer_msg(\"type\", &name, &descr, parent_name, parent_descr),\n+    );\n }\n \n /// Given a closure signature, return a `String` containing a list of all its argument types.\n@@ -217,65 +220,151 @@ impl Into<rustc_errors::DiagnosticId> for TypeAnnotationNeeded {\n     }\n }\n \n+/// Information about a constant or a type containing inference variables.\n+pub struct InferenceDiagnosticsData {\n+    pub name: String,\n+    pub span: Option<Span>,\n+    pub description: Cow<'static, str>,\n+    pub parent_name: Option<String>,\n+    pub parent_description: Option<&'static str>,\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn extract_type_name(\n+    /// Extracts data used by diagnostic for either types or constants\n+    /// which were stuck during inference.\n+    pub fn extract_inference_diagnostics_data(\n         &self,\n-        ty: Ty<'tcx>,\n+        arg: GenericArg<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n-    ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n-        if let ty::Infer(ty::TyVar(ty_vid)) = *ty.kind() {\n-            let mut inner = self.inner.borrow_mut();\n-            let ty_vars = &inner.type_variables();\n-            let var_origin = ty_vars.var_origin(ty_vid);\n-            if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) = var_origin.kind {\n-                let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n-                let (parent_name, parent_desc) = if let Some(parent_def_id) = parent_def_id {\n-                    let parent_name = self\n-                        .tcx\n-                        .def_key(parent_def_id)\n-                        .disambiguated_data\n-                        .data\n-                        .get_opt_name()\n-                        .map(|parent_symbol| parent_symbol.to_string());\n-\n-                    (parent_name, Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)))\n-                } else {\n-                    (None, None)\n-                };\n+    ) -> InferenceDiagnosticsData {\n+        match arg.unpack() {\n+            GenericArgKind::Type(ty) => {\n+                if let ty::Infer(ty::TyVar(ty_vid)) = *ty.kind() {\n+                    let mut inner = self.inner.borrow_mut();\n+                    let ty_vars = &inner.type_variables();\n+                    let var_origin = ty_vars.var_origin(ty_vid);\n+                    if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) =\n+                        var_origin.kind\n+                    {\n+                        let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n+                        let (parent_name, parent_description) =\n+                            if let Some(parent_def_id) = parent_def_id {\n+                                let parent_name = self\n+                                    .tcx\n+                                    .def_key(parent_def_id)\n+                                    .disambiguated_data\n+                                    .data\n+                                    .get_opt_name()\n+                                    .map(|parent_symbol| parent_symbol.to_string());\n+\n+                                (\n+                                    parent_name,\n+                                    Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n+                                )\n+                            } else {\n+                                (None, None)\n+                            };\n+\n+                        if name != kw::SelfUpper {\n+                            return InferenceDiagnosticsData {\n+                                name: name.to_string(),\n+                                span: Some(var_origin.span),\n+                                description: \"type parameter\".into(),\n+                                parent_name,\n+                                parent_description,\n+                            };\n+                        }\n+                    }\n+                }\n \n-                if name != kw::SelfUpper {\n-                    return (\n-                        name.to_string(),\n-                        Some(var_origin.span),\n-                        \"type parameter\".into(),\n-                        parent_name,\n-                        parent_desc,\n-                    );\n+                let mut s = String::new();\n+                let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n+                if let Some(highlight) = highlight {\n+                    printer.region_highlight_mode = highlight;\n+                }\n+                let _ = ty.print(printer);\n+                InferenceDiagnosticsData {\n+                    name: s,\n+                    span: None,\n+                    description: ty.prefix_string(),\n+                    parent_name: None,\n+                    parent_description: None,\n                 }\n             }\n-        }\n+            GenericArgKind::Const(ct) => {\n+                if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val {\n+                    let origin =\n+                        self.inner.borrow_mut().const_unification_table().probe_value(vid).origin;\n+                    if let ConstVariableOriginKind::ConstParameterDefinition(name, def_id) =\n+                        origin.kind\n+                    {\n+                        let parent_def_id = self.tcx.parent(def_id);\n+                        let (parent_name, parent_description) =\n+                            if let Some(parent_def_id) = parent_def_id {\n+                                let parent_name = self\n+                                    .tcx\n+                                    .def_key(parent_def_id)\n+                                    .disambiguated_data\n+                                    .data\n+                                    .get_opt_name()\n+                                    .map(|parent_symbol| parent_symbol.to_string());\n+\n+                                (\n+                                    parent_name,\n+                                    Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n+                                )\n+                            } else {\n+                                (None, None)\n+                            };\n+\n+                        return InferenceDiagnosticsData {\n+                            name: name.to_string(),\n+                            span: Some(origin.span),\n+                            description: \"const parameter\".into(),\n+                            parent_name,\n+                            parent_description,\n+                        };\n+                    }\n \n-        let mut s = String::new();\n-        let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n-        if let Some(highlight) = highlight {\n-            printer.region_highlight_mode = highlight;\n+                    debug_assert!(!origin.span.is_dummy());\n+                    let mut s = String::new();\n+                    let mut printer =\n+                        ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::ValueNS);\n+                    if let Some(highlight) = highlight {\n+                        printer.region_highlight_mode = highlight;\n+                    }\n+                    let _ = ct.print(printer);\n+                    InferenceDiagnosticsData {\n+                        name: s,\n+                        span: Some(origin.span),\n+                        description: \"the constant\".into(),\n+                        parent_name: None,\n+                        parent_description: None,\n+                    }\n+                } else {\n+                    bug!(\"unexpect const: {:?}\", ct);\n+                }\n+            }\n+            GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n         }\n-        let _ = ty.print(printer);\n-        (s, None, ty.prefix_string(), None, None)\n     }\n \n-    // FIXME(eddyb) generalize all of this to handle `ty::Const` inference variables as well.\n-    pub fn need_type_info_err(\n+    pub fn emit_inference_failure_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n         span: Span,\n-        ty: Ty<'tcx>,\n+        arg: GenericArg<'tcx>,\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx> {\n-        let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n+        let arg = self.resolve_vars_if_possible(&arg);\n+        let arg_data = self.extract_inference_diagnostics_data(arg, None);\n+        let kind_str = match arg.unpack() {\n+            GenericArgKind::Type(_) => \"type\",\n+            GenericArgKind::Const(_) => \"the value\",\n+            GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n+        };\n \n-        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into(), span);\n+        let mut local_visitor = FindHirNodeVisitor::new(&self, arg, span);\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -305,7 +394,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n         let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n             pattern.span\n-        } else if let Some(span) = name_sp {\n+        } else if let Some(span) = arg_data.span {\n             // `span` here lets us point at `sum` instead of the entire right hand side expr:\n             // error[E0282]: type annotations needed\n             //  --> file2.rs:3:15\n@@ -352,7 +441,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => String::new(),\n         };\n \n-        // When `name` corresponds to a type argument, show the path of the full type we're\n+        // When `arg_data.name` corresponds to a type argument, show the path of the full type we're\n         // trying to infer. In the following example, `ty_msg` contains\n         // \" in `std::result::Result<i32, E>`\":\n         // ```\n@@ -391,11 +480,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         &mut err,\n                         &decl.output,\n                         self.tcx.hir().body(body_id),\n-                        &descr,\n-                        &name,\n+                        &arg_data.description,\n+                        &arg_data.name,\n                         &ret,\n-                        parent_name,\n-                        parent_descr,\n+                        arg_data.parent_name,\n+                        arg_data.parent_description,\n                     );\n                     // We don't want to give the other suggestions when the problem is the\n                     // closure return type.\n@@ -409,15 +498,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // nudge them in the right direction.\n                 format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) && name == \"_\" => {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && arg_data.name == \"_\" => {\n                 let ty = ty_to_string(ty);\n                 format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != name => {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != arg_data.name => {\n                 let ty = ty_to_string(ty);\n                 format!(\n                     \"the explicit type `{}`, where the type parameter `{}` is specified\",\n-                    ty, name,\n+                    ty, arg_data.name,\n                 )\n             }\n             _ => \"a type\".to_string(),\n@@ -534,7 +623,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |               ^^^ cannot infer type for `S`\n         //   |\n         //   = note: type must be known at this point\n-        let span = name_sp.unwrap_or(err_span);\n+        let span = arg_data.span.unwrap_or(err_span);\n         if !err\n             .span\n             .span_labels()\n@@ -545,55 +634,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // Avoid multiple labels pointing at `span`.\n             err.span_label(\n                 span,\n-                InferCtxt::missing_type_msg(&name, &descr, parent_name, parent_descr),\n+                InferCtxt::cannot_infer_msg(\n+                    kind_str,\n+                    &arg_data.name,\n+                    &arg_data.description,\n+                    arg_data.parent_name,\n+                    arg_data.parent_description,\n+                ),\n             );\n         }\n \n         err\n     }\n \n-    // FIXME(const_generics): We should either try and merge this with `need_type_info_err`\n-    // or improve the errors created here.\n-    //\n-    // Unlike for type inference variables, we don't yet store the origin of const inference variables.\n-    // This is needed for to get a more relevant error span.\n-    pub fn need_type_info_err_const(\n-        &self,\n-        body_id: Option<hir::BodyId>,\n-        span: Span,\n-        ct: &'tcx ty::Const<'tcx>,\n-        error_code: TypeAnnotationNeeded,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let mut local_visitor = FindHirNodeVisitor::new(&self, ct.into(), span);\n-        if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n-            local_visitor.visit_expr(expr);\n-        }\n-\n-        let mut param_name = None;\n-        let span = if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val {\n-            let origin = self.inner.borrow_mut().const_unification_table().probe_value(vid).origin;\n-            if let ConstVariableOriginKind::ConstParameterDefinition(param) = origin.kind {\n-                param_name = Some(param);\n-            }\n-            origin.span\n-        } else {\n-            local_visitor.target_span\n-        };\n-\n-        let error_code = error_code.into();\n-        let mut err =\n-            self.tcx.sess.struct_span_err_with_code(span, \"type annotations needed\", error_code);\n-\n-        if let Some(param_name) = param_name {\n-            err.note(&format!(\"cannot infer the value of the const parameter `{}`\", param_name));\n-        } else {\n-            err.note(\"unable to infer the value of a const parameter\");\n-        }\n-\n-        err\n-    }\n-\n     /// If the `FnSig` for the method call can be found and type arguments are identified as\n     /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n     fn annotate_method_call(\n@@ -647,7 +700,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, _, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n+        let data = self.extract_inference_diagnostics_data(ty.into(), None);\n \n         let mut err = struct_span_err!(\n             self.tcx.sess,\n@@ -656,18 +709,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"type inside {} must be known in this context\",\n             kind,\n         );\n-        err.span_label(span, InferCtxt::missing_type_msg(&name, &descr, parent_name, parent_descr));\n+        err.span_label(\n+            span,\n+            InferCtxt::cannot_infer_msg(\n+                \"type\",\n+                &data.name,\n+                &data.description,\n+                data.parent_name,\n+                data.parent_description,\n+            ),\n+        );\n         err\n     }\n \n-    fn missing_type_msg(\n+    fn cannot_infer_msg(\n+        kind_str: &str,\n         type_name: &str,\n         descr: &str,\n         parent_name: Option<String>,\n         parent_descr: Option<&str>,\n-    ) -> Cow<'static, str> {\n+    ) -> String {\n         if type_name == \"_\" {\n-            \"cannot infer type\".into()\n+            format!(\"cannot infer {}\", kind_str)\n         } else {\n             let parent_desc = if let Some(parent_name) = parent_name {\n                 let parent_type_descr = if let Some(parent_descr) = parent_descr {\n@@ -681,7 +744,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 \"\".to_string()\n             };\n \n-            format!(\"cannot infer type for {} `{}`{}\", descr, type_name, parent_desc).into()\n+            // FIXME: We really shouldn't be dealing with strings here\n+            // but instead use a sensible enum for cases like this.\n+            let preposition = if \"the value\" == kind_str { \"of\" } else { \"for\" };\n+            // For example: \"cannot infer type for type parameter `T`\"\n+            format!(\n+                \"cannot infer {} {} {} `{}`{}\",\n+                kind_str, preposition, descr, type_name, parent_desc\n+            )\n+            .into()\n         }\n     }\n }"}, {"sha": "d7bfab8a7f85de483b3040fa2ce148163069a1c2", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -1163,7 +1163,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             GenericParamDefKind::Const { .. } => {\n                 let origin = ConstVariableOrigin {\n-                    kind: ConstVariableOriginKind::ConstParameterDefinition(param.name),\n+                    kind: ConstVariableOriginKind::ConstParameterDefinition(\n+                        param.name,\n+                        param.def_id,\n+                    ),\n                     span,\n                 };\n                 let const_var_id ="}, {"sha": "4d884dde393876d5680f00b84269b1b5bc6dfebb", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -4,8 +4,9 @@ use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify::{\n     self, EqUnifyValue, InPlace, NoError, UnificationTable, UnifyKey, UnifyValue,\n };\n+use rustc_span::def_id::DefId;\n use rustc_span::symbol::Symbol;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n \n use std::cmp;\n use std::marker::PhantomData;\n@@ -124,8 +125,7 @@ pub struct ConstVariableOrigin {\n pub enum ConstVariableOriginKind {\n     MiscVariable,\n     ConstInference,\n-    // FIXME(const_generics): Consider storing the `DefId` of the param here.\n-    ConstParameterDefinition(Symbol),\n+    ConstParameterDefinition(Symbol, DefId),\n     SubstitutionPlaceholder,\n }\n \n@@ -176,17 +176,17 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n     type Error = (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>);\n \n     fn unify_values(value1: &Self, value2: &Self) -> Result<Self, Self::Error> {\n-        let val = match (value1.val, value2.val) {\n+        let (val, span) = match (value1.val, value2.val) {\n             (ConstVariableValue::Known { .. }, ConstVariableValue::Known { .. }) => {\n                 bug!(\"equating two const variables, both of which have known values\")\n             }\n \n             // If one side is known, prefer that one.\n             (ConstVariableValue::Known { .. }, ConstVariableValue::Unknown { .. }) => {\n-                Ok(value1.val)\n+                (value1.val, value1.origin.span)\n             }\n             (ConstVariableValue::Unknown { .. }, ConstVariableValue::Known { .. }) => {\n-                Ok(value2.val)\n+                (value2.val, value2.origin.span)\n             }\n \n             // If both sides are *unknown*, it hardly matters, does it?\n@@ -200,14 +200,14 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n                 // universe is the minimum of the two universes, because that is\n                 // the one which contains the fewest names in scope.\n                 let universe = cmp::min(universe1, universe2);\n-                Ok(ConstVariableValue::Unknown { universe })\n+                (ConstVariableValue::Unknown { universe }, value1.origin.span)\n             }\n-        }?;\n+        };\n \n         Ok(ConstVarValue {\n             origin: ConstVariableOrigin {\n                 kind: ConstVariableOriginKind::ConstInference,\n-                span: DUMMY_SP,\n+                span: span,\n             },\n             val,\n         })"}, {"sha": "5f64eb3dba8ac4b4b442db830657404bb5af144a", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -396,15 +396,15 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ) -> Option<RegionNameHighlight> {\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n-        let type_name = self.infcx.extract_type_name(&ty, Some(highlight)).0;\n+        let type_name =\n+            self.infcx.extract_inference_diagnostics_data(ty.into(), Some(highlight)).name;\n \n         debug!(\n             \"highlight_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n         if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-\n             Some(RegionNameHighlight::CannotMatchHirTy(span, type_name))\n         } else {\n             None\n@@ -646,7 +646,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n+        let type_name =\n+            self.infcx.extract_inference_diagnostics_data(return_ty.into(), Some(highlight)).name;\n \n         let mir_hir_id = tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n \n@@ -698,7 +699,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n+        let type_name =\n+            self.infcx.extract_inference_diagnostics_data(yield_ty.into(), Some(highlight)).name;\n \n         let mir_hir_id = tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n "}, {"sha": "1b234a1535c978be426d12666fbc7b9bd67863e0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -20,7 +20,6 @@ use rustc_hir::Node;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n     self, fast_reject, AdtKind, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt,\n     TypeFoldable, WithConstness,\n@@ -1513,10 +1512,21 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // check upstream for type errors and don't add the obligations to\n                 // begin with in those cases.\n                 if self.tcx.lang_items().sized_trait() == Some(trait_ref.def_id()) {\n-                    self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n+                    self.emit_inference_failure_err(\n+                        body_id,\n+                        span,\n+                        self_ty.into(),\n+                        ErrorCode::E0282,\n+                    )\n+                    .emit();\n                     return;\n                 }\n-                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0283);\n+                let mut err = self.emit_inference_failure_err(\n+                    body_id,\n+                    span,\n+                    self_ty.into(),\n+                    ErrorCode::E0283,\n+                );\n                 err.note(&format!(\"cannot satisfy `{}`\", predicate));\n                 if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n                     self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n@@ -1580,17 +1590,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                match arg.unpack() {\n-                    GenericArgKind::Lifetime(lt) => {\n-                        span_bug!(span, \"unexpected well formed predicate: {:?}\", lt)\n-                    }\n-                    GenericArgKind::Type(ty) => {\n-                        self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n-                    }\n-                    GenericArgKind::Const(ct) => {\n-                        self.need_type_info_err_const(body_id, span, ct, ErrorCode::E0282)\n-                    }\n-                }\n+                self.emit_inference_failure_err(body_id, span, arg, ErrorCode::E0282)\n             }\n \n             ty::PredicateAtom::Subtype(data) => {\n@@ -1601,7 +1601,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let SubtypePredicate { a_is_expected: _, a, b } = data;\n                 // both must be type variables, or the other would've been instantiated\n                 assert!(a.is_ty_var() && b.is_ty_var());\n-                self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n+                self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282)\n             }\n             ty::PredicateAtom::Projection(data) => {\n                 let trait_ref = ty::Binder::bind(data).to_poly_trait_ref(self.tcx);\n@@ -1612,7 +1612,12 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n                 if self_ty.needs_infer() && ty.needs_infer() {\n                     // We do this for the `foo.collect()?` case to produce a suggestion.\n-                    let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0284);\n+                    let mut err = self.emit_inference_failure_err(\n+                        body_id,\n+                        span,\n+                        self_ty.into(),\n+                        ErrorCode::E0284,\n+                    );\n                     err.note(&format!(\"cannot satisfy `{}`\", predicate));\n                     err\n                 } else {"}, {"sha": "79d6c7dbfdae264e980b88b96c498bb6fb5e4ddf", "filename": "compiler/rustc_typeck/src/check/fn_ctxt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt.rs?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -2991,7 +2991,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty\n         } else {\n             if !self.is_tainted_by_errors() {\n-                self.need_type_info_err((**self).body_id, sp, ty, E0282)\n+                self.emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282)\n                     .note(\"type must be known at this point\")\n                     .emit();\n             }"}, {"sha": "6fd7277a1c332df50cfed0aef3b7d1482f9c498e", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -653,18 +653,23 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n     fn report_type_error(&self, t: Ty<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n             self.infcx\n-                .need_type_info_err(Some(self.body.id()), self.span.to_span(self.tcx), t, E0282)\n+                .emit_inference_failure_err(\n+                    Some(self.body.id()),\n+                    self.span.to_span(self.tcx),\n+                    t.into(),\n+                    E0282,\n+                )\n                 .emit();\n         }\n     }\n \n     fn report_const_error(&self, c: &'tcx ty::Const<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n             self.infcx\n-                .need_type_info_err_const(\n+                .emit_inference_failure_err(\n                     Some(self.body.id()),\n                     self.span.to_span(self.tcx),\n-                    c,\n+                    c.into(),\n                     E0282,\n                 )\n                 .emit();"}, {"sha": "b438ed3ad6508cb2100bc1ea060ba5f56368b264", "filename": "src/test/ui/const-generics/infer/cannot-infer-const-args.full.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-const-args.rs:12:5\n    |\n LL |     foo();\n-   |     ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `X`\n+   |     ^^^ cannot infer the value of const parameter `X` declared on the function `foo`\n \n error: aborting due to previous error\n "}, {"sha": "b438ed3ad6508cb2100bc1ea060ba5f56368b264", "filename": "src/test/ui/const-generics/infer/cannot-infer-const-args.min.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-const-args.rs:12:5\n    |\n LL |     foo();\n-   |     ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `X`\n+   |     ^^^ cannot infer the value of const parameter `X` declared on the function `foo`\n \n error: aborting due to previous error\n "}, {"sha": "9a1dd1a825895166d48281ebf29acf9d6e1c1637", "filename": "src/test/ui/const-generics/infer/issue-77092.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.rs?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -0,0 +1,16 @@\n+#![feature(min_const_generics)]\n+\n+use std::convert::TryInto;\n+\n+fn take_array_from_mut<T, const N: usize>(data: &mut [T], start: usize) -> &mut [T; N] {\n+    (&mut data[start .. start + N]).try_into().unwrap()\n+}\n+\n+fn main() {\n+    let mut arr = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+\n+    for i in 1 .. 4 {\n+        println!(\"{:?}\", take_array_from_mut(&mut arr, i));\n+        //~^ ERROR type annotations needed\n+    }\n+}"}, {"sha": "e84ff8baeea53ef03f818aaacbe769f88e1de463", "filename": "src/test/ui/const-generics/infer/issue-77092.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-77092.rs:13:26\n+   |\n+LL |         println!(\"{:?}\", take_array_from_mut(&mut arr, i));\n+   |                          ^^^^^^^^^^^^^^^^^^^ cannot infer the value of the constant `{_: usize}`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "1fb0b23cf11574d7e997fea6e607e4ac12c00a83", "filename": "src/test/ui/const-generics/infer/method-chain.full.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/method-chain.rs:21:33\n    |\n LL |     Foo.bar().bar().bar().bar().baz();\n-   |                                 ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `N`\n+   |                                 ^^^ cannot infer the value of const parameter `N` declared on the associated function `baz`\n \n error: aborting due to previous error\n "}, {"sha": "1fb0b23cf11574d7e997fea6e607e4ac12c00a83", "filename": "src/test/ui/const-generics/infer/method-chain.min.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/method-chain.rs:21:33\n    |\n LL |     Foo.bar().bar().bar().bar().baz();\n-   |                                 ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `N`\n+   |                                 ^^^ cannot infer the value of const parameter `N` declared on the associated function `baz`\n \n error: aborting due to previous error\n "}, {"sha": "7a451903e9630581760706173e315db758c6dfce", "filename": "src/test/ui/const-generics/infer/uninferred-consts.full.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/uninferred-consts.rs:14:9\n    |\n LL |     Foo.foo();\n-   |         ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `N`\n+   |         ^^^ cannot infer the value of const parameter `N` declared on the associated function `foo`\n \n error: aborting due to previous error\n "}, {"sha": "7a451903e9630581760706173e315db758c6dfce", "filename": "src/test/ui/const-generics/infer/uninferred-consts.min.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac8169dc106f2005d41d969c114d85e8e53bce61/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr?ref=ac8169dc106f2005d41d969c114d85e8e53bce61", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/uninferred-consts.rs:14:9\n    |\n LL |     Foo.foo();\n-   |         ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `N`\n+   |         ^^^ cannot infer the value of const parameter `N` declared on the associated function `foo`\n \n error: aborting due to previous error\n "}]}