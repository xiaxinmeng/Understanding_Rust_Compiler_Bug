{"sha": "2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjOGJiZjUwZGIwZWY5MGEzM2Y5ODZiYThmYzJlMWZlMTI5MTk3ZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-16T14:46:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-16T14:46:43Z"}, "message": "Auto merge of #59226 - kennytm:rollup, r=kennytm\n\nRollup of 37 pull requests\n\nSuccessful merges:\n\n - #58854 (appveyor: Use VS2017 for all our images)\n - #58855 (std: Spin for a global malloc lock on wasm32)\n - #58873 (Fix \"Auto-hide item methods documentation\" setting)\n - #58901 (Change `std::fs::copy` to use `copyfile` on MacOS and iOS)\n - #58933 (Move alloc::prelude::* to alloc::prelude::v1, make alloc a subset of std)\n - #58938 (core: ensure VaList passes improper_ctypes lint)\n - #58941 (MIPS: add r6 support)\n - #58949 (SGX target: Expose thread id function in os module)\n - #58959 (Add release notes for PR #56243)\n - #58976 (Default to integrated `rust-lld` linker for UEFI targets)\n - #59009 (Fix SGX implementations of read/write_vectored.)\n - #59025 (Fix generic argument lookup for Self)\n - #59036 (Fix ICE in MIR pretty printing)\n - #59037 (Avoid some common false positives in intra doc link checking)\n - #59072 (we can now skip should_panic tests with the libtest harness)\n - #59079 (add suggestions to invalid macro item error)\n - #59082 (A few improvements to comments in user-facing crates)\n - #59102 (Consistent naming for duration_float methods and additional f32 methods)\n - #59118 (rustc: fix ICE when trait alias has bare Self)\n - #59139 (Unregress using scalar unions in constants.)\n - #59146 (Suggest return lifetime when there's only one named lifetime)\n - #59147 (Make std time tests more robust for platform differences)\n - #59152 (Stabilize Range*::contains.)\n - #59156 ([wg-async-await] Add regression test for #55809.)\n - #59158 (Revert \"Don't generate minification variable if minification disabled\")\n - #59169 (Add `-Z allow_features=...` flag)\n - #59173 (bootstrap: Default to a sensible llvm-suffix.)\n - #59175 (Don't run test launching `echo` since that doesn't exist on Windows)\n - #59180 (Use try blocks in rustc_codegen_ssa)\n - #59185 (No old chestnuts in iter::repeat docs)\n - #59201 (Remove restriction on isize/usize in repr(simd))\n - #59204 (Output diagnostic information for rustdoc)\n - #59206 (Improved test output)\n - #59208 (Reduce a Code Repetition Related to Bit Operation)\n - #59212 (Add x86_64 musl host to the manifest)\n - #59221 (Option and Result: Add references to documentation of as_ref and as_mut)\n - #59231 (Stabilize Option::copied)", "tree": {"sha": "0d1a620d973a7dff4f6ca02a51bdd3e4814ba5c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d1a620d973a7dff4f6ca02a51bdd3e4814ba5c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "html_url": "https://github.com/rust-lang/rust/commit/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52e885628e4317aa3f158622435927eb29b812e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/52e885628e4317aa3f158622435927eb29b812e9", "html_url": "https://github.com/rust-lang/rust/commit/52e885628e4317aa3f158622435927eb29b812e9"}, {"sha": "7c009a4df7214290e6e5cf73d5bd5652fa8015dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c009a4df7214290e6e5cf73d5bd5652fa8015dc", "html_url": "https://github.com/rust-lang/rust/commit/7c009a4df7214290e6e5cf73d5bd5652fa8015dc"}], "stats": {"total": 1676, "additions": 1184, "deletions": 492}, "files": [{"sha": "a49e072e9eaa7efa8389daf63c5bd121d84f2e99", "filename": "RELEASES.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -110,8 +110,11 @@ Compatibility Notes\n   methods instead.\n - The `Error::cause` method has been deprecated in favor of `Error::source` which supports\n   downcasting.\n+- [Libtest no longer creates a new thread for each test when\n+  `--test-threads=1`.  It also runs the tests in deterministic order][56243]\n \n [55982]: https://github.com/rust-lang/rust/pull/55982/\n+[56243]: https://github.com/rust-lang/rust/pull/56243\n [56303]: https://github.com/rust-lang/rust/pull/56303/\n [56351]: https://github.com/rust-lang/rust/pull/56351/\n [56362]: https://github.com/rust-lang/rust/pull/56362"}, {"sha": "2abf723de496e46f9c23a337dc649bb1e57b3b12", "filename": "appveyor.yml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1,4 +1,7 @@\n environment:\n+  # This is required for at least an AArch64 compiler in one image, and is also\n+  # going to soon be required for compiling LLVM.\n+  APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017 Preview\n \n   # By default schannel checks revocation of certificates unlike some other SSL\n   # backends, but we've historically had problems on CI where a revocation\n@@ -81,7 +84,6 @@ environment:\n     DIST_REQUIRE_ALL_TOOLS: 1\n     DEPLOY: 1\n     CI_JOB_NAME: dist-x86_64-msvc\n-    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017 Preview\n   - RUST_CONFIGURE_ARGS: >\n       --build=i686-pc-windows-msvc\n       --target=i586-pc-windows-msvc"}, {"sha": "085f243785cbeb3270d9f3d6c32f371c720f3e3d", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -35,7 +35,7 @@ fn main() {\n         .arg(\"--cfg\")\n         .arg(\"dox\")\n         .arg(\"--sysroot\")\n-        .arg(sysroot)\n+        .arg(&sysroot)\n         .env(bootstrap::util::dylib_path_var(),\n              env::join_paths(&dylib_path).unwrap());\n \n@@ -72,7 +72,13 @@ fn main() {\n     }\n \n     if verbose > 1 {\n-        eprintln!(\"rustdoc command: {:?}\", cmd);\n+        eprintln!(\n+            \"rustdoc command: {:?}={:?} {:?}\",\n+            bootstrap::util::dylib_path_var(),\n+            env::join_paths(&dylib_path).unwrap(),\n+            cmd,\n+        );\n+        eprintln!(\"sysroot: {:?}\", sysroot);\n         eprintln!(\"libdir: {:?}\", libdir);\n     }\n "}, {"sha": "daa6749f87f3e7974be82219f8bcbf573181945b", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -408,11 +408,11 @@ impl<'a> Builder<'a> {\n                 test::RustdocJSStd,\n                 test::RustdocJSNotStd,\n                 test::RustdocTheme,\n+                test::RustdocUi,\n                 // Run bootstrap close to the end as it's unlikely to fail\n                 test::Bootstrap,\n                 // Run run-make last, since these won't pass without make on Windows\n                 test::RunMake,\n-                test::RustdocUi\n             ),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!("}, {"sha": "976b30a55c94b7d8db3e09a705069622ebfc9ade", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -241,6 +241,8 @@ pub struct Build {\n     clippy_info: channel::GitInfo,\n     miri_info: channel::GitInfo,\n     rustfmt_info: channel::GitInfo,\n+    in_tree_llvm_info: channel::GitInfo,\n+    emscripten_llvm_info: channel::GitInfo,\n     local_rebuild: bool,\n     fail_fast: bool,\n     doc_tests: DocTests,\n@@ -363,6 +365,8 @@ impl Build {\n         let clippy_info = channel::GitInfo::new(&config, &src.join(\"src/tools/clippy\"));\n         let miri_info = channel::GitInfo::new(&config, &src.join(\"src/tools/miri\"));\n         let rustfmt_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rustfmt\"));\n+        let in_tree_llvm_info = channel::GitInfo::new(&config, &src.join(\"src/llvm-project\"));\n+        let emscripten_llvm_info = channel::GitInfo::new(&config, &src.join(\"src/llvm-emscripten\"));\n \n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n@@ -386,6 +390,8 @@ impl Build {\n             clippy_info,\n             miri_info,\n             rustfmt_info,\n+            in_tree_llvm_info,\n+            emscripten_llvm_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n             ar: HashMap::new(),"}, {"sha": "3babbc9e102310b372112691091d0d3593564eb8", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -18,6 +18,7 @@ use build_helper::output;\n use cmake;\n use cc;\n \n+use crate::channel;\n use crate::util::{self, exe};\n use build_helper::up_to_date;\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n@@ -231,7 +232,26 @@ impl Step for Llvm {\n         }\n \n         if let Some(ref suffix) = builder.config.llvm_version_suffix {\n-            cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n+            // Allow version-suffix=\"\" to not define a version suffix at all.\n+            if !suffix.is_empty() {\n+                cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n+            }\n+        } else {\n+            let mut default_suffix = format!(\n+                \"-rust-{}-{}\",\n+                channel::CFG_RELEASE_NUM,\n+                builder.config.channel,\n+            );\n+            let llvm_info = if self.emscripten {\n+                &builder.emscripten_llvm_info\n+            } else {\n+                &builder.in_tree_llvm_info\n+            };\n+            if let Some(sha) = llvm_info.sha_short() {\n+                default_suffix.push_str(\"-\");\n+                default_suffix.push_str(sha);\n+            }\n+            cfg.define(\"LLVM_VERSION_SUFFIX\", default_suffix);\n         }\n \n         if let Some(ref linker) = builder.config.llvm_use_linker {"}, {"sha": "6767cf89f73ba2ce205cd784050eda5b9be72e5f", "filename": "src/liballoc/prelude.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/52e885628e4317aa3f158622435927eb29b812e9/src%2Fliballoc%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52e885628e4317aa3f158622435927eb29b812e9/src%2Fliballoc%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude.rs?ref=52e885628e4317aa3f158622435927eb29b812e9", "patch": "@@ -1,19 +0,0 @@\n-//! The alloc Prelude\n-//!\n-//! The purpose of this module is to alleviate imports of commonly-used\n-//! items of the `alloc` crate by adding a glob import to the top of modules:\n-//!\n-//! ```\n-//! # #![allow(unused_imports)]\n-//! # #![feature(alloc)]\n-//! extern crate alloc;\n-//! use alloc::prelude::*;\n-//! ```\n-\n-#![unstable(feature = \"alloc\", issue = \"27783\")]\n-\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::borrow::ToOwned;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::boxed::Box;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::slice::SliceConcatExt;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::string::{String, ToString};\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::vec::Vec;"}, {"sha": "33cc51d173203172a8e74aaa175491ccd4412a06", "filename": "src/liballoc/prelude/mod.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fmod.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,16 @@\n+//! The alloc Prelude\n+//!\n+//! The purpose of this module is to alleviate imports of commonly-used\n+//! items of the `alloc` crate by adding a glob import to the top of modules:\n+//!\n+//! ```\n+//! # #![allow(unused_imports)]\n+//! # #![feature(alloc)]\n+//! #![feature(alloc_prelude)]\n+//! extern crate alloc;\n+//! use alloc::prelude::v1::*;\n+//! ```\n+\n+#![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+\n+pub mod v1;"}, {"sha": "b6b01395ad63225f114dc23e756e310172856f61", "filename": "src/liballoc/prelude/v1.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fv1.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,11 @@\n+//! The first version of the prelude of `alloc` crate.\n+//!\n+//! See the [module-level documentation](../index.html) for more.\n+\n+#![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::borrow::ToOwned;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::boxed::Box;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::slice::SliceConcatExt;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::string::{String, ToString};\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::vec::Vec;"}, {"sha": "0930f8dacd494e7e6619989f086eca2c3a5405e2", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -282,7 +282,7 @@ fn assert_covariance() {\n //\n // Destructors must be called exactly once per element.\n #[test]\n-#[cfg(not(miri))] // Miri does not support panics\n+#[cfg(not(miri))] // Miri does not support panics nor entropy\n fn panic_safe() {\n     static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n "}, {"sha": "844afe870766ba1d2c161ecd9af933d96ee0890a", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -226,39 +226,34 @@ fn test_range_equal_empty_cases() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_range_equal_excluded() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(2), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_1() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Included(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_2() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Included(3), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_3() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_4() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(3), Excluded(2)));"}, {"sha": "b54c128a0249a59d7d00c77b5f2efcf2249027b7", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -258,7 +258,6 @@ fn test_swap_remove() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_swap_remove_fail() {\n     let mut v = vec![1];\n     let _ = v.swap_remove(0);\n@@ -632,7 +631,6 @@ fn test_insert() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_insert_oob() {\n     let mut a = vec![1, 2, 3];\n     a.insert(4, 5);\n@@ -657,7 +655,6 @@ fn test_remove() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_remove_fail() {\n     let mut a = vec![1];\n     let _ = a.remove(0);\n@@ -939,7 +936,6 @@ fn test_windowsator() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_windowsator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.windows(0);\n@@ -964,7 +960,6 @@ fn test_chunksator() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_chunksator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.chunks(0);\n@@ -989,7 +984,6 @@ fn test_chunks_exactator() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_chunks_exactator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.chunks_exact(0);\n@@ -1014,7 +1008,6 @@ fn test_rchunksator() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_rchunksator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.rchunks(0);\n@@ -1039,7 +1032,6 @@ fn test_rchunks_exactator() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_rchunks_exactator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.rchunks_exact(0);\n@@ -1092,7 +1084,6 @@ fn test_vec_default() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_overflow_does_not_cause_segfault() {\n     let mut v = vec![];\n     v.reserve_exact(!0);\n@@ -1102,7 +1093,6 @@ fn test_overflow_does_not_cause_segfault() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_overflow_does_not_cause_segfault_managed() {\n     let mut v = vec![Rc::new(1)];\n     v.reserve_exact(!0);\n@@ -1278,7 +1268,6 @@ fn test_mut_chunks_rev() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_chunks_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.chunks_mut(0);\n@@ -1311,7 +1300,6 @@ fn test_mut_chunks_exact_rev() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_chunks_exact_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.chunks_exact_mut(0);\n@@ -1344,7 +1332,6 @@ fn test_mut_rchunks_rev() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_rchunks_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.rchunks_mut(0);\n@@ -1377,7 +1364,6 @@ fn test_mut_rchunks_exact_rev() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_rchunks_exact_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.rchunks_exact_mut(0);\n@@ -1411,7 +1397,7 @@ fn test_box_slice_clone() {\n #[test]\n #[allow(unused_must_use)] // here, we care about the side effects of `.clone()`\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg(not(miri))] // Miri does not support panics\n+#[cfg(not(miri))] // Miri does not support threads nor entropy\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -1476,7 +1462,6 @@ fn test_copy_from_slice() {\n \n #[test]\n #[should_panic(expected = \"destination and source slices have different lengths\")]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_from_slice_dst_longer() {\n     let src = [0, 1, 2, 3];\n     let mut dst = [0; 5];\n@@ -1485,7 +1470,6 @@ fn test_copy_from_slice_dst_longer() {\n \n #[test]\n #[should_panic(expected = \"destination and source slices have different lengths\")]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_from_slice_dst_shorter() {\n     let src = [0, 1, 2, 3];\n     let mut dst = [0; 3];\n@@ -1605,7 +1589,7 @@ thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n-#[cfg(not(miri))] // Miri does not support panics\n+#[cfg(not(miri))] // Miri does not support threads nor entropy\n fn panic_safe() {\n     let prev = panic::take_hook();\n     panic::set_hook(Box::new(move |info| {"}, {"sha": "b197516403f7818e6a6b9b7a0f2cc08fb5dc799f", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -7,7 +7,7 @@ fn test_le() {\n     assert!(\"\" <= \"\");\n     assert!(\"\" <= \"foo\");\n     assert!(\"foo\" <= \"foo\");\n-    assert!(\"foo\" != \"bar\");\n+    assert_ne!(\"foo\", \"bar\");\n }\n \n #[test]\n@@ -351,7 +351,6 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of bounds\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_panic() {\n         assert_range_eq!(\"abc\", 0..5, \"abc\");\n     }\n@@ -361,7 +360,6 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"==\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_inequality() {\n         assert_range_eq!(\"abc\", 0..2, \"abc\");\n     }\n@@ -409,7 +407,6 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n-                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_fail() {\n                     let v: String = $data.into();\n                     let v: &str = &v;\n@@ -418,7 +415,6 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n-                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_mut_fail() {\n                     let mut v: String = $data.into();\n                     let v: &mut str = &mut v;\n@@ -514,7 +510,6 @@ mod slice_index {\n \n     #[test]\n     #[should_panic]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail() {\n         &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n     }\n@@ -666,14 +661,12 @@ mod slice_index {\n     // check the panic includes the prefix of the sliced string\n     #[test]\n     #[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail_truncated_1() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n     // check the truncation in the panic message\n     #[test]\n     #[should_panic(expected=\"luctus, im`[...]\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail_truncated_2() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n@@ -688,7 +681,6 @@ fn test_str_slice_rangetoinclusive_ok() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_str_slice_rangetoinclusive_notok() {\n     let s = \"abc\u03b1\u03b2\u03b3\";\n     &s[..=3];\n@@ -704,7 +696,6 @@ fn test_str_slicemut_rangetoinclusive_ok() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_str_slicemut_rangetoinclusive_notok() {\n     let mut s = \"abc\u03b1\u03b2\u03b3\".to_owned();\n     let s: &mut str = &mut s;\n@@ -894,7 +885,6 @@ fn test_as_bytes() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_as_bytes_fail() {\n     // Don't double free. (I'm not sure if this exercises the\n     // original problem code path anymore.)\n@@ -984,7 +974,6 @@ fn test_split_at_mut() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_split_at_boundscheck() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     s.split_at(1);"}, {"sha": "7e75b8c4f28c80687b2e77a22c5fa69d1c7e06da", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -231,7 +231,6 @@ fn test_split_off_empty() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_split_off_past_end() {\n     let orig = \"Hello, world!\";\n     let mut split = String::from(orig);\n@@ -240,7 +239,6 @@ fn test_split_off_past_end() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_split_off_mid_char() {\n     let mut orig = String::from(\"\u5c71\");\n     orig.split_off(1);\n@@ -289,7 +287,6 @@ fn test_str_truncate_invalid_len() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_str_truncate_split_codepoint() {\n     let mut s = String::from(\"\\u{FC}\"); // \u00fc\n     s.truncate(1);\n@@ -324,7 +321,6 @@ fn remove() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn remove_bad() {\n     \"\u0e28\".to_string().remove(1);\n }\n@@ -360,13 +356,11 @@ fn insert() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn insert_bad1() {\n     \"\".to_string().insert(1, 't');\n }\n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn insert_bad2() {\n     \"\u1ec7\".to_string().insert(1, 't');\n }\n@@ -447,7 +441,6 @@ fn test_replace_range() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_char_boundary() {\n     let mut s = \"Hello, \u4e16\u754c!\".to_owned();\n     s.replace_range(..8, \"\");\n@@ -464,15 +457,13 @@ fn test_replace_range_inclusive_range() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n     s.replace_range(5..6, \"789\");\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_inclusive_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n     s.replace_range(5..=5, \"789\");"}, {"sha": "545332bcd6a2f3985c5243bcb08b7f3417e7ce7f", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -368,7 +368,6 @@ fn test_vec_truncate_drop() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_vec_truncate_fail() {\n     struct BadElem(i32);\n     impl Drop for BadElem {\n@@ -392,55 +391,48 @@ fn test_index() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_index_out_of_bounds() {\n     let vec = vec![1, 2, 3];\n     let _ = vec[3];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_1() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[!0..];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_2() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[..6];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_3() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[!0..4];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_4() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[1..6];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_5() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[3..2];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_swap_remove_empty() {\n     let mut vec = Vec::<i32>::new();\n     vec.swap_remove(0);\n@@ -511,7 +503,6 @@ fn test_drain_items_zero_sized() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_drain_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     v.drain(5..6);\n@@ -585,7 +576,6 @@ fn test_drain_max_vec_size() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_drain_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     v.drain(5..=5);\n@@ -615,7 +605,6 @@ fn test_splice_inclusive_range() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_splice_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n@@ -624,7 +613,6 @@ fn test_splice_out_of_bounds() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_splice_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];"}, {"sha": "e0fe10a55f55c5623692cb5a3ef310de9f5d6100", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -108,7 +108,6 @@ fn test_index() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_index_out_of_bounds() {\n     let mut deq = VecDeque::new();\n     for i in 1..4 {"}, {"sha": "5cc9c25c21e0f81044eeac7d1f39a16601343edb", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -79,9 +79,9 @@ impl fmt::Debug for VaListImpl {\n                      all supported platforms\",\n            issue = \"44930\")]\n struct VaListImpl {\n-    stack: *mut (),\n-    gr_top: *mut (),\n-    vr_top: *mut (),\n+    stack: *mut c_void,\n+    gr_top: *mut c_void,\n+    vr_top: *mut c_void,\n     gr_offs: i32,\n     vr_offs: i32,\n }\n@@ -98,8 +98,8 @@ struct VaListImpl {\n     gpr: u8,\n     fpr: u8,\n     reserved: u16,\n-    overflow_arg_area: *mut (),\n-    reg_save_area: *mut (),\n+    overflow_arg_area: *mut c_void,\n+    reg_save_area: *mut c_void,\n }\n \n /// x86_64 ABI implementation of a `va_list`.\n@@ -113,8 +113,8 @@ struct VaListImpl {\n struct VaListImpl {\n     gp_offset: i32,\n     fp_offset: i32,\n-    overflow_arg_area: *mut (),\n-    reg_save_area: *mut (),\n+    overflow_arg_area: *mut c_void,\n+    reg_save_area: *mut c_void,\n }\n \n /// A wrapper for a `va_list`"}, {"sha": "cccd51b577930c78a6e6bc452ec60b011c8dd070", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1198,7 +1198,7 @@ impl<I: Iterator> Peekable<I> {\n     }\n }\n \n-/// An iterator that rejects elements while `predicate` is true.\n+/// An iterator that rejects elements while `predicate` returns `true`.\n ///\n /// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n /// documentation for more.\n@@ -1286,7 +1286,7 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n impl<I, P> FusedIterator for SkipWhile<I, P>\n     where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n \n-/// An iterator that only accepts elements while `predicate` is true.\n+/// An iterator that only accepts elements while `predicate` returns `true`.\n ///\n /// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n /// documentation for more."}, {"sha": "ffc24df3ed42e2cc0e07ef6b712afd438d90f3ba", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -39,8 +39,7 @@ unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n \n /// Creates a new iterator that endlessly repeats a single element.\n ///\n-/// The `repeat()` function repeats a single value over and over and over and\n-/// over and over and \ud83d\udd01.\n+/// The `repeat()` function repeats a single value over and over again.\n ///\n /// Infinite iterators like `repeat()` are often used with adapters like\n /// [`take`], in order to make them finite.\n@@ -128,8 +127,7 @@ unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}\n /// Creates a new iterator that repeats elements of type `A` endlessly by\n /// applying the provided closure, the repeater, `F: FnMut() -> A`.\n ///\n-/// The `repeat_with()` function calls the repeater over and over and over and\n-/// over and over and \ud83d\udd01.\n+/// The `repeat_with()` function calls the repeater over and over again.\n ///\n /// Infinite iterators like `repeat_with()` are often used with adapters like\n /// [`take`], in order to make them finite."}, {"sha": "3d2fcdc97937701fc8c16a27b21e47ff88bf3612", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1111,11 +1111,12 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// ```\n ///\n /// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n+//\n // FIXME before stabilizing, explain how to initialize a struct field-by-field.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n #[derive(Copy)]\n-// NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::uninitialized`.\n+// NOTE: after stabilizing `MaybeUninit`, proceed to deprecate `mem::uninitialized`.\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,\n@@ -1125,13 +1126,13 @@ pub union MaybeUninit<T> {\n impl<T: Copy> Clone for MaybeUninit<T> {\n     #[inline(always)]\n     fn clone(&self) -> Self {\n-        // Not calling T::clone(), we cannot know if we are initialized enough for that.\n+        // Not calling `T::clone()`, we cannot know if we are initialized enough for that.\n         *self\n     }\n }\n \n impl<T> MaybeUninit<T> {\n-    /// Create a new `MaybeUninit<T>` initialized with the given value.\n+    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n     ///\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n@@ -1239,6 +1240,7 @@ impl<T> MaybeUninit<T> {\n     /// let x_vec = unsafe { &*x.as_ptr() };\n     /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n     /// ```\n+    ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n@@ -1277,6 +1279,7 @@ impl<T> MaybeUninit<T> {\n     /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n     /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n     /// ```\n+    ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]"}, {"sha": "a83134a6b2ca49694ee4a2e0373dc2f29289f4a2", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -326,7 +326,7 @@ pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n     round_by_remainder(v, rem, q, z)\n }\n \n-/// Skip over most Algorithm M iterations by checking the bit length.\n+/// Skips over most Algorithm M iterations by checking the bit length.\n fn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n     // The bit length is an estimate of the base two logarithm, and log(u / v) = log(u) - log(v).\n     // The estimate is off by at most 1, but always an under-estimate, so the error on log(u)"}, {"sha": "d62cdae0688bea5f6c7bb8261d53b796afbd89e7", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -304,8 +304,8 @@ fn simplify(decimal: &mut Decimal) {\n     }\n }\n \n-/// Quick and dirty upper bound on the size (log10) of the largest value that Algorithm R and\n-/// Algorithm M will compute while working on the given decimal.\n+/// Returns a quick-an-dirty upper bound on the size (log10) of the largest value that Algorithm R\n+/// and Algorithm M will compute while working on the given decimal.\n fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 {\n     // We don't need to worry too much about overflow here thanks to trivial_cases() and the\n     // parser, which filter out the most extreme inputs for us.\n@@ -324,7 +324,7 @@ fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 {\n     }\n }\n \n-/// Detect obvious overflows and underflows without even looking at the decimal digits.\n+/// Detects obvious overflows and underflows without even looking at the decimal digits.\n fn trivial_cases<T: RawFloat>(decimal: &Decimal) -> Option<T> {\n     // There were zeros but they were stripped by simplify()\n     if decimal.integral.is_empty() && decimal.fractional.is_empty() {"}, {"sha": "f970595452ec9c8ab4f2899bd775212761cab104", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -78,7 +78,7 @@ pub fn parse_decimal(s: &str) -> ParseResult {\n     }\n }\n \n-/// Carve off decimal digits up to the first non-digit character.\n+/// Carves off decimal digits up to the first non-digit character.\n fn eat_digits(s: &[u8]) -> (&[u8], &[u8]) {\n     let mut i = 0;\n     while i < s.len() && b'0' <= s[i] && s[i] <= b'9' {"}, {"sha": "a8da31d3e4858c6eb0cb74494dbf59ff1c863f2b", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -10,7 +10,7 @@ use num::dec2flt::rawfp::RawFloat;\n ///\n /// - Any number from `(mant - minus) * 2^exp` to `(mant + plus) * 2^exp` will\n ///   round to the original value. The range is inclusive only when\n-///   `inclusive` is true.\n+///   `inclusive` is `true`.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Decoded {\n     /// The scaled mantissa."}, {"sha": "defd4247f4ea49b747d7fbc297ebf78bfa0176f1", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -315,15 +315,15 @@ fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n     }\n }\n \n-/// Formats given decimal digits `0.<...buf...> * 10^exp` into the exponential form\n-/// with at least given number of significant digits. When `upper` is true,\n+/// Formats the given decimal digits `0.<...buf...> * 10^exp` into the exponential\n+/// form with at least the given number of significant digits. When `upper` is `true`,\n /// the exponent will be prefixed by `E`; otherwise that's `e`. The result is\n /// stored to the supplied parts array and a slice of written parts is returned.\n ///\n /// `min_digits` can be less than the number of actual significant digits in `buf`;\n /// it will be ignored and full digits will be printed. It is only used to print\n-/// additional zeroes after rendered digits. Thus `min_digits` of 0 means that\n-/// it will only print given digits and nothing else.\n+/// additional zeroes after rendered digits. Thus, `min_digits == 0` means that\n+/// it will only print the given digits and nothing else.\n fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: bool,\n                          parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n@@ -384,7 +384,7 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n     }\n }\n \n-/// Formats given floating point number into the decimal form with at least\n+/// Formats the given floating point number into the decimal form with at least\n /// given number of fractional digits. The result is stored to the supplied parts\n /// array while utilizing given byte buffer as a scratch. `upper` is currently\n /// unused but left for the future decision to change the case of non-finite values,\n@@ -438,7 +438,7 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n     }\n }\n \n-/// Formats given floating point number into the decimal form or\n+/// Formats the given floating point number into the decimal form or\n /// the exponential form, depending on the resulting exponent. The result is\n /// stored to the supplied parts array while utilizing given byte buffer\n /// as a scratch. `upper` is used to determine the case of non-finite values\n@@ -497,7 +497,7 @@ pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n     }\n }\n \n-/// Returns rather crude approximation (upper bound) for the maximum buffer size\n+/// Returns a rather crude approximation (upper bound) for the maximum buffer size\n /// calculated from the given decoded exponent.\n ///\n /// The exact limit is:"}, {"sha": "4f71c8e794954157c8a9d3354b581661aa2d8b9a", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -71,7 +71,7 @@ impl fmt::Debug for RangeFull {\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n #[doc(alias = \"..\")]\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -95,8 +95,6 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!(!(3..5).contains(&2));\n@@ -112,7 +110,7 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// assert!(!(0.0..f32::NAN).contains(&0.5));\n     /// assert!(!(f32::NAN..1.0).contains(&0.5));\n     /// ```\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n         Idx: PartialOrd<U>,\n@@ -175,7 +173,7 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n ///\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n #[doc(alias = \"..\")]\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -196,8 +194,6 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!(!(3..).contains(&2));\n@@ -208,7 +204,7 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// assert!(!(0.0..).contains(&f32::NAN));\n     /// assert!(!(f32::NAN..).contains(&0.5));\n     /// ```\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n         Idx: PartialOrd<U>,\n@@ -280,8 +276,6 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!( (..5).contains(&-1_000_000_000));\n@@ -292,7 +286,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// assert!(!(..1.0).contains(&f32::NAN));\n     /// assert!(!(..f32::NAN).contains(&0.5));\n     /// ```\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n         Idx: PartialOrd<U>,\n@@ -329,7 +323,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);  // RangeInclusive\n /// ```\n #[doc(alias = \"..=\")]\n-#[derive(Clone)]  // not Copy -- see #27186\n+#[derive(Clone)] // not Copy -- see #27186\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeInclusive<Idx> {\n     pub(crate) start: Idx,\n@@ -365,7 +359,8 @@ impl<T: PartialOrd> RangeInclusiveEquality for T {\n impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n-        self.start == other.start && self.end == other.end\n+        self.start == other.start\n+            && self.end == other.end\n             && RangeInclusiveEquality::canonicalized_is_empty(self)\n                 == RangeInclusiveEquality::canonicalized_is_empty(other)\n     }\n@@ -397,7 +392,11 @@ impl<Idx> RangeInclusive<Idx> {\n     #[inline]\n     #[rustc_promotable]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self { start, end, is_empty: None }\n+        Self {\n+            start,\n+            end,\n+            is_empty: None,\n+        }\n     }\n \n     /// Returns the lower bound of the range (inclusive).\n@@ -478,8 +477,6 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!(!(3..=5).contains(&2));\n@@ -496,7 +493,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(!(0.0..=f32::NAN).contains(&0.0));\n     /// assert!(!(f32::NAN..=1.0).contains(&1.0));\n     /// ```\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n         Idx: PartialOrd<U>,\n@@ -609,15 +606,12 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     }\n }\n \n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!( (..=5).contains(&-1_000_000_000));\n@@ -628,7 +622,7 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// assert!(!(..=1.0).contains(&f32::NAN));\n     /// assert!(!(..=f32::NAN).contains(&0.5));\n     /// ```\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n         Idx: PartialOrd<U>,\n@@ -730,14 +724,11 @@ pub trait RangeBounds<T: ?Sized> {\n     #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n     fn end_bound(&self) -> Bound<&T>;\n \n-\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!( (3..5).contains(&4));\n@@ -747,7 +738,7 @@ pub trait RangeBounds<T: ?Sized> {\n     /// assert!(!(0.0..1.0).contains(&f32::NAN));\n     /// assert!(!(0.0..f32::NAN).contains(&0.5));\n     /// assert!(!(f32::NAN..1.0).contains(&0.5));\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     fn contains<U>(&self, item: &U) -> bool\n     where\n         T: PartialOrd<U>,\n@@ -757,9 +748,7 @@ pub trait RangeBounds<T: ?Sized> {\n             Included(ref start) => *start <= item,\n             Excluded(ref start) => *start < item,\n             Unbounded => true,\n-        })\n-        &&\n-        (match self.end_bound() {\n+        }) && (match self.end_bound() {\n             Included(ref end) => item <= *end,\n             Excluded(ref end) => item < *end,\n             Unbounded => true,\n@@ -835,15 +824,15 @@ impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n         match *self {\n             (Included(ref start), _) => Included(start),\n             (Excluded(ref start), _) => Excluded(start),\n-            (Unbounded, _)           => Unbounded,\n+            (Unbounded, _) => Unbounded,\n         }\n     }\n \n     fn end_bound(&self) -> Bound<&T> {\n         match *self {\n             (_, Included(ref end)) => Included(end),\n             (_, Excluded(ref end)) => Excluded(end),\n-            (_, Unbounded)         => Unbounded,\n+            (_, Unbounded) => Unbounded,\n         }\n     }\n }"}, {"sha": "dfc388409a84b53744287394c1428ab37639fe47", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -210,7 +210,7 @@ impl<T> Option<T> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Option<T>` to `Option<&T>`.\n+    /// Converts from `&Option<T>` to `Option<&T>`.\n     ///\n     /// # Examples\n     ///\n@@ -239,7 +239,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Converts from `Option<T>` to `Option<&mut T>`.\n+    /// Converts from `&mut Option<T>` to `Option<&mut T>`.\n     ///\n     /// # Examples\n     ///\n@@ -881,15 +881,13 @@ impl<T: Copy> Option<&T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(copied)]\n-    ///\n     /// let x = 12;\n     /// let opt_x = Some(&x);\n     /// assert_eq!(opt_x, Some(&12));\n     /// let copied = opt_x.copied();\n     /// assert_eq!(copied, Some(12));\n     /// ```\n-    #[unstable(feature = \"copied\", issue = \"57126\")]\n+    #[stable(feature = \"copied\", since = \"1.35.0\")]\n     pub fn copied(self) -> Option<T> {\n         self.map(|&t| t)\n     }\n@@ -902,15 +900,13 @@ impl<T: Copy> Option<&mut T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(copied)]\n-    ///\n     /// let mut x = 12;\n     /// let opt_x = Some(&mut x);\n     /// assert_eq!(opt_x, Some(&mut 12));\n     /// let copied = opt_x.copied();\n     /// assert_eq!(copied, Some(12));\n     /// ```\n-    #[unstable(feature = \"copied\", issue = \"57126\")]\n+    #[stable(feature = \"copied\", since = \"1.35.0\")]\n     pub fn copied(self) -> Option<T> {\n         self.map(|&mut t| t)\n     }"}, {"sha": "cf55b6c379d047482a0df491bf422ed1ee9f838f", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1,4 +1,4 @@\n-//! Types which pin data to its location in memory\n+//! Types that pin data to its location in memory.\n //!\n //! It is sometimes useful to have objects that are guaranteed to not move,\n //! in the sense that their placement in memory does not change, and can thus be relied upon."}, {"sha": "967f7e3e2fe72fc9cbbc2a80b3e44f13c412af74", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -369,7 +369,7 @@ impl<T, E> Result<T, E> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Result<T, E>` to `Result<&T, &E>`.\n+    /// Converts from `&Result<T, E>` to `Result<&T, &E>`.\n     ///\n     /// Produces a new `Result`, containing a reference\n     /// into the original, leaving the original in place.\n@@ -394,7 +394,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Converts from `Result<T, E>` to `Result<&mut T, &mut E>`.\n+    /// Converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "528281d317be34b23797774023d5bb58b1c2ac57", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -2968,7 +2968,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n@@ -3143,7 +3143,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n@@ -3326,7 +3326,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n@@ -3402,7 +3402,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///"}, {"sha": "12f812d3bed3eb6582519d1dab8ff6bdd7a407c9", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -108,7 +108,7 @@ impl Waker {\n         unsafe { (self.waker.vtable.wake)(self.waker.data) }\n     }\n \n-    /// Returns whether or not this `Waker` and other `Waker` have awaken the same task.\n+    /// Returns `true` if this `Waker` and another `Waker` have awoken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function"}, {"sha": "7bd7d1874101af0083f3ff9432cf67f6a0b059f8", "filename": "src/libcore/tests/cell.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcell.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -5,15 +5,15 @@ use std::mem::drop;\n #[test]\n fn smoketest_cell() {\n     let x = Cell::new(10);\n-    assert!(x == Cell::new(10));\n-    assert!(x.get() == 10);\n+    assert_eq!(x, Cell::new(10));\n+    assert_eq!(x.get(), 10);\n     x.set(20);\n-    assert!(x == Cell::new(20));\n-    assert!(x.get() == 20);\n+    assert_eq!(x, Cell::new(20));\n+    assert_eq!(x.get(), 20);\n \n     let y = Cell::new((30, 40));\n-    assert!(y == Cell::new((30, 40)));\n-    assert!(y.get() == (30, 40));\n+    assert_eq!(y, Cell::new((30, 40)));\n+    assert_eq!(y.get(), (30, 40));\n }\n \n #[test]\n@@ -109,7 +109,6 @@ fn double_borrow_single_release_no_borrow_mut() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn discard_doesnt_unborrow() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();\n@@ -350,7 +349,6 @@ fn refcell_ref_coercion() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn refcell_swap_borrows() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();\n@@ -360,7 +358,6 @@ fn refcell_swap_borrows() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn refcell_replace_borrows() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();"}, {"sha": "a3f0b02e2fe33f76b042cfb9ba445831cb2c2013", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -253,7 +253,6 @@ fn test_iterator_step_by_nth_overflow() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_iterator_step_by_zero() {\n     let mut it = (0..).step_by(0);\n     it.next();\n@@ -1442,7 +1441,6 @@ fn test_rposition() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_rposition_panic() {\n     let v: [(Box<_>, Box<_>); 4] =\n         [(box 0, box 0), (box 0, box 0),"}, {"sha": "a50310e195f0d81e37fa537afecbac71f3c49157", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1,6 +1,5 @@\n #![feature(box_syntax)]\n #![feature(cell_update)]\n-#![feature(copied)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n #![feature(dec2flt)]"}, {"sha": "b873f1dd0652f82855570caaf898692f2bac3354", "filename": "src/libcore/tests/num/bignum.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -3,7 +3,6 @@ use core::num::bignum::tests::Big8x3 as Big;\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_from_u64_overflow() {\n     Big::from_u64(0x1000000);\n }\n@@ -20,14 +19,12 @@ fn test_add() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_add_overflow_1() {\n     Big::from_small(1).add(&Big::from_u64(0xffffff));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_add_overflow_2() {\n     Big::from_u64(0xffffff).add(&Big::from_small(1));\n }\n@@ -45,7 +42,6 @@ fn test_add_small() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_add_small_overflow() {\n     Big::from_u64(0xffffff).add_small(1);\n }\n@@ -61,14 +57,12 @@ fn test_sub() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_sub_underflow_1() {\n     Big::from_u64(0x10665).sub(&Big::from_u64(0x10666));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_sub_underflow_2() {\n     Big::from_small(0).sub(&Big::from_u64(0x123456));\n }\n@@ -82,7 +76,6 @@ fn test_mul_small() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_small_overflow() {\n     Big::from_u64(0x800000).mul_small(2);\n }\n@@ -101,14 +94,12 @@ fn test_mul_pow2() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow2_overflow_1() {\n     Big::from_u64(0x1).mul_pow2(24);\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow2_overflow_2() {\n     Big::from_u64(0x123).mul_pow2(16);\n }\n@@ -127,14 +118,12 @@ fn test_mul_pow5() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow5_overflow_1() {\n     Big::from_small(1).mul_pow5(12);\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow5_overflow_2() {\n     Big::from_small(230).mul_pow5(8);\n }\n@@ -152,14 +141,12 @@ fn test_mul_digits() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_digits_overflow_1() {\n     Big::from_u64(0x800000).mul_digits(&[2]);\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_digits_overflow_2() {\n     Big::from_u64(0x1000).mul_digits(&[0, 0x10]);\n }\n@@ -219,7 +206,6 @@ fn test_get_bit() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_get_bit_out_of_range() {\n     Big::from_small(42).get_bit(24);\n }"}, {"sha": "4881f79ec248aee8d20c00f4e91a6fd7b8dee2ec", "filename": "src/libcore/tests/num/int_macros.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -12,7 +12,7 @@ mod tests {\n     fn test_overflows() {\n         assert!(MAX > 0);\n         assert!(MIN <= 0);\n-        assert!(MIN + MAX + 1 == 0);\n+        assert_eq!(MIN + MAX + 1, 0);\n     }\n \n     #[test]\n@@ -22,22 +22,22 @@ mod tests {\n \n     #[test]\n     fn test_rem_euclid() {\n-        assert!((-1 as $T).rem_euclid(MIN) == MAX);\n+        assert_eq!((-1 as $T).rem_euclid(MIN), MAX);\n     }\n \n     #[test]\n     pub fn test_abs() {\n-        assert!((1 as $T).abs() == 1 as $T);\n-        assert!((0 as $T).abs() == 0 as $T);\n-        assert!((-1 as $T).abs() == 1 as $T);\n+        assert_eq!((1 as $T).abs(), 1 as $T);\n+        assert_eq!((0 as $T).abs(), 0 as $T);\n+        assert_eq!((-1 as $T).abs(), 1 as $T);\n     }\n \n     #[test]\n     fn test_signum() {\n-        assert!((1 as $T).signum() == 1 as $T);\n-        assert!((0 as $T).signum() == 0 as $T);\n-        assert!((-0 as $T).signum() == 0 as $T);\n-        assert!((-1 as $T).signum() == -1 as $T);\n+        assert_eq!((1 as $T).signum(), 1 as $T);\n+        assert_eq!((0 as $T).signum(), 0 as $T);\n+        assert_eq!((-0 as $T).signum(), 0 as $T);\n+        assert_eq!((-1 as $T).signum(), -1 as $T);\n     }\n \n     #[test]\n@@ -58,12 +58,12 @@ mod tests {\n \n     #[test]\n     fn test_bitwise_operators() {\n-        assert!(0b1110 as $T == (0b1100 as $T).bitor(0b1010 as $T));\n-        assert!(0b1000 as $T == (0b1100 as $T).bitand(0b1010 as $T));\n-        assert!(0b0110 as $T == (0b1100 as $T).bitxor(0b1010 as $T));\n-        assert!(0b1110 as $T == (0b0111 as $T).shl(1));\n-        assert!(0b0111 as $T == (0b1110 as $T).shr(1));\n-        assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n+        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(0b1010 as $T));\n+        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(0b1010 as $T));\n+        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(0b1010 as $T));\n+        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(1));\n+        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(1));\n+        assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n     }\n \n     const A: $T = 0b0101100;\n@@ -75,17 +75,17 @@ mod tests {\n \n     #[test]\n     fn test_count_ones() {\n-        assert!(A.count_ones() == 3);\n-        assert!(B.count_ones() == 2);\n-        assert!(C.count_ones() == 5);\n+        assert_eq!(A.count_ones(), 3);\n+        assert_eq!(B.count_ones(), 2);\n+        assert_eq!(C.count_ones(), 5);\n     }\n \n     #[test]\n     fn test_count_zeros() {\n         let bits = mem::size_of::<$T>() * 8;\n-        assert!(A.count_zeros() == bits as u32 - 3);\n-        assert!(B.count_zeros() == bits as u32 - 2);\n-        assert!(C.count_zeros() == bits as u32 - 5);\n+        assert_eq!(A.count_zeros(), bits as u32 - 3);\n+        assert_eq!(B.count_zeros(), bits as u32 - 2);\n+        assert_eq!(C.count_zeros(), bits as u32 - 5);\n     }\n \n     #[test]\n@@ -148,9 +148,9 @@ mod tests {\n \n     #[test]\n     fn test_signed_checked_div() {\n-        assert!((10 as $T).checked_div(2) == Some(5));\n-        assert!((5 as $T).checked_div(0) == None);\n-        assert!(isize::MIN.checked_div(-1) == None);\n+        assert_eq!((10 as $T).checked_div(2), Some(5));\n+        assert_eq!((5 as $T).checked_div(0), None);\n+        assert_eq!(isize::MIN.checked_div(-1), None);\n     }\n \n     #[test]"}, {"sha": "78cf07119e729770a6c1ecf83c77efc912474651", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -7,23 +7,23 @@ fn test_range() {\n     let r = Range { start: 2, end: 10 };\n     let mut count = 0;\n     for (i, ri) in r.enumerate() {\n-        assert!(ri == i + 2);\n+        assert_eq!(ri, i + 2);\n         assert!(ri >= 2 && ri < 10);\n         count += 1;\n     }\n-    assert!(count == 8);\n+    assert_eq!(count, 8);\n }\n \n #[test]\n fn test_range_from() {\n     let r = RangeFrom { start: 2 };\n     let mut count = 0;\n     for (i, ri) in r.take(10).enumerate() {\n-        assert!(ri == i + 2);\n+        assert_eq!(ri, i + 2);\n         assert!(ri >= 2 && ri < 12);\n         count += 1;\n     }\n-    assert!(count == 10);\n+    assert_eq!(count, 10);\n }\n \n #[test]"}, {"sha": "b059b134868d999fae75fe4e75eba3c2ea03a3a7", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -69,7 +69,6 @@ fn test_option_dance() {\n }\n \n #[test] #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_option_too_much_dance() {\n     struct A;\n     let mut y = Some(A);\n@@ -130,15 +129,13 @@ fn test_unwrap() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_unwrap_panic1() {\n     let x: Option<isize> = None;\n     x.unwrap();\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_unwrap_panic2() {\n     let x: Option<String> = None;\n     x.unwrap();"}, {"sha": "1fab07526a07f7f3954a1faa84b802cb4751e795", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -117,7 +117,6 @@ fn test_unwrap_or_else() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n pub fn test_unwrap_or_else_panic() {\n     fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n@@ -139,7 +138,6 @@ pub fn test_expect_ok() {\n }\n #[test]\n #[should_panic(expected=\"Got expected error: \\\"All good\\\"\")]\n-#[cfg(not(miri))] // Miri does not support panics\n pub fn test_expect_err() {\n     let err: Result<isize, &'static str> = Err(\"All good\");\n     err.expect(\"Got expected error\");\n@@ -153,7 +151,6 @@ pub fn test_expect_err_err() {\n }\n #[test]\n #[should_panic(expected=\"Got expected ok: \\\"All good\\\"\")]\n-#[cfg(not(miri))] // Miri does not support panics\n pub fn test_expect_err_ok() {\n     let err: Result<&'static str, isize> = Ok(\"All good\");\n     err.expect_err(\"Got expected ok\");"}, {"sha": "ac9c17a0f7c356ec4962927297b2490ad09044d5", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -782,7 +782,6 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of range\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_panic() {\n         assert_range_eq!([0, 1, 2], 0..5, [0, 1, 2]);\n     }\n@@ -792,7 +791,6 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"==\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_inequality() {\n         assert_range_eq!([0, 1, 2], 0..2, [0, 1, 2]);\n     }\n@@ -842,7 +840,6 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n-                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_fail() {\n                     let v = $data;\n                     let v: &[_] = &v;\n@@ -851,7 +848,6 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n-                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_mut_fail() {\n                     let mut v = $data;\n                     let v: &mut [_] = &mut v;\n@@ -1304,7 +1300,6 @@ fn test_copy_within() {\n \n #[test]\n #[should_panic(expected = \"src is out of bounds\")]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_src_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so 14 is out of bounds.\n@@ -1313,15 +1308,13 @@ fn test_copy_within_panics_src_too_long() {\n \n #[test]\n #[should_panic(expected = \"dest is out of bounds\")]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_dest_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so a slice of length 4 starting at index 10 is out of bounds.\n     bytes.copy_within(0..4, 10);\n }\n #[test]\n #[should_panic(expected = \"src end is before src start\")]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_src_inverted() {\n     let mut bytes = *b\"Hello, World!\";\n     // 2 is greater than 1, so this range is invalid."}, {"sha": "6efd22572dc185d57fe9b06062cfccd93754e48a", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -107,14 +107,12 @@ fn checked_sub() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn sub_bad1() {\n     let _ = Duration::new(0, 0) - Duration::new(0, 1);\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn sub_bad2() {\n     let _ = Duration::new(0, 0) - Duration::new(1, 0);\n }"}, {"sha": "ae6d8078fd2366ecb8452cac364b325cf619fae7", "filename": "src/libcore/time.rs", "status": "modified", "additions": 129, "deletions": 11, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -21,7 +21,6 @@ const NANOS_PER_MILLI: u32 = 1_000_000;\n const NANOS_PER_MICRO: u32 = 1_000;\n const MILLIS_PER_SEC: u64 = 1_000;\n const MICROS_PER_SEC: u64 = 1_000_000;\n-const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f64;\n \n /// A `Duration` type to represent a span of time, typically used for system\n /// timeouts.\n@@ -510,15 +509,34 @@ impl Duration {\n     /// use std::time::Duration;\n     ///\n     /// let dur = Duration::new(2, 700_000_000);\n-    /// assert_eq!(dur.as_float_secs(), 2.7);\n+    /// assert_eq!(dur.as_secs_f64(), 2.7);\n     /// ```\n     #[unstable(feature = \"duration_float\", issue = \"54361\")]\n     #[inline]\n-    pub const fn as_float_secs(&self) -> f64 {\n+    pub const fn as_secs_f64(&self) -> f64 {\n         (self.secs as f64) + (self.nanos as f64) / (NANOS_PER_SEC as f64)\n     }\n \n-    /// Creates a new `Duration` from the specified number of seconds.\n+    /// Returns the number of seconds contained by this `Duration` as `f32`.\n+    ///\n+    /// The returned value does include the fractional (nanosecond) part of the duration.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_float)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur = Duration::new(2, 700_000_000);\n+    /// assert_eq!(dur.as_secs_f32(), 2.7);\n+    /// ```\n+    #[unstable(feature = \"duration_float\", issue = \"54361\")]\n+    #[inline]\n+    pub const fn as_secs_f32(&self) -> f32 {\n+        (self.secs as f32) + (self.nanos as f32) / (NANOS_PER_SEC as f32)\n+    }\n+\n+    /// Creates a new `Duration` from the specified number of seconds represented\n+    /// as `f64`.\n     ///\n     /// # Panics\n     /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n@@ -528,12 +546,14 @@ impl Duration {\n     /// #![feature(duration_float)]\n     /// use std::time::Duration;\n     ///\n-    /// let dur = Duration::from_float_secs(2.7);\n+    /// let dur = Duration::from_secs_f64(2.7);\n     /// assert_eq!(dur, Duration::new(2, 700_000_000));\n     /// ```\n     #[unstable(feature = \"duration_float\", issue = \"54361\")]\n     #[inline]\n-    pub fn from_float_secs(secs: f64) -> Duration {\n+    pub fn from_secs_f64(secs: f64) -> Duration {\n+        const MAX_NANOS_F64: f64 =\n+            ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f64;\n         let nanos =  secs * (NANOS_PER_SEC as f64);\n         if !nanos.is_finite() {\n             panic!(\"got non-finite value when converting float to duration\");\n@@ -551,6 +571,42 @@ impl Duration {\n         }\n     }\n \n+    /// Creates a new `Duration` from the specified number of seconds represented\n+    /// as `f32`.\n+    ///\n+    /// # Panics\n+    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_float)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur = Duration::from_secs_f32(2.7);\n+    /// assert_eq!(dur, Duration::new(2, 700_000_000));\n+    /// ```\n+    #[unstable(feature = \"duration_float\", issue = \"54361\")]\n+    #[inline]\n+    pub fn from_secs_f32(secs: f32) -> Duration {\n+        const MAX_NANOS_F32: f32 =\n+            ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f32;\n+        let nanos =  secs * (NANOS_PER_SEC as f32);\n+        if !nanos.is_finite() {\n+            panic!(\"got non-finite value when converting float to duration\");\n+        }\n+        if nanos >= MAX_NANOS_F32 {\n+            panic!(\"overflow when converting float to duration\");\n+        }\n+        if nanos < 0.0 {\n+            panic!(\"underflow when converting float to duration\");\n+        }\n+        let nanos =  nanos as u128;\n+        Duration {\n+            secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n+            nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n+        }\n+    }\n+\n     /// Multiplies `Duration` by `f64`.\n     ///\n     /// # Panics\n@@ -568,7 +624,29 @@ impl Duration {\n     #[unstable(feature = \"duration_float\", issue = \"54361\")]\n     #[inline]\n     pub fn mul_f64(self, rhs: f64) -> Duration {\n-        Duration::from_float_secs(rhs * self.as_float_secs())\n+        Duration::from_secs_f64(rhs * self.as_secs_f64())\n+    }\n+\n+    /// Multiplies `Duration` by `f32`.\n+    ///\n+    /// # Panics\n+    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_float)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur = Duration::new(2, 700_000_000);\n+    /// // note that due to rounding errors result is slightly different\n+    /// // from 8.478 and 847800.0\n+    /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_640));\n+    /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847799, 969_120_256));\n+    /// ```\n+    #[unstable(feature = \"duration_float\", issue = \"54361\")]\n+    #[inline]\n+    pub fn mul_f32(self, rhs: f32) -> Duration {\n+        Duration::from_secs_f32(rhs * self.as_secs_f32())\n     }\n \n     /// Divide `Duration` by `f64`.\n@@ -589,7 +667,30 @@ impl Duration {\n     #[unstable(feature = \"duration_float\", issue = \"54361\")]\n     #[inline]\n     pub fn div_f64(self, rhs: f64) -> Duration {\n-        Duration::from_float_secs(self.as_float_secs() / rhs)\n+        Duration::from_secs_f64(self.as_secs_f64() / rhs)\n+    }\n+\n+    /// Divide `Duration` by `f32`.\n+    ///\n+    /// # Panics\n+    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_float)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur = Duration::new(2, 700_000_000);\n+    /// // note that due to rounding errors result is slightly\n+    /// // different from 0.859_872_611\n+    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_576));\n+    /// // note that truncation is used, not rounding\n+    /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_598));\n+    /// ```\n+    #[unstable(feature = \"duration_float\", issue = \"54361\")]\n+    #[inline]\n+    pub fn div_f32(self, rhs: f32) -> Duration {\n+        Duration::from_secs_f32(self.as_secs_f32() / rhs)\n     }\n \n     /// Divide `Duration` by `Duration` and return `f64`.\n@@ -601,12 +702,29 @@ impl Duration {\n     ///\n     /// let dur1 = Duration::new(2, 700_000_000);\n     /// let dur2 = Duration::new(5, 400_000_000);\n-    /// assert_eq!(dur1.div_duration(dur2), 0.5);\n+    /// assert_eq!(dur1.div_duration_f64(dur2), 0.5);\n+    /// ```\n+    #[unstable(feature = \"duration_float\", issue = \"54361\")]\n+    #[inline]\n+    pub fn div_duration_f64(self, rhs: Duration) -> f64 {\n+        self.as_secs_f64() / rhs.as_secs_f64()\n+    }\n+\n+    /// Divide `Duration` by `Duration` and return `f32`.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_float)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur1 = Duration::new(2, 700_000_000);\n+    /// let dur2 = Duration::new(5, 400_000_000);\n+    /// assert_eq!(dur1.div_duration_f32(dur2), 0.5);\n     /// ```\n     #[unstable(feature = \"duration_float\", issue = \"54361\")]\n     #[inline]\n-    pub fn div_duration(self, rhs: Duration) -> f64 {\n-        self.as_float_secs() / rhs.as_float_secs()\n+    pub fn div_duration_f32(self, rhs: Duration) -> f32 {\n+        self.as_secs_f32() / rhs.as_secs_f32()\n     }\n }\n "}, {"sha": "151c5413dcf6058cd084d36ed5e5003c59a43d6a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -541,15 +541,17 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n         match self.get_by_hir_id(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n+            Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => id,\n             Node::GenericParam(_) => self.get_parent_node_by_hir_id(id),\n             _ => bug!(\"ty_param_owner: {} not a type parameter\", self.hir_to_string(id))\n         }\n     }\n \n     pub fn ty_param_name(&self, id: HirId) -> Name {\n         match self.get_by_hir_id(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfUpper.name(),\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n+            Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => keywords::SelfUpper.name(),\n             Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.hir_to_string(id)),\n         }"}, {"sha": "ab105360388722bdd72c378d7a935153362a3592", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -2299,19 +2299,26 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let span = lifetime_refs[0].span;\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n+        let mut lifetime_names = FxHashSet::default();\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n                 Scope::Body { .. } => return,\n \n                 Scope::Root => break None,\n \n-                Scope::Binder { s, .. } => {\n+                Scope::Binder { s, ref lifetimes, .. } => {\n+                    // collect named lifetimes for suggestions\n+                    for name in lifetimes.keys() {\n+                        if let hir::ParamName::Plain(name) = name {\n+                            lifetime_names.insert(*name);\n+                        }\n+                    }\n                     late_depth += 1;\n                     scope = s;\n                 }\n \n-                Scope::Elision { ref elide, .. } => {\n+                Scope::Elision { ref elide, ref s, .. } => {\n                     let lifetime = match *elide {\n                         Elide::FreshLateAnon(ref counter) => {\n                             for lifetime_ref in lifetime_refs {\n@@ -2321,7 +2328,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             return;\n                         }\n                         Elide::Exact(l) => l.shifted(late_depth),\n-                        Elide::Error(ref e) => break Some(e),\n+                        Elide::Error(ref e) => {\n+                            if let Scope::Binder { ref lifetimes, .. } = s {\n+                                // collect named lifetimes for suggestions\n+                                for name in lifetimes.keys() {\n+                                    if let hir::ParamName::Plain(name) = name {\n+                                        lifetime_names.insert(*name);\n+                                    }\n+                                }\n+                            }\n+                            break Some(e);\n+                        }\n                     };\n                     for lifetime_ref in lifetime_refs {\n                         self.insert_lifetime(lifetime_ref, lifetime);\n@@ -2344,7 +2361,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n         if add_label {\n-            add_missing_lifetime_specifiers_label(&mut err, span, lifetime_refs.len());\n+            add_missing_lifetime_specifiers_label(\n+                &mut err,\n+                span,\n+                lifetime_refs.len(),\n+                &lifetime_names,\n+                self.tcx.sess.source_map().span_to_snippet(span).ok().as_ref().map(|s| s.as_str()),\n+            );\n         }\n \n         err.emit();\n@@ -2885,10 +2908,23 @@ fn add_missing_lifetime_specifiers_label(\n     err: &mut DiagnosticBuilder<'_>,\n     span: Span,\n     count: usize,\n+    lifetime_names: &FxHashSet<ast::Ident>,\n+    snippet: Option<&str>,\n ) {\n     if count > 1 {\n         err.span_label(span, format!(\"expected {} lifetime parameters\", count));\n+    } else if let (1, Some(name), Some(\"&\")) = (\n+        lifetime_names.len(),\n+        lifetime_names.iter().next(),\n+        snippet,\n+    ) {\n+        err.span_suggestion(\n+            span,\n+            \"consider using the named lifetime\",\n+            format!(\"&{} \", name),\n+            Applicability::MaybeIncorrect,\n+        );\n     } else {\n         err.span_label(span, \"expected lifetime parameter\");\n-    };\n+    }\n }"}, {"sha": "ff18678f091b90f108e23c504364f49cff33b23e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -800,6 +800,7 @@ macro_rules! options {\n         pub const parse_opt_pathbuf: Option<&str> = Some(\"a path\");\n         pub const parse_list: Option<&str> = Some(\"a space-separated list of strings\");\n         pub const parse_opt_list: Option<&str> = Some(\"a space-separated list of strings\");\n+        pub const parse_opt_comma_list: Option<&str> = Some(\"a comma-separated list of strings\");\n         pub const parse_uint: Option<&str> = Some(\"a number\");\n         pub const parse_passes: Option<&str> =\n             Some(\"a space-separated list of passes, or `all`\");\n@@ -926,6 +927,18 @@ macro_rules! options {\n             }\n         }\n \n+        fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n+                      -> bool {\n+            match v {\n+                Some(s) => {\n+                    let v = s.split(',').map(|s| s.to_string()).collect();\n+                    *slot = Some(v);\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n         fn parse_uint(slot: &mut usize, v: Option<&str>) -> bool {\n             match v.and_then(|s| s.parse().ok()) {\n                 Some(i) => { *slot = i; true },\n@@ -1427,6 +1440,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n         \"control the operation of the MergeFunctions LLVM pass, taking\n          the same values as the target option of the same name\"),\n+    allow_features: Option<Vec<String>> = (None, parse_opt_comma_list, [TRACKED],\n+        \"only allow the listed language features to be enabled in code (space separated)\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -3273,6 +3288,10 @@ mod tests {\n         opts = reference.clone();\n         opts.debugging_opts.merge_functions = Some(MergeFunctions::Disabled);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.allow_features = Some(vec![String::from(\"lang_items\")]);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n     }\n \n     #[test]"}, {"sha": "7b6a51c01845980bc9764e623050f0e702efa972", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1911,7 +1911,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_machine(&self) -> bool {\n         match self.sty {\n-            Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => false,\n             Int(..) | Uint(..) | Float(..) => true,\n             _ => false,\n         }"}, {"sha": "c75788ecb4fbd3da5de704208f12ef88e160347f", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -15,7 +15,6 @@\n #![allow(unused_attributes)]\n #![feature(libc)]\n #![feature(nll)]\n-#![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(optin_builtin_traits)]\n #![feature(concat_idents)]"}, {"sha": "e6470dbb61ce18649625555d582ede8430586b6a", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -382,29 +382,27 @@ impl<'a> Linker for GccLinker<'a> {\n \n         if self.sess.target.target.options.is_like_osx {\n             // Write a plain, newline-separated list of symbols\n-            let res = (|| -> io::Result<()> {\n+            let res: io::Result<()> = try {\n                 let mut f = BufWriter::new(File::create(&path)?);\n                 for sym in self.info.exports[&crate_type].iter() {\n                     debug!(\"  _{}\", sym);\n                     writeln!(f, \"_{}\", sym)?;\n                 }\n-                Ok(())\n-            })();\n+            };\n             if let Err(e) = res {\n                 self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n             }\n         } else {\n             // Write an LD version script\n-            let res = (|| -> io::Result<()> {\n+            let res: io::Result<()> = try {\n                 let mut f = BufWriter::new(File::create(&path)?);\n                 writeln!(f, \"{{\\n  global:\")?;\n                 for sym in self.info.exports[&crate_type].iter() {\n                     debug!(\"    {};\", sym);\n                     writeln!(f, \"    {};\", sym)?;\n                 }\n                 writeln!(f, \"\\n  local:\\n    *;\\n}};\")?;\n-                Ok(())\n-            })();\n+            };\n             if let Err(e) = res {\n                 self.sess.fatal(&format!(\"failed to write version script: {}\", e));\n             }\n@@ -644,7 +642,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n                       tmpdir: &Path,\n                       crate_type: CrateType) {\n         let path = tmpdir.join(\"lib.def\");\n-        let res = (|| -> io::Result<()> {\n+        let res: io::Result<()> = try {\n             let mut f = BufWriter::new(File::create(&path)?);\n \n             // Start off with the standard module name header and then go\n@@ -655,8 +653,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n                 debug!(\"  _{}\", symbol);\n                 writeln!(f, \"  {}\", symbol)?;\n             }\n-            Ok(())\n-        })();\n+        };\n         if let Err(e) = res {\n             self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n         }"}, {"sha": "fe9b88c85f009fc5507ef57390d94284287a9e8a", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -7,6 +7,7 @@\n #![feature(libc)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(stmt_expr_attributes)]\n+#![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![allow(unused_attributes)]"}, {"sha": "6b4b437930d2609b642b4bc20036a0b059c71d29", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -2,7 +2,6 @@\n \n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n-#![feature(range_contains)]\n #![cfg_attr(unix, feature(libc))]\n #![feature(nll)]\n #![feature(optin_builtin_traits)]"}, {"sha": "0c710fd283be83fd37608a1190d770c7c89f49d3", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -243,6 +243,7 @@ pub fn register_plugins<'a>(\n         krate,\n         &sess.parse_sess,\n         sess.edition(),\n+        &sess.opts.debugging_opts.allow_features,\n     );\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n     sess.init_features(features);"}, {"sha": "77978d7d38ff79b14fc22ffe355e99653638a43f", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -114,14 +114,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n                     }\n                     ty::Int(ity) => {\n-                        // FIXME(49937): refactor these bit manipulations into interpret.\n                         let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n                         let max = truncate(u128::max_value(), size);\n                         let bias = 1u128 << (size.bits() - 1);\n                         (Some((0, max, size)), bias)\n                     }\n                     ty::Uint(uty) => {\n-                        // FIXME(49937): refactor these bit manipulations into interpret.\n                         let size = Integer::from_attr(&tcx, UnsignedInt(uty)).size();\n                         let max = truncate(u128::max_value(), size);\n                         (Some((0, max, size)), 0)"}, {"sha": "71d9398c686b7ac3818385db02bd9965a8b45fa3", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -65,12 +65,12 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n fn mplace_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     mplace: MPlaceTy<'tcx>,\n-) -> EvalResult<'tcx, ty::Const<'tcx>> {\n+) -> ty::Const<'tcx> {\n     let MemPlace { ptr, align, meta } = *mplace;\n     // extract alloc-offset pair\n     assert!(meta.is_none());\n-    let ptr = ptr.to_ptr()?;\n-    let alloc = ecx.memory.get(ptr.alloc_id)?;\n+    let ptr = ptr.to_ptr().unwrap();\n+    let alloc = ecx.memory.get(ptr.alloc_id).unwrap();\n     assert!(alloc.align >= align);\n     assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= mplace.layout.size.bytes());\n     let mut alloc = alloc.clone();\n@@ -79,16 +79,16 @@ fn mplace_to_const<'tcx>(\n     // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n     let alloc = ecx.tcx.intern_const_alloc(alloc);\n     let val = ConstValue::ByRef(ptr, alloc);\n-    Ok(ty::Const { val, ty: mplace.layout.ty })\n+    ty::Const { val, ty: mplace.layout.ty }\n }\n \n fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     op: OpTy<'tcx>,\n-) -> EvalResult<'tcx, ty::Const<'tcx>> {\n-    // We do not normalize just any data.  Only scalar layout and slices.\n+) -> ty::Const<'tcx> {\n+    // We do not normalize just any data.  Only non-union scalars and slices.\n     let normalize = match op.layout.abi {\n-        layout::Abi::Scalar(..) => true,\n+        layout::Abi::Scalar(..) => op.layout.ty.ty_adt_def().map_or(true, |adt| !adt.is_union()),\n         layout::Abi::ScalarPair(..) => op.layout.ty.is_slice(),\n         _ => false,\n     };\n@@ -100,11 +100,11 @@ fn op_to_const<'tcx>(\n     let val = match normalized_op {\n         Ok(mplace) => return mplace_to_const(ecx, mplace),\n         Err(Immediate::Scalar(x)) =>\n-            ConstValue::Scalar(x.not_undef()?),\n+            ConstValue::Scalar(x.not_undef().unwrap()),\n         Err(Immediate::ScalarPair(a, b)) =>\n-            ConstValue::Slice(a.not_undef()?, b.to_usize(ecx)?),\n+            ConstValue::Slice(a.not_undef().unwrap(), b.to_usize(ecx).unwrap()),\n     };\n-    Ok(ty::Const { val, ty: op.layout.ty })\n+    ty::Const { val, ty: op.layout.ty }\n }\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n@@ -488,7 +488,7 @@ pub fn const_field<'a, 'tcx>(\n     let field = ecx.operand_field(down, field.index() as u64).unwrap();\n     // and finally move back to the const world, always normalizing because\n     // this is not called for statics.\n-    op_to_const(&ecx, field).unwrap()\n+    op_to_const(&ecx, field)\n }\n \n // this function uses `unwrap` copiously, because an already validated constant must have valid\n@@ -534,9 +534,9 @@ fn validate_and_turn_into_const<'a, 'tcx>(\n         // Now that we validated, turn this into a proper constant.\n         let def_id = cid.instance.def.def_id();\n         if tcx.is_static(def_id).is_some() || cid.promoted.is_some() {\n-            mplace_to_const(&ecx, mplace)\n+            Ok(mplace_to_const(&ecx, mplace))\n         } else {\n-            op_to_const(&ecx, mplace.into())\n+            Ok(op_to_const(&ecx, mplace.into()))\n         }\n     })();\n "}, {"sha": "44bcb9de0e1578dee06dbe23542bd3f116c55033", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -172,7 +172,7 @@ use rustc::ty::{self, subst::SubstsRef, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::{ConstValue, Scalar};\n+use rustc::mir::interpret::{ConstValue, Scalar, truncate};\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -678,16 +678,14 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             ]\n         }\n         ty::Int(ity) => {\n-            // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n-            let max = (1u128 << (bits - 1)) - 1;\n+            let max = min - 1;\n             vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included)]\n         }\n         ty::Uint(uty) => {\n-            // FIXME(49937): refactor these bit manipulations into interpret.\n-            let bits = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n-            let max = !0u128 >> (128 - bits);\n+            let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n+            let max = truncate(u128::max_value(), size);\n             vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included)]\n         }\n         _ => {"}, {"sha": "c45e694ebf832a65371b9981329dd85b0207a730", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -14,7 +14,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(const_fn)]\n #![feature(decl_macro)]\n #![feature(exhaustive_patterns)]\n-#![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_attrs)]\n #![feature(never_type)]"}, {"sha": "c7c77d351a75f5b2bea9e92e745e14e299f87c5d", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1,4 +1,5 @@\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def::CtorKind;\n use rustc::mir::*;\n use rustc::mir::visit::Visitor;\n use rustc::ty::{self, TyCtxt};\n@@ -596,7 +597,8 @@ fn write_mir_sig(\n     trace!(\"write_mir_sig: {:?}\", src.instance);\n     let descr = tcx.describe_def(src.def_id());\n     let is_function = match descr {\n-        Some(Def::Fn(_)) | Some(Def::Method(_)) | Some(Def::StructCtor(..)) => true,\n+        Some(Def::Fn(_)) | Some(Def::Method(_)) | Some(Def::Variant(..)) |\n+        Some(Def::StructCtor(_, CtorKind::Fn)) => true,\n         _ => tcx.is_closure(src.def_id()),\n     };\n     match (descr, src.promoted) {"}, {"sha": "f47291458492e0cea6b658814809dc3fee290d3a", "filename": "src/librustc_target/spec/mipsisa32r6_unknown_linux_gnu.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,23 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"mipsisa32r6-unknown-linux-gnu\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n+        arch: \"mips\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            cpu: \"mips32r6\".to_string(),\n+            features: \"+mips32r6\".to_string(),\n+            max_atomic_width: Some(32),\n+\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "f4f98d33571f05724274d575a7d4586dff9154fb", "filename": "src/librustc_target/spec/mipsisa32r6el_unknown_linux_gnu.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,24 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"mipsisa32r6el-unknown-linux-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n+        arch: \"mips\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+\n+        options: TargetOptions {\n+            cpu: \"mips32r6\".to_string(),\n+            features: \"+mips32r6\".to_string(),\n+            max_atomic_width: Some(32),\n+\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "7faed3adc79cc1cca9c551db76f2732dad0f509e", "filename": "src/librustc_target/spec/mipsisa64r6_unknown_linux_gnuabi64.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,24 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"mipsisa64r6-unknown-linux-gnuabi64\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"mips64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            // NOTE(mips64r6) matches C toolchain\n+            cpu: \"mips64r6\".to_string(),\n+            features: \"+mips64r6\".to_string(),\n+            max_atomic_width: Some(64),\n+\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "58a814a759eb874d6fb33f02b1d9f3883ef8e00a", "filename": "src/librustc_target/spec/mipsisa64r6el_unknown_linux_gnuabi64.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,24 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"mipsisa64r6el-unknown-linux-gnuabi64\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"mips64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            // NOTE(mips64r6) matches C toolchain\n+            cpu: \"mips64r6\".to_string(),\n+            features: \"+mips64r6\".to_string(),\n+            max_atomic_width: Some(64),\n+\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "fdb1db645c3c43dc2623262edce9cb97f3abcdcd", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -335,6 +335,10 @@ supported_targets! {\n     (\"mips-unknown-linux-gnu\", mips_unknown_linux_gnu),\n     (\"mips64-unknown-linux-gnuabi64\", mips64_unknown_linux_gnuabi64),\n     (\"mips64el-unknown-linux-gnuabi64\", mips64el_unknown_linux_gnuabi64),\n+    (\"mipsisa32r6-unknown-linux-gnu\", mipsisa32r6_unknown_linux_gnu),\n+    (\"mipsisa32r6el-unknown-linux-gnu\", mipsisa32r6el_unknown_linux_gnu),\n+    (\"mipsisa64r6-unknown-linux-gnuabi64\", mipsisa64r6_unknown_linux_gnuabi64),\n+    (\"mipsisa64r6el-unknown-linux-gnuabi64\", mipsisa64r6el_unknown_linux_gnuabi64),\n     (\"mipsel-unknown-linux-gnu\", mipsel_unknown_linux_gnu),\n     (\"powerpc-unknown-linux-gnu\", powerpc_unknown_linux_gnu),\n     (\"powerpc-unknown-linux-gnuspe\", powerpc_unknown_linux_gnuspe),"}, {"sha": "956767a22a0e1cc5e43eab3c4a59767c880f0b14", "filename": "src/librustc_target/spec/uefi_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -59,7 +59,7 @@ pub fn opts() -> TargetOptions {\n         singlethread: true,\n         emit_debug_gdb_scripts: false,\n \n-        linker: Some(\"lld-link\".to_string()),\n+        linker: Some(\"rust-lld\".to_string()),\n         lld_flavor: LldFlavor::Link,\n         pre_link_args,\n "}, {"sha": "fa4bb02189f20260877fd0d42349c7ca114e0b1b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -5288,6 +5288,53 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n     }\n \n+    // Rewrite `SelfCtor` to `StructCtor`\n+    pub fn rewrite_self_ctor(&self, def: Def, span: Span) -> (Def, DefId, Ty<'tcx>) {\n+        let tcx = self.tcx;\n+        if let Def::SelfCtor(impl_def_id) = def {\n+            let ty = self.impl_self_ty(span, impl_def_id).ty;\n+            let adt_def = ty.ty_adt_def();\n+\n+            match adt_def {\n+                Some(adt_def) if adt_def.has_ctor() => {\n+                    let variant = adt_def.non_enum_variant();\n+                    let def = Def::StructCtor(variant.did, variant.ctor_kind);\n+                    (def, variant.did, tcx.type_of(variant.did))\n+                }\n+                _ => {\n+                    let mut err = tcx.sess.struct_span_err(span,\n+                        \"the `Self` constructor can only be used with tuple or unit structs\");\n+                    if let Some(adt_def) = adt_def {\n+                        match adt_def.adt_kind() {\n+                            AdtKind::Enum => {\n+                                err.help(\"did you mean to use one of the enum's variants?\");\n+                            },\n+                            AdtKind::Struct |\n+                            AdtKind::Union => {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"use curly brackets\",\n+                                    String::from(\"Self { /* fields */ }\"),\n+                                    Applicability::HasPlaceholders,\n+                                );\n+                            }\n+                        }\n+                    }\n+                    err.emit();\n+\n+                    (def, impl_def_id, tcx.types.err)\n+                }\n+            }\n+        } else {\n+            let def_id = def.def_id();\n+\n+            // The things we are substituting into the type should not contain\n+            // escaping late-bound regions, and nor should the base type scheme.\n+            let ty = tcx.type_of(def_id);\n+            (def, def_id, ty)\n+        }\n+    }\n+\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n@@ -5307,6 +5354,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n \n+        match def {\n+            Def::Local(nid) | Def::Upvar(nid, ..) => {\n+                let hid = self.tcx.hir().node_to_hir_id(nid);\n+                let ty = self.local_ty(span, hid).decl_ty;\n+                let ty = self.normalize_associated_types_in(span, &ty);\n+                self.write_ty(hir_id, ty);\n+                return (ty, def);\n+            }\n+            _ => {}\n+        }\n+\n+        let (def, def_id, ty) = self.rewrite_self_ctor(def, span);\n         let path_segs = AstConv::def_ids_for_path_segments(self, segments, self_ty, def);\n \n         let mut user_self_ty = None;\n@@ -5368,17 +5427,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             user_self_ty = None;\n         }\n \n-        match def {\n-            Def::Local(nid) | Def::Upvar(nid, ..) => {\n-                let hid = self.tcx.hir().node_to_hir_id(nid);\n-                let ty = self.local_ty(span, hid).decl_ty;\n-                let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(hir_id, ty);\n-                return (ty, def);\n-            }\n-            _ => {}\n-        }\n-\n         // Now we have to compare the types that the user *actually*\n         // provided against the types that were *expected*. If the user\n         // did not provide any types, then we want to substitute inference\n@@ -5411,53 +5459,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n-        let mut new_def = def;\n-        let (def_id, ty) = match def {\n-            Def::SelfCtor(impl_def_id) => {\n-                let ty = self.impl_self_ty(span, impl_def_id).ty;\n-                let adt_def = ty.ty_adt_def();\n-\n-                match adt_def {\n-                    Some(adt_def) if adt_def.has_ctor() => {\n-                        let variant = adt_def.non_enum_variant();\n-                        new_def = Def::StructCtor(variant.did, variant.ctor_kind);\n-                        (variant.did, tcx.type_of(variant.did))\n-                    }\n-                    _ => {\n-                        let mut err = tcx.sess.struct_span_err(span,\n-                            \"the `Self` constructor can only be used with tuple or unit structs\");\n-                        if let Some(adt_def) = adt_def {\n-                            match adt_def.adt_kind() {\n-                                AdtKind::Enum => {\n-                                    err.help(\"did you mean to use one of the enum's variants?\");\n-                                },\n-                                AdtKind::Struct |\n-                                AdtKind::Union => {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"use curly brackets\",\n-                                        String::from(\"Self { /* fields */ }\"),\n-                                        Applicability::HasPlaceholders,\n-                                    );\n-                                }\n-                            }\n-                        }\n-                        err.emit();\n-\n-                        (impl_def_id, tcx.types.err)\n-                    }\n-                }\n-            }\n-            _ => {\n-                let def_id = def.def_id();\n-\n-                // The things we are substituting into the type should not contain\n-                // escaping late-bound regions, and nor should the base type scheme.\n-                let ty = tcx.type_of(def_id);\n-                (def_id, ty)\n-            }\n-        };\n-\n         let substs = AstConv::create_substs_for_generic_args(\n             tcx,\n             def_id,\n@@ -5573,7 +5574,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                ty_substituted);\n         self.write_substs(hir_id, substs);\n \n-        (ty_substituted, new_def)\n+        (ty_substituted, def)\n     }\n \n     fn check_rustc_args_require_const(&self,"}, {"sha": "5109e775ebf8113b742187e9c40fba27fbf96ee6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1117,11 +1117,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n     // with rustdoc running in parallel.\n     all_indexes.sort();\n     let mut w = try_err!(File::create(&dst), &dst);\n-    if options.enable_minification {\n-        try_err!(writeln!(&mut w, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n-    } else {\n-        try_err!(writeln!(&mut w, \"var searchIndex={{}};\"), &dst);\n-    }\n+    try_err!(writeln!(&mut w, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n     try_err!(write_minify_replacer(&mut w,\n                                    &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n                                    options.enable_minification),"}, {"sha": "fef6910f40a574c5f62d6f259b25f1b6d25c88ee", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -2077,16 +2077,22 @@ if (!DOMTokenList.prototype.remove) {\n     }\n \n     var toggle = createSimpleToggle(false);\n+    var hideMethodDocs = getCurrentValue(\"rustdoc-method-docs\") !== \"false\";\n+    var pageId = getPageId();\n \n     var func = function(e) {\n         var next = e.nextElementSibling;\n         if (!next) {\n             return;\n         }\n-        if (hasClass(next, \"docblock\") ||\n-            (hasClass(next, \"stability\") &&\n-             hasClass(next.nextElementSibling, \"docblock\"))) {\n-            insertAfter(toggle.cloneNode(true), e.childNodes[e.childNodes.length - 1]);\n+        if (hasClass(next, \"docblock\") === true ||\n+            (hasClass(next, \"stability\") === true &&\n+             hasClass(next.nextElementSibling, \"docblock\") === true)) {\n+            var newToggle = toggle.cloneNode(true);\n+            insertAfter(newToggle, e.childNodes[e.childNodes.length - 1]);\n+            if (hideMethodDocs === true && hasClass(e, \"method\") === true) {\n+                collapseDocs(newToggle, \"hide\", pageId);\n+            }\n         }\n     };\n \n@@ -2107,17 +2113,16 @@ if (!DOMTokenList.prototype.remove) {\n     onEachLazy(document.getElementsByClassName(\"associatedconstant\"), func);\n     onEachLazy(document.getElementsByClassName(\"impl\"), funcImpl);\n     var impl_call = function() {};\n-    if (getCurrentValue(\"rustdoc-method-docs\") !== \"false\") {\n+    if (hideMethodDocs === true) {\n         impl_call = function(e, newToggle, pageId) {\n             if (e.id.match(/^impl(?:-\\d+)?$/) === null) {\n                 // Automatically minimize all non-inherent impls\n-                if (hasClass(e, \"impl\")) {\n+                if (hasClass(e, \"impl\") === true) {\n                     collapseDocs(newToggle, \"hide\", pageId);\n                 }\n             }\n         };\n     }\n-    var pageId = getPageId();\n     var newToggle = document.createElement(\"a\");\n     newToggle.href = \"javascript:void(0)\";\n     newToggle.className = \"collapse-toggle hidden-default collapsed\";\n@@ -2163,7 +2168,7 @@ if (!DOMTokenList.prototype.remove) {\n             var inner_toggle = newToggle.cloneNode(true);\n             inner_toggle.onclick = toggleClicked;\n             e.insertBefore(inner_toggle, e.firstChild);\n-            impl_call(e, inner_toggle, pageId);\n+            impl_call(e.previousSibling, inner_toggle, pageId);\n         }\n     });\n \n@@ -2265,30 +2270,6 @@ if (!DOMTokenList.prototype.remove) {\n     onEachLazy(document.getElementsByClassName(\"docblock\"), buildToggleWrapper);\n     onEachLazy(document.getElementsByClassName(\"sub-variant\"), buildToggleWrapper);\n \n-    // In the search display, allows to switch between tabs.\n-    function printTab(nb) {\n-        if (nb === 0 || nb === 1 || nb === 2) {\n-            currentTab = nb;\n-        }\n-        var nb_copy = nb;\n-        onEachLazy(document.getElementById(\"titles\").childNodes, function(elem) {\n-            if (nb_copy === 0) {\n-                addClass(elem, \"selected\");\n-            } else {\n-                removeClass(elem, \"selected\");\n-            }\n-            nb_copy -= 1;\n-        });\n-        onEachLazy(document.getElementById(\"results\").childNodes, function(elem) {\n-            if (nb === 0) {\n-                elem.style.display = \"\";\n-            } else {\n-                elem.style.display = \"none\";\n-            }\n-            nb -= 1;\n-        });\n-    }\n-\n     function createToggleWrapper(tog) {\n         var span = document.createElement(\"span\");\n         span.className = \"toggle-label\";\n@@ -2374,6 +2355,30 @@ if (!DOMTokenList.prototype.remove) {\n         };\n     });\n \n+    // In the search display, allows to switch between tabs.\n+    function printTab(nb) {\n+        if (nb === 0 || nb === 1 || nb === 2) {\n+            currentTab = nb;\n+        }\n+        var nb_copy = nb;\n+        onEachLazy(document.getElementById(\"titles\").childNodes, function(elem) {\n+            if (nb_copy === 0) {\n+                addClass(elem, \"selected\");\n+            } else {\n+                removeClass(elem, \"selected\");\n+            }\n+            nb_copy -= 1;\n+        });\n+        onEachLazy(document.getElementById(\"results\").childNodes, function(elem) {\n+            if (nb === 0) {\n+                elem.style.display = \"\";\n+            } else {\n+                elem.style.display = \"none\";\n+            }\n+            nb -= 1;\n+        });\n+    }\n+\n     function putBackSearch(search_input) {\n         if (search_input.value !== \"\") {\n             addClass(main, \"hidden\");"}, {"sha": "0f8e8894c04abd42432c85d8c8b318346b3ccdd7", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -288,6 +288,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             if ori_link.contains('/') {\n                 continue;\n             }\n+\n+            // [] is mostly likely not supposed to be a link\n+            if ori_link.is_empty() {\n+                continue;\n+            }\n+\n             let link = ori_link.replace(\"`\", \"\");\n             let (def, fragment) = {\n                 let mut kind = PathKind::Unknown;"}, {"sha": "1d45df499d86b914adf3ecae00967af2f0968d47", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -19,7 +19,7 @@ use super::table::{self, Bucket, EmptyBucket, Fallibility, FullBucket, FullBucke\n use super::table::BucketState::{Empty, Full};\n use super::table::Fallibility::{Fallible, Infallible};\n \n-const MIN_NONZERO_RAW_CAPACITY: usize = 32;     // must be a power of two\n+const MIN_NONZERO_RAW_CAPACITY: usize = 32; // must be a power of two\n \n /// The default behavior of HashMap implements a maximum load factor of 90.9%.\n #[derive(Clone)]"}, {"sha": "c026de35da63d79bfa33b9433da973041a7a5771", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -8,7 +8,7 @@ use super::Recover;\n use super::map::{self, HashMap, Keys, RandomState};\n \n // Future Optimization (FIXME!)\n-// =============================\n+// ============================\n //\n // Iteration over zero sized values is a noop. There is no need\n // for `bucket.val` in the case of HashSet. I suppose we would need HKT"}, {"sha": "8c3d0da0a7e405836a723ff096c7b5aa2b9560c3", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -211,7 +211,7 @@ pub struct DirBuilder {\n     recursive: bool,\n }\n \n-/// How large a buffer to pre-allocate before reading the entire file.\n+/// Indicates how large a buffer to pre-allocate before reading the entire file.\n fn initial_buffer_size(file: &File) -> usize {\n     // Allocate one extra byte so the buffer doesn't need to grow before the\n     // final `read` call at the end of the file.  Don't worry about `usize`\n@@ -1581,7 +1581,8 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// `O_CLOEXEC` is set for returned file descriptors.\n /// On Windows, this function currently corresponds to `CopyFileEx`. Alternate\n /// NTFS streams are copied but only the size of the main stream is returned by\n-/// this function.\n+/// this function. On MacOS, this function corresponds to `copyfile` with\n+/// `COPYFILE_ALL`.\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: ../io/index.html#platform-specific-behavior\n@@ -2836,6 +2837,26 @@ mod tests {\n         assert_eq!(check!(out_path.metadata()).len(), copied_len);\n     }\n \n+    #[test]\n+    fn copy_file_follows_dst_symlink() {\n+        let tmp = tmpdir();\n+        if !got_symlink_permission(&tmp) { return };\n+\n+        let in_path = tmp.join(\"in.txt\");\n+        let out_path = tmp.join(\"out.txt\");\n+        let out_path_symlink = tmp.join(\"out_symlink.txt\");\n+\n+        check!(fs::write(&in_path, \"foo\"));\n+        check!(fs::write(&out_path, \"bar\"));\n+        check!(symlink_file(&out_path, &out_path_symlink));\n+\n+        check!(fs::copy(&in_path, &out_path_symlink));\n+\n+        assert!(check!(out_path_symlink.symlink_metadata()).file_type().is_symlink());\n+        assert_eq!(check!(fs::read(&out_path_symlink)), b\"foo\".to_vec());\n+        assert_eq!(check!(fs::read(&out_path)), b\"foo\".to_vec());\n+    }\n+\n     #[test]\n     fn symlinks_work() {\n         let tmpdir = tmpdir();"}, {"sha": "1a2152a79af5a235fc660e5362dc7a79a4fe7fba", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -390,6 +390,28 @@ fn read_to_end_with_reservation<R: Read + ?Sized>(r: &mut R,\n     ret\n }\n \n+pub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoVecMut<'_>]) -> Result<usize>\n+where\n+    F: FnOnce(&mut [u8]) -> Result<usize>\n+{\n+    let buf = bufs\n+        .iter_mut()\n+        .find(|b| !b.is_empty())\n+        .map_or(&mut [][..], |b| &mut **b);\n+    read(buf)\n+}\n+\n+pub(crate) fn default_write_vectored<F>(write: F, bufs: &[IoVec<'_>]) -> Result<usize>\n+where\n+    F: FnOnce(&[u8]) -> Result<usize>\n+{\n+    let buf = bufs\n+        .iter()\n+        .find(|b| !b.is_empty())\n+        .map_or(&[][..], |b| &**b);\n+    write(buf)\n+}\n+\n /// The `Read` trait allows for reading bytes from a source.\n ///\n /// Implementors of the `Read` trait are called 'readers'.\n@@ -528,14 +550,11 @@ pub trait Read {\n     /// written to possibly being only partially filled. This method must behave\n     /// as a single call to `read` with the buffers concatenated would.\n     ///\n-    /// The default implementation simply passes the first nonempty buffer to\n-    /// `read`.\n+    /// The default implementation calls `read` with either the first nonempty\n+    /// buffer provided, or an empty one if none exists.\n     #[unstable(feature = \"iovec\", issue = \"58452\")]\n     fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> Result<usize> {\n-        match bufs.iter_mut().find(|b| !b.is_empty()) {\n-            Some(buf) => self.read(buf),\n-            None => Ok(0),\n-        }\n+        default_read_vectored(|b| self.read(b), bufs)\n     }\n \n     /// Determines if this `Read`er can work with buffers of uninitialized\n@@ -1107,14 +1126,11 @@ pub trait Write {\n     /// read from possibly being only partially consumed. This method must\n     /// behave as a call to `write` with the buffers concatenated would.\n     ///\n-    /// The default implementation simply passes the first nonempty buffer to\n-    /// `write`.\n+    /// The default implementation calls `write` with either the first nonempty\n+    /// buffer provided, or an empty one if none exists.\n     #[unstable(feature = \"iovec\", issue = \"58452\")]\n     fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> Result<usize> {\n-        match bufs.iter().find(|b| !b.is_empty()) {\n-            Some(buf) => self.write(buf),\n-            None => Ok(0),\n-        }\n+        default_write_vectored(|b| self.write(b), bufs)\n     }\n \n     /// Flush this output stream, ensuring that all intermediately buffered"}, {"sha": "fc8ac9a0b3e00b57978501097236dbd9dda88f28", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -221,7 +221,7 @@\n \n #![cfg_attr(test, feature(print_internals, set_stdio, test, update_panic_count))]\n #![cfg_attr(all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n-            feature(global_asm, range_contains, slice_index_methods,\n+            feature(global_asm, slice_index_methods,\n                     decl_macro, coerce_unsized, sgx_platform, ptr_wrapping_offset_from))]\n \n // std is implemented with unstable features, many of which are internal"}, {"sha": "4e30b1edd15e82dc7171328699fd3e23f2de679a", "filename": "src/libstd/os/fortanix_sgx/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -43,3 +43,8 @@ pub mod mem {\n }\n \n pub use crate::sys::ext::{io, arch, ffi};\n+\n+/// Functions for querying thread-related information.\n+pub mod thread {\n+    pub use crate::sys::abi::thread::current;\n+}"}, {"sha": "ad86acbb47de420c6ed67365fd2cf118c81a18f1", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -8,7 +8,7 @@\n //!\n //! The [`Command`] struct is used to configure and spawn processes:\n //!\n-//! ```\n+//! ```no_run\n //! use std::process::Command;\n //!\n //! let output = Command::new(\"echo\")"}, {"sha": "c383f21dcd752ae327a13ad9289977d2387467a2", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -190,7 +190,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// while !*started {\n     ///     started = cvar.wait(started).unwrap();\n     /// }\n@@ -254,7 +254,7 @@ impl Condvar {\n     ///\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// let _guard = cvar.wait_until(lock.lock().unwrap(), |started| { *started }).unwrap();\n     /// ```\n     #[unstable(feature = \"wait_until\", issue = \"47960\")]\n@@ -311,7 +311,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// loop {\n     ///     let result = cvar.wait_timeout_ms(started, 10).unwrap();\n     ///     // 10 milliseconds have passed, or maybe the value changed!\n@@ -384,7 +384,7 @@ impl Condvar {\n     /// // wait for the thread to start up\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // as long as the value inside the `Mutex` is false, we wait\n+    /// // as long as the value inside the `Mutex<bool>` is `false`, we wait\n     /// loop {\n     ///     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n     ///     // 10 milliseconds have passed, or maybe the value changed!\n@@ -518,7 +518,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// while !*started {\n     ///     started = cvar.wait(started).unwrap();\n     /// }\n@@ -558,7 +558,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// while !*started {\n     ///     started = cvar.wait(started).unwrap();\n     /// }"}, {"sha": "3f2f6166a791a4433c316c1e9d90d9d25f44b7dd", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -35,21 +35,15 @@ impl TcpStream {\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n-        match bufs.iter_mut().find(|b| !b.is_empty()) {\n-            Some(buf) => self.read(buf),\n-            None => Ok(0),\n-        }\n+        io::default_read_vectored(|b| self.read(b), bufs)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> Result<usize> {\n         self.0.write(buf)\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n-        match bufs.iter().find(|b| !b.is_empty()) {\n-            Some(buf) => self.write(buf),\n-            None => Ok(0),\n-        }\n+        io::default_write_vectored(|b| self.write(b), bufs)\n     }\n \n     pub fn take_error(&self) -> Result<Option<Error>> {"}, {"sha": "c17fa2d00159ee305a1db0df35a248e714b4b350", "filename": "src/libstd/sys/sgx/abi/thread.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -4,6 +4,7 @@ use fortanix_sgx_abi::Tcs;\n /// all currently running threads in the enclave, and it is guaranteed to be\n /// constant for the lifetime of the thread. More specifically for SGX, there\n /// is a one-to-one correspondence of the ID to the address of the TCS.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn current() -> Tcs {\n     extern \"C\" { fn get_tcs_addr() -> Tcs; }\n     unsafe { get_tcs_addr() }"}, {"sha": "e167e917957f3f652b9dce3735f802c868bcb9fd", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -103,24 +103,16 @@ impl TcpStream {\n         self.inner.inner.read(buf)\n     }\n \n-    pub fn read_vectored(&self, buf: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n-        let buf = match buf.get_mut(0) {\n-            Some(buf) => buf,\n-            None => return Ok(0),\n-        };\n-        self.read(buf)\n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        io::default_read_vectored(|b| self.read(b), bufs)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.inner.write(buf)\n     }\n \n-    pub fn write_vectored(&self, buf: &[IoVec<'_>]) -> io::Result<usize> {\n-        let buf = match buf.get(0) {\n-            Some(buf) => buf,\n-            None => return Ok(0),\n-        };\n-        self.write(buf)\n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        io::default_write_vectored(|b| self.write(b), bufs)\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {"}, {"sha": "7ff098bc9e1237fd288beb1c2ecfa4a7cb8d9ea3", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -827,7 +827,10 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n-#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+#[cfg(not(any(target_os = \"linux\",\n+              target_os = \"android\",\n+              target_os = \"macos\",\n+              target_os = \"ios\")))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::fs::File;\n     if !from.is_file() {\n@@ -937,3 +940,85 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     writer.set_permissions(perm)?;\n     Ok(written)\n }\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    const COPYFILE_ACL: u32 = 1 << 0;\n+    const COPYFILE_STAT: u32 = 1 << 1;\n+    const COPYFILE_XATTR: u32 = 1 << 2;\n+    const COPYFILE_DATA: u32 = 1 << 3;\n+\n+    const COPYFILE_SECURITY: u32 = COPYFILE_STAT | COPYFILE_ACL;\n+    const COPYFILE_METADATA: u32 = COPYFILE_SECURITY | COPYFILE_XATTR;\n+    const COPYFILE_ALL: u32 = COPYFILE_METADATA | COPYFILE_DATA;\n+\n+    const COPYFILE_STATE_COPIED: u32 = 8;\n+\n+    #[allow(non_camel_case_types)]\n+    type copyfile_state_t = *mut libc::c_void;\n+    #[allow(non_camel_case_types)]\n+    type copyfile_flags_t = u32;\n+\n+    extern \"C\" {\n+        fn copyfile(\n+            from: *const libc::c_char,\n+            to: *const libc::c_char,\n+            state: copyfile_state_t,\n+            flags: copyfile_flags_t,\n+        ) -> libc::c_int;\n+        fn copyfile_state_alloc() -> copyfile_state_t;\n+        fn copyfile_state_free(state: copyfile_state_t) -> libc::c_int;\n+        fn copyfile_state_get(\n+            state: copyfile_state_t,\n+            flag: u32,\n+            dst: *mut libc::c_void,\n+        ) -> libc::c_int;\n+    }\n+\n+    struct FreeOnDrop(copyfile_state_t);\n+    impl Drop for FreeOnDrop {\n+        fn drop(&mut self) {\n+            // The code below ensures that `FreeOnDrop` is never a null pointer\n+            unsafe {\n+                // `copyfile_state_free` returns -1 if the `to` or `from` files\n+                // cannot be closed. However, this is not considerd this an\n+                // error.\n+                copyfile_state_free(self.0);\n+            }\n+        }\n+    }\n+\n+    if !from.is_file() {\n+        return Err(Error::new(ErrorKind::InvalidInput,\n+                              \"the source path is not an existing regular file\"))\n+    }\n+\n+    // We ensure that `FreeOnDrop` never contains a null pointer so it is\n+    // always safe to call `copyfile_state_free`\n+    let state = unsafe {\n+        let state = copyfile_state_alloc();\n+        if state.is_null() {\n+            return Err(crate::io::Error::last_os_error());\n+        }\n+        FreeOnDrop(state)\n+    };\n+\n+    cvt(unsafe {\n+        copyfile(\n+            cstr(from)?.as_ptr(),\n+            cstr(to)?.as_ptr(),\n+            state.0,\n+            COPYFILE_ALL,\n+        )\n+    })?;\n+\n+    let mut bytes_copied: libc::off_t = 0;\n+    cvt(unsafe {\n+        copyfile_state_get(\n+            state.0,\n+            COPYFILE_STATE_COPIED,\n+            &mut bytes_copied as *mut libc::off_t as *mut libc::c_void,\n+        )\n+    })?;\n+    Ok(bytes_copied as u64)\n+}"}, {"sha": "c1af6ec12623c51bf7d9509b398f41e7452157d7", "filename": "src/libstd/sys/wasm/alloc.rs", "status": "modified", "additions": 80, "deletions": 15, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -49,7 +49,6 @@ unsafe impl GlobalAlloc for System {\n \n #[cfg(target_feature = \"atomics\")]\n mod lock {\n-    use crate::arch::wasm32;\n     use crate::sync::atomic::{AtomicI32, Ordering::SeqCst};\n \n     static LOCKED: AtomicI32 = AtomicI32::new(0);\n@@ -61,27 +60,93 @@ mod lock {\n             if LOCKED.swap(1, SeqCst) == 0 {\n                 return DropLock\n             }\n-            unsafe {\n-                let r = wasm32::i32_atomic_wait(\n-                    &LOCKED as *const AtomicI32 as *mut i32,\n-                    1,  // expected value\n-                    -1, // timeout\n-                );\n-                debug_assert!(r == 0 || r == 1);\n-            }\n+            // Ok so here's where things get a little depressing. At this point\n+            // in time we need to synchronously acquire a lock, but we're\n+            // contending with some other thread. Typically we'd execute some\n+            // form of `i32.atomic.wait` like so:\n+            //\n+            //     unsafe {\n+            //         let r = core::arch::wasm32::i32_atomic_wait(\n+            //             &LOCKED as *const AtomicI32 as *mut i32,\n+            //             1,  //     expected value\n+            //             -1, //     timeout\n+            //         );\n+            //         debug_assert!(r == 0 || r == 1);\n+            //     }\n+            //\n+            // Unfortunately though in doing so we would cause issues for the\n+            // main thread. The main thread in a web browser *cannot ever\n+            // block*, no exceptions. This means that the main thread can't\n+            // actually execute the `i32.atomic.wait` instruction.\n+            //\n+            // As a result if we want to work within the context of browsers we\n+            // need to figure out some sort of allocation scheme for the main\n+            // thread where when there's contention on the global malloc lock we\n+            // do... something.\n+            //\n+            // Possible ideas include:\n+            //\n+            // 1. Attempt to acquire the global lock. If it fails, fall back to\n+            //    memory allocation via `memory.grow`. Later just ... somehow\n+            //    ... inject this raw page back into the main allocator as it\n+            //    gets sliced up over time. This strategy has the downside of\n+            //    forcing allocation of a page to happen whenever the main\n+            //    thread contents with other threads, which is unfortunate.\n+            //\n+            // 2. Maintain a form of \"two level\" allocator scheme where the main\n+            //    thread has its own allocator. Somehow this allocator would\n+            //    also be balanced with a global allocator, not only to have\n+            //    allocations cross between threads but also to ensure that the\n+            //    two allocators stay \"balanced\" in terms of free'd memory and\n+            //    such. This, however, seems significantly complicated.\n+            //\n+            // Out of a lack of other ideas, the current strategy implemented\n+            // here is to simply spin. Typical spin loop algorithms have some\n+            // form of \"hint\" here to the CPU that it's what we're doing to\n+            // ensure that the CPU doesn't get too hot, but wasm doesn't have\n+            // such an instruction.\n+            //\n+            // To be clear, spinning here is not a great solution.\n+            // Another thread with the lock may take quite a long time to wake\n+            // up. For example it could be in `memory.grow` or it could be\n+            // evicted from the CPU for a timeslice like 10ms. For these periods\n+            // of time our thread will \"helpfully\" sit here and eat CPU time\n+            // until it itself is evicted or the lock holder finishes. This\n+            // means we're just burning and wasting CPU time to no one's\n+            // benefit.\n+            //\n+            // Spinning does have the nice properties, though, of being\n+            // semantically correct, being fair to all threads for memory\n+            // allocation, and being simple enough to implement.\n+            //\n+            // This will surely (hopefully) be replaced in the future with a\n+            // real memory allocator that can handle the restriction of the main\n+            // thread.\n+            //\n+            //\n+            // FIXME: We can also possibly add an optimization here to detect\n+            // when a thread is the main thread or not and block on all\n+            // non-main-thread threads. Currently, however, we have no way\n+            // of knowing which wasm thread is on the browser main thread, but\n+            // if we could figure out we could at least somewhat mitigate the\n+            // cost of this spinning.\n         }\n     }\n \n     impl Drop for DropLock {\n         fn drop(&mut self) {\n             let r = LOCKED.swap(0, SeqCst);\n             debug_assert_eq!(r, 1);\n-            unsafe {\n-                wasm32::atomic_notify(\n-                    &LOCKED as *const AtomicI32 as *mut i32,\n-                    1, // only one thread\n-                );\n-            }\n+\n+            // Note that due to the above logic we don't actually need to wake\n+            // anyone up, but if we did it'd likely look something like this:\n+            //\n+            //     unsafe {\n+            //         core::arch::wasm32::atomic_notify(\n+            //             &LOCKED as *const AtomicI32 as *mut i32,\n+            //             1, //     only one thread\n+            //         );\n+            //     }\n         }\n     }\n }"}, {"sha": "b38727830f37f11c64a4acb9e858438612c95a50", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -37,9 +37,9 @@ pub struct Pipes {\n ///\n /// The ours/theirs pipes are *not* specifically readable or writable. Each\n /// one only supports a read or a write, but which is which depends on the\n-/// boolean flag given. If `ours_readable` is true then `ours` is readable where\n-/// `theirs` is writable. Conversely if `ours_readable` is false then `ours` is\n-/// writable where `theirs` is readable.\n+/// boolean flag given. If `ours_readable` is `true`, then `ours` is readable and\n+/// `theirs` is writable. Conversely, if `ours_readable` is `false`, then `ours`\n+/// is writable and `theirs` is readable.\n ///\n /// Also note that the `ours` pipe is always a handle opened up in overlapped\n /// mode. This means that technically speaking it should only ever be used"}, {"sha": "4c86f70ad871d6df5617bc4828ab5f7513081a56", "filename": "src/libstd/time.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -712,13 +712,6 @@ mod tests {\n         assert_almost_eq!(a - second + second, a);\n         assert_almost_eq!(a.checked_sub(second).unwrap().checked_add(second).unwrap(), a);\n \n-        // A difference of 80 and 800 years cannot fit inside a 32-bit time_t\n-        if !(cfg!(unix) && crate::mem::size_of::<libc::time_t>() <= 4) {\n-            let eighty_years = second * 60 * 60 * 24 * 365 * 80;\n-            assert_almost_eq!(a - eighty_years + eighty_years, a);\n-            assert_almost_eq!(a - (eighty_years * 10) + (eighty_years * 10), a);\n-        }\n-\n         let one_second_from_epoch = UNIX_EPOCH + Duration::new(1, 0);\n         let one_second_from_epoch2 = UNIX_EPOCH + Duration::new(0, 500_000_000)\n             + Duration::new(0, 500_000_000);\n@@ -747,8 +740,8 @@ mod tests {\n     #[test]\n     fn since_epoch() {\n         let ts = SystemTime::now();\n-        let a = ts.duration_since(UNIX_EPOCH).unwrap();\n-        let b = ts.duration_since(UNIX_EPOCH - Duration::new(1, 0)).unwrap();\n+        let a = ts.duration_since(UNIX_EPOCH + Duration::new(1, 0)).unwrap();\n+        let b = ts.duration_since(UNIX_EPOCH).unwrap();\n         assert!(b > a);\n         assert_eq!(b - a, Duration::new(1, 0));\n "}, {"sha": "2abb7e407eb026d1d22f94f51ef8ca91d131c253", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -24,8 +24,8 @@ pub struct StripUnconfigured<'a> {\n }\n \n // `cfg_attr`-process the crate's attributes and compute the crate's features.\n-pub fn features(mut krate: ast::Crate, sess: &ParseSess, edition: Edition)\n-                -> (ast::Crate, Features) {\n+pub fn features(mut krate: ast::Crate, sess: &ParseSess, edition: Edition,\n+                allow_features: &Option<Vec<String>>) -> (ast::Crate, Features) {\n     let features;\n     {\n         let mut strip_unconfigured = StripUnconfigured {\n@@ -43,7 +43,7 @@ pub fn features(mut krate: ast::Crate, sess: &ParseSess, edition: Edition)\n             return (krate, Features::new());\n         }\n \n-        features = get_features(&sess.span_diagnostic, &krate.attrs, edition);\n+        features = get_features(&sess.span_diagnostic, &krate.attrs, edition, allow_features);\n \n         // Avoid reconfiguring malformed `cfg_attr`s\n         if err_count == sess.span_diagnostic.err_count() {"}, {"sha": "ac24475cab89fa1d6c614c3e2c3d9bd9f6a1e6d0", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -378,6 +378,21 @@ Erroneous code example:\n \n \"##,\n \n+E0725: r##\"\n+A feature attribute named a feature that was disallowed in the compiler\n+command line flags.\n+\n+Erroneous code example:\n+\n+```ignore (can't specify compiler flags from doctests)\n+#![feature(never_type)] // error: the feature `never_type` is not in\n+                        // the list of allowed features\n+```\n+\n+Delete the offending feature attribute, or add it to the list of allowed\n+features in the `-Z allow_features` flag.\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "280b17da0be3f313e538d9c9a6a22a1313af50c4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -2008,7 +2008,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n }\n \n pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n-                    crate_edition: Edition) -> Features {\n+                    crate_edition: Edition, allow_features: &Option<Vec<String>>) -> Features {\n     fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n         let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n         if let Some(reason) = reason {\n@@ -2127,6 +2127,15 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n             }\n \n             if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n+                if let Some(allowed) = allow_features.as_ref() {\n+                    if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n+                        span_err!(span_handler, mi.span, E0725,\n+                                  \"the feature `{}` is not in the list of allowed features\",\n+                                  name);\n+                        continue;\n+                    }\n+                }\n+\n                 set(&mut features, mi.span);\n                 features.declared_lang_features.push((name, mi.span, None));\n                 continue"}, {"sha": "22af7d47fd0a1fe6736bab98aac875feb383d416", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -5116,12 +5116,8 @@ impl<'a> Parser<'a> {\n \n                 let ident = self.parse_ident()?;\n                 let (delim, tokens) = self.expect_delimited_token_tree()?;\n-                if delim != MacDelimiter::Brace {\n-                    if !self.eat(&token::Semi) {\n-                        let msg = \"macros that expand to items must either \\\n-                                   be surrounded with braces or followed by a semicolon\";\n-                        self.span_err(self.prev_span, msg);\n-                    }\n+                if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+                    self.report_invalid_macro_expansion_item();\n                 }\n \n                 (ident, ast::MacroDef { tokens: tokens, legacy: true })\n@@ -5264,13 +5260,8 @@ impl<'a> Parser<'a> {\n                 // if it has a special ident, it's definitely an item\n                 //\n                 // Require a semicolon or braces.\n-                if style != MacStmtStyle::Braces {\n-                    if !self.eat(&token::Semi) {\n-                        self.span_err(self.prev_span,\n-                                      \"macros that expand to items must \\\n-                                       either be surrounded with braces or \\\n-                                       followed by a semicolon\");\n-                    }\n+                if style != MacStmtStyle::Braces && !self.eat(&token::Semi) {\n+                    self.report_invalid_macro_expansion_item();\n                 }\n                 let span = lo.to(hi);\n                 Stmt {\n@@ -8360,13 +8351,8 @@ impl<'a> Parser<'a> {\n             };\n             // eat a matched-delimiter token tree:\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace {\n-                if !self.eat(&token::Semi) {\n-                    self.span_err(self.prev_span,\n-                                  \"macros that expand to items must either \\\n-                                   be surrounded with braces or followed by \\\n-                                   a semicolon\");\n-                }\n+            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+                self.report_invalid_macro_expansion_item();\n             }\n \n             let hi = self.prev_span;\n@@ -8597,6 +8583,25 @@ impl<'a> Parser<'a> {\n             }\n         }\n     }\n+\n+    fn report_invalid_macro_expansion_item(&self) {\n+        self.struct_span_err(\n+            self.prev_span,\n+            \"macros that expand to items must be delimited with braces or followed by a semicolon\",\n+        ).multipart_suggestion(\n+            \"change the delimiters to curly braces\",\n+            vec![\n+                (self.prev_span.with_hi(self.prev_span.lo() + BytePos(1)), String::from(\" {\")),\n+                (self.prev_span.with_lo(self.prev_span.hi() - BytePos(1)), '}'.to_string()),\n+            ],\n+            Applicability::MaybeIncorrect,\n+        ).span_suggestion(\n+            self.sess.source_map.next_point(self.prev_span),\n+            \"add a semicolon\",\n+            ';'.to_string(),\n+            Applicability::MaybeIncorrect,\n+        ).emit();\n+    }\n }\n \n pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, handler: &errors::Handler) {"}, {"sha": "4fc9fb8245abe24680192535870c4522644a4212", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1 +1 @@\n-Subproject commit 38ad31bde8ff681d862dc0f96930a5dd9b7a472e\n+Subproject commit 4fc9fb8245abe24680192535870c4522644a4212"}, {"sha": "ced30381fda68cb0f81a16151a9f3005297456bb", "filename": "src/test/mir-opt/unusual-item-types.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -7,11 +7,18 @@ impl A {\n     const ASSOCIATED_CONSTANT: i32 = 2;\n }\n \n+// See #59021\n+enum Test {\n+    X(usize),\n+    Y { a: usize },\n+}\n+\n enum E {\n     V = 5,\n }\n \n fn main() {\n+    let f = Test::X as fn(usize) -> Test;\n     let v = Vec::<i32>::new();\n }\n \n@@ -64,3 +71,14 @@ fn main() {\n //     _3 = const std::ops::Drop::drop(move _2) -> [return: bb6, unwind: bb5];\n // }\n // END rustc.ptr-real_drop_in_place.std__vec__Vec_i32_.AddMovesForPackedDrops.before.mir\n+\n+// START rustc.Test-X.mir_map.0.mir\n+// fn Test::X(_1: usize) -> Test {\n+//     let mut _0: Test;\n+//\n+//     bb0: {\n+//         _0 = Test::X(move _1,);\n+//         return;\n+//     }\n+// }\n+// END rustc.Test-X.mir_map.0.mir"}, {"sha": "cd2c17220655af8db2f75cabf74458b14f3d7f8a", "filename": "src/test/run-pass/array-slice-vec/estr-slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Festr-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Festr-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Festr-slice.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n \n     let z : &str = \"thing\";\n     assert_eq!(v, x);\n-    assert!(x != z);\n+    assert_ne!(x, z);\n \n     let a = \"aaaa\";\n     let b = \"bbbb\";\n@@ -26,23 +26,23 @@ pub fn main() {\n \n     assert!(a < b);\n     assert!(a <= b);\n-    assert!(a != b);\n+    assert_ne!(a, b);\n     assert!(b >= a);\n     assert!(b > a);\n \n     println!(\"{}\", b);\n \n     assert!(a < c);\n     assert!(a <= c);\n-    assert!(a != c);\n+    assert_ne!(a, c);\n     assert!(c >= a);\n     assert!(c > a);\n \n     println!(\"{}\", c);\n \n     assert!(c < cc);\n     assert!(c <= cc);\n-    assert!(c != cc);\n+    assert_ne!(c, cc);\n     assert!(cc >= c);\n     assert!(cc > c);\n "}, {"sha": "86b0977bebe1d5a3f2821d5e6a9423ed3a5a99b4", "filename": "src/test/run-pass/issue-55809.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Frun-pass%2Fissue-55809.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Frun-pass%2Fissue-55809.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-55809.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,30 @@\n+// edition:2018\n+// run-pass\n+\n+#![feature(async_await, await_macro, futures_api)]\n+\n+trait Foo { }\n+\n+impl Foo for () { }\n+\n+impl<'a, T> Foo for &'a mut T where T: Foo { }\n+\n+async fn foo_async<T>(_v: T) -> u8 where T: Foo {\n+    0\n+}\n+\n+async fn bad<T>(v: T) -> u8 where T: Foo {\n+    await!(foo_async(v))\n+}\n+\n+async fn async_main() {\n+    let mut v = ();\n+\n+    let _ = await!(bad(&mut v));\n+    let _ = await!(foo_async(&mut v));\n+    let _ = await!(bad(v));\n+}\n+\n+fn main() {\n+    let _ = async_main();\n+}"}, {"sha": "232596334b0ed9cb4d80421f6d0b5ff3d52c560a", "filename": "src/test/run-pass/issues/issue-57924.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Frun-pass%2Fissues%2Fissue-57924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Frun-pass%2Fissues%2Fissue-57924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-57924.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,9 @@\n+pub struct Gcm<E>(E);\n+\n+impl<E> Gcm<E> {\n+    pub fn crash(e: E) -> Self {\n+        Self::<E>(e)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "556013788c33557c0b81445d0b3d5d235d1dd5a5", "filename": "src/test/run-pass/simd/simd-size-align.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Frun-pass%2Fsimd%2Fsimd-size-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Frun-pass%2Fsimd%2Fsimd-size-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd%2Fsimd-size-align.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -37,6 +37,22 @@ fn main() {\n     check::<f32x6>();\n     check::<f32x7>();\n     check::<f32x8>();\n+\n+    check::<usizex2>();\n+    check::<usizex3>();\n+    check::<usizex4>();\n+    check::<usizex5>();\n+    check::<usizex6>();\n+    check::<usizex7>();\n+    check::<usizex8>();\n+\n+    check::<isizex2>();\n+    check::<isizex3>();\n+    check::<isizex4>();\n+    check::<isizex5>();\n+    check::<isizex6>();\n+    check::<isizex7>();\n+    check::<isizex8>();\n }\n \n #[repr(simd)] struct u8x2(u8, u8);\n@@ -62,3 +78,19 @@ fn main() {\n #[repr(simd)] struct f32x6(f32, f32, f32, f32, f32, f32);\n #[repr(simd)] struct f32x7(f32, f32, f32, f32, f32, f32, f32);\n #[repr(simd)] struct f32x8(f32, f32, f32, f32, f32, f32, f32, f32);\n+\n+#[repr(simd)] struct usizex2(usize, usize);\n+#[repr(simd)] struct usizex3(usize, usize, usize);\n+#[repr(simd)] struct usizex4(usize, usize, usize, usize);\n+#[repr(simd)] struct usizex5(usize, usize, usize, usize, usize);\n+#[repr(simd)] struct usizex6(usize, usize, usize, usize, usize, usize);\n+#[repr(simd)] struct usizex7(usize, usize, usize, usize, usize, usize, usize);\n+#[repr(simd)] struct usizex8(usize, usize, usize, usize, usize, usize, usize, usize);\n+\n+#[repr(simd)] struct isizex2(isize, isize);\n+#[repr(simd)] struct isizex3(isize, isize, isize);\n+#[repr(simd)] struct isizex4(isize, isize, isize, isize);\n+#[repr(simd)] struct isizex5(isize, isize, isize, isize, isize);\n+#[repr(simd)] struct isizex6(isize, isize, isize, isize, isize, isize);\n+#[repr(simd)] struct isizex7(isize, isize, isize, isize, isize, isize, isize);\n+#[repr(simd)] struct isizex8(isize, isize, isize, isize, isize, isize, isize, isize);"}, {"sha": "074014908bad45f0b2181cc848b9345156ac2fbd", "filename": "src/test/ui/consts/union_constant.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fconsts%2Funion_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fconsts%2Funion_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funion_constant.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,11 @@\n+// compile-pass\n+\n+union Uninit {\n+    _never_use: *const u8,\n+    uninit: (),\n+}\n+\n+const UNINIT: Uninit = Uninit { uninit: () };\n+\n+fn main() {}\n+"}, {"sha": "83250052cb506f83b7e9612104b24fa511dfc993", "filename": "src/test/ui/feature-gate/allow-features-empty.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Z allow_features=\n+// Note: This test uses rustc internal flags because they will never stabilize.\n+\n+#![feature(rustc_diagnostic_macros)] //~ ERROR\n+\n+#![feature(rustc_const_unstable)] //~ ERROR\n+\n+#![feature(lang_items)] //~ ERROR\n+\n+fn main() {}"}, {"sha": "cce2c4078c242b5141ffe6bfc94f6a8b99625027", "filename": "src/test/ui/feature-gate/allow-features-empty.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features-empty.stderr?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,21 @@\n+error[E0725]: the feature `rustc_diagnostic_macros` is not in the list of allowed features\n+  --> $DIR/allow-features-empty.rs:4:12\n+   |\n+LL | #![feature(rustc_diagnostic_macros)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0725]: the feature `rustc_const_unstable` is not in the list of allowed features\n+  --> $DIR/allow-features-empty.rs:6:12\n+   |\n+LL | #![feature(rustc_const_unstable)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0725]: the feature `lang_items` is not in the list of allowed features\n+  --> $DIR/allow-features-empty.rs:8:12\n+   |\n+LL | #![feature(lang_items)]\n+   |            ^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0725`."}, {"sha": "1cebc8f34f26fff1be71850b2d1f5499d8e0c4e4", "filename": "src/test/ui/feature-gate/allow-features.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Z allow_features=rustc_diagnostic_macros,lang_items\n+// Note: This test uses rustc internal flags because they will never stabilize.\n+\n+#![feature(rustc_diagnostic_macros)]\n+\n+#![feature(rustc_const_unstable)] //~ ERROR\n+\n+#![feature(lang_items)]\n+\n+fn main() {}"}, {"sha": "b13560fb81c6a07586a12ecc5395da9ad5af9a92", "filename": "src/test/ui/feature-gate/allow-features.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fallow-features.stderr?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,9 @@\n+error[E0725]: the feature `rustc_const_unstable` is not in the list of allowed features\n+  --> $DIR/allow-features.rs:6:12\n+   |\n+LL | #![feature(rustc_const_unstable)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0725`."}, {"sha": "ceb44ecf7f58379dea230ebdf0588cfa2c724e63", "filename": "src/test/ui/issues/issue-10536.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -12,7 +12,7 @@ pub fn main() {\n     foo!();\n \n     assert!({one! two()});\n-    //~^ ERROR macros that expand to items must either be surrounded with braces or followed by a\n+    //~^ ERROR macros that expand to items\n     //~| ERROR cannot find macro `one!` in this scope\n     //~| ERROR mismatched types\n "}, {"sha": "584cdf43a8f4bafe862d2faab3869be92d290c04", "filename": "src/test/ui/issues/issue-10536.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1,8 +1,16 @@\n-error: macros that expand to items must either be surrounded with braces or followed by a semicolon\n+error: macros that expand to items must be delimited with braces or followed by a semicolon\n   --> $DIR/issue-10536.rs:14:22\n    |\n LL |     assert!({one! two()});\n    |                      ^^\n+help: change the delimiters to curly braces\n+   |\n+LL |     assert!({one! two {}});\n+   |                       ^^\n+help: add a semicolon\n+   |\n+LL |     assert!({one! two();});\n+   |                        ^\n \n error: expected `(` or `{`, found `}`\n   --> $DIR/issue-10536.rs:21:22"}, {"sha": "e98a4d0e491a3a1a9c9664db3889937de2c21cfd", "filename": "src/test/ui/issues/issue-59029-1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fissues%2Fissue-59029-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fissues%2Fissue-59029-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59029-1.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,8 @@\n+#![feature(trait_alias)]\n+\n+trait Svc<Req> { type Res; }\n+\n+trait MkSvc<Target, Req> = Svc<Target> where Self::Res: Svc<Req>;\n+//~^ ERROR associated type `Res` not found for `Self`\n+\n+fn main() {}"}, {"sha": "ed1d98c40d18af61735acc441af8c7a84b1a4ff1", "filename": "src/test/ui/issues/issue-59029-1.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fissues%2Fissue-59029-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fissues%2Fissue-59029-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59029-1.stderr?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,9 @@\n+error[E0220]: associated type `Res` not found for `Self`\n+  --> $DIR/issue-59029-1.rs:5:46\n+   |\n+LL | trait MkSvc<Target, Req> = Svc<Target> where Self::Res: Svc<Req>;\n+   |                                              ^^^^^^^^^ associated type `Res` not found\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "2bdb128d8c4c8af18121625ee55867223e3f2af5", "filename": "src/test/ui/issues/issue-59029-2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fissues%2Fissue-59029-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fissues%2Fissue-59029-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59029-2.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,8 @@\n+// run-pass\n+#![feature(trait_alias)]\n+\n+trait Svc<Req> { type Res; }\n+\n+trait MkSvc<Target, Req> = Svc<Target> where <Self as Svc<Target>>::Res: Svc<Req>;\n+\n+fn main() {}"}, {"sha": "3afc275d61a2bc864fc954d558f5ba7e6106cb54", "filename": "src/test/ui/parser/macros-no-semicolon-items.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon-items.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1,4 +1,15 @@\n macro_rules! foo()  //~ ERROR semicolon\n+                    //~| ERROR unexpected end of macro\n+\n+macro_rules! bar {\n+    ($($tokens:tt)*) => {}\n+}\n+\n+bar!( //~ ERROR semicolon\n+    blah\n+    blah\n+    blah\n+)\n \n fn main() {\n }"}, {"sha": "5276aa6f5e9e9992ac6861e29b224b7fd333e37f", "filename": "src/test/ui/parser/macros-no-semicolon-items.stderr", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacros-no-semicolon-items.stderr?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1,8 +1,45 @@\n-error: macros that expand to items must either be surrounded with braces or followed by a semicolon\n+error: macros that expand to items must be delimited with braces or followed by a semicolon\n   --> $DIR/macros-no-semicolon-items.rs:1:17\n    |\n LL | macro_rules! foo()\n    |                 ^^\n+help: change the delimiters to curly braces\n+   |\n+LL | macro_rules! foo {}\n+   |                  ^^\n+help: add a semicolon\n+   |\n+LL | macro_rules! foo();\n+   |                   ^\n+\n+error: macros that expand to items must be delimited with braces or followed by a semicolon\n+  --> $DIR/macros-no-semicolon-items.rs:8:5\n+   |\n+LL |   bar!(\n+   |  _____^\n+LL | |     blah\n+LL | |     blah\n+LL | |     blah\n+LL | | )\n+   | |_^\n+help: change the delimiters to curly braces\n+   |\n+LL | bar! {\n+LL |     blah\n+LL |     blah\n+LL |     blah\n+LL | }\n+   |\n+help: add a semicolon\n+   |\n+LL | );\n+   |  ^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macros-no-semicolon-items.rs:1:1\n+   |\n+LL | macro_rules! foo()\n+   | ^^^^^^^^^^^^^^^^^^ missing tokens in macro arguments\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n "}, {"sha": "9e4b7e7656055f1ca685ec7c026a671713d74df3", "filename": "src/test/ui/simd-type.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fsimd-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fsimd-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-type.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -7,7 +7,4 @@ struct empty; //~ ERROR SIMD vector cannot be empty\n #[repr(simd)]\n struct i64f64(i64, f64); //~ ERROR SIMD vector should be homogeneous\n \n-#[repr(simd)]\n-struct int4(isize, isize, isize, isize); //~ ERROR SIMD vector element type should be machine type\n-\n fn main() {}"}, {"sha": "48b9916e89d98b65cbabdbd2a14575769474c028", "filename": "src/test/ui/simd-type.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fsimd-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fsimd-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-type.stderr?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -10,13 +10,7 @@ error[E0076]: SIMD vector should be homogeneous\n LL | struct i64f64(i64, f64);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ SIMD elements must have the same type\n \n-error[E0077]: SIMD vector element type should be machine type\n-  --> $DIR/simd-type.rs:11:1\n-   |\n-LL | struct int4(isize, isize, isize, isize);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors occurred: E0075, E0076, E0077.\n+Some errors occurred: E0075, E0076.\n For more information about an error, try `rustc --explain E0075`."}, {"sha": "9bfce11be9ea3b23938a81e6694099775aec9023", "filename": "src/test/ui/suggestions/return-without-lifetime.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,10 @@\n+struct Thing<'a>(&'a ());\n+struct Foo<'a>(&usize);\n+//~^ ERROR missing lifetime specifier\n+\n+fn func1<'a>(_arg: &'a Thing) -> &() { unimplemented!() }\n+//~^ ERROR missing lifetime specifier\n+fn func2<'a>(_arg: &Thing<'a>) -> &() { unimplemented!() }\n+//~^ ERROR missing lifetime specifier\n+\n+fn main() {}"}, {"sha": "7f5ff95938e309524ce6130c406deba98afe85c3", "filename": "src/test/ui/suggestions/return-without-lifetime.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-without-lifetime.stderr?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -0,0 +1,25 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-without-lifetime.rs:2:16\n+   |\n+LL | struct Foo<'a>(&usize);\n+   |                ^ help: consider using the named lifetime: `&'a`\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-without-lifetime.rs:5:34\n+   |\n+LL | fn func1<'a>(_arg: &'a Thing) -> &() { unimplemented!() }\n+   |                                  ^ help: consider using the named lifetime: `&'a`\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `_arg`'s 2 lifetimes it is borrowed from\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-without-lifetime.rs:7:35\n+   |\n+LL | fn func2<'a>(_arg: &Thing<'a>) -> &() { unimplemented!() }\n+   |                                   ^ help: consider using the named lifetime: `&'a`\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `_arg`'s 2 lifetimes it is borrowed from\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "058f2df624b55d29f912f4c59cdc90a3af64d271", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -23,6 +23,10 @@ static HOSTS: &'static [&'static str] = &[\n     \"mips64-unknown-linux-gnuabi64\",\n     \"mips64el-unknown-linux-gnuabi64\",\n     \"mipsel-unknown-linux-gnu\",\n+    \"mipsisa32r6-unknown-linux-gnu\",\n+    \"mipsisa32r6el-unknown-linux-gnu\",\n+    \"mipsisa64r6-unknown-linux-gnuabi64\",\n+    \"mipsisa64r6el-unknown-linux-gnuabi64\",\n     \"powerpc-unknown-linux-gnu\",\n     \"powerpc64-unknown-linux-gnu\",\n     \"powerpc64le-unknown-linux-gnu\",\n@@ -32,6 +36,7 @@ static HOSTS: &'static [&'static str] = &[\n     \"x86_64-pc-windows-msvc\",\n     \"x86_64-unknown-freebsd\",\n     \"x86_64-unknown-linux-gnu\",\n+    \"x86_64-unknown-linux-musl\",\n     \"x86_64-unknown-netbsd\",\n ];\n \n@@ -77,6 +82,10 @@ static TARGETS: &'static [&'static str] = &[\n     \"mips-unknown-linux-musl\",\n     \"mips64-unknown-linux-gnuabi64\",\n     \"mips64el-unknown-linux-gnuabi64\",\n+    \"mipsisa32r6-unknown-linux-gnu\",\n+    \"mipsisa32r6el-unknown-linux-gnu\",\n+    \"mipsisa64r6-unknown-linux-gnuabi64\",\n+    \"mipsisa64r6el-unknown-linux-gnuabi64\",\n     \"mipsel-unknown-linux-gnu\",\n     \"mipsel-unknown-linux-musl\",\n     \"nvptx64-nvidia-cuda\","}, {"sha": "3533dcdc988a12d9d6f19f044122d050fcdfe84b", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -49,7 +49,15 @@ const ARCH_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"mips\", \"mips\"),\n     (\"mips64\", \"mips64\"),\n     (\"mips64el\", \"mips64\"),\n+    (\"mipsisa32r6\", \"mips\"),\n+    (\"mipsisa32r6el\", \"mips\"),\n+    (\"mipsisa64r6\", \"mips64\"),\n+    (\"mipsisa64r6el\", \"mips64\"),\n     (\"mipsel\", \"mips\"),\n+    (\"mipsisa32r6\", \"mips\"),\n+    (\"mipsisa32r6el\", \"mips\"),\n+    (\"mipsisa64r6\", \"mips64\"),\n+    (\"mipsisa64r6el\", \"mips64\"),\n     (\"msp430\", \"msp430\"),\n     (\"powerpc\", \"powerpc\"),\n     (\"powerpc64\", \"powerpc64\"),"}]}