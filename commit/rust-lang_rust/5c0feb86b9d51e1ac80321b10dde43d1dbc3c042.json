{"sha": "5c0feb86b9d51e1ac80321b10dde43d1dbc3c042", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMGZlYjg2YjlkNTFlMWFjODAzMjFiMTBkZGU0M2QxZGJjM2MwNDI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-12T22:09:56Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-20T13:36:24Z"}, "message": "add proofs and fix postorder traversal\n\nI don't think the \"quasi-postorder\" travesal could cause any issues, but\nthere's no reason for it to stay broken.", "tree": {"sha": "22e5350b02f2a978803f2c031be7f4845ca13308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22e5350b02f2a978803f2c031be7f4845ca13308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042", "html_url": "https://github.com/rust-lang/rust/commit/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bb3dc19bf8962b04d96456524fe021b3938ba97", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb3dc19bf8962b04d96456524fe021b3938ba97", "html_url": "https://github.com/rust-lang/rust/commit/0bb3dc19bf8962b04d96456524fe021b3938ba97"}], "stats": {"total": 74, "additions": 57, "deletions": 17}, "files": [{"sha": "29147a2a50adde571446414432d787b235a28d6c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=5c0feb86b9d51e1ac80321b10dde43d1dbc3c042", "patch": "@@ -27,11 +27,19 @@\n //! for more details.\n //!\n //! Note: it is an important invariant that the default visitor walks\n-//! the body of a function in \"execution order\" (more concretely,\n-//! reverse post-order with respect to the CFG implied by the AST),\n-//! meaning that if AST node A may execute before AST node B, then A\n-//! is visited first.  The borrow checker in particular relies on this\n-//! property.\n+//! the body of a function in \"execution order\" - more concretely, if\n+//! we consider the reverse post-order (RPO) of the CFG implied by the HIR,\n+//! then a pre-order traversal of the HIR is consistent with the CFG RPO\n+//! on the *initial CFG point* of each HIR node, while a post-order traversal\n+//! of the HIR is consistent with the CFG RPO on each *final CFG point* of\n+//! each CFG node.\n+//!\n+//! One thing that follows is that if HIR node A always starts/ends executing\n+//! before HIR node B, then A appears in traversal pre/postorder before B,\n+//! respectively. (This follows from RPO respecting CFG domination).\n+//!\n+//! This order consistency is required in a few places in rustc, for\n+//! example generator inference, and possibly also HIR borrowck.\n \n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};"}, {"sha": "d5b6e388bde79cc3a886460ed42c5e9ac56a2efd", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5c0feb86b9d51e1ac80321b10dde43d1dbc3c042", "patch": "@@ -249,8 +249,36 @@ pub struct ScopeTree {\n     closure_tree: FxHashMap<hir::ItemLocalId, hir::ItemLocalId>,\n \n     /// If there are any `yield` nested within a scope, this map\n-    /// stores the `Span` of the last one and the number of expressions\n-    /// which came before it in a generator body.\n+    /// stores the `Span` of the last one and its index in the\n+    /// postorder of the Visitor traversal on the HIR.\n+    ///\n+    /// HIR Visitor postorder indexes might seem like a peculiar\n+    /// thing to care about. but it turns out that HIR bindings\n+    /// and the temporary results of HIR expressions are never\n+    /// storage-live at the end of HIR nodes with postorder indexes\n+    /// lower than theirs, and therefore don't need to be suspended\n+    /// at yield-points at these indexes.\n+    ///\n+    /// Let's show that: let `D` be our binding/temporary and `U` be our\n+    /// other HIR node, with `HIR-postorder(U) < HIR-postorder(D)`.\n+    ///\n+    /// Then:\n+    ///     1. From the ordering guarantee of HIR visitors (see\n+    ///     `rustc::hir::intravisit`), `D` does not dominate `U`.\n+    ///     2. Therefore, `D` is *potentially* storage-dead at `U` (because\n+    ///     we might visit `U` without ever getting to `D`).\n+    ///     3. However, we guarantee that at each HIR point, each\n+    ///     binding/temporary is always either always storage-live\n+    ///     or always storage-dead. This is what is being guaranteed\n+    ///     by `terminating_scopes` including all blocks where the\n+    ///     count of executions is not guaranteed.\n+    ///     4. By `2.` and `3.`, `D` is *statically* dead at `U`,\n+    ///     QED.\n+    ///\n+    /// I don't think this property relies on `3.` in an essential way - it\n+    /// is probably still correct even if we have \"unrestricted\" terminating\n+    /// scopes. However, why use the complicated proof when a simple one\n+    /// works?\n     yield_in_scope: FxHashMap<Scope, (Span, usize)>,\n \n     /// The number of visit_expr calls done in the body.\n@@ -754,8 +782,6 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt:\n fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n-    visitor.expr_count += 1;\n-\n     let prev_cx = visitor.cx;\n     visitor.enter_node_scope_with_dtor(expr.hir_id.local_id);\n \n@@ -837,6 +863,8 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n         _ => intravisit::walk_expr(visitor, expr)\n     }\n \n+    visitor.expr_count += 1;\n+\n     if let hir::ExprYield(..) = expr.node {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n         let mut scope = Scope::Node(expr.hir_id.local_id);"}, {"sha": "168e0251caf64e70b970bd61eebaaa2d49fd2cfd", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=5c0feb86b9d51e1ac80321b10dde43d1dbc3c042", "patch": "@@ -35,7 +35,12 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n \n         let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n             self.region_scope_tree.yield_in_scope(s).and_then(|(span, expr_count)| {\n-                // Check if the span in the region comes after the expression\n+                // If we are recording an expression that is the last yield\n+                // in the scope, or that has a postorder CFG index larger\n+                // than the one of all of the yields, then its value can't\n+                // be storage-live (and therefore live) at any of the yields.\n+                //\n+                // See the mega-comment at `yield_in_scope` for a proof.\n                 if expr.is_none() || expr_count >= self.expr_count {\n                     Some(span)\n                 } else {\n@@ -114,14 +119,13 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        intravisit::walk_expr(self, expr);\n+\n         self.expr_count += 1;\n \n         let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n-\n         let ty = self.fcx.tables.borrow().expr_ty_adjusted(expr);\n         self.record(ty, scope, Some(expr));\n-\n-        intravisit::walk_expr(self, expr);\n     }\n }"}, {"sha": "a1f110accc100cc56ea9cf21280dd74df7ef16b7", "filename": "src/test/ui/generator/not-send-sync.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr?ref=5c0feb86b9d51e1ac80321b10dde43d1dbc3c042", "patch": "@@ -9,15 +9,15 @@ error[E0277]: the trait bound `std::cell::Cell<i32>: std::marker::Sync` is not s\n    = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:26:17: 30:6 a:&std::cell::Cell<i32> _]`\n    = note: required by `main::assert_send`\n \n-error[E0277]: the trait bound `std::cell::Cell<i32>: std::marker::Sync` is not satisfied in `[generator@$DIR/not-send-sync.rs:19:17: 23:6 ((), std::cell::Cell<i32>)]`\n+error[E0277]: the trait bound `std::cell::Cell<i32>: std::marker::Sync` is not satisfied in `[generator@$DIR/not-send-sync.rs:19:17: 23:6 (std::cell::Cell<i32>, ())]`\n   --> $DIR/not-send-sync.rs:19:5\n    |\n 19 |     assert_sync(|| {\n    |     ^^^^^^^^^^^ `std::cell::Cell<i32>` cannot be shared between threads safely\n    |\n-   = help: within `[generator@$DIR/not-send-sync.rs:19:17: 23:6 ((), std::cell::Cell<i32>)]`, the trait `std::marker::Sync` is not implemented for `std::cell::Cell<i32>`\n-   = note: required because it appears within the type `((), std::cell::Cell<i32>)`\n-   = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:19:17: 23:6 ((), std::cell::Cell<i32>)]`\n+   = help: within `[generator@$DIR/not-send-sync.rs:19:17: 23:6 (std::cell::Cell<i32>, ())]`, the trait `std::marker::Sync` is not implemented for `std::cell::Cell<i32>`\n+   = note: required because it appears within the type `(std::cell::Cell<i32>, ())`\n+   = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:19:17: 23:6 (std::cell::Cell<i32>, ())]`\n    = note: required by `main::assert_sync`\n \n error: aborting due to 2 previous errors"}]}