{"sha": "39e049d2a1d7e0adbd9546f9e8124843443b31ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZTA0OWQyYTFkN2UwYWRiZDk1NDZmOWU4MTI0ODQzNDQzYjMxY2U=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-12T20:20:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-12T20:20:36Z"}, "message": "Merge #5319\n\n5319: Chalk upgrade r=flodiebold a=flodiebold\n\n - upgrade Chalk\r\n - make use of Chalk's `Unsize` impls, remove ours\r\n - use Chalk's built-in array type\r\n - search efficiently for impls for an int/float variable\r\n - output Chalk tracing logs in hir_ty tests\r\n\r\nFixes #2534.\r\nFixes #5057.\r\nFixes #4374.\r\nFixes #4281.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "c4bd56eaa24b25db28d8f213bae39c3b47703c46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4bd56eaa24b25db28d8f213bae39c3b47703c46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39e049d2a1d7e0adbd9546f9e8124843443b31ce", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfC3CUCRBK7hj4Ov3rIwAAdHIIAGKtqaWs9K5/58wsIlyPY3Ek\nDFOv/o/UHfyRjtAEbEkBNRa7Z0PxweS+6Bge/2PmDjdg5+qSSFMJ5586Ae+uZRHN\nAPF7xBDU/mTcNYyEcFz66c970rUuPd33Mg4LN0Zj8mqRA/FbkwzwGHqf+dmHJ8i9\nB7QKwQRiUmBK/xJIY1Q8jiLsBtWG85mG+/Ho1t2UHJ7DoJT9OnHV3h7W8uw0xJ7U\npO1+BPV8tAKVrp1Y2k2fx3KIdrJeQreRvswiS0cU3J0VRdEMQvwiFuqGedu/s+E6\nUcUAK59+XGmu7YXewewR69vLgWKoXqVO4QNmDBn4vvanjQZ7sMPC3+/QHCZL/6s=\n=7CNG\n-----END PGP SIGNATURE-----\n", "payload": "tree c4bd56eaa24b25db28d8f213bae39c3b47703c46\nparent ab1ad19f552e1b11055ed60f87cc420871d902eb\nparent d885f38011b6d4265b527744234b3c317fe86501\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594585236 +0000\ncommitter GitHub <noreply@github.com> 1594585236 +0000\n\nMerge #5319\n\n5319: Chalk upgrade r=flodiebold a=flodiebold\n\n - upgrade Chalk\r\n - make use of Chalk's `Unsize` impls, remove ours\r\n - use Chalk's built-in array type\r\n - search efficiently for impls for an int/float variable\r\n - output Chalk tracing logs in hir_ty tests\r\n\r\nFixes #2534.\r\nFixes #5057.\r\nFixes #4374.\r\nFixes #4281.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39e049d2a1d7e0adbd9546f9e8124843443b31ce", "html_url": "https://github.com/rust-lang/rust/commit/39e049d2a1d7e0adbd9546f9e8124843443b31ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39e049d2a1d7e0adbd9546f9e8124843443b31ce/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab1ad19f552e1b11055ed60f87cc420871d902eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab1ad19f552e1b11055ed60f87cc420871d902eb", "html_url": "https://github.com/rust-lang/rust/commit/ab1ad19f552e1b11055ed60f87cc420871d902eb"}, {"sha": "d885f38011b6d4265b527744234b3c317fe86501", "url": "https://api.github.com/repos/rust-lang/rust/commits/d885f38011b6d4265b527744234b3c317fe86501", "html_url": "https://github.com/rust-lang/rust/commit/d885f38011b6d4265b527744234b3c317fe86501"}], "stats": {"total": 773, "additions": 420, "deletions": 353}, "files": [{"sha": "66ae19b1e4561507aca2630fad57cf0172c0d4a9", "filename": "Cargo.lock", "status": "modified", "additions": 75, "deletions": 16, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -33,6 +33,15 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"ansi_term\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2\"\n+dependencies = [\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"anyhow\"\n version = \"1.0.31\"\n@@ -51,6 +60,17 @@ version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n \n+[[package]]\n+name = \"atty\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"autocfg\"\n version = \"1.0.0\"\n@@ -124,9 +144,9 @@ checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.15.0\"\n+version = \"0.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c7379caa72d04103fcfd9bde5642b816f58e3ffd6a0d39347e9e35a066648226\"\n+checksum = \"9396f12a23b1a40d5019aa81bc0cbd7ccd2c9736d6bc4afc95868533c2346dcb\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -135,42 +155,43 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"chalk-engine\"\n-version = \"0.15.0\"\n+name = \"chalk-ir\"\n+version = \"0.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8e8afe48b5663504b485791ab4fae69cf4864869a71ceec9c758fd4d03423722\"\n+checksum = \"87e9c67d500717d65ede27affb7ae40efe240d86fbefff1006fe0ffb62d4caf9\"\n dependencies = [\n  \"chalk-derive\",\n- \"chalk-ir\",\n- \"rustc-hash\",\n- \"tracing\",\n+ \"lazy_static\",\n ]\n \n [[package]]\n-name = \"chalk-ir\"\n-version = \"0.15.0\"\n+name = \"chalk-recursive\"\n+version = \"0.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"231e391a03c1fc45874171d92be9542efedc939bac59d9501ee28b9521feb406\"\n+checksum = \"a8fd2ac0fc06c857b95614d229bbe8ea317d1d94a7e8b9442a3f05c9a2c2d5f4\"\n dependencies = [\n  \"chalk-derive\",\n- \"lazy_static\",\n+ \"chalk-ir\",\n+ \"chalk-solve\",\n+ \"rustc-hash\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.15.0\"\n+version = \"0.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72c969c0fd06ad50538253327ca3445ff02cc9d0209f94c3cbf198ad9d365b48\"\n+checksum = \"2a79166f2405c1e51eadcc1344f5ee833c7b391532dd78f64a0731a9a123cc58\"\n dependencies = [\n  \"chalk-derive\",\n- \"chalk-engine\",\n  \"chalk-ir\",\n  \"ena\",\n  \"itertools\",\n  \"petgraph\",\n  \"rustc-hash\",\n  \"tracing\",\n  \"tracing-subscriber\",\n+ \"tracing-tree\",\n ]\n \n [[package]]\n@@ -971,6 +992,16 @@ dependencies = [\n  \"unicode-xid\",\n ]\n \n+[[package]]\n+name = \"quanta\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f4f7a1905379198075914bc93d32a5465c40474f90a078bb13439cb00c547bcc\"\n+dependencies = [\n+ \"libc\",\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"quote\"\n version = \"1.0.7\"\n@@ -1103,6 +1134,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"arrayvec\",\n  \"chalk-ir\",\n+ \"chalk-recursive\",\n  \"chalk-solve\",\n  \"ena\",\n  \"expect\",\n@@ -1120,6 +1152,9 @@ dependencies = [\n  \"smallvec\",\n  \"stdx\",\n  \"test_utils\",\n+ \"tracing\",\n+ \"tracing-subscriber\",\n+ \"tracing-tree\",\n ]\n \n [[package]]\n@@ -1722,6 +1757,15 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"termcolor\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bb6bfa289a4d7c5766392812c0a1f4c1ba45afa1ad47803c11e1f407d846d75f\"\n+dependencies = [\n+ \"winapi-util\",\n+]\n+\n [[package]]\n name = \"terminal_size\"\n version = \"0.1.13\"\n@@ -1856,7 +1900,7 @@ version = \"0.2.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c72c8cf3ec4ed69fef614d011a5ae4274537a8a8c59133558029bd731eb71659\"\n dependencies = [\n- \"ansi_term\",\n+ \"ansi_term 0.11.0\",\n  \"chrono\",\n  \"lazy_static\",\n  \"matchers\",\n@@ -1870,6 +1914,21 @@ dependencies = [\n  \"tracing-serde\",\n ]\n \n+[[package]]\n+name = \"tracing-tree\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e0a389731c9e6c56fef11e438e5b6afae861d5bc301c8b4bdca8d19f0e830d82\"\n+dependencies = [\n+ \"ansi_term 0.12.1\",\n+ \"atty\",\n+ \"chrono\",\n+ \"quanta\",\n+ \"termcolor\",\n+ \"tracing\",\n+ \"tracing-subscriber\",\n+]\n+\n [[package]]\n name = \"unicode-bidi\"\n version = \"0.3.4\""}, {"sha": "90368220b919d1b3d022cfcc8aa8d75935f9261a", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -27,9 +27,14 @@ test_utils = { path = \"../test_utils\" }\n \n scoped-tls = \"1\"\n \n-chalk-solve = { version = \"0.15.0\" }\n-chalk-ir = { version = \"0.15.0\" }\n+chalk-solve = { version = \"0.17.0\" }\n+chalk-ir = { version = \"0.17.0\" }\n+chalk-recursive = { version = \"0.17.0\" }\n \n [dev-dependencies]\n insta = \"0.16.0\"\n expect = { path = \"../expect\" }\n+\n+tracing = \"0.1\"\n+tracing-subscriber = { version = \"0.2\", default-features = false, features = [\"env-filter\", \"registry\"] }\n+tracing-tree = { version = \"0.1.3\" }"}, {"sha": "fb4b30a131fc1ddf2ad599c4bbccff0376e4b7ad", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -6,8 +6,10 @@ use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n use hir_def::{\n-    lang_item::LangItemTarget, type_ref::Mutability, AssocContainerId, AssocItemId, FunctionId,\n-    HasModule, ImplId, Lookup, TraitId,\n+    builtin_type::{IntBitness, Signedness},\n+    lang_item::LangItemTarget,\n+    type_ref::Mutability,\n+    AssocContainerId, AssocItemId, FunctionId, HasModule, ImplId, Lookup, TraitId,\n };\n use hir_expand::name::Name;\n use ra_db::CrateId;\n@@ -16,9 +18,12 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use super::Substs;\n use crate::{\n-    autoderef, db::HirDatabase, primitive::FloatBitness, utils::all_super_traits, ApplicationTy,\n-    Canonical, DebruijnIndex, InEnvironment, TraitEnvironment, TraitRef, Ty, TyKind, TypeCtor,\n-    TypeWalk,\n+    autoderef,\n+    db::HirDatabase,\n+    primitive::{FloatBitness, FloatTy, IntTy},\n+    utils::all_super_traits,\n+    ApplicationTy, Canonical, DebruijnIndex, InEnvironment, TraitEnvironment, TraitRef, Ty, TyKind,\n+    TypeCtor, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -39,6 +44,62 @@ impl TyFingerprint {\n     }\n }\n \n+pub(crate) const ALL_INT_FPS: [TyFingerprint; 12] = [\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Unsigned,\n+        bitness: IntBitness::X8,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Unsigned,\n+        bitness: IntBitness::X16,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Unsigned,\n+        bitness: IntBitness::X32,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Unsigned,\n+        bitness: IntBitness::X64,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Unsigned,\n+        bitness: IntBitness::X128,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Unsigned,\n+        bitness: IntBitness::Xsize,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Signed,\n+        bitness: IntBitness::X8,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Signed,\n+        bitness: IntBitness::X16,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Signed,\n+        bitness: IntBitness::X32,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Signed,\n+        bitness: IntBitness::X64,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Signed,\n+        bitness: IntBitness::X128,\n+    })),\n+    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n+        signedness: Signedness::Signed,\n+        bitness: IntBitness::Xsize,\n+    })),\n+];\n+\n+pub(crate) const ALL_FLOAT_FPS: [TyFingerprint; 2] = [\n+    TyFingerprint::Apply(TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 })),\n+    TyFingerprint::Apply(TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 })),\n+];\n+\n /// Trait impls defined or available in some crate.\n #[derive(Debug, Eq, PartialEq)]\n pub struct TraitImpls {"}, {"sha": "27f5a60bf6edbea68ffaed2db09cbbe9e7d7e91e", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -37,6 +37,15 @@ use crate::{\n // against snapshots of the expected results using insta. Use cargo-insta to\n // update the snapshots.\n \n+fn setup_tracing() -> tracing::subscriber::DefaultGuard {\n+    use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Registry};\n+    use tracing_tree::HierarchicalLayer;\n+    let filter = EnvFilter::from_env(\"CHALK_DEBUG\");\n+    let layer = HierarchicalLayer::default().with_indent_amount(2).with_writer(std::io::stderr);\n+    let subscriber = Registry::default().with(filter).with(layer);\n+    tracing::subscriber::set_default(subscriber)\n+}\n+\n fn check_types(ra_fixture: &str) {\n     check_types_impl(ra_fixture, false)\n }\n@@ -46,6 +55,7 @@ fn check_types_source_code(ra_fixture: &str) {\n }\n \n fn check_types_impl(ra_fixture: &str, display_source: bool) {\n+    let _tracing = setup_tracing();\n     let db = TestDB::with_files(ra_fixture);\n     let mut checked_one = false;\n     for (file_id, annotations) in db.extract_annotations() {\n@@ -86,6 +96,7 @@ fn infer(ra_fixture: &str) -> String {\n }\n \n fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n+    let _tracing = setup_tracing();\n     let (db, file_id) = TestDB::with_single_file(content);\n \n     let mut buf = String::new();"}, {"sha": "d7fb6a962e8e9ed07a02b92eb577e6dce58e1d60", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -662,7 +662,53 @@ fn test() {\n }\n \n #[test]\n-fn coerce_unsize_trait_object() {\n+fn coerce_unsize_trait_object_simple() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+#[lang = \"unsize\"]\n+pub trait Unsize<T> {}\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+trait Foo<T, U> {}\n+trait Bar<U, T, X>: Foo<T, U> {}\n+trait Baz<T, X>: Bar<usize, T, X> {}\n+\n+struct S<T, X>;\n+impl<T, X> Foo<T, usize> for S<T, X> {}\n+impl<T, X> Bar<usize, T, X> for S<T, X> {}\n+impl<T, X> Baz<T, X> for S<T, X> {}\n+\n+fn test() {\n+    let obj: &dyn Baz<i8, i16> = &S;\n+    let obj: &dyn Bar<_, i8, i16> = &S;\n+    let obj: &dyn Foo<i8, _> = &S;\n+}\n+\"#, true),\n+        @r###\"\n+    424..539 '{     ... &S; }': ()\n+    434..437 'obj': &dyn Baz<i8, i16>\n+    459..461 '&S': &S<i8, i16>\n+    460..461 'S': S<i8, i16>\n+    471..474 'obj': &dyn Bar<usize, i8, i16>\n+    499..501 '&S': &S<i8, i16>\n+    500..501 'S': S<i8, i16>\n+    511..514 'obj': &dyn Foo<i8, usize>\n+    534..536 '&S': &S<i8, {unknown}>\n+    535..536 'S': S<i8, {unknown}>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+// The rust reference says this should be possible, but rustc doesn't implement\n+// it. We used to support it, but Chalk doesn't.\n+#[ignore]\n+fn coerce_unsize_trait_object_to_trait_object() {\n     assert_snapshot!(\n         infer_with_mismatches(r#\"\n #[lang = \"sized\"]\n@@ -735,16 +781,17 @@ impl D for S {}\n \n fn test() {\n     let obj: &dyn D = &S;\n-    let obj: &dyn A = obj;\n+    let obj: &dyn A = &S;\n }\n \"#, true),\n         @r###\"\n-    328..384 '{     ...obj; }': ()\n+    328..383 '{     ... &S; }': ()\n     338..341 'obj': &dyn D\n     352..354 '&S': &S\n     353..354 'S': S\n     364..367 'obj': &dyn A\n-    378..381 'obj': &dyn D\n+    378..380 '&S': &S\n+    379..380 'S': S\n     \"###\n     );\n }"}, {"sha": "27737fa941ed40a7ae2dfadadc45a2a8b4ff4825", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 72, "deletions": 60, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -1991,6 +1991,28 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn fn_item_fn_trait() {\n+    check_types(\n+        r#\"\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+struct S;\n+\n+fn foo() -> S {}\n+\n+fn takes_closure<U, F: FnOnce() -> U>(f: F) -> U { f() }\n+\n+fn test() {\n+    takes_closure(foo);\n+} //^^^^^^^^^^^^^^^^^^ S\n+\"#,\n+    );\n+}\n+\n #[test]\n fn unselected_projection_in_trait_env_1() {\n     check_types(\n@@ -3000,74 +3022,47 @@ fn infer_box_fn_arg() {\n \n #[test]\n fn infer_dyn_fn_output() {\n-    assert_snapshot!(\n-        infer(\n-            r#\"\n-            //- /lib.rs deps:std\n-\n-            #[lang = \"fn_once\"]\n-            pub trait FnOnce<Args> {\n-                type Output;\n-\n-                extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-            }\n-\n-            #[lang = \"fn\"]\n-            pub trait Fn<Args>:FnOnce<Args> {\n-                extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-            }\n-\n-            #[lang = \"deref\"]\n-            pub trait Deref {\n-                type Target: ?Sized;\n-\n-                fn deref(&self) -> &Self::Target;\n-            }\n+    check_types(\n+        r#\"\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    type Output;\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n \n-            #[lang = \"owned_box\"]\n-            pub struct Box<T: ?Sized> {\n-                inner: *mut T,\n-            }\n+#[lang = \"fn\"]\n+pub trait Fn<Args>: FnOnce<Args> {\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n \n-            impl<T: ?Sized> Deref for Box<T> {\n-                type Target = T;\n+fn foo() {\n+    let f: &dyn Fn() -> i32;\n+    f();\n+  //^^^ i32\n+}\"#,\n+    );\n+}\n \n-                fn deref(&self) -> &T {\n-                    &self.inner\n-                }\n-            }\n+#[test]\n+fn infer_dyn_fn_once_output() {\n+    check_types(\n+        r#\"\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    type Output;\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n \n-            fn foo() {\n-                let f: Box<dyn Fn() -> i32> = box(|| 5);\n-                let x = f();\n-            }\n-        \"#\n-        ),\n-        @r###\"\n-    100..104 'self': Self\n-    106..110 'args': Args\n-    219..223 'self': &Self\n-    225..229 'args': Args\n-    333..337 'self': &Self\n-    503..507 'self': &Box<T>\n-    515..542 '{     ...     }': &T\n-    525..536 '&self.inner': &*mut T\n-    526..530 'self': &Box<T>\n-    526..536 'self.inner': *mut T\n-    555..620 '{     ...f(); }': ()\n-    565..566 'f': Box<dyn Fn<(), Output = i32>>\n-    591..600 'box(|| 5)': Box<|| -> i32>\n-    595..599 '|| 5': || -> i32\n-    598..599 '5': i32\n-    610..611 'x': FnOnce::Output<dyn Fn<(), Output = i32>, ()>\n-    614..615 'f': Box<dyn Fn<(), Output = i32>>\n-    614..617 'f()': FnOnce::Output<dyn Fn<(), Output = i32>, ()>\n-    \"###\n+fn foo() {\n+    let f: dyn FnOnce() -> i32;\n+    f();\n+  //^^^ i32\n+}\"#,\n     );\n }\n \n #[test]\n-fn variable_kinds() {\n+fn variable_kinds_1() {\n     check_types(\n         r#\"\n trait Trait<T> { fn get(self, t: T) -> T; }\n@@ -3083,3 +3078,20 @@ fn test() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn variable_kinds_2() {\n+    check_types(\n+        r#\"\n+trait Trait { fn get(self) -> Self; }\n+impl Trait for u128 {}\n+impl Trait for f32 {}\n+fn test() {\n+    1.get();\n+  //^^^^^^^ u128\n+    (1.).get();\n+  //^^^^^^^^^^ f32\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "f7edb4c8b6af740040c82fbaa3646fb7b593a658", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -2,6 +2,7 @@\n use std::sync::Arc;\n \n use chalk_ir::cast::Cast;\n+use chalk_solve::Solver;\n use hir_def::{\n     expr::ExprId, lang_item::LangItemTarget, DefWithBodyId, ImplId, TraitId, TypeAliasId,\n };\n@@ -32,9 +33,10 @@ struct ChalkContext<'a> {\n     krate: CrateId,\n }\n \n-fn create_chalk_solver() -> chalk_solve::Solver<Interner> {\n-    let solver_choice = chalk_solve::SolverChoice::recursive();\n-    solver_choice.into_solver()\n+fn create_chalk_solver() -> chalk_recursive::RecursiveSolver<Interner> {\n+    let overflow_depth = 100;\n+    let caching_enabled = true;\n+    chalk_recursive::RecursiveSolver::new(overflow_depth, caching_enabled)\n }\n \n /// A set of clauses that we assume to be true. E.g. if we are inside this function:\n@@ -293,13 +295,8 @@ pub enum Impl {\n     /// A normal impl from an impl block.\n     ImplDef(ImplId),\n     /// Closure types implement the Fn traits synthetically.\n+    // FIXME: implement closure support from Chalk, remove this\n     ClosureFnTraitImpl(ClosureFnTraitImplData),\n-    /// [T; n]: Unsize<[T]>\n-    UnsizeArray,\n-    /// T: Unsize<dyn Trait> where T: Trait\n-    UnsizeToTraitObject(TraitId),\n-    /// dyn Trait: Unsize<dyn SuperTrait> if Trait: SuperTrait\n-    UnsizeToSuperTraitObject(UnsizeToSuperTraitObjectData),\n }\n /// This exists just for Chalk, because our ImplIds are only unique per module.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "86e22e459542a669ac49a86b7fb333b749412917", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 4, "deletions": 197, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -1,15 +1,12 @@\n //! This module provides the built-in trait implementations, e.g. to make\n //! closures implement `Fn`.\n-use hir_def::{expr::Expr, lang_item::LangItemTarget, TraitId, TypeAliasId};\n+use hir_def::{expr::Expr, TraitId, TypeAliasId};\n use hir_expand::name::name;\n use ra_db::CrateId;\n \n-use super::{AssocTyValue, Impl, UnsizeToSuperTraitObjectData};\n+use super::{AssocTyValue, Impl};\n use crate::{\n-    db::HirDatabase,\n-    utils::{all_super_traits, generics},\n-    ApplicationTy, Binders, BoundVar, DebruijnIndex, GenericPredicate, Substs, TraitRef, Ty,\n-    TypeCtor, TypeWalk,\n+    db::HirDatabase, ApplicationTy, BoundVar, DebruijnIndex, Substs, TraitRef, Ty, TypeCtor,\n };\n \n pub(super) struct BuiltinImplData {\n@@ -31,7 +28,7 @@ pub(super) fn get_builtin_impls(\n     krate: CrateId,\n     ty: &Ty,\n     // The first argument for the trait, if present\n-    arg: &Option<Ty>,\n+    _arg: &Option<Ty>,\n     trait_: TraitId,\n     mut callback: impl FnMut(Impl),\n ) {\n@@ -50,60 +47,12 @@ pub(super) fn get_builtin_impls(\n             }\n         }\n     }\n-\n-    let unsize_trait = get_unsize_trait(db, krate);\n-    if let Some(actual_trait) = unsize_trait {\n-        if trait_ == actual_trait {\n-            get_builtin_unsize_impls(db, krate, ty, arg, callback);\n-        }\n-    }\n-}\n-\n-fn get_builtin_unsize_impls(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    ty: &Ty,\n-    // The first argument for the trait, if present\n-    arg: &Option<Ty>,\n-    mut callback: impl FnMut(Impl),\n-) {\n-    if !check_unsize_impl_prerequisites(db, krate) {\n-        return;\n-    }\n-\n-    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Array, .. }) = ty {\n-        callback(Impl::UnsizeArray);\n-        return; // array is unsized, the rest of the impls shouldn't apply\n-    }\n-\n-    if let Some(target_trait) = arg.as_ref().and_then(|t| t.dyn_trait_ref()) {\n-        // FIXME what about more complicated dyn tys with marker traits?\n-        if let Some(trait_ref) = ty.dyn_trait_ref() {\n-            if trait_ref.trait_ != target_trait.trait_ {\n-                let super_traits = all_super_traits(db.upcast(), trait_ref.trait_);\n-                if super_traits.contains(&target_trait.trait_) {\n-                    callback(Impl::UnsizeToSuperTraitObject(UnsizeToSuperTraitObjectData {\n-                        trait_: trait_ref.trait_,\n-                        super_trait: target_trait.trait_,\n-                    }));\n-                }\n-            }\n-        } else {\n-            // FIXME only for sized types\n-            callback(Impl::UnsizeToTraitObject(target_trait.trait_));\n-        }\n-    }\n }\n \n pub(super) fn impl_datum(db: &dyn HirDatabase, krate: CrateId, impl_: Impl) -> BuiltinImplData {\n     match impl_ {\n         Impl::ImplDef(_) => unreachable!(),\n         Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n-        Impl::UnsizeArray => array_unsize_impl_datum(db, krate),\n-        Impl::UnsizeToTraitObject(trait_) => trait_object_unsize_impl_datum(db, krate, trait_),\n-        Impl::UnsizeToSuperTraitObject(data) => {\n-            super_trait_object_unsize_impl_datum(db, krate, data)\n-        }\n     }\n }\n \n@@ -227,145 +176,3 @@ fn closure_fn_trait_output_assoc_ty_value(\n         value: output_ty,\n     }\n }\n-\n-// Array unsizing\n-\n-fn check_unsize_impl_prerequisites(db: &dyn HirDatabase, krate: CrateId) -> bool {\n-    // the Unsize trait needs to exist and have two type parameters (Self and T)\n-    let unsize_trait = match get_unsize_trait(db, krate) {\n-        Some(t) => t,\n-        None => return false,\n-    };\n-    let generic_params = generics(db.upcast(), unsize_trait.into());\n-    generic_params.len() == 2\n-}\n-\n-fn array_unsize_impl_datum(db: &dyn HirDatabase, krate: CrateId) -> BuiltinImplData {\n-    // impl<T> Unsize<[T]> for [T; _]\n-    // (this can be a single impl because we don't distinguish array sizes currently)\n-\n-    let trait_ = get_unsize_trait(db, krate) // get unsize trait\n-        // the existence of the Unsize trait has been checked before\n-        .expect(\"Unsize trait missing\");\n-\n-    let var = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n-    let substs = Substs::builder(2)\n-        .push(Ty::apply_one(TypeCtor::Array, var.clone()))\n-        .push(Ty::apply_one(TypeCtor::Slice, var))\n-        .build();\n-\n-    let trait_ref = TraitRef { trait_, substs };\n-\n-    BuiltinImplData {\n-        num_vars: 1,\n-        trait_ref,\n-        where_clauses: Vec::new(),\n-        assoc_ty_values: Vec::new(),\n-    }\n-}\n-\n-// Trait object unsizing\n-\n-fn trait_object_unsize_impl_datum(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    trait_: TraitId,\n-) -> BuiltinImplData {\n-    // impl<T, T1, ...> Unsize<dyn Trait<T1, ...>> for T where T: Trait<T1, ...>\n-\n-    let unsize_trait = get_unsize_trait(db, krate) // get unsize trait\n-        // the existence of the Unsize trait has been checked before\n-        .expect(\"Unsize trait missing\");\n-\n-    let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n-\n-    let target_substs = Substs::build_for_def(db, trait_)\n-        .push(Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0)))\n-        .fill_with_bound_vars(DebruijnIndex::ONE, 1)\n-        .build();\n-    let num_vars = target_substs.len();\n-    let target_trait_ref = TraitRef { trait_, substs: target_substs };\n-    let target_bounds = vec![GenericPredicate::Implemented(target_trait_ref)];\n-\n-    let self_substs =\n-        Substs::build_for_def(db, trait_).fill_with_bound_vars(DebruijnIndex::INNERMOST, 0).build();\n-    let self_trait_ref = TraitRef { trait_, substs: self_substs };\n-    let where_clauses = vec![GenericPredicate::Implemented(self_trait_ref)];\n-\n-    let impl_substs = Substs::builder(2).push(self_ty).push(Ty::Dyn(target_bounds.into())).build();\n-\n-    let trait_ref = TraitRef { trait_: unsize_trait, substs: impl_substs };\n-\n-    BuiltinImplData { num_vars, trait_ref, where_clauses, assoc_ty_values: Vec::new() }\n-}\n-\n-fn super_trait_object_unsize_impl_datum(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    data: UnsizeToSuperTraitObjectData,\n-) -> BuiltinImplData {\n-    // impl<T1, ...> Unsize<dyn SuperTrait> for dyn Trait<T1, ...>\n-\n-    let unsize_trait = get_unsize_trait(db, krate) // get unsize trait\n-        // the existence of the Unsize trait has been checked before\n-        .expect(\"Unsize trait missing\");\n-\n-    let self_substs = Substs::build_for_def(db, data.trait_)\n-        .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n-        .build();\n-    let self_trait_ref = TraitRef { trait_: data.trait_, substs: self_substs.clone() };\n-\n-    let num_vars = self_substs.len() - 1;\n-\n-    // we need to go from our trait to the super trait, substituting type parameters\n-    let path = crate::utils::find_super_trait_path(db.upcast(), data.trait_, data.super_trait);\n-\n-    let mut current_trait_ref = self_trait_ref.clone();\n-    for t in path.into_iter().skip(1) {\n-        let bounds = db.generic_predicates(current_trait_ref.trait_.into());\n-        let super_trait_ref = bounds\n-            .iter()\n-            .find_map(|b| match &b.value {\n-                GenericPredicate::Implemented(tr)\n-                    if tr.trait_ == t\n-                        && tr.substs[0]\n-                            == Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0)) =>\n-                {\n-                    Some(Binders { value: tr, num_binders: b.num_binders })\n-                }\n-                _ => None,\n-            })\n-            .expect(\"trait bound for known super trait not found\");\n-        current_trait_ref = super_trait_ref.cloned().subst(&current_trait_ref.substs);\n-    }\n-\n-    // We need to renumber the variables a bit now: from ^0.0, ^0.1, ^0.2, ...\n-    // to ^0.0, ^1.0, ^1.1. The reason for this is that the first variable comes\n-    // from the dyn Trait binder, while the other variables come from the impl.\n-    let new_substs = Substs::builder(num_vars + 1)\n-        .push(Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0)))\n-        .fill_with_bound_vars(DebruijnIndex::ONE, 0)\n-        .build();\n-\n-    let self_bounds =\n-        vec![GenericPredicate::Implemented(self_trait_ref.subst_bound_vars(&new_substs))];\n-    let super_bounds =\n-        vec![GenericPredicate::Implemented(current_trait_ref.subst_bound_vars(&new_substs))];\n-\n-    let substs = Substs::builder(2)\n-        .push(Ty::Dyn(self_bounds.into()))\n-        .push(Ty::Dyn(super_bounds.into()))\n-        .build();\n-\n-    let trait_ref = TraitRef { trait_: unsize_trait, substs };\n-\n-    BuiltinImplData { num_vars, trait_ref, where_clauses: Vec::new(), assoc_ty_values: Vec::new() }\n-}\n-\n-fn get_unsize_trait(db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n-    let target = db.lang_item(krate, \"unsize\".into())?;\n-    match target {\n-        LangItemTarget::TraitId(t) => Some(t),\n-        _ => None,\n-    }\n-}"}, {"sha": "c448aea656645c563175aecd7fbec4ad969dcfed", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 62, "deletions": 15, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use log::debug;\n \n-use chalk_ir::{fold::shift::Shift, GenericArg, TypeName};\n+use chalk_ir::{fold::shift::Shift, CanonicalVarKinds, GenericArg, TypeName};\n use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n use hir_def::{\n@@ -14,7 +14,10 @@ use ra_db::{salsa::InternKey, CrateId};\n \n use super::{builtin, AssocTyValue, ChalkContext, Impl};\n use crate::{\n-    db::HirDatabase, display::HirDisplay, method_resolution::TyFingerprint, utils::generics,\n+    db::HirDatabase,\n+    display::HirDisplay,\n+    method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n+    utils::generics,\n     CallableDef, DebruijnIndex, GenericPredicate, Substs, Ty, TypeCtor,\n };\n use mapping::{convert_where_clauses, generic_predicate_to_inline_bound, make_binders};\n@@ -66,13 +69,31 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         &self,\n         trait_id: TraitId,\n         parameters: &[GenericArg<Interner>],\n+        binders: &CanonicalVarKinds<Interner>,\n     ) -> Vec<ImplId> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n         let trait_: hir_def::TraitId = from_chalk(self.db, trait_id);\n \n         let ty: Ty = from_chalk(self.db, parameters[0].assert_ty_ref(&Interner).clone());\n \n+        fn binder_kind(ty: &Ty, binders: &CanonicalVarKinds<Interner>) -> Option<chalk_ir::TyKind> {\n+            if let Ty::Bound(bv) = ty {\n+                let binders = binders.as_slice(&Interner);\n+                if bv.debruijn == DebruijnIndex::INNERMOST {\n+                    if let chalk_ir::VariableKind::Ty(tk) = binders[bv.index].kind {\n+                        return Some(tk);\n+                    }\n+                }\n+            }\n+            None\n+        }\n+\n         let self_ty_fp = TyFingerprint::for_impl(&ty);\n+        let fps: &[TyFingerprint] = match binder_kind(&ty, binders) {\n+            Some(chalk_ir::TyKind::Integer) => &ALL_INT_FPS,\n+            Some(chalk_ir::TyKind::Float) => &ALL_FLOAT_FPS,\n+            _ => self_ty_fp.as_ref().map(std::slice::from_ref).unwrap_or(&[]),\n+        };\n \n         // Note: Since we're using impls_for_trait, only impls where the trait\n         // can be resolved should ever reach Chalk. `impl_datum` relies on that\n@@ -83,17 +104,21 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n \n         let id_to_chalk = |id: hir_def::ImplId| Impl::ImplDef(id).to_chalk(self.db);\n \n-        let mut result: Vec<_> = match self_ty_fp {\n-            Some(fp) => impl_maps\n+        let mut result: Vec<_> = if fps.is_empty() {\n+            debug!(\"Unrestricted search for {:?} impls...\", trait_);\n+            impl_maps\n+                .iter()\n+                .flat_map(|crate_impl_defs| crate_impl_defs.for_trait(trait_).map(id_to_chalk))\n+                .collect()\n+        } else {\n+            impl_maps\n                 .iter()\n                 .flat_map(|crate_impl_defs| {\n-                    crate_impl_defs.for_trait_and_self_ty(trait_, fp).map(id_to_chalk)\n+                    fps.iter().flat_map(move |fp| {\n+                        crate_impl_defs.for_trait_and_self_ty(trait_, *fp).map(id_to_chalk)\n+                    })\n                 })\n-                .collect(),\n-            None => impl_maps\n-                .iter()\n-                .flat_map(|crate_impl_defs| crate_impl_defs.for_trait(trait_).map(id_to_chalk))\n-                .collect(),\n+                .collect()\n         };\n \n         let arg: Option<Ty> =\n@@ -219,6 +244,22 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         // FIXME: implement closure support\n         unimplemented!()\n     }\n+\n+    fn trait_name(&self, _trait_id: chalk_ir::TraitId<Interner>) -> String {\n+        unimplemented!()\n+    }\n+    fn adt_name(&self, _struct_id: chalk_ir::AdtId<Interner>) -> String {\n+        unimplemented!()\n+    }\n+    fn assoc_type_name(&self, _assoc_ty_id: chalk_ir::AssocTypeId<Interner>) -> String {\n+        unimplemented!()\n+    }\n+    fn opaque_type_name(&self, _opaque_ty_id: chalk_ir::OpaqueTyId<Interner>) -> String {\n+        unimplemented!()\n+    }\n+    fn fn_def_name(&self, _fn_def_id: chalk_ir::FnDefId<Interner>) -> String {\n+        unimplemented!()\n+    }\n }\n \n pub(crate) fn program_clauses_for_chalk_env_query(\n@@ -354,12 +395,18 @@ pub(crate) fn struct_datum_query(\n         fundamental: false,\n         phantom_data: false,\n     };\n-    let struct_datum_bound = rust_ir::AdtDatumBound {\n-        fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n-        where_clauses,\n+    // FIXME provide enum variants properly (for auto traits)\n+    let variant = rust_ir::AdtVariantDatum {\n+        fields: Vec::new(), // FIXME add fields (only relevant for auto traits),\n+    };\n+    let struct_datum_bound = rust_ir::AdtDatumBound { variants: vec![variant], where_clauses };\n+    let struct_datum = StructDatum {\n+        // FIXME set ADT kind\n+        kind: rust_ir::AdtKind::Struct,\n+        id: struct_id,\n+        binders: make_binders(struct_datum_bound, num_params),\n+        flags,\n     };\n-    let struct_datum =\n-        StructDatum { id: struct_id, binders: make_binders(struct_datum_bound, num_params), flags };\n     Arc::new(struct_datum)\n }\n "}, {"sha": "156b691b45c3a3acbaa0681f553b3bdbdf779d43", "filename": "crates/ra_hir_ty/src/traits/chalk/interner.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -39,6 +39,7 @@ impl chalk_ir::interner::Interner for Interner {\n     type InternedQuantifiedWhereClauses = Vec<chalk_ir::QuantifiedWhereClause<Self>>;\n     type InternedVariableKinds = Vec<chalk_ir::VariableKind<Self>>;\n     type InternedCanonicalVarKinds = Vec<chalk_ir::CanonicalVarKind<Self>>;\n+    type InternedConstraints = Vec<chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>>;\n     type DefId = InternId;\n     type InternedAdtId = crate::TypeCtorId;\n     type Identifier = TypeAliasId;\n@@ -349,6 +350,20 @@ impl chalk_ir::interner::Interner for Interner {\n     ) -> &'a [chalk_ir::CanonicalVarKind<Self>] {\n         &canonical_var_kinds\n     }\n+\n+    fn intern_constraints<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>, E>>,\n+    ) -> Result<Self::InternedConstraints, E> {\n+        data.into_iter().collect()\n+    }\n+\n+    fn constraints_data<'a>(\n+        &self,\n+        constraints: &'a Self::InternedConstraints,\n+    ) -> &'a [chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>] {\n+        constraints\n+    }\n }\n \n impl chalk_ir::interner::HasInterner for Interner {"}, {"sha": "7dc9ee7598d762370fd1039995bcdb61df87d25c", "filename": "crates/ra_hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -29,6 +29,7 @@ impl ToChalk for Ty {\n         match self {\n             Ty::Apply(apply_ty) => match apply_ty.ctor {\n                 TypeCtor::Ref(m) => ref_to_chalk(db, m, apply_ty.parameters),\n+                TypeCtor::Array => array_to_chalk(db, apply_ty.parameters),\n                 TypeCtor::FnPtr { num_args: _ } => {\n                     let substitution = apply_ty.parameters.to_chalk(db).shifted_in(&Interner);\n                     chalk_ir::TyData::Function(chalk_ir::Fn { num_binders: 0, substitution })\n@@ -61,13 +62,13 @@ impl ToChalk for Ty {\n             Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx).intern(&Interner),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n             Ty::Dyn(predicates) => {\n-                let where_clauses = chalk_ir::QuantifiedWhereClauses::from(\n+                let where_clauses = chalk_ir::QuantifiedWhereClauses::from_iter(\n                     &Interner,\n                     predicates.iter().filter(|p| !p.is_error()).cloned().map(|p| p.to_chalk(db)),\n                 );\n                 let bounded_ty = chalk_ir::DynTy {\n                     bounds: make_binders(where_clauses, 1),\n-                    lifetime: LIFETIME_PLACEHOLDER.to_lifetime(&Interner),\n+                    lifetime: FAKE_PLACEHOLDER.to_lifetime(&Interner),\n                 };\n                 chalk_ir::TyData::Dyn(bounded_ty).intern(&Interner)\n             }\n@@ -92,6 +93,7 @@ impl ToChalk for Ty {\n             chalk_ir::TyData::Apply(apply_ty) => match apply_ty.name {\n                 TypeName::Error => Ty::Unknown,\n                 TypeName::Ref(m) => ref_from_chalk(db, m, apply_ty.substitution),\n+                TypeName::Array => array_from_chalk(db, apply_ty.substitution),\n                 _ => {\n                     let ctor = from_chalk(db, apply_ty.name);\n                     let parameters = from_chalk(db, apply_ty.substitution);\n@@ -138,7 +140,7 @@ impl ToChalk for Ty {\n     }\n }\n \n-const LIFETIME_PLACEHOLDER: PlaceholderIndex =\n+const FAKE_PLACEHOLDER: PlaceholderIndex =\n     PlaceholderIndex { ui: UniverseIndex::ROOT, idx: usize::MAX };\n \n /// We currently don't model lifetimes, but Chalk does. So, we have to insert a\n@@ -149,10 +151,10 @@ fn ref_to_chalk(\n     subst: Substs,\n ) -> chalk_ir::Ty<Interner> {\n     let arg = subst[0].clone().to_chalk(db);\n-    let lifetime = LIFETIME_PLACEHOLDER.to_lifetime(&Interner);\n+    let lifetime = FAKE_PLACEHOLDER.to_lifetime(&Interner);\n     chalk_ir::ApplicationTy {\n         name: TypeName::Ref(mutability.to_chalk(db)),\n-        substitution: chalk_ir::Substitution::from(\n+        substitution: chalk_ir::Substitution::from_iter(\n             &Interner,\n             vec![lifetime.cast(&Interner), arg.cast(&Interner)],\n         ),\n@@ -173,11 +175,40 @@ fn ref_from_chalk(\n     Ty::apply(TypeCtor::Ref(from_chalk(db, mutability)), Substs(tys))\n }\n \n+/// We currently don't model constants, but Chalk does. So, we have to insert a\n+/// fake constant here, because Chalks built-in logic may expect it to be there.\n+fn array_to_chalk(db: &dyn HirDatabase, subst: Substs) -> chalk_ir::Ty<Interner> {\n+    let arg = subst[0].clone().to_chalk(db);\n+    let usize_ty = chalk_ir::ApplicationTy {\n+        name: TypeName::Scalar(Scalar::Uint(chalk_ir::UintTy::Usize)),\n+        substitution: chalk_ir::Substitution::empty(&Interner),\n+    }\n+    .intern(&Interner);\n+    let const_ = FAKE_PLACEHOLDER.to_const(&Interner, usize_ty);\n+    chalk_ir::ApplicationTy {\n+        name: TypeName::Array,\n+        substitution: chalk_ir::Substitution::from_iter(\n+            &Interner,\n+            vec![arg.cast(&Interner), const_.cast(&Interner)],\n+        ),\n+    }\n+    .intern(&Interner)\n+}\n+\n+/// Here we remove the const from the type we got from Chalk.\n+fn array_from_chalk(db: &dyn HirDatabase, subst: chalk_ir::Substitution<Interner>) -> Ty {\n+    let tys = subst\n+        .iter(&Interner)\n+        .filter_map(|p| Some(from_chalk(db, p.ty(&Interner)?.clone())))\n+        .collect();\n+    Ty::apply(TypeCtor::Array, Substs(tys))\n+}\n+\n impl ToChalk for Substs {\n     type Chalk = chalk_ir::Substitution<Interner>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Substitution<Interner> {\n-        chalk_ir::Substitution::from(&Interner, self.iter().map(|ty| ty.clone().to_chalk(db)))\n+        chalk_ir::Substitution::from_iter(&Interner, self.iter().map(|ty| ty.clone().to_chalk(db)))\n     }\n \n     fn from_chalk(db: &dyn HirDatabase, parameters: chalk_ir::Substitution<Interner>) -> Substs {\n@@ -263,6 +294,7 @@ impl ToChalk for TypeCtor {\n             TypeCtor::Tuple { cardinality } => TypeName::Tuple(cardinality.into()),\n             TypeCtor::RawPtr(mutability) => TypeName::Raw(mutability.to_chalk(db)),\n             TypeCtor::Slice => TypeName::Slice,\n+            TypeCtor::Array => TypeName::Array,\n             TypeCtor::Ref(mutability) => TypeName::Ref(mutability.to_chalk(db)),\n             TypeCtor::Str => TypeName::Str,\n             TypeCtor::FnDef(callable_def) => {\n@@ -271,10 +303,8 @@ impl ToChalk for TypeCtor {\n             }\n             TypeCtor::Never => TypeName::Never,\n \n-            TypeCtor::Adt(_)\n-            | TypeCtor::Array\n-            | TypeCtor::FnPtr { .. }\n-            | TypeCtor::Closure { .. } => {\n+            // FIXME convert these\n+            TypeCtor::Adt(_) | TypeCtor::FnPtr { .. } | TypeCtor::Closure { .. } => {\n                 // other TypeCtors get interned and turned into a chalk StructId\n                 let struct_id = db.intern_type_ctor(self).into();\n                 TypeName::Adt(struct_id)\n@@ -492,6 +522,11 @@ impl ToChalk for GenericPredicate {\n                 // we shouldn't get these from Chalk\n                 panic!(\"encountered LifetimeOutlives from Chalk\")\n             }\n+\n+            chalk_ir::WhereClause::TypeOutlives(_) => {\n+                // we shouldn't get these from Chalk\n+                panic!(\"encountered TypeOutlives from Chalk\")\n+            }\n         }\n     }\n }\n@@ -570,7 +605,10 @@ where\n                 )\n             });\n         let value = self.value.to_chalk(db);\n-        chalk_ir::Canonical { value, binders: chalk_ir::CanonicalVarKinds::from(&Interner, kinds) }\n+        chalk_ir::Canonical {\n+            value,\n+            binders: chalk_ir::CanonicalVarKinds::from_iter(&Interner, kinds),\n+        }\n     }\n \n     fn from_chalk(db: &dyn HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n@@ -691,7 +729,7 @@ where\n     T: HasInterner<Interner = Interner>,\n {\n     chalk_ir::Binders::new(\n-        chalk_ir::VariableKinds::from(\n+        chalk_ir::VariableKinds::from_iter(\n             &Interner,\n             std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General)).take(num_vars),\n         ),"}, {"sha": "1e226baead897ff39152f9b38319f4f900bb1c18", "filename": "crates/ra_hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -157,7 +157,7 @@ impl DebugContext<'_> {\n             _ => panic!(\"associated type not in trait\"),\n         };\n         let trait_data = self.0.trait_data(trait_);\n-        let params = projection_ty.substitution.parameters(&Interner);\n+        let params = projection_ty.substitution.as_slice(&Interner);\n         write!(fmt, \"<{:?} as {}\", &params[0], trait_data.name,)?;\n         if params.len() > 1 {\n             write!("}, {"sha": "e3e2442680e8ec7946c19501c70e480fe40c482b", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e049d2a1d7e0adbd9546f9e8124843443b31ce/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=39e049d2a1d7e0adbd9546f9e8124843443b31ce", "patch": "@@ -110,38 +110,6 @@ pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) ->\n     result\n }\n \n-/// Finds a path from a trait to one of its super traits. Returns an empty\n-/// vector if there is no path.\n-pub(super) fn find_super_trait_path(\n-    db: &dyn DefDatabase,\n-    trait_: TraitId,\n-    super_trait: TraitId,\n-) -> Vec<TraitId> {\n-    let mut result = Vec::with_capacity(2);\n-    result.push(trait_);\n-    return if go(db, super_trait, &mut result) { result } else { Vec::new() };\n-\n-    fn go(db: &dyn DefDatabase, super_trait: TraitId, path: &mut Vec<TraitId>) -> bool {\n-        let trait_ = *path.last().unwrap();\n-        if trait_ == super_trait {\n-            return true;\n-        }\n-\n-        for tt in direct_super_traits(db, trait_) {\n-            if path.contains(&tt) {\n-                continue;\n-            }\n-            path.push(tt);\n-            if go(db, super_trait, path) {\n-                return true;\n-            } else {\n-                path.pop();\n-            }\n-        }\n-        false\n-    }\n-}\n-\n pub(super) fn associated_type_by_name_including_super_traits(\n     db: &dyn HirDatabase,\n     trait_ref: TraitRef,"}]}