{"sha": "e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "node_id": "C_kwDOAAsO6NoAKGU2Yjg4M2M3NGY0OWYzMmNiNWQxY2JhZDM0NTdmMmI4ODA1YTRhMzg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-08T18:45:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-08T18:45:03Z"}, "message": "Auto merge of #91665 - matthiaskrgr:rollup-o3wnkam, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #90709 (Only shown relevant type params in E0283 label)\n - #91551 (Allow for failure of subst_normalize_erasing_regions in const_eval)\n - #91570 (Evaluate inline const pat early and report error if too generic)\n - #91571 (Remove unneeded access to pretty printer's `s` field in favor of deref)\n - #91610 (Link to rustdoc_json_types docs instead of rustdoc-json RFC)\n - #91619 (Update cargo)\n - #91630 (Add missing whitespace before disabled HTML attribute)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "53e1238381710371f5c0d88c6fd36284aea8482b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53e1238381710371f5c0d88c6fd36284aea8482b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "html_url": "https://github.com/rust-lang/rust/commit/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9e77f2b460492013cea459221194318b7fd8204", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e77f2b460492013cea459221194318b7fd8204", "html_url": "https://github.com/rust-lang/rust/commit/f9e77f2b460492013cea459221194318b7fd8204"}, {"sha": "382426be34fe0d5fda38068bb60ed1ac06ebd4c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/382426be34fe0d5fda38068bb60ed1ac06ebd4c8", "html_url": "https://github.com/rust-lang/rust/commit/382426be34fe0d5fda38068bb60ed1ac06ebd4c8"}], "stats": {"total": 1174, "additions": 766, "deletions": 408}, "files": [{"sha": "15fdc60c99fc88d3ebecbe9f103296d6c65f73b1", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -558,11 +558,11 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"2.33.3\"\n+version = \"2.34.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"37e58ac78573c40708d45522f0d80fa2f01cc4f9b4e2bf749807255454312002\"\n+checksum = \"a0610544180c38b88101fecf2dd634b174a62eef6946f84dfc6a7127512b381c\"\n dependencies = [\n- \"ansi_term 0.11.0\",\n+ \"ansi_term 0.12.1\",\n  \"atty\",\n  \"bitflags\",\n  \"strsim\","}, {"sha": "74f2a2b2e09d613511909b34c53b758d4cc197bf", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 165, "deletions": 165, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -878,29 +878,29 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n \n     fn print_ident(&mut self, ident: Ident) {\n-        self.s.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n+        self.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n         self.ann.post(self, AnnNode::Ident(&ident))\n     }\n \n     fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool) {\n         if colons_before_params {\n-            self.s.word(\"::\")\n+            self.word(\"::\")\n         }\n \n         match *args {\n             ast::GenericArgs::AngleBracketed(ref data) => {\n-                self.s.word(\"<\");\n+                self.word(\"<\");\n                 self.commasep(Inconsistent, &data.args, |s, arg| match arg {\n                     ast::AngleBracketedArg::Arg(a) => s.print_generic_arg(a),\n                     ast::AngleBracketedArg::Constraint(c) => s.print_assoc_constraint(c),\n                 });\n-                self.s.word(\">\")\n+                self.word(\">\")\n             }\n \n             ast::GenericArgs::Parenthesized(ref data) => {\n-                self.s.word(\"(\");\n+                self.word(\"(\");\n                 self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(ty));\n-                self.s.word(\")\");\n+                self.word(\")\");\n                 self.print_fn_ret_ty(&data.output);\n             }\n         }\n@@ -925,7 +925,7 @@ impl<'a> State<'a> {\n             op(self, elt);\n             i += 1;\n             if i < len {\n-                self.s.word(\",\");\n+                self.word(\",\");\n                 self.maybe_print_trailing_comment(get_span(elt), Some(get_span(&elts[i]).hi()));\n                 self.space_if_not_bol();\n             }\n@@ -954,7 +954,7 @@ impl<'a> State<'a> {\n     pub fn print_assoc_constraint(&mut self, constraint: &ast::AssocTyConstraint) {\n         self.print_ident(constraint.ident);\n         constraint.gen_args.as_ref().map(|args| self.print_generic_args(args, false));\n-        self.s.space();\n+        self.space();\n         match &constraint.kind {\n             ast::AssocTyConstraintKind::Equality { ty } => {\n                 self.word_space(\"=\");\n@@ -979,27 +979,27 @@ impl<'a> State<'a> {\n         self.ibox(0);\n         match ty.kind {\n             ast::TyKind::Slice(ref ty) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_type(ty);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             ast::TyKind::Ptr(ref mt) => {\n-                self.s.word(\"*\");\n+                self.word(\"*\");\n                 self.print_mt(mt, true);\n             }\n             ast::TyKind::Rptr(ref lifetime, ref mt) => {\n-                self.s.word(\"&\");\n+                self.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n                 self.print_mt(mt, false);\n             }\n             ast::TyKind::Never => {\n-                self.s.word(\"!\");\n+                self.word(\"!\");\n             }\n             ast::TyKind::Tup(ref elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(ty));\n                 if elts.len() == 1 {\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n                 self.pclose();\n             }\n@@ -1023,33 +1023,33 @@ impl<'a> State<'a> {\n                 self.print_type_bounds(\"impl\", &bounds[..]);\n             }\n             ast::TyKind::Array(ref ty, ref length) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_type(ty);\n-                self.s.word(\"; \");\n+                self.word(\"; \");\n                 self.print_expr(&length.value);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             ast::TyKind::Typeof(ref e) => {\n-                self.s.word(\"typeof(\");\n+                self.word(\"typeof(\");\n                 self.print_expr(&e.value);\n-                self.s.word(\")\");\n+                self.word(\")\");\n             }\n             ast::TyKind::Infer => {\n-                self.s.word(\"_\");\n+                self.word(\"_\");\n             }\n             ast::TyKind::Err => {\n                 self.popen();\n-                self.s.word(\"/*ERROR*/\");\n+                self.word(\"/*ERROR*/\");\n                 self.pclose();\n             }\n             ast::TyKind::ImplicitSelf => {\n-                self.s.word(\"Self\");\n+                self.word(\"Self\");\n             }\n             ast::TyKind::MacCall(ref m) => {\n                 self.print_mac(m);\n             }\n             ast::TyKind::CVarArgs => {\n-                self.s.word(\"...\");\n+                self.word(\"...\");\n             }\n         }\n         self.end();\n@@ -1087,7 +1087,7 @@ impl<'a> State<'a> {\n             ast::ForeignItemKind::MacCall(m) => {\n                 self.print_mac(m);\n                 if m.args.need_semicolon() {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n             }\n         }\n@@ -1115,13 +1115,13 @@ impl<'a> State<'a> {\n         self.print_ident(ident);\n         self.word_space(\":\");\n         self.print_type(ty);\n-        self.s.space();\n+        self.space();\n         self.end(); // end the head-ibox\n         if let Some(body) = body {\n             self.word_space(\"=\");\n             self.print_expr(body);\n         }\n-        self.s.word(\";\");\n+        self.word(\";\");\n         self.end(); // end the outer cbox\n     }\n \n@@ -1143,11 +1143,11 @@ impl<'a> State<'a> {\n         self.print_type_bounds(\":\", bounds);\n         self.print_where_clause(&generics.where_clause);\n         if let Some(ty) = ty {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"=\");\n             self.print_type(ty);\n         }\n-        self.s.word(\";\");\n+        self.word(\";\");\n         self.end(); // end inner head-block\n         self.end(); // end outer head-block\n     }\n@@ -1163,19 +1163,19 @@ impl<'a> State<'a> {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name);\n-                    self.s.space();\n-                    self.s.word(\"as\");\n-                    self.s.space();\n+                    self.space();\n+                    self.word(\"as\");\n+                    self.space();\n                 }\n                 self.print_ident(item.ident);\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n             ast::ItemKind::Use(ref tree) => {\n                 self.head(visibility_qualified(&item.vis, \"use\"));\n                 self.print_use_tree(tree);\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n@@ -1218,7 +1218,7 @@ impl<'a> State<'a> {\n                         self.bclose(item.span, empty);\n                     }\n                     ModKind::Unloaded => {\n-                        self.s.word(\";\");\n+                        self.word(\";\");\n                         self.end(); // end inner head-block\n                         self.end(); // end outer head-block\n                     }\n@@ -1289,23 +1289,23 @@ impl<'a> State<'a> {\n \n                 if !generics.params.is_empty() {\n                     self.print_generic_params(&generics.params);\n-                    self.s.space();\n+                    self.space();\n                 }\n \n                 if let ast::ImplPolarity::Negative(_) = polarity {\n-                    self.s.word(\"!\");\n+                    self.word(\"!\");\n                 }\n \n                 if let Some(ref t) = *of_trait {\n                     self.print_trait_ref(t);\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"for\");\n                 }\n \n                 self.print_type(self_ty);\n                 self.print_where_clause(&generics.where_clause);\n \n-                self.s.space();\n+                self.space();\n                 self.bopen();\n                 self.print_inner_attributes(&item.attrs);\n                 for impl_item in items {\n@@ -1332,7 +1332,7 @@ impl<'a> State<'a> {\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n                     if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        self.s.space();\n+                        self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n                     } else {\n@@ -1341,7 +1341,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_type_bounds(\":\", &real_bounds[..]);\n                 self.print_where_clause(&generics.where_clause);\n-                self.s.word(\" \");\n+                self.word(\" \");\n                 self.bopen();\n                 self.print_inner_attributes(&item.attrs);\n                 for trait_item in items {\n@@ -1360,7 +1360,7 @@ impl<'a> State<'a> {\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n                     if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        self.s.space();\n+                        self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n                     } else {\n@@ -1370,12 +1370,12 @@ impl<'a> State<'a> {\n                 self.nbsp();\n                 self.print_type_bounds(\"=\", &real_bounds[..]);\n                 self.print_where_clause(&generics.where_clause);\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n             ast::ItemKind::MacCall(ref mac) => {\n                 self.print_mac(mac);\n                 if mac.args.need_semicolon() {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n             }\n             ast::ItemKind::MacroDef(ref macro_def) => {\n@@ -1393,7 +1393,7 @@ impl<'a> State<'a> {\n \n     fn print_formal_generic_params(&mut self, generic_params: &[ast::GenericParam]) {\n         if !generic_params.is_empty() {\n-            self.s.word(\"for\");\n+            self.word(\"for\");\n             self.print_generic_params(generic_params);\n             self.nbsp();\n         }\n@@ -1416,7 +1416,7 @@ impl<'a> State<'a> {\n         self.print_ident(ident);\n         self.print_generic_params(&generics.params);\n         self.print_where_clause(&generics.where_clause);\n-        self.s.space();\n+        self.space();\n         self.print_variants(&enum_definition.variants, span)\n     }\n \n@@ -1428,7 +1428,7 @@ impl<'a> State<'a> {\n             self.print_outer_attributes(&v.attrs);\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n-            self.s.word(\",\");\n+            self.word(\",\");\n             self.end();\n             self.maybe_print_trailing_comment(v.span, None);\n         }\n@@ -1477,7 +1477,7 @@ impl<'a> State<'a> {\n                 self.print_ident(field.ident.unwrap());\n                 self.word_nbsp(\":\");\n                 self.print_type(&field.ty);\n-                self.s.word(\",\");\n+                self.word(\",\");\n             }\n         }\n \n@@ -1508,7 +1508,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_where_clause(&generics.where_clause);\n                 if print_finalizer {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n                 self.end();\n                 self.end(); // Close the outer-box.\n@@ -1526,7 +1526,7 @@ impl<'a> State<'a> {\n         let generics = ast::Generics::default();\n         self.print_struct(&v.data, &generics, v.ident, v.span, false);\n         if let Some(ref d) = v.disr_expr {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"=\");\n             self.print_expr(&d.value)\n         }\n@@ -1558,7 +1558,7 @@ impl<'a> State<'a> {\n             ast::AssocItemKind::MacCall(m) => {\n                 self.print_mac(m);\n                 if m.args.need_semicolon() {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n             }\n         }\n@@ -1584,36 +1584,36 @@ impl<'a> State<'a> {\n                     if let Some(els) = els {\n                         self.cbox(INDENT_UNIT);\n                         self.ibox(INDENT_UNIT);\n-                        self.s.word(\" else \");\n+                        self.word(\" else \");\n                         self.print_block(els);\n                     }\n                 }\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // `let` ibox\n             }\n             ast::StmtKind::Item(ref item) => self.print_item(item),\n             ast::StmtKind::Expr(ref expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr_outer_attr_style(expr, false);\n                 if classify::expr_requires_semi_to_be_stmt(expr) {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n             }\n             ast::StmtKind::Semi(ref expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr_outer_attr_style(expr, false);\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n             ast::StmtKind::Empty => {\n                 self.space_if_not_bol();\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n             ast::StmtKind::MacCall(ref mac) => {\n                 self.space_if_not_bol();\n                 self.print_outer_attributes(&mac.attrs);\n                 self.print_mac(&mac.mac);\n                 if mac.style == ast::MacStmtStyle::Semicolon {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n             }\n         }\n@@ -1667,9 +1667,9 @@ impl<'a> State<'a> {\n \n     /// Print a `let pat = expr` expression.\n     crate fn print_let(&mut self, pat: &ast::Pat, expr: &ast::Expr) {\n-        self.s.word(\"let \");\n+        self.word(\"let \");\n         self.print_pat(pat);\n-        self.s.space();\n+        self.space();\n         self.word_space(\"=\");\n         let npals = || parser::needs_par_as_let_scrutinee(expr.precedence().order());\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n@@ -1682,17 +1682,17 @@ impl<'a> State<'a> {\n                 ast::ExprKind::If(ref i, ref then, ref e) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n-                    self.s.word(\" else if \");\n+                    self.word(\" else if \");\n                     self.print_expr_as_cond(i);\n-                    self.s.space();\n+                    self.space();\n                     self.print_block(then);\n                     self.print_else(e.as_deref())\n                 }\n                 // Final `else` block.\n                 ast::ExprKind::Block(ref b, _) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n-                    self.s.word(\" else \");\n+                    self.word(\" else \");\n                     self.print_block(b)\n                 }\n                 // Constraints would be great here!\n@@ -1706,7 +1706,7 @@ impl<'a> State<'a> {\n     crate fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block, elseopt: Option<&ast::Expr>) {\n         self.head(\"if\");\n         self.print_expr_as_cond(test);\n-        self.s.space();\n+        self.space();\n         self.print_block(blk);\n         self.print_else(elseopt)\n     }\n@@ -1763,26 +1763,26 @@ impl<'a> State<'a> {\n \n     fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word(\"[\");\n+        self.word(\"[\");\n         self.commasep_exprs(Inconsistent, exprs);\n-        self.s.word(\"]\");\n+        self.word(\"]\");\n         self.end();\n     }\n \n     fn print_expr_anon_const(&mut self, expr: &ast::AnonConst) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word(\"const\");\n+        self.word(\"const\");\n         self.print_expr(&expr.value);\n         self.end();\n     }\n \n     fn print_expr_repeat(&mut self, element: &ast::Expr, count: &ast::AnonConst) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word(\"[\");\n+        self.word(\"[\");\n         self.print_expr(element);\n         self.word_space(\";\");\n         self.print_expr(&count.value);\n-        self.s.word(\"]\");\n+        self.word(\"]\");\n         self.end();\n     }\n \n@@ -1798,7 +1798,7 @@ impl<'a> State<'a> {\n         } else {\n             self.print_path(path, true, 0);\n         }\n-        self.s.word(\"{\");\n+        self.word(\"{\");\n         self.commasep_cmnt(\n             Consistent,\n             fields,\n@@ -1818,26 +1818,26 @@ impl<'a> State<'a> {\n             ast::StructRest::Base(_) | ast::StructRest::Rest(_) => {\n                 self.ibox(INDENT_UNIT);\n                 if !fields.is_empty() {\n-                    self.s.word(\",\");\n-                    self.s.space();\n+                    self.word(\",\");\n+                    self.space();\n                 }\n-                self.s.word(\"..\");\n+                self.word(\"..\");\n                 if let ast::StructRest::Base(ref expr) = *rest {\n                     self.print_expr(expr);\n                 }\n                 self.end();\n             }\n-            ast::StructRest::None if !fields.is_empty() => self.s.word(\",\"),\n+            ast::StructRest::None if !fields.is_empty() => self.word(\",\"),\n             _ => {}\n         }\n-        self.s.word(\"}\");\n+        self.word(\"}\");\n     }\n \n     fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) {\n         self.popen();\n         self.commasep_exprs(Inconsistent, exprs);\n         if exprs.len() == 1 {\n-            self.s.word(\",\");\n+            self.word(\",\");\n         }\n         self.pclose()\n     }\n@@ -1855,7 +1855,7 @@ impl<'a> State<'a> {\n     fn print_expr_method_call(&mut self, segment: &ast::PathSegment, args: &[P<ast::Expr>]) {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n-        self.s.word(\".\");\n+        self.word(\".\");\n         self.print_ident(segment.ident);\n         if let Some(ref args) = segment.args {\n             self.print_generic_args(args, true);\n@@ -1896,13 +1896,13 @@ impl<'a> State<'a> {\n         };\n \n         self.print_expr_maybe_paren(lhs, left_prec);\n-        self.s.space();\n+        self.space();\n         self.word_space(op.node.to_string());\n         self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n     fn print_expr_unary(&mut self, op: ast::UnOp, expr: &ast::Expr) {\n-        self.s.word(ast::UnOp::to_string(op));\n+        self.word(ast::UnOp::to_string(op));\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n@@ -1912,7 +1912,7 @@ impl<'a> State<'a> {\n         mutability: ast::Mutability,\n         expr: &ast::Expr,\n     ) {\n-        self.s.word(\"&\");\n+        self.word(\"&\");\n         match kind {\n             ast::BorrowKind::Ref => self.print_mutability(mutability, false),\n             ast::BorrowKind::Raw => {\n@@ -1980,7 +1980,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Cast(ref expr, ref ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(expr, prec);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"as\");\n                 self.print_type(ty);\n             }\n@@ -2003,7 +2003,7 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"while\");\n                 self.print_expr_as_cond(test);\n-                self.s.space();\n+                self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n             ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n@@ -2013,10 +2013,10 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"for\");\n                 self.print_pat(pat);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"in\");\n                 self.print_expr_as_cond(iter);\n-                self.s.space();\n+                self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n             ast::ExprKind::Loop(ref blk, opt_label) => {\n@@ -2032,7 +2032,7 @@ impl<'a> State<'a> {\n                 self.ibox(INDENT_UNIT);\n                 self.word_nbsp(\"match\");\n                 self.print_expr_as_cond(expr);\n-                self.s.space();\n+                self.space();\n                 self.bopen();\n                 self.print_inner_attributes_no_trailing_hardbreak(attrs);\n                 for arm in arms {\n@@ -2054,7 +2054,7 @@ impl<'a> State<'a> {\n                 self.print_capture_clause(capture_clause);\n \n                 self.print_fn_params_and_ret(decl, true);\n-                self.s.space();\n+                self.space();\n                 self.print_expr(body);\n                 self.end(); // need to close a box\n \n@@ -2084,33 +2084,33 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::Await(ref expr) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.s.word(\".await\");\n+                self.word(\".await\");\n             }\n             ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(rhs, prec);\n             }\n             ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n-                self.s.space();\n-                self.s.word(op.node.to_string());\n+                self.space();\n+                self.word(op.node.to_string());\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(rhs, prec);\n             }\n             ast::ExprKind::Field(ref expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.s.word(\".\");\n+                self.word(\".\");\n                 self.print_ident(ident);\n             }\n             ast::ExprKind::Index(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_expr(index);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             ast::ExprKind::Range(ref start, ref end, limits) => {\n                 // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n@@ -2122,41 +2122,41 @@ impl<'a> State<'a> {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n                 if limits == ast::RangeLimits::HalfOpen {\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                 } else {\n-                    self.s.word(\"..=\");\n+                    self.word(\"..=\");\n                 }\n                 if let Some(ref e) = *end {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n             }\n-            ast::ExprKind::Underscore => self.s.word(\"_\"),\n+            ast::ExprKind::Underscore => self.word(\"_\"),\n             ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n             ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n             ast::ExprKind::Break(opt_label, ref opt_expr) => {\n-                self.s.word(\"break\");\n-                self.s.space();\n+                self.word(\"break\");\n+                self.space();\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n-                    self.s.space();\n+                    self.space();\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                    self.s.space();\n+                    self.space();\n                 }\n             }\n             ast::ExprKind::Continue(opt_label) => {\n-                self.s.word(\"continue\");\n-                self.s.space();\n+                self.word(\"continue\");\n+                self.space();\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n-                    self.s.space()\n+                    self.space()\n                 }\n             }\n             ast::ExprKind::Ret(ref result) => {\n-                self.s.word(\"return\");\n+                self.word(\"return\");\n                 if let Some(ref expr) = *result {\n-                    self.s.word(\" \");\n+                    self.word(\" \");\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n@@ -2165,7 +2165,7 @@ impl<'a> State<'a> {\n                 self.print_inline_asm(a);\n             }\n             ast::ExprKind::LlvmInlineAsm(ref a) => {\n-                self.s.word(\"llvm_asm!\");\n+                self.word(\"llvm_asm!\");\n                 self.popen();\n                 self.print_symbol(a.asm, a.asm_str_style);\n                 self.word_space(\":\");\n@@ -2183,7 +2183,7 @@ impl<'a> State<'a> {\n                     s.print_expr(&out.expr);\n                     s.pclose();\n                 });\n-                self.s.space();\n+                self.space();\n                 self.word_space(\":\");\n \n                 self.commasep(Inconsistent, &a.inputs, |s, &(co, ref o)| {\n@@ -2192,7 +2192,7 @@ impl<'a> State<'a> {\n                     s.print_expr(o);\n                     s.pclose();\n                 });\n-                self.s.space();\n+                self.space();\n                 self.word_space(\":\");\n \n                 self.commasep(Inconsistent, &a.clobbers, |s, &co| {\n@@ -2211,7 +2211,7 @@ impl<'a> State<'a> {\n                 }\n \n                 if !options.is_empty() {\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\":\");\n                     self.commasep(Inconsistent, &options, |s, &co| {\n                         s.print_string(co, ast::StrStyle::Cooked);\n@@ -2227,25 +2227,25 @@ impl<'a> State<'a> {\n                 self.pclose();\n             }\n             ast::ExprKind::Yield(ref e) => {\n-                self.s.word(\"yield\");\n+                self.word(\"yield\");\n \n                 if let Some(ref expr) = *e {\n-                    self.s.space();\n+                    self.space();\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n             ast::ExprKind::Try(ref e) => {\n                 self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n-                self.s.word(\"?\")\n+                self.word(\"?\")\n             }\n             ast::ExprKind::TryBlock(ref blk) => {\n                 self.head(\"try\");\n-                self.s.space();\n+                self.space();\n                 self.print_block_with_attrs(blk, attrs)\n             }\n             ast::ExprKind::Err => {\n                 self.popen();\n-                self.s.word(\"/*ERROR*/\");\n+                self.word(\"/*ERROR*/\");\n                 self.pclose()\n             }\n         }\n@@ -2387,22 +2387,22 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_name(&mut self, name: Symbol) {\n-        self.s.word(name.to_string());\n+        self.word(name.to_string());\n         self.ann.post(self, AnnNode::Name(&name))\n     }\n \n     fn print_qpath(&mut self, path: &ast::Path, qself: &ast::QSelf, colons_before_params: bool) {\n-        self.s.word(\"<\");\n+        self.word(\"<\");\n         self.print_type(&qself.ty);\n         if qself.position > 0 {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"as\");\n             let depth = path.segments.len() - qself.position;\n             self.print_path(path, false, depth);\n         }\n-        self.s.word(\">\");\n+        self.word(\">\");\n         for item_segment in &path.segments[qself.position..] {\n-            self.s.word(\"::\");\n+            self.word(\"::\");\n             self.print_ident(item_segment.ident);\n             if let Some(ref args) = item_segment.args {\n                 self.print_generic_args(args, colons_before_params)\n@@ -2416,7 +2416,7 @@ impl<'a> State<'a> {\n         /* Pat isn't normalized, but the beauty of it\n         is that it doesn't matter */\n         match pat.kind {\n-            PatKind::Wild => self.s.word(\"_\"),\n+            PatKind::Wild => self.word(\"_\"),\n             PatKind::Ident(binding_mode, ident, ref sub) => {\n                 match binding_mode {\n                     ast::BindingMode::ByRef(mutbl) => {\n@@ -2430,8 +2430,8 @@ impl<'a> State<'a> {\n                 }\n                 self.print_ident(ident);\n                 if let Some(ref p) = *sub {\n-                    self.s.space();\n-                    self.s.word_space(\"@\");\n+                    self.space();\n+                    self.word_space(\"@\");\n                     self.print_pat(p);\n                 }\n             }\n@@ -2480,27 +2480,27 @@ impl<'a> State<'a> {\n                     if !fields.is_empty() {\n                         self.word_space(\",\");\n                     }\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                 }\n-                self.s.space();\n-                self.s.word(\"}\");\n+                self.space();\n+                self.word(\"}\");\n             }\n             PatKind::Tuple(ref elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n                 if elts.len() == 1 {\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n                 self.pclose();\n             }\n             PatKind::Box(ref inner) => {\n-                self.s.word(\"box \");\n+                self.word(\"box \");\n                 self.print_pat(inner);\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                self.s.word(\"&\");\n+                self.word(\"&\");\n                 if mutbl == ast::Mutability::Mut {\n-                    self.s.word(\"mut \");\n+                    self.word(\"mut \");\n                 }\n                 if let PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Mut), ..) =\n                     inner.kind\n@@ -2516,23 +2516,23 @@ impl<'a> State<'a> {\n             PatKind::Range(ref begin, ref end, Spanned { node: ref end_kind, .. }) => {\n                 if let Some(e) = begin {\n                     self.print_expr(e);\n-                    self.s.space();\n+                    self.space();\n                 }\n                 match *end_kind {\n-                    RangeEnd::Included(RangeSyntax::DotDotDot) => self.s.word(\"...\"),\n-                    RangeEnd::Included(RangeSyntax::DotDotEq) => self.s.word(\"..=\"),\n-                    RangeEnd::Excluded => self.s.word(\"..\"),\n+                    RangeEnd::Included(RangeSyntax::DotDotDot) => self.word(\"...\"),\n+                    RangeEnd::Included(RangeSyntax::DotDotEq) => self.word(\"..=\"),\n+                    RangeEnd::Excluded => self.word(\"..\"),\n                 }\n                 if let Some(e) = end {\n                     self.print_expr(e);\n                 }\n             }\n             PatKind::Slice(ref elts) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n-            PatKind::Rest => self.s.word(\"..\"),\n+            PatKind::Rest => self.word(\"..\"),\n             PatKind::Paren(ref inner) => {\n                 self.popen();\n                 self.print_pat(inner);\n@@ -2546,18 +2546,18 @@ impl<'a> State<'a> {\n     fn print_arm(&mut self, arm: &ast::Arm) {\n         // Note, I have no idea why this check is necessary, but here it is.\n         if arm.attrs.is_empty() {\n-            self.s.space();\n+            self.space();\n         }\n         self.cbox(INDENT_UNIT);\n         self.ibox(0);\n         self.maybe_print_comment(arm.pat.span.lo());\n         self.print_outer_attributes(&arm.attrs);\n         self.print_pat(&arm.pat);\n-        self.s.space();\n+        self.space();\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\");\n             self.print_expr(e);\n-            self.s.space();\n+            self.space();\n         }\n         self.word_space(\"=>\");\n \n@@ -2573,13 +2573,13 @@ impl<'a> State<'a> {\n \n                 // If it is a user-provided unsafe block, print a comma after it.\n                 if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n             }\n             _ => {\n                 self.end(); // Close the ibox for the pattern.\n                 self.print_expr(&arm.body);\n-                self.s.word(\",\");\n+                self.word(\",\");\n             }\n         }\n         self.end(); // Close enclosing cbox.\n@@ -2589,17 +2589,17 @@ impl<'a> State<'a> {\n         match explicit_self.node {\n             SelfKind::Value(m) => {\n                 self.print_mutability(m, false);\n-                self.s.word(\"self\")\n+                self.word(\"self\")\n             }\n             SelfKind::Region(ref lt, m) => {\n-                self.s.word(\"&\");\n+                self.word(\"&\");\n                 self.print_opt_lifetime(lt);\n                 self.print_mutability(m, false);\n-                self.s.word(\"self\")\n+                self.word(\"self\")\n             }\n             SelfKind::Explicit(ref typ, m) => {\n                 self.print_mutability(m, false);\n-                self.s.word(\"self\");\n+                self.word(\"self\");\n                 self.word_space(\":\");\n                 self.print_type(typ)\n             }\n@@ -2626,7 +2626,7 @@ impl<'a> State<'a> {\n             self.nbsp();\n             self.print_block_with_attrs(body, attrs);\n         } else {\n-            self.s.word(\";\");\n+            self.word(\";\");\n         }\n     }\n \n@@ -2677,7 +2677,7 @@ impl<'a> State<'a> {\n \n     pub fn print_type_bounds(&mut self, prefix: &'static str, bounds: &[ast::GenericBound]) {\n         if !bounds.is_empty() {\n-            self.s.word(prefix);\n+            self.word(prefix);\n             let mut first = true;\n             for bound in bounds {\n                 if !(first && prefix.is_empty()) {\n@@ -2692,7 +2692,7 @@ impl<'a> State<'a> {\n                 match bound {\n                     GenericBound::Trait(tref, modifier) => {\n                         if modifier == &TraitBoundModifier::Maybe {\n-                            self.s.word(\"?\");\n+                            self.word(\"?\");\n                         }\n                         self.print_poly_trait_ref(tref);\n                     }\n@@ -2713,10 +2713,10 @@ impl<'a> State<'a> {\n     ) {\n         self.print_lifetime(lifetime);\n         if !bounds.is_empty() {\n-            self.s.word(\": \");\n+            self.word(\": \");\n             for (i, bound) in bounds.iter().enumerate() {\n                 if i != 0 {\n-                    self.s.word(\" + \");\n+                    self.word(\" + \");\n                 }\n                 match bound {\n                     ast::GenericBound::Outlives(lt) => self.print_lifetime(*lt),\n@@ -2731,7 +2731,7 @@ impl<'a> State<'a> {\n             return;\n         }\n \n-        self.s.word(\"<\");\n+        self.word(\"<\");\n \n         self.commasep(Inconsistent, &generic_params, |s, param| {\n             s.print_outer_attributes_inline(&param.attrs);\n@@ -2745,36 +2745,36 @@ impl<'a> State<'a> {\n                     s.print_ident(param.ident);\n                     s.print_type_bounds(\":\", &param.bounds);\n                     if let Some(ref default) = default {\n-                        s.s.space();\n+                        s.space();\n                         s.word_space(\"=\");\n                         s.print_type(default)\n                     }\n                 }\n                 ast::GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n                     s.word_space(\"const\");\n                     s.print_ident(param.ident);\n-                    s.s.space();\n+                    s.space();\n                     s.word_space(\":\");\n                     s.print_type(ty);\n                     s.print_type_bounds(\":\", &param.bounds);\n                     if let Some(ref default) = default {\n-                        s.s.space();\n+                        s.space();\n                         s.word_space(\"=\");\n                         s.print_expr(&default.value);\n                     }\n                 }\n             }\n         });\n \n-        self.s.word(\">\");\n+        self.word(\">\");\n     }\n \n     crate fn print_where_clause(&mut self, where_clause: &ast::WhereClause) {\n         if where_clause.predicates.is_empty() && !where_clause.has_where_token {\n             return;\n         }\n \n-        self.s.space();\n+        self.space();\n         self.word_space(\"where\");\n \n         for (i, predicate) in where_clause.predicates.iter().enumerate() {\n@@ -2806,7 +2806,7 @@ impl<'a> State<'a> {\n                     ..\n                 }) => {\n                     self.print_type(lhs_ty);\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"=\");\n                     self.print_type(rhs_ty);\n                 }\n@@ -2819,29 +2819,29 @@ impl<'a> State<'a> {\n             ast::UseTreeKind::Simple(rename, ..) => {\n                 self.print_path(&tree.prefix, false, 0);\n                 if let Some(rename) = rename {\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"as\");\n                     self.print_ident(rename);\n                 }\n             }\n             ast::UseTreeKind::Glob => {\n                 if !tree.prefix.segments.is_empty() {\n                     self.print_path(&tree.prefix, false, 0);\n-                    self.s.word(\"::\");\n+                    self.word(\"::\");\n                 }\n-                self.s.word(\"*\");\n+                self.word(\"*\");\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 if tree.prefix.segments.is_empty() {\n-                    self.s.word(\"{\");\n+                    self.word(\"{\");\n                 } else {\n                     self.print_path(&tree.prefix, false, 0);\n-                    self.s.word(\"::{\");\n+                    self.word(\"::{\");\n                 }\n                 self.commasep(Inconsistent, &items[..], |this, &(ref tree, _)| {\n                     this.print_use_tree(tree)\n                 });\n-                self.s.word(\"}\");\n+                self.word(\"}\");\n             }\n         }\n     }\n@@ -2880,8 +2880,8 @@ impl<'a> State<'a> {\n                     };\n                     if !invalid {\n                         self.print_pat(&input.pat);\n-                        self.s.word(\":\");\n-                        self.s.space();\n+                        self.word(\":\");\n+                        self.space();\n                     }\n                     self.print_type(&input.ty);\n                 }\n@@ -2911,7 +2911,7 @@ impl<'a> State<'a> {\n     ) {\n         self.ibox(INDENT_UNIT);\n         if !generic_params.is_empty() {\n-            self.s.word(\"for\");\n+            self.word(\"for\");\n             self.print_generic_params(generic_params);\n         }\n         let generics = ast::Generics {\n@@ -2945,7 +2945,7 @@ impl<'a> State<'a> {\n             }\n         }\n \n-        self.s.word(\"fn\")\n+        self.word(\"fn\")\n     }\n \n     crate fn print_unsafety(&mut self, s: ast::Unsafe) {"}, {"sha": "d46950ed90315c24f2d87d7c7fa6ecabbe7ac0ec", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -7,14 +7,15 @@ use rustc_hir::{self as hir, def_id::DefId, definitions::DefPathData};\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_middle::mir;\n+use rustc_middle::mir::interpret::{InterpError, InvalidProgramInfo};\n use rustc_middle::ty::layout::{self, LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::{\n     self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_mir_dataflow::storage::AlwaysLiveLocals;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::Limit;\n-use rustc_span::{Pos, Span};\n+use rustc_span::{Pos, Span, DUMMY_SP};\n use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n@@ -508,7 +509,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub(super) fn subst_from_current_frame_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n         &self,\n         value: T,\n-    ) -> T {\n+    ) -> Result<T, InterpError<'tcx>> {\n         self.subst_from_frame_and_normalize_erasing_regions(self.frame(), value)\n     }\n \n@@ -518,8 +519,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         value: T,\n-    ) -> T {\n-        frame.instance.subst_mir_and_normalize_erasing_regions(*self.tcx, self.param_env, value)\n+    ) -> Result<T, InterpError<'tcx>> {\n+        frame\n+            .instance\n+            .try_subst_mir_and_normalize_erasing_regions(*self.tcx, self.param_env, value)\n+            .or_else(|e| {\n+                self.tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\"failed to normalize {}\", e.get_type_for_failure()).as_str(),\n+                );\n+\n+                Err(InterpError::InvalidProgram(InvalidProgramInfo::TooGeneric))\n+            })\n     }\n \n     /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env).\n@@ -554,7 +565,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let layout = from_known_layout(self.tcx, self.param_env, layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty =\n-                        self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty);\n+                        self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty)?;\n                     self.layout_of(local_ty)\n                 })?;\n                 if let Some(state) = frame.locals.get(local) {\n@@ -702,7 +713,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         for const_ in &body.required_consts {\n             let span = const_.span;\n             let const_ =\n-                self.subst_from_current_frame_and_normalize_erasing_regions(const_.literal);\n+                self.subst_from_current_frame_and_normalize_erasing_regions(const_.literal)?;\n             self.mir_const_to_op(&const_, None).map_err(|err| {\n                 // If there was an error, set the span of the current frame to this constant.\n                 // Avoiding doing this when evaluation succeeds."}, {"sha": "e82ce73c814ff1a65f9aae47b180b1f61c1d326d", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -512,7 +512,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.param_env,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n                 place.ty(&self.frame().body.local_decls, *self.tcx).ty\n-            ))?,\n+            )?)?,\n             op.layout,\n         ));\n         Ok(op)\n@@ -534,7 +534,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Constant(ref constant) => {\n                 let val =\n-                    self.subst_from_current_frame_and_normalize_erasing_regions(constant.literal);\n+                    self.subst_from_current_frame_and_normalize_erasing_regions(constant.literal)?;\n                 // This can still fail:\n                 // * During ConstProp, with `TooGeneric` or since the `requried_consts` were not all\n                 //   checked yet."}, {"sha": "4c95da896a2230a11d6793e3bf18e468d12a0173", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -643,7 +643,7 @@ where\n             self.param_env,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n                 place.ty(&self.frame().body.local_decls, *self.tcx).ty\n-            ))?,\n+            )?)?,\n             place_ty.layout,\n         ));\n         Ok(place_ty)"}, {"sha": "992cef1cb6aa0cb8151138beeea64c094f4b4839", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -276,7 +276,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             NullaryOp(null_op, ty) => {\n-                let ty = self.subst_from_current_frame_and_normalize_erasing_regions(ty);\n+                let ty = self.subst_from_current_frame_and_normalize_erasing_regions(ty)?;\n                 let layout = self.layout_of(ty)?;\n                 if layout.is_unsized() {\n                     // FIXME: This should be a span_bug (#80742)\n@@ -302,7 +302,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Cast(cast_kind, ref operand, cast_ty) => {\n                 let src = self.eval_operand(operand, None)?;\n-                let cast_ty = self.subst_from_current_frame_and_normalize_erasing_regions(cast_ty);\n+                let cast_ty =\n+                    self.subst_from_current_frame_and_normalize_erasing_regions(cast_ty)?;\n                 self.cast(&src, cast_kind, cast_ty, &dest)?;\n             }\n "}, {"sha": "4240a4045a1ec7c2ef151c943f31430c18161286", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 177, "deletions": 177, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -89,7 +89,7 @@ impl<'a> State<'a> {\n             Node::TraitRef(a) => self.print_trait_ref(&a),\n             Node::Binding(a) | Node::Pat(a) => self.print_pat(&a),\n             Node::Arm(a) => self.print_arm(&a),\n-            Node::Infer(_) => self.s.word(\"_\"),\n+            Node::Infer(_) => self.word(\"_\"),\n             Node::Block(a) => {\n                 // Containing cbox, will be closed by print-block at `}`.\n                 self.cbox(INDENT_UNIT);\n@@ -130,7 +130,7 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n \n     fn print_ident(&mut self, ident: Ident) {\n-        self.s.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n+        self.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n         self.ann.post(self, AnnNode::Name(&ident.name))\n     }\n \n@@ -194,7 +194,7 @@ where\n pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility<'_>, w: S) -> String {\n     to_string(NO_ANN, |s| {\n         s.print_visibility(vis);\n-        s.s.word(w)\n+        s.word(w)\n     })\n }\n \n@@ -244,7 +244,7 @@ impl<'a> State<'a> {\n     pub fn bclose_maybe_open(&mut self, span: rustc_span::Span, close_box: bool) {\n         self.maybe_print_comment(span.hi());\n         self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n-        self.s.word(\"}\");\n+        self.word(\"}\");\n         if close_box {\n             self.end(); // close the outer-box\n         }\n@@ -267,7 +267,7 @@ impl<'a> State<'a> {\n             op(self, elt);\n             i += 1;\n             if i < len {\n-                self.s.word(\",\");\n+                self.word(\",\");\n                 self.maybe_print_trailing_comment(get_span(elt), Some(get_span(&elts[i]).hi()));\n                 self.space_if_not_bol();\n             }\n@@ -298,27 +298,27 @@ impl<'a> State<'a> {\n         self.ibox(0);\n         match ty.kind {\n             hir::TyKind::Slice(ref ty) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_type(&ty);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             hir::TyKind::Ptr(ref mt) => {\n-                self.s.word(\"*\");\n+                self.word(\"*\");\n                 self.print_mt(mt, true);\n             }\n             hir::TyKind::Rptr(ref lifetime, ref mt) => {\n-                self.s.word(\"&\");\n+                self.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n                 self.print_mt(mt, false);\n             }\n             hir::TyKind::Never => {\n-                self.s.word(\"!\");\n+                self.word(\"!\");\n             }\n             hir::TyKind::Tup(ref elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&ty));\n                 if elts.len() == 1 {\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n                 self.pclose();\n             }\n@@ -332,7 +332,7 @@ impl<'a> State<'a> {\n                     f.param_names,\n                 );\n             }\n-            hir::TyKind::OpaqueDef(..) => self.s.word(\"/*impl Trait*/\"),\n+            hir::TyKind::OpaqueDef(..) => self.word(\"/*impl Trait*/\"),\n             hir::TyKind::Path(ref qpath) => self.print_qpath(qpath, false),\n             hir::TyKind::TraitObject(bounds, ref lifetime, syntax) => {\n                 if syntax == ast::TraitObjectSyntax::Dyn {\n@@ -355,24 +355,24 @@ impl<'a> State<'a> {\n                 }\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_type(&ty);\n-                self.s.word(\"; \");\n+                self.word(\"; \");\n                 self.print_anon_const(length);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             hir::TyKind::Typeof(ref e) => {\n-                self.s.word(\"typeof(\");\n+                self.word(\"typeof(\");\n                 self.print_anon_const(e);\n-                self.s.word(\")\");\n+                self.word(\")\");\n             }\n             hir::TyKind::Err => {\n                 self.popen();\n-                self.s.word(\"/*ERROR*/\");\n+                self.word(\"/*ERROR*/\");\n                 self.pclose();\n             }\n             hir::TyKind::Infer => {\n-                self.s.word(\"_\");\n+                self.word(\"_\");\n             }\n         }\n         self.end()\n@@ -400,7 +400,7 @@ impl<'a> State<'a> {\n                     None,\n                 );\n                 self.end(); // end head-ibox\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemKind::Static(ref t, m) => {\n@@ -411,14 +411,14 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n                 self.print_type(&t);\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end the head-ibox\n                 self.end() // end the outer cbox\n             }\n             hir::ForeignItemKind::Type => {\n                 self.head(visibility_qualified(&item.vis, \"type\"));\n                 self.print_ident(item.ident);\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end the head-ibox\n                 self.end() // end the outer cbox\n             }\n@@ -432,17 +432,17 @@ impl<'a> State<'a> {\n         default: Option<hir::BodyId>,\n         vis: &hir::Visibility<'_>,\n     ) {\n-        self.s.word(visibility_qualified(vis, \"\"));\n+        self.word(visibility_qualified(vis, \"\"));\n         self.word_space(\"const\");\n         self.print_ident(ident);\n         self.word_space(\":\");\n         self.print_type(ty);\n         if let Some(expr) = default {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"=\");\n             self.ann.nested(self, Nested::Body(expr));\n         }\n-        self.s.word(\";\")\n+        self.word(\";\")\n     }\n \n     fn print_associated_type(\n@@ -460,11 +460,11 @@ impl<'a> State<'a> {\n         }\n         self.print_where_clause(&generics.where_clause);\n         if let Some(ty) = ty {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"=\");\n             self.print_type(ty);\n         }\n-        self.s.word(\";\")\n+        self.word(\";\")\n     }\n \n     fn print_item_type(\n@@ -479,9 +479,9 @@ impl<'a> State<'a> {\n         self.end(); // end the inner ibox\n \n         self.print_where_clause(&generics.where_clause);\n-        self.s.space();\n+        self.space();\n         inner(self);\n-        self.s.word(\";\");\n+        self.word(\";\");\n         self.end(); // end the outer ibox\n     }\n \n@@ -497,12 +497,12 @@ impl<'a> State<'a> {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name);\n-                    self.s.space();\n-                    self.s.word(\"as\");\n-                    self.s.space();\n+                    self.space();\n+                    self.word(\"as\");\n+                    self.space();\n                 }\n                 self.print_ident(item.ident);\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n@@ -513,14 +513,14 @@ impl<'a> State<'a> {\n                 match kind {\n                     hir::UseKind::Single => {\n                         if path.segments.last().unwrap().ident != item.ident {\n-                            self.s.space();\n+                            self.space();\n                             self.word_space(\"as\");\n                             self.print_ident(item.ident);\n                         }\n-                        self.s.word(\";\");\n+                        self.word(\";\");\n                     }\n-                    hir::UseKind::Glob => self.s.word(\"::*;\"),\n-                    hir::UseKind::ListStem => self.s.word(\"::{};\"),\n+                    hir::UseKind::Glob => self.word(\"::*;\"),\n+                    hir::UseKind::ListStem => self.word(\"::{};\"),\n                 }\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n@@ -533,25 +533,25 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n                 self.print_type(&ty);\n-                self.s.space();\n+                self.space();\n                 self.end(); // end the head-ibox\n \n                 self.word_space(\"=\");\n                 self.ann.nested(self, Nested::Body(expr));\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end the outer cbox\n             }\n             hir::ItemKind::Const(ref ty, expr) => {\n                 self.head(visibility_qualified(&item.vis, \"const\"));\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n                 self.print_type(&ty);\n-                self.s.space();\n+                self.space();\n                 self.end(); // end the head-ibox\n \n                 self.word_space(\"=\");\n                 self.ann.nested(self, Nested::Body(expr));\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end the outer cbox\n             }\n             hir::ItemKind::Fn(ref sig, ref param_names, body) => {\n@@ -565,7 +565,7 @@ impl<'a> State<'a> {\n                     &[],\n                     Some(body),\n                 );\n-                self.s.word(\" \");\n+                self.word(\" \");\n                 self.end(); // need to close a box\n                 self.end(); // need to close a box\n                 self.ann.nested(self, Nested::Body(body));\n@@ -609,7 +609,7 @@ impl<'a> State<'a> {\n                     let mut real_bounds = Vec::with_capacity(opaque_ty.bounds.len());\n                     for b in opaque_ty.bounds.iter() {\n                         if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n-                            state.s.space();\n+                            state.space();\n                             state.word_space(\"for ?\");\n                             state.print_trait_ref(&ptr.trait_ref);\n                         } else {\n@@ -649,27 +649,27 @@ impl<'a> State<'a> {\n \n                 if !generics.params.is_empty() {\n                     self.print_generic_params(&generics.params);\n-                    self.s.space();\n+                    self.space();\n                 }\n \n                 if constness == hir::Constness::Const {\n                     self.word_nbsp(\"const\");\n                 }\n \n                 if let hir::ImplPolarity::Negative(_) = polarity {\n-                    self.s.word(\"!\");\n+                    self.word(\"!\");\n                 }\n \n                 if let Some(ref t) = of_trait {\n                     self.print_trait_ref(t);\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"for\");\n                 }\n \n                 self.print_type(&self_ty);\n                 self.print_where_clause(&generics.where_clause);\n \n-                self.s.space();\n+                self.space();\n                 self.bopen();\n                 self.print_inner_attributes(attrs);\n                 for impl_item in items {\n@@ -688,7 +688,7 @@ impl<'a> State<'a> {\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n                     if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n-                        self.s.space();\n+                        self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n                     } else {\n@@ -697,7 +697,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_bounds(\":\", real_bounds);\n                 self.print_where_clause(&generics.where_clause);\n-                self.s.word(\" \");\n+                self.word(\" \");\n                 self.bopen();\n                 for trait_item in trait_items {\n                     self.ann.nested(self, Nested::TraitItem(trait_item.id));\n@@ -714,7 +714,7 @@ impl<'a> State<'a> {\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n                     if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n-                        self.s.space();\n+                        self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n                     } else {\n@@ -724,7 +724,7 @@ impl<'a> State<'a> {\n                 self.nbsp();\n                 self.print_bounds(\"=\", real_bounds);\n                 self.print_where_clause(&generics.where_clause);\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n         }\n         self.ann.post(self, AnnNode::Item(item))\n@@ -736,7 +736,7 @@ impl<'a> State<'a> {\n \n     fn print_formal_generic_params(&mut self, generic_params: &[hir::GenericParam<'_>]) {\n         if !generic_params.is_empty() {\n-            self.s.word(\"for\");\n+            self.word(\"for\");\n             self.print_generic_params(generic_params);\n             self.nbsp();\n         }\n@@ -759,7 +759,7 @@ impl<'a> State<'a> {\n         self.print_name(name);\n         self.print_generic_params(&generics.params);\n         self.print_where_clause(&generics.where_clause);\n-        self.s.space();\n+        self.space();\n         self.print_variants(&enum_definition.variants, span)\n     }\n \n@@ -771,7 +771,7 @@ impl<'a> State<'a> {\n             self.print_outer_attributes(self.attrs(v.id));\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n-            self.s.word(\",\");\n+            self.word(\",\");\n             self.end();\n             self.maybe_print_trailing_comment(v.span, None);\n         }\n@@ -784,10 +784,10 @@ impl<'a> State<'a> {\n             hir::VisibilityKind::Crate(ast::CrateSugar::JustCrate) => self.word_nbsp(\"crate\"),\n             hir::VisibilityKind::Crate(ast::CrateSugar::PubCrate) => self.word_nbsp(\"pub(crate)\"),\n             hir::VisibilityKind::Restricted { ref path, .. } => {\n-                self.s.word(\"pub(\");\n+                self.word(\"pub(\");\n                 if path.segments.len() == 1 && path.segments[0].ident.name == kw::Super {\n                     // Special case: `super` can print like `pub(super)`.\n-                    self.s.word(\"super\");\n+                    self.word(\"super\");\n                 } else {\n                     // Everything else requires `in` at present.\n                     self.word_nbsp(\"in\");\n@@ -830,7 +830,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_where_clause(&generics.where_clause);\n                 if print_finalizer {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n                 self.end();\n                 self.end() // close the outer-box\n@@ -849,7 +849,7 @@ impl<'a> State<'a> {\n                     self.print_ident(field.ident);\n                     self.word_nbsp(\":\");\n                     self.print_type(&field.ty);\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n \n                 self.bclose(span)\n@@ -862,7 +862,7 @@ impl<'a> State<'a> {\n         let generics = hir::Generics::empty();\n         self.print_struct(&v.data, &generics, v.ident.name, v.span, false);\n         if let Some(ref d) = v.disr_expr {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"=\");\n             self.print_anon_const(d);\n         }\n@@ -894,7 +894,7 @@ impl<'a> State<'a> {\n                 let vis =\n                     Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n                 self.print_method_sig(ti.ident, sig, &ti.generics, &vis, arg_names, None);\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                 let vis =\n@@ -975,11 +975,11 @@ impl<'a> State<'a> {\n             hir::StmtKind::Semi(ref expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr(&expr);\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n         }\n         if stmt_ends_with_semi(&st.kind) {\n-            self.s.word(\";\");\n+            self.word(\";\");\n         }\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n@@ -1031,17 +1031,17 @@ impl<'a> State<'a> {\n                 hir::ExprKind::If(ref i, ref then, ref e) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n-                    self.s.word(\" else if \");\n+                    self.word(\" else if \");\n                     self.print_expr_as_cond(&i);\n-                    self.s.space();\n+                    self.space();\n                     self.print_expr(&then);\n                     self.print_else(e.as_ref().map(|e| &**e))\n                 }\n                 // Final `else` block.\n                 hir::ExprKind::Block(ref b, _) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n-                    self.s.word(\" else \");\n+                    self.word(\" else \");\n                     self.print_block(&b)\n                 }\n                 // Constraints would be great here!\n@@ -1060,7 +1060,7 @@ impl<'a> State<'a> {\n     ) {\n         self.head(\"if\");\n         self.print_expr_as_cond(test);\n-        self.s.space();\n+        self.space();\n         self.print_expr(blk);\n         self.print_else(elseopt)\n     }\n@@ -1102,9 +1102,9 @@ impl<'a> State<'a> {\n \n     /// Print a `let pat = expr` expression.\n     fn print_let(&mut self, pat: &hir::Pat<'_>, expr: &hir::Expr<'_>) {\n-        self.s.word(\"let \");\n+        self.word(\"let \");\n         self.print_pat(pat);\n-        self.s.space();\n+        self.space();\n         self.word_space(\"=\");\n         let npals = || parser::needs_par_as_let_scrutinee(expr.precedence().order());\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n@@ -1123,26 +1123,26 @@ impl<'a> State<'a> {\n \n     fn print_expr_vec(&mut self, exprs: &[hir::Expr<'_>]) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word(\"[\");\n+        self.word(\"[\");\n         self.commasep_exprs(Inconsistent, exprs);\n-        self.s.word(\"]\");\n+        self.word(\"]\");\n         self.end()\n     }\n \n     fn print_expr_anon_const(&mut self, anon_const: &hir::AnonConst) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word_space(\"const\");\n+        self.word_space(\"const\");\n         self.print_anon_const(anon_const);\n         self.end()\n     }\n \n     fn print_expr_repeat(&mut self, element: &hir::Expr<'_>, count: &hir::AnonConst) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word(\"[\");\n+        self.word(\"[\");\n         self.print_expr(element);\n         self.word_space(\";\");\n         self.print_anon_const(count);\n-        self.s.word(\"]\");\n+        self.word(\"]\");\n         self.end()\n     }\n \n@@ -1153,7 +1153,7 @@ impl<'a> State<'a> {\n         wth: &Option<&hir::Expr<'_>>,\n     ) {\n         self.print_qpath(qpath, true);\n-        self.s.word(\"{\");\n+        self.word(\"{\");\n         self.commasep_cmnt(\n             Consistent,\n             fields,\n@@ -1172,27 +1172,27 @@ impl<'a> State<'a> {\n             Some(ref expr) => {\n                 self.ibox(INDENT_UNIT);\n                 if !fields.is_empty() {\n-                    self.s.word(\",\");\n-                    self.s.space();\n+                    self.word(\",\");\n+                    self.space();\n                 }\n-                self.s.word(\"..\");\n+                self.word(\"..\");\n                 self.print_expr(&expr);\n                 self.end();\n             }\n             _ => {\n                 if !fields.is_empty() {\n-                    self.s.word(\",\")\n+                    self.word(\",\")\n                 }\n             }\n         }\n-        self.s.word(\"}\");\n+        self.word(\"}\");\n     }\n \n     fn print_expr_tup(&mut self, exprs: &[hir::Expr<'_>]) {\n         self.popen();\n         self.commasep_exprs(Inconsistent, exprs);\n         if exprs.len() == 1 {\n-            self.s.word(\",\");\n+            self.word(\",\");\n         }\n         self.pclose()\n     }\n@@ -1210,7 +1210,7 @@ impl<'a> State<'a> {\n     fn print_expr_method_call(&mut self, segment: &hir::PathSegment<'_>, args: &[hir::Expr<'_>]) {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n-        self.s.word(\".\");\n+        self.word(\".\");\n         self.print_ident(segment.ident);\n \n         let generic_args = segment.args();\n@@ -1246,13 +1246,13 @@ impl<'a> State<'a> {\n         };\n \n         self.print_expr_maybe_paren(lhs, left_prec);\n-        self.s.space();\n+        self.space();\n         self.word_space(op.node.as_str());\n         self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n     fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr<'_>) {\n-        self.s.word(op.as_str());\n+        self.word(op.as_str());\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n@@ -1262,7 +1262,7 @@ impl<'a> State<'a> {\n         mutability: hir::Mutability,\n         expr: &hir::Expr<'_>,\n     ) {\n-        self.s.word(\"&\");\n+        self.word(\"&\");\n         match kind {\n             hir::BorrowKind::Ref => self.print_mutability(mutability, false),\n             hir::BorrowKind::Raw => {\n@@ -1434,7 +1434,7 @@ impl<'a> State<'a> {\n             hir::ExprKind::Cast(ref expr, ref ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(&expr, prec);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"as\");\n                 self.print_type(&ty);\n             }\n@@ -1453,7 +1453,7 @@ impl<'a> State<'a> {\n                 // Print `let _t = $init;`:\n                 let temp = Ident::from_str(\"_t\");\n                 self.print_local(Some(init), |this| this.print_ident(temp));\n-                self.s.word(\";\");\n+                self.word(\";\");\n \n                 // Print `_t`:\n                 self.space_if_not_bol();\n@@ -1481,7 +1481,7 @@ impl<'a> State<'a> {\n                 self.ibox(INDENT_UNIT);\n                 self.word_nbsp(\"match\");\n                 self.print_expr_as_cond(&expr);\n-                self.s.space();\n+                self.space();\n                 self.bopen();\n                 for arm in arms {\n                     self.print_arm(arm);\n@@ -1492,7 +1492,7 @@ impl<'a> State<'a> {\n                 self.print_capture_clause(capture_clause);\n \n                 self.print_closure_params(&decl, body);\n-                self.s.space();\n+                self.space();\n \n                 // This is a bare expression.\n                 self.ann.nested(self, Nested::Body(body));\n@@ -1517,54 +1517,54 @@ impl<'a> State<'a> {\n             hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(&lhs, prec + 1);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(&rhs, prec);\n             }\n             hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(&lhs, prec + 1);\n-                self.s.space();\n-                self.s.word(op.node.as_str());\n+                self.space();\n+                self.word(op.node.as_str());\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(&rhs, prec);\n             }\n             hir::ExprKind::Field(ref expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.s.word(\".\");\n+                self.word(\".\");\n                 self.print_ident(ident);\n             }\n             hir::ExprKind::Index(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX);\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_expr(&index);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             hir::ExprKind::Path(ref qpath) => self.print_qpath(qpath, true),\n             hir::ExprKind::Break(destination, ref opt_expr) => {\n-                self.s.word(\"break\");\n-                self.s.space();\n+                self.word(\"break\");\n+                self.space();\n                 if let Some(label) = destination.label {\n                     self.print_ident(label.ident);\n-                    self.s.space();\n+                    self.space();\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                    self.s.space();\n+                    self.space();\n                 }\n             }\n             hir::ExprKind::Continue(destination) => {\n-                self.s.word(\"continue\");\n-                self.s.space();\n+                self.word(\"continue\");\n+                self.space();\n                 if let Some(label) = destination.label {\n                     self.print_ident(label.ident);\n-                    self.s.space()\n+                    self.space()\n                 }\n             }\n             hir::ExprKind::Ret(ref result) => {\n-                self.s.word(\"return\");\n+                self.word(\"return\");\n                 if let Some(ref expr) = *result {\n-                    self.s.word(\" \");\n+                    self.word(\" \");\n                     self.print_expr_maybe_paren(&expr, parser::PREC_JUMP);\n                 }\n             }\n@@ -1574,7 +1574,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprKind::LlvmInlineAsm(ref a) => {\n                 let i = &a.inner;\n-                self.s.word(\"llvm_asm!\");\n+                self.word(\"llvm_asm!\");\n                 self.popen();\n                 self.print_symbol(i.asm, i.asm_str_style);\n                 self.word_space(\":\");\n@@ -1594,7 +1594,7 @@ impl<'a> State<'a> {\n                     s.pclose();\n                     out_idx += 1;\n                 });\n-                self.s.space();\n+                self.space();\n                 self.word_space(\":\");\n \n                 let mut in_idx = 0;\n@@ -1605,7 +1605,7 @@ impl<'a> State<'a> {\n                     s.pclose();\n                     in_idx += 1;\n                 });\n-                self.s.space();\n+                self.space();\n                 self.word_space(\":\");\n \n                 self.commasep(Inconsistent, &i.clobbers, |s, &co| {\n@@ -1624,7 +1624,7 @@ impl<'a> State<'a> {\n                 }\n \n                 if !options.is_empty() {\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\":\");\n                     self.commasep(Inconsistent, &options, |s, &co| {\n                         s.print_string(co, ast::StrStyle::Cooked);\n@@ -1639,7 +1639,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprKind::Err => {\n                 self.popen();\n-                self.s.word(\"/*ERROR*/\");\n+                self.word(\"/*ERROR*/\");\n                 self.pclose();\n             }\n         }\n@@ -1664,7 +1664,7 @@ impl<'a> State<'a> {\n \n         for (i, segment) in path.segments.iter().enumerate() {\n             if i > 0 {\n-                self.s.word(\"::\")\n+                self.word(\"::\")\n             }\n             if segment.ident.name != kw::PathRoot {\n                 self.print_ident(segment.ident);\n@@ -1684,14 +1684,14 @@ impl<'a> State<'a> {\n         match *qpath {\n             hir::QPath::Resolved(None, ref path) => self.print_path(path, colons_before_params),\n             hir::QPath::Resolved(Some(ref qself), ref path) => {\n-                self.s.word(\"<\");\n+                self.word(\"<\");\n                 self.print_type(qself);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"as\");\n \n                 for (i, segment) in path.segments[..path.segments.len() - 1].iter().enumerate() {\n                     if i > 0 {\n-                        self.s.word(\"::\")\n+                        self.word(\"::\")\n                     }\n                     if segment.ident.name != kw::PathRoot {\n                         self.print_ident(segment.ident);\n@@ -1703,8 +1703,8 @@ impl<'a> State<'a> {\n                     }\n                 }\n \n-                self.s.word(\">\");\n-                self.s.word(\"::\");\n+                self.word(\">\");\n+                self.word(\"::\");\n                 let item_segment = path.segments.last().unwrap();\n                 self.print_ident(item_segment.ident);\n                 self.print_generic_args(\n@@ -1720,12 +1720,12 @@ impl<'a> State<'a> {\n                 if let hir::TyKind::Path(hir::QPath::Resolved(None, _)) = &qself.kind {\n                     self.print_type(qself);\n                 } else {\n-                    self.s.word(\"<\");\n+                    self.word(\"<\");\n                     self.print_type(qself);\n-                    self.s.word(\">\");\n+                    self.word(\">\");\n                 }\n \n-                self.s.word(\"::\");\n+                self.word(\"::\");\n                 self.print_ident(item_segment.ident);\n                 self.print_generic_args(\n                     item_segment.args(),\n@@ -1734,9 +1734,9 @@ impl<'a> State<'a> {\n                 )\n             }\n             hir::QPath::LangItem(lang_item, span) => {\n-                self.s.word(\"#[lang = \\\"\");\n+                self.word(\"#[lang = \\\"\");\n                 self.print_ident(Ident::new(lang_item.name(), span));\n-                self.s.word(\"\\\"]\");\n+                self.word(\"\\\"]\");\n             }\n         }\n     }\n@@ -1748,9 +1748,9 @@ impl<'a> State<'a> {\n         colons_before_params: bool,\n     ) {\n         if generic_args.parenthesized {\n-            self.s.word(\"(\");\n+            self.word(\"(\");\n             self.commasep(Inconsistent, generic_args.inputs(), |s, ty| s.print_type(&ty));\n-            self.s.word(\")\");\n+            self.word(\")\");\n \n             self.space_if_not_bol();\n             self.word_space(\"->\");\n@@ -1761,7 +1761,7 @@ impl<'a> State<'a> {\n             let start_or_comma = |this: &mut Self| {\n                 if empty.get() {\n                     empty.set(false);\n-                    this.s.word(start)\n+                    this.word(start)\n                 } else {\n                     this.word_space(\",\")\n                 }\n@@ -1795,14 +1795,14 @@ impl<'a> State<'a> {\n             // \"non-exhaustive patterns: `Some::<..>(_)` not covered\").\n             if infer_args && false {\n                 start_or_comma(self);\n-                self.s.word(\"..\");\n+                self.word(\"..\");\n             }\n \n             for binding in generic_args.bindings.iter() {\n                 start_or_comma(self);\n                 self.print_ident(binding.ident);\n                 self.print_generic_args(binding.gen_args, false, false);\n-                self.s.space();\n+                self.space();\n                 match generic_args.bindings[0].kind {\n                     hir::TypeBindingKind::Equality { ref ty } => {\n                         self.word_space(\"=\");\n@@ -1815,7 +1815,7 @@ impl<'a> State<'a> {\n             }\n \n             if !empty.get() {\n-                self.s.word(\">\")\n+                self.word(\">\")\n             }\n         }\n     }\n@@ -1826,7 +1826,7 @@ impl<'a> State<'a> {\n         // Pat isn't normalized, but the beauty of it\n         // is that it doesn't matter\n         match pat.kind {\n-            PatKind::Wild => self.s.word(\"_\"),\n+            PatKind::Wild => self.word(\"_\"),\n             PatKind::Binding(binding_mode, _, ident, ref sub) => {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n@@ -1844,7 +1844,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_ident(ident);\n                 if let Some(ref p) = *sub {\n-                    self.s.word(\"@\");\n+                    self.word(\"@\");\n                     self.print_pat(&p);\n                 }\n             }\n@@ -1856,9 +1856,9 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\");\n                     }\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                     if ddpos != elts.len() {\n-                        self.s.word(\",\");\n+                        self.word(\",\");\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p));\n                     }\n                 } else {\n@@ -1891,10 +1891,10 @@ impl<'a> State<'a> {\n                     if !fields.is_empty() {\n                         self.word_space(\",\");\n                     }\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                 }\n-                self.s.space();\n-                self.s.word(\"}\");\n+                self.space();\n+                self.word(\"}\");\n             }\n             PatKind::Or(ref pats) => {\n                 self.strsep(\"|\", true, Inconsistent, &pats[..], |s, p| s.print_pat(&p));\n@@ -1906,22 +1906,22 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\");\n                     }\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                     if ddpos != elts.len() {\n-                        self.s.word(\",\");\n+                        self.word(\",\");\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p));\n                     }\n                 } else {\n                     self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p));\n                     if elts.len() == 1 {\n-                        self.s.word(\",\");\n+                        self.word(\",\");\n                     }\n                 }\n                 self.pclose();\n             }\n             PatKind::Box(ref inner) => {\n                 let is_range_inner = matches!(inner.kind, PatKind::Range(..));\n-                self.s.word(\"box \");\n+                self.word(\"box \");\n                 if is_range_inner {\n                     self.popen();\n                 }\n@@ -1932,8 +1932,8 @@ impl<'a> State<'a> {\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n                 let is_range_inner = matches!(inner.kind, PatKind::Range(..));\n-                self.s.word(\"&\");\n-                self.s.word(mutbl.prefix_str());\n+                self.word(\"&\");\n+                self.word(mutbl.prefix_str());\n                 if is_range_inner {\n                     self.popen();\n                 }\n@@ -1946,18 +1946,18 @@ impl<'a> State<'a> {\n             PatKind::Range(ref begin, ref end, ref end_kind) => {\n                 if let Some(expr) = begin {\n                     self.print_expr(expr);\n-                    self.s.space();\n+                    self.space();\n                 }\n                 match *end_kind {\n-                    RangeEnd::Included => self.s.word(\"...\"),\n-                    RangeEnd::Excluded => self.s.word(\"..\"),\n+                    RangeEnd::Included => self.word(\"...\"),\n+                    RangeEnd::Excluded => self.word(\"..\"),\n                 }\n                 if let Some(expr) = end {\n                     self.print_expr(expr);\n                 }\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&p));\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() {\n@@ -1968,13 +1968,13 @@ impl<'a> State<'a> {\n                     } else {\n                         self.print_pat(&p);\n                     }\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                     if !after.is_empty() {\n                         self.word_space(\",\");\n                     }\n                 }\n                 self.commasep(Inconsistent, &after[..], |s, p| s.print_pat(&p));\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n         }\n         self.ann.post(self, AnnNode::Pat(pat))\n@@ -1989,29 +1989,29 @@ impl<'a> State<'a> {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n         if self.attrs(arm.hir_id).is_empty() {\n-            self.s.space();\n+            self.space();\n         }\n         self.cbox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Arm(arm));\n         self.ibox(0);\n         self.print_outer_attributes(&self.attrs(arm.hir_id));\n         self.print_pat(&arm.pat);\n-        self.s.space();\n+        self.space();\n         if let Some(ref g) = arm.guard {\n             match g {\n                 hir::Guard::If(e) => {\n                     self.word_space(\"if\");\n                     self.print_expr(&e);\n-                    self.s.space();\n+                    self.space();\n                 }\n                 hir::Guard::IfLet(pat, e) => {\n                     self.word_nbsp(\"if\");\n                     self.word_nbsp(\"let\");\n                     self.print_pat(&pat);\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"=\");\n                     self.print_expr(&e);\n-                    self.s.space();\n+                    self.space();\n                 }\n             }\n         }\n@@ -2029,13 +2029,13 @@ impl<'a> State<'a> {\n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::UserProvided) = blk.rules\n                 {\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n             }\n             _ => {\n                 self.end(); // close the ibox for the pattern\n                 self.print_expr(&arm.body);\n-                self.s.word(\",\");\n+                self.word(\",\");\n             }\n         }\n         self.ann.post(self, AnnNode::Arm(arm));\n@@ -2067,20 +2067,20 @@ impl<'a> State<'a> {\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n             if let Some(arg_name) = arg_names.get(i) {\n-                s.s.word(arg_name.to_string());\n-                s.s.word(\":\");\n-                s.s.space();\n+                s.word(arg_name.to_string());\n+                s.word(\":\");\n+                s.space();\n             } else if let Some(body_id) = body_id {\n                 s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n-                s.s.word(\":\");\n-                s.s.space();\n+                s.word(\":\");\n+                s.space();\n             }\n             i += 1;\n             s.print_type(ty);\n             s.end()\n         });\n         if decl.c_variadic {\n-            self.s.word(\", ...\");\n+            self.word(\", ...\");\n         }\n         self.pclose();\n \n@@ -2089,7 +2089,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_closure_params(&mut self, decl: &hir::FnDecl<'_>, body_id: hir::BodyId) {\n-        self.s.word(\"|\");\n+        self.word(\"|\");\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n@@ -2100,13 +2100,13 @@ impl<'a> State<'a> {\n             if let hir::TyKind::Infer = ty.kind {\n                 // Print nothing.\n             } else {\n-                s.s.word(\":\");\n-                s.s.space();\n+                s.word(\":\");\n+                s.space();\n                 s.print_type(ty);\n             }\n             s.end();\n         });\n-        self.s.word(\"|\");\n+        self.word(\"|\");\n \n         if let hir::FnRetTy::DefaultReturn(..) = decl.output {\n             return;\n@@ -2138,7 +2138,7 @@ impl<'a> State<'a> {\n         let mut first = true;\n         for bound in bounds {\n             if first {\n-                self.s.word(prefix);\n+                self.word(prefix);\n             }\n             if !(first && prefix.is_empty()) {\n                 self.nbsp();\n@@ -2152,14 +2152,14 @@ impl<'a> State<'a> {\n             match bound {\n                 GenericBound::Trait(tref, modifier) => {\n                     if modifier == &TraitBoundModifier::Maybe {\n-                        self.s.word(\"?\");\n+                        self.word(\"?\");\n                     }\n                     self.print_poly_trait_ref(tref);\n                 }\n                 GenericBound::LangItemTrait(lang_item, span, ..) => {\n-                    self.s.word(\"#[lang = \\\"\");\n+                    self.word(\"#[lang = \\\"\");\n                     self.print_ident(Ident::new(lang_item.name(), *span));\n-                    self.s.word(\"\\\"]\");\n+                    self.word(\"\\\"]\");\n                 }\n                 GenericBound::Outlives(lt) => {\n                     self.print_lifetime(lt);\n@@ -2170,11 +2170,11 @@ impl<'a> State<'a> {\n \n     pub fn print_generic_params(&mut self, generic_params: &[GenericParam<'_>]) {\n         if !generic_params.is_empty() {\n-            self.s.word(\"<\");\n+            self.word(\"<\");\n \n             self.commasep(Inconsistent, generic_params, |s, param| s.print_generic_param(param));\n \n-            self.s.word(\">\");\n+            self.word(\">\");\n         }\n     }\n \n@@ -2191,7 +2191,7 @@ impl<'a> State<'a> {\n                 for bound in param.bounds {\n                     match bound {\n                         GenericBound::Outlives(ref lt) => {\n-                            self.s.word(sep);\n+                            self.word(sep);\n                             self.print_lifetime(lt);\n                             sep = \"+\";\n                         }\n@@ -2202,7 +2202,7 @@ impl<'a> State<'a> {\n             GenericParamKind::Type { ref default, .. } => {\n                 self.print_bounds(\":\", param.bounds);\n                 if let Some(default) = default {\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"=\");\n                     self.print_type(&default)\n                 }\n@@ -2211,7 +2211,7 @@ impl<'a> State<'a> {\n                 self.word_space(\":\");\n                 self.print_type(ty);\n                 if let Some(ref default) = default {\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"=\");\n                     self.print_anon_const(&default)\n                 }\n@@ -2228,7 +2228,7 @@ impl<'a> State<'a> {\n             return;\n         }\n \n-        self.s.space();\n+        self.space();\n         self.word_space(\"where\");\n \n         for (i, predicate) in where_clause.predicates.iter().enumerate() {\n@@ -2253,7 +2253,7 @@ impl<'a> State<'a> {\n                     ..\n                 }) => {\n                     self.print_lifetime(lifetime);\n-                    self.s.word(\":\");\n+                    self.word(\":\");\n \n                     for (i, bound) in bounds.iter().enumerate() {\n                         match bound {\n@@ -2264,15 +2264,15 @@ impl<'a> State<'a> {\n                         }\n \n                         if i != 0 {\n-                            self.s.word(\":\");\n+                            self.word(\":\");\n                         }\n                     }\n                 }\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     lhs_ty, rhs_ty, ..\n                 }) => {\n                     self.print_type(lhs_ty);\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"=\");\n                     self.print_type(rhs_ty);\n                 }\n@@ -2326,7 +2326,7 @@ impl<'a> State<'a> {\n     ) {\n         self.ibox(INDENT_UNIT);\n         if !generic_params.is_empty() {\n-            self.s.word(\"for\");\n+            self.word(\"for\");\n             self.print_generic_params(generic_params);\n         }\n         let generics = hir::Generics {\n@@ -2352,7 +2352,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility<'_>) {\n-        self.s.word(visibility_qualified(vis, \"\"));\n+        self.word(visibility_qualified(vis, \"\"));\n \n         match header.constness {\n             hir::Constness::NotConst => {}\n@@ -2371,7 +2371,7 @@ impl<'a> State<'a> {\n             self.word_nbsp(header.abi.to_string());\n         }\n \n-        self.s.word(\"fn\")\n+        self.word(\"fn\")\n     }\n \n     pub fn print_unsafety(&mut self, s: hir::Unsafety) {"}, {"sha": "9cf6cde259150a433041cbdb7631d194f04d736a", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 131, "deletions": 6, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -1,6 +1,5 @@\n use crate::infer::type_variable::TypeVariableOriginKind;\n-use crate::infer::InferCtxt;\n-use crate::rustc_middle::ty::TypeFoldable;\n+use crate::infer::{InferCtxt, Symbol};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace};\n@@ -11,7 +10,7 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::infer::unify_key::ConstVariableOriginKind;\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, DefIdTree, InferConst, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Const, DefIdTree, InferConst, Ty, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -306,6 +305,15 @@ pub enum UnderspecifiedArgKind {\n     Const { is_parameter: bool },\n }\n \n+impl UnderspecifiedArgKind {\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            Self::Type { .. } => \"type\",\n+            Self::Const { .. } => \"const\",\n+        }\n+    }\n+}\n+\n impl InferenceDiagnosticsData {\n     /// Generate a label for a generic argument which can't be inferred. When not\n     /// much is known about the argument, `use_diag` may be used to describe the\n@@ -588,6 +596,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n+        let param_type = arg_data.kind.descr();\n         let suffix = match local_visitor.found_node_ty {\n             Some(ty) if ty.is_closure() => {\n                 let substs =\n@@ -626,13 +635,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             Some(ty) if is_named_and_not_impl_trait(ty) && arg_data.name == \"_\" => {\n                 let ty = ty_to_string(ty);\n-                format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n+                format!(\"the explicit type `{}`, with the {} parameters specified\", ty, param_type)\n             }\n             Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != arg_data.name => {\n+                let ty = ResolvedTypeParamEraser::new(self.tcx).fold_ty(ty);\n+                let ty = ErrTypeParamEraser(self.tcx).fold_ty(ty);\n                 let ty = ty_to_string(ty);\n                 format!(\n-                    \"the explicit type `{}`, where the type parameter `{}` is specified\",\n-                    ty, arg_data.name,\n+                    \"the explicit type `{}`, where the {} parameter `{}` is specified\",\n+                    ty, param_type, arg_data.name,\n                 )\n             }\n             _ => \"a type\".to_string(),\n@@ -908,3 +919,117 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err\n     }\n }\n+\n+/// Turn *resolved* type params into `[type error]` to signal we don't want to display them. After\n+/// performing that replacement, we'll turn all remaining infer type params to use their name from\n+/// their definition, and replace all the `[type error]`s back to being infer so they display in\n+/// the output as `_`. If we didn't go through `[type error]`, we would either show all type params\n+/// by their name *or* `_`, neither of which is desireable: we want to show all types that we could\n+/// infer as `_` to reduce verbosity and avoid telling the user about unnecessary type annotations.\n+struct ResolvedTypeParamEraser<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    level: usize,\n+}\n+\n+impl<'tcx> ResolvedTypeParamEraser<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        ResolvedTypeParamEraser { tcx, level: 0 }\n+    }\n+\n+    /// Replace not yet inferred const params with their def name.\n+    fn replace_infers(&self, c: &'tcx Const<'tcx>, index: u32, name: Symbol) -> &'tcx Const<'tcx> {\n+        match c.val {\n+            ty::ConstKind::Infer(..) => self.tcx().mk_const_param(index, name, c.ty),\n+            _ => c,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        self.level += 1;\n+        let t = match t.kind() {\n+            // We'll hide this type only if all its type params are hidden as well.\n+            ty::Adt(def, substs) => {\n+                let generics = self.tcx().generics_of(def.did);\n+                // Account for params with default values, like `Vec`, where we\n+                // want to show `Vec<T>`, not `Vec<T, _>`. If we replaced that\n+                // subst, then we'd get the incorrect output, so we passthrough.\n+                let substs: Vec<_> = substs\n+                    .iter()\n+                    .zip(generics.params.iter())\n+                    .map(|(subst, param)| match &(subst.unpack(), &param.kind) {\n+                        (_, ty::GenericParamDefKind::Type { has_default: true, .. }) => subst,\n+                        (crate::infer::GenericArgKind::Const(c), _) => {\n+                            self.replace_infers(c, param.index, param.name).into()\n+                        }\n+                        _ => subst.super_fold_with(self),\n+                    })\n+                    .collect();\n+                let should_keep = |subst: &GenericArg<'_>| match subst.unpack() {\n+                    ty::subst::GenericArgKind::Type(t) => match t.kind() {\n+                        ty::Error(_) => false,\n+                        _ => true,\n+                    },\n+                    // Account for `const` params here, otherwise `doesnt_infer.rs`\n+                    // shows `_` instead of `Foo<{ _: u32 }>`\n+                    ty::subst::GenericArgKind::Const(_) => true,\n+                    _ => false,\n+                };\n+                if self.level == 1 || substs.iter().any(should_keep) {\n+                    let substs = self.tcx().intern_substs(&substs[..]);\n+                    self.tcx().mk_ty(ty::Adt(def, substs))\n+                } else {\n+                    self.tcx().ty_error()\n+                }\n+            }\n+            ty::Ref(_, ty, _) => {\n+                let ty = self.fold_ty(ty);\n+                match ty.kind() {\n+                    // Avoid `&_`, these can be safely presented as `_`.\n+                    ty::Error(_) => self.tcx().ty_error(),\n+                    _ => t.super_fold_with(self),\n+                }\n+            }\n+            // We could account for `()` if we wanted to replace it, but it's assured to be short.\n+            ty::Tuple(_)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Opaque(..)\n+            | ty::Projection(_)\n+            | ty::Never => t.super_fold_with(self),\n+            ty::Array(ty, c) => self\n+                .tcx()\n+                .mk_ty(ty::Array(self.fold_ty(ty), self.replace_infers(c, 0, Symbol::intern(\"N\")))),\n+            // We don't want to hide type params that haven't been resolved yet.\n+            // This would be the type that will be written out with the type param\n+            // name in the output.\n+            ty::Infer(_) => t,\n+            // We don't want to hide the outermost type, only its type params.\n+            _ if self.level == 1 => t.super_fold_with(self),\n+            // Hide this type\n+            _ => self.tcx().ty_error(),\n+        };\n+        self.level -= 1;\n+        t\n+    }\n+}\n+\n+/// Replace `[type error]` with `ty::Infer(ty::Var)` to display `_`.\n+struct ErrTypeParamEraser<'tcx>(TyCtxt<'tcx>);\n+impl<'tcx> TypeFolder<'tcx> for ErrTypeParamEraser<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.0\n+    }\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.kind() {\n+            ty::Error(_) => self.tcx().mk_ty_var(ty::TyVid::from_u32(0)),\n+            _ => t.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "2d301262730642aeaefefc3a59f290a82ba507f8", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::def::Namespace;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_macros::HashStable;\n+use rustc_middle::ty::normalize_erasing_regions::NormalizationError;\n \n use std::fmt;\n \n@@ -575,6 +576,23 @@ impl<'tcx> Instance<'tcx> {\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn try_subst_mir_and_normalize_erasing_regions<T>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        v: T,\n+    ) -> Result<T, NormalizationError<'tcx>>\n+    where\n+        T: TypeFoldable<'tcx> + Clone,\n+    {\n+        if let Some(substs) = self.substs_for_mir_body() {\n+            tcx.try_subst_and_normalize_erasing_regions(substs, param_env, v)\n+        } else {\n+            tcx.try_normalize_erasing_regions(param_env, v)\n+        }\n+    }\n+\n     /// Returns a new `Instance` where generic parameters in `instance.substs` are replaced by\n     /// identity parameters if they are determined to be unused in `instance.def`.\n     pub fn polymorphize(self, tcx: TyCtxt<'tcx>) -> Self {"}, {"sha": "c472d4a5a4dc2524762c8dc55076edbd4dd7f9f5", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -115,6 +115,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Monomorphizes a type from the AST by first applying the\n     /// in-scope substitutions and then normalizing any associated\n     /// types.\n+    /// Panics if normalization fails. In case normalization might fail\n+    /// use `try_subst_and_normalize_erasing_regions` instead.\n     pub fn subst_and_normalize_erasing_regions<T>(\n         self,\n         param_substs: SubstsRef<'tcx>,\n@@ -134,6 +136,30 @@ impl<'tcx> TyCtxt<'tcx> {\n         let substituted = value.subst(self, param_substs);\n         self.normalize_erasing_regions(param_env, substituted)\n     }\n+\n+    /// Monomorphizes a type from the AST by first applying the\n+    /// in-scope substitutions and then trying to normalize any associated\n+    /// types. Contrary to `subst_and_normalize_erasing_regions` this does\n+    /// not assume that normalization succeeds.\n+    pub fn try_subst_and_normalize_erasing_regions<T>(\n+        self,\n+        param_substs: SubstsRef<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: T,\n+    ) -> Result<T, NormalizationError<'tcx>>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"subst_and_normalize_erasing_regions(\\\n+             param_substs={:?}, \\\n+             value={:?}, \\\n+             param_env={:?})\",\n+            param_substs, value, param_env,\n+        );\n+        let substituted = value.subst(self, param_substs);\n+        self.try_normalize_erasing_regions(param_env, substituted)\n+    }\n }\n \n struct NormalizeAfterErasingRegionsFolder<'tcx> {"}, {"sha": "55cf807172e02fc0b390ccd8653e4abe615a3a33", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -533,43 +533,64 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Converts inline const patterns.\n+    fn lower_inline_const(\n+        &mut self,\n+        anon_const: &'tcx hir::AnonConst,\n+        id: hir::HirId,\n+        span: Span,\n+    ) -> PatKind<'tcx> {\n+        let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n+        let value = ty::Const::from_inline_const(self.tcx, anon_const_def_id);\n+\n+        // Evaluate early like we do in `lower_path`.\n+        let value = value.eval(self.tcx, self.param_env);\n+\n+        match value.val {\n+            ConstKind::Param(_) => {\n+                self.errors.push(PatternError::ConstParamInPattern(span));\n+                return PatKind::Wild;\n+            }\n+            ConstKind::Unevaluated(_) => {\n+                // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n+                self.tcx.sess.span_err(span, \"constant pattern depends on a generic parameter\");\n+                return PatKind::Wild;\n+            }\n+            _ => (),\n+        }\n+\n+        *self.const_to_pat(value, id, span, false).kind\n+    }\n+\n     /// Converts literals, paths and negation of literals to patterns.\n     /// The special case for negation exists to allow things like `-128_i8`\n     /// which would overflow if we tried to evaluate `128_i8` and then negate\n     /// afterwards.\n     fn lower_lit(&mut self, expr: &'tcx hir::Expr<'tcx>) -> PatKind<'tcx> {\n-        if let hir::ExprKind::Path(ref qpath) = expr.kind {\n-            *self.lower_path(qpath, expr.hir_id, expr.span).kind\n-        } else {\n-            let (lit, neg) = match expr.kind {\n-                hir::ExprKind::ConstBlock(ref anon_const) => {\n-                    let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n-                    let value = ty::Const::from_inline_const(self.tcx, anon_const_def_id);\n-                    if matches!(value.val, ConstKind::Param(_)) {\n-                        let span = self.tcx.hir().span(anon_const.hir_id);\n-                        self.errors.push(PatternError::ConstParamInPattern(span));\n-                        return PatKind::Wild;\n-                    }\n-                    return *self.const_to_pat(value, expr.hir_id, expr.span, false).kind;\n-                }\n-                hir::ExprKind::Lit(ref lit) => (lit, false),\n-                hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => {\n-                    let lit = match expr.kind {\n-                        hir::ExprKind::Lit(ref lit) => lit,\n-                        _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n-                    };\n-                    (lit, true)\n-                }\n-                _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n-            };\n-\n-            let lit_input =\n-                LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n-            match self.tcx.at(expr.span).lit_to_const(lit_input) {\n-                Ok(val) => *self.const_to_pat(val, expr.hir_id, lit.span, false).kind,\n-                Err(LitToConstError::Reported) => PatKind::Wild,\n-                Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n+        let (lit, neg) = match expr.kind {\n+            hir::ExprKind::Path(ref qpath) => {\n+                return *self.lower_path(qpath, expr.hir_id, expr.span).kind;\n+            }\n+            hir::ExprKind::ConstBlock(ref anon_const) => {\n+                return self.lower_inline_const(anon_const, expr.hir_id, expr.span);\n+            }\n+            hir::ExprKind::Lit(ref lit) => (lit, false),\n+            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => {\n+                let lit = match expr.kind {\n+                    hir::ExprKind::Lit(ref lit) => lit,\n+                    _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n+                };\n+                (lit, true)\n             }\n+            _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n+        };\n+\n+        let lit_input =\n+            LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n+        match self.tcx.at(expr.span).lit_to_const(lit_input) {\n+            Ok(val) => *self.const_to_pat(val, expr.hir_id, lit.span, false).kind,\n+            Err(LitToConstError::Reported) => PatKind::Wild,\n+            Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n         }\n     }\n }"}, {"sha": "56ca7c03928009d53d34c9a6565df29f5e55f7b7", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -396,7 +396,7 @@ Note that the third item is the crate root, which in this case is undocumented.\n ### `-w`/`--output-format`: output format\n \n `--output-format json` emits documentation in the experimental\n-[JSON format](https://github.com/rust-lang/rfcs/pull/2963). `--output-format html` has no effect,\n+[JSON format](https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc_json_types/). `--output-format html` has no effect,\n and is also accepted on stable toolchains.\n \n It can also be used with `--show-coverage`. Take a look at its"}, {"sha": "5c957e4a379a457c00d5082cf9b4a232cabd8cb1", "filename": "src/librustdoc/html/templates/page.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -20,7 +20,7 @@\n           id=\"mainThemeStyle\"> {#- -#}\n     {%- for theme in themes -%}\n         <link rel=\"stylesheet\" type=\"text/css\" {# -#}\n-            href=\"{{static_root_path | safe}}{{theme}}{{page.resource_suffix}}.css\" {#- -#}\n+            href=\"{{static_root_path | safe}}{{theme}}{{page.resource_suffix}}.css\" {# -#}\n         {%- if theme == \"light\" -%}\n             id=\"themeStyle\"\n         {%- else -%}"}, {"sha": "d6c64d58be5f39c9975650203301179d702f500f", "filename": "src/test/ui/const-generics/defaults/doesnt_infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed for `Foo<{_: u32}>`\n LL |     let foo = Foo::foo();\n    |         ---   ^^^^^^^^ cannot infer the value of const parameter `N`\n    |         |\n-   |         consider giving `foo` the explicit type `Foo<{_: u32}>`, where the type parameter `N` is specified\n+   |         consider giving `foo` the explicit type `Foo<N>`, where the const parameter `N` is specified\n \n error: aborting due to previous error\n "}, {"sha": "bea5dc8ba21e6fb23a0e4ac5c09b918f152d3ca0", "filename": "src/test/ui/const-generics/issues/issue-72845.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72845.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -0,0 +1,49 @@\n+#![feature(generic_const_exprs)]\n+#![feature(specialization)]\n+#![allow(incomplete_features)]\n+\n+//--------------------------------------------------\n+\n+trait Depth {\n+    const C: usize;\n+}\n+\n+trait Type {\n+    type AT: Depth;\n+}\n+\n+//--------------------------------------------------\n+\n+enum Predicate<const B: bool> {}\n+\n+trait Satisfied {}\n+\n+impl Satisfied for Predicate<true> {}\n+\n+//--------------------------------------------------\n+\n+trait Spec1 {}\n+\n+impl<T: Type> Spec1 for T where Predicate<{T::AT::C > 0}>: Satisfied {}\n+\n+trait Spec2 {}\n+\n+//impl<T: Type > Spec2 for T where Predicate<{T::AT::C > 1}>: Satisfied {}\n+impl<T: Type > Spec2 for T where Predicate<true>: Satisfied {}\n+\n+//--------------------------------------------------\n+\n+trait Foo {\n+    fn Bar();\n+}\n+\n+impl<T: Spec1> Foo for T {\n+    default fn Bar() {}\n+}\n+\n+impl<T: Spec2> Foo for T {\n+//~^ ERROR conflicting implementations of trait\n+    fn Bar() {}\n+}\n+\n+fn main() {}"}, {"sha": "631c8605fb4d6a3a752c29b70f726e926010e95c", "filename": "src/test/ui/const-generics/issues/issue-72845.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72845.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72845.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72845.stderr?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `Foo`\n+  --> $DIR/issue-72845.rs:44:1\n+   |\n+LL | impl<T: Spec1> Foo for T {\n+   | ------------------------ first implementation here\n+...\n+LL | impl<T: Spec2> Foo for T {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "45a3d901c987119540915c195daa098f28fe0c01", "filename": "src/test/ui/consts/const-eval/const-eval-query-stack.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -20,7 +20,7 @@ error[E0080]: evaluation of constant value failed\n LL |     let x: &'static i32 = &X;\n    |                            ^ referenced constant has errors\n query stack during panic:\n-#0 [normalize_mir_const_after_erasing_regions] normalizing `main::promoted[1]`\n+#0 [try_normalize_mir_const_after_erasing_regions] normalizing `main::promoted[1]`\n #1 [optimized_mir] optimizing MIR for `main`\n #2 [collect_and_partition_mono_items] collect_and_partition_mono_items\n end of query stack"}, {"sha": "1fea2da92da94367ec01ededabbbd74b014bde3f", "filename": "src/test/ui/inference/erase-type-params-in-label.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -0,0 +1,27 @@\n+fn main() {\n+    let foo = foo(1, \"\"); //~ ERROR E0283\n+}\n+fn baz() {\n+    let bar = bar(1, \"\"); //~ ERROR E0283\n+}\n+\n+struct Bar<T, K, N: Default> {\n+    t: T,\n+    k: K,\n+    n: N,\n+}\n+\n+fn bar<T, K, Z: Default>(t: T, k: K) -> Bar<T, K, Z> {\n+    Bar { t, k, n: Default::default() }\n+}\n+\n+struct Foo<T, K, N: Default, M: Default> {\n+    t: T,\n+    k: K,\n+    n: N,\n+    m: M,\n+}\n+\n+fn foo<T, K, W: Default, Z: Default>(t: T, k: K) -> Foo<T, K, W, Z> {\n+    Foo { t, k, n: Default::default(), m: Default::default() }\n+}"}, {"sha": "d0b06cde9d63a58bef0164f77026ed17b1212c99", "filename": "src/test/ui/inference/erase-type-params-in-label.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -0,0 +1,41 @@\n+error[E0283]: type annotations needed for `Foo<i32, &str, W, Z>`\n+  --> $DIR/erase-type-params-in-label.rs:2:15\n+   |\n+LL |     let foo = foo(1, \"\");\n+   |         ---   ^^^ cannot infer type for type parameter `W` declared on the function `foo`\n+   |         |\n+   |         consider giving `foo` the explicit type `Foo<_, _, W, Z>`, where the type parameter `W` is specified\n+   |\n+   = note: cannot satisfy `_: Default`\n+note: required by a bound in `foo`\n+  --> $DIR/erase-type-params-in-label.rs:25:17\n+   |\n+LL | fn foo<T, K, W: Default, Z: Default>(t: T, k: K) -> Foo<T, K, W, Z> {\n+   |                 ^^^^^^^ required by this bound in `foo`\n+help: consider specifying the type arguments in the function call\n+   |\n+LL |     let foo = foo::<T, K, W, Z>(1, \"\");\n+   |                  ++++++++++++++\n+\n+error[E0283]: type annotations needed for `Bar<i32, &str, Z>`\n+  --> $DIR/erase-type-params-in-label.rs:5:15\n+   |\n+LL |     let bar = bar(1, \"\");\n+   |         ---   ^^^ cannot infer type for type parameter `Z` declared on the function `bar`\n+   |         |\n+   |         consider giving `bar` the explicit type `Bar<_, _, Z>`, where the type parameter `Z` is specified\n+   |\n+   = note: cannot satisfy `_: Default`\n+note: required by a bound in `bar`\n+  --> $DIR/erase-type-params-in-label.rs:14:17\n+   |\n+LL | fn bar<T, K, Z: Default>(t: T, k: K) -> Bar<T, K, Z> {\n+   |                 ^^^^^^^ required by this bound in `bar`\n+help: consider specifying the type arguments in the function call\n+   |\n+LL |     let bar = bar::<T, K, Z>(1, \"\");\n+   |                  +++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "9ca8f35fd545a4abb34cbae54e3ee8b9a8765443", "filename": "src/test/ui/inference/issue-83606.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed for `[usize; _]`\n LL |     let _ = foo(\"foo\"); //<- Do not suggest `foo::<N>(\"foo\");`!\n    |         -   ^^^ cannot infer the value of const parameter `N` declared on the function `foo`\n    |         |\n-   |         consider giving this pattern the explicit type `[usize; _]`, where the type parameter `N` is specified\n+   |         consider giving this pattern the explicit type `[_; N]`, where the const parameter `N` is specified\n \n error: aborting due to previous error\n "}, {"sha": "be7e1d8d44984c7676aaa1c80a07569d9feb8cdb", "filename": "src/test/ui/inline-const/const-match-pat-generic.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.rs?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -1,16 +1,31 @@\n #![allow(incomplete_features)]\n #![feature(inline_const_pat)]\n+#![feature(generic_const_exprs)]\n \n // rust-lang/rust#82518: ICE with inline-const in match referencing const-generic parameter\n \n fn foo<const V: usize>() {\n-  match 0 {\n-    const { V } => {},\n-    //~^ ERROR const parameters cannot be referenced in patterns [E0158]\n-    _ => {},\n-  }\n+    match 0 {\n+        const { V } => {},\n+        //~^ ERROR const parameters cannot be referenced in patterns [E0158]\n+        _ => {},\n+    }\n+}\n+\n+const fn f(x: usize) -> usize {\n+    x + 1\n+}\n+\n+fn bar<const V: usize>() where [(); f(V)]: {\n+    match 0 {\n+        const { f(V) } => {},\n+        //~^ ERROR constant pattern depends on a generic parameter\n+        //~| ERROR constant pattern depends on a generic parameter\n+        _ => {},\n+    }\n }\n \n fn main() {\n     foo::<1>();\n+    bar::<1>();\n }"}, {"sha": "5fe5a7a6dad412b4eb97c6efc8f33939dd7e3b24", "filename": "src/test/ui/inline-const/const-match-pat-generic.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6b883c74f49f32cb5d1cbad3457f2b8805a4a38/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -1,9 +1,21 @@\n error[E0158]: const parameters cannot be referenced in patterns\n-  --> $DIR/const-match-pat-generic.rs:8:11\n+  --> $DIR/const-match-pat-generic.rs:9:9\n    |\n-LL |     const { V } => {},\n-   |           ^^^^^\n+LL |         const { V } => {},\n+   |         ^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: constant pattern depends on a generic parameter\n+  --> $DIR/const-match-pat-generic.rs:21:9\n+   |\n+LL |         const { f(V) } => {},\n+   |         ^^^^^^^^^^^^^^\n+\n+error: constant pattern depends on a generic parameter\n+  --> $DIR/const-match-pat-generic.rs:21:9\n+   |\n+LL |         const { f(V) } => {},\n+   |         ^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0158`."}, {"sha": "40dc281755137ee804bc9b3b08e782773b726e44", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=e6b883c74f49f32cb5d1cbad3457f2b8805a4a38", "patch": "@@ -1 +1 @@\n-Subproject commit 294967c53f0c70d598fc54ca189313c86c576ea7\n+Subproject commit 40dc281755137ee804bc9b3b08e782773b726e44"}]}