{"sha": "27b4d104c88d33248dbc59fef27ae9866a591dfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YjRkMTA0Yzg4ZDMzMjQ4ZGJjNTlmZWYyN2FlOTg2NmE1OTFkZmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-11T01:21:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-13T06:18:51Z"}, "message": "Explain what ifmt! is all about", "tree": {"sha": "571c39d01302195cd03920d38b11b10ace6b6332", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/571c39d01302195cd03920d38b11b10ace6b6332"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27b4d104c88d33248dbc59fef27ae9866a591dfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27b4d104c88d33248dbc59fef27ae9866a591dfd", "html_url": "https://github.com/rust-lang/rust/commit/27b4d104c88d33248dbc59fef27ae9866a591dfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27b4d104c88d33248dbc59fef27ae9866a591dfd/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "html_url": "https://github.com/rust-lang/rust/commit/1f6afa887b9fbaadda36ce57a3c296f43ed8a084"}], "stats": {"total": 301, "additions": 301, "deletions": 0}, "files": [{"sha": "f90e7d5084afb2734ea23a53d11d1ecb94e2549b", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/27b4d104c88d33248dbc59fef27ae9866a591dfd/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b4d104c88d33248dbc59fef27ae9866a591dfd/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=27b4d104c88d33248dbc59fef27ae9866a591dfd", "patch": "@@ -8,6 +8,307 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/**!\n+\n+# The Formatting Module\n+\n+This module contains the runtime support for the `ifmt!` syntax extension. This\n+macro is implemented in the compiler to emit calls to this module in order to\n+format arguments at runtime into strings and streams.\n+\n+The functions contained in this module should not normally be used in everyday\n+use cases of `ifmt!`. The assumptions made by these functions are unsafe for all\n+inputs, and the compiler performs a large amount of validation on the arguments\n+to `ifmt!` in order to ensure safety at runtime. While it is possible to call\n+these functions directly, it is not recommended to do so in the general case.\n+\n+## Usage\n+\n+The `ifmt!` macro is intended to be familiar to those coming from C's\n+printf/sprintf functions or Python's `str.format` function. In its current\n+revision, the `ifmt!` macro returns a `~str` type which is the result of the\n+formatting. In the future it will also be able to pass in a stream to format\n+arguments directly while performing minimal allocations.\n+\n+Some examples of the `ifmt!` extension are:\n+\n+~~~{.rust}\n+ifmt!(\"Hello\")                  // => ~\"Hello\"\n+ifmt!(\"Hello, {:s}!\", \"world\")  // => ~\"Hello, world!\"\n+ifmt!(\"The number is {:d}\", 1)  // => ~\"The number is 1\"\n+ifmt!(\"{}\", ~[3, 4])            // => ~\"~[3, 4]\"\n+ifmt!(\"{value}\", value=4)       // => ~\"4\"\n+ifmt!(\"{} {}\", 1, 2)            // => ~\"1 2\"\n+~~~\n+\n+From these, you can see that the first argument is a format string. It is\n+required by the compiler for this to be a string literal; it cannot be a\n+variable passed in (in order to perform validity checking). The compiler will\n+then parse the format string and determine if the list of arguments provided is\n+suitable to pass to this format string.\n+\n+### Positional parameters\n+\n+Each formatting argument is allowed to specify which value argument it's\n+referencing, and if omitted it is assumed to be \"the next argument\". For\n+example, the format string `{} {} {}` would take three parameters, and they\n+would be formatted in the same order as they're given. The format string\n+`{2} {1} {0}`, however, would format arguments in reverse order.\n+\n+A format string is required to use all of its arguments, otherwise it is a\n+compile-time error. You may refer to the same argument more than once in the\n+format string, although it must always be referred to with the same type.\n+\n+### Named parameters\n+\n+Rust itself does not have a Python-like equivalent of named parameters to a\n+function, but the `ifmt!` macro is a syntax extension which allows it to\n+leverage named parameters. Named parameters are listed at the end of the\n+argument list and have the syntax:\n+\n+~~~\n+identifier '=' expression\n+~~~\n+\n+It is illegal to put positional parameters (those without names) after arguments\n+which have names. Like positional parameters, it is illegal to provided named\n+parameters that are unused by the format string.\n+\n+### Argument types\n+\n+Each argument's type is dictated by the format string. It is a requirement that\n+every argument is only ever referred to by one type. When specifying the format\n+of an argument, however, a string like `{}` indicates no type. This is allowed,\n+and if all references to one argument do not provide a type, then the format `?`\n+is used (the type's rust-representation is printed). For example, this is an\n+invalid format string:\n+\n+~~~\n+{0:d} {0:s}\n+~~~\n+\n+Because the first argument is both referred to as an integer as well as a\n+string.\n+\n+Because formatting is done via traits, there is no requirement that the\n+`d` format actually takes an `int`, but rather it simply requires a type which\n+ascribes to the `Signed` formatting trait. There are various parameters which do\n+require a particular type, however. Namely if the sytnax `{:.*s}` is used, then\n+the number of characters to print from the string precedes the actual string and\n+must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is\n+illegal to reference an argument as such. For example, this is another invalid\n+format string:\n+\n+~~~\n+{:.*s} {0:u}\n+~~~\n+\n+### Formatting traits\n+\n+When requesting that an argument be formatted with a particular type, you are\n+actually requesting that an argument ascribes to a particular trait. This allows\n+multiple actual types to be formatted via `{:d}` (like `i8` as well as `int`).\n+The current mapping of types to traits is:\n+\n+* `?` => Poly\n+* `d` => Signed\n+* `i` => Signed\n+* `u` => Unsigned\n+* `b` => Bool\n+* `c` => Char\n+* `o` => Octal\n+* `x` => LowerHex\n+* `X` => UpperHex\n+* `s` => String\n+* `p` => Pointer\n+* `t` => Binary\n+\n+What this means is that any type of argument which implements the\n+`std::fmt::Binary` trait can then be formatted with `{:t}`. Implementations are\n+provided for these traits for a number of primitive types by the standard\n+library as well. Again, the default formatting type (if no other is specified)\n+is `?` which is defined for all types by default.\n+\n+When implementing a format trait for your own time, you will have to implement a\n+method of the signature:\n+\n+~~~\n+fn fmt(value: &T, f: &mut std::fmt::Formatter);\n+~~~\n+\n+Your type will be passed by-reference in `value`, and then the function should\n+emit output into the `f.buf` stream. It is up to each format trait\n+implementation to correctly adhere to the requested formatting parameters. The\n+values of these parameters will be listed in the fields of the `Formatter`\n+struct. In order to help with this, the `Formatter` struct also provides some\n+helper methods.\n+\n+## Internationalization\n+\n+The formatting syntax supported by the `ifmt!` extension supports\n+internationalization by providing \"methods\" which execute various differnet\n+outputs depending on the input. The syntax and methods provided are similar to\n+other internationalization systems, so again nothing should seem alien.\n+Currently two methods are supported by this extension: \"select\" and \"plural\".\n+\n+Each method will execute one of a number of clauses, and then the value of the\n+clause will become what's the result of the argument's format. Inside of the\n+cases, nested argument strings may be provided, but all formatting arguments\n+must not be done through implicit positional means. All arguments inside of each\n+case of a method must be explicitly selected by their name or their integer\n+position.\n+\n+Furthermore, whenever a case is running, the special character `#` can be used\n+to reference the string value of the argument which was selected upon. As an\n+example:\n+\n+~~~\n+ifmt!(\"{0, select, other{#}}\", \"hello\") // => ~\"hello\"\n+~~~\n+\n+This example is the equivalent of `{0:s}` essentially.\n+\n+### Select\n+\n+The select method is a switch over a `&str` parameter, and the parameter *must*\n+be of the type `&str`. An example of the syntax is:\n+\n+~~~\n+{0, select, male{...} female{...} other{...}}\n+~~~\n+\n+Breaking this down, the `0`-th argument is selected upon with the `select`\n+method, and then a number of cases follow. Each case is preceded by an\n+identifier which is the match-clause to execute the given arm. In this case,\n+there are two explicit cases, `male` and `female`. The case will be executed if\n+the string argument provided is an exact match to the case selected.\n+\n+The `other` case is also a required case for all `select` methods. This arm will\n+be executed if none of the other arms matched the word being selected over.\n+\n+### Plural\n+\n+The plural method is a switch statement over a `uint` parameter, and the\n+parameter *must* be a `uint`. A plural method in its full glory can be specified\n+as:\n+\n+~~~\n+{0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n+~~~\n+\n+To break this down, the first `0` indicates that this method is selecting over\n+the value of the first positional parameter to the format string. Next, the\n+`plural` method is being executed. An optionally-supplied `offset` is then given\n+which indicates a number to subtract from argument `0` when matching. This is\n+then followed by a list of cases.\n+\n+Each case is allowed to supply a specific value to match upon with the syntax\n+`=N`. This case is executed if the value at argument `0` matches N exactly,\n+without taking the offset into account. A case may also be specified by one of\n+five keywords: `zero`, `one`, `two`, `few`, and `many`. These cases are matched\n+on after argument `0` has the offset taken into account. Currently the\n+definitions of `many` and `few` are hardcoded, but they are in theory defined by\n+the current locale.\n+\n+Finally, all `plural` methods must have an `other` case supplied which will be\n+executed if none of the other cases match.\n+\n+## Syntax\n+\n+The syntax for the formatting language used is drawn from other languages, so it\n+should not be too alien. Arguments are formatted with python-like syntax,\n+meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n+actual grammar for the formatting syntax is:\n+\n+~~~\n+format_string := <text> [ format <text> ] *\n+format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n+argument := integer | identifier\n+\n+format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n+fill := character\n+align := '<' | '>'\n+sign := '+' | '-'\n+width := count\n+precision := count | '*'\n+type := identifier | ''\n+count := parameter | integer\n+parameter := integer '$'\n+\n+function_spec := plural | select\n+select := 'select' ',' ( identifier arm ) *\n+plural := 'plural' ',' [ 'offset:' integer ] ( selector arm ) *\n+selector := '=' integer | keyword\n+keyword := 'zero' | 'one' | 'two' | 'few' | 'many' | 'other'\n+arm := '{' format_string '}'\n+~~~\n+\n+## Formatting Parameters\n+\n+Each argument being formatted can be transformed by a number of formatting\n+parameters (corresponding to `format_spec` in the syntax above). These\n+parameters affect the string representation of what's being formatted. This\n+syntax draws heavily from Python's, so it may seem a bit familiar.\n+\n+### Fill/Alignment\n+\n+The fill character is provided normally in conjunction with the `width`\n+parameter. This indicates that if the value being formatted is smaller than\n+`width` some extra characters will be printed around it. The extra characters\n+are specified by `fill`, and the alignment can be one of two options:\n+\n+* `<` - the argument is left-aligned in `width` columns\n+* `>` - the argument is right-aligned in `width` columns\n+\n+### Sign/#/0\n+\n+These can all be interpreted as flags for a particular formatter.\n+\n+* '+' - This is intended for numeric types and indicates that the sign should\n+        always be printed. Positive signs are never printed by default, and the\n+        negative sign is only printed by default for the `Signed` trait. This\n+        flag indicates that the correct sign (+ or -) should always be printed.\n+* '-' - Currently not used\n+* '#' - This flag is indicates that the \"alternate\" form of printing should be\n+        used. By default, this only applies to the integer formatting traits and\n+        performs like:\n+    * `x` - precedes the argument with a \"0x\"\n+    * `X` - precedes the argument with a \"0x\"\n+    * `t` - precedes the argument with a \"0b\"\n+    * `o` - precedes the argument with a \"0o\"\n+* '0' - This is used to indicate for integer formats that the padding should\n+        both be done with a `0` character as well as be sign-aware. A format\n+        like `{:08d}` would yield `00000001` for the integer `1`, while the same\n+        format would yield `-0000001` for the integer `-1`. Notice that the\n+        negative version has one fewer zero than the positive version.\n+\n+### Width\n+\n+This is a parameter for the \"minimum width\" that the format should take up. If\n+the value's string does not fill up this many characters, then the padding\n+specified by fill/alignment will be used to take up the required space.\n+\n+The default fill/alignment for non-numerics is a space and left-aligned. The\n+defaults for numeric formatters is also a space but with right-alignment. If the\n+'0' flag is specified for numerics, then the implicit fill character is '0'.\n+\n+The value for the width can also be provided as a `uint` in the list of\n+parameters by using the `2$` syntax indicating that the second argument is a\n+`uint` specifying the width.\n+\n+### Precision\n+\n+For non-numeric types, this can be considered a \"maximum width\". If the\n+resulting string is longer than this width, then it is truncated down to this\n+many characters and only those are emitted.\n+\n+For integral types, this has no meaning currently.\n+\n+For floating-point types, this indicates how many digits after the decimal point\n+should be printed.\n+\n+*/\n+\n use prelude::*;\n \n use cast;"}]}