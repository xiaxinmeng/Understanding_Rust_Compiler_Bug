{"sha": "2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYTNhYjNhOTAyMmE5M2U0NWM0ZDUwYTFjNDNhZWM1ZjU2YWI0ZGM=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-09-19T19:31:56Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-09-19T19:31:56Z"}, "message": "Add the ability to merge spans to codemap", "tree": {"sha": "28b2c21cf26ac97dd70651b1970bdab4c462b816", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28b2c21cf26ac97dd70651b1970bdab4c462b816"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc", "html_url": "https://github.com/rust-lang/rust/commit/2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc/comments", "author": null, "committer": null, "parents": [{"sha": "8394685b8385156fc4bc31cfbc693867e276d9d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8394685b8385156fc4bc31cfbc693867e276d9d7", "html_url": "https://github.com/rust-lang/rust/commit/8394685b8385156fc4bc31cfbc693867e276d9d7"}], "stats": {"total": 101, "additions": 83, "deletions": 18}, "files": [{"sha": "bc599a8207656aadff7a97317ce884f9c7bbd3bb", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc", "patch": "@@ -81,6 +81,7 @@ pub trait CodeMapper {\n     fn span_to_string(&self, sp: Span) -> String;\n     fn span_to_filename(&self, sp: Span) -> FileName;\n     fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace>;\n+    fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span>;\n }\n \n impl CodeSuggestion {"}, {"sha": "ce15bd89590bc90c40cd767a9c90d9ef51a97e5c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc", "patch": "@@ -364,6 +364,46 @@ impl CodeMap {\n         }\n     }\n \n+    /// Returns `Some(span)`, a union of the lhs and rhs span.  The lhs must precede the rhs. If\n+    /// there are gaps between lhs and rhs, the resulting union will cross these gaps.\n+    /// For this to work, the spans have to be:\n+    ///    * the expn_id of both spans much match\n+    ///    * the lhs span needs to end on the same line the rhs span begins\n+    ///    * the lhs span must start at or before the rhs span\n+    pub fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n+        use std::cmp;\n+\n+        // make sure we're at the same expansion id\n+        if sp_lhs.expn_id != sp_rhs.expn_id {\n+            return None;\n+        }\n+\n+        let lhs_end = match self.lookup_line(sp_lhs.hi) {\n+            Ok(x) => x,\n+            Err(_) => return None\n+        };\n+        let rhs_begin = match self.lookup_line(sp_rhs.lo) {\n+            Ok(x) => x,\n+            Err(_) => return None\n+        };\n+\n+        // if we must cross lines to merge, don't merge\n+        if lhs_end.line != rhs_begin.line {\n+            return None;\n+        }\n+\n+        // ensure these follow the expected order\n+        if sp_lhs.lo <= sp_rhs.lo {\n+            Some(Span {\n+                lo: cmp::min(sp_lhs.lo, sp_rhs.lo),\n+                hi: cmp::max(sp_lhs.hi, sp_rhs.hi),\n+                expn_id: sp_lhs.expn_id,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn span_to_string(&self, sp: Span) -> String {\n         if sp == COMMAND_LINE_SP {\n             return \"<command line option>\".to_string();\n@@ -819,6 +859,9 @@ impl CodeMapper for CodeMap {\n     fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace> {\n         self.macro_backtrace(span)\n     }\n+    fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n+        self.merge_spans(sp_lhs, sp_rhs)\n+    }\n }\n \n // _____________________________________________________________________________\n@@ -1072,6 +1115,45 @@ mod tests {\n                     blork.rs:1:1: 1:12\\n  `first line.`\\n\");\n     }\n \n+    /// Test merging two spans on the same line\n+    #[test]\n+    fn span_merging() {\n+        let cm = CodeMap::new();\n+        let inputtext  = \"bbbb BB bb CCC\\n\";\n+        let selection1 = \"     ~~       \\n\";\n+        let selection2 = \"           ~~~\\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        let span1 = span_from_selection(inputtext, selection1);\n+        let span2 = span_from_selection(inputtext, selection2);\n+\n+        if let Some(sp) = cm.merge_spans(span1, span2) {\n+            let sstr = cm.span_to_expanded_string(sp);\n+            assert_eq!(sstr, \"blork.rs:1:6: 1:15\\n`BB bb CCC`\\n\");\n+        }\n+        else {\n+            assert!(false);\n+        }\n+    }\n+\n+    /// Test failing to merge two spans on different lines\n+    #[test]\n+    fn span_merging_fail() {\n+        let cm = CodeMap::new();\n+        let inputtext  = \"bbbb BB\\ncc CCC\\n\";\n+        let selection1 = \"     ~~\\n      \\n\";\n+        let selection2 = \"       \\n   ~~~\\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        let span1 = span_from_selection(inputtext, selection1);\n+        let span2 = span_from_selection(inputtext, selection2);\n+\n+        if let Some(_) = cm.merge_spans(span1, span2) {\n+            assert!(false);\n+        }\n+        else {\n+            assert!(true);\n+        }\n+    }\n+\n     /// Returns the span corresponding to the `n`th occurrence of\n     /// `substring` in `source_text`.\n     trait CodeMapExtension {"}, {"sha": "0c0c62275d4dbab3dd0b7b5644223847bf1d3004", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=2ea3ab3a9022a93e45c4d50a1c43aec5f56ab4dc", "patch": "@@ -96,24 +96,6 @@ impl Span {\n         self.lo == other.lo && self.hi == other.hi\n     }\n \n-    /// Returns `Some(span)`, a union of `self` and `other`, on overlap.\n-    pub fn merge(self, other: Span) -> Option<Span> {\n-        if self.expn_id != other.expn_id {\n-            return None;\n-        }\n-\n-        if (self.lo <= other.lo && self.hi > other.lo) ||\n-           (self.lo >= other.lo && self.lo < other.hi) {\n-            Some(Span {\n-                lo: cmp::min(self.lo, other.lo),\n-                hi: cmp::max(self.hi, other.hi),\n-                expn_id: self.expn_id,\n-            })\n-        } else {\n-            None\n-        }\n-    }\n-\n     /// Returns `Some(span)`, where the start is trimmed by the end of `other`\n     pub fn trim_start(self, other: Span) -> Option<Span> {\n         if self.hi > other.hi {"}]}