{"sha": "6b099db18cbf252e84ec7035c6f8917a61c3c231", "node_id": "C_kwDOAAsO6NoAKDZiMDk5ZGIxOGNiZjI1MmU4NGVjNzAzNWM2Zjg5MTdhNjFjM2MyMzE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-15T15:41:48Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-31T11:48:16Z"}, "message": "Record item-likes in ItemLowerer.", "tree": {"sha": "0477e8f4157c4559cbebf8b87ed646abf473bc2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0477e8f4157c4559cbebf8b87ed646abf473bc2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b099db18cbf252e84ec7035c6f8917a61c3c231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b099db18cbf252e84ec7035c6f8917a61c3c231", "html_url": "https://github.com/rust-lang/rust/commit/6b099db18cbf252e84ec7035c6f8917a61c3c231", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b099db18cbf252e84ec7035c6f8917a61c3c231/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5d482eecaa51a3a4836c550c2e36e93f543e576", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5d482eecaa51a3a4836c550c2e36e93f543e576", "html_url": "https://github.com/rust-lang/rust/commit/e5d482eecaa51a3a4836c550c2e36e93f543e576"}], "stats": {"total": 130, "additions": 69, "deletions": 61}, "files": [{"sha": "c8fd96309a6cd3bac49a1e8ed7729880465ca6d2", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 57, "deletions": 48, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6b099db18cbf252e84ec7035c6f8917a61c3c231/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b099db18cbf252e84ec7035c6f8917a61c3c231/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=6b099db18cbf252e84ec7035c6f8917a61c3c231", "patch": "@@ -5,7 +5,7 @@ use crate::{Arena, FnDeclKind};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -53,18 +53,22 @@ fn add_ty_alias_where_clause(\n }\n \n impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n-    fn make_lctx(&mut self) -> LoweringContext<'_, 'hir> {\n-        LoweringContext {\n+    fn with_lctx(\n+        &mut self,\n+        owner: NodeId,\n+        f: impl FnOnce(&mut LoweringContext<'_, 'hir>) -> hir::OwnerNode<'hir>,\n+    ) {\n+        let mut lctx = LoweringContext {\n             // Pseudo-globals.\n             sess: &self.sess,\n             resolver: self.resolver,\n             nt_to_tokenstream: self.nt_to_tokenstream,\n             arena: self.arena,\n-            owners: self.owners,\n \n             // HirId handling.\n             bodies: Vec::new(),\n             attrs: SortedMap::default(),\n+            children: FxHashMap::default(),\n             current_hir_id_owner: CRATE_DEF_ID,\n             item_local_id_counter: hir::ItemLocalId::new(0),\n             node_id_to_local_id: Default::default(),\n@@ -87,6 +91,13 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             allow_try_trait: Some([sym::try_trait_v2][..].into()),\n             allow_gen_future: Some([sym::gen_future][..].into()),\n             allow_into_future: Some([sym::into_future][..].into()),\n+        };\n+        lctx.with_hir_id_owner(owner, |lctx| f(lctx));\n+\n+        for (def_id, info) in lctx.children {\n+            self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+            debug_assert!(matches!(self.owners[def_id], hir::MaybeOwner::Phantom));\n+            self.owners[def_id] = info;\n         }\n     }\n \n@@ -109,23 +120,21 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n         self.owners[def_id]\n     }\n \n-    fn lower_crate(&mut self, c: &'a Crate) {\n+    fn lower_crate(&mut self, c: &Crate) {\n         debug_assert_eq!(self.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n \n-        let mut lctx = self.make_lctx();\n-        lctx.with_hir_id_owner(CRATE_NODE_ID, |lctx| {\n+        self.with_lctx(CRATE_NODE_ID, |lctx| {\n             let module = lctx.lower_mod(&c.items, c.spans.inner_span);\n             lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n             hir::OwnerNode::Crate(lctx.arena.alloc(module))\n         })\n     }\n \n-    fn lower_item(&mut self, item: &'a Item) {\n-        let mut lctx = self.make_lctx();\n-        lctx.with_hir_id_owner(item.id, |lctx| hir::OwnerNode::Item(lctx.lower_item(item)))\n+    fn lower_item(&mut self, item: &Item) {\n+        self.with_lctx(item.id, |lctx| hir::OwnerNode::Item(lctx.lower_item(item)))\n     }\n \n-    fn lower_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n+    fn lower_assoc_item(&mut self, item: &AssocItem, ctxt: AssocCtxt) {\n         let def_id = self.resolver.local_def_id(item.id);\n \n         let parent_id = {\n@@ -135,43 +144,44 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n         };\n \n         let parent_hir = self.lower_node(parent_id).unwrap().node().expect_item();\n-        let mut lctx = self.make_lctx();\n-\n-        // Evaluate with the lifetimes in `params` in-scope.\n-        // This is used to track which lifetimes have already been defined,\n-        // and which need to be replicated when lowering an async fn.\n-        match parent_hir.kind {\n-            hir::ItemKind::Impl(hir::Impl { ref of_trait, ref generics, .. }) => {\n-                lctx.is_in_trait_impl = of_trait.is_some();\n-                lctx.in_scope_lifetimes = generics\n-                    .params\n-                    .iter()\n-                    .filter(|param| matches!(param.kind, hir::GenericParamKind::Lifetime { .. }))\n-                    .map(|param| param.name)\n-                    .collect();\n-            }\n-            hir::ItemKind::Trait(_, _, ref generics, ..) => {\n-                lctx.in_scope_lifetimes = generics\n-                    .params\n-                    .iter()\n-                    .filter(|param| matches!(param.kind, hir::GenericParamKind::Lifetime { .. }))\n-                    .map(|param| param.name)\n-                    .collect();\n-            }\n-            _ => {}\n-        };\n+        self.with_lctx(item.id, |lctx| {\n+            // Evaluate with the lifetimes in `params` in-scope.\n+            // This is used to track which lifetimes have already been defined,\n+            // and which need to be replicated when lowering an async fn.\n+            match parent_hir.kind {\n+                hir::ItemKind::Impl(hir::Impl { ref of_trait, ref generics, .. }) => {\n+                    lctx.is_in_trait_impl = of_trait.is_some();\n+                    lctx.in_scope_lifetimes = generics\n+                        .params\n+                        .iter()\n+                        .filter(|param| {\n+                            matches!(param.kind, hir::GenericParamKind::Lifetime { .. })\n+                        })\n+                        .map(|param| param.name)\n+                        .collect();\n+                }\n+                hir::ItemKind::Trait(_, _, ref generics, ..) => {\n+                    lctx.in_scope_lifetimes = generics\n+                        .params\n+                        .iter()\n+                        .filter(|param| {\n+                            matches!(param.kind, hir::GenericParamKind::Lifetime { .. })\n+                        })\n+                        .map(|param| param.name)\n+                        .collect();\n+                }\n+                _ => {}\n+            };\n \n-        lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n-            AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n-            AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n+            match ctxt {\n+                AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n+                AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n+            }\n         })\n     }\n \n-    fn lower_foreign_item(&mut self, item: &'a ForeignItem) {\n-        let mut lctx = self.make_lctx();\n-        lctx.with_hir_id_owner(item.id, |lctx| {\n-            hir::OwnerNode::ForeignItem(lctx.lower_foreign_item(item))\n-        })\n+    fn lower_foreign_item(&mut self, item: &ForeignItem) {\n+        self.with_lctx(item.id, |lctx| hir::OwnerNode::ForeignItem(lctx.lower_foreign_item(item)))\n     }\n }\n \n@@ -555,12 +565,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let new_id = self.resolver.local_def_id(new_node_id);\n                     let Some(res) = resolutions.next() else {\n                         // Associate an HirId to both ids even if there is no resolution.\n-                        self.owners.ensure_contains_elem(new_id, || hir::MaybeOwner::Phantom);\n-                        let _old = std::mem::replace(\n-                            &mut self.owners[new_id],\n+                        let _old = self.children.insert(\n+                            new_id,\n                             hir::MaybeOwner::NonOwner(hir::HirId::make_owner(new_id)),\n                         );\n-                        debug_assert!(matches!(_old, hir::MaybeOwner::Phantom));\n+                        debug_assert!(_old.is_none());\n                         continue;\n                     };\n                     let ident = *ident;"}, {"sha": "e4ed48d4b530d673e0adca9c5038c4bcc67fa112", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6b099db18cbf252e84ec7035c6f8917a61c3c231/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b099db18cbf252e84ec7035c6f8917a61c3c231/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=6b099db18cbf252e84ec7035c6f8917a61c3c231", "patch": "@@ -85,7 +85,7 @@ mod path;\n \n rustc_hir::arena_types!(rustc_arena::declare_arena);\n \n-struct LoweringContext<'a, 'hir> {\n+struct LoweringContext<'a, 'hir: 'a> {\n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n@@ -99,12 +99,12 @@ struct LoweringContext<'a, 'hir> {\n     /// Used to allocate HIR nodes.\n     arena: &'hir Arena<'hir>,\n \n-    /// The items being lowered are collected here.\n-    owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n     /// Bodies inside the owner being lowered.\n     bodies: Vec<(hir::ItemLocalId, &'hir hir::Body<'hir>)>,\n     /// Attributes inside the owner being lowered.\n     attrs: SortedMap<hir::ItemLocalId, &'hir [Attribute]>,\n+    /// Collect items that were created by lowering the current owner.\n+    children: FxHashMap<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n@@ -536,13 +536,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.current_hir_id_owner = current_owner;\n         self.item_local_id_counter = current_local_counter;\n \n-        self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n-        self.owners[def_id] = hir::MaybeOwner::Owner(self.arena.alloc(info));\n+        let _old = self.children.insert(def_id, hir::MaybeOwner::Owner(info));\n+        debug_assert!(_old.is_none())\n     }\n \n-    fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> hir::OwnerInfo<'hir> {\n+    fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> &'hir hir::OwnerInfo<'hir> {\n         let attrs = std::mem::take(&mut self.attrs);\n         let mut bodies = std::mem::take(&mut self.bodies);\n+        let local_id_to_def_id = std::mem::take(&mut self.local_id_to_def_id);\n+        let trait_map = std::mem::take(&mut self.trait_map);\n \n         #[cfg(debug_assertions)]\n         for (id, attrs) in attrs.iter() {\n@@ -562,7 +564,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hash_without_bodies,\n             nodes,\n             bodies,\n-            local_id_to_def_id: std::mem::take(&mut self.local_id_to_def_id),\n+            local_id_to_def_id,\n         };\n         let attrs = {\n             let mut hcx = self.resolver.create_stable_hashing_context();\n@@ -572,7 +574,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir::AttributeMap { map: attrs, hash }\n         };\n \n-        hir::OwnerInfo { nodes, parenting, attrs, trait_map: std::mem::take(&mut self.trait_map) }\n+        self.arena.alloc(hir::OwnerInfo { nodes, parenting, attrs, trait_map })\n     }\n \n     /// Hash the HIR node twice, one deep and one shallow hash.  This allows to differentiate\n@@ -620,11 +622,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 assert_ne!(local_id, hir::ItemLocalId::new(0));\n                 if let Some(def_id) = self.resolver.opt_local_def_id(ast_node_id) {\n-                    self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n-                    if let o @ hir::MaybeOwner::Phantom = &mut self.owners[def_id] {\n-                        // Do not override a `MaybeOwner::Owner` that may already here.\n-                        *o = hir::MaybeOwner::NonOwner(hir_id);\n-                    }\n+                    // Do not override a `MaybeOwner::Owner` that may already here.\n+                    self.children.entry(def_id).or_insert(hir::MaybeOwner::NonOwner(hir_id));\n                     self.local_id_to_def_id.insert(local_id, def_id);\n                 }\n "}]}