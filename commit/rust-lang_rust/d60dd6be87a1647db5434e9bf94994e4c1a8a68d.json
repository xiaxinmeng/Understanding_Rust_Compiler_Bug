{"sha": "d60dd6be87a1647db5434e9bf94994e4c1a8a68d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MGRkNmJlODdhMTY0N2RiNTQzNGU5YmY5NDk5NGU0YzFhOGE2OGQ=", "commit": {"author": {"name": "Daniel Patterson", "email": "dbp@riseup.net", "date": "2012-07-26T02:40:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-03T18:28:19Z"}, "message": "std::net::url making scheme parsing compliant with rfc, give appropriate error messages, better split fn", "tree": {"sha": "266bafd75f32b2122391cfb7b00365a2b80f8829", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/266bafd75f32b2122391cfb7b00365a2b80f8829"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d60dd6be87a1647db5434e9bf94994e4c1a8a68d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d60dd6be87a1647db5434e9bf94994e4c1a8a68d", "html_url": "https://github.com/rust-lang/rust/commit/d60dd6be87a1647db5434e9bf94994e4c1a8a68d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d60dd6be87a1647db5434e9bf94994e4c1a8a68d/comments", "author": null, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e349201bc26c2581e948aae53ac7701c34bef80c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e349201bc26c2581e948aae53ac7701c34bef80c", "html_url": "https://github.com/rust-lang/rust/commit/e349201bc26c2581e948aae53ac7701c34bef80c"}], "stats": {"total": 78, "additions": 59, "deletions": 19}, "files": [{"sha": "ef20807d2f119754d42bfa56543796e5c9597c51", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 59, "deletions": 19, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d60dd6be87a1647db5434e9bf94994e4c1a8a68d/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60dd6be87a1647db5434e9bf94994e4c1a8a68d/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=d60dd6be87a1647db5434e9bf94994e4c1a8a68d", "patch": "@@ -263,11 +263,25 @@ fn decode_form_urlencoded(s: ~[u8]) -> hashmap<~str, @dvec<@~str>> {\n \n \n fn split_char_first(s: ~str, c: char) -> (~str, ~str) {\n-    let mut v = str::splitn_char(s, c, 1);\n-    if v.len() == 1 {\n-        return (s, ~\"\");\n+    let len = str::len(s);\n+    let mut index = len;\n+    let mut match_ = 0;\n+    do io::with_str_reader(s) |rdr| {\n+        let mut ch : char;\n+        while !rdr.eof() {\n+            ch = rdr.read_byte() as char;\n+            if ch == c {\n+                // found a match, adjust markers\n+                index = rdr.tell()-1;\n+                match_ = 1;\n+                break;\n+            }\n+        }\n+    }\n+    if index+match_ == len {\n+        return (str::slice(s, 0, index), ~\"\");\n     } else {\n-        return (vec::shift(v), vec::pop(v));\n+        return (str::slice(s, 0, index), str::slice(s, index + match_, str::len(s)));\n     }\n }\n \n@@ -311,18 +325,30 @@ fn query_to_str(query: query) -> ~str {\n     return str::connect(strvec, ~\"&\");\n }\n \n-fn get_scheme(rawurl: ~str) -> option::option<(~str, ~str)> {\n+fn get_scheme(rawurl: ~str) -> result::result<(~str, ~str), @~str> {\n     for str::each_chari(rawurl) |i,c| {\n-        if char::is_alphabetic(c) {\n+        alt c {\n+          'A' to 'Z' | 'a' to 'z' { again; }\n+          '0' to '9' | '+' | '-' | '.' {\n+            if i == 0 {\n+                return result::err(@~\"url: Scheme must begin with a letter.\");\n+            }\n             again;\n-        } else if c == ':' && i != 0 {\n-            return option::some((rawurl.slice(0,i),\n-                              rawurl.slice(i+3,str::len(rawurl))));\n-        } else {\n-            return option::none;\n+          }\n+          ':' {\n+            if i == 0 {\n+                return result::err(@~\"url: Scheme cannot be empty.\");\n+            } else {\n+                return result::ok((rawurl.slice(0,i),\n+                                rawurl.slice(i+3,str::len(rawurl))));\n+            }\n+          }\n+          _  {\n+            return result::err(@~\"url: Invalid character in scheme.\");\n+          }\n         }\n     };\n-    return option::none;\n+    return result::ok((copy rawurl, ~\"\"));\n }\n \n /**\n@@ -340,10 +366,10 @@ fn get_scheme(rawurl: ~str) -> option::option<(~str, ~str)> {\n \n fn from_str(rawurl: ~str) -> result::result<url, ~str> {\n     let mut schm = get_scheme(rawurl);\n-    if option::is_none(schm) {\n-        return result::err(~\"invalid scheme\");\n+    if result::is_err(schm) {\n+        return result::err(copy *result::get_err(schm));\n     }\n-    let (scheme, rest) = option::unwrap(schm);\n+    let (scheme, rest) = result::unwrap(schm);\n     let (u, rest) = split_char_first(rest, '@');\n     let user = if str::len(rest) == 0 {\n         option::none\n@@ -421,18 +447,32 @@ impl of to_str::to_str for url {\n \n #[cfg(test)]\n mod tests {\n+    #[test]\n+    fn test_split_char_first() {\n+        let (u,v) = split_char_first(~\"hello, sweet world\", ',');\n+        assert u == ~\"hello\";\n+        assert v == ~\" sweet world\";\n+    }\n+\n     #[test]\n     fn test_url_parse() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n         let u = result::unwrap(from_str(url));\n         assert u.scheme == ~\"http\";\n-        assert option::unwrap(u.user).user == ~\"user\";\n-        assert option::unwrap(option::unwrap(u.user).pass) == ~\"pass\";\n+        assert option::unwrap(copy u.user).user == ~\"user\";\n+        assert option::unwrap(copy option::unwrap(copy u.user).pass) == ~\"pass\";\n         assert u.host == ~\"rust-lang.org\";\n         assert u.path == ~\"/doc\";\n-        assert u.query.get(~\"s\") == ~\"v\";\n-        assert option::unwrap(u.fragment) == \"something\";\n+        assert u.query.find(|kv| kv.first() == ~\"s\").get().second() == ~\"v\";\n+        assert option::unwrap(copy u.fragment) == ~\"something\";\n     }\n+\n+    #[test]\n+    fn test_invalid_scheme_errors() {\n+        assert result::is_err(from_str(~\"99://something\"));\n+        assert result::is_err(from_str(~\"://something\"));\n+    }\n+\n     #[test]\n     fn test_full_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";"}]}