{"sha": "b85944456224ee7a824486415cb093ae518dd0cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NTk0NDQ1NjIyNGVlN2E4MjQ0ODY0MTVjYjA5M2FlNTE4ZGQwY2I=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-10T00:52:44Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-10T00:52:53Z"}, "message": "Do or do not.", "tree": {"sha": "9b3a7d85aa69f7a75cc565849cf947d5f271ae7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b3a7d85aa69f7a75cc565849cf947d5f271ae7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b85944456224ee7a824486415cb093ae518dd0cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b85944456224ee7a824486415cb093ae518dd0cb", "html_url": "https://github.com/rust-lang/rust/commit/b85944456224ee7a824486415cb093ae518dd0cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b85944456224ee7a824486415cb093ae518dd0cb/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4792b8a873826d07c82d1c56933fc7d97779f62e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4792b8a873826d07c82d1c56933fc7d97779f62e", "html_url": "https://github.com/rust-lang/rust/commit/4792b8a873826d07c82d1c56933fc7d97779f62e"}], "stats": {"total": 310, "additions": 154, "deletions": 156}, "files": [{"sha": "d86dbdbe6877fe82e5bebd11ee7834a0317d08d2", "filename": "src/interpreter.rs", "status": "modified", "additions": 122, "deletions": 125, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/b85944456224ee7a824486415cb093ae518dd0cb/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85944456224ee7a824486415cb093ae518dd0cb/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=b85944456224ee7a824486415cb093ae518dd0cb", "patch": "@@ -186,14 +186,14 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     self.log(0, || print!(\"{:?}\", stmt));\n                     let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n                     let result = self.eval_assignment(lvalue, rvalue);\n-                    try!(self.maybe_report(stmt.span, result));\n+                    self.maybe_report(stmt.span, result)?;\n                 }\n \n                 let terminator = block_data.terminator();\n                 self.log(0, || print!(\"{:?}\", terminator.kind));\n \n                 let result = self.eval_terminator(terminator);\n-                match try!(self.maybe_report(terminator.span, result)) {\n+                match self.maybe_report(terminator.span, result)? {\n                     TerminatorTarget::Block(block) => current_block = block,\n                     TerminatorTarget::Return => {\n                         self.pop_stack_frame();\n@@ -221,7 +221,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n         let substs = nested_fecx.substs();\n         nested_fecx.push_stack_frame(CachedMir::Ref(mir), substs, return_ptr);\n-        try!(nested_fecx.run());\n+        nested_fecx.run()?;\n         Ok(return_ptr)\n     }\n \n@@ -267,25 +267,25 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             Goto { target } => TerminatorTarget::Block(target),\n \n             If { ref cond, targets: (then_target, else_target) } => {\n-                let cond_ptr = try!(self.eval_operand(cond));\n-                let cond_val = try!(self.memory.read_bool(cond_ptr));\n+                let cond_ptr = self.eval_operand(cond)?;\n+                let cond_val = self.memory.read_bool(cond_ptr)?;\n                 TerminatorTarget::Block(if cond_val { then_target } else { else_target })\n             }\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                let discr_ptr = try!(self.eval_lvalue(discr)).to_ptr();\n+                let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n                 let discr_size = self\n                     .type_layout(self.lvalue_ty(discr))\n                     .size(&self.tcx.data_layout)\n                     .bytes() as usize;\n-                let discr_val = try!(self.memory.read_uint(discr_ptr, discr_size));\n+                let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, val_const) in values.iter().enumerate() {\n-                    let ptr = try!(self.const_to_ptr(val_const));\n-                    let val = try!(self.memory.read_uint(ptr, discr_size));\n+                    let ptr = self.const_to_ptr(val_const)?;\n+                    let val = self.memory.read_uint(ptr, discr_size)?;\n                     if discr_val == val {\n                         target_block = targets[index];\n                         break;\n@@ -296,13 +296,13 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             }\n \n             Switch { ref discr, ref targets, adt_def } => {\n-                let adt_ptr = try!(self.eval_lvalue(discr)).to_ptr();\n+                let adt_ptr = self.eval_lvalue(discr)?.to_ptr();\n                 let adt_layout = self.type_layout(self.lvalue_ty(discr));\n \n                  match *adt_layout {\n                     Layout::General { discr, .. } | Layout::CEnum { discr, .. } => {\n                         let discr_size = discr.size().bytes();\n-                        let discr_val = try!(self.memory.read_uint(adt_ptr, discr_size as usize));\n+                        let discr_val = self.memory.read_uint(adt_ptr, discr_size as usize)?;\n \n                         let matching = adt_def.variants.iter()\n                             .position(|v| discr_val == v.disr_val.to_u64_unchecked());\n@@ -333,7 +333,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 let mut return_ptr = None;\n                 if let Some((ref lv, target)) = *destination {\n                     self.frame_mut().next_block = target;\n-                    return_ptr = Some(try!(self.eval_lvalue(lv)).to_ptr());\n+                    return_ptr = Some(self.eval_lvalue(lv)?.to_ptr());\n                 }\n \n                 let func_ty = self.operand_ty(func);\n@@ -346,15 +346,14 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                 match fn_ty.sig.0.output {\n                                     ty::FnConverging(ty) => {\n                                         let size = self.type_size(ty);\n-                                        try!(self.call_intrinsic(&name, substs, args,\n-                                            return_ptr.unwrap(), size))\n+                                        self.call_intrinsic(&name, substs, args,\n+                                            return_ptr.unwrap(), size)?\n                                     }\n                                     ty::FnDiverging => unimplemented!(),\n                                 }\n                             }\n \n-                            Abi::C =>\n-                                try!(self.call_c_abi(def_id, args, return_ptr.unwrap())),\n+                            Abi::C => self.call_c_abi(def_id, args, return_ptr.unwrap())?,\n \n                             Abi::Rust | Abi::RustCall => {\n                                 // TODO(tsion): Adjust the first argument when calling a Fn or\n@@ -369,15 +368,15 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n                                 let mut arg_srcs = Vec::new();\n                                 for arg in args {\n-                                    let src = try!(self.eval_operand(arg));\n+                                    let src = self.eval_operand(arg)?;\n                                     let src_ty = self.operand_ty(arg);\n                                     arg_srcs.push((src, src_ty));\n                                 }\n \n                                 if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n                                     arg_srcs.pop();\n                                     let last_arg = args.last().unwrap();\n-                                    let last = try!(self.eval_operand(last_arg));\n+                                    let last = self.eval_operand(last_arg)?;\n                                     let last_ty = self.operand_ty(last_arg);\n                                     let last_layout = self.type_layout(last_ty);\n                                     match (&last_ty.sty, last_layout) {\n@@ -401,7 +400,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n                                 for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n                                     let dest = self.frame().locals[i];\n-                                    try!(self.move_(src, dest, src_ty));\n+                                    self.move_(src, dest, src_ty)?;\n                                 }\n \n                                 TerminatorTarget::Call\n@@ -416,9 +415,9 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             }\n \n             Drop { ref value, target, .. } => {\n-                let ptr = try!(self.eval_lvalue(value)).to_ptr();\n+                let ptr = self.eval_lvalue(value)?.to_ptr();\n                 let ty = self.lvalue_ty(value);\n-                try!(self.drop(ptr, ty));\n+                self.drop(ptr, ty)?;\n                 TerminatorTarget::Block(target)\n             }\n \n@@ -441,13 +440,13 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             ty::TyBox(contents_ty) => {\n                 match self.memory.read_ptr(ptr) {\n                     Ok(contents_ptr) => {\n-                        try!(self.drop(contents_ptr, contents_ty));\n+                        self.drop(contents_ptr, contents_ty)?;\n                         self.log(1, || print!(\"deallocating box\"));\n-                        try!(self.memory.deallocate(contents_ptr));\n+                        self.memory.deallocate(contents_ptr)?;\n                     }\n                     Err(EvalError::ReadBytesAsPointer) => {\n                         let size = self.memory.pointer_size;\n-                        let possible_drop_fill = try!(self.memory.read_bytes(ptr, size));\n+                        let possible_drop_fill = self.memory.read_bytes(ptr, size)?;\n                         if possible_drop_fill.iter().all(|&b| b == mem::POST_DROP_U8) {\n                             return Ok(());\n                         } else {\n@@ -465,7 +464,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         // Filling drop.\n         // FIXME(tsion): Trait objects (with no static size) probably get filled, too.\n         let size = self.type_size(ty);\n-        try!(self.memory.drop_fill(ptr, size));\n+        self.memory.drop_fill(ptr, size)?;\n \n         Ok(())\n     }\n@@ -481,79 +480,79 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         let args_res: EvalResult<Vec<Pointer>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n-        let args = try!(args_res);\n+        let args = args_res?;\n \n         match name {\n             \"assume\" => {}\n \n             \"copy_nonoverlapping\" => {\n                 let elem_ty = *substs.types.get(subst::FnSpace, 0);\n                 let elem_size = self.type_size(elem_ty);\n-                let src = try!(self.memory.read_ptr(args[0]));\n-                let dest = try!(self.memory.read_ptr(args[1]));\n-                let count = try!(self.memory.read_isize(args[2]));\n-                try!(self.memory.copy(src, dest, count as usize * elem_size));\n+                let src = self.memory.read_ptr(args[0])?;\n+                let dest = self.memory.read_ptr(args[1])?;\n+                let count = self.memory.read_isize(args[2])?;\n+                self.memory.copy(src, dest, count as usize * elem_size)?;\n             }\n \n             \"forget\" => {\n                 let arg_ty = *substs.types.get(subst::FnSpace, 0);\n                 let arg_size = self.type_size(arg_ty);\n-                try!(self.memory.drop_fill(args[0], arg_size));\n+                self.memory.drop_fill(args[0], arg_size)?;\n             }\n \n-            \"init\" => try!(self.memory.write_repeat(dest, 0, dest_size)),\n+            \"init\" => self.memory.write_repeat(dest, 0, dest_size)?,\n \n             \"min_align_of\" => {\n-                try!(self.memory.write_int(dest, 1, dest_size));\n+                self.memory.write_int(dest, 1, dest_size)?;\n             }\n \n             \"move_val_init\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let ptr = try!(self.memory.read_ptr(args[0]));\n-                try!(self.move_(args[1], ptr, ty));\n+                let ptr = self.memory.read_ptr(args[0])?;\n+                self.move_(args[1], ptr, ty)?;\n             }\n \n             // FIXME(tsion): Handle different integer types correctly.\n             \"add_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 let size = self.type_size(ty);\n-                let left = try!(self.memory.read_int(args[0], size));\n-                let right = try!(self.memory.read_int(args[1], size));\n+                let left = self.memory.read_int(args[0], size)?;\n+                let right = self.memory.read_int(args[1], size)?;\n                 let (n, overflowed) = unsafe {\n                     ::std::intrinsics::add_with_overflow::<i64>(left, right)\n                 };\n-                try!(self.memory.write_int(dest, n, size));\n-                try!(self.memory.write_bool(dest.offset(size as isize), overflowed));\n+                self.memory.write_int(dest, n, size)?;\n+                self.memory.write_bool(dest.offset(size as isize), overflowed)?;\n             }\n \n             // FIXME(tsion): Handle different integer types correctly.\n             \"mul_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 let size = self.type_size(ty);\n-                let left = try!(self.memory.read_int(args[0], size));\n-                let right = try!(self.memory.read_int(args[1], size));\n+                let left = self.memory.read_int(args[0], size)?;\n+                let right = self.memory.read_int(args[1], size)?;\n                 let (n, overflowed) = unsafe {\n                     ::std::intrinsics::mul_with_overflow::<i64>(left, right)\n                 };\n-                try!(self.memory.write_int(dest, n, size));\n-                try!(self.memory.write_bool(dest.offset(size as isize), overflowed));\n+                self.memory.write_int(dest, n, size)?;\n+                self.memory.write_bool(dest.offset(size as isize), overflowed)?;\n             }\n \n             \"offset\" => {\n                 let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n                 let pointee_size = self.type_size(pointee_ty) as isize;\n                 let ptr_arg = args[0];\n-                let offset = try!(self.memory.read_isize(args[1]));\n+                let offset = self.memory.read_isize(args[1])?;\n \n                 match self.memory.read_ptr(ptr_arg) {\n                     Ok(ptr) => {\n                         let result_ptr = ptr.offset(offset as isize * pointee_size);\n-                        try!(self.memory.write_ptr(dest, result_ptr));\n+                        self.memory.write_ptr(dest, result_ptr)?;\n                     }\n                     Err(EvalError::ReadBytesAsPointer) => {\n-                        let addr = try!(self.memory.read_isize(ptr_arg));\n+                        let addr = self.memory.read_isize(ptr_arg)?;\n                         let result_addr = addr + offset * pointee_size as i64;\n-                        try!(self.memory.write_isize(dest, result_addr));\n+                        self.memory.write_isize(dest, result_addr)?;\n                     }\n                     Err(e) => return Err(e),\n                 }\n@@ -563,23 +562,23 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             \"overflowing_sub\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 let size = self.type_size(ty);\n-                let left = try!(self.memory.read_int(args[0], size));\n-                let right = try!(self.memory.read_int(args[1], size));\n+                let left = self.memory.read_int(args[0], size)?;\n+                let right = self.memory.read_int(args[1], size)?;\n                 let n = left.wrapping_sub(right);\n-                try!(self.memory.write_int(dest, n, size));\n+                self.memory.write_int(dest, n, size)?;\n             }\n \n             \"size_of\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 let size = self.type_size(ty) as u64;\n-                try!(self.memory.write_uint(dest, size, dest_size));\n+                self.memory.write_uint(dest, size, dest_size)?;\n             }\n \n             \"transmute\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                try!(self.move_(args[0], dest, ty));\n+                self.move_(args[0], dest, ty)?;\n             }\n-            \"uninit\" => try!(self.memory.mark_definedness(dest, dest_size, false)),\n+            \"uninit\" => self.memory.mark_definedness(dest, dest_size, false)?,\n \n             name => panic!(\"can't handle intrinsic: {}\", name),\n         }\n@@ -606,20 +605,20 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         let args_res: EvalResult<Vec<Pointer>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n-        let args = try!(args_res);\n+        let args = args_res?;\n \n         match &link_name[..] {\n             \"__rust_allocate\" => {\n-                let size = try!(self.memory.read_usize(args[0]));\n+                let size = self.memory.read_usize(args[0])?;\n                 let ptr = self.memory.allocate(size as usize);\n-                try!(self.memory.write_ptr(dest, ptr));\n+                self.memory.write_ptr(dest, ptr)?;\n             }\n \n             \"__rust_reallocate\" => {\n-                let ptr = try!(self.memory.read_ptr(args[0]));\n-                let size = try!(self.memory.read_usize(args[2]));\n-                try!(self.memory.reallocate(ptr, size as usize));\n-                try!(self.memory.write_ptr(dest, ptr));\n+                let ptr = self.memory.read_ptr(args[0])?;\n+                let size = self.memory.read_usize(args[2])?;\n+                self.memory.reallocate(ptr, size as usize)?;\n+                self.memory.write_ptr(dest, ptr)?;\n             }\n \n             _ => panic!(\"can't call C ABI function: {}\", link_name),\n@@ -638,46 +637,46 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         operands: &[mir::Operand<'tcx>],\n     ) -> EvalResult<()> {\n         for (offset, operand) in offsets.into_iter().zip(operands) {\n-            let src = try!(self.eval_operand(operand));\n+            let src = self.eval_operand(operand)?;\n             let src_ty = self.operand_ty(operand);\n             let field_dest = dest.offset(offset as isize);\n-            try!(self.move_(src, field_dest, src_ty));\n+            self.move_(src, field_dest, src_ty)?;\n         }\n         Ok(())\n     }\n \n     fn eval_assignment(&mut self, lvalue: &mir::Lvalue<'tcx>, rvalue: &mir::Rvalue<'tcx>)\n         -> EvalResult<()>\n     {\n-        let dest = try!(self.eval_lvalue(lvalue)).to_ptr();\n+        let dest = self.eval_lvalue(lvalue)?.to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n         let dest_layout = self.type_layout(dest_ty);\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n             Use(ref operand) => {\n-                let src = try!(self.eval_operand(operand));\n-                try!(self.move_(src, dest, dest_ty));\n+                let src = self.eval_operand(operand)?;\n+                self.move_(src, dest, dest_ty)?;\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n-                let left_ptr = try!(self.eval_operand(left));\n+                let left_ptr = self.eval_operand(left)?;\n                 let left_ty = self.operand_ty(left);\n-                let left_val = try!(self.read_primval(left_ptr, left_ty));\n+                let left_val = self.read_primval(left_ptr, left_ty)?;\n \n-                let right_ptr = try!(self.eval_operand(right));\n+                let right_ptr = self.eval_operand(right)?;\n                 let right_ty = self.operand_ty(right);\n-                let right_val = try!(self.read_primval(right_ptr, right_ty));\n+                let right_val = self.read_primval(right_ptr, right_ty)?;\n \n-                let val = try!(primval::binary_op(bin_op, left_val, right_val));\n-                try!(self.memory.write_primval(dest, val));\n+                let val = primval::binary_op(bin_op, left_val, right_val)?;\n+                self.memory.write_primval(dest, val)?;\n             }\n \n             UnaryOp(un_op, ref operand) => {\n-                let ptr = try!(self.eval_operand(operand));\n+                let ptr = self.eval_operand(operand)?;\n                 let ty = self.operand_ty(operand);\n-                let val = try!(self.read_primval(ptr, ty));\n-                try!(self.memory.write_primval(dest, primval::unary_op(un_op, val)));\n+                let val = self.read_primval(ptr, ty)?;\n+                self.memory.write_primval(dest, primval::unary_op(un_op, val))?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n@@ -686,7 +685,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     Univariant { ref variant, .. } => {\n                         let offsets = iter::once(0)\n                             .chain(variant.offset_after_field.iter().map(|s| s.bytes()));\n-                        try!(self.assign_fields(dest, offsets, operands));\n+                        self.assign_fields(dest, offsets, operands)?;\n                     }\n \n                     Array { .. } => {\n@@ -696,18 +695,18 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                         kind, dest_ty),\n                         };\n                         let offsets = (0..).map(|i| i * elem_size);\n-                        try!(self.assign_fields(dest, offsets, operands));\n+                        self.assign_fields(dest, offsets, operands)?;\n                     }\n \n                     General { discr, ref variants, .. } => {\n                         if let mir::AggregateKind::Adt(adt_def, variant, _) = *kind {\n                             let discr_val = adt_def.variants[variant].disr_val.to_u64_unchecked();\n                             let discr_size = discr.size().bytes() as usize;\n-                            try!(self.memory.write_uint(dest, discr_val, discr_size));\n+                            self.memory.write_uint(dest, discr_val, discr_size)?;\n \n                             let offsets = variants[variant].offset_after_field.iter()\n                                 .map(|s| s.bytes());\n-                            try!(self.assign_fields(dest, offsets, operands));\n+                            self.assign_fields(dest, offsets, operands)?;\n                         } else {\n                             panic!(\"tried to assign {:?} to Layout::General\", kind);\n                         }\n@@ -718,12 +717,12 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                             if nndiscr == variant as u64 {\n                                 assert_eq!(operands.len(), 1);\n                                 let operand = &operands[0];\n-                                let src = try!(self.eval_operand(operand));\n+                                let src = self.eval_operand(operand)?;\n                                 let src_ty = self.operand_ty(operand);\n-                                try!(self.move_(src, dest, src_ty));\n+                                self.move_(src, dest, src_ty)?;\n                             } else {\n                                 assert_eq!(operands.len(), 0);\n-                                try!(self.memory.write_isize(dest, 0));\n+                                self.memory.write_isize(dest, 0)?;\n                             }\n                         } else {\n                             panic!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n@@ -737,9 +736,9 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                             let size = discr.size().bytes() as usize;\n \n                             if signed {\n-                                try!(self.memory.write_int(dest, val as i64, size));\n+                                self.memory.write_int(dest, val as i64, size)?;\n                             } else {\n-                                try!(self.memory.write_uint(dest, val, size));\n+                                self.memory.write_uint(dest, val, size)?;\n                             }\n                         } else {\n                             panic!(\"tried to assign {:?} to Layout::CEnum\", kind);\n@@ -757,15 +756,15 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     _ => panic!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n \n-                let src = try!(self.eval_operand(operand));\n+                let src = self.eval_operand(operand)?;\n                 for i in 0..length {\n                     let elem_dest = dest.offset((i * elem_size) as isize);\n-                    try!(self.memory.copy(src, elem_dest, elem_size));\n+                    self.memory.copy(src, elem_dest, elem_size)?;\n                 }\n             }\n \n             Len(ref lvalue) => {\n-                let src = try!(self.eval_lvalue(lvalue));\n+                let src = self.eval_lvalue(lvalue)?;\n                 let ty = self.lvalue_ty(lvalue);\n                 let len = match ty.sty {\n                     ty::TyArray(_, n) => n as u64,\n@@ -776,17 +775,17 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     },\n                     _ => panic!(\"Rvalue::Len expected array or slice, got {:?}\", ty),\n                 };\n-                try!(self.memory.write_usize(dest, len));\n+                self.memory.write_usize(dest, len)?;\n             }\n \n             Ref(_, _, ref lvalue) => {\n-                let lv = try!(self.eval_lvalue(lvalue));\n-                try!(self.memory.write_ptr(dest, lv.ptr));\n+                let lv = self.eval_lvalue(lvalue)?;\n+                self.memory.write_ptr(dest, lv.ptr)?;\n                 match lv.extra {\n                     LvalueExtra::None => {},\n                     LvalueExtra::Length(len) => {\n                         let len_ptr = dest.offset(self.memory.pointer_size as isize);\n-                        try!(self.memory.write_usize(len_ptr, len));\n+                        self.memory.write_usize(len_ptr, len)?;\n                     }\n                     LvalueExtra::DowncastVariant(..) =>\n                         panic!(\"attempted to take a reference to an enum downcast lvalue\"),\n@@ -796,24 +795,24 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             Box(ty) => {\n                 let size = self.type_size(ty);\n                 let ptr = self.memory.allocate(size);\n-                try!(self.memory.write_ptr(dest, ptr));\n+                self.memory.write_ptr(dest, ptr)?;\n             }\n \n             Cast(kind, ref operand, dest_ty) => {\n-                let src = try!(self.eval_operand(operand));\n+                let src = self.eval_operand(operand)?;\n                 let src_ty = self.operand_ty(operand);\n \n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n                     Unsize => {\n-                        try!(self.move_(src, dest, src_ty));\n+                        self.move_(src, dest, src_ty)?;\n                         let src_pointee_ty = pointee_type(src_ty).unwrap();\n                         let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n \n                         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n                             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                                 let len_ptr = dest.offset(self.memory.pointer_size as isize);\n-                                try!(self.memory.write_usize(len_ptr, length as u64));\n+                                self.memory.write_usize(len_ptr, length as u64)?;\n                             }\n \n                             _ => panic!(\"can't handle cast: {:?}\", rvalue),\n@@ -823,7 +822,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     Misc => {\n                         // FIXME(tsion): Wrong for almost everything.\n                         let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n-                        try!(self.memory.copy(src, dest, size));\n+                        self.memory.copy(src, dest, size)?;\n                     }\n \n                     _ => panic!(\"can't handle cast: {:?}\", rvalue),\n@@ -840,12 +839,11 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<Pointer> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n-            Consume(ref lvalue) =>\n-                Ok(try!(self.eval_lvalue(lvalue)).to_ptr()),\n+            Consume(ref lvalue) => Ok(self.eval_lvalue(lvalue)?.to_ptr()),\n             Constant(mir::Constant { ref literal, .. }) => {\n                 use rustc::mir::repr::Literal::*;\n                 match *literal {\n-                    Value { ref value } => Ok(try!(self.const_to_ptr(value))),\n+                    Value { ref value } => Ok(self.const_to_ptr(value)?),\n                     Item { .. } => unimplemented!(),\n                     Promoted { index } => {\n                         let current_mir = self.mir();\n@@ -869,7 +867,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             Static(_def_id) => unimplemented!(),\n \n             Projection(ref proj) => {\n-                let base = try!(self.eval_lvalue(&proj.base));\n+                let base = self.eval_lvalue(&proj.base)?;\n                 let base_ty = self.lvalue_ty(&proj.base);\n                 let base_layout = self.type_layout(base_ty);\n \n@@ -909,11 +907,11 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n                     Deref => {\n                         let pointee_ty = pointee_type(base_ty).expect(\"Deref of non-pointer\");\n-                        let ptr = try!(self.memory.read_ptr(base.ptr));\n+                        let ptr = self.memory.read_ptr(base.ptr)?;\n                         let extra = match pointee_ty.sty {\n                             ty::TySlice(_) | ty::TyStr => {\n                                 let len_ptr = base.ptr.offset(self.memory.pointer_size as isize);\n-                                let len = try!(self.memory.read_usize(len_ptr));\n+                                let len = self.memory.read_usize(len_ptr)?;\n                                 LvalueExtra::Length(len)\n                             }\n                             ty::TyTrait(_) => unimplemented!(),\n@@ -928,8 +926,8 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                             ty::TySlice(elem_ty) => self.type_size(elem_ty),\n                             _ => panic!(\"indexing expected an array or slice, got {:?}\", base_ty),\n                         };\n-                        let n_ptr = try!(self.eval_operand(operand));\n-                        let n = try!(self.memory.read_usize(n_ptr));\n+                        let n_ptr = self.eval_operand(operand)?;\n+                        let n = self.memory.read_usize(n_ptr)?;\n                         base.ptr.offset(n as isize * elem_size as isize)\n                     }\n \n@@ -949,29 +947,29 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             Integral(int) => {\n                 // TODO(tsion): Check int constant type.\n                 let ptr = self.memory.allocate(8);\n-                try!(self.memory.write_uint(ptr, int.to_u64_unchecked(), 8));\n+                self.memory.write_uint(ptr, int.to_u64_unchecked(), 8)?;\n                 Ok(ptr)\n             }\n             Str(ref s) => {\n                 let psize = self.memory.pointer_size;\n                 let static_ptr = self.memory.allocate(s.len());\n                 let ptr = self.memory.allocate(psize * 2);\n-                try!(self.memory.write_bytes(static_ptr, s.as_bytes()));\n-                try!(self.memory.write_ptr(ptr, static_ptr));\n-                try!(self.memory.write_usize(ptr.offset(psize as isize), s.len() as u64));\n+                self.memory.write_bytes(static_ptr, s.as_bytes())?;\n+                self.memory.write_ptr(ptr, static_ptr)?;\n+                self.memory.write_usize(ptr.offset(psize as isize), s.len() as u64)?;\n                 Ok(ptr)\n             }\n             ByteStr(ref bs) => {\n                 let psize = self.memory.pointer_size;\n                 let static_ptr = self.memory.allocate(bs.len());\n                 let ptr = self.memory.allocate(psize);\n-                try!(self.memory.write_bytes(static_ptr, bs));\n-                try!(self.memory.write_ptr(ptr, static_ptr));\n+                self.memory.write_bytes(static_ptr, bs)?;\n+                self.memory.write_ptr(ptr, static_ptr)?;\n                 Ok(ptr)\n             }\n             Bool(b) => {\n                 let ptr = self.memory.allocate(1);\n-                try!(self.memory.write_bool(ptr, b));\n+                self.memory.write_bool(ptr, b)?;\n                 Ok(ptr)\n             }\n             Char(_c)          => unimplemented!(),\n@@ -1003,9 +1001,9 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n     fn move_(&mut self, src: Pointer, dest: Pointer, ty: ty::Ty<'tcx>) -> EvalResult<()> {\n         let size = self.type_size(ty);\n-        try!(self.memory.copy(src, dest, size));\n+        self.memory.copy(src, dest, size)?;\n         if self.type_needs_drop(ty) {\n-            try!(self.memory.drop_fill(src, size));\n+            self.memory.drop_fill(src, size)?;\n         }\n         Ok(())\n     }\n@@ -1031,28 +1029,27 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     pub fn read_primval(&mut self, ptr: Pointer, ty: ty::Ty<'tcx>) -> EvalResult<PrimVal> {\n         use syntax::ast::{IntTy, UintTy};\n         let val = match ty.sty {\n-            ty::TyBool              => PrimVal::Bool(try!(self.memory.read_bool(ptr))),\n-            ty::TyInt(IntTy::I8)    => PrimVal::I8(try!(self.memory.read_int(ptr, 1)) as i8),\n-            ty::TyInt(IntTy::I16)   => PrimVal::I16(try!(self.memory.read_int(ptr, 2)) as i16),\n-            ty::TyInt(IntTy::I32)   => PrimVal::I32(try!(self.memory.read_int(ptr, 4)) as i32),\n-            ty::TyInt(IntTy::I64)   => PrimVal::I64(try!(self.memory.read_int(ptr, 8)) as i64),\n-            ty::TyUint(UintTy::U8)  => PrimVal::U8(try!(self.memory.read_uint(ptr, 1)) as u8),\n-            ty::TyUint(UintTy::U16) => PrimVal::U16(try!(self.memory.read_uint(ptr, 2)) as u16),\n-            ty::TyUint(UintTy::U32) => PrimVal::U32(try!(self.memory.read_uint(ptr, 4)) as u32),\n-            ty::TyUint(UintTy::U64) => PrimVal::U64(try!(self.memory.read_uint(ptr, 8)) as u64),\n+            ty::TyBool              => PrimVal::Bool(self.memory.read_bool(ptr)?),\n+            ty::TyInt(IntTy::I8)    => PrimVal::I8(self.memory.read_int(ptr, 1)? as i8),\n+            ty::TyInt(IntTy::I16)   => PrimVal::I16(self.memory.read_int(ptr, 2)? as i16),\n+            ty::TyInt(IntTy::I32)   => PrimVal::I32(self.memory.read_int(ptr, 4)? as i32),\n+            ty::TyInt(IntTy::I64)   => PrimVal::I64(self.memory.read_int(ptr, 8)? as i64),\n+            ty::TyUint(UintTy::U8)  => PrimVal::U8(self.memory.read_uint(ptr, 1)? as u8),\n+            ty::TyUint(UintTy::U16) => PrimVal::U16(self.memory.read_uint(ptr, 2)? as u16),\n+            ty::TyUint(UintTy::U32) => PrimVal::U32(self.memory.read_uint(ptr, 4)? as u32),\n+            ty::TyUint(UintTy::U64) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n \n             // TODO(tsion): Pick the PrimVal dynamically.\n-            ty::TyInt(IntTy::Is)   => PrimVal::I64(try!(self.memory.read_isize(ptr))),\n-            ty::TyUint(UintTy::Us) => PrimVal::U64(try!(self.memory.read_usize(ptr))),\n+            ty::TyInt(IntTy::Is)   => PrimVal::I64(self.memory.read_isize(ptr)?),\n+            ty::TyUint(UintTy::Us) => PrimVal::U64(self.memory.read_usize(ptr)?),\n \n             ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                 if self.type_is_sized(ty) {\n                     match self.memory.read_ptr(ptr) {\n                         Ok(p) => PrimVal::AbstractPtr(p),\n                         Err(EvalError::ReadBytesAsPointer) => {\n-                            let n = try!(self.memory.read_usize(ptr));\n-                            PrimVal::IntegerPtr(n)\n+                            PrimVal::IntegerPtr(self.memory.read_usize(ptr)?)\n                         }\n                         Err(e) => return Err(e),\n                     }"}, {"sha": "623ed14be76ea7f219c8ad5890b843881566bbb9", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b85944456224ee7a824486415cb093ae518dd0cb/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85944456224ee7a824486415cb093ae518dd0cb/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b85944456224ee7a824486415cb093ae518dd0cb", "patch": "@@ -4,6 +4,7 @@\n     collections_bound,\n     core_intrinsics,\n     filling_drop,\n+    question_mark,\n     rustc_private,\n )]\n "}, {"sha": "bf53c599bd77512d990f4d8d90789838f3bc8f99", "filename": "src/memory.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b85944456224ee7a824486415cb093ae518dd0cb/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85944456224ee7a824486415cb093ae518dd0cb/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=b85944456224ee7a824486415cb093ae518dd0cb", "patch": "@@ -83,7 +83,7 @@ impl Memory {\n             panic!()\n         }\n \n-        let alloc = try!(self.get_mut(ptr.alloc_id));\n+        let alloc = self.get_mut(ptr.alloc_id)?;\n         let size = alloc.bytes.len();\n         if new_size > size {\n             let amount = new_size - size;\n@@ -181,32 +181,32 @@ impl Memory {\n     ////////////////////////////////////////////////////////////////////////////////\n \n     fn get_bytes_unchecked(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n-        let alloc = try!(self.get(ptr.alloc_id));\n+        let alloc = self.get(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n             return Err(EvalError::PointerOutOfBounds);\n         }\n         Ok(&alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n     fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n-        let alloc = try!(self.get_mut(ptr.alloc_id));\n+        let alloc = self.get_mut(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n             return Err(EvalError::PointerOutOfBounds);\n         }\n         Ok(&mut alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n     fn get_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n-        if try!(self.relocations(ptr, size)).count() != 0 {\n+        if self.relocations(ptr, size)?.count() != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }\n-        try!(self.check_defined(ptr, size));\n+        self.check_defined(ptr, size)?;\n         self.get_bytes_unchecked(ptr, size)\n     }\n \n     fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n-        try!(self.clear_relocations(ptr, size));\n-        try!(self.mark_definedness(ptr, size, true));\n+        self.clear_relocations(ptr, size)?;\n+        self.mark_definedness(ptr, size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size)\n     }\n \n@@ -215,10 +215,10 @@ impl Memory {\n     ////////////////////////////////////////////////////////////////////////////////\n \n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n-        try!(self.check_relocation_edges(src, size));\n+        self.check_relocation_edges(src, size)?;\n \n-        let src_bytes = try!(self.get_bytes_unchecked_mut(src, size)).as_mut_ptr();\n-        let dest_bytes = try!(self.get_bytes_mut(dest, size)).as_mut_ptr();\n+        let src_bytes = self.get_bytes_unchecked_mut(src, size)?.as_mut_ptr();\n+        let dest_bytes = self.get_bytes_mut(dest, size)?.as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n@@ -231,8 +231,8 @@ impl Memory {\n             }\n         }\n \n-        try!(self.copy_undef_mask(src, dest, size));\n-        try!(self.copy_relocations(src, dest, size));\n+        self.copy_undef_mask(src, dest, size)?;\n+        self.copy_relocations(src, dest, size)?;\n \n         Ok(())\n     }\n@@ -242,13 +242,13 @@ impl Memory {\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<()> {\n-        let bytes = try!(self.get_bytes_mut(ptr, src.len()));\n+        let bytes = self.get_bytes_mut(ptr, src.len())?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: usize) -> EvalResult<()> {\n-        let bytes = try!(self.get_bytes_mut(ptr, count));\n+        let bytes = self.get_bytes_mut(ptr, count)?;\n         for b in bytes { *b = val; }\n         Ok(())\n     }\n@@ -259,10 +259,10 @@ impl Memory {\n \n     pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<Pointer> {\n         let size = self.pointer_size;\n-        try!(self.check_defined(ptr, size));\n-        let offset = try!(self.get_bytes_unchecked(ptr, size))\n+        self.check_defined(ptr, size)?;\n+        let offset = self.get_bytes_unchecked(ptr, size)?\n             .read_uint::<NativeEndian>(size).unwrap() as usize;\n-        let alloc = try!(self.get(ptr.alloc_id));\n+        let alloc = self.get(ptr.alloc_id)?;\n         match alloc.relocations.get(&ptr.offset) {\n             Some(&alloc_id) => Ok(Pointer { alloc_id: alloc_id, offset: offset }),\n             None => Err(EvalError::ReadBytesAsPointer),\n@@ -272,10 +272,10 @@ impl Memory {\n     pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<()> {\n         {\n             let size = self.pointer_size;\n-            let mut bytes = try!(self.get_bytes_mut(dest, size));\n+            let mut bytes = self.get_bytes_mut(dest, size)?;\n             bytes.write_uint::<NativeEndian>(ptr.offset as u64, size).unwrap();\n         }\n-        try!(self.get_mut(dest.alloc_id)).relocations.insert(dest.offset, ptr.alloc_id);\n+        self.get_mut(dest.alloc_id)?.relocations.insert(dest.offset, ptr.alloc_id);\n         Ok(())\n     }\n \n@@ -297,7 +297,7 @@ impl Memory {\n     }\n \n     pub fn read_bool(&self, ptr: Pointer) -> EvalResult<bool> {\n-        let bytes = try!(self.get_bytes(ptr, 1));\n+        let bytes = self.get_bytes(ptr, 1)?;\n         match bytes[0] {\n             0 => Ok(false),\n             1 => Ok(true),\n@@ -352,12 +352,12 @@ impl Memory {\n     {\n         let start = ptr.offset.saturating_sub(self.pointer_size - 1);\n         let end = start + size;\n-        Ok(try!(self.get(ptr.alloc_id)).relocations.range(Included(&start), Excluded(&end)))\n+        Ok(self.get(ptr.alloc_id)?.relocations.range(Included(&start), Excluded(&end)))\n     }\n \n     fn clear_relocations(&mut self, ptr: Pointer, size: usize) -> EvalResult<()> {\n         // Find all relocations overlapping the given range.\n-        let keys: Vec<_> = try!(self.relocations(ptr, size)).map(|(&k, _)| k).collect();\n+        let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n         if keys.is_empty() { return Ok(()); }\n \n         // Find the start and end of the given range and its outermost relocations.\n@@ -366,7 +366,7 @@ impl Memory {\n         let first = *keys.first().unwrap();\n         let last = *keys.last().unwrap() + self.pointer_size;\n \n-        let alloc = try!(self.get_mut(ptr.alloc_id));\n+        let alloc = self.get_mut(ptr.alloc_id)?;\n \n         // Mark parts of the outermost relocations as undefined if they partially fall outside the\n         // given range.\n@@ -380,22 +380,22 @@ impl Memory {\n     }\n \n     fn check_relocation_edges(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n-        let overlapping_start = try!(self.relocations(ptr, 0)).count();\n-        let overlapping_end = try!(self.relocations(ptr.offset(size as isize), 0)).count();\n+        let overlapping_start = self.relocations(ptr, 0)?.count();\n+        let overlapping_end = self.relocations(ptr.offset(size as isize), 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }\n         Ok(())\n     }\n \n     fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n-        let relocations: Vec<_> = try!(self.relocations(src, size))\n+        let relocations: Vec<_> = self.relocations(src, size)?\n             .map(|(&offset, &alloc_id)| {\n                 // Update relocation offsets for the new positions in the destination allocation.\n                 (offset + dest.offset - src.offset, alloc_id)\n             })\n             .collect();\n-        try!(self.get_mut(dest.alloc_id)).relocations.extend(relocations);\n+        self.get_mut(dest.alloc_id)?.relocations.extend(relocations);\n         Ok(())\n     }\n \n@@ -408,17 +408,17 @@ impl Memory {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         let mut v = Vec::with_capacity(size);\n         for i in 0..size {\n-            let defined = try!(self.get(src.alloc_id)).undef_mask.get(src.offset + i);\n+            let defined = self.get(src.alloc_id)?.undef_mask.get(src.offset + i);\n             v.push(defined);\n         }\n         for (i, defined) in v.into_iter().enumerate() {\n-            try!(self.get_mut(dest.alloc_id)).undef_mask.set(dest.offset + i, defined);\n+            self.get_mut(dest.alloc_id)?.undef_mask.set(dest.offset + i, defined);\n         }\n         Ok(())\n     }\n \n     fn check_defined(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n-        let alloc = try!(self.get(ptr.alloc_id));\n+        let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) {\n             return Err(EvalError::ReadUndefBytes);\n         }\n@@ -428,7 +428,7 @@ impl Memory {\n     pub fn mark_definedness(&mut self, ptr: Pointer, size: usize, new_state: bool)\n         -> EvalResult<()>\n     {\n-        let mut alloc = try!(self.get_mut(ptr.alloc_id));\n+        let mut alloc = self.get_mut(ptr.alloc_id)?;\n         alloc.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n         Ok(())\n     }"}]}