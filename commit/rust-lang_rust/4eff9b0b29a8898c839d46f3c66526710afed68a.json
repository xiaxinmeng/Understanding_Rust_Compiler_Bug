{"sha": "4eff9b0b29a8898c839d46f3c66526710afed68a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZmY5YjBiMjlhODg5OGM4MzlkNDZmM2M2NjUyNjcxMGFmZWQ2OGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-21T15:06:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-21T15:06:20Z"}, "message": "Auto merge of #77013 - RalfJung:rollup-84ut0xq, r=RalfJung\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #76439 (Add error explanation for E0755)\n - #76521 (Fix segfault if pthread_getattr_np fails)\n - #76835 (make replace_prefix only take &str as arguments )\n - #76967 (Revert adding Atomic::from_mut.)\n - #76977 (Add a regression test for copy propagation miscompilation)\n - #76981 (liballoc bench use imported path Bencher)\n - #76983 (BTreeMap: extra testing & fixed comments)\n - #76996 (Fix typo in rustc_lexer docs)\n - #77009 (Dogfood total_cmp in the test crate)\n - #77012 (update Miri for another bugfix)\n\nFailed merges:\n\n - #76489 (Add explanation for E0756)\n\nr? `@ghost`", "tree": {"sha": "293b62ed5a035e287e40e111ccf1d32bf18de682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/293b62ed5a035e287e40e111ccf1d32bf18de682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eff9b0b29a8898c839d46f3c66526710afed68a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eff9b0b29a8898c839d46f3c66526710afed68a", "html_url": "https://github.com/rust-lang/rust/commit/4eff9b0b29a8898c839d46f3c66526710afed68a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eff9b0b29a8898c839d46f3c66526710afed68a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0bf356f9e5f6a8cca1eb656e900ffba79340fa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0bf356f9e5f6a8cca1eb656e900ffba79340fa1", "html_url": "https://github.com/rust-lang/rust/commit/e0bf356f9e5f6a8cca1eb656e900ffba79340fa1"}, {"sha": "6417eb0cff24da1a6e026891c0714ef8f4f773bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6417eb0cff24da1a6e026891c0714ef8f4f773bd", "html_url": "https://github.com/rust-lang/rust/commit/6417eb0cff24da1a6e026891c0714ef8f4f773bd"}], "stats": {"total": 268, "additions": 120, "deletions": 148}, "files": [{"sha": "23a7b08016e509bbde955726d6b8527d9ea2afd6", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -440,6 +440,7 @@ E0751: include_str!(\"./error_codes/E0751.md\"),\n E0752: include_str!(\"./error_codes/E0752.md\"),\n E0753: include_str!(\"./error_codes/E0753.md\"),\n E0754: include_str!(\"./error_codes/E0754.md\"),\n+E0755: include_str!(\"./error_codes/E0755.md\"),\n E0758: include_str!(\"./error_codes/E0758.md\"),\n E0759: include_str!(\"./error_codes/E0759.md\"),\n E0760: include_str!(\"./error_codes/E0760.md\"),\n@@ -632,7 +633,6 @@ E0774: include_str!(\"./error_codes/E0774.md\"),\n     E0722, // Malformed `#[optimize]` attribute\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n-    E0755, // `#[ffi_pure]` is only allowed on foreign functions\n     E0756, // `#[ffi_const]` is only allowed on foreign functions\n     E0757, // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n     E0772, // `'static' obligation coming from `impl dyn Trait {}` or `impl Foo for dyn Bar {}`."}, {"sha": "88b7f48496906d614f69538b5bb0256d2057804d", "filename": "compiler/rustc_error_codes/src/error_codes/E0755.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0755.md", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0755.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0755.md?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -0,0 +1,28 @@\n+The `ffi_pure` attribute was used on a non-foreign function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0755\n+#![feature(ffi_pure)]\n+\n+#[ffi_pure] // error!\n+pub fn foo() {}\n+# fn main() {}\n+```\n+\n+The `ffi_pure` attribute can only be used on foreign functions which do not have\n+side effects or infinite loops:\n+\n+```\n+#![feature(ffi_pure)]\n+\n+extern \"C\" {\n+    #[ffi_pure] // ok!\n+    pub fn strlen(s: *const i8) -> isize;\n+}\n+# fn main() {}\n+```\n+\n+You can find more information about it in the [unstable Rust Book].\n+\n+[unstable Rust Book]: https://doc.rust-lang.org/unstable-book/language-features/ffi-pure.html"}, {"sha": "d784a86f14ceede0341d74b561530c1f6552082d", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -2,7 +2,7 @@\n //!\n //! The idea with `librustc_lexer` is to make a reusable library,\n //! by separating out pure lexing and rustc-specific concerns, like spans,\n-//! error reporting an interning.  So, rustc_lexer operates directly on `&str`,\n+//! error reporting, and interning.  So, rustc_lexer operates directly on `&str`,\n //! produces simple tokens which are a pair of type-tag and a bit of original text,\n //! and does not report errors, instead storing them as flags on the token.\n //!"}, {"sha": "247bbf637ceaf9c447be86b3840e4217b2c740b8", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -362,16 +362,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn replace_prefix<A, B, C>(&self, s: A, old: B, new: C) -> Option<String>\n-    where\n-        A: AsRef<str>,\n-        B: AsRef<str>,\n-        C: AsRef<str>,\n-    {\n-        let s = s.as_ref();\n-        let old = old.as_ref();\n+    fn replace_prefix(&self, s: &str, old: &str, new: &str) -> Option<String> {\n         if let Some(stripped) = s.strip_prefix(old) {\n-            Some(new.as_ref().to_owned() + stripped)\n+            Some(new.to_string() + stripped)\n         } else {\n             None\n         }\n@@ -422,7 +415,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (&ty::Str, &ty::Array(arr, _) | &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if let Some(src) = self.replace_prefix(src, \"b\\\"\", \"\\\"\") {\n+                            if let Some(src) = self.replace_prefix(&src, \"b\\\"\", \"\\\"\") {\n                                 return Some((\n                                     sp,\n                                     \"consider removing the leading `b`\",\n@@ -436,7 +429,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (&ty::Array(arr, _) | &ty::Slice(arr), &ty::Str) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if let Some(src) = self.replace_prefix(src, \"\\\"\", \"b\\\"\") {\n+                            if let Some(src) = self.replace_prefix(&src, \"\\\"\", \"b\\\"\") {\n                                 return Some((\n                                     sp,\n                                     \"consider adding a leading `b`\",\n@@ -561,7 +554,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {\n                     if let Ok(src) = sm.span_to_snippet(sp) {\n-                        if let Some(src) = self.replace_prefix(src, \"&\", \"\") {\n+                        if let Some(src) = self.replace_prefix(&src, \"&\", \"\") {\n                             return Some((\n                                 sp,\n                                 \"consider removing the borrow\",\n@@ -598,7 +591,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     match mutbl_a {\n                                         hir::Mutability::Mut => {\n                                             if let Some(s) =\n-                                                self.replace_prefix(src, \"&mut \", new_prefix)\n+                                                self.replace_prefix(&src, \"&mut \", &new_prefix)\n                                             {\n                                                 Some((s, Applicability::MachineApplicable))\n                                             } else {\n@@ -607,7 +600,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         }\n                                         hir::Mutability::Not => {\n                                             if let Some(s) =\n-                                                self.replace_prefix(src, \"&\", new_prefix)\n+                                                self.replace_prefix(&src, \"&\", &new_prefix)\n                                             {\n                                                 Some((s, Applicability::Unspecified))\n                                             } else {\n@@ -621,7 +614,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     match mutbl_a {\n                                         hir::Mutability::Mut => {\n                                             if let Some(s) =\n-                                                self.replace_prefix(src, \"&mut \", new_prefix)\n+                                                self.replace_prefix(&src, \"&mut \", &new_prefix)\n                                             {\n                                                 Some((s, Applicability::MachineApplicable))\n                                             } else {\n@@ -630,7 +623,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         }\n                                         hir::Mutability::Not => {\n                                             if let Some(s) =\n-                                                self.replace_prefix(src, \"&\", new_prefix)\n+                                                self.replace_prefix(&src, \"&\", &new_prefix)\n                                             {\n                                                 Some((s, Applicability::MachineApplicable))\n                                             } else {"}, {"sha": "b295342f3610ee609cbb73c72ae785fe600967a5", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -496,7 +496,7 @@ bench_in_place![\n ];\n \n #[bench]\n-fn bench_in_place_recycle(b: &mut test::Bencher) {\n+fn bench_in_place_recycle(b: &mut Bencher) {\n     let mut data = vec![0; 1000];\n \n     b.iter(|| {\n@@ -513,7 +513,7 @@ fn bench_in_place_recycle(b: &mut test::Bencher) {\n }\n \n #[bench]\n-fn bench_in_place_zip_recycle(b: &mut test::Bencher) {\n+fn bench_in_place_zip_recycle(b: &mut Bencher) {\n     let mut data = vec![0u8; 1000];\n     let mut rng = rand::thread_rng();\n     let mut subst = vec![0u8; 1000];\n@@ -533,7 +533,7 @@ fn bench_in_place_zip_recycle(b: &mut test::Bencher) {\n }\n \n #[bench]\n-fn bench_in_place_zip_iter_mut(b: &mut test::Bencher) {\n+fn bench_in_place_zip_iter_mut(b: &mut Bencher) {\n     let mut data = vec![0u8; 256];\n     let mut rng = rand::thread_rng();\n     let mut subst = vec![0u8; 1000];\n@@ -558,7 +558,7 @@ impl Drop for Droppable {\n }\n \n #[bench]\n-fn bench_in_place_collect_droppable(b: &mut test::Bencher) {\n+fn bench_in_place_collect_droppable(b: &mut Bencher) {\n     let v: Vec<Droppable> = std::iter::repeat_with(|| Droppable(0)).take(1000).collect();\n     b.iter(|| {\n         v.clone()\n@@ -571,13 +571,13 @@ fn bench_in_place_collect_droppable(b: &mut test::Bencher) {\n }\n \n #[bench]\n-fn bench_chain_collect(b: &mut test::Bencher) {\n+fn bench_chain_collect(b: &mut Bencher) {\n     let data = black_box([0; LEN]);\n     b.iter(|| data.iter().cloned().chain([1].iter().cloned()).collect::<Vec<_>>());\n }\n \n #[bench]\n-fn bench_chain_chain_collect(b: &mut test::Bencher) {\n+fn bench_chain_chain_collect(b: &mut Bencher) {\n     let data = black_box([0; LEN]);\n     b.iter(|| {\n         data.iter()\n@@ -589,7 +589,7 @@ fn bench_chain_chain_collect(b: &mut test::Bencher) {\n }\n \n #[bench]\n-fn bench_nest_chain_chain_collect(b: &mut test::Bencher) {\n+fn bench_nest_chain_chain_collect(b: &mut Bencher) {\n     let data = black_box([0; LEN]);\n     b.iter(|| {\n         data.iter().cloned().chain([1].iter().chain([2].iter()).cloned()).collect::<Vec<_>>()\n@@ -616,12 +616,12 @@ pub fn map_fast(l: &[(u32, u32)]) -> Vec<u32> {\n const LEN: usize = 16384;\n \n #[bench]\n-fn bench_range_map_collect(b: &mut test::Bencher) {\n+fn bench_range_map_collect(b: &mut Bencher) {\n     b.iter(|| (0..LEN).map(|_| u32::default()).collect::<Vec<_>>());\n }\n \n #[bench]\n-fn bench_chain_extend_ref(b: &mut test::Bencher) {\n+fn bench_chain_extend_ref(b: &mut Bencher) {\n     let data = black_box([0; LEN]);\n     b.iter(|| {\n         let mut v = Vec::<u32>::with_capacity(data.len() + 1);\n@@ -631,7 +631,7 @@ fn bench_chain_extend_ref(b: &mut test::Bencher) {\n }\n \n #[bench]\n-fn bench_chain_extend_value(b: &mut test::Bencher) {\n+fn bench_chain_extend_value(b: &mut Bencher) {\n     let data = black_box([0; LEN]);\n     b.iter(|| {\n         let mut v = Vec::<u32>::with_capacity(data.len() + 1);\n@@ -641,7 +641,7 @@ fn bench_chain_extend_value(b: &mut test::Bencher) {\n }\n \n #[bench]\n-fn bench_rev_1(b: &mut test::Bencher) {\n+fn bench_rev_1(b: &mut Bencher) {\n     let data = black_box([0; LEN]);\n     b.iter(|| {\n         let mut v = Vec::<u32>::new();\n@@ -651,13 +651,13 @@ fn bench_rev_1(b: &mut test::Bencher) {\n }\n \n #[bench]\n-fn bench_rev_2(b: &mut test::Bencher) {\n+fn bench_rev_2(b: &mut Bencher) {\n     let data = black_box([0; LEN]);\n     b.iter(|| example_plain_slow(&data));\n }\n \n #[bench]\n-fn bench_map_regular(b: &mut test::Bencher) {\n+fn bench_map_regular(b: &mut Bencher) {\n     let data = black_box([(0, 0); LEN]);\n     b.iter(|| {\n         let mut v = Vec::<u32>::new();\n@@ -667,7 +667,7 @@ fn bench_map_regular(b: &mut test::Bencher) {\n }\n \n #[bench]\n-fn bench_map_fast(b: &mut test::Bencher) {\n+fn bench_map_fast(b: &mut Bencher) {\n     let data = black_box([(0, 0); LEN]);\n     b.iter(|| map_fast(&data));\n }"}, {"sha": "8018514fa1776dd6875770df96178bcab4cbc25e", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -88,6 +88,11 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n                     let min_len = if is_root { 1 } else { node::MIN_LEN };\n                     assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n \n+                    for idx in 0..=node.len() {\n+                        let edge = unsafe { node::Handle::new_edge(node, idx) };\n+                        assert!(edge.descend().ascend().ok().unwrap() == edge);\n+                    }\n+\n                     internal_length += node.len();\n                 }\n                 Position::InternalKV(kv) => {\n@@ -1846,3 +1851,17 @@ fn test_into_values() {\n     assert!(values.contains(&'b'));\n     assert!(values.contains(&'c'));\n }\n+\n+#[test]\n+fn test_insert_remove_intertwined() {\n+    let loops = if cfg!(miri) { 100 } else { 1_000_000 };\n+    let mut map = BTreeMap::new();\n+    let mut i = 1;\n+    for _ in 0..loops {\n+        i = (i + 421) & 0xFF;\n+        map.insert(i, i);\n+        map.remove(&(0xFF - i));\n+    }\n+\n+    map.check();\n+}"}, {"sha": "f1d66e973cb52dd53b0ae343999e8bf3d627ef95", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -613,8 +613,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Adds a key/value pair and an edge to go to the right of that pair to\n-    /// the end of the node.\n+    /// Adds a key/value pair, and an edge to go to the right of that pair,\n+    /// to the end of the node.\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n \n@@ -630,8 +630,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         }\n     }\n \n-    /// Adds a key/value pair and an edge to go to the left of that pair to\n-    /// the beginning of the node.\n+    /// Adds a key/value pair, and an edge to go to the left of that pair,\n+    /// to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n         assert!(self.len() < CAPACITY);\n@@ -1152,7 +1152,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     ///\n     /// - The node is truncated to only contain the key/value pairs to the right of\n     ///   this handle.\n-    /// - The key and value pointed to by this handle and extracted.\n+    /// - The key and value pointed to by this handle are extracted.\n     /// - All the key/value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n@@ -1196,7 +1196,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     ///\n     /// - The node is truncated to only contain the edges and key/value pairs to the\n     ///   right of this handle.\n-    /// - The key and value pointed to by this handle and extracted.\n+    /// - The key and value pointed to by this handle are extracted.\n     /// - All the edges and key/value pairs to the right of this handle are put into\n     ///   a newly allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {"}, {"sha": "7eec2c487fef42a935ff765e29e6d00bb5c39682", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -110,7 +110,6 @@ use self::Ordering::*;\n use crate::cell::UnsafeCell;\n use crate::fmt;\n use crate::intrinsics;\n-use crate::mem::align_of;\n \n use crate::hint::spin_loop;\n \n@@ -328,27 +327,6 @@ impl AtomicBool {\n         unsafe { &mut *(self.v.get() as *mut bool) }\n     }\n \n-    /// Get atomic access to a `&mut bool`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(atomic_from_mut)]\n-    /// use std::sync::atomic::{AtomicBool, Ordering};\n-    ///\n-    /// let mut some_bool = true;\n-    /// let a = AtomicBool::from_mut(&mut some_bool);\n-    /// a.store(false, Ordering::Relaxed);\n-    /// assert_eq!(some_bool, false);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n-    pub fn from_mut(v: &mut bool) -> &Self {\n-        // SAFETY: the mutable reference guarantees unique ownership, and\n-        // alignment of both `bool` and `Self` is 1.\n-        unsafe { &*(v as *mut bool as *mut Self) }\n-    }\n-\n     /// Consumes the atomic and returns the contained value.\n     ///\n     /// This is safe because passing `self` by value guarantees that no other threads are\n@@ -841,30 +819,6 @@ impl<T> AtomicPtr<T> {\n         self.p.get_mut()\n     }\n \n-    /// Get atomic access to a pointer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(atomic_from_mut)]\n-    /// use std::sync::atomic::{AtomicPtr, Ordering};\n-    ///\n-    /// let mut some_ptr = &mut 123 as *mut i32;\n-    /// let a = AtomicPtr::from_mut(&mut some_ptr);\n-    /// a.store(&mut 456, Ordering::Relaxed);\n-    /// assert_eq!(unsafe { *some_ptr }, 456);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n-    pub fn from_mut(v: &mut *mut T) -> &Self {\n-        let [] = [(); align_of::<AtomicPtr<()>>() - align_of::<*mut ()>()];\n-        // SAFETY:\n-        //  - the mutable reference guarantees unique ownership.\n-        //  - the alignment of `*mut T` and `Self` is the same on all platforms\n-        //    supported by rust, as verified above.\n-        unsafe { &*(v as *mut *mut T as *mut Self) }\n-    }\n-\n     /// Consumes the atomic and returns the contained value.\n     ///\n     /// This is safe because passing `self` by value guarantees that no other threads are\n@@ -1167,7 +1121,6 @@ macro_rules! atomic_int {\n      $stable_nand:meta,\n      $const_stable:meta,\n      $stable_init_const:meta,\n-     $(from_mut: cfg($from_mut_cfg:meta),)?\n      $s_int_type:literal, $int_ref:expr,\n      $extra_feature:expr,\n      $min_fn:ident, $max_fn:ident,\n@@ -1278,45 +1231,6 @@ assert_eq!(some_var.load(Ordering::SeqCst), 5);\n                 }\n             }\n \n-            doc_comment! {\n-                concat!(\"Get atomic access to a `&mut \", stringify!($int_type), \"`.\n-\n-\",\n-if_not_8_bit! {\n-    $int_type,\n-    concat!(\n-        \"**Note:** This function is only available on targets where `\",\n-        stringify!($int_type), \"` has an alignment of \", $align, \" bytes.\"\n-    )\n-},\n-\"\n-\n-# Examples\n-\n-```\n-#![feature(atomic_from_mut)]\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let mut some_int = 123;\n-let a = \", stringify!($atomic_type), \"::from_mut(&mut some_int);\n-a.store(100, Ordering::Relaxed);\n-assert_eq!(some_int, 100);\n-```\n-                \"),\n-                #[inline]\n-                $(#[cfg($from_mut_cfg)])?\n-                #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n-                pub fn from_mut(v: &mut $int_type) -> &Self {\n-                    let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n-                    // SAFETY:\n-                    //  - the mutable reference guarantees unique ownership.\n-                    //  - the alignment of `$int_type` and `Self` is the\n-                    //    same on all platforms enabled by `$from_mut_cfg`\n-                    //    as verified above.\n-                    unsafe { &*(v as *mut $int_type as *mut Self) }\n-                }\n-            }\n-\n             doc_comment! {\n                 concat!(\"Consumes the atomic and returns the contained value.\n \n@@ -2075,7 +1989,6 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    from_mut: cfg(not(target_arch = \"x86\")),\n     \"i64\", \"../../../std/primitive.i64.html\",\n     \"\",\n     atomic_min, atomic_max,\n@@ -2094,7 +2007,6 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    from_mut: cfg(not(target_arch = \"x86\")),\n     \"u64\", \"../../../std/primitive.u64.html\",\n     \"\",\n     atomic_umin, atomic_umax,\n@@ -2113,7 +2025,6 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    from_mut: cfg(not(target_arch = \"x86_64\")),\n     \"i128\", \"../../../std/primitive.i128.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n     atomic_min, atomic_max,\n@@ -2132,7 +2043,6 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    from_mut: cfg(not(target_arch = \"x86_64\")),\n     \"u128\", \"../../../std/primitive.u128.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n     atomic_umin, atomic_umax,"}, {"sha": "652219e28f6e03a382a422ac0da567ddc51ac543", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -294,6 +294,7 @@ pub mod guard {\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = crate::mem::zeroed();\n+        #[cfg(target_os = \"freebsd\")]\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n         #[cfg(target_os = \"freebsd\")]\n         let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n@@ -305,7 +306,9 @@ pub mod guard {\n             assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize), 0);\n             ret = Some(stackaddr);\n         }\n-        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n+        if e == 0 || cfg!(target_os = \"freebsd\") {\n+            assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n+        }\n         ret\n     }\n \n@@ -403,6 +406,7 @@ pub mod guard {\n     pub unsafe fn current() -> Option<Guard> {\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = crate::mem::zeroed();\n+        #[cfg(target_os = \"freebsd\")]\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n         #[cfg(target_os = \"freebsd\")]\n         let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n@@ -446,7 +450,9 @@ pub mod guard {\n                 Some(stackaddr..stackaddr + guardsize)\n             };\n         }\n-        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n+        if e == 0 || cfg!(target_os = \"freebsd\") {\n+            assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n+        }\n         ret\n     }\n }"}, {"sha": "caea4b1e3094162593310c64f32d8340fb11c578", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -29,6 +29,7 @@\n #![feature(staged_api)]\n #![feature(termination_trait_lib)]\n #![feature(test)]\n+#![feature(total_cmp)]\n \n // Public reexports\n pub use self::bench::{black_box, Bencher};"}, {"sha": "1a2cb893a8a4fc551807c4750d2d5c82ceecdec4", "filename": "library/test/src/stats.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Ftest%2Fsrc%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Ftest%2Fsrc%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fstats.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -1,29 +1,13 @@\n #![allow(missing_docs)]\n #![allow(deprecated)] // Float\n \n-use std::cmp::Ordering::{self, Equal, Greater, Less};\n use std::mem;\n \n #[cfg(test)]\n mod tests;\n \n-fn local_cmp(x: f64, y: f64) -> Ordering {\n-    // arbitrarily decide that NaNs are larger than everything.\n-    if y.is_nan() {\n-        Less\n-    } else if x.is_nan() {\n-        Greater\n-    } else if x < y {\n-        Less\n-    } else if x == y {\n-        Equal\n-    } else {\n-        Greater\n-    }\n-}\n-\n fn local_sort(v: &mut [f64]) {\n-    v.sort_by(|x: &f64, y: &f64| local_cmp(*x, *y));\n+    v.sort_by(|x: &f64, y: &f64| x.total_cmp(y));\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples."}, {"sha": "bc911c85ddb296c13fb209fa85ae107113f9bac8", "filename": "src/test/ui/ffi_pure.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/src%2Ftest%2Fui%2Fffi_pure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/src%2Ftest%2Fui%2Fffi_pure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fffi_pure.stderr?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -6,3 +6,4 @@ LL | #[ffi_pure]\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0755`."}, {"sha": "e3283949b2688dc94981786b7e076ef5199e2b59", "filename": "src/test/ui/mir/issue-76740-copy-propagation.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/src%2Ftest%2Fui%2Fmir%2Fissue-76740-copy-propagation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/src%2Ftest%2Fui%2Fmir%2Fissue-76740-copy-propagation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-76740-copy-propagation.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -0,0 +1,30 @@\n+// Regression test for issue #76740.\n+// run-fail FIXME: change to run-pass once #76899 lands\n+// compile-flags: -Zmir-opt-level=3\n+\n+#[derive(Copy, Clone)]\n+pub struct V([usize; 4]);\n+\n+impl V {\n+    fn new() -> Self {\n+        V([0; 4])\n+    }\n+\n+    #[inline(never)]\n+    fn check(mut self) {\n+        assert_eq!(self.0[0], 0);\n+        self.0[0] = 1;\n+    }\n+}\n+\n+fn main() {\n+    let v = V::new();\n+    let mut i = 0;\n+    while i != 10 {\n+        // Copy propagation incorrectly assumed that Operand::Move does not\n+        // mutate the local, and used the same v for each V::check call,\n+        // rather than a copy.\n+        v.check();\n+        i += 1;\n+    }\n+}"}, {"sha": "02a33d411d8e385942776760a99535d69826349b", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -1 +1 @@\n-Subproject commit cbc7560ae2d44669ef6ba0f43014e10ce881180e\n+Subproject commit 02a33d411d8e385942776760a99535d69826349b"}]}