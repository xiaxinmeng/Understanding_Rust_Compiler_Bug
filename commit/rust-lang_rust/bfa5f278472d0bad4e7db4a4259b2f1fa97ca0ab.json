{"sha": "bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYTVmMjc4NDcyZDBiYWQ0ZTdkYjRhNDI1OWIyZjFmYTk3Y2EwYWI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-25T08:48:25Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-02T12:31:57Z"}, "message": "introduce unescape module\n\nCurrently, we deal with escape sequences twice: once when we lex a\nstring, and a second time when we unescape literals. This PR aims to\nremove this duplication, by introducing a new `unescape` mode as a\nsingle source of truth for character escaping rules", "tree": {"sha": "bb27691d38cfe85ef181ea8d2cb7609da12cbe91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb27691d38cfe85ef181ea8d2cb7609da12cbe91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "html_url": "https://github.com/rust-lang/rust/commit/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "html_url": "https://github.com/rust-lang/rust/commit/9b67bd42b7cbf97f72d039afcba02f5177d0d68c"}], "stats": {"total": 1816, "additions": 1047, "deletions": 769}, "files": [{"sha": "f74dcd6070c70f6005b4bd541affa541f7abc871", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -184,7 +184,7 @@ impl<'a> DiagnosticBuilder<'a> {\n                                                   ) -> &mut Self);\n     forward!(pub fn warn(&mut self, msg: &str) -> &mut Self);\n     forward!(pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self);\n-    forward!(pub fn help(&mut self , msg: &str) -> &mut Self);\n+    forward!(pub fn help(&mut self, msg: &str) -> &mut Self);\n     forward!(pub fn span_help<S: Into<MultiSpan>>(&mut self,\n                                                   sp: S,\n                                                   msg: &str,"}, {"sha": "3c342c2ff26a9bc2d15a334d47e2d909536c00d2", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 142, "deletions": 443, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -1,8 +1,10 @@\n use crate::ast::{self, Ident};\n use crate::parse::{token, ParseSess};\n use crate::symbol::Symbol;\n+use crate::parse::unescape;\n+use crate::parse::unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n-use errors::{Applicability, FatalError, Diagnostic, DiagnosticBuilder};\n+use errors::{FatalError, Diagnostic, DiagnosticBuilder};\n use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION};\n use core::unicode::property::Pattern_White_Space;\n \n@@ -334,25 +336,12 @@ impl<'a> StringReader<'a> {\n         self.err_span(self.mk_sp(from_pos, to_pos), m)\n     }\n \n-    /// Pushes a character to a message string for error reporting\n-    fn push_escaped_char_for_msg(m: &mut String, c: char) {\n-        match c {\n-            '\\u{20}'..='\\u{7e}' => {\n-                // Don't escape \\, ' or \" for user-facing messages\n-                m.push(c);\n-            }\n-            _ => {\n-                m.extend(c.escape_default());\n-            }\n-        }\n-    }\n-\n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n     /// escaped character to the error message\n     fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> FatalError {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        Self::push_escaped_char_for_msg(&mut m, c);\n+        push_escaped_char(&mut m, c);\n \n         self.fatal_span_(from_pos, to_pos, &m[..])\n     }\n@@ -368,7 +357,7 @@ impl<'a> StringReader<'a> {\n     {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        Self::push_escaped_char_for_msg(&mut m, c);\n+        push_escaped_char(&mut m, c);\n \n         self.sess.span_diagnostic.struct_span_fatal(self.mk_sp(from_pos, to_pos), &m[..])\n     }\n@@ -378,29 +367,10 @@ impl<'a> StringReader<'a> {\n     fn err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        Self::push_escaped_char_for_msg(&mut m, c);\n+        push_escaped_char(&mut m, c);\n         self.err_span_(from_pos, to_pos, &m[..]);\n     }\n \n-    fn struct_err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char)\n-        -> DiagnosticBuilder<'a>\n-    {\n-        let mut m = m.to_string();\n-        m.push_str(\": \");\n-        Self::push_escaped_char_for_msg(&mut m, c);\n-\n-        self.sess.span_diagnostic.struct_span_err(self.mk_sp(from_pos, to_pos), &m[..])\n-    }\n-\n-    /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n-    /// offending string to the error message\n-    fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> FatalError {\n-        m.push_str(\": \");\n-        m.push_str(&self.src[self.src_index(from_pos)..self.src_index(to_pos)]);\n-\n-        self.fatal_span_(from_pos, to_pos, &m[..])\n-    }\n-\n     /// Advance peek_tok and peek_span to refer to the next token, and\n     /// possibly update the interner.\n     fn advance_token(&mut self) -> Result<(), ()> {\n@@ -863,271 +833,6 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    /// Scan over `n_digits` hex digits, stopping at `delim`, reporting an\n-    /// error if too many or too few digits are encountered.\n-    fn scan_hex_digits(&mut self, n_digits: usize, delim: char, below_0x7f_only: bool) -> bool {\n-        debug!(\"scanning {} digits until {:?}\", n_digits, delim);\n-        let start_bpos = self.pos;\n-        let mut accum_int = 0;\n-\n-        let mut valid = true;\n-        for _ in 0..n_digits {\n-            if self.is_eof() {\n-                let last_bpos = self.pos;\n-                self.fatal_span_(start_bpos,\n-                                 last_bpos,\n-                                 \"unterminated numeric character escape\").raise();\n-            }\n-            if self.ch_is(delim) {\n-                let last_bpos = self.pos;\n-                self.err_span_(start_bpos,\n-                               last_bpos,\n-                               \"numeric character escape is too short\");\n-                valid = false;\n-                break;\n-            }\n-            let c = self.ch.unwrap_or('\\x00');\n-            accum_int *= 16;\n-            accum_int += c.to_digit(16).unwrap_or_else(|| {\n-                self.err_span_char(self.pos,\n-                                   self.next_pos,\n-                                   \"invalid character in numeric character escape\",\n-                                   c);\n-\n-                valid = false;\n-                0\n-            });\n-            self.bump();\n-        }\n-\n-        if below_0x7f_only && accum_int >= 0x80 {\n-            self.err_span_(start_bpos,\n-                           self.pos,\n-                           \"this form of character escape may only be used with characters in \\\n-                            the range [\\\\x00-\\\\x7f]\");\n-            valid = false;\n-        }\n-\n-        match char::from_u32(accum_int) {\n-            Some(_) => valid,\n-            None => {\n-                let last_bpos = self.pos;\n-                self.err_span_(start_bpos, last_bpos, \"invalid numeric character escape\");\n-                false\n-            }\n-        }\n-    }\n-\n-    /// Scan for a single (possibly escaped) byte or char\n-    /// in a byte, (non-raw) byte string, char, or (non-raw) string literal.\n-    /// `start` is the position of `first_source_char`, which is already consumed.\n-    ///\n-    /// Returns `true` if there was a valid char/byte.\n-    fn scan_char_or_byte(&mut self,\n-                         start: BytePos,\n-                         first_source_char: char,\n-                         ascii_only: bool,\n-                         delim: char)\n-                         -> bool\n-    {\n-        match first_source_char {\n-            '\\\\' => {\n-                // '\\X' for some X must be a character constant:\n-                let escaped = self.ch;\n-                let escaped_pos = self.pos;\n-                self.bump();\n-                match escaped {\n-                    None => {}  // EOF here is an error that will be checked later.\n-                    Some(e) => {\n-                        return match e {\n-                            'n' | 'r' | 't' | '\\\\' | '\\'' | '\"' | '0' => true,\n-                            'x' => self.scan_byte_escape(delim, !ascii_only),\n-                            'u' => {\n-                                let valid = if self.ch_is('{') {\n-                                    self.scan_unicode_escape(delim) && !ascii_only\n-                                } else {\n-                                    let span = self.mk_sp(start, self.pos);\n-                                    let mut suggestion = \"\\\\u{\".to_owned();\n-                                    let msg = \"incorrect unicode escape sequence\";\n-                                    let mut err = self.sess.span_diagnostic.struct_span_err(\n-                                        span,\n-                                        msg,\n-                                    );\n-                                    let mut i = 0;\n-                                    while let (Some(ch), true) = (self.ch, i < 6) {\n-                                        if ch.is_digit(16) {\n-                                            suggestion.push(ch);\n-                                            self.bump();\n-                                            i += 1;\n-                                        } else {\n-                                            break;\n-                                        }\n-                                    }\n-                                    if i != 0 {\n-                                        suggestion.push('}');\n-                                        err.span_suggestion(\n-                                            self.mk_sp(start, self.pos),\n-                                            \"format of unicode escape sequences uses braces\",\n-                                            suggestion,\n-                                            Applicability::MaybeIncorrect,\n-                                        );\n-                                    } else {\n-                                        err.span_label(span, msg);\n-                                        err.help(\n-                                            \"format of unicode escape sequences is `\\\\u{...}`\",\n-                                        );\n-                                    }\n-                                    err.emit();\n-                                    false\n-                                };\n-                                if ascii_only {\n-                                    self.err_span_(start,\n-                                                   self.pos,\n-                                                   \"unicode escape sequences cannot be used as a \\\n-                                                    byte or in a byte string\");\n-                                }\n-                                valid\n-\n-                            }\n-                            '\\n' if delim == '\"' => {\n-                                self.consume_whitespace();\n-                                true\n-                            }\n-                            '\\r' if delim == '\"' && self.ch_is('\\n') => {\n-                                self.consume_whitespace();\n-                                true\n-                            }\n-                            c => {\n-                                let pos = self.pos;\n-                                let msg = if ascii_only {\n-                                    \"unknown byte escape\"\n-                                } else {\n-                                    \"unknown character escape\"\n-                                };\n-                                let mut err = self.struct_err_span_char(escaped_pos, pos, msg, c);\n-                                err.span_label(self.mk_sp(escaped_pos, pos), msg);\n-                                if e == '\\r' {\n-                                    err.help(\n-                                        \"this is an isolated carriage return; consider checking \\\n-                                         your editor and version control settings\",\n-                                    );\n-                                }\n-                                if (e == '{' || e == '}') && !ascii_only {\n-                                    err.help(\n-                                        \"if used in a formatting string, curly braces are escaped \\\n-                                         with `{{` and `}}`\",\n-                                    );\n-                                }\n-                                err.emit();\n-                                false\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            '\\t' | '\\n' | '\\r' | '\\'' if delim == '\\'' => {\n-                let pos = self.pos;\n-                self.err_span_char(start,\n-                                   pos,\n-                                   if ascii_only {\n-                                       \"byte constant must be escaped\"\n-                                   } else {\n-                                       \"character constant must be escaped\"\n-                                   },\n-                                   first_source_char);\n-                return false;\n-            }\n-            '\\r' => {\n-                if self.ch_is('\\n') {\n-                    self.bump();\n-                    return true;\n-                } else {\n-                    self.err_span_(start,\n-                                   self.pos,\n-                                   \"bare CR not allowed in string, use \\\\r instead\");\n-                    return false;\n-                }\n-            }\n-            _ => {\n-                if ascii_only && first_source_char > '\\x7F' {\n-                    let pos = self.pos;\n-                    self.err_span_(start,\n-                                   pos,\n-                                   \"byte constant must be ASCII. Use a \\\\xHH escape for a \\\n-                                    non-ASCII byte\");\n-                    return false;\n-                }\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Scan over a `\\u{...}` escape\n-    ///\n-    /// At this point, we have already seen the `\\` and the `u`, the `{` is the current character.\n-    /// We will read a hex number (with `_` separators), with 1 to 6 actual digits,\n-    /// and pass over the `}`.\n-    fn scan_unicode_escape(&mut self, delim: char) -> bool {\n-        self.bump(); // past the {\n-        let start_bpos = self.pos;\n-        let mut valid = true;\n-\n-        if let Some('_') = self.ch {\n-            // disallow leading `_`\n-            self.err_span_(self.pos,\n-                           self.next_pos,\n-                           \"invalid start of unicode escape\");\n-            valid = false;\n-        }\n-\n-        let count = self.scan_digits(16, 16);\n-\n-        if count > 6 {\n-            self.err_span_(start_bpos,\n-                           self.pos,\n-                           \"overlong unicode escape (must have at most 6 hex digits)\");\n-            valid = false;\n-        }\n-\n-        loop {\n-            match self.ch {\n-                Some('}') => {\n-                    if valid && count == 0 {\n-                        self.err_span_(start_bpos,\n-                                       self.pos,\n-                                       \"empty unicode escape (must have at least 1 hex digit)\");\n-                        valid = false;\n-                    }\n-                    self.bump(); // past the ending `}`\n-                    break;\n-                },\n-                Some(c) => {\n-                    if c == delim {\n-                        self.err_span_(self.pos,\n-                                       self.pos,\n-                                       \"unterminated unicode escape (needed a `}`)\");\n-                        valid = false;\n-                        break;\n-                    } else if valid {\n-                        self.err_span_char(start_bpos,\n-                                           self.pos,\n-                                           \"invalid character in unicode escape\",\n-                                           c);\n-                        valid = false;\n-                    }\n-                },\n-                None => {\n-                    self.fatal_span_(start_bpos,\n-                                     self.pos,\n-                                     \"unterminated unicode escape (found EOF)\").raise();\n-                }\n-            }\n-            self.bump();\n-        }\n-\n-        valid\n-    }\n-\n     /// Scan over a float exponent.\n     fn scan_float_exponent(&mut self) {\n         if self.ch_is('e') || self.ch_is('E') {\n@@ -1393,26 +1098,21 @@ impl<'a> StringReader<'a> {\n                 self.bump();\n                 let start = self.pos;\n \n-                // the eof will be picked up by the final `'` check below\n-                let c2 = self.ch.unwrap_or('\\x00');\n-                self.bump();\n-\n                 // If the character is an ident start not followed by another single\n                 // quote, then this is a lifetime name:\n-                if (ident_start(Some(c2)) || c2.is_numeric()) && !self.ch_is('\\'') {\n+                let starts_with_number = self.ch.unwrap_or('\\x00').is_numeric();\n+                if (ident_start(self.ch) || starts_with_number) && !self.nextch_is('\\'') {\n+                    self.bump();\n                     while ident_continue(self.ch) {\n                         self.bump();\n                     }\n                     // lifetimes shouldn't end with a single quote\n                     // if we find one, then this is an invalid character literal\n                     if self.ch_is('\\'') {\n-                        self.err_span_(\n-                            start_with_quote,\n-                            self.next_pos,\n-                            \"character literal may only contain one codepoint\");\n+                        let id = self.name_from(start);\n                         self.bump();\n-                        return Ok(token::Literal(token::Err(Symbol::intern(\"??\")), None))\n-\n+                        self.validate_char_escape(start_with_quote);\n+                        return Ok(token::Literal(token::Char(id), None))\n                     }\n \n                     // Include the leading `'` in the real identifier, for macro\n@@ -1422,7 +1122,7 @@ impl<'a> StringReader<'a> {\n                         self.mk_ident(lifetime_name)\n                     });\n \n-                    if c2.is_numeric() {\n+                    if starts_with_number {\n                         // this is a recovered lifetime written `'1`, error but accept it\n                         self.err_span_(\n                             start_with_quote,\n@@ -1433,58 +1133,30 @@ impl<'a> StringReader<'a> {\n \n                     return Ok(token::Lifetime(ident));\n                 }\n-\n-                let valid = self.scan_char_or_byte(start, c2, /* ascii_only */ false, '\\'');\n-\n-                if !self.ch_is('\\'') {\n-                    let pos = self.pos;\n-\n-                    loop {\n-                        self.bump();\n-                        if self.ch_is('\\'') {\n-                            let start = self.src_index(start);\n-                            let end = self.src_index(self.pos);\n-                            self.bump();\n-                            let span = self.mk_sp(start_with_quote, self.pos);\n-                            self.sess.span_diagnostic\n-                                .struct_span_err(span,\n-                                                 \"character literal may only contain one codepoint\")\n-                                .span_suggestion(\n-                                    span,\n-                                    \"if you meant to write a `str` literal, use double quotes\",\n-                                    format!(\"\\\"{}\\\"\", &self.src[start..end]),\n-                                    Applicability::MachineApplicable\n-                                ).emit();\n-                            return Ok(token::Literal(token::Err(Symbol::intern(\"??\")), None))\n-                        }\n-                        if self.ch_is('\\n') || self.is_eof() || self.ch_is('/') {\n-                            // Only attempt to infer single line string literals. If we encounter\n-                            // a slash, bail out in order to avoid nonsensical suggestion when\n-                            // involving comments.\n-                            break;\n-                        }\n-                    }\n-\n-                    self.fatal_span_verbose(start_with_quote, pos,\n-                        String::from(\"character literal may only contain one codepoint\")).raise();\n-                }\n-\n-                let id = if valid {\n-                    self.name_from(start)\n-                } else {\n-                    Symbol::intern(\"0\")\n-                };\n-\n-                self.bump(); // advance ch past token\n+                let msg = \"unterminated character literal\";\n+                let id = self.scan_single_quoted_string(start_with_quote, msg);\n+                self.validate_char_escape(start_with_quote);\n                 let suffix = self.scan_optional_raw_name();\n-\n                 Ok(token::Literal(token::Char(id), suffix))\n             }\n             'b' => {\n                 self.bump();\n                 let lit = match self.ch {\n-                    Some('\\'') => self.scan_byte(),\n-                    Some('\"') => self.scan_byte_string(),\n+                    Some('\\'') => {\n+                        let start_with_quote = self.pos;\n+                        self.bump();\n+                        let msg = \"unterminated byte constant\";\n+                        let id = self.scan_single_quoted_string(start_with_quote, msg);\n+                        self.validate_byte_escape(start_with_quote);\n+                        token::Byte(id)\n+                    },\n+                    Some('\"') => {\n+                        let start_with_quote = self.pos;\n+                        let msg = \"unterminated double quote byte string\";\n+                        let id = self.scan_double_quoted_string(msg);\n+                        self.validate_byte_str_escape(start_with_quote);\n+                        token::ByteStr(id)\n+                    },\n                     Some('r') => self.scan_raw_byte_string(),\n                     _ => unreachable!(),  // Should have been a token::Ident above.\n                 };\n@@ -1493,32 +1165,11 @@ impl<'a> StringReader<'a> {\n                 Ok(token::Literal(lit, suffix))\n             }\n             '\"' => {\n-                let start_bpos = self.pos;\n-                let mut valid = true;\n-                self.bump();\n-\n-                while !self.ch_is('\"') {\n-                    if self.is_eof() {\n-                        let last_bpos = self.pos;\n-                        self.fatal_span_(start_bpos,\n-                                         last_bpos,\n-                                         \"unterminated double quote string\").raise();\n-                    }\n-\n-                    let ch_start = self.pos;\n-                    let ch = self.ch.unwrap();\n-                    self.bump();\n-                    valid &= self.scan_char_or_byte(ch_start, ch, /* ascii_only */ false, '\"');\n-                }\n-                // adjust for the ASCII \" at the start of the literal\n-                let id = if valid {\n-                    self.name_from(start_bpos + BytePos(1))\n-                } else {\n-                    Symbol::intern(\"??\")\n-                };\n-                self.bump();\n+                let start_with_quote = self.pos;\n+                let msg = \"unterminated double quote string\";\n+                let id = self.scan_double_quoted_string(msg);\n+                self.validate_str_escape(start_with_quote);\n                 let suffix = self.scan_optional_raw_name();\n-\n                 Ok(token::Literal(token::Str_(id), suffix))\n             }\n             'r' => {\n@@ -1659,12 +1310,6 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    fn consume_whitespace(&mut self) {\n-        while is_pattern_whitespace(self.ch) && !self.is_eof() {\n-            self.bump();\n-        }\n-    }\n-\n     fn read_to_eol(&mut self) -> String {\n         let mut val = String::new();\n         while !self.ch_is('\\n') && !self.is_eof() {\n@@ -1698,73 +1343,63 @@ impl<'a> StringReader<'a> {\n         (self.ch_is('#') && self.nextch_is('!') && !self.nextnextch_is('['))\n     }\n \n-    fn scan_byte(&mut self) -> token::Lit {\n-        self.bump();\n+    fn scan_single_quoted_string(&mut self,\n+                                 start_with_quote: BytePos,\n+                                 unterminated_msg: &str) -> ast::Name {\n+        // assumes that first `'` is consumed\n         let start = self.pos;\n-\n-        // the eof will be picked up by the final `'` check below\n-        let c2 = self.ch.unwrap_or('\\x00');\n-        self.bump();\n-\n-        let valid = self.scan_char_or_byte(start,\n-                                           c2,\n-                                           // ascii_only =\n-                                           true,\n-                                           '\\'');\n-        if !self.ch_is('\\'') {\n-            // Byte offsetting here is okay because the\n-            // character before position `start` are an\n-            // ascii single quote and ascii 'b'.\n-            let pos = self.pos;\n-            self.fatal_span_verbose(start - BytePos(2),\n-                                    pos,\n-                                    \"unterminated byte constant\".to_string()).raise();\n-        }\n-\n-        let id = if valid {\n-            self.name_from(start)\n+        // lex `'''` as a single char, for recovery\n+        if self.ch_is('\\'') && self.nextch_is('\\'') {\n+            self.bump();\n         } else {\n-            Symbol::intern(\"?\")\n-        };\n-        self.bump(); // advance ch past token\n-\n-        token::Byte(id)\n-    }\n+            let mut first = true;\n+            loop {\n+                if self.ch_is('\\'') {\n+                    break;\n+                }\n+                if self.ch_is('\\\\') && (self.nextch_is('\\'') || self.nextch_is('\\\\')) {\n+                    self.bump();\n+                    self.bump();\n+                } else {\n+                    // Only attempt to infer single line string literals. If we encounter\n+                    // a slash, bail out in order to avoid nonsensical suggestion when\n+                    // involving comments.\n+                    if self.is_eof()\n+                        || (self.ch_is('/') && !first)\n+                        || (self.ch_is('\\n') && !self.nextch_is('\\'')) {\n+\n+                        self.fatal_span_(start_with_quote, self.pos, unterminated_msg.into())\n+                            .raise()\n+                    }\n+                    self.bump();\n+                }\n+                first = false;\n+            }\n+        }\n \n-    #[inline]\n-    fn scan_byte_escape(&mut self, delim: char, below_0x7f_only: bool) -> bool {\n-        self.scan_hex_digits(2, delim, below_0x7f_only)\n+        let id = self.name_from(start);\n+        self.bump();\n+        id\n     }\n \n-    fn scan_byte_string(&mut self) -> token::Lit {\n+    fn scan_double_quoted_string(&mut self, unterminated_msg: &str) -> ast::Name {\n+        debug_assert!(self.ch_is('\\\"'));\n+        let start_with_quote = self.pos;\n         self.bump();\n         let start = self.pos;\n-        let mut valid = true;\n-\n         while !self.ch_is('\"') {\n             if self.is_eof() {\n                 let pos = self.pos;\n-                self.fatal_span_(start, pos, \"unterminated double quote byte string\").raise();\n+                self.fatal_span_(start_with_quote, pos, unterminated_msg).raise();\n+            }\n+            if self.ch_is('\\\\') && (self.nextch_is('\\\\') || self.nextch_is('\"')) {\n+                self.bump();\n             }\n-\n-            let ch_start = self.pos;\n-            let ch = self.ch.unwrap();\n             self.bump();\n-            valid &= self.scan_char_or_byte(ch_start,\n-                                            ch,\n-                                            // ascii_only =\n-                                            true,\n-                                            '\"');\n         }\n-\n-        let id = if valid {\n-            self.name_from(start)\n-        } else {\n-            Symbol::intern(\"??\")\n-        };\n+        let id = self.name_from(start);\n         self.bump();\n-\n-        token::ByteStr(id)\n+        id\n     }\n \n     fn scan_raw_byte_string(&mut self) -> token::Lit {\n@@ -1826,6 +1461,70 @@ impl<'a> StringReader<'a> {\n \n         token::ByteStrRaw(self.name_from_to(content_start_bpos, content_end_bpos), hash_count)\n     }\n+\n+    fn validate_char_escape(&self, start_with_quote: BytePos) {\n+        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n+            if let Err((off, err)) = unescape::unescape_char(lit) {\n+                emit_unescape_error(\n+                    &self.sess.span_diagnostic,\n+                    lit,\n+                    self.mk_sp(start_with_quote, self.pos),\n+                    unescape::Mode::Char,\n+                    0..off,\n+                    err,\n+                )\n+            }\n+        });\n+    }\n+\n+    fn validate_byte_escape(&self, start_with_quote: BytePos) {\n+        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n+            if let Err((off, err)) = unescape::unescape_byte(lit) {\n+                emit_unescape_error(\n+                    &self.sess.span_diagnostic,\n+                    lit,\n+                    self.mk_sp(start_with_quote, self.pos),\n+                    unescape::Mode::Byte,\n+                    0..off,\n+                    err,\n+                )\n+            }\n+        });\n+    }\n+\n+    fn validate_str_escape(&self, start_with_quote: BytePos) {\n+        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n+            unescape::unescape_str(lit, &mut |range, c| {\n+                if let Err(err) = c {\n+                    emit_unescape_error(\n+                        &self.sess.span_diagnostic,\n+                        lit,\n+                        self.mk_sp(start_with_quote, self.pos),\n+                        unescape::Mode::Str,\n+                        range,\n+                        err,\n+                    )\n+                }\n+            })\n+        });\n+    }\n+\n+    fn validate_byte_str_escape(&self, start_with_quote: BytePos) {\n+        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n+            unescape::unescape_byte_str(lit, &mut |range, c| {\n+                if let Err(err) = c {\n+                    emit_unescape_error(\n+                        &self.sess.span_diagnostic,\n+                        lit,\n+                        self.mk_sp(start_with_quote, self.pos),\n+                        unescape::Mode::ByteStr,\n+                        range,\n+                        err,\n+                    )\n+                }\n+            })\n+        });\n+    }\n }\n \n // This tests the character for the unicode property 'PATTERN_WHITE_SPACE' which"}, {"sha": "d6d4f8e8f04294d272902326177ceea13432b490", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 40, "deletions": 222, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -18,7 +18,6 @@ use log::debug;\n \n use rustc_data_structures::fx::FxHashSet;\n use std::borrow::Cow;\n-use std::iter;\n use std::path::{Path, PathBuf};\n use std::str;\n \n@@ -33,6 +32,11 @@ pub mod attr;\n \n pub mod classify;\n \n+pub(crate) mod unescape;\n+use unescape::{unescape_str, unescape_char, unescape_byte_str, unescape_byte, EscapeError};\n+\n+pub(crate) mod unescape_error_reporting;\n+\n /// Info about a parsing session.\n pub struct ParseSess {\n     pub span_diagnostic: Handler,\n@@ -306,133 +310,6 @@ pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser<'_> {\n     Parser::new(sess, stream, None, true, false)\n }\n \n-/// Parses a string representing a character literal into its final form.\n-/// Rather than just accepting/rejecting a given literal, unescapes it as\n-/// well. Can take any slice prefixed by a character escape. Returns the\n-/// character and the number of characters consumed.\n-fn char_lit(lit: &str, diag: Option<(Span, &Handler)>) -> (char, isize) {\n-    use std::char;\n-\n-    // Handle non-escaped chars first.\n-    if lit.as_bytes()[0] != b'\\\\' {\n-        // If the first byte isn't '\\\\' it might part of a multi-byte char, so\n-        // get the char with chars().\n-        let c = lit.chars().next().unwrap();\n-        return (c, 1);\n-    }\n-\n-    // Handle escaped chars.\n-    match lit.as_bytes()[1] as char {\n-        '\"' => ('\"', 2),\n-        'n' => ('\\n', 2),\n-        'r' => ('\\r', 2),\n-        't' => ('\\t', 2),\n-        '\\\\' => ('\\\\', 2),\n-        '\\'' => ('\\'', 2),\n-        '0' => ('\\0', 2),\n-        'x' => {\n-            let v = u32::from_str_radix(&lit[2..4], 16).unwrap();\n-            let c = char::from_u32(v).unwrap();\n-            (c, 4)\n-        }\n-        'u' => {\n-            assert_eq!(lit.as_bytes()[2], b'{');\n-            let idx = lit.find('}').unwrap();\n-\n-            // All digits and '_' are ascii, so treat each byte as a char.\n-            let mut v: u32 = 0;\n-            for c in lit[3..idx].bytes() {\n-                let c = char::from(c);\n-                if c != '_' {\n-                    let x = c.to_digit(16).unwrap();\n-                    v = v.checked_mul(16).unwrap().checked_add(x).unwrap();\n-                }\n-            }\n-            let c = char::from_u32(v).unwrap_or_else(|| {\n-                if let Some((span, diag)) = diag {\n-                    let mut diag = diag.struct_span_err(span, \"invalid unicode character escape\");\n-                    if v > 0x10FFFF {\n-                        diag.help(\"unicode escape must be at most 10FFFF\").emit();\n-                    } else {\n-                        diag.help(\"unicode escape must not be a surrogate\").emit();\n-                    }\n-                }\n-                '\\u{FFFD}'\n-            });\n-            (c, (idx + 1) as isize)\n-        }\n-        _ => panic!(\"lexer should have rejected a bad character escape {}\", lit)\n-    }\n-}\n-\n-/// Parses a string representing a string literal into its final form. Does unescaping.\n-fn str_lit(lit: &str, diag: Option<(Span, &Handler)>) -> String {\n-    debug!(\"str_lit: given {}\", lit.escape_default());\n-    let mut res = String::with_capacity(lit.len());\n-\n-    let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n-\n-    /// Eat everything up to a non-whitespace.\n-    fn eat<'a>(it: &mut iter::Peekable<str::CharIndices<'a>>) {\n-        loop {\n-            match it.peek().map(|x| x.1) {\n-                Some(' ') | Some('\\n') | Some('\\r') | Some('\\t') => {\n-                    it.next();\n-                },\n-                _ => { break; }\n-            }\n-        }\n-    }\n-\n-    let mut chars = lit.char_indices().peekable();\n-    while let Some((i, c)) = chars.next() {\n-        match c {\n-            '\\\\' => {\n-                let ch = chars.peek().unwrap_or_else(|| {\n-                    panic!(\"{}\", error(i))\n-                }).1;\n-\n-                if ch == '\\n' {\n-                    eat(&mut chars);\n-                } else if ch == '\\r' {\n-                    chars.next();\n-                    let ch = chars.peek().unwrap_or_else(|| {\n-                        panic!(\"{}\", error(i))\n-                    }).1;\n-\n-                    if ch != '\\n' {\n-                        panic!(\"lexer accepted bare CR\");\n-                    }\n-                    eat(&mut chars);\n-                } else {\n-                    // otherwise, a normal escape\n-                    let (c, n) = char_lit(&lit[i..], diag);\n-                    for _ in 0..n - 1 { // we don't need to move past the first \\\n-                        chars.next();\n-                    }\n-                    res.push(c);\n-                }\n-            },\n-            '\\r' => {\n-                let ch = chars.peek().unwrap_or_else(|| {\n-                    panic!(\"{}\", error(i))\n-                }).1;\n-\n-                if ch != '\\n' {\n-                    panic!(\"lexer accepted bare CR\");\n-                }\n-                chars.next();\n-                res.push('\\n');\n-            }\n-            c => res.push(c),\n-        }\n-    }\n-\n-    res.shrink_to_fit(); // probably not going to do anything, unless there was an escape.\n-    debug!(\"parse_str_lit: returning {}\", res);\n-    res\n-}\n-\n /// Parses a string representing a raw string literal into its final form. The\n /// only operation this does is convert embedded CRLF into a single LF.\n fn raw_str_lit(lit: &str) -> String {\n@@ -475,9 +352,23 @@ crate fn lit_token(lit: token::Lit, suf: Option<Symbol>, diag: Option<(Span, &Ha\n     use ast::LitKind;\n \n     match lit {\n-       token::Byte(i) => (true, Some(LitKind::Byte(byte_lit(&i.as_str()).0))),\n-       token::Char(i) => (true, Some(LitKind::Char(char_lit(&i.as_str(), diag).0))),\n-       token::Err(i) => (true, Some(LitKind::Err(i))),\n+        token::Byte(i) => {\n+            let lit_kind = match unescape_byte(&i.as_str()) {\n+                Ok(c) => LitKind::Byte(c),\n+                Err((_, EscapeError::MoreThanOneChar)) => LitKind::Err(i),\n+                Err(_) => LitKind::Byte(0),\n+            };\n+            (true, Some(lit_kind))\n+        },\n+        token::Char(i) => {\n+            let lit_kind = match unescape_char(&i.as_str()) {\n+                Ok(c) => LitKind::Char(c),\n+                Err((_, EscapeError::MoreThanOneChar)) => LitKind::Err(i),\n+                Err(_) => LitKind::Char('\\u{FFFD}'),\n+            };\n+            (true, Some(lit_kind))\n+        },\n+        token::Err(i) => (true, Some(LitKind::Err(i))),\n \n         // There are some valid suffixes for integer and float literals,\n         // so all the handling is done internally.\n@@ -491,7 +382,14 @@ crate fn lit_token(lit: token::Lit, suf: Option<Symbol>, diag: Option<(Span, &Ha\n             // string in the Token.\n             let s = &sym.as_str();\n             if s.as_bytes().iter().any(|&c| c == b'\\\\' || c == b'\\r') {\n-                sym = Symbol::intern(&str_lit(s, diag));\n+                let mut buf = String::with_capacity(s.len());\n+                unescape_str(s, &mut |_, unescaped_char| {\n+                    match unescaped_char {\n+                        Ok(c) => buf.push(c),\n+                        Err(_) => buf.push('\\u{FFFD}'),\n+                    }\n+                });\n+                sym = Symbol::intern(&buf)\n             }\n             (true, Some(LitKind::Str(sym, ast::StrStyle::Cooked)))\n         }\n@@ -504,7 +402,16 @@ crate fn lit_token(lit: token::Lit, suf: Option<Symbol>, diag: Option<(Span, &Ha\n             (true, Some(LitKind::Str(sym, ast::StrStyle::Raw(n))))\n         }\n         token::ByteStr(i) => {\n-            (true, Some(LitKind::ByteStr(byte_str_lit(&i.as_str()))))\n+            let s = &i.as_str();\n+            let mut buf = Vec::with_capacity(s.len());\n+            unescape_byte_str(s, &mut |_, unescaped_byte| {\n+                match unescaped_byte {\n+                    Ok(c) => buf.push(c),\n+                    Err(_) => buf.push(0),\n+                }\n+            });\n+            buf.shrink_to_fit();\n+            (true, Some(LitKind::ByteStr(Lrc::new(buf))))\n         }\n         token::ByteStrRaw(i, _) => {\n             (true, Some(LitKind::ByteStr(Lrc::new(i.to_string().into_bytes()))))\n@@ -559,95 +466,6 @@ fn float_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n     filtered_float_lit(Symbol::intern(s), suffix, diag)\n }\n \n-/// Parses a string representing a byte literal into its final form. Similar to `char_lit`.\n-fn byte_lit(lit: &str) -> (u8, usize) {\n-    let err = |i| format!(\"lexer accepted invalid byte literal {} step {}\", lit, i);\n-\n-    if lit.len() == 1 {\n-        (lit.as_bytes()[0], 1)\n-    } else {\n-        assert_eq!(lit.as_bytes()[0], b'\\\\', \"{}\", err(0));\n-        let b = match lit.as_bytes()[1] {\n-            b'\"' => b'\"',\n-            b'n' => b'\\n',\n-            b'r' => b'\\r',\n-            b't' => b'\\t',\n-            b'\\\\' => b'\\\\',\n-            b'\\'' => b'\\'',\n-            b'0' => b'\\0',\n-            _ => {\n-                match u64::from_str_radix(&lit[2..4], 16).ok() {\n-                    Some(c) =>\n-                        if c > 0xFF {\n-                            panic!(err(2))\n-                        } else {\n-                            return (c as u8, 4)\n-                        },\n-                    None => panic!(err(3))\n-                }\n-            }\n-        };\n-        (b, 2)\n-    }\n-}\n-\n-fn byte_str_lit(lit: &str) -> Lrc<Vec<u8>> {\n-    let mut res = Vec::with_capacity(lit.len());\n-\n-    let error = |i| panic!(\"lexer should have rejected {} at {}\", lit, i);\n-\n-    /// Eat everything up to a non-whitespace.\n-    fn eat<I: Iterator<Item=(usize, u8)>>(it: &mut iter::Peekable<I>) {\n-        loop {\n-            match it.peek().map(|x| x.1) {\n-                Some(b' ') | Some(b'\\n') | Some(b'\\r') | Some(b'\\t') => {\n-                    it.next();\n-                },\n-                _ => { break; }\n-            }\n-        }\n-    }\n-\n-    // byte string literals *must* be ASCII, but the escapes don't have to be\n-    let mut chars = lit.bytes().enumerate().peekable();\n-    loop {\n-        match chars.next() {\n-            Some((i, b'\\\\')) => {\n-                match chars.peek().unwrap_or_else(|| error(i)).1 {\n-                    b'\\n' => eat(&mut chars),\n-                    b'\\r' => {\n-                        chars.next();\n-                        if chars.peek().unwrap_or_else(|| error(i)).1 != b'\\n' {\n-                            panic!(\"lexer accepted bare CR\");\n-                        }\n-                        eat(&mut chars);\n-                    }\n-                    _ => {\n-                        // otherwise, a normal escape\n-                        let (c, n) = byte_lit(&lit[i..]);\n-                        // we don't need to move past the first \\\n-                        for _ in 0..n - 1 {\n-                            chars.next();\n-                        }\n-                        res.push(c);\n-                    }\n-                }\n-            },\n-            Some((i, b'\\r')) => {\n-                if chars.peek().unwrap_or_else(|| error(i)).1 != b'\\n' {\n-                    panic!(\"lexer accepted bare CR\");\n-                }\n-                chars.next();\n-                res.push(b'\\n');\n-            }\n-            Some((_, c)) => res.push(c),\n-            None => break,\n-        }\n-    }\n-\n-    Lrc::new(res)\n-}\n-\n fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n                    -> Option<ast::LitKind> {\n     // s can only be ascii, byte indexing is fine"}, {"sha": "90ee549db017b5641c8b338a9dc9b765d424edbe", "filename": "src/libsyntax/parse/unescape.rs", "status": "added", "additions": 515, "deletions": 0, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Flibsyntax%2Fparse%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Flibsyntax%2Fparse%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Funescape.rs?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -0,0 +1,515 @@\n+//! Utilities for validating  string and char literals and turning them into\n+//! values they represent.\n+\n+use std::str::Chars;\n+use std::ops::Range;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) enum EscapeError {\n+    ZeroChars,\n+    MoreThanOneChar,\n+\n+    LoneSlash,\n+    InvalidEscape,\n+    BareCarriageReturn,\n+    EscapeOnlyChar,\n+\n+    TooShortHexEscape,\n+    InvalidCharInHexEscape,\n+    OutOfRangeHexEscape,\n+\n+    NoBraceInUnicodeEscape,\n+    InvalidCharInUnicodeEscape,\n+    EmptyUnicodeEscape,\n+    UnclosedUnicodeEscape,\n+    LeadingUnderscoreUnicodeEscape,\n+    OverlongUnicodeEscape,\n+    LoneSurrogateUnicodeEscape,\n+    OutOfRangeUnicodeEscape,\n+\n+    UnicodeEscapeInByte,\n+    NonAsciiCharInByte,\n+}\n+\n+/// Takes a contents of a char literal (without quotes), and returns an\n+/// unescaped char or an error\n+pub(crate) fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n+    let mut chars = literal_text.chars();\n+    unescape_char_or_byte(&mut chars, Mode::Char)\n+        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+}\n+\n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of escaped characters or errors.\n+pub(crate) fn unescape_str<F>(literal_text: &str, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+{\n+    unescape_str_or_byte_str(literal_text, Mode::Str, callback)\n+}\n+\n+pub(crate) fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n+    let mut chars = literal_text.chars();\n+    unescape_char_or_byte(&mut chars, Mode::Byte)\n+        .map(byte_from_char)\n+        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+}\n+\n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of escaped characters or errors.\n+pub(crate) fn unescape_byte_str<F>(literal_text: &str, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<u8, EscapeError>),\n+{\n+    unescape_str_or_byte_str(literal_text, Mode::ByteStr, &mut |range, char| {\n+        callback(range, char.map(byte_from_char))\n+    })\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+pub(crate) enum Mode {\n+    Char,\n+    Str,\n+    Byte,\n+    ByteStr,\n+}\n+\n+impl Mode {\n+    fn in_single_quotes(self) -> bool {\n+        match self {\n+            Mode::Char | Mode::Byte => true,\n+            Mode::Str | Mode::ByteStr => false,\n+        }\n+    }\n+\n+    pub(crate) fn in_double_quotes(self) -> bool {\n+        !self.in_single_quotes()\n+    }\n+\n+    pub(crate) fn is_bytes(self) -> bool {\n+        match self {\n+            Mode::Byte | Mode::ByteStr => true,\n+            Mode::Char | Mode::Str => false,\n+        }\n+    }\n+}\n+\n+\n+fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+    if first_char != '\\\\' {\n+        return match first_char {\n+            '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n+            '\\r' => Err(if chars.clone().next() == Some('\\n') {\n+                EscapeError::EscapeOnlyChar\n+            } else {\n+                EscapeError::BareCarriageReturn\n+            }),\n+            '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n+            '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n+            _ => {\n+                if mode.is_bytes() && !first_char.is_ascii() {\n+                    return Err(EscapeError::NonAsciiCharInByte);\n+                }\n+                Ok(first_char)\n+            }\n+        };\n+    }\n+\n+    let second_char = chars.next().ok_or(EscapeError::LoneSlash)?;\n+\n+    let res = match second_char {\n+        '\"' => '\"',\n+        'n' => '\\n',\n+        'r' => '\\r',\n+        't' => '\\t',\n+        '\\\\' => '\\\\',\n+        '\\'' => '\\'',\n+        '0' => '\\0',\n+\n+        'x' => {\n+            let hi = chars.next().ok_or(EscapeError::TooShortHexEscape)?;\n+            let hi = hi.to_digit(16).ok_or(EscapeError::InvalidCharInHexEscape)?;\n+\n+            let lo = chars.next().ok_or(EscapeError::TooShortHexEscape)?;\n+            let lo = lo.to_digit(16).ok_or(EscapeError::InvalidCharInHexEscape)?;\n+\n+            let value = hi * 16 + lo;\n+\n+            if !mode.is_bytes() && !is_ascii(value) {\n+                return Err(EscapeError::OutOfRangeHexEscape);\n+            }\n+            let value = value as u8;\n+\n+            value as char\n+        }\n+\n+        'u' => {\n+            if chars.next() != Some('{') {\n+                return Err(EscapeError::NoBraceInUnicodeEscape);\n+            }\n+\n+            let mut n_digits = 1;\n+            let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n+                '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n+                '}' => return Err(EscapeError::EmptyUnicodeEscape),\n+                c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n+            };\n+\n+            loop {\n+                match chars.next() {\n+                    None => return Err(EscapeError::UnclosedUnicodeEscape),\n+                    Some('_') => continue,\n+                    Some('}') => {\n+                        if n_digits > 6 {\n+                            return Err(EscapeError::OverlongUnicodeEscape);\n+                        }\n+                        if mode.is_bytes() {\n+                            return Err(EscapeError::UnicodeEscapeInByte);\n+                        }\n+\n+                        break std::char::from_u32(value).ok_or_else(|| {\n+                            if value > 0x10FFFF {\n+                                EscapeError::OutOfRangeUnicodeEscape\n+                            } else {\n+                                EscapeError::LoneSurrogateUnicodeEscape\n+                            }\n+                        })?;\n+                    }\n+                    Some(c) => {\n+                        let digit = c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n+                        n_digits += 1;\n+                        if n_digits > 6 {\n+                            continue;\n+                        }\n+                        let digit = digit as u32;\n+                        value = value * 16 + digit;\n+                    }\n+                };\n+            }\n+        }\n+        _ => return Err(EscapeError::InvalidEscape),\n+    };\n+    Ok(res)\n+}\n+\n+fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+    let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n+    let res = scan_escape(first_char, chars, mode)?;\n+    if chars.next().is_some() {\n+        return Err(EscapeError::MoreThanOneChar);\n+    }\n+    Ok(res)\n+}\n+\n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of escaped characters or errors.\n+fn unescape_str_or_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+{\n+    assert!(mode.in_double_quotes());\n+    let initial_len = src.len();\n+    let mut chars = src.chars();\n+    while let Some(first_char) = chars.next() {\n+        let start = initial_len - chars.as_str().len() - first_char.len_utf8();\n+\n+        let unescaped_char = match first_char {\n+            '\\\\' => {\n+                let (second_char, third_char) = {\n+                    let mut chars = chars.clone();\n+                    (chars.next(), chars.next())\n+                };\n+                match (second_char, third_char) {\n+                    (Some('\\n'), _) | (Some('\\r'), Some('\\n')) => {\n+                        skip_ascii_whitespace(&mut chars);\n+                        continue;\n+                    }\n+                    _ => scan_escape(first_char, &mut chars, mode),\n+                }\n+            }\n+            '\\r' => {\n+                let second_char = chars.clone().next();\n+                if second_char == Some('\\n') {\n+                    chars.next();\n+                    Ok('\\n')\n+                } else {\n+                    scan_escape(first_char, &mut chars, mode)\n+                }\n+            }\n+            '\\n' => Ok('\\n'),\n+            '\\t' => Ok('\\t'),\n+            _ => scan_escape(first_char, &mut chars, mode),\n+        };\n+        let end = initial_len - chars.as_str().len();\n+        callback(start..end, unescaped_char);\n+    }\n+\n+    fn skip_ascii_whitespace(chars: &mut Chars<'_>) {\n+        let str = chars.as_str();\n+        let first_non_space = str\n+            .bytes()\n+            .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n+            .unwrap_or(str.len());\n+        *chars = str[first_non_space..].chars()\n+    }\n+}\n+\n+fn byte_from_char(c: char) -> u8 {\n+    let res = c as u32;\n+    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::Byte\");\n+    res as u8\n+}\n+\n+fn is_ascii(x: u32) -> bool {\n+    x <= 0x7F\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_unescape_char_bad() {\n+        fn check(literal_text: &str, expected_error: EscapeError) {\n+            let actual_result = unescape_char(literal_text).map_err(|(_offset, err)| err);\n+            assert_eq!(actual_result, Err(expected_error));\n+        }\n+\n+        check(\"\", EscapeError::ZeroChars);\n+        check(r\"\\\", EscapeError::LoneSlash);\n+\n+        check(\"\\n\", EscapeError::EscapeOnlyChar);\n+        check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n+        check(\"\\t\", EscapeError::EscapeOnlyChar);\n+        check(\"'\", EscapeError::EscapeOnlyChar);\n+        check(\"\\r\", EscapeError::BareCarriageReturn);\n+\n+        check(\"spam\", EscapeError::MoreThanOneChar);\n+        check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n+        check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n+        check(r\"\\na\", EscapeError::MoreThanOneChar);\n+        check(r\"\\ra\", EscapeError::MoreThanOneChar);\n+        check(r\"\\ta\", EscapeError::MoreThanOneChar);\n+        check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n+        check(r\"\\'a\", EscapeError::MoreThanOneChar);\n+        check(r\"\\0a\", EscapeError::MoreThanOneChar);\n+        check(r\"\\u{0}x\", EscapeError::MoreThanOneChar);\n+        check(r\"\\u{1F63b}}\", EscapeError::MoreThanOneChar);\n+\n+        check(r\"\\v\", EscapeError::InvalidEscape);\n+        check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n+        check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+\n+        check(r\"\\x\", EscapeError::TooShortHexEscape);\n+        check(r\"\\x0\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xf\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xa\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\xff\", EscapeError::OutOfRangeHexEscape);\n+        check(r\"\\xFF\", EscapeError::OutOfRangeHexEscape);\n+        check(r\"\\x80\", EscapeError::OutOfRangeHexEscape);\n+\n+        check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n+        check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n+        check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n+        check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n+        check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n+        check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n+        check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n+        check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n+        check(r\"\\u{FFFFFF}\", EscapeError::OutOfRangeUnicodeEscape);\n+        check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n+        check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n+\n+        check(r\"\\u{DC00}\", EscapeError::LoneSurrogateUnicodeEscape);\n+        check(r\"\\u{DDDD}\", EscapeError::LoneSurrogateUnicodeEscape);\n+        check(r\"\\u{DFFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n+\n+        check(r\"\\u{D800}\", EscapeError::LoneSurrogateUnicodeEscape);\n+        check(r\"\\u{DAAA}\", EscapeError::LoneSurrogateUnicodeEscape);\n+        check(r\"\\u{DBFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n+    }\n+\n+    #[test]\n+    fn test_unescape_char_good() {\n+        fn check(literal_text: &str, expected_char: char) {\n+            let actual_result = unescape_char(literal_text);\n+            assert_eq!(actual_result, Ok(expected_char));\n+        }\n+\n+        check(\"a\", 'a');\n+        check(\"\u044b\", '\u044b');\n+        check(\"\ud83e\udd80\", '\ud83e\udd80');\n+\n+        check(r#\"\\\"\"#, '\"');\n+        check(r\"\\n\", '\\n');\n+        check(r\"\\r\", '\\r');\n+        check(r\"\\t\", '\\t');\n+        check(r\"\\\\\", '\\\\');\n+        check(r\"\\'\", '\\'');\n+        check(r\"\\0\", '\\0');\n+\n+        check(r\"\\x00\", '\\0');\n+        check(r\"\\x5a\", 'Z');\n+        check(r\"\\x5A\", 'Z');\n+        check(r\"\\x7f\", 127 as char);\n+\n+        check(r\"\\u{0}\", '\\0');\n+        check(r\"\\u{000000}\", '\\0');\n+        check(r\"\\u{41}\", 'A');\n+        check(r\"\\u{0041}\", 'A');\n+        check(r\"\\u{00_41}\", 'A');\n+        check(r\"\\u{4__1__}\", 'A');\n+        check(r\"\\u{1F63b}\", '\ud83d\ude3b');\n+    }\n+\n+    #[test]\n+    fn test_unescape_str_good() {\n+        fn check(literal_text: &str, expected: &str) {\n+            let mut buf = Ok(String::with_capacity(literal_text.len()));\n+            unescape_str(literal_text, &mut |range, c| {\n+                if let Ok(b) = &mut buf {\n+                    match c {\n+                        Ok(c) => b.push(c),\n+                        Err(e) => buf = Err((range, e)),\n+                    }\n+                }\n+            });\n+            let buf = buf.as_ref().map(|it| it.as_ref());\n+            assert_eq!(buf, Ok(expected))\n+        }\n+\n+        check(\"foo\", \"foo\");\n+        check(\"\", \"\");\n+        check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n+\n+        check(\"hello \\\\\\n     world\", \"hello world\");\n+        check(\"hello \\\\\\r\\n     world\", \"hello world\");\n+        check(\"thread's\", \"thread's\")\n+    }\n+\n+    #[test]\n+    fn test_unescape_byte_bad() {\n+        fn check(literal_text: &str, expected_error: EscapeError) {\n+            let actual_result = unescape_byte(literal_text).map_err(|(_offset, err)| err);\n+            assert_eq!(actual_result, Err(expected_error));\n+        }\n+\n+        check(\"\", EscapeError::ZeroChars);\n+        check(r\"\\\", EscapeError::LoneSlash);\n+\n+        check(\"\\n\", EscapeError::EscapeOnlyChar);\n+        check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n+        check(\"\\t\", EscapeError::EscapeOnlyChar);\n+        check(\"'\", EscapeError::EscapeOnlyChar);\n+        check(\"\\r\", EscapeError::BareCarriageReturn);\n+\n+        check(\"spam\", EscapeError::MoreThanOneChar);\n+        check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n+        check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n+        check(r\"\\na\", EscapeError::MoreThanOneChar);\n+        check(r\"\\ra\", EscapeError::MoreThanOneChar);\n+        check(r\"\\ta\", EscapeError::MoreThanOneChar);\n+        check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n+        check(r\"\\'a\", EscapeError::MoreThanOneChar);\n+        check(r\"\\0a\", EscapeError::MoreThanOneChar);\n+\n+        check(r\"\\v\", EscapeError::InvalidEscape);\n+        check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n+        check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+\n+        check(r\"\\x\", EscapeError::TooShortHexEscape);\n+        check(r\"\\x0\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xa\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xf\", EscapeError::TooShortHexEscape);\n+        check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n+        check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n+\n+        check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n+        check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n+        check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n+        check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n+        check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n+        check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n+        check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n+        check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n+\n+        check(\"\u044b\", EscapeError::NonAsciiCharInByte);\n+        check(\"\ud83e\udd80\", EscapeError::NonAsciiCharInByte);\n+\n+        check(r\"\\u{0}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{000000}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{41}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{0041}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{00_41}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{4__1__}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{1F63b}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{0}x\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{1F63b}}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{FFFFFF}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{DC00}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{DDDD}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{DFFF}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{D800}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{DAAA}\", EscapeError::UnicodeEscapeInByte);\n+        check(r\"\\u{DBFF}\", EscapeError::UnicodeEscapeInByte);\n+    }\n+\n+    #[test]\n+    fn test_unescape_byte_good() {\n+        fn check(literal_text: &str, expected_byte: u8) {\n+            let actual_result = unescape_byte(literal_text);\n+            assert_eq!(actual_result, Ok(expected_byte));\n+        }\n+\n+        check(\"a\", b'a');\n+\n+        check(r#\"\\\"\"#, b'\"');\n+        check(r\"\\n\", b'\\n');\n+        check(r\"\\r\", b'\\r');\n+        check(r\"\\t\", b'\\t');\n+        check(r\"\\\\\", b'\\\\');\n+        check(r\"\\'\", b'\\'');\n+        check(r\"\\0\", b'\\0');\n+\n+        check(r\"\\x00\", b'\\0');\n+        check(r\"\\x5a\", b'Z');\n+        check(r\"\\x5A\", b'Z');\n+        check(r\"\\x7f\", 127);\n+        check(r\"\\x80\", 128);\n+        check(r\"\\xff\", 255);\n+        check(r\"\\xFF\", 255);\n+    }\n+\n+    #[test]\n+    fn test_unescape_byte_str_good() {\n+        fn check(literal_text: &str, expected: &[u8]) {\n+            let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n+            unescape_byte_str(literal_text, &mut |range, c| {\n+                if let Ok(b) = &mut buf {\n+                    match c {\n+                        Ok(c) => b.push(c),\n+                        Err(e) => buf = Err((range, e)),\n+                    }\n+                }\n+            });\n+            let buf = buf.as_ref().map(|it| it.as_ref());\n+            assert_eq!(buf, Ok(expected))\n+        }\n+\n+        check(\"foo\", b\"foo\");\n+        check(\"\", b\"\");\n+        check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n+\n+        check(\"hello \\\\\\n     world\", b\"hello world\");\n+        check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n+        check(\"thread's\", b\"thread's\")\n+    }\n+}"}, {"sha": "22777c0884f47b786d1c3d55f8db6fd323fb410e", "filename": "src/libsyntax/parse/unescape_error_reporting.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -0,0 +1,200 @@\n+//! Utilities for rendering escape sequence errors as diagnostics.\n+\n+use std::ops::Range;\n+use std::iter::once;\n+\n+use syntax_pos::{Span, BytePos};\n+\n+use crate::errors::{Handler, Applicability};\n+\n+use super::unescape::{EscapeError, Mode};\n+\n+pub(crate) fn emit_unescape_error(\n+    handler: &Handler,\n+    // interior part of the literal, without quotes\n+    lit: &str,\n+    // full span of the literal, including quotes\n+    span_with_quotes: Span,\n+    mode: Mode,\n+    // range of the error inside `lit`\n+    range: Range<usize>,\n+    error: EscapeError,\n+) {\n+    log::debug!(\"emit_unescape_error: {:?}, {:?}, {:?}, {:?}, {:?}\",\n+                lit, span_with_quotes, mode, range, error);\n+    let span = {\n+        let Range { start, end } = range;\n+        let (start, end) = (start as u32, end as u32);\n+        let lo = span_with_quotes.lo() + BytePos(start + 1);\n+        let hi = lo + BytePos(end - start);\n+            span_with_quotes\n+            .with_lo(lo)\n+            .with_hi(hi)\n+    };\n+    let last_char = || {\n+        let c = lit[range.clone()].chars().rev().next().unwrap();\n+        let span = span.with_lo(span.hi() - BytePos(c.len_utf8() as u32));\n+        (c, span)\n+    };\n+    match error {\n+        EscapeError::LoneSurrogateUnicodeEscape => {\n+            handler.struct_span_err(span, \"invalid unicode character escape\")\n+                .help(\"unicode escape must not be a surrogate\")\n+                .emit();\n+        }\n+        EscapeError::OutOfRangeUnicodeEscape => {\n+            handler.struct_span_err(span, \"invalid unicode character escape\")\n+                .help(\"unicode escape must be at most 10FFFF\")\n+                .emit();\n+        }\n+        EscapeError::MoreThanOneChar => {\n+            handler\n+                .struct_span_err(\n+                    span_with_quotes,\n+                    \"character literal may only contain one codepoint\",\n+                )\n+                .span_suggestion(\n+                    span_with_quotes,\n+                    \"if you meant to write a `str` literal, use double quotes\",\n+                    format!(\"\\\"{}\\\"\", lit),\n+                    Applicability::MachineApplicable,\n+                ).emit()\n+        }\n+        EscapeError::EscapeOnlyChar => {\n+            let (c, _span) = last_char();\n+\n+            let mut msg = if mode.is_bytes() {\n+                \"byte constant must be escaped: \"\n+            } else {\n+                \"character constant must be escaped: \"\n+            }.to_string();\n+            push_escaped_char(&mut msg, c);\n+\n+            handler.span_err(span, msg.as_str())\n+        }\n+        EscapeError::BareCarriageReturn => {\n+            let msg = if mode.in_double_quotes() {\n+                \"bare CR not allowed in string, use \\\\r instead\"\n+            } else {\n+                \"character constant must be escaped: \\\\r\"\n+            };\n+            handler.span_err(span, msg);\n+        }\n+        EscapeError::InvalidEscape => {\n+            let (c, span) = last_char();\n+\n+            let label = if mode.is_bytes() {\n+                \"unknown byte escape\"\n+            } else {\n+                \"unknown character escape\"\n+            };\n+            let mut msg = label.to_string();\n+            msg.push_str(\": \");\n+            push_escaped_char(&mut msg, c);\n+\n+            let mut diag = handler.struct_span_err(span, msg.as_str());\n+            diag.span_label(span, label);\n+            if c == '{' || c == '}' && !mode.is_bytes() {\n+                diag.help(\"if used in a formatting string, \\\n+                           curly braces are escaped with `{{` and `}}`\");\n+            } else if c == '\\r' {\n+                diag.help(\"this is an isolated carriage return; \\\n+                           consider checking your editor and version control settings\");\n+            }\n+            diag.emit();\n+        }\n+        EscapeError::TooShortHexEscape => {\n+            handler.span_err(span, \"numeric character escape is too short\")\n+        }\n+        EscapeError::InvalidCharInHexEscape | EscapeError::InvalidCharInUnicodeEscape => {\n+            let (c, span) = last_char();\n+\n+            let mut msg = if error == EscapeError::InvalidCharInHexEscape {\n+                \"invalid character in numeric character escape: \"\n+            } else {\n+                \"invalid character in unicode escape: \"\n+            }.to_string();\n+            push_escaped_char(&mut msg, c);\n+\n+            handler.span_err(span, msg.as_str())\n+        }\n+        EscapeError::NonAsciiCharInByte => {\n+            assert!(mode.is_bytes());\n+            let (_c, span) = last_char();\n+            handler.span_err(span, \"byte constant must be ASCII. \\\n+                                    Use a \\\\xHH escape for a non-ASCII byte\")\n+        }\n+        EscapeError::OutOfRangeHexEscape => {\n+            handler.span_err(span, \"this form of character escape may only be used \\\n+                                    with characters in the range [\\\\x00-\\\\x7f]\")\n+        }\n+        EscapeError::LeadingUnderscoreUnicodeEscape => {\n+            let (_c, span) = last_char();\n+            handler.span_err(span, \"invalid start of unicode escape\")\n+        }\n+        EscapeError::OverlongUnicodeEscape => {\n+            handler.span_err(span, \"overlong unicode escape (must have at most 6 hex digits)\")\n+        }\n+        EscapeError::UnclosedUnicodeEscape => {\n+            handler.span_err(span, \"unterminated unicode escape (needed a `}`)\")\n+        }\n+        EscapeError::NoBraceInUnicodeEscape => {\n+            let msg = \"incorrect unicode escape sequence\";\n+            let mut diag = handler.struct_span_err(span, msg);\n+\n+            let mut suggestion = \"\\\\u{\".to_owned();\n+            let mut suggestion_len = 0;\n+            let (c, char_span) = last_char();\n+            let chars = once(c).chain(lit[range.end..].chars());\n+            for c in chars.take(6).take_while(|c| c.is_digit(16)) {\n+                suggestion.push(c);\n+                suggestion_len += c.len_utf8();\n+            }\n+\n+            if suggestion_len > 0 {\n+                suggestion.push('}');\n+                let lo = char_span.lo();\n+                let hi = lo + BytePos(suggestion_len as u32);\n+                diag.span_suggestion(\n+                    span.with_lo(lo).with_hi(hi),\n+                    \"format of unicode escape sequences uses braces\",\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                diag.span_label(span, msg);\n+                diag.help(\n+                    \"format of unicode escape sequences is `\\\\u{...}`\",\n+                );\n+            }\n+\n+            diag.emit();\n+        }\n+        EscapeError::UnicodeEscapeInByte => {\n+            handler.span_err(span, \"unicode escape sequences cannot be used \\\n+                                    as a byte or in a byte string\")\n+        }\n+        EscapeError::EmptyUnicodeEscape => {\n+            handler.span_err(span, \"empty unicode escape (must have at least 1 hex digit)\")\n+        }\n+        EscapeError::ZeroChars => {\n+            handler.span_err(span, \"empty character literal\")\n+        }\n+        EscapeError::LoneSlash => {\n+            panic!(\"lexer accepted unterminated literal with trailing slash\")\n+        }\n+    }\n+}\n+\n+/// Pushes a character to a message string for error reporting\n+pub(crate) fn push_escaped_char(msg: &mut String, c: char) {\n+    match c {\n+        '\\u{20}'..='\\u{7e}' => {\n+            // Don't escape \\, ' or \" for user-facing messages\n+            msg.push(c);\n+        }\n+        _ => {\n+            msg.extend(c.escape_default());\n+        }\n+    }\n+}"}, {"sha": "e9169d338f7eca632187f6f550a7d098f7b78082", "filename": "src/test/ui/fmt/format-string-error-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.rs?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Z continue-parse-after-error\n // ignore-tidy-tab\n \n fn main() {\n@@ -76,7 +77,7 @@ raw  { \\n\n \n     println!(\"\\x7B}\\u8 {\", 1);\n     //~^ ERROR incorrect unicode escape sequence\n-    //~| ERROR argument never used\n+    //~| ERROR invalid format string: expected `'}'` but string was terminated\n \n     // note: raw strings don't escape `\\xFF` and `\\u{FF}` sequences\n     println!(r#\"\\x7B}\\u{8} {\"#, 1);"}, {"sha": "6656cc82369733df82dfdc1751ba2196945d004f", "filename": "src/test/ui/fmt/format-string-error-2.stderr", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error-2.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -1,13 +1,13 @@\n error: incorrect unicode escape sequence\n-  --> $DIR/format-string-error-2.rs:77:20\n+  --> $DIR/format-string-error-2.rs:78:20\n    |\n LL |     println!(\"\\x7B}\\u8 {\", 1);\n    |                    ^^-\n-   |                    |\n-   |                    help: format of unicode escape sequences uses braces: `\\u{8}`\n+   |                      |\n+   |                      help: format of unicode escape sequences uses braces: `\\u{8}`\n \n error: invalid format string: expected `'}'`, found `'a'`\n-  --> $DIR/format-string-error-2.rs:5:5\n+  --> $DIR/format-string-error-2.rs:6:5\n    |\n LL |     format!(\"{\n    |              - because of this opening brace\n@@ -17,7 +17,7 @@ LL |     a\");\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'b'`\n-  --> $DIR/format-string-error-2.rs:9:5\n+  --> $DIR/format-string-error-2.rs:10:5\n    |\n LL |     format!(\"{ \\\n    |              - because of this opening brace\n@@ -28,7 +28,7 @@ LL |     b\");\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'\\'`\n-  --> $DIR/format-string-error-2.rs:11:18\n+  --> $DIR/format-string-error-2.rs:12:18\n    |\n LL |     format!(r#\"{ \\\n    |                - ^ expected `}` in format string\n@@ -38,7 +38,7 @@ LL |     format!(r#\"{ \\\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'\\'`\n-  --> $DIR/format-string-error-2.rs:15:18\n+  --> $DIR/format-string-error-2.rs:16:18\n    |\n LL |     format!(r#\"{ \\n\n    |                - ^ expected `}` in format string\n@@ -48,7 +48,7 @@ LL |     format!(r#\"{ \\n\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'e'`\n-  --> $DIR/format-string-error-2.rs:21:5\n+  --> $DIR/format-string-error-2.rs:22:5\n    |\n LL |     format!(\"{ \\n\n    |              - because of this opening brace\n@@ -59,7 +59,7 @@ LL |     e\");\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'a'`\n-  --> $DIR/format-string-error-2.rs:25:5\n+  --> $DIR/format-string-error-2.rs:26:5\n    |\n LL |     {\n    |     - because of this opening brace\n@@ -69,7 +69,7 @@ LL |     a\");\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'a'`\n-  --> $DIR/format-string-error-2.rs:29:5\n+  --> $DIR/format-string-error-2.rs:30:5\n    |\n LL |     {\n    |     - because of this opening brace\n@@ -79,7 +79,7 @@ LL |     a\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'b'`\n-  --> $DIR/format-string-error-2.rs:35:5\n+  --> $DIR/format-string-error-2.rs:36:5\n    |\n LL |     { \\\n    |     - because of this opening brace\n@@ -90,7 +90,7 @@ LL |     b\");\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'b'`\n-  --> $DIR/format-string-error-2.rs:40:5\n+  --> $DIR/format-string-error-2.rs:41:5\n    |\n LL |     { \\\n    |     - because of this opening brace\n@@ -101,7 +101,7 @@ LL |     b \\\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'\\'`\n-  --> $DIR/format-string-error-2.rs:45:8\n+  --> $DIR/format-string-error-2.rs:46:8\n    |\n LL | raw  { \\\n    |      - ^ expected `}` in format string\n@@ -111,7 +111,7 @@ LL | raw  { \\\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'\\'`\n-  --> $DIR/format-string-error-2.rs:50:8\n+  --> $DIR/format-string-error-2.rs:51:8\n    |\n LL | raw  { \\n\n    |      - ^ expected `}` in format string\n@@ -121,7 +121,7 @@ LL | raw  { \\n\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'e'`\n-  --> $DIR/format-string-error-2.rs:57:5\n+  --> $DIR/format-string-error-2.rs:58:5\n    |\n LL |   { \\n\n    |   - because of this opening brace\n@@ -132,7 +132,7 @@ LL |     e\");\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: expected `'}'`, found `'a'`\n-  --> $DIR/format-string-error-2.rs:67:5\n+  --> $DIR/format-string-error-2.rs:68:5\n    |\n LL |     {\n    |     - because of this opening brace\n@@ -142,13 +142,13 @@ LL |     asdf}\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n error: 1 positional argument in format string, but no arguments were given\n-  --> $DIR/format-string-error-2.rs:70:17\n+  --> $DIR/format-string-error-2.rs:71:17\n    |\n LL |     println!(\"\\t{}\");\n    |                 ^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/format-string-error-2.rs:74:27\n+  --> $DIR/format-string-error-2.rs:75:27\n    |\n LL |     println!(\"\\x7B}\\u{8} {\", 1);\n    |                          -^ expected `'}'` in format string\n@@ -157,24 +157,26 @@ LL |     println!(\"\\x7B}\\u{8} {\", 1);\n    |\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n-error: argument never used\n-  --> $DIR/format-string-error-2.rs:77:28\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/format-string-error-2.rs:78:27\n    |\n LL |     println!(\"\\x7B}\\u8 {\", 1);\n-   |              ------------  ^ argument never used\n-   |              |\n-   |              formatting specifier missing\n+   |                          -^ expected `'}'` in format string\n+   |                          |\n+   |                          because of this opening brace\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/format-string-error-2.rs:82:21\n+  --> $DIR/format-string-error-2.rs:83:21\n    |\n LL |     println!(r#\"\\x7B}\\u{8} {\"#, 1);\n    |                     ^ unmatched `}` in format string\n    |\n    = note: if you intended to print `}`, you can escape it using `}}`\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/format-string-error-2.rs:85:21\n+  --> $DIR/format-string-error-2.rs:86:21\n    |\n LL |     println!(r#\"\\x7B}\\u8 {\"#, 1);\n    |                     ^ unmatched `}` in format string"}, {"sha": "391677917580bee901285fca8bae5322c6cd6456", "filename": "src/test/ui/parser/ascii-only-character-escape.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fascii-only-character-escape.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fascii-only-character-escape.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fascii-only-character-escape.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -1,20 +1,20 @@\n error: this form of character escape may only be used with characters in the range [\\x00-\\x7f]\n-  --> $DIR/ascii-only-character-escape.rs:4:16\n+  --> $DIR/ascii-only-character-escape.rs:4:14\n    |\n LL |     let x = \"\\x80\";\n-   |                ^^\n+   |              ^^^^\n \n error: this form of character escape may only be used with characters in the range [\\x00-\\x7f]\n-  --> $DIR/ascii-only-character-escape.rs:5:16\n+  --> $DIR/ascii-only-character-escape.rs:5:14\n    |\n LL |     let y = \"\\xff\";\n-   |                ^^\n+   |              ^^^^\n \n error: this form of character escape may only be used with characters in the range [\\x00-\\x7f]\n-  --> $DIR/ascii-only-character-escape.rs:6:16\n+  --> $DIR/ascii-only-character-escape.rs:6:14\n    |\n LL |     let z = \"\\xe2\";\n-   |                ^^\n+   |              ^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "58a5797b907761f3d9175de9582d4c24ea0feb35", "filename": "src/test/ui/parser/byte-literals.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -34,11 +34,11 @@ error: byte constant must be ASCII. Use a \\xHH escape for a non-ASCII byte\n LL |     b'\u00e9';\n    |       ^\n \n-error: unterminated byte constant: b'a\n-  --> $DIR/byte-literals.rs:14:5\n+error: unterminated byte constant\n+  --> $DIR/byte-literals.rs:14:6\n    |\n LL |     b'a\n-   |     ^^^\n+   |      ^^^^\n \n error: aborting due to 7 previous errors\n "}, {"sha": "eeb2fcd12320bd2baa95e189c297eee336cc5879", "filename": "src/test/ui/parser/byte-string-literals.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -23,10 +23,10 @@ LL |     b\"\u00e9\";\n    |       ^\n \n error: unterminated double quote byte string\n-  --> $DIR/byte-string-literals.rs:9:7\n+  --> $DIR/byte-string-literals.rs:9:6\n    |\n LL |       b\"a\n-   |  _______^\n+   |  ______^\n LL | | }\n    | |__^\n "}, {"sha": "53629973a1b5f002a873bffd4e110aba9354c9de", "filename": "src/test/ui/parser/issue-23620-invalid-escapes.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.rs?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -9,32 +9,27 @@ fn main() {\n \n     let _ = b'\\u';\n     //~^ ERROR incorrect unicode escape sequence\n-    //~^^ ERROR unicode escape sequences cannot be used as a byte or in a byte string\n \n     let _ = b'\\x5';\n     //~^ ERROR numeric character escape is too short\n \n     let _ = b'\\xxy';\n     //~^ ERROR invalid character in numeric character escape: x\n-    //~^^ ERROR invalid character in numeric character escape: y\n \n     let _ = '\\x5';\n     //~^ ERROR numeric character escape is too short\n \n     let _ = '\\xxy';\n     //~^ ERROR invalid character in numeric character escape: x\n-    //~^^ ERROR invalid character in numeric character escape: y\n \n     let _ = b\"\\u{a4a4} \\xf \\u\";\n     //~^ ERROR unicode escape sequences cannot be used as a byte or in a byte string\n     //~^^ ERROR invalid character in numeric character escape:\n     //~^^^ ERROR incorrect unicode escape sequence\n-    //~^^^^ ERROR unicode escape sequences cannot be used as a byte or in a byte string\n \n     let _ = \"\\xf \\u\";\n     //~^ ERROR invalid character in numeric character escape:\n-    //~^^ ERROR form of character escape may only be used with characters in the range [\\x00-\\x7f]\n-    //~^^^ ERROR incorrect unicode escape sequence\n+    //~^^ ERROR incorrect unicode escape sequence\n \n     let _ = \"\\u8f\";\n     //~^ ERROR incorrect unicode escape sequence"}, {"sha": "5fabc1d7e4326643f6238fb2fc643bcb5ede6c10", "filename": "src/test/ui/parser/issue-23620-invalid-escapes.stderr", "status": "modified", "additions": 15, "deletions": 45, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-23620-invalid-escapes.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -18,101 +18,71 @@ LL |     let _ = b'\\u';\n    |\n    = help: format of unicode escape sequences is `\\u{...}`\n \n-error: unicode escape sequences cannot be used as a byte or in a byte string\n-  --> $DIR/issue-23620-invalid-escapes.rs:10:15\n-   |\n-LL |     let _ = b'\\u';\n-   |               ^^\n-\n error: numeric character escape is too short\n-  --> $DIR/issue-23620-invalid-escapes.rs:14:17\n+  --> $DIR/issue-23620-invalid-escapes.rs:13:15\n    |\n LL |     let _ = b'\\x5';\n-   |                 ^\n+   |               ^^^\n \n error: invalid character in numeric character escape: x\n-  --> $DIR/issue-23620-invalid-escapes.rs:17:17\n+  --> $DIR/issue-23620-invalid-escapes.rs:16:17\n    |\n LL |     let _ = b'\\xxy';\n    |                 ^\n \n-error: invalid character in numeric character escape: y\n-  --> $DIR/issue-23620-invalid-escapes.rs:17:18\n-   |\n-LL |     let _ = b'\\xxy';\n-   |                  ^\n-\n error: numeric character escape is too short\n-  --> $DIR/issue-23620-invalid-escapes.rs:21:16\n+  --> $DIR/issue-23620-invalid-escapes.rs:19:14\n    |\n LL |     let _ = '\\x5';\n-   |                ^\n+   |              ^^^\n \n error: invalid character in numeric character escape: x\n-  --> $DIR/issue-23620-invalid-escapes.rs:24:16\n+  --> $DIR/issue-23620-invalid-escapes.rs:22:16\n    |\n LL |     let _ = '\\xxy';\n    |                ^\n \n-error: invalid character in numeric character escape: y\n-  --> $DIR/issue-23620-invalid-escapes.rs:24:17\n-   |\n-LL |     let _ = '\\xxy';\n-   |                 ^\n-\n error: unicode escape sequences cannot be used as a byte or in a byte string\n-  --> $DIR/issue-23620-invalid-escapes.rs:28:15\n+  --> $DIR/issue-23620-invalid-escapes.rs:25:15\n    |\n LL |     let _ = b\"\\u{a4a4} \\xf \\u\";\n    |               ^^^^^^^^\n \n error: invalid character in numeric character escape:  \n-  --> $DIR/issue-23620-invalid-escapes.rs:28:27\n+  --> $DIR/issue-23620-invalid-escapes.rs:25:27\n    |\n LL |     let _ = b\"\\u{a4a4} \\xf \\u\";\n    |                           ^\n \n error: incorrect unicode escape sequence\n-  --> $DIR/issue-23620-invalid-escapes.rs:28:28\n+  --> $DIR/issue-23620-invalid-escapes.rs:25:28\n    |\n LL |     let _ = b\"\\u{a4a4} \\xf \\u\";\n    |                            ^^ incorrect unicode escape sequence\n    |\n    = help: format of unicode escape sequences is `\\u{...}`\n \n-error: unicode escape sequences cannot be used as a byte or in a byte string\n-  --> $DIR/issue-23620-invalid-escapes.rs:28:28\n-   |\n-LL |     let _ = b\"\\u{a4a4} \\xf \\u\";\n-   |                            ^^\n-\n error: invalid character in numeric character escape:  \n-  --> $DIR/issue-23620-invalid-escapes.rs:34:17\n+  --> $DIR/issue-23620-invalid-escapes.rs:30:17\n    |\n LL |     let _ = \"\\xf \\u\";\n    |                 ^\n \n-error: this form of character escape may only be used with characters in the range [\\x00-\\x7f]\n-  --> $DIR/issue-23620-invalid-escapes.rs:34:16\n-   |\n-LL |     let _ = \"\\xf \\u\";\n-   |                ^^\n-\n error: incorrect unicode escape sequence\n-  --> $DIR/issue-23620-invalid-escapes.rs:34:18\n+  --> $DIR/issue-23620-invalid-escapes.rs:30:18\n    |\n LL |     let _ = \"\\xf \\u\";\n    |                  ^^ incorrect unicode escape sequence\n    |\n    = help: format of unicode escape sequences is `\\u{...}`\n \n error: incorrect unicode escape sequence\n-  --> $DIR/issue-23620-invalid-escapes.rs:39:14\n+  --> $DIR/issue-23620-invalid-escapes.rs:34:14\n    |\n LL |     let _ = \"\\u8f\";\n    |              ^^--\n-   |              |\n-   |              help: format of unicode escape sequences uses braces: `\\u{8f}`\n+   |                |\n+   |                help: format of unicode escape sequences uses braces: `\\u{8f}`\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "000d155c268336a46bf1468b72718bc817cf17ac", "filename": "src/test/ui/parser/lex-bad-char-literals-1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-1.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -1,14 +1,14 @@\n error: numeric character escape is too short\n-  --> $DIR/lex-bad-char-literals-1.rs:3:8\n+  --> $DIR/lex-bad-char-literals-1.rs:3:6\n    |\n LL |     '\\x1'\n-   |        ^\n+   |      ^^^\n \n error: numeric character escape is too short\n-  --> $DIR/lex-bad-char-literals-1.rs:7:8\n+  --> $DIR/lex-bad-char-literals-1.rs:7:6\n    |\n LL |     \"\\x1\"\n-   |        ^\n+   |      ^^^\n \n error: unknown character escape: \\u{25cf}\n   --> $DIR/lex-bad-char-literals-1.rs:11:7"}, {"sha": "b0a4ed02434b4bd8ef19178b6bb8f415abdde788", "filename": "src/test/ui/parser/lex-bad-char-literals-2.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-2.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -3,6 +3,10 @@ error: character literal may only contain one codepoint\n    |\n LL |     'nope'\n    |     ^^^^^^\n+help: if you meant to write a `str` literal, use double quotes\n+   |\n+LL |     \"nope\"\n+   |     ^^^^^^\n \n error[E0601]: `main` function not found in crate `lex_bad_char_literals_2`\n    |"}, {"sha": "de0a19df99360e875e979f7b45a27837b1908ffa", "filename": "src/test/ui/parser/lex-bad-char-literals-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-4.rs?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -1,5 +1,5 @@\n //\n // This test needs to the last one appearing in this file as it kills the parser\n static c: char =\n-    '\u25cf  //~ ERROR: character literal may only contain one codepoint\n+    '\u25cf  //~ ERROR: unterminated character literal\n ;"}, {"sha": "8f8f806f6cf61a33e022bfc61c6d267239964bc1", "filename": "src/test/ui/parser/lex-bad-char-literals-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-4.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -1,8 +1,8 @@\n-error: character literal may only contain one codepoint: '\u25cf\n+error: unterminated character literal\n   --> $DIR/lex-bad-char-literals-4.rs:4:5\n    |\n LL |     '\u25cf\n-   |     ^^\n+   |     ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "a7bbe05e94b7b7a15c6536203cd173b8e9f9380c", "filename": "src/test/ui/parser/lex-bad-char-literals-6.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-6.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -3,18 +3,30 @@ error: character literal may only contain one codepoint\n    |\n LL |     let x: &str = 'ab';\n    |                   ^^^^\n+help: if you meant to write a `str` literal, use double quotes\n+   |\n+LL |     let x: &str = \"ab\";\n+   |                   ^^^^\n \n error: character literal may only contain one codepoint\n   --> $DIR/lex-bad-char-literals-6.rs:4:19\n    |\n LL |     let y: char = 'cd';\n    |                   ^^^^\n+help: if you meant to write a `str` literal, use double quotes\n+   |\n+LL |     let y: char = \"cd\";\n+   |                   ^^^^\n \n error: character literal may only contain one codepoint\n   --> $DIR/lex-bad-char-literals-6.rs:6:13\n    |\n LL |     let z = 'ef';\n    |             ^^^^\n+help: if you meant to write a `str` literal, use double quotes\n+   |\n+LL |     let z = \"ef\";\n+   |             ^^^^\n \n error[E0277]: can't compare `&str` with `char`\n   --> $DIR/lex-bad-char-literals-6.rs:9:10"}, {"sha": "70eafcb91dacb9c2a9de8cc307d68e550a5903fd", "filename": "src/test/ui/parser/lex-bad-char-literals-7.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-7.rs?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Z continue-parse-after-error\n+fn main() {\n+    let _: char = '';\n+    //~^ ERROR: empty character literal\n+    let _: char = '\\u{}';\n+    //~^ ERROR: empty unicode escape (must have at least 1 hex digit)\n+\n+    // Next two are OK, but may befool error recovery\n+    let _ = '/';\n+    let _ = b'/';\n+\n+    let _ = ' hello // here's a comment\n+    //~^ ERROR: unterminated character literal\n+}"}, {"sha": "e1ba3c3ee0f170a7eaaa2e9515a00d8c73616ff7", "filename": "src/test/ui/parser/lex-bad-char-literals-7.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-7.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -0,0 +1,20 @@\n+error: empty character literal\n+  --> $DIR/lex-bad-char-literals-7.rs:3:20\n+   |\n+LL |     let _: char = '';\n+   |                    ^\n+\n+error: empty unicode escape (must have at least 1 hex digit)\n+  --> $DIR/lex-bad-char-literals-7.rs:5:20\n+   |\n+LL |     let _: char = '\\u{}';\n+   |                    ^^^^\n+\n+error: unterminated character literal\n+  --> $DIR/lex-bad-char-literals-7.rs:12:13\n+   |\n+LL |     let _ = ' hello // here's a comment\n+   |             ^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "c3fc754b5567f102922ad91b11fc4cb7b44b1c37", "filename": "src/test/ui/parser/macro/literals-are-validated-before-expansion.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fliterals-are-validated-before-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fliterals-are-validated-before-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fliterals-are-validated-before-expansion.rs?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -0,0 +1,10 @@\n+macro_rules! black_hole {\n+    ($($tt:tt)*) => {}\n+}\n+\n+fn main() {\n+    black_hole! { '\\u{FFFFFF}' }\n+    //~^ ERROR: invalid unicode character escape\n+    black_hole! { \"this is surrogate: \\u{DAAA}\" }\n+    //~^ ERROR: invalid unicode character escape\n+}"}, {"sha": "d20eb0fb30a49c0e71edb37483e1b8828822dd79", "filename": "src/test/ui/parser/macro/literals-are-validated-before-expansion.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fliterals-are-validated-before-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fliterals-are-validated-before-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fliterals-are-validated-before-expansion.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -0,0 +1,18 @@\n+error: invalid unicode character escape\n+  --> $DIR/literals-are-validated-before-expansion.rs:6:20\n+   |\n+LL |     black_hole! { '\\u{FFFFFF}' }\n+   |                    ^^^^^^^^^^\n+   |\n+   = help: unicode escape must be at most 10FFFF\n+\n+error: invalid unicode character escape\n+  --> $DIR/literals-are-validated-before-expansion.rs:8:39\n+   |\n+LL |     black_hole! { \"this is surrogate: \\u{DAAA}\" }\n+   |                                       ^^^^^^^^\n+   |\n+   = help: unicode escape must not be a surrogate\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "22d6a0981ffd6d7275f1b7ab83e47e98f3f1e778", "filename": "src/test/ui/parser/new-unicode-escapes-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fnew-unicode-escapes-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fnew-unicode-escapes-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnew-unicode-escapes-1.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -1,8 +1,8 @@\n error: unterminated unicode escape (needed a `}`)\n-  --> $DIR/new-unicode-escapes-1.rs:2:21\n+  --> $DIR/new-unicode-escapes-1.rs:2:14\n    |\n LL |     let s = \"\\u{2603\";\n-   |                     ^\n+   |              ^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b5148279c7450c1f5c9bc8b452a98530d6f16859", "filename": "src/test/ui/parser/new-unicode-escapes-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fnew-unicode-escapes-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fnew-unicode-escapes-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnew-unicode-escapes-2.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -1,8 +1,8 @@\n error: overlong unicode escape (must have at most 6 hex digits)\n-  --> $DIR/new-unicode-escapes-2.rs:2:17\n+  --> $DIR/new-unicode-escapes-2.rs:2:14\n    |\n LL |     let s = \"\\u{260311111111}\";\n-   |                 ^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "361698467f97d9b33efc3c2cd00c47b7f11a4ffc", "filename": "src/test/ui/parser/new-unicode-escapes-3.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fnew-unicode-escapes-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab/src%2Ftest%2Fui%2Fparser%2Fnew-unicode-escapes-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnew-unicode-escapes-3.stderr?ref=bfa5f278472d0bad4e7db4a4259b2f1fa97ca0ab", "patch": "@@ -1,16 +1,16 @@\n error: invalid unicode character escape\n-  --> $DIR/new-unicode-escapes-3.rs:2:14\n+  --> $DIR/new-unicode-escapes-3.rs:2:15\n    |\n LL |     let s1 = \"\\u{d805}\";\n-   |              ^^^^^^^^^^\n+   |               ^^^^^^^^\n    |\n    = help: unicode escape must not be a surrogate\n \n error: invalid unicode character escape\n-  --> $DIR/new-unicode-escapes-3.rs:3:14\n+  --> $DIR/new-unicode-escapes-3.rs:3:15\n    |\n LL |     let s2 = \"\\u{ffffff}\";\n-   |              ^^^^^^^^^^^^\n+   |               ^^^^^^^^^^\n    |\n    = help: unicode escape must be at most 10FFFF\n "}]}