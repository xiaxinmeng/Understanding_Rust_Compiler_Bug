{"sha": "511f0b8a3de5a166fc96aba5170782c9abf92101", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMWYwYjhhM2RlNWExNjZmYzk2YWJhNTE3MDc4MmM5YWJmOTIxMDE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-09T20:37:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-07T20:18:08Z"}, "message": "std: Stabilize the std::hash module\n\nThis commit aims to prepare the `std::hash` module for alpha by formalizing its\ncurrent interface whileholding off on adding `#[stable]` to the new APIs.  The\ncurrent usage with the `HashMap` and `HashSet` types is also reconciled by\nseparating out composable parts of the design. The primary goal of this slight\nredesign is to separate the concepts of a hasher's state from a hashing\nalgorithm itself.\n\nThe primary change of this commit is to separate the `Hasher` trait into a\n`Hasher` and a `HashState` trait. Conceptually the old `Hasher` trait was\nactually just a factory for various states, but hashing had very little control\nover how these states were used. Additionally the old `Hasher` trait was\nactually fairly unrelated to hashing.\n\nThis commit redesigns the existing `Hasher` trait to match what the notion of a\n`Hasher` normally implies with the following definition:\n\n    trait Hasher {\n        type Output;\n        fn reset(&mut self);\n        fn finish(&self) -> Output;\n    }\n\nThis `Hasher` trait emphasizes that hashing algorithms may produce outputs other\nthan a `u64`, so the output type is made generic. Other than that, however, very\nlittle is assumed about a particular hasher. It is left up to implementors to\nprovide specific methods or trait implementations to feed data into a hasher.\n\nThe corresponding `Hash` trait becomes:\n\n    trait Hash<H: Hasher> {\n        fn hash(&self, &mut H);\n    }\n\nThe old default of `SipState` was removed from this trait as it's not something\nthat we're willing to stabilize until the end of time, but the type parameter is\nalways required to implement `Hasher`. Note that the type parameter `H` remains\non the trait to enable multidispatch for specialization of hashing for\nparticular hashers.\n\nNote that `Writer` is not mentioned in either of `Hash` or `Hasher`, it is\nsimply used as part `derive` and the implementations for all primitive types.\n\nWith these definitions, the old `Hasher` trait is realized as a new `HashState`\ntrait in the `collections::hash_state` module as an unstable addition for\nnow. The current definition looks like:\n\n    trait HashState {\n        type Hasher: Hasher;\n        fn hasher(&self) -> Hasher;\n    }\n\nThe purpose of this trait is to emphasize that the one piece of functionality\nfor implementors is that new instances of `Hasher` can be created.  This\nconceptually represents the two keys from which more instances of a\n`SipHasher` can be created, and a `HashState` is what's stored in a\n`HashMap`, not a `Hasher`.\n\nImplementors of custom hash algorithms should implement the `Hasher` trait, and\nonly hash algorithms intended for use in hash maps need to implement or worry\nabout the `HashState` trait.\n\nThe entire module and `HashState` infrastructure remains `#[unstable]` due to it\nbeing recently redesigned, but some other stability decision made for the\n`std::hash` module are:\n\n* The `Writer` trait remains `#[experimental]` as it's intended to be replaced\n  with an `io::Writer` (more details soon).\n* The top-level `hash` function is `#[unstable]` as it is intended to be generic\n  over the hashing algorithm instead of hardwired to `SipHasher`\n* The inner `sip` module is now private as its one export, `SipHasher` is\n  reexported in the `hash` module.\n\nAnd finally, a few changes were made to the default parameters on `HashMap`.\n\n* The `RandomSipHasher` default type parameter was renamed to `RandomState`.\n  This renaming emphasizes that it is not a hasher, but rather just state to\n  generate hashers. It also moves away from the name \"sip\" as it may not always\n  be implemented as `SipHasher`. This type lives in the\n  `std::collections::hash_map` module as `#[unstable]`\n\n* The associated `Hasher` type of `RandomState` is creatively called...\n  `Hasher`! This concrete structure lives next to `RandomState` as an\n  implemenation of the \"default hashing algorithm\" used for a `HashMap`. Under\n  the hood this is currently implemented as `SipHasher`, but it draws an\n  explicit interface for now and allows us to modify the implementation over\n  time if necessary.\n\nThere are many breaking changes outlined above, and as a result this commit is\na:\n\n[breaking-change]", "tree": {"sha": "89f96ae820351742b56d424decfa393a1660e049", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89f96ae820351742b56d424decfa393a1660e049"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/511f0b8a3de5a166fc96aba5170782c9abf92101", "comment_count": 10, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/511f0b8a3de5a166fc96aba5170782c9abf92101", "html_url": "https://github.com/rust-lang/rust/commit/511f0b8a3de5a166fc96aba5170782c9abf92101", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/511f0b8a3de5a166fc96aba5170782c9abf92101/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e4e524e0eb17c8f463e731f23b544003e8709c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e4e524e0eb17c8f463e731f23b544003e8709c6", "html_url": "https://github.com/rust-lang/rust/commit/9e4e524e0eb17c8f463e731f23b544003e8709c6"}], "stats": {"total": 2073, "additions": 1061, "deletions": 1012}, "files": [{"sha": "ac8cf543a423a402323fb2a2ab56fb4fafb9e2cc", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"bin\"]\n-#![feature(slicing_syntax, unboxed_closures)]\n+#![feature(slicing_syntax)]\n \n #![deny(warnings)]\n "}, {"sha": "38d6f4dad6ea9f0072baf85facfe482705417d10", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -67,21 +67,20 @@\n //! }\n //! ```\n \n+use core::prelude::*;\n+\n use core::atomic;\n use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::borrow::BorrowFrom;\n-use core::clone::Clone;\n use core::fmt::{self, Show};\n-use core::cmp::{Eq, Ord, PartialEq, PartialOrd, Ordering};\n+use core::cmp::{Ordering};\n use core::default::Default;\n-use core::marker::{Sync, Send};\n-use core::mem::{min_align_of, size_of, drop};\n+use core::mem::{min_align_of, size_of};\n use core::mem;\n use core::nonzero::NonZero;\n-use core::ops::{Drop, Deref};\n-use core::option::Option;\n-use core::option::Option::{Some, None};\n-use core::ptr::{self, PtrExt};\n+use core::ops::Deref;\n+use core::ptr;\n+use core::hash::{Hash, Hasher};\n use heap::deallocate;\n \n /// An atomically reference counted wrapper for shared state.\n@@ -591,6 +590,12 @@ impl<T: Default + Sync + Send> Default for Arc<T> {\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n \n+impl<H: Hasher, T: Hash<H>> Hash<H> for Arc<T> {\n+    fn hash(&self, state: &mut H) {\n+        (**self).hash(state)\n+    }\n+}\n+\n #[cfg(test)]\n #[allow(experimental)]\n mod tests {"}, {"sha": "adca8b9cc4c27a179f79abf4ba6da6ade26987aa", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -106,12 +106,20 @@ impl<T: ?Sized + Ord> Ord for Box<T> {\n #[stable]}\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n+#[cfg(stage0)]\n impl<S: hash::Writer, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n \n /// Extension methods for an owning `Any` trait object.\n #[unstable = \"post-DST and coherence changes, this will not be a trait but \\"}, {"sha": "83eff71e2b80fc3463732f7540839cec6297316b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -10,23 +10,26 @@\n \n //! Thread-local reference-counted boxes (the `Rc<T>` type).\n //!\n-//! The `Rc<T>` type provides shared ownership of an immutable value. Destruction is deterministic,\n-//! and will occur as soon as the last owner is gone. It is marked as non-sendable because it\n-//! avoids the overhead of atomic reference counting.\n+//! The `Rc<T>` type provides shared ownership of an immutable value.\n+//! Destruction is deterministic, and will occur as soon as the last owner is\n+//! gone. It is marked as non-sendable because it avoids the overhead of atomic\n+//! reference counting.\n //!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A\n-//! `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but will return `None` if the value\n-//! has already been dropped.\n+//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n+//! to the box. A `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but\n+//! will return `None` if the value has already been dropped.\n //!\n-//! For example, a tree with parent pointers can be represented by putting the nodes behind strong\n-//! `Rc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.\n+//! For example, a tree with parent pointers can be represented by putting the\n+//! nodes behind strong `Rc<T>` pointers, and then storing the parent pointers\n+//! as `Weak<T>` pointers.\n //!\n //! # Examples\n //!\n-//! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.  We want to have our\n-//! `Gadget`s point to their `Owner`. We can't do this with unique ownership, because more than one\n-//! gadget may belong to the same `Owner`. `Rc<T>` allows us to share an `Owner` between multiple\n-//! `Gadget`s, and have the `Owner` remain allocated as long as any `Gadget` points at it.\n+//! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n+//! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n+//! unique ownership, because more than one gadget may belong to the same\n+//! `Owner`. `Rc<T>` allows us to share an `Owner` between multiple `Gadget`s,\n+//! and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n //! ```rust\n //! use std::rc::Rc;\n@@ -597,12 +600,20 @@ impl<T: Ord> Ord for Rc<T> {\n }\n \n // FIXME (#18248) Make `T` `Sized?`\n+#[cfg(stage0)]\n impl<S: hash::Writer, T: Hash<S>> Hash<S> for Rc<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n \n #[experimental = \"Show is experimental.\"]\n impl<T: fmt::Show> fmt::Show for Rc<T> {"}, {"sha": "f7277d4dfd8fcfefcdf7152babef4522fdeb9680", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -982,7 +982,7 @@ impl fmt::Show for Bitv {\n }\n \n #[stable]\n-impl<S: hash::Writer> hash::Hash<S> for Bitv {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n         for elem in self.blocks() {\n@@ -1742,7 +1742,7 @@ impl fmt::Show for BitvSet {\n     }\n }\n \n-impl<S: hash::Writer> hash::Hash<S> for BitvSet {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n     fn hash(&self, state: &mut S) {\n         for pos in self.iter() {\n             pos.hash(state);"}, {"sha": "3e1533dd35f598aad43903e14b74774627c0af14", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -23,7 +23,9 @@ use core::borrow::BorrowFrom;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Show;\n-use core::hash::{Writer, Hash};\n+use core::hash::{Hash, Hasher};\n+#[cfg(stage0)]\n+use core::hash::Writer;\n use core::iter::{Map, FromIterator};\n use core::ops::{Index, IndexMut};\n use core::{iter, fmt, mem};\n@@ -820,13 +822,23 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n }\n \n #[stable]\n+#[cfg(stage0)]\n impl<S: Writer, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n         for elt in self.iter() {\n             elt.hash(state);\n         }\n     }\n }\n+#[stable]\n+#[cfg(not(stage0))]\n+impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n+    fn hash(&self, state: &mut S) {\n+        for elt in self.iter() {\n+            elt.hash(state);\n+        }\n+    }\n+}\n \n #[stable]\n impl<K: Ord, V> Default for BTreeMap<K, V> {"}, {"sha": "812cff6fab722d223997f813221b98ba5eea399c", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -678,7 +678,7 @@ mod test {\n     use prelude::*;\n \n     use super::BTreeSet;\n-    use std::hash;\n+    use std::hash::{self, SipHasher};\n \n     #[test]\n     fn test_clone_eq() {\n@@ -703,7 +703,7 @@ mod test {\n       y.insert(2);\n       y.insert(1);\n \n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n     }\n \n     struct Counter<'a, 'b> {"}, {"sha": "0b426f6016cb897af0496d139b1364622f125437", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -27,7 +27,7 @@ use alloc::boxed::Box;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::hash::{Writer, Hash};\n+use core::hash::{Writer, Hasher, Hash};\n use core::iter::{self, FromIterator};\n use core::mem;\n use core::ptr;\n@@ -675,7 +675,7 @@ impl<A: fmt::Show> fmt::Show for DList<A> {\n }\n \n #[stable]\n-impl<S: Writer, A: Hash<S>> Hash<S> for DList<A> {\n+impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n         for elt in self.iter() {\n@@ -688,7 +688,7 @@ impl<S: Writer, A: Hash<S>> Hash<S> for DList<A> {\n mod tests {\n     use prelude::*;\n     use std::rand;\n-    use std::hash;\n+    use std::hash::{self, SipHasher};\n     use std::thread::Thread;\n     use test::Bencher;\n     use test;\n@@ -951,7 +951,7 @@ mod tests {\n       let mut x = DList::new();\n       let mut y = DList::new();\n \n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n \n       x.push_back(1i);\n       x.push_back(2);\n@@ -961,7 +961,7 @@ mod tests {\n       y.push_front(2);\n       y.push_front(1);\n \n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n     }\n \n     #[test]"}, {"sha": "84cd898a263fe2a4f1ac8c800221a1aa9cd4af0a", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -23,8 +23,8 @@\n \n #![allow(unknown_features)]\n #![feature(unsafe_destructor, slicing_syntax)]\n-#![feature(old_impl_check)]\n #![feature(unboxed_closures)]\n+#![feature(old_impl_check)]\n #![no_std]\n \n #[macro_use]"}, {"sha": "a35482aa5d3c29342f18a48206ae1c85647e1df8", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -27,7 +27,7 @@ use core::ops::{Index, IndexMut};\n use core::ptr;\n use core::raw::Slice as RawSlice;\n \n-use std::hash::{Writer, Hash};\n+use std::hash::{Writer, Hash, Hasher};\n use std::cmp;\n \n use alloc::heap;\n@@ -1562,7 +1562,7 @@ impl<A: Ord> Ord for RingBuf<A> {\n }\n \n #[stable]\n-impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n+impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n         for elt in self.iter() {\n@@ -1631,7 +1631,7 @@ mod tests {\n     use prelude::*;\n     use core::iter;\n     use std::fmt::Show;\n-    use std::hash;\n+    use std::hash::{self, SipHasher};\n     use test::Bencher;\n     use test;\n \n@@ -2283,7 +2283,7 @@ mod tests {\n       y.push_back(2);\n       y.push_back(3);\n \n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n     }\n \n     #[test]"}, {"sha": "0d91a5d4a643fc9c65f0ac5ba3961559d0ba58d7", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -820,12 +820,21 @@ impl fmt::Show for String {\n }\n \n #[experimental = \"waiting on Hash stabilization\"]\n+#[cfg(stage0)]\n impl<H: hash::Writer> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         (**self).hash(hasher)\n     }\n }\n+#[experimental = \"waiting on Hash stabilization\"]\n+#[cfg(not(stage0))]\n+impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n+    #[inline]\n+    fn hash(&self, hasher: &mut H) {\n+        (**self).hash(hasher)\n+    }\n+}\n \n #[unstable = \"recent addition, needs more experience\"]\n impl<'a> Add<&'a str> for String {"}, {"sha": "ed86eaa30807868d35d12f29264f795423f0289f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -1183,12 +1183,20 @@ impl<T:Clone> Clone for Vec<T> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.as_slice().hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state);\n+    }\n+}\n \n #[experimental = \"waiting on Index stability\"]\n impl<T> Index<uint> for Vec<T> {"}, {"sha": "d4ce266d3e211b5ed45c7ebc2b7faaba5ab24389", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -18,7 +18,7 @@ use core::prelude::*;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::hash::{Hash, Writer};\n+use core::hash::{Hash, Writer, Hasher};\n use core::iter::{Enumerate, FilterMap, Map, FromIterator};\n use core::iter;\n use core::mem::replace;\n@@ -85,7 +85,7 @@ impl<V:Clone> Clone for VecMap<V> {\n     }\n }\n \n-impl<S: Writer, V: Hash<S>> Hash<S> for VecMap<V> {\n+impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n     fn hash(&self, state: &mut S) {\n         // In order to not traverse the `VecMap` twice, count the elements\n         // during iteration.\n@@ -712,7 +712,7 @@ impl<V> DoubleEndedIterator for IntoIter<V> {\n #[cfg(test)]\n mod test_map {\n     use prelude::*;\n-    use core::hash::hash;\n+    use core::hash::{hash, SipHasher};\n \n     use super::VecMap;\n \n@@ -1004,7 +1004,7 @@ mod test_map {\n         let mut x = VecMap::new();\n         let mut y = VecMap::new();\n \n-        assert!(hash(&x) == hash(&y));\n+        assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n         x.insert(1, 'a');\n         x.insert(2, 'b');\n         x.insert(3, 'c');\n@@ -1013,12 +1013,12 @@ mod test_map {\n         y.insert(2, 'b');\n         y.insert(1, 'a');\n \n-        assert!(hash(&x) == hash(&y));\n+        assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n \n         x.insert(1000, 'd');\n         x.remove(&1000);\n \n-        assert!(hash(&x) == hash(&y));\n+        assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n     }\n \n     #[test]"}, {"sha": "a82ea009e1361d571f8fe0797a15a3ad57e0e90a", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 333, "deletions": 140, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -16,8 +16,7 @@\n //! # Examples\n //!\n //! ```rust\n-//! use std::hash;\n-//! use std::hash::Hash;\n+//! use std::hash::{hash, Hash, SipHasher};\n //!\n //! #[derive(Hash)]\n //! struct Person {\n@@ -29,25 +28,23 @@\n //! let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n //! let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n //!\n-//! assert!(hash::hash(&person1) != hash::hash(&person2));\n+//! assert!(hash::<_, SipHasher>(&person1) != hash::<_, SipHasher>(&person2));\n //! ```\n //!\n //! If you need more control over how a value is hashed, you need to implement\n //! the trait `Hash`:\n //!\n //! ```rust\n-//! use std::hash;\n-//! use std::hash::Hash;\n-//! use std::hash::sip::SipState;\n+//! use std::hash::{hash, Hash, Hasher, Writer, SipHasher};\n //!\n //! struct Person {\n //!     id: uint,\n //!     name: String,\n //!     phone: u64,\n //! }\n //!\n-//! impl Hash for Person {\n-//!     fn hash(&self, state: &mut SipState) {\n+//! impl<H: Hasher + Writer> Hash<H> for Person {\n+//!     fn hash(&self, state: &mut H) {\n //!         self.id.hash(state);\n //!         self.phone.hash(state);\n //!     }\n@@ -56,186 +53,382 @@\n //! let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n //! let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n //!\n-//! assert!(hash::hash(&person1) == hash::hash(&person2));\n+//! assert_eq!(hash::<_, SipHasher>(&person1), hash::<_, SipHasher>(&person2));\n //! ```\n \n-#![allow(unused_must_use)]\n+#![unstable = \"module was recently redesigned\"]\n \n-use prelude::*;\n+use default::Default;\n \n-use borrow::{Cow, ToOwned};\n-use intrinsics::TypeId;\n-use mem;\n-use num::Int;\n+pub use self::sip::SipHasher;\n \n-/// Reexport the `sip::hash` function as our default hasher.\n-pub use self::sip::hash as hash;\n+mod sip;\n \n-pub mod sip;\n+/// A hashable type.\n+///\n+/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n+/// to compute the hash. Specific implementations of this trait may specialize\n+/// for particular instances of `H` in order to be able to optimize the hashing\n+/// behavior.\n+#[cfg(stage0)]\n+pub trait Hash<H> {\n+    /// Feeds this value into the state given, updating the hasher as necessary.\n+    fn hash(&self, state: &mut H);\n+}\n \n-/// A hashable type. The `S` type parameter is an abstract hash state that is\n-/// used by the `Hash` to compute the hash. It defaults to\n-/// `std::hash::sip::SipState`.\n-pub trait Hash<S = sip::SipState> {\n-    /// Computes the hash of a value.\n-    fn hash(&self, state: &mut S);\n+/// A hashable type.\n+///\n+/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n+/// to compute the hash. Specific implementations of this trait may specialize\n+/// for particular instances of `H` in order to be able to optimize the hashing\n+/// behavior.\n+#[cfg(not(stage0))]\n+pub trait Hash<H: Hasher> {\n+    /// Feeds this value into the state given, updating the hasher as necessary.\n+    fn hash(&self, state: &mut H);\n }\n \n-/// A trait that computes a hash for a value. The main users of this trait are\n-/// containers like `HashMap`, which need a generic way hash multiple types.\n-pub trait Hasher<S> {\n-    /// Compute the hash of a value.\n-    fn hash<T: ?Sized + Hash<S>>(&self, value: &T) -> u64;\n+/// A trait which represents the ability to hash an arbitrary stream of bytes.\n+pub trait Hasher {\n+    /// Result type of one run of hashing generated by this hasher.\n+    type Output;\n+\n+    /// Resets this hasher back to its initial state (as if it were just\n+    /// created).\n+    fn reset(&mut self);\n+\n+    /// Completes a round of hashing, producing the output hash generated.\n+    fn finish(&self) -> Self::Output;\n }\n \n+/// A common bound on the `Hasher` parameter to `Hash` implementations in order\n+/// to generically hash an aggregate.\n+#[experimental = \"this trait will likely be replaced by io::Writer\"]\n #[allow(missing_docs)]\n pub trait Writer {\n     fn write(&mut self, bytes: &[u8]);\n }\n \n+/// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n+///\n+/// The specified value will be hashed with this hasher and then the resulting\n+/// hash will be returned.\n+pub fn hash<T: Hash<H>, H: Hasher + Default>(value: &T) -> H::Output {\n+    let mut h: H = Default::default();\n+    value.hash(&mut h);\n+    h.finish()\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n \n-macro_rules! impl_hash {\n-    ($ty:ident, $uty:ident) => {\n-        impl<S: Writer> Hash<S> for $ty {\n-            #[inline]\n-            fn hash(&self, state: &mut S) {\n-                let a: [u8; ::$ty::BYTES] = unsafe {\n-                    mem::transmute((*self as $uty).to_le() as $ty)\n-                };\n-                state.write(a.as_slice())\n+#[cfg(stage0)]\n+mod impls {\n+    use prelude::*;\n+\n+    use borrow::{Cow, ToOwned};\n+    use intrinsics::TypeId;\n+    use mem;\n+    use super::{Hash, Writer};\n+    use num::Int;\n+\n+    macro_rules! impl_hash {\n+        ($ty:ident, $uty:ident) => {\n+            impl<S: Writer> Hash<S> for $ty {\n+                #[inline]\n+                fn hash(&self, state: &mut S) {\n+                    let a: [u8; ::$ty::BYTES] = unsafe {\n+                        mem::transmute((*self as $uty).to_le() as $ty)\n+                    };\n+                    state.write(a.as_slice())\n+                }\n             }\n         }\n     }\n-}\n \n-impl_hash! { u8, u8 }\n-impl_hash! { u16, u16 }\n-impl_hash! { u32, u32 }\n-impl_hash! { u64, u64 }\n-impl_hash! { uint, uint }\n-impl_hash! { i8, u8 }\n-impl_hash! { i16, u16 }\n-impl_hash! { i32, u32 }\n-impl_hash! { i64, u64 }\n-impl_hash! { int, uint }\n-\n-impl<S: Writer> Hash<S> for bool {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (*self as u8).hash(state);\n+    impl_hash! { u8, u8 }\n+    impl_hash! { u16, u16 }\n+    impl_hash! { u32, u32 }\n+    impl_hash! { u64, u64 }\n+    impl_hash! { uint, uint }\n+    impl_hash! { i8, u8 }\n+    impl_hash! { i16, u16 }\n+    impl_hash! { i32, u32 }\n+    impl_hash! { i64, u64 }\n+    impl_hash! { int, uint }\n+\n+    impl<S: Writer> Hash<S> for bool {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u8).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer> Hash<S> for char {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (*self as u32).hash(state);\n+    impl<S: Writer> Hash<S> for char {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u32).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer> Hash<S> for str {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        state.write(self.as_bytes());\n-        0xffu8.hash(state)\n+    impl<S: Writer> Hash<S> for str {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            state.write(self.as_bytes());\n+            0xffu8.hash(state)\n+        }\n     }\n-}\n \n-macro_rules! impl_hash_tuple {\n-    () => (\n-        impl<S: Writer> Hash<S> for () {\n-            #[inline]\n-            fn hash(&self, state: &mut S) {\n-                state.write(&[]);\n+    macro_rules! impl_hash_tuple {\n+        () => (\n+            impl<S> Hash<S> for () {\n+                #[inline]\n+                fn hash(&self, _state: &mut S) {}\n             }\n-        }\n-    );\n-\n-    ( $($name:ident)+) => (\n-        impl<S: Writer, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n-            #[inline]\n-            #[allow(non_snake_case)]\n-            fn hash(&self, state: &mut S) {\n-                match *self {\n-                    ($(ref $name,)*) => {\n-                        $(\n-                            $name.hash(state);\n-                        )*\n+        );\n+\n+        ( $($name:ident)+) => (\n+            impl<S, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n+                #[inline]\n+                #[allow(non_snake_case)]\n+                fn hash(&self, state: &mut S) {\n+                    match *self {\n+                        ($(ref $name,)*) => {\n+                            $(\n+                                $name.hash(state);\n+                            )*\n+                        }\n                     }\n                 }\n             }\n+        );\n+    }\n+\n+    impl_hash_tuple! {}\n+    impl_hash_tuple! { A }\n+    impl_hash_tuple! { A B }\n+    impl_hash_tuple! { A B C }\n+    impl_hash_tuple! { A B C D }\n+    impl_hash_tuple! { A B C D E }\n+    impl_hash_tuple! { A B C D E F }\n+    impl_hash_tuple! { A B C D E F G }\n+    impl_hash_tuple! { A B C D E F G H }\n+    impl_hash_tuple! { A B C D E F G H I }\n+    impl_hash_tuple! { A B C D E F G H I J }\n+    impl_hash_tuple! { A B C D E F G H I J K }\n+    impl_hash_tuple! { A B C D E F G H I J K L }\n+\n+    impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.len().hash(state);\n+            for elt in self.iter() {\n+                elt.hash(state);\n+            }\n         }\n-    );\n-}\n+    }\n+\n \n-impl_hash_tuple! {}\n-impl_hash_tuple! { A }\n-impl_hash_tuple! { A B }\n-impl_hash_tuple! { A B C }\n-impl_hash_tuple! { A B C D }\n-impl_hash_tuple! { A B C D E }\n-impl_hash_tuple! { A B C D E F }\n-impl_hash_tuple! { A B C D E F G }\n-impl_hash_tuple! { A B C D E F G H }\n-impl_hash_tuple! { A B C D E F G H I }\n-impl_hash_tuple! { A B C D E F G H I J }\n-impl_hash_tuple! { A B C D E F G H I J K }\n-impl_hash_tuple! { A B C D E F G H I J K L }\n-\n-impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.len().hash(state);\n-        for elt in self.iter() {\n-            elt.hash(state);\n+    impl<'a, S, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n         }\n     }\n-}\n \n+    impl<'a, S, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n+        }\n+    }\n \n-impl<'a, S: Writer, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n+    impl<S: Writer, T> Hash<S> for *const T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n     }\n-}\n \n-impl<'a, S: Writer, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n+    impl<S: Writer, T> Hash<S> for *mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer, T> Hash<S> for *const T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        // NB: raw-pointer Hash does _not_ dereference\n-        // to the target; it just gives you the pointer-bytes.\n-        (*self as uint).hash(state);\n+    impl<S: Writer> Hash<S> for TypeId {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.hash().hash(state)\n+        }\n     }\n-}\n \n-impl<S: Writer, T> Hash<S> for *mut T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        // NB: raw-pointer Hash does _not_ dereference\n-        // to the target; it just gives you the pointer-bytes.\n-        (*self as uint).hash(state);\n+    impl<'a, T, B: ?Sized, S> Hash<S> for Cow<'a, T, B>\n+        where B: Hash<S> + ToOwned<T>\n+    {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            Hash::hash(&**self, state)\n+        }\n     }\n }\n \n-impl<S: Writer> Hash<S> for TypeId {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.hash().hash(state)\n+#[cfg(not(stage0))]\n+mod impls {\n+    use prelude::*;\n+\n+    use borrow::{Cow, ToOwned};\n+    use intrinsics::TypeId;\n+    use mem;\n+    use super::{Hash, Writer, Hasher};\n+    use num::Int;\n+\n+    macro_rules! impl_hash {\n+        ($ty:ident, $uty:ident) => {\n+            impl<S: Writer + Hasher> Hash<S> for $ty {\n+                #[inline]\n+                fn hash(&self, state: &mut S) {\n+                    let a: [u8; ::$ty::BYTES] = unsafe {\n+                        mem::transmute((*self as $uty).to_le() as $ty)\n+                    };\n+                    state.write(a.as_slice())\n+                }\n+            }\n+        }\n+    }\n+\n+    impl_hash! { u8, u8 }\n+    impl_hash! { u16, u16 }\n+    impl_hash! { u32, u32 }\n+    impl_hash! { u64, u64 }\n+    impl_hash! { uint, uint }\n+    impl_hash! { i8, u8 }\n+    impl_hash! { i16, u16 }\n+    impl_hash! { i32, u32 }\n+    impl_hash! { i64, u64 }\n+    impl_hash! { int, uint }\n+\n+    impl<S: Writer + Hasher> Hash<S> for bool {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u8).hash(state);\n+        }\n+    }\n+\n+    impl<S: Writer + Hasher> Hash<S> for char {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u32).hash(state);\n+        }\n+    }\n+\n+    impl<S: Writer + Hasher> Hash<S> for str {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            state.write(self.as_bytes());\n+            0xffu8.hash(state)\n+        }\n+    }\n+\n+    macro_rules! impl_hash_tuple {\n+        () => (\n+            impl<S: Hasher> Hash<S> for () {\n+                #[inline]\n+                fn hash(&self, _state: &mut S) {}\n+            }\n+        );\n+\n+        ( $($name:ident)+) => (\n+            impl<S: Hasher, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n+                #[inline]\n+                #[allow(non_snake_case)]\n+                fn hash(&self, state: &mut S) {\n+                    match *self {\n+                        ($(ref $name,)*) => {\n+                            $(\n+                                $name.hash(state);\n+                            )*\n+                        }\n+                    }\n+                }\n+            }\n+        );\n+    }\n+\n+    impl_hash_tuple! {}\n+    impl_hash_tuple! { A }\n+    impl_hash_tuple! { A B }\n+    impl_hash_tuple! { A B C }\n+    impl_hash_tuple! { A B C D }\n+    impl_hash_tuple! { A B C D E }\n+    impl_hash_tuple! { A B C D E F }\n+    impl_hash_tuple! { A B C D E F G }\n+    impl_hash_tuple! { A B C D E F G H }\n+    impl_hash_tuple! { A B C D E F G H I }\n+    impl_hash_tuple! { A B C D E F G H I J }\n+    impl_hash_tuple! { A B C D E F G H I J K }\n+    impl_hash_tuple! { A B C D E F G H I J K L }\n+\n+    impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.len().hash(state);\n+            for elt in self.iter() {\n+                elt.hash(state);\n+            }\n+        }\n+    }\n+\n+\n+    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n+        }\n+    }\n+\n+    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n+        }\n     }\n-}\n \n-impl<'a, T, B: ?Sized, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        Hash::hash(&**self, state)\n+    impl<S: Writer + Hasher, T> Hash<S> for *const T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n+    }\n+\n+    impl<S: Writer + Hasher, T> Hash<S> for *mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n+    }\n+\n+    impl<S: Writer + Hasher> Hash<S> for TypeId {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.hash().hash(state)\n+        }\n+    }\n+\n+    impl<'a, T, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, T, B>\n+        where B: Hash<S> + ToOwned<T>\n+    {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            Hash::hash(&**self, state)\n+        }\n     }\n }"}, {"sha": "c20fb8457d26ed6d90d538f90028b50504dbc1f5", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 67, "deletions": 393, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -11,27 +11,27 @@\n // ignore-lexer-test FIXME #15883\n \n //! An implementation of SipHash 2-4.\n-//!\n-//! See: http://131002.net/siphash/\n-//!\n-//! Consider this as a main \"general-purpose\" hash for all hashtables: it\n-//! runs at good speed (competitive with spooky and city) and permits\n-//! strong _keyed_ hashing. Key your hashtables from a strong RNG,\n-//! such as `rand::Rng`.\n-//!\n-//! Although the SipHash algorithm is considered to be cryptographically\n-//! strong, this implementation has not been reviewed for such purposes.\n-//! As such, all cryptographic uses of this implementation are strongly\n-//! discouraged.\n \n use prelude::*;\n use default::Default;\n \n-use super::{Hash, Hasher, Writer};\n-\n-/// `SipState` computes a SipHash 2-4 hash over a stream of bytes.\n-#[derive(Copy)]\n-pub struct SipState {\n+use super::{Hasher, Writer};\n+\n+/// An implementation of SipHash 2-4.\n+///\n+/// See: http://131002.net/siphash/\n+///\n+/// Consider this as a main \"general-purpose\" hash for all hashtables: it\n+/// runs at good speed (competitive with spooky and city) and permits\n+/// strong _keyed_ hashing. Key your hashtables from a strong RNG,\n+/// such as `rand::Rng`.\n+///\n+/// Although the SipHash algorithm is considered to be cryptographically\n+/// strong, this implementation has not been reviewed for such purposes.\n+/// As such, all cryptographic uses of this implementation are strongly\n+/// discouraged.\n+#[allow(missing_copy_implementations)]\n+pub struct SipHasher {\n     k0: u64,\n     k1: u64,\n     length: uint, // how many bytes we've processed\n@@ -86,17 +86,17 @@ macro_rules! compress {\n     })\n }\n \n-impl SipState {\n-    /// Creates a `SipState` that is keyed off the provided keys.\n+impl SipHasher {\n+    /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n-    pub fn new() -> SipState {\n-        SipState::new_with_keys(0, 0)\n+    pub fn new() -> SipHasher {\n+        SipHasher::new_with_keys(0, 0)\n     }\n \n-    /// Creates a `SipState` that is keyed off the provided keys.\n+    /// Creates a `SipHasher` that is keyed off the provided keys.\n     #[inline]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipState {\n-        let mut state = SipState {\n+    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n+        let mut state = SipHasher {\n             k0: key0,\n             k1: key1,\n             length: 0,\n@@ -111,43 +111,12 @@ impl SipState {\n         state\n     }\n \n-    /// Resets the state to its initial state.\n-    #[inline]\n-    pub fn reset(&mut self) {\n-        self.length = 0;\n-        self.v0 = self.k0 ^ 0x736f6d6570736575;\n-        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n-        self.v2 = self.k0 ^ 0x6c7967656e657261;\n-        self.v3 = self.k1 ^ 0x7465646279746573;\n-        self.ntail = 0;\n-    }\n-\n     /// Returns the computed hash.\n-    #[inline]\n-    pub fn result(&self) -> u64 {\n-        let mut v0 = self.v0;\n-        let mut v1 = self.v1;\n-        let mut v2 = self.v2;\n-        let mut v3 = self.v3;\n-\n-        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n-\n-        v3 ^= b;\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        v0 ^= b;\n-\n-        v2 ^= 0xff;\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-\n-        v0 ^ v1 ^ v2 ^ v3\n-    }\n+    #[deprecated = \"renamed to finish\"]\n+    pub fn result(&self) -> u64 { self.finish() }\n }\n \n-impl Writer for SipState {\n+impl Writer for SipHasher {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n@@ -195,355 +164,60 @@ impl Writer for SipState {\n     }\n }\n \n-#[stable]\n-impl Clone for SipState {\n-    #[inline]\n-    fn clone(&self) -> SipState {\n-        *self\n-    }\n-}\n+impl Hasher for SipHasher {\n+    type Output = u64;\n \n-#[stable]\n-impl Default for SipState {\n-    #[inline]\n-    #[stable]\n-    fn default() -> SipState {\n-        SipState::new()\n+    fn reset(&mut self) {\n+        self.length = 0;\n+        self.v0 = self.k0 ^ 0x736f6d6570736575;\n+        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n+        self.v2 = self.k0 ^ 0x6c7967656e657261;\n+        self.v3 = self.k1 ^ 0x7465646279746573;\n+        self.ntail = 0;\n     }\n-}\n \n-/// `SipHasher` computes the SipHash algorithm from a stream of bytes.\n-#[derive(Clone)]\n-#[allow(missing_copy_implementations)]\n-pub struct SipHasher {\n-    k0: u64,\n-    k1: u64,\n-}\n+    fn finish(&self) -> u64 {\n+        let mut v0 = self.v0;\n+        let mut v1 = self.v1;\n+        let mut v2 = self.v2;\n+        let mut v3 = self.v3;\n \n-impl SipHasher {\n-    /// Creates a `Sip`.\n-    #[inline]\n-    pub fn new() -> SipHasher {\n-        SipHasher::new_with_keys(0, 0)\n-    }\n+        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n \n-    /// Creates a `Sip` that is keyed off the provided keys.\n-    #[inline]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n-        SipHasher {\n-            k0: key0,\n-            k1: key1,\n-        }\n+        v3 ^= b;\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        v0 ^= b;\n+\n+        v2 ^= 0xff;\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+\n+        v0 ^ v1 ^ v2 ^ v3\n     }\n }\n \n-impl Hasher<SipState> for SipHasher {\n+impl Clone for SipHasher {\n     #[inline]\n-    fn hash<T: ?Sized + Hash<SipState>>(&self, value: &T) -> u64 {\n-        let mut state = SipState::new_with_keys(self.k0, self.k1);\n-        value.hash(&mut state);\n-        state.result()\n+    fn clone(&self) -> SipHasher {\n+        SipHasher {\n+            k0: self.k0,\n+            k1: self.k1,\n+            length: self.length,\n+            v0: self.v0,\n+            v1: self.v1,\n+            v2: self.v2,\n+            v3: self.v3,\n+            tail: self.tail,\n+            ntail: self.ntail,\n+        }\n     }\n }\n \n impl Default for SipHasher {\n-    #[inline]\n     fn default() -> SipHasher {\n         SipHasher::new()\n     }\n }\n-\n-/// Hashes a value using the SipHash algorithm.\n-#[inline]\n-pub fn hash<T: ?Sized + Hash<SipState>>(value: &T) -> u64 {\n-    let mut state = SipState::new();\n-    value.hash(&mut state);\n-    state.result()\n-}\n-\n-/// Hashes a value with the SipHash algorithm with the provided keys.\n-#[inline]\n-pub fn hash_with_keys<T: ?Sized + Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n-    let mut state = SipState::new_with_keys(k0, k1);\n-    value.hash(&mut state);\n-    state.result()\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use test::Bencher;\n-    use prelude::*;\n-    use std::fmt;\n-\n-    use super::super::{Hash, Writer};\n-    use super::{SipState, hash, hash_with_keys};\n-\n-    // Hash just the bytes of the slice, without length prefix\n-    struct Bytes<'a>(&'a [u8]);\n-\n-    impl<'a, S: Writer> Hash<S> for Bytes<'a> {\n-        #[allow(unused_must_use)]\n-        fn hash(&self, state: &mut S) {\n-            let Bytes(v) = *self;\n-            state.write(v);\n-        }\n-    }\n-\n-    #[test]\n-    #[allow(unused_must_use)]\n-    fn test_siphash() {\n-        let vecs : [[u8; 8]; 64] = [\n-            [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n-            [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n-            [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n-            [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n-            [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n-            [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n-            [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n-            [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n-            [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n-            [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n-            [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n-            [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n-            [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n-            [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n-            [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n-            [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n-            [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n-            [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n-            [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n-            [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n-            [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n-            [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n-            [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n-            [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n-            [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n-            [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n-            [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n-            [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n-            [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n-            [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n-            [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n-            [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n-            [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n-            [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n-            [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n-            [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n-            [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n-            [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n-            [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n-            [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n-            [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n-            [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n-            [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n-            [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n-            [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n-            [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n-            [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n-            [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n-            [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n-            [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n-            [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n-            [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n-            [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n-            [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n-            [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n-            [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n-            [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n-            [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n-            [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n-            [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n-            [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n-            [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n-            [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n-            [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n-        ];\n-\n-        let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n-        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n-        let mut buf = Vec::new();\n-        let mut t = 0;\n-        let mut state_inc = SipState::new_with_keys(k0, k1);\n-        let mut state_full = SipState::new_with_keys(k0, k1);\n-\n-        fn to_hex_str(r: &[u8; 8]) -> String {\n-            let mut s = String::new();\n-            for b in r.iter() {\n-                s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n-            }\n-            s\n-        }\n-\n-        fn result_bytes(h: u64) -> Vec<u8> {\n-            vec![(h >> 0) as u8,\n-              (h >> 8) as u8,\n-              (h >> 16) as u8,\n-              (h >> 24) as u8,\n-              (h >> 32) as u8,\n-              (h >> 40) as u8,\n-              (h >> 48) as u8,\n-              (h >> 56) as u8,\n-            ]\n-        }\n-\n-        fn result_str(h: u64) -> String {\n-            let r = result_bytes(h);\n-            let mut s = String::new();\n-            for b in r.iter() {\n-                s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n-            }\n-            s\n-        }\n-\n-        while t < 64 {\n-            debug!(\"siphash test {}: {}\", t, buf);\n-            let vec = u8to64_le!(vecs[t], 0);\n-            let out = hash_with_keys(k0, k1, &Bytes(buf.as_slice()));\n-            debug!(\"got {}, expected {}\", out, vec);\n-            assert_eq!(vec, out);\n-\n-            state_full.reset();\n-            state_full.write(buf.as_slice());\n-            let f = result_str(state_full.result());\n-            let i = result_str(state_inc.result());\n-            let v = to_hex_str(&vecs[t]);\n-            debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n-\n-            assert_eq!(f, i);\n-            assert_eq!(f, v);\n-\n-            buf.push(t as u8);\n-            state_inc.write(&[t as u8]);\n-\n-            t += 1;\n-        }\n-    }\n-\n-    #[test] #[cfg(target_arch = \"aarch64\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!(hash(&(val as u64)), hash(&(val as uint)));\n-        assert!(hash(&(val as u32)) != hash(&(val as uint)));\n-    }\n-    #[test] #[cfg(target_arch = \"arm\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!(hash(&(val as u64)) != hash(&(val as uint)));\n-        assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n-    }\n-    #[test] #[cfg(target_arch = \"x86_64\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!(hash(&(val as u64)), hash(&(val as uint)));\n-        assert!(hash(&(val as u32)) != hash(&(val as uint)));\n-    }\n-    #[test] #[cfg(target_arch = \"x86\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!(hash(&(val as u64)) != hash(&(val as uint)));\n-        assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n-    }\n-\n-    #[test]\n-    fn test_hash_idempotent() {\n-        let val64 = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!(hash(&val64), hash(&val64));\n-        let val32 = 0xdeadbeef_u32;\n-        assert_eq!(hash(&val32), hash(&val32));\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_64() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-\n-        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 4)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 5)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 6)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 7)));\n-\n-        fn zero_byte(val: u64, byte: uint) -> u64 {\n-            assert!(byte < 8);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_32() {\n-        let val = 0xdeadbeef_u32;\n-\n-        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n-\n-        fn zero_byte(val: u32, byte: uint) -> u32 {\n-            assert!(byte < 4);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash_no_concat_alias() {\n-        let s = (\"aa\", \"bb\");\n-        let t = (\"aabb\", \"\");\n-        let u = (\"a\", \"abb\");\n-\n-        assert!(s != t && t != u);\n-        assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n-\n-        let v: (&[u8], &[u8], &[u8]) = (&[1u8], &[0u8, 0], &[0u8]);\n-        let w: (&[u8], &[u8], &[u8]) = (&[1u8, 0, 0, 0], &[], &[]);\n-\n-        assert!(v != w);\n-        assert!(hash(&v) != hash(&w));\n-    }\n-\n-    #[bench]\n-    fn bench_str_under_8_bytes(b: &mut Bencher) {\n-        let s = \"foo\";\n-        b.iter(|| {\n-            assert_eq!(hash(&s), 16262950014981195938);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_str_of_8_bytes(b: &mut Bencher) {\n-        let s = \"foobar78\";\n-        b.iter(|| {\n-            assert_eq!(hash(&s), 4898293253460910787);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_str_over_8_bytes(b: &mut Bencher) {\n-        let s = \"foobarbaz0\";\n-        b.iter(|| {\n-            assert_eq!(hash(&s), 10581415515220175264);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_long_str(b: &mut Bencher) {\n-        let s = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor \\\n-incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud \\\n-exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute \\\n-irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla \\\n-pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui \\\n-officia deserunt mollit anim id est laborum.\";\n-        b.iter(|| {\n-            assert_eq!(hash(&s), 17717065544121360093);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_u64(b: &mut Bencher) {\n-        let u = 16262950014981195938u64;\n-        b.iter(|| {\n-            assert_eq!(hash(&u), 5254097107239593357);\n-        })\n-    }\n-}"}, {"sha": "63935894bf514b99549bbec0b8eb06b9a205c74a", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 60, "deletions": 43, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -7,27 +7,22 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use core::marker::Sized;\n-use std::mem;\n-\n-use core::slice::SliceExt;\n-use core::hash::{Hash, Hasher, Writer};\n \n-struct MyWriterHasher;\n+use std::mem;\n+use std::hash::{Hash, Hasher, Writer};\n+use std::default::Default;\n \n-impl Hasher<MyWriter> for MyWriterHasher {\n-    fn hash<T: ?Sized + Hash<MyWriter>>(&self, value: &T) -> u64 {\n-        let mut state = MyWriter { hash: 0 };\n-        value.hash(&mut state);\n-        state.hash\n-    }\n+struct MyHasher {\n+    hash: u64,\n }\n \n-struct MyWriter {\n-    hash: u64,\n+impl Default for MyHasher {\n+    fn default() -> MyHasher {\n+        MyHasher { hash: 0 }\n+    }\n }\n \n-impl Writer for MyWriter {\n+impl Writer for MyHasher {\n     // Most things we'll just add up the bytes.\n     fn write(&mut self, buf: &[u8]) {\n         for byte in buf.iter() {\n@@ -36,66 +31,88 @@ impl Writer for MyWriter {\n     }\n }\n \n+impl Hasher for MyHasher {\n+    type Output = u64;\n+    fn reset(&mut self) { self.hash = 0; }\n+    fn finish(&self) -> u64 { self.hash }\n+}\n+\n+\n #[test]\n fn test_writer_hasher() {\n-    let hasher = MyWriterHasher;\n+    fn hash<T: Hash<MyHasher>>(t: &T) -> u64 {\n+        ::std::hash::hash::<_, MyHasher>(t)\n+    }\n \n-    assert_eq!(hasher.hash(&()), 0);\n+    assert_eq!(hash(&()), 0);\n \n-    assert_eq!(hasher.hash(&5u8), 5);\n-    assert_eq!(hasher.hash(&5u16), 5);\n-    assert_eq!(hasher.hash(&5u32), 5);\n-    assert_eq!(hasher.hash(&5u64), 5);\n-    assert_eq!(hasher.hash(&5u), 5);\n+    assert_eq!(hash(&5u8), 5);\n+    assert_eq!(hash(&5u16), 5);\n+    assert_eq!(hash(&5u32), 5);\n+    assert_eq!(hash(&5u64), 5);\n+    assert_eq!(hash(&5u), 5);\n \n-    assert_eq!(hasher.hash(&5i8), 5);\n-    assert_eq!(hasher.hash(&5i16), 5);\n-    assert_eq!(hasher.hash(&5i32), 5);\n-    assert_eq!(hasher.hash(&5i64), 5);\n-    assert_eq!(hasher.hash(&5i), 5);\n+    assert_eq!(hash(&5i8), 5);\n+    assert_eq!(hash(&5i16), 5);\n+    assert_eq!(hash(&5i32), 5);\n+    assert_eq!(hash(&5i64), 5);\n+    assert_eq!(hash(&5i), 5);\n \n-    assert_eq!(hasher.hash(&false), 0);\n-    assert_eq!(hasher.hash(&true), 1);\n+    assert_eq!(hash(&false), 0);\n+    assert_eq!(hash(&true), 1);\n \n-    assert_eq!(hasher.hash(&'a'), 97);\n+    assert_eq!(hash(&'a'), 97);\n \n     let s: &str = \"a\";\n-    assert_eq!(hasher.hash(& s), 97 + 0xFF);\n+    assert_eq!(hash(& s), 97 + 0xFF);\n     // FIXME (#18283) Enable test\n     //let s: Box<str> = box \"a\";\n     //assert_eq!(hasher.hash(& s), 97 + 0xFF);\n     let cs: &[u8] = &[1u8, 2u8, 3u8];\n-    assert_eq!(hasher.hash(& cs), 9);\n+    assert_eq!(hash(& cs), 9);\n     let cs: Box<[u8]> = box [1u8, 2u8, 3u8];\n-    assert_eq!(hasher.hash(& cs), 9);\n+    assert_eq!(hash(& cs), 9);\n \n     // FIXME (#18248) Add tests for hashing Rc<str> and Rc<[T]>\n \n     unsafe {\n         let ptr: *const int = mem::transmute(5i);\n-        assert_eq!(hasher.hash(&ptr), 5);\n+        assert_eq!(hash(&ptr), 5);\n     }\n \n     unsafe {\n         let ptr: *mut int = mem::transmute(5i);\n-        assert_eq!(hasher.hash(&ptr), 5);\n+        assert_eq!(hash(&ptr), 5);\n     }\n }\n \n-struct Custom {\n-    hash: u64\n+struct Custom { hash: u64 }\n+struct CustomHasher { output: u64 }\n+\n+impl Hasher for CustomHasher {\n+    type Output = u64;\n+    fn reset(&mut self) { self.output = 0; }\n+    fn finish(&self) -> u64 { self.output }\n+}\n+\n+impl Default for CustomHasher {\n+    fn default() -> CustomHasher {\n+        CustomHasher { output: 0 }\n+    }\n }\n \n-impl Hash<u64> for Custom {\n-    fn hash(&self, state: &mut u64) {\n-        *state = self.hash;\n+impl Hash<CustomHasher> for Custom {\n+    fn hash(&self, state: &mut CustomHasher) {\n+        state.output = self.hash;\n     }\n }\n \n #[test]\n fn test_custom_state() {\n+    fn hash<T: Hash<CustomHasher>>(t: &T) -> u64 {\n+        ::std::hash::hash::<_, CustomHasher>(t)\n+    }\n+\n     let custom = Custom { hash: 5 };\n-    let mut state = 0;\n-    custom.hash(&mut state);\n-    assert_eq!(state, 5);\n+    assert_eq!(hash(&Custom { hash: 5 }), 5);\n }"}, {"sha": "7043ea89c7d79257ae4720fa33d7620609df4bfa", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -186,7 +186,7 @@ impl PartialEq for LintId {\n \n impl Eq for LintId { }\n \n-impl<S: hash::Writer> hash::Hash<S> for LintId {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for LintId {\n     fn hash(&self, state: &mut S) {\n         let ptr = self.lint as *const Lint;\n         ptr.hash(state);"}, {"sha": "750f8a298560884c6bde21f819f9f96ede8d36cb", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -33,8 +33,7 @@ use middle::ty::{self, Ty};\n use middle::astencode::vtable_decoder_helpers;\n \n use std::collections::HashMap;\n-use std::hash::Hash;\n-use std::hash;\n+use std::hash::{self, Hash, SipHasher};\n use std::io::extensions::u64_from_be_bytes;\n use std::io;\n use std::num::FromPrimitive;\n@@ -94,7 +93,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n     }\n     lookup_hash(items,\n                 |a| eq_item(a, item_id),\n-                hash::hash(&(item_id as i64)))\n+                hash::hash::<i64, SipHasher>(&(item_id as i64)))\n }\n \n fn find_item<'a>(item_id: ast::NodeId, items: rbml::Doc<'a>) -> rbml::Doc<'a> {"}, {"sha": "af1b27afa39c64b35e83c275d81ed69da37346e0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -29,8 +29,7 @@ use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cell::RefCell;\n-use std::hash::Hash;\n-use std::hash;\n+use std::hash::{Hash, Hasher, SipHasher};\n use syntax::abi;\n use syntax::ast::{self, DefId, NodeId};\n use syntax::ast_map::{PathElem, PathElems};\n@@ -1598,11 +1597,13 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n     F: FnMut(&mut SeekableMemWriter, &T),\n-    T: Hash,\n+    T: Hash<SipHasher>,\n {\n     let mut buckets: Vec<Vec<entry<T>>> = range(0, 256u16).map(|_| Vec::new()).collect();\n     for elt in index.into_iter() {\n-        let h = hash::hash(&elt.val) as uint;\n+        let mut s = SipHasher::new();\n+        elt.val.hash(&mut s);\n+        let h = s.finish() as uint;\n         (&mut buckets[h % 256]).push(elt);\n     }\n "}, {"sha": "edf132dec3d1efdcf5b318274d68ce0ffa05007c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -72,7 +72,7 @@ use std::borrow::BorrowFrom;\n use std::cell::{Cell, RefCell};\n use std::cmp::{self, Ordering};\n use std::fmt::{self, Show};\n-use std::hash::{Hash, sip, Writer};\n+use std::hash::{Hash, Writer, SipHasher, Hasher};\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n@@ -946,11 +946,18 @@ impl<'tcx> PartialEq for TyS<'tcx> {\n }\n impl<'tcx> Eq for TyS<'tcx> {}\n \n+#[cfg(stage0)]\n impl<'tcx, S: Writer> Hash<S> for TyS<'tcx> {\n     fn hash(&self, s: &mut S) {\n         (self as *const _).hash(s)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'tcx, S: Writer + Hasher> Hash<S> for TyS<'tcx> {\n+    fn hash(&self, s: &mut S) {\n+        (self as *const _).hash(s)\n+    }\n+}\n \n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n@@ -968,7 +975,7 @@ impl<'tcx> PartialEq for InternedTy<'tcx> {\n \n impl<'tcx> Eq for InternedTy<'tcx> {}\n \n-impl<'tcx, S: Writer> Hash<S> for InternedTy<'tcx> {\n+impl<'tcx, S: Writer + Hasher> Hash<S> for InternedTy<'tcx> {\n     fn hash(&self, s: &mut S) {\n         self.ty.sty.hash(s)\n     }\n@@ -6164,15 +6171,16 @@ pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n /// Creates a hash of the type `Ty` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n-    let mut state = sip::SipState::new();\n+    let mut state = SipHasher::new();\n     helper(tcx, ty, svh, &mut state);\n-    return state.result();\n+    return state.finish();\n \n-    fn helper<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh, state: &mut sip::SipState) {\n+    fn helper<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh,\n+                    state: &mut SipHasher) {\n         macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n         macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n \n-        let region = |&: state: &mut sip::SipState, r: Region| {\n+        let region = |&: state: &mut SipHasher, r: Region| {\n             match r {\n                 ReStatic => {}\n                 ReLateBound(db, BrAnon(i)) => {\n@@ -6189,7 +6197,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 }\n             }\n         };\n-        let did = |&: state: &mut sip::SipState, did: DefId| {\n+        let did = |&: state: &mut SipHasher, did: DefId| {\n             let h = if ast_util::is_local(did) {\n                 svh.clone()\n             } else {\n@@ -6198,10 +6206,10 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n             h.as_str().hash(state);\n             did.node.hash(state);\n         };\n-        let mt = |&: state: &mut sip::SipState, mt: mt| {\n+        let mt = |&: state: &mut SipHasher, mt: mt| {\n             mt.mutbl.hash(state);\n         };\n-        let fn_sig = |&: state: &mut sip::SipState, sig: &Binder<FnSig<'tcx>>| {\n+        let fn_sig = |&: state: &mut SipHasher, sig: &Binder<FnSig<'tcx>>| {\n             let sig = anonymize_late_bound_regions(tcx, sig).0;\n             for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n             if let ty::FnConverging(output) = sig.output {"}, {"sha": "c505e9e311256309a77b5458002a8514fa525bcf", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -16,6 +16,7 @@ use std::fmt::Show;\n use std::hash::{Hash, Hasher};\n use std::iter::repeat;\n use std::time::Duration;\n+use std::collections::hash_state::HashState;\n \n use syntax::ast;\n use syntax::visit;\n@@ -140,11 +141,11 @@ pub fn block_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr) -\n /// Efficiency note: This is implemented in an inefficient way because it is typically invoked on\n /// very small graphs. If the graphs become larger, a more efficient graph representation and\n /// algorithm would probably be advised.\n-pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n-    edges_map: &HashMap<T,Vec<T>,H>,\n-    source: T,\n-    destination: T)\n-    -> bool\n+pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n+                       destination: T) -> bool\n+    where S: HashState,\n+          <S as HashState>::Hasher: Hasher<Output=u64>,\n+          T: Hash< <S as HashState>::Hasher> + Eq + Clone,\n {\n     if source == destination {\n         return true;\n@@ -202,11 +203,12 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n /// }\n /// ```\n #[inline(always)]\n-pub fn memoized<T, U, S, H, F>(cache: &RefCell<HashMap<T, U, H>>, arg: T, f: F) -> U where\n-    T: Clone + Hash<S> + Eq,\n-    U: Clone,\n-    H: Hasher<S>,\n-    F: FnOnce(T) -> U,\n+pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n+    where T: Clone + Hash<<S as HashState>::Hasher> + Eq,\n+          U: Clone,\n+          S: HashState,\n+          <S as HashState>::Hasher: Hasher<Output=u64>,\n+          F: FnOnce(T) -> U,\n {\n     let key = arg.clone();\n     let result = cache.borrow().get(&key).map(|result| result.clone());"}, {"sha": "044534ae8523651a509cfa0d02a22449ebe5209a", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -12,12 +12,14 @@\n \n #![allow(non_snake_case)]\n \n+use std::collections::hash_state::{DefaultState};\n use std::collections::{HashMap, HashSet};\n-use std::hash::{Hasher, Hash, Writer};\n+use std::default::Default;\n+use std::hash::{Hasher, Writer};\n use syntax::ast;\n \n-pub type FnvHashMap<K, V> = HashMap<K, V, FnvHasher>;\n-pub type FnvHashSet<V> = HashSet<V, FnvHasher>;\n+pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n+pub type FnvHashSet<V> = HashSet<V, DefaultState<FnvHasher>>;\n \n pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n@@ -28,16 +30,16 @@ pub type DefIdSet = FnvHashSet<ast::DefId>;\n // Hacks to get good names\n pub mod FnvHashMap {\n     use std::hash::Hash;\n-    use std::collections::HashMap;\n-    pub fn new<K: Hash<super::FnvState> + Eq, V>() -> super::FnvHashMap<K, V> {\n-        HashMap::with_hasher(super::FnvHasher)\n+    use std::default::Default;\n+    pub fn new<K: Hash<super::FnvHasher> + Eq, V>() -> super::FnvHashMap<K, V> {\n+        Default::default()\n     }\n }\n pub mod FnvHashSet {\n     use std::hash::Hash;\n-    use std::collections::HashSet;\n-    pub fn new<V: Hash<super::FnvState> + Eq>() -> super::FnvHashSet<V> {\n-        HashSet::with_hasher(super::FnvHasher)\n+    use std::default::Default;\n+    pub fn new<V: Hash<super::FnvHasher> + Eq>() -> super::FnvHashSet<V> {\n+        Default::default()\n     }\n }\n pub mod NodeMap {\n@@ -68,28 +70,26 @@ pub mod DefIdSet {\n ///\n /// This uses FNV hashing, as described here:\n /// http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n-#[derive(Clone, Copy, Default)]\n-pub struct FnvHasher;\n-\n #[allow(missing_copy_implementations)]\n-pub struct FnvState(u64);\n+pub struct FnvHasher(u64);\n \n-impl Hasher<FnvState> for FnvHasher {\n-    fn hash<T: ?Sized + Hash<FnvState>>(&self, t: &T) -> u64 {\n-        let mut state = FnvState(0xcbf29ce484222325);\n-        t.hash(&mut state);\n-        let FnvState(ret) = state;\n-        return ret;\n-    }\n+impl Default for FnvHasher {\n+    fn default() -> FnvHasher { FnvHasher(0xcbf29ce484222325) }\n+}\n+\n+impl Hasher for FnvHasher {\n+    type Output = u64;\n+    fn reset(&mut self) { *self = Default::default(); }\n+    fn finish(&self) -> u64 { self.0 }\n }\n \n-impl Writer for FnvState {\n+impl Writer for FnvHasher {\n     fn write(&mut self, bytes: &[u8]) {\n-        let FnvState(mut hash) = *self;\n+        let FnvHasher(mut hash) = *self;\n         for byte in bytes.iter() {\n             hash = hash ^ (*byte as u64);\n             hash = hash * 0x100000001b3;\n         }\n-        *self = FnvState(hash);\n+        *self = FnvHasher(hash);\n     }\n }"}, {"sha": "edd1bc873be9251c4a7f277ca21d13bb1550d81a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -26,6 +26,7 @@ use middle::ty;\n use middle::ty_fold::TypeFoldable;\n \n use std::collections::HashMap;\n+use std::collections::hash_state::HashState;\n use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n use syntax::abi;\n@@ -1350,11 +1351,11 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n     }\n }\n \n-#[old_impl_check]\n-impl<'tcx, S, H, K, V> Repr<'tcx> for HashMap<K,V,H>\n-    where K : Hash<S> + Eq + Repr<'tcx>,\n-          V : Repr<'tcx>,\n-          H : Hasher<S>\n+impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n+    where K: Hash<<S as HashState>::Hasher> + Eq + Repr<'tcx>,\n+          V: Repr<'tcx>,\n+          S: HashState,\n+          <S as HashState>::Hasher: Hasher<Output=u64>,\n {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"HashMap({})\","}, {"sha": "2dcf08cee9265162e7f72df4d0081d1ef17f1ea7", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -47,8 +47,7 @@\n //! Original issue: https://github.com/rust-lang/rust/issues/10207\n \n use std::fmt;\n-use std::hash::Hash;\n-use std::hash::sip::SipState;\n+use std::hash::{Hash, SipHasher, Hasher};\n use std::iter::range_step;\n use syntax::ast;\n use syntax::visit;\n@@ -78,7 +77,7 @@ impl Svh {\n \n         // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n         //        avoid collisions.\n-        let mut state = SipState::new();\n+        let mut state = SipHasher::new();\n \n         for data in metadata.iter() {\n             data.hash(&mut state);\n@@ -102,7 +101,7 @@ impl Svh {\n             attr.node.value.hash(&mut state);\n         }\n \n-        let hash = state.result();\n+        let hash = state.finish();\n         return Svh {\n             hash: range_step(0u, 64u, 4u).map(|i| hex(hash >> i)).collect()\n         };\n@@ -149,14 +148,13 @@ mod svh_visitor {\n     use syntax::visit;\n     use syntax::visit::{Visitor, FnKind};\n \n-    use std::hash::Hash;\n-    use std::hash::sip::SipState;\n+    use std::hash::{Hash, SipHasher};\n \n     pub struct StrictVersionHashVisitor<'a> {\n-        pub st: &'a mut SipState,\n+        pub st: &'a mut SipHasher,\n     }\n \n-    pub fn make<'a>(st: &'a mut SipState) -> StrictVersionHashVisitor<'a> {\n+    pub fn make<'a>(st: &'a mut SipHasher) -> StrictVersionHashVisitor<'a> {\n         StrictVersionHashVisitor { st: st }\n     }\n \n@@ -400,7 +398,7 @@ mod svh_visitor {\n         }\n \n         // All of the remaining methods just record (in the hash\n-        // SipState) that the visitor saw that particular variant\n+        // SipHasher) that the visitor saw that particular variant\n         // (with its payload), and continue walking as the default\n         // visitor would.\n         //"}, {"sha": "cc98ee9592b0f8a6af2bebf88e801a5374bc21fd", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -32,7 +32,7 @@ use syntax::ast_map;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n-use std::hash::{sip, Hash};\n+use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: ast::DefId,\n@@ -125,11 +125,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let hash;\n     let s = {\n-        let mut state = sip::SipState::new();\n+        let mut state = SipHasher::new();\n         hash_id.hash(&mut state);\n         mono_ty.hash(&mut state);\n \n-        hash = format!(\"h{}\", state.result());\n+        hash = format!(\"h{}\", state.finish());\n         ccx.tcx().map.with_path(fn_id.node, |path| {\n             exported_name(path, hash.index(&FullRange))\n         })"}, {"sha": "42498328ff6cb7f324828290defc606cd093c3d7", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -13,6 +13,7 @@\n use std::uint;\n use std::default::Default;\n use std::hash::{Hash, Hasher};\n+use std::collections::hash_state::HashState;\n \n use {Decodable, Encodable, Decoder, Encoder};\n use std::collections::{DList, RingBuf, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n@@ -156,13 +157,12 @@ impl<\n     }\n }\n \n-#[old_impl_check]\n-impl<\n-    K: Encodable + Hash<X> + Eq,\n-    V: Encodable,\n-    X,\n-    H: Hasher<X>\n-> Encodable for HashMap<K, V, H> {\n+impl<K, V, S> Encodable for HashMap<K, V, S>\n+    where K: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n+          V: Encodable,\n+          S: HashState,\n+          <S as HashState>::Hasher: Hasher<Output=u64>\n+{\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n@@ -176,17 +176,16 @@ impl<\n     }\n }\n \n-#[old_impl_check]\n-impl<\n-    K: Decodable + Hash<S> + Eq,\n-    V: Decodable,\n-    S,\n-    H: Hasher<S> + Default\n-> Decodable for HashMap<K, V, H> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, H>, D::Error> {\n+impl<K, V, S> Decodable for HashMap<K, V, S>\n+    where K: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n+          V: Decodable,\n+          S: HashState + Default,\n+          <S as HashState>::Hasher: Hasher<Output=u64>\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n         d.read_map(|d, len| {\n-            let hasher = Default::default();\n-            let mut map = HashMap::with_capacity_and_hasher(len, hasher);\n+            let state = Default::default();\n+            let mut map = HashMap::with_capacity_and_hash_state(len, state);\n             for i in range(0u, len) {\n                 let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n                 let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n@@ -197,12 +196,11 @@ impl<\n     }\n }\n \n-#[old_impl_check]\n-impl<\n-    T: Encodable + Hash<X> + Eq,\n-    X,\n-    H: Hasher<X>\n-> Encodable for HashSet<T, H> {\n+impl<T, S> Encodable for HashSet<T, S>\n+    where T: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n+          S: HashState,\n+          <S as HashState>::Hasher: Hasher<Output=u64>\n+{\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n@@ -215,15 +213,15 @@ impl<\n     }\n }\n \n-#[old_impl_check]\n-impl<\n-    T: Decodable + Hash<S> + Eq,\n-    S,\n-    H: Hasher<S> + Default\n-> Decodable for HashSet<T, H> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, H>, D::Error> {\n+impl<T, S> Decodable for HashSet<T, S>\n+    where T: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n+          S: HashState + Default,\n+          <S as HashState>::Hasher: Hasher<Output=u64>\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n         d.read_seq(|d, len| {\n-            let mut set = HashSet::with_capacity_and_hasher(len, Default::default());\n+            let state = Default::default();\n+            let mut set = HashSet::with_capacity_and_hash_state(len, state);\n             for i in range(0u, len) {\n                 set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }"}, {"sha": "fd15526193456ea082420572aa2fece98bc37346", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -24,7 +24,6 @@ Core encoding and decoding interfaces.\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n-#![feature(old_impl_check)]\n #![cfg_attr(stage0, allow(unused_attributes))]\n \n // test harness access"}, {"sha": "8dc41368e7f92d40ea64d9d57da763c02f3ca60e", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -273,7 +273,7 @@ macro_rules! bitflags {\n #[cfg(test)]\n #[allow(non_upper_case_globals)]\n mod tests {\n-    use hash;\n+    use hash::{self, SipHasher};\n     use option::Option::{Some, None};\n \n     bitflags! {\n@@ -467,9 +467,9 @@ mod tests {\n     fn test_hash() {\n       let mut x = Flags::empty();\n       let mut y = Flags::empty();\n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n       x = Flags::all();\n       y = FlagABC;\n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n     }\n }"}, {"sha": "bf3b48645154c1c68f6a71962b212bb0b7fe4425", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 145, "deletions": 61, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -19,16 +19,15 @@ use clone::Clone;\n use cmp::{max, Eq, PartialEq};\n use default::Default;\n use fmt::{self, Show};\n-use hash::{Hash, Hasher, RandomSipHasher};\n+use hash::{self, Hash, SipHasher};\n use iter::{self, Iterator, IteratorExt, FromIterator, Extend, Map};\n use marker::Sized;\n use mem::{self, replace};\n use num::{Int, UnsignedInt};\n use ops::{Deref, FnMut, Index, IndexMut};\n-use option::Option;\n-use option::Option::{Some, None};\n-use result::Result;\n-use result::Result::{Ok, Err};\n+use option::Option::{self, Some, None};\n+use rand::{self, Rng};\n+use result::Result::{self, Ok, Err};\n \n use super::table::{\n     self,\n@@ -44,6 +43,7 @@ use super::table::BucketState::{\n     Empty,\n     Full,\n };\n+use super::state::HashState;\n \n const INITIAL_LOG2_CAP: uint = 5;\n pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n@@ -297,9 +297,9 @@ fn test_resize_policy() {\n /// ```\n #[derive(Clone)]\n #[stable]\n-pub struct HashMap<K, V, H = RandomSipHasher> {\n+pub struct HashMap<K, V, S = RandomState> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n-    hasher: H,\n+    hash_state: S,\n \n     table: RawTable<K, V>,\n \n@@ -439,25 +439,28 @@ impl<K, V, M> SearchResult<K, V, M> {\n     }\n }\n \n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n-    fn make_hash<X: ?Sized + Hash<S>>(&self, x: &X) -> SafeHash {\n-        table::make_hash(&self.hasher, x)\n+impl<K, V, S, H> HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash<H> {\n+        table::make_hash(&self.hash_state, x)\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n     fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash<S>\n+        where Q: BorrowFrom<K> + Eq + Hash<H>\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n             .into_option()\n     }\n \n     fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash<S>\n+        where Q: BorrowFrom<K> + Eq + Hash<H>\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&mut self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n@@ -486,7 +489,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n+impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// Create an empty HashMap.\n     ///\n     /// # Example\n@@ -497,9 +500,8 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn new() -> HashMap<K, V, RandomSipHasher> {\n-        let hasher = RandomSipHasher::new();\n-        HashMap::with_hasher(hasher)\n+    pub fn new() -> HashMap<K, V, RandomState> {\n+        Default::default()\n     }\n \n     /// Creates an empty hash map with the given initial capacity.\n@@ -512,14 +514,16 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> {\n-        let hasher = RandomSipHasher::new();\n-        HashMap::with_capacity_and_hasher(capacity, hasher)\n+    pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomState> {\n+        HashMap::with_capacity_and_hash_state(capacity, Default::default())\n     }\n }\n \n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+impl<K, V, S, H> HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     /// Creates an empty hashmap which will use the given hasher to hash keys.\n     ///\n     /// The creates map has the default initial capacity.\n@@ -528,17 +532,17 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// use std::hash::sip::SipHasher;\n+    /// use std::collections::hash_map::RandomState;\n     ///\n-    /// let h = SipHasher::new();\n-    /// let mut map = HashMap::with_hasher(h);\n+    /// let s = RandomState::new();\n+    /// let mut map = HashMap::with_hash_state(s);\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n     #[unstable = \"hasher stuff is unclear\"]\n-    pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n+    pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n         HashMap {\n-            hasher:        hasher,\n+            hash_state:    hash_state,\n             resize_policy: DefaultResizePolicy::new(),\n             table:         RawTable::new(0),\n         }\n@@ -556,21 +560,22 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// use std::hash::sip::SipHasher;\n+    /// use std::collections::hash_map::RandomState;\n     ///\n-    /// let h = SipHasher::new();\n-    /// let mut map = HashMap::with_capacity_and_hasher(10, h);\n+    /// let s = RandomState::new();\n+    /// let mut map = HashMap::with_capacity_and_hash_state(10, s);\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n     #[unstable = \"hasher stuff is unclear\"]\n-    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> {\n+    pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n+                                        -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n         let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n         let internal_cap = min_cap.checked_next_power_of_two().expect(\"capacity overflow\");\n         assert!(internal_cap >= capacity, \"capacity overflow\");\n         HashMap {\n-            hasher:        hasher,\n+            hash_state:    hash_state,\n             resize_policy: resize_policy,\n             table:         RawTable::new(internal_cap),\n         }\n@@ -1031,7 +1036,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[stable]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where Q: Hash<S> + Eq + BorrowFrom<K>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n         self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n@@ -1054,7 +1059,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[stable]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where Q: Hash<S> + Eq + BorrowFrom<K>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n         self.search(k).is_some()\n     }\n@@ -1080,7 +1085,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[stable]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where Q: Hash<S> + Eq + BorrowFrom<K>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n@@ -1132,7 +1137,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[stable]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where Q: Hash<S> + Eq + BorrowFrom<K>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n         if self.table.size() == 0 {\n             return None\n@@ -1189,10 +1194,12 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n     }\n }\n \n-#[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V, H> {\n-    fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n+impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n+    where K: Eq + Hash<H>, V: PartialEq,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n         if self.len() != other.len() { return false; }\n \n         self.iter().all(|(key, value)|\n@@ -1202,12 +1209,18 @@ impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V,\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {}\n+impl<K, V, S, H> Eq for HashMap<K, V, S>\n+    where K: Eq + Hash<H>, V: Eq,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{}\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n+impl<K, V, S, H> Show for HashMap<K, V, S>\n+    where K: Eq + Hash<H> + Show, V: Show,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"HashMap {{\"));\n \n@@ -1221,18 +1234,22 @@ impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H>\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n-    #[stable]\n-    fn default() -> HashMap<K, V, H> {\n-        HashMap::with_hasher(Default::default())\n+impl<K, V, S, H> Default for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn default() -> HashMap<K, V, S> {\n+        HashMap::with_hash_state(Default::default())\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H>\n-    where Q: BorrowFrom<K> + Hash<S> + Eq\n+impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          Q: Eq + Hash<H> + BorrowFrom<K>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Output = V;\n \n@@ -1243,9 +1260,11 @@ impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V,\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> IndexMut<Q> for HashMap<K, V, H>\n-    where Q: BorrowFrom<K> + Hash<S> + Eq\n+impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          Q: Eq + Hash<H> + BorrowFrom<K>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Output = V;\n \n@@ -1473,26 +1492,91 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n-    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, H> {\n+impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, S> {\n         let lower = iter.size_hint().0;\n-        let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n+        let mut map = HashMap::with_capacity_and_hash_state(lower,\n+                                                            Default::default());\n         map.extend(iter);\n         map\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Extend<(K, V)> for HashMap<K, V, H> {\n+impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n+\n+/// `RandomState` is the default state for `HashMap` types.\n+///\n+/// A particular instance `RandomState` will create the same instances of\n+/// `Hasher`, but the hashers created by two different `RandomState`\n+/// instances are unlikely to produce the same result for the same values.\n+#[derive(Clone)]\n+#[allow(missing_copy_implementations)]\n+#[unstable = \"hashing an hash maps may be altered\"]\n+pub struct RandomState {\n+    k0: u64,\n+    k1: u64,\n+}\n+\n+#[unstable = \"hashing an hash maps may be altered\"]\n+impl RandomState {\n+    /// Construct a new `RandomState` that is initialized with random keys.\n+    #[inline]\n+    pub fn new() -> RandomState {\n+        let mut r = rand::thread_rng();\n+        RandomState { k0: r.gen(), k1: r.gen() }\n+    }\n+}\n+\n+#[unstable = \"hashing an hash maps may be altered\"]\n+impl HashState for RandomState {\n+    type Hasher = Hasher;\n+    fn hasher(&self) -> Hasher {\n+        Hasher { inner: SipHasher::new_with_keys(self.k0, self.k1) }\n+    }\n+}\n+\n+#[unstable = \"hashing an hash maps may be altered\"]\n+impl Default for RandomState {\n+    #[inline]\n+    fn default() -> RandomState {\n+        RandomState::new()\n+    }\n+}\n+\n+/// A hasher implementation which is generated from `RandomState` instances.\n+///\n+/// This is the default hasher used in a `HashMap` to hash keys. Types do not\n+/// typically declare an ability to explicitly hash into this particular type,\n+/// but rather in a `H: hash::Writer` type parameter.\n+#[allow(missing_copy_implementations)]\n+pub struct Hasher { inner: SipHasher }\n+\n+impl hash::Writer for Hasher {\n+    fn write(&mut self, data: &[u8]) { self.inner.write(data) }\n+}\n+\n+impl hash::Hasher for Hasher {\n+    type Output = u64;\n+    fn reset(&mut self) { self.inner.reset() }\n+    fn finish(&self) -> u64 { self.inner.finish() }\n+}\n+\n #[cfg(test)]\n mod test_map {\n     use prelude::v1::*;"}, {"sha": "47e300af26981da7cd395a6b361bf63704358cb6", "filename": "src/libstd/collections/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -11,6 +11,7 @@\n //! Unordered containers, implemented as hash-tables\n \n mod bench;\n+mod table;\n pub mod map;\n pub mod set;\n-mod table;\n+pub mod state;"}, {"sha": "4003d3addf13949f74b415521b188f9b6edd587e", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 127, "deletions": 90, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -17,12 +17,13 @@ use core::marker::Sized;\n use default::Default;\n use fmt::Show;\n use fmt;\n-use hash::{Hash, Hasher, RandomSipHasher};\n+use hash::{self, Hash};\n use iter::{Iterator, IteratorExt, FromIterator, Map, Chain, Extend};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n \n-use super::map::{self, HashMap, Keys, INITIAL_CAPACITY};\n+use super::map::{self, HashMap, Keys, INITIAL_CAPACITY, RandomState, Hasher};\n+use super::state::HashState;\n \n // Future Optimization (FIXME!)\n // =============================\n@@ -90,11 +91,11 @@ use super::map::{self, HashMap, Keys, INITIAL_CAPACITY};\n /// ```\n #[derive(Clone)]\n #[stable]\n-pub struct HashSet<T, H = RandomSipHasher> {\n-    map: HashMap<T, (), H>\n+pub struct HashSet<T, S = RandomState> {\n+    map: HashMap<T, (), S>\n }\n \n-impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n+impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// Create an empty HashSet.\n     ///\n     /// # Example\n@@ -105,7 +106,7 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn new() -> HashSet<T, RandomSipHasher> {\n+    pub fn new() -> HashSet<T, RandomState> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n \n@@ -120,13 +121,16 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> {\n+    pub fn with_capacity(capacity: uint) -> HashSet<T, RandomState> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n }\n \n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n+impl<T, S, H> HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     /// Creates a new empty hash set which will use the given hasher to hash\n     /// keys.\n     ///\n@@ -136,16 +140,16 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// use std::hash::sip::SipHasher;\n+    /// use std::collections::hash_map::RandomState;\n     ///\n-    /// let h = SipHasher::new();\n-    /// let mut set = HashSet::with_hasher(h);\n+    /// let s = RandomState::new();\n+    /// let mut set = HashSet::with_hash_state(s);\n     /// set.insert(2u);\n     /// ```\n     #[inline]\n     #[unstable = \"hasher stuff is unclear\"]\n-    pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n-        HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n+    pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n+        HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n     }\n \n     /// Create an empty HashSet with space for at least `capacity`\n@@ -160,16 +164,19 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// use std::hash::sip::SipHasher;\n+    /// use std::collections::hash_map::RandomState;\n     ///\n-    /// let h = SipHasher::new();\n-    /// let mut set = HashSet::with_capacity_and_hasher(10u, h);\n+    /// let s = RandomState::new();\n+    /// let mut set = HashSet::with_capacity_and_hash_state(10u, s);\n     /// set.insert(1i);\n     /// ```\n     #[inline]\n     #[unstable = \"hasher stuff is unclear\"]\n-    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> {\n-        HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n+    pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n+                                        -> HashSet<T, S> {\n+        HashSet {\n+            map: HashMap::with_capacity_and_hash_state(capacity, hash_state),\n+        }\n     }\n \n     /// Returns the number of elements the set can hold without reallocating.\n@@ -300,7 +307,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n-    pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> Difference<'a, T, H> {\n+    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n         Difference {\n             iter: self.iter(),\n             other: other,\n@@ -328,8 +335,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n-        -> SymmetricDifference<'a, T, H> {\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n+        -> SymmetricDifference<'a, T, S> {\n         SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n     }\n \n@@ -351,7 +358,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n-    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>) -> Intersection<'a, T, H> {\n+    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n         Intersection {\n             iter: self.iter(),\n             other: other,\n@@ -376,7 +383,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n-    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>) -> Union<'a, T, H> {\n+    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n         Union { iter: self.iter().chain(other.difference(self)) }\n     }\n \n@@ -452,7 +459,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[stable]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-        where Q: BorrowFrom<T> + Hash<S> + Eq\n+        where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n         self.map.contains_key(value)\n     }\n@@ -475,7 +482,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n     #[stable]\n-    pub fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n+    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n \n@@ -496,7 +503,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n     #[stable]\n-    pub fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n+    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n \n@@ -521,7 +528,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn is_superset(&self, other: &HashSet<T, H>) -> bool {\n+    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n         other.is_subset(self)\n     }\n \n@@ -562,29 +569,38 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[stable]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-        where Q: BorrowFrom<T> + Hash<S> + Eq\n+        where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n         self.map.remove(value).is_some()\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n-    fn eq(&self, other: &HashSet<T, H>) -> bool {\n+impl<T, S, H> PartialEq for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn eq(&self, other: &HashSet<T, S>) -> bool {\n         if self.len() != other.len() { return false; }\n \n         self.iter().all(|key| other.contains(key))\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n+impl<T, S, H> Eq for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{}\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n+impl<T, S, H> fmt::Show for HashSet<T, S>\n+    where T: Eq + Hash<H> + fmt::Show,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"HashSet {{\"));\n \n@@ -598,19 +614,25 @@ impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n-    fn from_iter<I: Iterator<Item=T>>(iter: I) -> HashSet<T, H> {\n+impl<T, S, H> FromIterator<T> for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn from_iter<I: Iterator<Item=T>>(iter: I) -> HashSet<T, S> {\n         let lower = iter.size_hint().0;\n-        let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n+        let mut set = HashSet::with_capacity_and_hash_state(lower, Default::default());\n         set.extend(iter);\n         set\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Extend<T> for HashSet<T, H> {\n+impl<T, S, H> Extend<T> for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     fn extend<I: Iterator<Item=T>>(&mut self, mut iter: I) {\n         for k in iter {\n             self.insert(k);\n@@ -619,21 +641,26 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> Extend<T> for HashSet<T, H> {\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n+impl<T, S, H> Default for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n     #[stable]\n-    fn default() -> HashSet<T, H> {\n-        HashSet::with_hasher(Default::default())\n+    fn default() -> HashSet<T, S> {\n+        HashSet::with_hash_state(Default::default())\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-BitOr<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n-    type Output = HashSet<T, H>;\n+impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n \n-    /// Returns the union of `self` and `rhs` as a new `HashSet<T, H>`.\n+    /// Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.\n     ///\n     /// # Examples\n     ///\n@@ -653,18 +680,20 @@ BitOr<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n     /// }\n     /// assert_eq!(i, expected.len());\n     /// ```\n-    fn bitor(self, rhs: &HashSet<T, H>) -> HashSet<T, H> {\n+    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n         self.union(rhs).cloned().collect()\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-BitAnd<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n-    type Output = HashSet<T, H>;\n+impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n \n-    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, H>`.\n+    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.\n     ///\n     /// # Examples\n     ///\n@@ -684,18 +713,20 @@ BitAnd<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n     /// }\n     /// assert_eq!(i, expected.len());\n     /// ```\n-    fn bitand(self, rhs: &HashSet<T, H>) -> HashSet<T, H> {\n+    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n         self.intersection(rhs).cloned().collect()\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-BitXor<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n-    type Output = HashSet<T, H>;\n+impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n \n-    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, H>`.\n+    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.\n     ///\n     /// # Examples\n     ///\n@@ -715,18 +746,20 @@ BitXor<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n     /// }\n     /// assert_eq!(i, expected.len());\n     /// ```\n-    fn bitxor(self, rhs: &HashSet<T, H>) -> HashSet<T, H> {\n+    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n         self.symmetric_difference(rhs).cloned().collect()\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-Sub<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n-    type Output = HashSet<T, H>;\n+impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n \n-    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, H>`.\n+    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.\n     ///\n     /// # Examples\n     ///\n@@ -746,7 +779,7 @@ Sub<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n     /// }\n     /// assert_eq!(i, expected.len());\n     /// ```\n-    fn sub(self, rhs: &HashSet<T, H>) -> HashSet<T, H> {\n+    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n         self.difference(rhs).cloned().collect()\n     }\n }\n@@ -771,32 +804,32 @@ pub struct Drain<'a, K: 'a> {\n \n /// Intersection iterator\n #[stable]\n-pub struct Intersection<'a, T: 'a, H: 'a> {\n+pub struct Intersection<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n     // the second set\n-    other: &'a HashSet<T, H>,\n+    other: &'a HashSet<T, S>,\n }\n \n /// Difference iterator\n #[stable]\n-pub struct Difference<'a, T: 'a, H: 'a> {\n+pub struct Difference<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n     // the second set\n-    other: &'a HashSet<T, H>,\n+    other: &'a HashSet<T, S>,\n }\n \n /// Symmetric difference iterator.\n #[stable]\n-pub struct SymmetricDifference<'a, T: 'a, H: 'a> {\n-    iter: Chain<Difference<'a, T, H>, Difference<'a, T, H>>\n+pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n+    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n }\n \n /// Set union iterator.\n #[stable]\n-pub struct Union<'a, T: 'a, H: 'a> {\n-    iter: Chain<Iter<'a, T>, Difference<'a, T, H>>\n+pub struct Union<'a, T: 'a, S: 'a> {\n+    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n }\n \n #[stable]\n@@ -824,9 +857,10 @@ impl<'a, K: 'a> Iterator for Drain<'a, K> {\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, T, S, H> Iterator for Intersection<'a, T, H>\n-    where T: Eq + Hash<S>, H: Hasher<S>\n+impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Item = &'a T;\n \n@@ -848,9 +882,10 @@ impl<'a, T, S, H> Iterator for Intersection<'a, T, H>\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, T, S, H> Iterator for Difference<'a, T, H>\n-    where T: Eq + Hash<S>, H: Hasher<S>\n+impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Item = &'a T;\n \n@@ -872,9 +907,10 @@ impl<'a, T, S, H> Iterator for Difference<'a, T, H>\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, H>\n-    where T: Eq + Hash<S>, H: Hasher<S>\n+impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Item = &'a T;\n \n@@ -883,9 +919,10 @@ impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, H>\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, T, S, H> Iterator for Union<'a, T, H>\n-    where T: Eq + Hash<S>, H: Hasher<S>\n+impl<'a, T, S, H> Iterator for Union<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Item = &'a T;\n "}, {"sha": "ffbc958f179f5adfcccbdb9fd04d0060ab974455", "filename": "src/libstd/collections/hash/state.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clone::Clone;\n+use default::Default;\n+use hash;\n+\n+/// A trait representing stateful hashes which can be used to hash keys in a\n+/// `HashMap`.\n+///\n+/// A HashState is used as a factory for instances of `Hasher` which a `HashMap`\n+/// can then use to hash keys independently. A `HashMap` by default uses a state\n+/// which will create instances of a `SipHasher`, but a custom state factory can\n+/// be provided to the `with_hash_state` function.\n+///\n+/// If a hashing algorithm has no initial state, then the `Hasher` type for that\n+/// algorithm can implement the `Default` trait and create hash maps with the\n+/// `DefaultState` structure. This state is 0-sized and will simply delegate\n+/// to `Default` when asked to create a hasher.\n+pub trait HashState {\n+    type Hasher: hash::Hasher;\n+\n+    /// Creates a new hasher based on the given state of this object.\n+    fn hasher(&self) -> Self::Hasher;\n+}\n+\n+/// A structure which is a factory for instances of `Hasher` which implement the\n+/// default trait.\n+///\n+/// This struct has is 0-sized and does not need construction.\n+pub struct DefaultState<H>;\n+\n+impl<H: Default + hash::Hasher> HashState for DefaultState<H> {\n+    type Hasher = H;\n+    fn hasher(&self) -> H { Default::default() }\n+}\n+\n+impl<H> Clone for DefaultState<H> {\n+    fn clone(&self) -> DefaultState<H> { DefaultState }\n+}\n+\n+impl<H> Default for DefaultState<H> {\n+    fn default() -> DefaultState<H> { DefaultState }\n+}"}, {"sha": "e43cc053ba07904883cabd7c23e61d6bd215c5a4", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -26,6 +26,7 @@ use option::Option::{Some, None};\n use ptr::{Unique, PtrExt, copy_nonoverlapping_memory, zero_memory};\n use ptr;\n use rt::heap::{allocate, deallocate};\n+use collections::hash_state::HashState;\n \n const EMPTY_BUCKET: u64 = 0u64;\n \n@@ -138,12 +139,18 @@ impl SafeHash {\n /// We need to remove hashes of 0. That's reserved for empty buckets.\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n-pub fn make_hash<T: ?Sized + Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n+pub fn make_hash<T: ?Sized, S, H>(hash_state: &S, t: &T) -> SafeHash\n+    where T: Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: Hasher<Output=u64>\n+{\n+    let mut state = hash_state.hasher();\n+    t.hash(&mut state);\n     // We need to avoid 0u64 in order to prevent collisions with\n     // EMPTY_HASH. We can maintain our precious uniform distribution\n     // of initial indexes by unconditionally setting the MSB,\n     // effectively reducing 64-bits hashes to 63 bits.\n-    SafeHash { hash: 0x8000_0000_0000_0000 | hasher.hash(t) }\n+    SafeHash { hash: 0x8000_0000_0000_0000 | state.finish() }\n }\n \n // `replace` casts a `*u64` to a `*SafeHash`. Since we statically"}, {"sha": "71ab89027ff4c88d73611fe27b419b4e356534ed", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -333,3 +333,10 @@ pub mod hash_set {\n     //! A hashset\n     pub use super::hash::set::*;\n }\n+\n+/// Experimental support for providing custom hash algorithms to a HashMap and\n+/// HashSet.\n+#[unstable = \"module was recently added\"]\n+pub mod hash_state {\n+    pub use super::hash::state::*;\n+}"}, {"sha": "69e7e429d07da01b5d7726415d17f08b1163d626", "filename": "src/libstd/hash.rs", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e524e0eb17c8f463e731f23b544003e8709c6/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=9e4e524e0eb17c8f463e731f23b544003e8709c6", "patch": "@@ -1,105 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Generic hashing support.\n-//!\n-//! This module provides a generic way to compute the hash of a value. The\n-//! simplest way to make a type hashable is to use `#[derive(Hash)]`:\n-//!\n-//! # Example\n-//!\n-//! ```rust\n-//! use std::hash;\n-//! use std::hash::Hash;\n-//!\n-//! #[derive(Hash)]\n-//! struct Person {\n-//!     id: uint,\n-//!     name: String,\n-//!     phone: u64,\n-//! }\n-//!\n-//! let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n-//! let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n-//!\n-//! assert!(hash::hash(&person1) != hash::hash(&person2));\n-//! ```\n-//!\n-//! If you need more control over how a value is hashed, you need to implement\n-//! the trait `Hash`:\n-//!\n-//! ```rust\n-//! use std::hash;\n-//! use std::hash::Hash;\n-//! use std::hash::sip::SipState;\n-//!\n-//! struct Person {\n-//!     id: uint,\n-//!     name: String,\n-//!     phone: u64,\n-//! }\n-//!\n-//! impl Hash for Person {\n-//!     fn hash(&self, state: &mut SipState) {\n-//!         self.id.hash(state);\n-//!         self.phone.hash(state);\n-//!     }\n-//! }\n-//!\n-//! let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n-//! let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n-//!\n-//! assert!(hash::hash(&person1) == hash::hash(&person2));\n-//! ```\n-\n-#![experimental]\n-\n-pub use core::hash::{Hash, Hasher, Writer, hash, sip};\n-\n-use core::marker::Sized;\n-use default::Default;\n-use rand::Rng;\n-use rand;\n-\n-/// `RandomSipHasher` computes the SipHash algorithm from a stream of bytes\n-/// initialized with random keys.\n-#[derive(Clone)]\n-pub struct RandomSipHasher {\n-    hasher: sip::SipHasher,\n-}\n-\n-impl RandomSipHasher {\n-    /// Construct a new `RandomSipHasher` that is initialized with random keys.\n-    #[inline]\n-    pub fn new() -> RandomSipHasher {\n-        let mut r = rand::thread_rng();\n-        let r0 = r.gen();\n-        let r1 = r.gen();\n-        RandomSipHasher {\n-            hasher: sip::SipHasher::new_with_keys(r0, r1),\n-        }\n-    }\n-}\n-\n-impl Hasher<sip::SipState> for RandomSipHasher {\n-    #[inline]\n-    fn hash<T: ?Sized + Hash<sip::SipState>>(&self, value: &T) -> u64 {\n-        self.hasher.hash(value)\n-    }\n-}\n-\n-#[stable]\n-impl Default for RandomSipHasher {\n-    #[stable]\n-    #[inline]\n-    fn default() -> RandomSipHasher {\n-        RandomSipHasher::new()\n-    }\n-}"}, {"sha": "ed29d3b2c7fffd457ffb65a001be3d34b1cc2fd9", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -34,7 +34,7 @@ use sys::process::Process as ProcessImp;\n use sys;\n use thread::Thread;\n \n-#[cfg(windows)] use std::hash::sip::SipState;\n+#[cfg(windows)] use hash;\n #[cfg(windows)] use str;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n@@ -98,7 +98,7 @@ pub struct Process {\n /// A representation of environment variable name\n /// It compares case-insensitive on Windows and case-sensitive everywhere else.\n #[cfg(not(windows))]\n-#[derive(PartialEq, Eq, Hash, Clone, Show)]\n+#[derive(Hash, PartialEq, Eq, Clone, Show)]\n struct EnvKey(CString);\n \n #[doc(hidden)]\n@@ -107,8 +107,8 @@ struct EnvKey(CString);\n struct EnvKey(CString);\n \n #[cfg(windows)]\n-impl Hash for EnvKey {\n-    fn hash(&self, state: &mut SipState) {\n+impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for EnvKey {\n+    fn hash(&self, state: &mut H) {\n         let &EnvKey(ref x) = self;\n         match str::from_utf8(x.as_bytes()) {\n             Ok(s) => for ch in s.chars() {"}, {"sha": "6950a6cf8d04f11c8f7c0b58f0bb615a5c8c42f4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -150,6 +150,7 @@ pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;\n pub use core::default;\n pub use core::finally;\n+pub use core::hash;\n pub use core::intrinsics;\n pub use core::iter;\n #[cfg(stage0)] #[cfg(not(test))] pub use core::marker as kinds;\n@@ -242,7 +243,6 @@ pub mod time;\n /* Common data structures */\n \n pub mod collections;\n-pub mod hash;\n \n /* Threads and communication */\n \n@@ -274,6 +274,7 @@ mod std {\n     pub use clone;\n     pub use cmp;\n     pub use hash;\n+    pub use default;\n \n     pub use sync; // used for select!()\n     pub use error; // used for try!()"}, {"sha": "b13278205b4ebbfaa4bf33815330bf6e08ada1b1", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -91,7 +91,7 @@ impl FromStr for Path {\n     }\n }\n \n-impl<S: hash::Writer> hash::Hash<S> for Path {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.repr.hash(state)"}, {"sha": "0a43c7b5140e8150908362e12dd96f47896a7bbf", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -118,7 +118,7 @@ impl FromStr for Path {\n     }\n }\n \n-impl<S: hash::Writer> hash::Hash<S> for Path {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n     #[cfg(not(test))]\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "36bf696dba5503da7cb02b613ee782cf941be89d", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -11,7 +11,8 @@\n use prelude::v1::*;\n use self::Req::*;\n \n-use collections;\n+use collections::HashMap;\n+use collections::hash_map::Hasher;\n use ffi::CString;\n use hash::Hash;\n use io::process::{ProcessExit, ExitStatus, ExitSignal};\n@@ -60,7 +61,7 @@ impl Process {\n                               out_fd: Option<P>, err_fd: Option<P>)\n                               -> IoResult<Process>\n         where C: ProcessConfig<K, V>, P: AsInner<FileDesc>,\n-              K: BytesContainer + Eq + Hash, V: BytesContainer\n+              K: BytesContainer + Eq + Hash<Hasher>, V: BytesContainer\n     {\n         use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n         use libc::funcs::bsd44::getdtablesize;\n@@ -553,11 +554,11 @@ fn with_argv<T,F>(prog: &CString, args: &[CString],\n     cb(ptrs.as_ptr())\n }\n \n-fn with_envp<K,V,T,F>(env: Option<&collections::HashMap<K, V>>,\n+fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n                       cb: F)\n                       -> T\n     where F : FnOnce(*const c_void) -> T,\n-          K : BytesContainer + Eq + Hash,\n+          K : BytesContainer + Eq + Hash<Hasher>,\n           V : BytesContainer\n {\n     // On posixy systems we can pass a char** for envp, which is a"}, {"sha": "1b837385d1eb60a37512b2ad9d210e4ab955d3d9", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -13,6 +13,7 @@ use prelude::v1::*;\n use collections;\n use ffi::CString;\n use hash::Hash;\n+use collections::hash_map::Hasher;\n use io::fs::PathExtensions;\n use io::process::{ProcessExit, ExitStatus, ExitSignal};\n use io::{IoResult, IoError};\n@@ -109,7 +110,7 @@ impl Process {\n                               out_fd: Option<P>, err_fd: Option<P>)\n                               -> IoResult<Process>\n         where C: ProcessConfig<K, V>, P: AsInner<FileDesc>,\n-              K: BytesContainer + Eq + Hash, V: BytesContainer\n+              K: BytesContainer + Eq + Hash<Hasher>, V: BytesContainer\n     {\n         use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n         use libc::consts::os::extra::{\n@@ -424,8 +425,10 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n     }\n }\n \n-fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T where\n-    K: BytesContainer + Eq + Hash, V: BytesContainer, F: FnOnce(*mut c_void) -> T,\n+fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T\n+    where K: BytesContainer + Eq + Hash<Hasher>,\n+          V: BytesContainer,\n+          F: FnOnce(*mut c_void) -> T,\n {\n     // On Windows we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final"}, {"sha": "db99c14244324569e63c86e56d399933ae56c93f", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -30,7 +30,8 @@ pub fn expand_deriving_hash<F>(cx: &mut ExtCtxt,\n     let generics = LifetimeBounds {\n         lifetimes: Vec::new(),\n         bounds: vec!((\"__S\",\n-                      vec!(Path::new(vec!(\"std\", \"hash\", \"Writer\"))))),\n+                      vec!(Path::new(vec!(\"std\", \"hash\", \"Writer\")),\n+                           Path::new(vec!(\"std\", \"hash\", \"Hasher\"))))),\n     };\n     let args = Path::new_local(\"__S\");\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));"}, {"sha": "13a14d069d70510765a45b54f7112a6b0df3b08b", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -37,9 +37,11 @@\n //!   Moreover, a switch to, e.g. `P<'a, T>` would be easy and mostly automated.\n \n use std::fmt::{self, Show};\n-use std::hash::Hash;\n+use std::hash::{Hash, Hasher};\n+#[cfg(stage0)] use std::hash::Writer;\n use std::ops::Deref;\n use std::ptr;\n+\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// An owned smart pointer.\n@@ -105,7 +107,14 @@ impl<T: Show> Show for P<T> {\n     }\n }\n \n-impl<S, T: Hash<S>> Hash<S> for P<T> {\n+#[cfg(stage0)]\n+impl<S: Writer, T: Hash<S>> Hash<S> for P<T> {\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n+#[cfg(not(stage0))]\n+impl<S: Hasher, T: Hash<S>> Hash<S> for P<T> {\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }"}, {"sha": "7058fa64811c025d51646f123aae9e5de4bf9155", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -20,6 +20,7 @@ use std::cmp::Ordering;\n use std::collections::HashMap;\n use std::fmt;\n use std::hash::Hash;\n+use std::collections::hash_map::Hasher;\n use std::ops::Deref;\n use std::rc::Rc;\n \n@@ -28,8 +29,8 @@ pub struct Interner<T> {\n     vect: RefCell<Vec<T> >,\n }\n \n-// when traits can extend traits, we should extend index<Name,T> to get .index(&FullRange)\n-impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n+// when traits can extend traits, we should extend index<Name,T> to get []\n+impl<T: Eq + Hash<Hasher> + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n             map: RefCell::new(HashMap::new()),\n@@ -78,7 +79,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n     }\n \n     pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where Q: BorrowFrom<T> + Eq + Hash {\n+    where Q: BorrowFrom<T> + Eq + Hash<Hasher> {\n         let map = self.map.borrow();\n         match (*map).get(val) {\n             Some(v) => Some(*v),\n@@ -203,7 +204,7 @@ impl StrInterner {\n     }\n \n     pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where Q: BorrowFrom<RcStr> + Eq + Hash {\n+    where Q: BorrowFrom<RcStr> + Eq + Hash<Hasher> {\n         match (*self.map.borrow()).get(val) {\n             Some(v) => Some(*v),\n             None => None,"}, {"sha": "6061c4fd1d3d30b181761b78a2760910e872ced4", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -12,7 +12,7 @@\n \n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::collections::hash_map;\n+use std::collections::hash_map::{self, Hasher};\n use std::fmt;\n use std::hash::Hash;\n use std::io;\n@@ -440,7 +440,7 @@ pub fn write_boxplot<W: Writer, T: Float + fmt::String + fmt::Show + FromPrimiti\n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n pub fn freq_count<T, U>(mut iter: T) -> hash_map::HashMap<U, uint>\n-  where T: Iterator<Item=U>, U: Eq + Clone + Hash\n+  where T: Iterator<Item=U>, U: Eq + Clone + Hash<Hasher>\n {\n     let mut map: hash_map::HashMap<U,uint> = hash_map::HashMap::new();\n     for elem in iter {"}, {"sha": "edeb07c960e7e45ceca6c6473c1e1d10b9e8d53d", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -18,6 +18,7 @@ extern crate rand;\n use std::collections::BTreeSet;\n use std::collections::BitvSet;\n use std::collections::HashSet;\n+use std::collections::hash_map::Hasher;\n use std::hash::Hash;\n use std::os;\n use std::time::Duration;\n@@ -43,7 +44,7 @@ trait MutableSet<T> {\n     fn contains(&self, k: &T) -> bool;\n }\n \n-impl<T: Hash + Eq> MutableSet<T> for HashSet<T> {\n+impl<T: Hash<Hasher> + Eq> MutableSet<T> for HashSet<T> {\n     fn insert(&mut self, k: T) { self.insert(k); }\n     fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n     fn contains(&self, k: &T) -> bool { self.contains(k) }"}, {"sha": "02ab7e5db5b89e06e3f6d3d063c5a96e112346c4", "filename": "src/test/run-pass/deriving-hash.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-hash.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use std::hash;\n-use std::hash::Hash;\n+use std::hash::{Hash, SipHasher};\n \n #[derive(Hash)]\n struct Person {\n@@ -19,6 +17,10 @@ struct Person {\n     phone: uint,\n }\n \n+fn hash<T: Hash<SipHasher>>(t: &T) -> u64 {\n+    std::hash::hash::<T, SipHasher>(t)\n+}\n+\n fn main() {\n     let person1 = Person {\n         id: 5,\n@@ -30,6 +32,6 @@ fn main() {\n         name: \"Bob\".to_string(),\n         phone: 555_666_7777\n     };\n-    assert!(hash::hash(&person1) == hash::hash(&person1));\n-    assert!(hash::hash(&person1) != hash::hash(&person2));\n+    assert!(hash(&person1) == hash(&person1));\n+    assert!(hash(&person1) != hash(&person2));\n }"}, {"sha": "f45dce9da632e40070727ff9e9f2be28e14f2f45", "filename": "src/test/run-pass/deriving-meta-multiple.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -9,7 +9,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash::hash;\n+use std::hash::{Hash, SipHasher};\n \n // testing multiple separate deriving attributes\n #[derive(PartialEq)]\n@@ -20,6 +20,8 @@ struct Foo {\n     baz: int\n }\n \n+fn hash<T: Hash<SipHasher>>(_t: &T) {}\n+\n pub fn main() {\n     let a = Foo {bar: 4, baz: -3};\n "}, {"sha": "d6a2fad08ed880fdc81146c4c25d09b9980be803", "filename": "src/test/run-pass/deriving-meta.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -9,14 +9,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash::hash;\n+use std::hash::{Hash, SipHasher};\n \n #[derive(PartialEq, Clone, Hash)]\n struct Foo {\n     bar: uint,\n     baz: int\n }\n \n+fn hash<T: Hash<SipHasher>>(_t: &T) {}\n+\n pub fn main() {\n     let a = Foo {bar: 4, baz: -3};\n "}, {"sha": "e346c4ff3495e2f3f1aa210f73c8d804f833fa5a", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511f0b8a3de5a166fc96aba5170782c9abf92101/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=511f0b8a3de5a166fc96aba5170782c9abf92101", "patch": "@@ -14,7 +14,7 @@\n extern crate \"typeid-intrinsic\" as other1;\n extern crate \"typeid-intrinsic2\" as other2;\n \n-use std::hash;\n+use std::hash::{self, SipHasher};\n use std::intrinsics;\n use std::intrinsics::TypeId;\n \n@@ -70,5 +70,6 @@ pub fn main() {\n     // check it has a hash\n     let (a, b) = (TypeId::of::<uint>(), TypeId::of::<uint>());\n \n-    assert_eq!(hash::hash(&a), hash::hash(&b));\n+    assert_eq!(hash::hash::<TypeId, SipHasher>(&a),\n+               hash::hash::<TypeId, SipHasher>(&b));\n }"}]}