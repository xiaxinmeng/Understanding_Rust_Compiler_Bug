{"sha": "baa1c1834f608c8c789db6d2495626ff9d28dd96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYTFjMTgzNGY2MDhjOGM3ODlkYjZkMjQ5NTYyNmZmOWQyOGRkOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-03T02:15:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-03T02:15:36Z"}, "message": "auto merge of #6140 : Dretch/rust/run-with-rust, r=brson\n\nEven more of `core::run` could be rust-ified -- I believe that access to the C extern environ can be done with rust now. I did not do this because some special casing is needed for OSX and I don't have a mac I can test with.\r\n\r\nI think this will also fix #6096.", "tree": {"sha": "60fd48ee85df71d9a3b5ff418f1c616e80c1954c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60fd48ee85df71d9a3b5ff418f1c616e80c1954c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baa1c1834f608c8c789db6d2495626ff9d28dd96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baa1c1834f608c8c789db6d2495626ff9d28dd96", "html_url": "https://github.com/rust-lang/rust/commit/baa1c1834f608c8c789db6d2495626ff9d28dd96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baa1c1834f608c8c789db6d2495626ff9d28dd96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73733c96db89f267e8a3289f660937c807b71283", "url": "https://api.github.com/repos/rust-lang/rust/commits/73733c96db89f267e8a3289f660937c807b71283", "html_url": "https://github.com/rust-lang/rust/commit/73733c96db89f267e8a3289f660937c807b71283"}, {"sha": "bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6", "html_url": "https://github.com/rust-lang/rust/commit/bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6"}], "stats": {"total": 742, "additions": 492, "deletions": 250}, "files": [{"sha": "59b06faf5a2517471fdc76a4a999f830bcef8312", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 127, "deletions": 4, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=baa1c1834f608c8c789db6d2495626ff9d28dd96", "patch": "@@ -582,12 +582,16 @@ pub mod types {\n \n                 pub type LPWSTR = *mut WCHAR;\n                 pub type LPSTR = *mut CHAR;\n+                pub type LPTSTR = *mut CHAR;\n \n                 // Not really, but opaque to us.\n                 pub type LPSECURITY_ATTRIBUTES = LPVOID;\n \n                 pub type LPVOID = *mut c_void;\n+                pub type LPBYTE = *mut BYTE;\n                 pub type LPWORD = *mut WORD;\n+                pub type LPDWORD = *mut DWORD;\n+                pub type LPHANDLE = *mut HANDLE;\n \n                 pub type LRESULT = LONG_PTR;\n                 pub type PBOOL = *mut BOOL;\n@@ -596,6 +600,36 @@ pub mod types {\n \n                 pub type time64_t = i64;\n                 pub type int64 = i64;\n+\n+                pub struct STARTUPINFO {\n+                    cb: DWORD,\n+                    lpReserved: LPTSTR,\n+                    lpDesktop: LPTSTR,\n+                    lpTitle: LPTSTR,\n+                    dwX: DWORD,\n+                    dwY: DWORD,\n+                    dwXSize: DWORD,\n+                    dwYSize: DWORD,\n+                    dwXCountChars: DWORD,\n+                    dwYCountCharts: DWORD,\n+                    dwFillAttribute: DWORD,\n+                    dwFlags: DWORD,\n+                    wShowWindow: WORD,\n+                    cbReserved2: WORD,\n+                    lpReserved2: LPBYTE,\n+                    hStdInput: HANDLE,\n+                    hStdOutput: HANDLE,\n+                    hStdError: HANDLE\n+                }\n+                pub type LPSTARTUPINFO = *mut STARTUPINFO;\n+\n+                pub struct PROCESS_INFORMATION {\n+                    hProcess: HANDLE,\n+                    hThread: HANDLE,\n+                    dwProcessId: DWORD,\n+                    dwThreadId: DWORD\n+                }\n+                pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n             }\n         }\n     }\n@@ -848,13 +882,62 @@ pub mod consts {\n         pub mod bsd44 {\n         }\n         pub mod extra {\n+            use libc::types::os::arch::extra::{DWORD, BOOL};\n+\n+            pub static TRUE : BOOL = 1;\n+            pub static FALSE : BOOL = 0;\n+\n             pub static O_TEXT : int = 16384;\n             pub static O_BINARY : int = 32768;\n             pub static O_NOINHERIT: int = 128;\n \n             pub static ERROR_SUCCESS : int = 0;\n             pub static ERROR_INSUFFICIENT_BUFFER : int = 122;\n             pub static INVALID_HANDLE_VALUE: int = -1;\n+\n+            pub static DELETE : DWORD = 0x00010000;\n+            pub static READ_CONTROL : DWORD = 0x00020000;\n+            pub static SYNCHRONIZE : DWORD = 0x00100000;\n+            pub static WRITE_DAC : DWORD = 0x00040000;\n+            pub static WRITE_OWNER : DWORD = 0x00080000;\n+\n+            pub static PROCESS_CREATE_PROCESS : DWORD = 0x0080;\n+            pub static PROCESS_CREATE_THREAD : DWORD = 0x0002;\n+            pub static PROCESS_DUP_HANDLE : DWORD = 0x0040;\n+            pub static PROCESS_QUERY_INFORMATION : DWORD = 0x0400;\n+            pub static PROCESS_QUERY_LIMITED_INFORMATION : DWORD = 0x1000;\n+            pub static PROCESS_SET_INFORMATION : DWORD = 0x0200;\n+            pub static PROCESS_SET_QUOTA : DWORD = 0x0100;\n+            pub static PROCESS_SUSPEND_RESUME : DWORD = 0x0800;\n+            pub static PROCESS_TERMINATE : DWORD = 0x0001;\n+            pub static PROCESS_VM_OPERATION : DWORD = 0x0008;\n+            pub static PROCESS_VM_READ : DWORD = 0x0010;\n+            pub static PROCESS_VM_WRITE : DWORD = 0x0020;\n+\n+            pub static STARTF_FORCEONFEEDBACK : DWORD = 0x00000040;\n+            pub static STARTF_FORCEOFFFEEDBACK : DWORD = 0x00000080;\n+            pub static STARTF_PREVENTPINNING : DWORD = 0x00002000;\n+            pub static STARTF_RUNFULLSCREEN : DWORD = 0x00000020;\n+            pub static STARTF_TITLEISAPPID : DWORD = 0x00001000;\n+            pub static STARTF_TITLEISLINKNAME : DWORD = 0x00000800;\n+            pub static STARTF_USECOUNTCHARS : DWORD = 0x00000008;\n+            pub static STARTF_USEFILLATTRIBUTE : DWORD = 0x00000010;\n+            pub static STARTF_USEHOTKEY : DWORD = 0x00000200;\n+            pub static STARTF_USEPOSITION : DWORD = 0x00000004;\n+            pub static STARTF_USESHOWWINDOW : DWORD = 0x00000001;\n+            pub static STARTF_USESIZE : DWORD = 0x00000002;\n+            pub static STARTF_USESTDHANDLES : DWORD = 0x00000100;\n+\n+            pub static WAIT_ABANDONED : DWORD = 0x00000080;\n+            pub static WAIT_OBJECT_0 : DWORD = 0x00000000;\n+            pub static WAIT_TIMEOUT : DWORD = 0x00000102;\n+            pub static WAIT_FAILED : DWORD = -1;\n+\n+            pub static DUPLICATE_CLOSE_SOURCE : DWORD = 0x00000001;\n+            pub static DUPLICATE_SAME_ACCESS : DWORD = 0x00000002;\n+\n+            pub static INFINITE : DWORD = -1;\n+            pub static STILL_ACTIVE : DWORD = 259;\n         }\n     }\n \n@@ -1751,12 +1834,24 @@ pub mod funcs {\n \n             unsafe fn sysctlnametomib(name: *c_char, mibp: *mut c_int,\n                                sizep: *mut size_t) -> c_int;\n+\n+            unsafe fn getdtablesize() -> c_int;\n         }\n     }\n \n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n+    pub mod bsd44 {\n+        use libc::types::os::arch::c95::{c_int};\n+\n+        #[abi = \"cdecl\"]\n+        pub extern {\n+            unsafe fn getdtablesize() -> c_int;\n+        }\n+    }\n+\n+\n     #[cfg(target_os = \"win32\")]\n     pub mod bsd44 {\n     }\n@@ -1790,9 +1885,11 @@ pub mod funcs {\n         pub mod kernel32 {\n             use libc::types::os::arch::c95::{c_uint};\n             use libc::types::os::arch::extra::{BOOL, DWORD, HMODULE};\n-            use libc::types::os::arch::extra::{LPCWSTR, LPWSTR, LPTCH};\n-            use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES};\n-            use libc::types::os::arch::extra::{HANDLE};\n+            use libc::types::os::arch::extra::{LPCWSTR, LPWSTR, LPCTSTR,\n+                                               LPTSTR, LPTCH, LPDWORD, LPVOID};\n+            use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, LPSTARTUPINFO,\n+                                               LPPROCESS_INFORMATION};\n+            use libc::types::os::arch::extra::{HANDLE, LPHANDLE};\n \n             #[abi = \"stdcall\"]\n             pub extern \"stdcall\" {\n@@ -1829,19 +1926,45 @@ pub mod funcs {\n                                        findFileData: HANDLE)\n                     -> BOOL;\n                 unsafe fn FindClose(findFile: HANDLE) -> BOOL;\n+                unsafe fn DuplicateHandle(hSourceProcessHandle: HANDLE,\n+                                          hSourceHandle: HANDLE,\n+                                          hTargetProcessHandle: HANDLE,\n+                                          lpTargetHandle: LPHANDLE,\n+                                          dwDesiredAccess: DWORD,\n+                                          bInheritHandle: BOOL,\n+                                          dwOptions: DWORD) -> BOOL;\n                 unsafe fn CloseHandle(hObject: HANDLE) -> BOOL;\n+                unsafe fn OpenProcess(dwDesiredAccess: DWORD,\n+                                      bInheritHandle: BOOL,\n+                                      dwProcessId: DWORD) -> HANDLE;\n+                unsafe fn GetCurrentProcess() -> HANDLE;\n+                unsafe fn CreateProcessA(lpApplicationName: LPCTSTR,\n+                                         lpCommandLine: LPTSTR,\n+                                         lpProcessAttributes: LPSECURITY_ATTRIBUTES,\n+                                         lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n+                                         bInheritHandles: BOOL,\n+                                         dwCreationFlags: DWORD,\n+                                         lpEnvironment: LPVOID,\n+                                         lpCurrentDirectory: LPCTSTR,\n+                                         lpStartupInfo: LPSTARTUPINFO,\n+                                         lpProcessInformation: LPPROCESS_INFORMATION) -> BOOL;\n+                unsafe fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n                 unsafe fn TerminateProcess(hProcess: HANDLE, uExitCode: c_uint) -> BOOL;\n+                unsafe fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;\n             }\n         }\n \n         pub mod msvcrt {\n-            use libc::types::os::arch::c95::c_int;\n+            use libc::types::os::arch::c95::{c_int, c_long};\n \n             #[abi = \"cdecl\"]\n             #[nolink]\n             pub extern {\n                 #[link_name = \"_commit\"]\n                 unsafe fn commit(fd: c_int) -> c_int;\n+\n+                #[link_name = \"_get_osfhandle\"]\n+                unsafe fn get_osfhandle(fd: c_int) -> c_long;\n             }\n         }\n     }"}, {"sha": "c4b03d76cefec7bf44447df6fff04feade145b62", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=baa1c1834f608c8c789db6d2495626ff9d28dd96", "patch": "@@ -373,7 +373,7 @@ pub fn pipe() -> Pipe {\n         // inheritance has to be handled in a different way that I do not\n         // fully understand. Here we explicitly make the pipe non-inheritable,\n         // which means to pass it to a subprocess they need to be duplicated\n-        // first, as in rust_run_program.\n+        // first, as in core::run.\n         let mut fds = Pipe {in: 0 as c_int,\n                     out: 0 as c_int };\n         let res = libc::pipe(&mut fds.in, 1024 as ::libc::c_uint,"}, {"sha": "7e73b3a3f80be398244e4629b711538416c5f3b7", "filename": "src/libcore/run.rs", "status": "modified", "additions": 346, "deletions": 59, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=baa1c1834f608c8c789db6d2495626ff9d28dd96", "patch": "@@ -22,31 +22,6 @@ use str;\n use task;\n use vec;\n \n-pub mod rustrt {\n-    use libc::{c_int, c_void};\n-    use libc;\n-    use run;\n-\n-    #[abi = \"cdecl\"]\n-    pub extern {\n-        unsafe fn rust_run_program(argv: **libc::c_char,\n-                                   envp: *c_void,\n-                                   dir: *libc::c_char,\n-                                   in_fd: c_int,\n-                                   out_fd: c_int,\n-                                   err_fd: c_int) -> run::RunProgramResult;\n-        unsafe fn rust_process_wait(pid: c_int) -> c_int;\n-    }\n-}\n-\n-pub struct RunProgramResult {\n-    // the process id of the program, or -1 if in case of errors\n-    pid: pid_t,\n-    // a handle to the process - on unix this will always be NULL, but on windows it will be a\n-    // HANDLE to the process, which will prevent the pid being re-used until the handle is closed.\n-    handle: *(),\n-}\n-\n /// A value representing a child process\n pub struct Program {\n     priv pid: pid_t,\n@@ -191,21 +166,262 @@ pub fn spawn_process(prog: &str, args: &[~str],\n     return res.pid;\n }\n \n+struct RunProgramResult {\n+    // the process id of the program (this should never be negative)\n+    pid: pid_t,\n+    // a handle to the process - on unix this will always be NULL, but on windows it will be a\n+    // HANDLE to the process, which will prevent the pid being re-used until the handle is closed.\n+    handle: *(),\n+}\n+\n+#[cfg(windows)]\n+fn spawn_process_internal(prog: &str, args: &[~str],\n+                          env: &Option<~[(~str,~str)]>,\n+                          dir: &Option<~str>,\n+                          in_fd: c_int, out_fd: c_int, err_fd: c_int) -> RunProgramResult {\n+\n+    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+    use libc::consts::os::extra::{\n+        TRUE, FALSE,\n+        STARTF_USESTDHANDLES,\n+        INVALID_HANDLE_VALUE,\n+        DUPLICATE_SAME_ACCESS\n+    };\n+    use libc::funcs::extra::kernel32::{\n+        GetCurrentProcess,\n+        DuplicateHandle,\n+        CloseHandle,\n+        CreateProcessA\n+    };\n+    use libc::funcs::extra::msvcrt::get_osfhandle;\n+\n+    unsafe {\n+\n+        let mut si = zeroed_startupinfo();\n+        si.cb = sys::size_of::<STARTUPINFO>() as DWORD;\n+        si.dwFlags = STARTF_USESTDHANDLES;\n+\n+        let cur_proc = GetCurrentProcess();\n+\n+        let orig_std_in = get_osfhandle(if in_fd > 0 { in_fd } else { 0 }) as HANDLE;\n+        if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n+            fail!(fmt!(\"failure in get_osfhandle: %s\", os::last_os_error()));\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail!(fmt!(\"failure in DuplicateHandle: %s\", os::last_os_error()));\n+        }\n+\n+        let orig_std_out = get_osfhandle(if out_fd > 0 { out_fd } else { 1 }) as HANDLE;\n+        if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n+            fail!(fmt!(\"failure in get_osfhandle: %s\", os::last_os_error()));\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail!(fmt!(\"failure in DuplicateHandle: %s\", os::last_os_error()));\n+        }\n+\n+        let orig_std_err = get_osfhandle(if err_fd > 0 { err_fd } else { 2 }) as HANDLE;\n+        if orig_std_err as HANDLE == INVALID_HANDLE_VALUE as HANDLE {\n+            fail!(fmt!(\"failure in get_osfhandle: %s\", os::last_os_error()));\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail!(fmt!(\"failure in DuplicateHandle: %s\", os::last_os_error()));\n+        }\n+\n+        let cmd = make_command_line(prog, args);\n+        let mut pi = zeroed_process_information();\n+        let mut create_err = None;\n+\n+        do with_envp(env) |envp| {\n+            do with_dirp(dir) |dirp| {\n+                do str::as_c_str(cmd) |cmdp| {\n+                    let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n+                                                 ptr::mut_null(), ptr::mut_null(), TRUE,\n+                                                 0, envp, dirp, &mut si, &mut pi);\n+                    if created == FALSE {\n+                        create_err = Some(os::last_os_error());\n+                    }\n+                }\n+            }\n+        }\n+\n+        CloseHandle(si.hStdInput);\n+        CloseHandle(si.hStdOutput);\n+        CloseHandle(si.hStdError);\n+\n+        for create_err.each |msg| {\n+            fail!(fmt!(\"failure in CreateProcess: %s\", *msg));\n+        }\n+\n+        // We close the thread handle because we don't care about keeping the thread id valid,\n+        // and we aren't keeping the thread handle around to be able to close it later. We don't\n+        // close the process handle however because we want the process id to stay valid at least\n+        // until the calling code closes the process handle.\n+        CloseHandle(pi.hThread);\n+\n+        RunProgramResult {\n+            pid: pi.dwProcessId as pid_t,\n+            handle: pi.hProcess as *()\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n+    libc::types::os::arch::extra::STARTUPINFO {\n+        cb: 0,\n+        lpReserved: ptr::mut_null(),\n+        lpDesktop: ptr::mut_null(),\n+        lpTitle: ptr::mut_null(),\n+        dwX: 0,\n+        dwY: 0,\n+        dwXSize: 0,\n+        dwYSize: 0,\n+        dwXCountChars: 0,\n+        dwYCountCharts: 0,\n+        dwFillAttribute: 0,\n+        dwFlags: 0,\n+        wShowWindow: 0,\n+        cbReserved2: 0,\n+        lpReserved2: ptr::mut_null(),\n+        hStdInput: ptr::mut_null(),\n+        hStdOutput: ptr::mut_null(),\n+        hStdError: ptr::mut_null()\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n+    libc::types::os::arch::extra::PROCESS_INFORMATION {\n+        hProcess: ptr::mut_null(),\n+        hThread: ptr::mut_null(),\n+        dwProcessId: 0,\n+        dwThreadId: 0\n+    }\n+}\n+\n+// FIXME: this is only pub so it can be tested (see issue #4536)\n+#[cfg(windows)]\n+pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n+\n+    let mut cmd = ~\"\";\n+    append_arg(&mut cmd, prog);\n+    for args.each |arg| {\n+        cmd.push_char(' ');\n+        append_arg(&mut cmd, *arg);\n+    }\n+    return cmd;\n+\n+    fn append_arg(cmd: &mut ~str, arg: &str) {\n+        let quote = arg.any(|c| c == ' ' || c == '\\t');\n+        if quote {\n+            cmd.push_char('\"');\n+        }\n+        for uint::range(0, arg.len()) |i| {\n+            append_char_at(cmd, arg, i);\n+        }\n+        if quote {\n+            cmd.push_char('\"');\n+        }\n+    }\n+\n+    fn append_char_at(cmd: &mut ~str, arg: &str, i: uint) {\n+        match arg[i] as char {\n+            '\"' => {\n+                // Escape quotes.\n+                cmd.push_str(\"\\\\\\\"\");\n+            }\n+            '\\\\' => {\n+                if backslash_run_ends_in_quote(arg, i) {\n+                    // Double all backslashes that are in runs before quotes.\n+                    cmd.push_str(\"\\\\\\\\\");\n+                } else {\n+                    // Pass other backslashes through unescaped.\n+                    cmd.push_char('\\\\');\n+                }\n+            }\n+            c => {\n+                cmd.push_char(c);\n+            }\n+        }\n+    }\n+\n+    fn backslash_run_ends_in_quote(s: &str, mut i: uint) -> bool {\n+        while i < s.len() && s[i] as char == '\\\\' {\n+            i += 1;\n+        }\n+        return i < s.len() && s[i] as char == '\"';\n+    }\n+}\n+\n+#[cfg(unix)]\n fn spawn_process_internal(prog: &str, args: &[~str],\n                           env: &Option<~[(~str,~str)]>,\n                           dir: &Option<~str>,\n                           in_fd: c_int, out_fd: c_int, err_fd: c_int) -> RunProgramResult {\n+\n+    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+    use libc::funcs::bsd44::getdtablesize;\n+\n+    mod rustrt {\n+        use libc::c_void;\n+\n+        #[abi = \"cdecl\"]\n+        pub extern {\n+            unsafe fn rust_unset_sigprocmask();\n+            unsafe fn rust_set_environ(envp: *c_void);\n+        }\n+    }\n+\n     unsafe {\n-        do with_argv(prog, args) |argv| {\n-            do with_envp(env) |envp| {\n-                do with_dirp(dir) |dirp| {\n-                    rustrt::rust_run_program(argv, envp, dirp, in_fd, out_fd, err_fd)\n+\n+        let pid = fork();\n+        if pid < 0 {\n+            fail!(fmt!(\"failure in fork: %s\", os::last_os_error()));\n+        } else if pid > 0 {\n+            return RunProgramResult {pid: pid, handle: ptr::null()};\n+        }\n+\n+        rustrt::rust_unset_sigprocmask();\n+\n+        if in_fd > 0 && dup2(in_fd, 0) == -1 {\n+            fail!(fmt!(\"failure in dup2(in_fd, 0): %s\", os::last_os_error()));\n+        }\n+        if out_fd > 0 && dup2(out_fd, 1) == -1 {\n+            fail!(fmt!(\"failure in dup2(out_fd, 1): %s\", os::last_os_error()));\n+        }\n+        if err_fd > 0 && dup2(err_fd, 2) == -1 {\n+            fail!(fmt!(\"failure in dup3(err_fd, 2): %s\", os::last_os_error()));\n+        }\n+        // close all other fds\n+        for int::range_rev(getdtablesize() as int - 1, 2) |fd| {\n+            close(fd as c_int);\n+        }\n+\n+        for dir.each |dir| {\n+            do str::as_c_str(*dir) |dirp| {\n+                if chdir(dirp) == -1 {\n+                    fail!(fmt!(\"failure in chdir: %s\", os::last_os_error()));\n                 }\n             }\n         }\n+\n+        do with_envp(env) |envp| {\n+            if !envp.is_null() {\n+                rustrt::rust_set_environ(envp);\n+            }\n+            do with_argv(prog, args) |argv| {\n+                execvp(*argv, argv);\n+                // execvp only returns if an error occurred\n+                fail!(fmt!(\"failure in execvp: %s\", os::last_os_error()));\n+            }\n+        }\n     }\n }\n \n+#[cfg(unix)]\n fn with_argv<T>(prog: &str, args: &[~str],\n                 cb: &fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = str::as_c_str(prog, |b| ~[b]);\n@@ -246,7 +462,7 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n \n #[cfg(windows)]\n fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n-                cb: &fn(*c_void) -> T) -> T {\n+                cb: &fn(*mut c_void) -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n@@ -264,11 +480,12 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n             blk += ~[0_u8];\n             vec::as_imm_buf(blk, |p, _len| cb(::cast::transmute(p)))\n           }\n-          _ => cb(ptr::null())\n+          _ => cb(ptr::mut_null())\n         }\n     }\n }\n \n+#[cfg(windows)]\n fn with_dirp<T>(d: &Option<~str>,\n                 cb: &fn(*libc::c_char) -> T) -> T {\n     match *d {\n@@ -312,8 +529,6 @@ priv fn free_handle(_handle: *()) {\n pub fn run_program(prog: &str, args: &[~str]) -> int {\n     let res = spawn_process_internal(prog, args, &None, &None,\n                                      0i32, 0i32, 0i32);\n-    if res.pid == -1 as pid_t { fail!(); }\n-\n     let code = waitpid(res.pid);\n     free_handle(res.handle);\n     return code;\n@@ -345,7 +560,6 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n                                pipe_err.out);\n \n     unsafe {\n-        if res.pid == -1 as pid_t { fail!(); }\n         libc::close(pipe_input.in);\n         libc::close(pipe_output.out);\n         libc::close(pipe_err.out);\n@@ -398,13 +612,6 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n     os::close(pipe_in.in);\n     os::close(pipe_out.out);\n     os::close(pipe_err.out);\n-    if res.pid == -1i32 {\n-        os::close(pipe_in.out);\n-        os::close(pipe_out.in);\n-        os::close(pipe_err.in);\n-        fail!();\n-    }\n-\n     os::close(pipe_in.out);\n \n     // Spawn two entire schedulers to read both stdout and sterr\n@@ -485,11 +692,46 @@ pub fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(windows)]\n     fn waitpid_os(pid: pid_t) -> int {\n-        let status = unsafe { rustrt::rust_process_wait(pid) };\n-        if status < 0 {\n-            fail!(fmt!(\"failure in rust_process_wait: %s\", os::last_os_error()));\n+\n+        use libc::types::os::arch::extra::DWORD;\n+        use libc::consts::os::extra::{\n+            SYNCHRONIZE,\n+            PROCESS_QUERY_INFORMATION,\n+            FALSE,\n+            STILL_ACTIVE,\n+            INFINITE,\n+            WAIT_FAILED\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            OpenProcess,\n+            GetExitCodeProcess,\n+            CloseHandle,\n+            WaitForSingleObject\n+        };\n+\n+        unsafe {\n+\n+            let proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n+            if proc.is_null() {\n+                fail!(fmt!(\"failure in OpenProcess: %s\", os::last_os_error()));\n+            }\n+\n+            loop {\n+                let mut status = 0;\n+                if GetExitCodeProcess(proc, &mut status) == FALSE {\n+                    CloseHandle(proc);\n+                    fail!(fmt!(\"failure in GetExitCodeProcess: %s\", os::last_os_error()));\n+                }\n+                if status != STILL_ACTIVE {\n+                    CloseHandle(proc);\n+                    return status as int;\n+                }\n+                if WaitForSingleObject(proc, INFINITE) == WAIT_FAILED {\n+                    CloseHandle(proc);\n+                    fail!(fmt!(\"failure in WaitForSingleObject: %s\", os::last_os_error()));\n+                }\n+            }\n         }\n-        return status as int;\n     }\n \n     #[cfg(unix)]\n@@ -539,10 +781,30 @@ mod tests {\n     use libc;\n     use option::None;\n     use os;\n-    use path::Path;\n     use run::{readclose, writeclose};\n     use run;\n \n+    #[test]\n+    #[cfg(windows)]\n+    fn test_make_command_line() {\n+        assert_eq!(\n+            run::make_command_line(\"prog\", [~\"aaa\", ~\"bbb\", ~\"ccc\"]),\n+            ~\"prog aaa bbb ccc\"\n+        );\n+        assert_eq!(\n+            run::make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [~\"aaa\"]),\n+            ~\"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n+        );\n+        assert_eq!(\n+            run::make_command_line(\"C:\\\\Program Files\\\\test\", [~\"aa\\\"bb\"]),\n+            ~\"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n+        );\n+        assert_eq!(\n+            run::make_command_line(\"echo\", [~\"a b c\"]),\n+            ~\"echo \\\"a b c\\\"\"\n+        );\n+    }\n+\n     // Regression test for memory leaks\n     #[test]\n     fn test_leaks() {\n@@ -607,34 +869,59 @@ mod tests {\n         p.destroy(); // ...and nor should this (and nor should the destructor)\n     }\n \n-    #[cfg(unix)] // there is no way to sleep on windows from inside libcore...\n     fn test_destroy_actually_kills(force: bool) {\n-        let path = Path(fmt!(\"test/core-run-test-destroy-actually-kills-%?.tmp\", force));\n \n-        os::remove_file(&path);\n+        #[cfg(unix)]\n+        static BLOCK_COMMAND: &'static str = \"cat\";\n \n-        let cmd = fmt!(\"sleep 5 && echo MurderDeathKill > %s\", path.to_str());\n-        let mut p = run::start_program(\"sh\", [~\"-c\", cmd]);\n+        #[cfg(windows)]\n+        static BLOCK_COMMAND: &'static str = \"cmd\";\n \n-        p.destroy(); // destroy the program before it has a chance to echo its message\n+        #[cfg(unix)]\n+        fn process_exists(pid: libc::pid_t) -> bool {\n+            run::program_output(\"ps\", [~\"-p\", pid.to_str()]).out.contains(pid.to_str())\n+        }\n \n-        unsafe {\n-            // wait to ensure the program is really destroyed and not just waiting itself\n-            libc::sleep(10);\n+        #[cfg(windows)]\n+        fn process_exists(pid: libc::pid_t) -> bool {\n+\n+            use libc::types::os::arch::extra::DWORD;\n+            use libc::funcs::extra::kernel32::{CloseHandle, GetExitCodeProcess, OpenProcess};\n+            use libc::consts::os::extra::{FALSE, PROCESS_QUERY_INFORMATION, STILL_ACTIVE };\n+\n+            unsafe {\n+                let proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n+                if proc.is_null() {\n+                    return false;\n+                }\n+                // proc will be non-null if the process is alive, or if it died recently\n+                let mut status = 0;\n+                GetExitCodeProcess(proc, &mut status);\n+                CloseHandle(proc);\n+                return status == STILL_ACTIVE;\n+            }\n+        }\n+\n+        // this program will stay alive indefinitely trying to read from stdin\n+        let mut p = run::start_program(BLOCK_COMMAND, []);\n+\n+        assert!(process_exists(p.get_id()));\n+\n+        if force {\n+            p.force_destroy();\n+        } else {\n+            p.destroy();\n         }\n \n-        // the program should not have had chance to echo its message\n-        assert!(!path.exists());\n+        assert!(!process_exists(p.get_id()));\n     }\n \n     #[test]\n-    #[cfg(unix)]\n     fn test_unforced_destroy_actually_kills() {\n         test_destroy_actually_kills(false);\n     }\n \n     #[test]\n-    #[cfg(unix)]\n     fn test_forced_destroy_actually_kills() {\n         test_destroy_actually_kills(true);\n     }"}, {"sha": "0ba760786914006dc1f58c5660a52c9e18bec374", "filename": "src/rt/rust_run_program.cpp", "status": "modified", "additions": 16, "deletions": 184, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Frt%2Frust_run_program.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Frt%2Frust_run_program.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_run_program.cpp?ref=baa1c1834f608c8c789db6d2495626ff9d28dd96", "patch": "@@ -15,212 +15,44 @@\n #include <crt_externs.h>\n #endif\n \n-struct RunProgramResult {\n-    pid_t pid;\n-    void* handle;\n-};\n-\n #if defined(__WIN32__)\n \n-#include <process.h>\n-#include <io.h>\n-\n-bool backslash_run_ends_in_quote(char const *c) {\n-    while (*c == '\\\\') ++c;\n-    return *c == '\"';\n-}\n-\n-void append_first_char(char *&buf, char const *c) {\n-    switch (*c) {\n-\n-    case '\"':\n-        // Escape quotes.\n-        *buf++ = '\\\\';\n-        *buf++ = '\"';\n-        break;\n-\n-\n-    case '\\\\':\n-        if (backslash_run_ends_in_quote(c)) {\n-            // Double all backslashes that are in runs before quotes.\n-            *buf++ = '\\\\';\n-            *buf++ = '\\\\';\n-        } else {\n-            // Pass other backslashes through unescaped.\n-            *buf++ = '\\\\';\n-        }\n-        break;\n-\n-    default:\n-        *buf++ = *c;\n-    }\n+extern \"C\" CDECL void\n+rust_unset_sigprocmask() {\n+    // empty stub for windows to keep linker happy\n }\n \n-bool contains_whitespace(char const *arg) {\n-    while (*arg) {\n-        switch (*arg++) {\n-        case ' ':\n-        case '\\t':\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-void append_arg(char *& buf, char const *arg, bool last) {\n-    bool quote = contains_whitespace(arg);\n-    if (quote)\n-        *buf++ = '\"';\n-    while (*arg)\n-        append_first_char(buf, arg++);\n-    if (quote)\n-        *buf++ = '\"';\n-\n-    if (! last) {\n-        *buf++ = ' ';\n-    } else {\n-        *buf++ = '\\0';\n-    }\n-}\n-\n-extern \"C\" CDECL RunProgramResult\n-rust_run_program(const char* argv[],\n-                 void* envp,\n-                 const char* dir,\n-                 int in_fd, int out_fd, int err_fd) {\n-    STARTUPINFO si;\n-    ZeroMemory(&si, sizeof(STARTUPINFO));\n-    si.cb = sizeof(STARTUPINFO);\n-    si.dwFlags = STARTF_USESTDHANDLES;\n-\n-    RunProgramResult result = {-1, NULL};\n-\n-    HANDLE curproc = GetCurrentProcess();\n-    HANDLE origStdin = (HANDLE)_get_osfhandle(in_fd ? in_fd : 0);\n-    if (!DuplicateHandle(curproc, origStdin,\n-        curproc, &si.hStdInput, 0, 1, DUPLICATE_SAME_ACCESS))\n-        return result;\n-    HANDLE origStdout = (HANDLE)_get_osfhandle(out_fd ? out_fd : 1);\n-    if (!DuplicateHandle(curproc, origStdout,\n-        curproc, &si.hStdOutput, 0, 1, DUPLICATE_SAME_ACCESS))\n-        return result;\n-    HANDLE origStderr = (HANDLE)_get_osfhandle(err_fd ? err_fd : 2);\n-    if (!DuplicateHandle(curproc, origStderr,\n-        curproc, &si.hStdError, 0, 1, DUPLICATE_SAME_ACCESS))\n-        return result;\n-\n-    size_t cmd_len = 0;\n-    for (const char** arg = argv; *arg; arg++) {\n-        cmd_len += strlen(*arg);\n-        cmd_len += 3; // Two quotes plus trailing space or \\0\n-    }\n-    cmd_len *= 2; // Potentially backslash-escape everything.\n-\n-    char* cmd = (char*)malloc(cmd_len);\n-    char* pos = cmd;\n-    for (const char** arg = argv; *arg; arg++) {\n-        append_arg(pos, *arg, *(arg+1) == NULL);\n-    }\n-\n-    PROCESS_INFORMATION pi;\n-    BOOL created = CreateProcess(NULL, cmd, NULL, NULL, TRUE,\n-                                 0, envp, dir, &si, &pi);\n-\n-    CloseHandle(si.hStdInput);\n-    CloseHandle(si.hStdOutput);\n-    CloseHandle(si.hStdError);\n-    free(cmd);\n-\n-    if (!created) {\n-        return result;\n-    }\n-\n-    // We close the thread handle because we don't care about keeping the thread id valid,\n-    // and we aren't keeping the thread handle around to be able to close it later. We don't\n-    // close the process handle however because we want the process id to stay valid at least\n-    // until the calling rust code closes the process handle.\n-    CloseHandle(pi.hThread);\n-    result.pid = pi.dwProcessId;\n-    result.handle = pi.hProcess;\n-    return result;\n-}\n-\n-extern \"C\" CDECL int\n-rust_process_wait(int pid) {\n-\n-    HANDLE proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid);\n-    if (proc == NULL) {\n-        return -1;\n-    }\n-\n-    DWORD status;\n-    while (true) {\n-        if (!GetExitCodeProcess(proc, &status)) {\n-            CloseHandle(proc);\n-            return -1;\n-        }\n-        if (status != STILL_ACTIVE) {\n-            CloseHandle(proc);\n-            return (int) status;\n-        }\n-        WaitForSingleObject(proc, INFINITE);\n-    }\n+extern \"C\" CDECL void\n+rust_set_environ(void* envp) {\n+    // empty stub for windows to keep linker happy\n }\n \n #elif defined(__GNUC__)\n \n-#include <sys/file.h>\n #include <signal.h>\n-#include <sys/ioctl.h>\n #include <unistd.h>\n-#include <termios.h>\n \n #ifdef __FreeBSD__\n extern char **environ;\n #endif\n \n-extern \"C\" CDECL RunProgramResult\n-rust_run_program(const char* argv[],\n-                 void* envp,\n-                 const char* dir,\n-                 int in_fd, int out_fd, int err_fd) {\n-    int pid = fork();\n-    if (pid != 0) {\n-        RunProgramResult result = {pid, NULL};\n-        return result;\n-    }\n-\n+extern \"C\" CDECL void\n+rust_unset_sigprocmask() {\n+    // this can't be safely converted to rust code because the\n+    // representation of sigset_t is platform-dependent\n     sigset_t sset;\n     sigemptyset(&sset);\n     sigprocmask(SIG_SETMASK, &sset, NULL);\n+}\n \n-    if (in_fd) dup2(in_fd, 0);\n-    if (out_fd) dup2(out_fd, 1);\n-    if (err_fd) dup2(err_fd, 2);\n-    /* Close all other fds. */\n-    for (int fd = getdtablesize() - 1; fd >= 3; fd--) close(fd);\n-    if (dir) {\n-        int result = chdir(dir);\n-        // FIXME (#2674): need error handling\n-        assert(!result && \"chdir failed\");\n-    }\n-\n-    if (envp) {\n+extern \"C\" CDECL void\n+rust_set_environ(void* envp) {\n+    // FIXME: this could actually be converted to rust (see issue #2674)\n #ifdef __APPLE__\n-        *_NSGetEnviron() = (char **)envp;\n+    *_NSGetEnviron() = (char **) envp;\n #else\n-        environ = (char **)envp;\n+    environ = (char **) envp;\n #endif\n-    }\n-\n-    execvp(argv[0], (char * const *)argv);\n-    exit(1);\n-}\n-\n-extern \"C\" CDECL int\n-rust_process_wait(int pid) {\n-    // FIXME: stub; exists to placate linker. (#2692)\n-    return 0;\n }\n \n #else"}, {"sha": "408e2e9a816711899e7940b1ea6e5ed90eccb266", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=baa1c1834f608c8c789db6d2495626ff9d28dd96", "patch": "@@ -37,8 +37,8 @@ rust_list_dir_wfd_size\n rust_list_dir_wfd_fp_buf\n rust_log_console_on\n rust_log_console_off\n-rust_process_wait\n-rust_run_program\n+rust_set_environ\n+rust_unset_sigprocmask\n rust_sched_current_nonlazy_threads\n rust_sched_threads\n rust_set_exit_status"}]}