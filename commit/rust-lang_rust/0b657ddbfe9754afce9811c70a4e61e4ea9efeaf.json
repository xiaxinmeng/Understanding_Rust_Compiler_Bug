{"sha": "0b657ddbfe9754afce9811c70a4e61e4ea9efeaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNjU3ZGRiZmU5NzU0YWZjZTk4MTFjNzBhNGU2MWU0ZWE5ZWZlYWY=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-06-25T01:42:44Z"}, "committer": {"name": "Paul Daniel Faria", "email": "nashenas88@users.noreply.github.com", "date": "2020-06-25T13:27:00Z"}, "message": "Revert resolution of all glob imports first, replace with tracking of glob imports and shadowing when more specific", "tree": {"sha": "9a99332d1d2fa720fbb0da6af4122a5c4d6526f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a99332d1d2fa720fbb0da6af4122a5c4d6526f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf", "html_url": "https://github.com/rust-lang/rust/commit/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70d4829560b81e3f5dc8e624da702ed6d345c49c", "url": "https://api.github.com/repos/rust-lang/rust/commits/70d4829560b81e3f5dc8e624da702ed6d345c49c", "html_url": "https://github.com/rust-lang/rust/commit/70d4829560b81e3f5dc8e624da702ed6d345c49c"}], "stats": {"total": 168, "additions": 119, "deletions": 49}, "files": [{"sha": "0184b6af9e5e8fedc7aad94b4e16052b2e7321b5", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=0b657ddbfe9754afce9811c70a4e61e4ea9efeaf", "patch": "@@ -128,25 +128,29 @@ impl ItemScope {\n         let existing = self.visible.entry(name).or_default();\n \n         macro_rules! check_changed {\n-            ($changed:ident, $existing:expr, $def:expr) => {\n-                match ($existing, $def) {\n+            ($changed:ident, ($existing:ident/$def:ident).$field:ident) => {\n+                match ($existing.$field, $def.$field) {\n                     (None, Some(_)) => {\n-                        $existing = $def;\n+                        $existing.from_glob = $def.from_glob;\n+                        $existing.$field = $def.$field;\n                         $changed = true;\n                     }\n-                    (Some(e), Some(d)) if e.0 != d.0 => {\n+                    // Only update if the new def came from a specific import and the existing\n+                    // import came from a glob import.\n+                    (Some(_), Some(_)) if $existing.from_glob && !$def.from_glob => {\n                         mark::hit!(import_shadowed);\n-                        $existing = $def;\n+                        $existing.from_glob = $def.from_glob;\n+                        $existing.$field = $def.$field;\n                         $changed = true;\n                     }\n                     _ => {}\n                 }\n             };\n         }\n \n-        check_changed!(changed, existing.types, def.types);\n-        check_changed!(changed, existing.values, def.values);\n-        check_changed!(changed, existing.macros, def.macros);\n+        check_changed!(changed, (existing / def).types);\n+        check_changed!(changed, (existing / def).values);\n+        check_changed!(changed, (existing / def).macros);\n \n         changed\n     }"}, {"sha": "93f58e2c761b9914f58dcc4d9fafa3c9a34d092e", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 49, "deletions": 35, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=0b657ddbfe9754afce9811c70a4e61e4ea9efeaf", "patch": "@@ -305,6 +305,7 @@ impl DefCollector<'_> {\n                 self.def_map.root,\n                 &[(name, PerNs::macros(macro_, Visibility::Public))],\n                 Visibility::Public,\n+                false,\n             );\n         }\n     }\n@@ -330,6 +331,7 @@ impl DefCollector<'_> {\n             self.def_map.root,\n             &[(name, PerNs::macros(macro_, Visibility::Public))],\n             Visibility::Public,\n+            false,\n         );\n     }\n \n@@ -380,35 +382,25 @@ impl DefCollector<'_> {\n \n         while self.unresolved_imports.len() < n_previous_unresolved {\n             n_previous_unresolved = self.unresolved_imports.len();\n-            let mut imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n-            for mut directive in &mut imports {\n+            let imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+            for mut directive in imports {\n                 directive.status = self.resolve_import(directive.module_id, &directive.import);\n-            }\n-\n-            let (glob_imports, non_glob_imports): (Vec<_>, Vec<_>) =\n-                imports.into_iter().partition(|directive| directive.import.is_glob);\n-            let mut record = |imports: Vec<ImportDirective>| {\n-                for directive in imports {\n-                    match directive.status {\n-                        PartialResolvedImport::Indeterminate(_) => {\n-                            self.record_resolved_import(&directive);\n-                            // FIXME: For avoid performance regression,\n-                            // we consider an imported resolved if it is indeterminate (i.e not all namespace resolved)\n-                            self.resolved_imports.push(directive)\n-                        }\n-                        PartialResolvedImport::Resolved(_) => {\n-                            self.record_resolved_import(&directive);\n-                            self.resolved_imports.push(directive)\n-                        }\n-                        PartialResolvedImport::Unresolved => {\n-                            self.unresolved_imports.push(directive);\n-                        }\n+                match directive.status {\n+                    PartialResolvedImport::Indeterminate(_) => {\n+                        self.record_resolved_import(&directive);\n+                        // FIXME: For avoid performance regression,\n+                        // we consider an imported resolved if it is indeterminate (i.e not all namespace resolved)\n+                        self.resolved_imports.push(directive)\n+                    }\n+                    PartialResolvedImport::Resolved(_) => {\n+                        self.record_resolved_import(&directive);\n+                        self.resolved_imports.push(directive)\n+                    }\n+                    PartialResolvedImport::Unresolved => {\n+                        self.unresolved_imports.push(directive);\n                     }\n                 }\n-            };\n-\n-            record(glob_imports);\n-            record(non_glob_imports);\n+            }\n         }\n     }\n \n@@ -486,7 +478,7 @@ impl DefCollector<'_> {\n                             .filter(|(_, res)| !res.is_none())\n                             .collect::<Vec<_>>();\n \n-                        self.update(module_id, &items, vis);\n+                        self.update(module_id, &items, vis, true);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n@@ -508,7 +500,7 @@ impl DefCollector<'_> {\n                             .filter(|(_, res)| !res.is_none())\n                             .collect::<Vec<_>>();\n \n-                        self.update(module_id, &items, vis);\n+                        self.update(module_id, &items, vis, true);\n                         // record the glob import in case we add further items\n                         let glob = self.glob_imports.entry(m.local_id).or_default();\n                         if !glob.iter().any(|(mid, _)| *mid == module_id) {\n@@ -538,7 +530,7 @@ impl DefCollector<'_> {\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, &resolutions, vis);\n+                    self.update(module_id, &resolutions, vis, true);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -564,15 +556,21 @@ impl DefCollector<'_> {\n                         }\n                     }\n \n-                    self.update(module_id, &[(name, def)], vis);\n+                    self.update(module_id, &[(name, def)], vis, false);\n                 }\n                 None => mark::hit!(bogus_paths),\n             }\n         }\n     }\n \n-    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, PerNs)], vis: Visibility) {\n-        self.update_recursive(module_id, resolutions, vis, 0)\n+    fn update(\n+        &mut self,\n+        module_id: LocalModuleId,\n+        resolutions: &[(Name, PerNs)],\n+        vis: Visibility,\n+        is_from_glob: bool,\n+    ) {\n+        self.update_recursive(module_id, resolutions, vis, is_from_glob, 0)\n     }\n \n     fn update_recursive(\n@@ -582,6 +580,9 @@ impl DefCollector<'_> {\n         // All resolutions are imported with this visibility; the visibilies in\n         // the `PerNs` values are ignored and overwritten\n         vis: Visibility,\n+        // All resolutions are imported with this glob status; the glob status\n+        // in the `PerNs` values are ignored and overwritten\n+        is_from_glob: bool,\n         depth: usize,\n     ) {\n         if depth > 100 {\n@@ -591,7 +592,8 @@ impl DefCollector<'_> {\n         let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            changed |= scope.push_res(name.clone(), res.with_visibility(vis));\n+            changed |=\n+                scope.push_res(name.clone(), res.with_visibility(vis).from_glob(is_from_glob));\n         }\n \n         if !changed {\n@@ -610,7 +612,13 @@ impl DefCollector<'_> {\n             if !vis.is_visible_from_def_map(&self.def_map, glob_importing_module) {\n                 continue;\n             }\n-            self.update_recursive(glob_importing_module, resolutions, glob_import_vis, depth + 1);\n+            self.update_recursive(\n+                glob_importing_module,\n+                resolutions,\n+                glob_import_vis,\n+                true,\n+                depth + 1,\n+            );\n         }\n     }\n \n@@ -932,6 +940,7 @@ impl ModCollector<'_, '_> {\n                         self.module_id,\n                         &[(name.clone(), PerNs::from_def(id, vis, has_constructor))],\n                         vis,\n+                        false,\n                     )\n                 }\n             }\n@@ -1034,7 +1043,12 @@ impl ModCollector<'_, '_> {\n         let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: res };\n         let def: ModuleDefId = module.into();\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        self.def_collector.update(self.module_id, &[(name, PerNs::from_def(def, vis, false))], vis);\n+        self.def_collector.update(\n+            self.module_id,\n+            &[(name, PerNs::from_def(def, vis, false))],\n+            vis,\n+            false,\n+        );\n         res\n     }\n "}, {"sha": "7f3d7509c94cbb55740d8ccb9131862b394e8f6e", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=0b657ddbfe9754afce9811c70a4e61e4ea9efeaf", "patch": "@@ -322,3 +322,47 @@ fn glob_shadowed_def_reversed() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn glob_shadowed_def_dependencies() {\n+    let map = def_map(\n+        r###\"\n+        //- /lib.rs\n+        mod a { pub mod foo { pub struct X; } }\n+        mod b { pub use super::a::foo; }\n+        mod c { pub mod foo { pub struct Y; } }\n+        mod d {\n+            use super::c::foo;\n+            use super::b::*;\n+            use foo::Y;\n+        }\n+        \"###,\n+    );\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eea: t\n+        \u22eeb: t\n+        \u22eec: t\n+        \u22eed: t\n+        \u22ee\n+        \u22eecrate::d\n+        \u22eeY: t v\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::c\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::c::foo\n+        \u22eeY: t v\n+        \u22ee\n+        \u22eecrate::b\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::a\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::a::foo\n+        \u22eeX: t v\n+    \"###\n+    );\n+}"}, {"sha": "e5cbca71d61b931f8b90045ad02b0e83c6c255db", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b657ddbfe9754afce9811c70a4e61e4ea9efeaf/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=0b657ddbfe9754afce9811c70a4e61e4ea9efeaf", "patch": "@@ -9,36 +9,37 @@ use crate::{item_scope::ItemInNs, visibility::Visibility, ModuleDefId};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub struct PerNs {\n+    pub from_glob: bool,\n     pub types: Option<(ModuleDefId, Visibility)>,\n     pub values: Option<(ModuleDefId, Visibility)>,\n     pub macros: Option<(MacroDefId, Visibility)>,\n }\n \n impl Default for PerNs {\n     fn default() -> Self {\n-        PerNs { types: None, values: None, macros: None }\n+        PerNs { from_glob: false, types: None, values: None, macros: None }\n     }\n }\n \n impl PerNs {\n     pub fn none() -> PerNs {\n-        PerNs { types: None, values: None, macros: None }\n+        PerNs { from_glob: false, types: None, values: None, macros: None }\n     }\n \n     pub fn values(t: ModuleDefId, v: Visibility) -> PerNs {\n-        PerNs { types: None, values: Some((t, v)), macros: None }\n+        PerNs { from_glob: false, types: None, values: Some((t, v)), macros: None }\n     }\n \n     pub fn types(t: ModuleDefId, v: Visibility) -> PerNs {\n-        PerNs { types: Some((t, v)), values: None, macros: None }\n+        PerNs { from_glob: false, types: Some((t, v)), values: None, macros: None }\n     }\n \n     pub fn both(types: ModuleDefId, values: ModuleDefId, v: Visibility) -> PerNs {\n-        PerNs { types: Some((types, v)), values: Some((values, v)), macros: None }\n+        PerNs { from_glob: false, types: Some((types, v)), values: Some((values, v)), macros: None }\n     }\n \n     pub fn macros(macro_: MacroDefId, v: Visibility) -> PerNs {\n-        PerNs { types: None, values: None, macros: Some((macro_, v)) }\n+        PerNs { from_glob: false, types: None, values: None, macros: Some((macro_, v)) }\n     }\n \n     pub fn is_none(&self) -> bool {\n@@ -63,6 +64,7 @@ impl PerNs {\n \n     pub fn filter_visibility(self, mut f: impl FnMut(Visibility) -> bool) -> PerNs {\n         PerNs {\n+            from_glob: self.from_glob,\n             types: self.types.filter(|(_, v)| f(*v)),\n             values: self.values.filter(|(_, v)| f(*v)),\n             macros: self.macros.filter(|(_, v)| f(*v)),\n@@ -71,6 +73,7 @@ impl PerNs {\n \n     pub fn with_visibility(self, vis: Visibility) -> PerNs {\n         PerNs {\n+            from_glob: self.from_glob,\n             types: self.types.map(|(it, _)| (it, vis)),\n             values: self.values.map(|(it, _)| (it, vis)),\n             macros: self.macros.map(|(it, _)| (it, vis)),\n@@ -79,6 +82,7 @@ impl PerNs {\n \n     pub fn or(self, other: PerNs) -> PerNs {\n         PerNs {\n+            from_glob: self.from_glob,\n             types: self.types.or(other.types),\n             values: self.values.or(other.values),\n             macros: self.macros.or(other.macros),\n@@ -92,4 +96,8 @@ impl PerNs {\n             .chain(self.values.map(|it| ItemInNs::Values(it.0)).into_iter())\n             .chain(self.macros.map(|it| ItemInNs::Macros(it.0)).into_iter())\n     }\n+\n+    pub fn from_glob(self, from_glob: bool) -> PerNs {\n+        PerNs { from_glob, ..self }\n+    }\n }"}]}