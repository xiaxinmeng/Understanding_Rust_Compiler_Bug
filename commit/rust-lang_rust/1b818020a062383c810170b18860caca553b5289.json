{"sha": "1b818020a062383c810170b18860caca553b5289", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiODE4MDIwYTA2MjM4M2M4MTAxNzBiMTg4NjBjYWNhNTUzYjUyODk=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-08T21:21:34Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-13T19:06:00Z"}, "message": "Remove container guide.\n\nThis isn't really what guides are for, this information belongs in the\nmodule-level docs.\n\nFixes #9314.", "tree": {"sha": "73310db912bdc7b8eb6569e997193db57535fc39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73310db912bdc7b8eb6569e997193db57535fc39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b818020a062383c810170b18860caca553b5289", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b818020a062383c810170b18860caca553b5289", "html_url": "https://github.com/rust-lang/rust/commit/1b818020a062383c810170b18860caca553b5289", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b818020a062383c810170b18860caca553b5289/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84030fd05a6d6b0bc3d31cf638bc8c88adae7a41", "url": "https://api.github.com/repos/rust-lang/rust/commits/84030fd05a6d6b0bc3d31cf638bc8c88adae7a41", "html_url": "https://github.com/rust-lang/rust/commit/84030fd05a6d6b0bc3d31cf638bc8c88adae7a41"}], "stats": {"total": 421, "additions": 3, "deletions": 418}, "files": [{"sha": "e9bda17f4bc7d9956d5dadd65c8ccf0cb9fdc108", "filename": "src/doc/guide-container.md", "status": "modified", "additions": 3, "deletions": 411, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/1b818020a062383c810170b18860caca553b5289/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b818020a062383c810170b18860caca553b5289/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=1b818020a062383c810170b18860caca553b5289", "patch": "@@ -1,414 +1,6 @@\n % The Rust Containers and Iterators Guide\n \n-# Containers\n+This guide has been removed, with no direct replacement.\n \n-The container traits are defined in the `std::container` module.\n-\n-## Unique vectors\n-\n-Vectors have `O(1)` indexing, push (to the end) and pop (from the end). Vectors\n-are the most common container in Rust, and are flexible enough to fit many use\n-cases.\n-\n-Vectors can also be sorted and used as efficient lookup tables with the\n-`bsearch()` method, if all the elements are inserted at one time and\n-deletions are unnecessary.\n-\n-## Maps and sets\n-\n-Maps are collections of unique keys with corresponding values, and sets are\n-just unique keys without a corresponding value. The `Map` and `Set` traits in\n-`std::container` define the basic interface.\n-\n-The standard library provides three owned map/set types:\n-\n-* `collections::HashMap` and `collections::HashSet`, requiring the keys to\n-  implement `Eq` and `Hash`\n-* `collections::TrieMap` and `collections::TrieSet`, requiring the keys to be `uint`\n-* `collections::TreeMap` and `collections::TreeSet`, requiring the keys\n-  to implement `Ord`\n-\n-These maps do not use managed pointers so they can be sent between tasks as\n-long as the key and value types are sendable. Neither the key or value type has\n-to be copyable.\n-\n-The `TrieMap` and `TreeMap` maps are ordered, while `HashMap` uses an arbitrary\n-order.\n-\n-Each `HashMap` instance has a random 128-bit key to use with a keyed hash,\n-making the order of a set of keys in a given hash table randomized. Rust\n-provides a [SipHash](https://131002.net/siphash/) implementation for any type\n-implementing the `Hash` trait.\n-\n-## Double-ended queues\n-\n-The `collections::ringbuf` module implements a double-ended queue with `O(1)`\n-amortized inserts and removals from both ends of the container. It also has\n-`O(1)` indexing like a vector. The contained elements are not required to be\n-copyable, and the queue will be sendable if the contained type is sendable.\n-Its interface `Deque` is defined in `collections`.\n-\n-The `extra::dlist` module implements a double-ended linked list, also\n-implementing the `Deque` trait, with `O(1)` removals and inserts at either end,\n-and `O(1)` concatenation.\n-\n-## Priority queues\n-\n-The `collections::priority_queue` module implements a queue ordered by a key.  The\n-contained elements are not required to be copyable, and the queue will be\n-sendable if the contained type is sendable.\n-\n-Insertions have `O(log n)` time complexity and checking or popping the largest\n-element is `O(1)`. Converting a vector to a priority queue can be done\n-in-place, and has `O(n)` complexity. A priority queue can also be converted to\n-a sorted vector in-place, allowing it to be used for an `O(n log n)` in-place\n-heapsort.\n-\n-# Iterators\n-\n-## Iteration protocol\n-\n-The iteration protocol is defined by the `Iterator` trait in the\n-`std::iter` module. The minimal implementation of the trait is a `next`\n-method, yielding the next element from an iterator object:\n-\n-~~~\n-/// An infinite stream of zeroes\n-struct ZeroStream;\n-\n-impl Iterator<int> for ZeroStream {\n-    fn next(&mut self) -> Option<int> {\n-        Some(0)\n-    }\n-}\n-~~~\n-\n-Reaching the end of the iterator is signalled by returning `None` instead of\n-`Some(item)`:\n-\n-~~~\n-# fn main() {}\n-/// A stream of N zeroes\n-struct ZeroStream {\n-    remaining: uint\n-}\n-\n-impl ZeroStream {\n-    fn new(n: uint) -> ZeroStream {\n-        ZeroStream { remaining: n }\n-    }\n-}\n-\n-impl Iterator<int> for ZeroStream {\n-    fn next(&mut self) -> Option<int> {\n-        if self.remaining == 0 {\n-            None\n-        } else {\n-            self.remaining -= 1;\n-            Some(0)\n-        }\n-    }\n-}\n-~~~\n-\n-In general, you cannot rely on the behavior of the `next()` method after it has\n-returned `None`. Some iterators may return `None` forever. Others may behave\n-differently.\n-\n-## Container iterators\n-\n-Containers implement iteration over the contained elements by returning an\n-iterator object. For example, for vector slices several iterators are available:\n-\n-* `iter()` for immutable references to the elements\n-* `mut_iter()` for mutable references to the elements\n-* `move_iter()` to move the elements out by-value\n-\n-A typical mutable container will implement at least `iter()`, `mut_iter()` and\n-`move_iter()`. If it maintains an order, the returned iterators will be\n-`DoubleEndedIterator`s, which are described below.\n-\n-### Freezing\n-\n-Unlike most other languages with external iterators, Rust has no *iterator\n-invalidation*. As long as an iterator is still in scope, the compiler will prevent\n-modification of the container through another handle.\n-\n-~~~\n-let mut xs = [1i, 2, 3];\n-{\n-    let _it = xs.iter();\n-\n-    // the vector is frozen for this scope, the compiler will statically\n-    // prevent modification\n-}\n-// the vector becomes unfrozen again at the end of the scope\n-~~~\n-\n-These semantics are due to most container iterators being implemented with `&`\n-and `&mut`.\n-\n-## Iterator adaptors\n-\n-The `Iterator` trait provides many common algorithms as default methods. For\n-example, the `fold` method will accumulate the items yielded by an `Iterator`\n-into a single value:\n-\n-~~~\n-let xs = [1i, 9, 2, 3, 14, 12];\n-let result = xs.iter().fold(0, |accumulator, item| accumulator - *item);\n-assert_eq!(result, -41);\n-~~~\n-\n-Most adaptors return an adaptor object implementing the `Iterator` trait itself:\n-\n-~~~\n-let xs = [1i, 9, 2, 3, 14, 12];\n-let ys = [5i, 2, 1, 8];\n-let sum = xs.iter().chain(ys.iter()).fold(0, |a, b| a + *b);\n-assert_eq!(sum, 57);\n-~~~\n-\n-Some iterator adaptors may return `None` before exhausting the underlying\n-iterator. Additionally, if these iterator adaptors are called again after\n-returning `None`, they may call their underlying iterator again even if the\n-adaptor will continue to return `None` forever. This may not be desired if the\n-underlying iterator has side-effects.\n-\n-In order to provide a guarantee about behavior once `None` has been returned, an\n-iterator adaptor named `fuse()` is provided. This returns an iterator that will\n-never call its underlying iterator again once `None` has been returned:\n-\n-~~~\n-let xs = [1i,2,3,4,5];\n-let mut calls = 0i;\n-\n-{\n-    let it = xs.iter().scan((), |_, x| {\n-        calls += 1;\n-        if *x < 3 { Some(x) } else { None }});\n-\n-    // the iterator will only yield 1 and 2 before returning None\n-    // If we were to call it 5 times, calls would end up as 5, despite\n-    // only 2 values being yielded (and therefore 3 unique calls being\n-    // made). The fuse() adaptor can fix this.\n-\n-    let mut it = it.fuse();\n-    it.next();\n-    it.next();\n-    it.next();\n-    it.next();\n-    it.next();\n-}\n-\n-assert_eq!(calls, 3);\n-~~~\n-\n-## For loops\n-\n-The function `range` (or `range_inclusive`) allows to simply iterate through a given range:\n-\n-~~~\n-for i in range(0i, 5) {\n-  print!(\"{} \", i) // prints \"0 1 2 3 4\"\n-}\n-\n-for i in std::iter::range_inclusive(0i, 5) { // needs explicit import\n-  print!(\"{} \", i) // prints \"0 1 2 3 4 5\"\n-}\n-~~~\n-\n-The `for` keyword can be used as sugar for iterating through any iterator:\n-\n-~~~\n-let xs = [2u, 3, 5, 7, 11, 13, 17];\n-\n-// print out all the elements in the vector\n-for x in xs.iter() {\n-    println!(\"{}\", *x)\n-}\n-\n-// print out all but the first 3 elements in the vector\n-for x in xs.iter().skip(3) {\n-    println!(\"{}\", *x)\n-}\n-~~~\n-\n-For loops are *often* used with a temporary iterator object, as above. They can\n-also advance the state of an iterator in a mutable location:\n-\n-~~~\n-let xs = [1i, 2, 3, 4, 5];\n-let ys = [\"foo\", \"bar\", \"baz\", \"foobar\"];\n-\n-// create an iterator yielding tuples of elements from both vectors\n-let mut it = xs.iter().zip(ys.iter());\n-\n-// print out the pairs of elements up to (&3, &\"baz\")\n-for (x, y) in it {\n-    println!(\"{} {}\", *x, *y);\n-\n-    if *x == 3 {\n-        break;\n-    }\n-}\n-\n-// yield and print the last pair from the iterator\n-println!(\"last: {}\", it.next());\n-\n-// the iterator is now fully consumed\n-assert!(it.next().is_none());\n-~~~\n-\n-## Conversion\n-\n-Iterators offer generic conversion to containers with the `collect` adaptor:\n-\n-~~~\n-let xs = [0i, 1, 1, 2, 3, 5, 8];\n-let ys = xs.iter().rev().skip(1).map(|&x| x * 2).collect::<Vec<int>>();\n-assert_eq!(ys, vec![10, 6, 4, 2, 2, 0]);\n-~~~\n-\n-The method requires a type hint for the container type, if the surrounding code\n-does not provide sufficient information.\n-\n-Containers can provide conversion from iterators through `collect` by\n-implementing the `FromIterator` trait. For example, the implementation for\n-vectors is as follows:\n-\n-~~~ {.ignore}\n-impl<T> FromIterator<T> for Vec<T> {\n-    fn from_iter<I:Iterator<A>>(mut iterator: I) -> Vec<T> {\n-        let (lower, _) = iterator.size_hint();\n-        let mut vector = Vec::with_capacity(lower);\n-        for element in iterator {\n-            vector.push(element);\n-        }\n-        vector\n-    }\n-}\n-~~~\n-\n-### Size hints\n-\n-The `Iterator` trait provides a `size_hint` default method, returning a lower\n-bound and optionally on upper bound on the length of the iterator:\n-\n-~~~ {.ignore}\n-fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n-~~~\n-\n-The vector implementation of `FromIterator` from above uses the lower bound\n-to pre-allocate enough space to hold the minimum number of elements the\n-iterator will yield.\n-\n-The default implementation is always correct, but it should be overridden if\n-the iterator can provide better information.\n-\n-The `ZeroStream` from earlier can provide an exact lower and upper bound:\n-\n-~~~\n-# fn main() {}\n-/// A stream of N zeroes\n-struct ZeroStream {\n-    remaining: uint\n-}\n-\n-impl ZeroStream {\n-    fn new(n: uint) -> ZeroStream {\n-        ZeroStream { remaining: n }\n-    }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining, Some(self.remaining))\n-    }\n-}\n-\n-impl Iterator<int> for ZeroStream {\n-    fn next(&mut self) -> Option<int> {\n-        if self.remaining == 0 {\n-            None\n-        } else {\n-            self.remaining -= 1;\n-            Some(0)\n-        }\n-    }\n-}\n-~~~\n-\n-## Double-ended iterators\n-\n-The `DoubleEndedIterator` trait represents an iterator able to yield elements\n-from either end of a range. It inherits from the `Iterator` trait and extends\n-it with the `next_back` function.\n-\n-A `DoubleEndedIterator` can have its direction changed with the `rev` adaptor,\n-returning another `DoubleEndedIterator` with `next` and `next_back` exchanged.\n-\n-~~~\n-let xs = [1i, 2, 3, 4, 5, 6];\n-let mut it = xs.iter();\n-println!(\"{}\", it.next()); // prints `Some(1)`\n-println!(\"{}\", it.next()); // prints `Some(2)`\n-println!(\"{}\", it.next_back()); // prints `Some(6)`\n-\n-// prints `5`, `4` and `3`\n-for &x in it.rev() {\n-    println!(\"{}\", x)\n-}\n-~~~\n-\n-The `chain`, `map`, `filter`, `filter_map` and `inspect` adaptors are\n-`DoubleEndedIterator` implementations if the underlying iterators are.\n-\n-~~~\n-let xs = [1i, 2, 3, 4];\n-let ys = [5i, 6, 7, 8];\n-let mut it = xs.iter().chain(ys.iter()).map(|&x| x * 2);\n-\n-println!(\"{}\", it.next()); // prints `Some(2)`\n-\n-// prints `16`, `14`, `12`, `10`, `8`, `6`, `4`\n-for x in it.rev() {\n-    println!(\"{}\", x);\n-}\n-~~~\n-\n-The `reverse_` method is also available for any double-ended iterator yielding\n-mutable references. It can be used to reverse a container in-place. Note that\n-the trailing underscore is a workaround for issue #5898 and will be removed.\n-\n-~~~\n-let mut ys = [1i, 2, 3, 4, 5];\n-ys.mut_iter().reverse_();\n-assert!(ys == [5i, 4, 3, 2, 1]);\n-~~~\n-\n-## Random-access iterators\n-\n-The `RandomAccessIterator` trait represents an iterator offering random access\n-to the whole range. The `indexable` method retrieves the number of elements\n-accessible with the `idx` method.\n-\n-The `chain` adaptor is an implementation of `RandomAccessIterator` if the\n-underlying iterators are.\n-\n-~~~\n-let xs = [1i, 2, 3, 4, 5];\n-let ys = [7i, 9, 11];\n-let mut it = xs.iter().chain(ys.iter());\n-println!(\"{}\", it.idx(0)); // prints `Some(1)`\n-println!(\"{}\", it.idx(5)); // prints `Some(7)`\n-println!(\"{}\", it.idx(7)); // prints `Some(11)`\n-println!(\"{}\", it.idx(8)); // prints `None`\n-\n-// yield two elements from the beginning, and one from the end\n-it.next();\n-it.next();\n-it.next_back();\n-\n-println!(\"{}\", it.idx(0)); // prints `Some(3)`\n-println!(\"{}\", it.idx(4)); // prints `Some(9)`\n-println!(\"{}\", it.idx(6)); // prints `None`\n-~~~\n+You may enjoy reading the [iterator](std/iter/index.html) and\n+[collections](std/collections/index.html) documentation."}, {"sha": "475c3b748db7ff292fd29595ef9828dc66e16e97", "filename": "src/doc/index.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b818020a062383c810170b18860caca553b5289/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b818020a062383c810170b18860caca553b5289/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=1b818020a062383c810170b18860caca553b5289", "patch": "@@ -57,7 +57,6 @@ a guide that can help you out:\n * [Strings](guide-strings.html)\n * [Pointers](guide-pointers.html)\n * [References and Lifetimes](guide-lifetimes.html)\n-* [Containers and Iterators](guide-container.html)\n * [Tasks and Communication](guide-tasks.html)\n * [Foreign Function Interface](guide-ffi.html)\n * [Writing Unsafe and Low-Level Code](guide-unsafe.html)"}, {"sha": "cf977a6ebe60377594cf3eebcfc2e38e58c4622a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b818020a062383c810170b18860caca553b5289/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b818020a062383c810170b18860caca553b5289/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=1b818020a062383c810170b18860caca553b5289", "patch": "@@ -56,12 +56,6 @@ loop {\n \n This `for` loop syntax can be applied to any iterator over any type.\n \n-## Iteration protocol and more\n-\n-More detailed information about iterators can be found in the [container\n-guide](http://doc.rust-lang.org/guide-container.html) with\n-the rest of the rust manuals.\n-\n */\n \n use clone::Clone;"}]}