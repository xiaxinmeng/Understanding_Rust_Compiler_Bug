{"sha": "f200fbca10b4cc066120c4d19b58d2f244c6e638", "node_id": "C_kwDOAAsO6NoAKGYyMDBmYmNhMTBiNGNjMDY2MTIwYzRkMTliNThkMmYyNDRjNmU2Mzg", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-09-05T15:37:56Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-09-05T15:38:03Z"}, "message": "Implement simd_bitmask", "tree": {"sha": "4f9d02e0e006587d720a8ae509f1b47ee01ff0e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f9d02e0e006587d720a8ae509f1b47ee01ff0e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f200fbca10b4cc066120c4d19b58d2f244c6e638", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f200fbca10b4cc066120c4d19b58d2f244c6e638", "html_url": "https://github.com/rust-lang/rust/commit/f200fbca10b4cc066120c4d19b58d2f244c6e638", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f200fbca10b4cc066120c4d19b58d2f244c6e638/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bb9bdf8e337b494c5ea385a309425c46f6aa383", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb9bdf8e337b494c5ea385a309425c46f6aa383", "html_url": "https://github.com/rust-lang/rust/commit/0bb9bdf8e337b494c5ea385a309425c46f6aa383"}], "stats": {"total": 151, "additions": 111, "deletions": 40}, "files": [{"sha": "c75d5dda5caf57a04cf86868c5bebbd2db945341", "filename": "patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f200fbca10b4cc066120c4d19b58d2f244c6e638/patches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/f200fbca10b4cc066120c4d19b58d2f244c6e638/patches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=f200fbca10b4cc066120c4d19b58d2f244c6e638", "patch": "@@ -1,15 +1,15 @@\n-From 82f597cf81b169b0e72a576ac8751f598c059c48 Mon Sep 17 00:00:00 2001\n+From b742f03694b920cc14400727d54424e8e1b60928 Mon Sep 17 00:00:00 2001\n From: bjorn3 <bjorn3@users.noreply.github.com>\n Date: Thu, 18 Nov 2021 19:28:40 +0100\n Subject: [PATCH] Disable unsupported tests\n \n ---\n  crates/core_simd/src/elements/int.rs     | 8 ++++++++\n  crates/core_simd/src/elements/uint.rs    | 4 ++++\n- crates/core_simd/src/masks/full_masks.rs | 9 +++++++++\n+ crates/core_simd/src/masks/full_masks.rs | 6 ++++++\n  crates/core_simd/src/vector.rs           | 2 ++\n- crates/core_simd/tests/masks.rs          | 2 ++\n- 5 files changed, 25 insertions(+)\n+ crates/core_simd/tests/masks.rs          | 3 ---\n+ 5 files changed, 20 insertions(+), 3 deletions(-)\n \n diff --git a/crates/core_simd/src/elements/int.rs b/crates/core_simd/src/elements/int.rs\n index 9b8c37e..ea95f08 100644\n@@ -116,52 +116,35 @@ index 21e7e76..0d6dee2 100644\n              #[inline]\n              fn reduce_sum(self) -> Self::Scalar {\n diff --git a/crates/core_simd/src/masks/full_masks.rs b/crates/core_simd/src/masks/full_masks.rs\n-index adf0fcb..5b10292 100644\n+index adf0fcb..e7e657e 100644\n --- a/crates/core_simd/src/masks/full_masks.rs\n +++ b/crates/core_simd/src/masks/full_masks.rs\n-@@ -150,6 +150,7 @@ where\n+@@ -180,6 +180,7 @@ where\n          super::Mask<T, LANES>: ToBitMaskArray,\n          [(); <super::Mask<T, LANES> as ToBitMaskArray>::BYTES]: Sized,\n      {\n +        /*\n          assert_eq!(<super::Mask<T, LANES> as ToBitMaskArray>::BYTES, N);\n  \n          // Safety: N is the correct bitmask size\n-@@ -170,6 +171,8 @@ where\n- \n-             bitmask\n-         }\n-+        */\n-+        panic!();\n-     }\n- \n-     #[cfg(feature = \"generic_const_exprs\")]\n-@@ -209,6 +212,7 @@ where\n-     where\n-         super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n-     {\n-+        /*\n-         // Safety: U is required to be the appropriate bitmask type\n-         let bitmask: U = unsafe { intrinsics::simd_bitmask(self.0) };\n- \n-@@ -218,6 +222,8 @@ where\n-         } else {\n-             bitmask\n+@@ -202,6 +203,8 @@ where\n+                 Self::splat(false).to_int(),\n+             ))\n          }\n +        */\n +        panic!();\n      }\n  \n      #[inline]\n-@@ -225,6 +231,7 @@ where\n+@@ -225,6 +228,7 @@ where\n      where\n          super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n      {\n +        /*\n          // LLVM assumes bit order should match endianness\n          let bitmask = if cfg!(target_endian = \"big\") {\n              bitmask.reverse_bits(LANES)\n-@@ -240,6 +247,8 @@ where\n+@@ -240,6 +244,8 @@ where\n                  Self::splat(false).to_int(),\n              ))\n          }\n@@ -191,24 +174,30 @@ index e8e8f68..7173c24 100644\n  \n  impl<T, const LANES: usize> Copy for Simd<T, LANES>\n diff --git a/crates/core_simd/tests/masks.rs b/crates/core_simd/tests/masks.rs\n-index 673d0db..0d68b01 100644\n+index 673d0db..3ebfcd1 100644\n --- a/crates/core_simd/tests/masks.rs\n +++ b/crates/core_simd/tests/masks.rs\n-@@ -59,6 +59,7 @@ macro_rules! test_mask_api {\n-                 assert!(!v.all());\n+@@ -78,7 +78,6 @@ macro_rules! test_mask_api {\n+                 let mask = core_simd::Mask::<$type, 16>::from_array(values);\n+                 let bitmask = mask.to_bitmask();\n+                 assert_eq!(bitmask, 0b1000001101001001);\n+-                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n              }\n  \n-+            /*\n              #[test]\n-             fn roundtrip_int_conversion() {\n-                 let values = [true, false, false, true, false, false, true, false];\n-@@ -99,6 +100,7 @@ macro_rules! test_mask_api {\n+@@ -91,13 +90,11 @@ macro_rules! test_mask_api {\n+                 let mask = core_simd::Mask::<$type, 4>::from_array(values);\n+                 let bitmask = mask.to_bitmask();\n+                 assert_eq!(bitmask, 0b1000);\n+-                assert_eq!(core_simd::Mask::<$type, 4>::from_bitmask(bitmask), mask);\n+ \n+                 let values = [true, false];\n+                 let mask = core_simd::Mask::<$type, 2>::from_array(values);\n+                 let bitmask = mask.to_bitmask();\n                  assert_eq!(bitmask, 0b01);\n-                 assert_eq!(core_simd::Mask::<$type, 2>::from_bitmask(bitmask), mask);\n+-                assert_eq!(core_simd::Mask::<$type, 2>::from_bitmask(bitmask), mask);\n              }\n-+            */\n  \n              #[test]\n-             fn cast() {\n -- \n 2.25.1"}, {"sha": "4d77370dfc520acd684c0af602735827121db82f", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f200fbca10b4cc066120c4d19b58d2f244c6e638/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f200fbca10b4cc066120c4d19b58d2f244c6e638/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=f200fbca10b4cc066120c4d19b58d2f244c6e638", "patch": "@@ -2,6 +2,7 @@\n \n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::Symbol;\n+use rustc_target::abi::Endian;\n \n use super::*;\n use crate::prelude::*;\n@@ -162,6 +163,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                     }\n                 }\n             } else {\n+                // FIXME remove this case\n                 intrinsic.as_str()[\"simd_shuffle\".len()..].parse().unwrap()\n             };\n \n@@ -650,10 +652,90 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             }\n         }\n \n-        // simd_saturating_*\n-        // simd_bitmask\n+        sym::simd_bitmask => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_clif_ty = fx.clif_type(lane_ty).unwrap();\n+\n+            // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n+            // vector mask and returns the most significant bit (MSB) of each lane in the form\n+            // of either:\n+            // * an unsigned integer\n+            // * an array of `u8`\n+            // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+            //\n+            // The bit order of the result depends on the byte endianness, LSB-first for little\n+            // endian and MSB-first for big endian.\n+            let expected_int_bits = lane_count.max(8);\n+            let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n+\n+            match lane_ty.kind() {\n+                ty::Int(_) | ty::Uint(_) => {}\n+                _ => {\n+                    fx.tcx.sess.span_fatal(\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `simd_bitmask` intrinsic: \\\n+                            vector argument `{}`'s element type `{}`, expected integer element \\\n+                            type\",\n+                            a.layout().ty,\n+                            lane_ty\n+                        ),\n+                    );\n+                }\n+            }\n+\n+            let res_type =\n+                Type::int_with_byte_size(u16::try_from(expected_bytes).unwrap()).unwrap();\n+            let mut res = fx.bcx.ins().iconst(res_type, 0);\n+\n+            let lanes = match fx.tcx.sess.target.endian {\n+                Endian::Big => Box::new(0..lane_count) as Box<dyn Iterator<Item = u64>>,\n+                Endian::Little => Box::new((0..lane_count).rev()) as Box<dyn Iterator<Item = u64>>,\n+            };\n+            for lane in lanes {\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+\n+                // extract sign bit of an int\n+                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_clif_ty.bits() - 1));\n+\n+                // shift sign bit into result\n+                let a_lane_sign = clif_intcast(fx, a_lane_sign, res_type, false);\n+                res = fx.bcx.ins().ishl_imm(res, 1);\n+                res = fx.bcx.ins().bor(res, a_lane_sign);\n+            }\n+\n+            match ret.layout().ty.kind() {\n+                ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {}\n+                ty::Array(elem, len)\n+                    if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                        && len.try_eval_usize(fx.tcx, ty::ParamEnv::reveal_all())\n+                            == Some(expected_bytes) => {}\n+                _ => {\n+                    fx.tcx.sess.span_fatal(\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `simd_bitmask` intrinsic: \\\n+                            cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+                            ret.layout().ty,\n+                            expected_int_bits,\n+                            expected_bytes\n+                        ),\n+                    );\n+                }\n+            }\n+\n+            let res = CValue::by_val(res, ret.layout());\n+            ret.write_cvalue(fx, res);\n+        }\n+\n+        // simd_arith_offset\n+        // simd_saturating_add\n+        // simd_saturating_sub\n         // simd_scatter\n         // simd_gather\n+        // simd_select_bitmask\n         _ => {\n             fx.tcx.sess.span_fatal(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n         }"}]}