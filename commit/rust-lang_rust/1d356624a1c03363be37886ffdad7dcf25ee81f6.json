{"sha": "1d356624a1c03363be37886ffdad7dcf25ee81f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkMzU2NjI0YTFjMDMzNjNiZTM3ODg2ZmZkYWQ3ZGNmMjVlZTgxZjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-23T15:42:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-30T15:54:30Z"}, "message": "collections: Enable IndexMut for some collections\n\nThis commit enables implementations of IndexMut for a number of collections,\nincluding Vec, RingBuf, SmallIntMap, TrieMap, TreeMap, and HashMap. At the same\ntime this deprecates the `get_mut` methods on vectors in favor of using the\nindexing notation.\n\ncc #18424", "tree": {"sha": "4aef71be9e3f509b1bc8b4880e6894656e6404c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4aef71be9e3f509b1bc8b4880e6894656e6404c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d356624a1c03363be37886ffdad7dcf25ee81f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d356624a1c03363be37886ffdad7dcf25ee81f6", "html_url": "https://github.com/rust-lang/rust/commit/1d356624a1c03363be37886ffdad7dcf25ee81f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d356624a1c03363be37886ffdad7dcf25ee81f6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18a3db6aa1ce9e66b0c9cb776588d56470c6078b", "url": "https://api.github.com/repos/rust-lang/rust/commits/18a3db6aa1ce9e66b0c9cb776588d56470c6078b", "html_url": "https://github.com/rust-lang/rust/commit/18a3db6aa1ce9e66b0c9cb776588d56470c6078b"}], "stats": {"total": 436, "additions": 165, "deletions": 271}, "files": [{"sha": "a40913a5db2a2250e781aaf9facb52f57641a32c", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -1013,7 +1013,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                 if prefix_matches(line, prefixes[i].as_slice()) &&\n                     line.contains(ee.kind.as_slice()) &&\n                     line.contains(ee.msg.as_slice()) {\n-                    *found_flags.get_mut(i) = true;\n+                    found_flags[i] = true;\n                     was_expected = true;\n                     break;\n                 }"}, {"sha": "1b12fdcb8dc0406d70bbb79a22c2893155a45c52", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -243,7 +243,7 @@ impl Bitv {\n         let used_bits = bitv.nbits % u32::BITS;\n         if init && used_bits != 0 {\n             let largest_used_word = (bitv.nbits + u32::BITS - 1) / u32::BITS - 1;\n-            *bitv.storage.get_mut(largest_used_word) &= (1 << used_bits) - 1;\n+            bitv.storage[largest_used_word] &= (1 << used_bits) - 1;\n         }\n \n         bitv\n@@ -297,8 +297,9 @@ impl Bitv {\n         let w = i / u32::BITS;\n         let b = i % u32::BITS;\n         let flag = 1 << b;\n-        *self.storage.get_mut(w) = if x { self.storage[w] | flag }\n-                          else { self.storage[w] & !flag };\n+        let val = if x { self.storage[w] | flag }\n+                  else { self.storage[w] & !flag };\n+        self.storage[w] = val;\n     }\n \n     /// Sets all bits to 1.\n@@ -617,7 +618,7 @@ impl Bitv {\n             self.storage.truncate(word_len);\n             if len % u32::BITS > 0 {\n                 let mask = (1 << len % u32::BITS) - 1;\n-                *self.storage.get_mut(word_len - 1) &= mask;\n+                self.storage[word_len - 1] &= mask;\n             }\n         }\n     }\n@@ -681,15 +682,15 @@ impl Bitv {\n             let overhang = self.nbits % u32::BITS; // # of already-used bits\n             let mask = !((1 << overhang) - 1);  // e.g. 5 unused bits => 111110....0\n             if value {\n-                *self.storage.get_mut(old_last_word) |= mask;\n+                self.storage[old_last_word] |= mask;\n             } else {\n-                *self.storage.get_mut(old_last_word) &= !mask;\n+                self.storage[old_last_word] &= !mask;\n             }\n         }\n         // Fill in words after the old tail word\n         let stop_idx = cmp::min(self.storage.len(), new_nwords);\n         for idx in range(old_last_word + 1, stop_idx) {\n-            *self.storage.get_mut(idx) = full_value;\n+            self.storage[idx] = full_value;\n         }\n         // Allocate new words, if needed\n         if new_nwords > self.storage.len() {\n@@ -700,7 +701,7 @@ impl Bitv {\n             if value {\n                 let tail_word = new_nwords - 1;\n                 let used_bits = new_nbits % u32::BITS;\n-                *self.storage.get_mut(tail_word) &= (1 << used_bits) - 1;\n+                self.storage[tail_word] &= (1 << used_bits) - 1;\n             }\n         }\n         // Adjust internal bit count\n@@ -728,7 +729,7 @@ impl Bitv {\n         let ret = self.get(self.nbits - 1);\n         // If we are unusing a whole word, make sure it is zeroed out\n         if self.nbits % u32::BITS == 1 {\n-            *self.storage.get_mut(self.nbits / u32::BITS) = 0;\n+            self.storage[self.nbits / u32::BITS] = 0;\n         }\n         self.nbits -= 1;\n         ret\n@@ -1184,7 +1185,7 @@ impl BitvSet {\n         for (i, w) in other_words {\n             let old = self_bitv.storage[i];\n             let new = f(old, w);\n-            *self_bitv.storage.get_mut(i) = new;\n+            self_bitv.storage[i] = new;\n         }\n     }\n "}, {"sha": "dc7d935619f9ef08052cbf8c615fdc14510ebec5", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -690,6 +690,12 @@ impl<K: Ord, V> Index<K, V> for BTreeMap<K, V> {\n     }\n }\n \n+impl<K: Ord, V> IndexMut<K, V> for BTreeMap<K, V> {\n+    fn index_mut(&mut self, key: &K) -> &mut V {\n+        self.find_mut(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n /// Genericises over how to get the correct type of iterator from the correct type\n /// of Node ownership.\n trait Traverse<N> {"}, {"sha": "fbadbb0ffc90b804fbcfd309b80aa8bac700e26b", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -71,7 +71,7 @@\n //!     let mut pq = PriorityQueue::new();\n //!\n //!     // We're at `start`, with a zero cost\n-//!     *dist.get_mut(start) = 0u;\n+//!     dist[start] = 0u;\n //!     pq.push(State { cost: 0u, position: start });\n //!\n //!     // Examine the frontier with lower cost nodes first (min-heap)\n@@ -96,7 +96,7 @@\n //!             if next.cost < dist[next.position] {\n //!                 pq.push(next);\n //!                 // Relaxation, we have now found a better way\n-//!                 *dist.get_mut(next.position) = next.cost;\n+//!                 dist[next.position] = next.cost;\n //!             }\n //!         }\n //!     }\n@@ -330,7 +330,7 @@ impl<T: Ord> PriorityQueue<T> {\n             None           => { None }\n             Some(mut item) => {\n                 if !self.is_empty() {\n-                    swap(&mut item, self.data.get_mut(0));\n+                    swap(&mut item, &mut self.data[0]);\n                     self.siftdown(0);\n                 }\n                 Some(item)\n@@ -378,7 +378,7 @@ impl<T: Ord> PriorityQueue<T> {\n     /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         if !self.is_empty() && *self.top().unwrap() > item {\n-            swap(&mut item, self.data.get_mut(0));\n+            swap(&mut item, &mut self.data[0]);\n             self.siftdown(0);\n         }\n         item\n@@ -402,7 +402,7 @@ impl<T: Ord> PriorityQueue<T> {\n     /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n-            swap(&mut item, self.data.get_mut(0));\n+            swap(&mut item, &mut self.data[0]);\n             self.siftdown(0);\n             Some(item)\n         } else {\n@@ -462,40 +462,40 @@ impl<T: Ord> PriorityQueue<T> {\n     // compared to using swaps, which involves twice as many moves.\n     fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n-            let new = replace(self.data.get_mut(pos), zeroed());\n+            let new = replace(&mut self.data[pos], zeroed());\n \n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n                 if new > self.data[parent] {\n-                    let x = replace(self.data.get_mut(parent), zeroed());\n-                    ptr::write(self.data.get_mut(pos), x);\n+                    let x = replace(&mut self.data[parent], zeroed());\n+                    ptr::write(&mut self.data[pos], x);\n                     pos = parent;\n                     continue\n                 }\n                 break\n             }\n-            ptr::write(self.data.get_mut(pos), new);\n+            ptr::write(&mut self.data[pos], new);\n         }\n     }\n \n     fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n-            let new = replace(self.data.get_mut(pos), zeroed());\n+            let new = replace(&mut self.data[pos], zeroed());\n \n             let mut child = 2 * pos + 1;\n             while child < end {\n                 let right = child + 1;\n                 if right < end && !(self.data[child] > self.data[right]) {\n                     child = right;\n                 }\n-                let x = replace(self.data.get_mut(child), zeroed());\n-                ptr::write(self.data.get_mut(pos), x);\n+                let x = replace(&mut self.data[child], zeroed());\n+                ptr::write(&mut self.data[pos], x);\n                 pos = child;\n                 child = 2 * pos + 1;\n             }\n \n-            ptr::write(self.data.get_mut(pos), new);\n+            ptr::write(&mut self.data[pos], new);\n             self.siftup(start, pos);\n         }\n     }"}, {"sha": "81e4361ec39493907ab075484f69dbe2529fa73e", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -58,7 +58,7 @@ impl<T> Deque<T> for RingBuf<T> {\n \n     /// Returns a mutable reference to the first element in the `RingBuf`.\n     fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        if self.nelts > 0 { Some(self.get_mut(0)) } else { None }\n+        if self.nelts > 0 { Some(&mut self[0]) } else { None }\n     }\n \n     /// Returns a reference to the last element in the `RingBuf`.\n@@ -69,13 +69,13 @@ impl<T> Deque<T> for RingBuf<T> {\n     /// Returns a mutable reference to the last element in the `RingBuf`.\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n         let nelts = self.nelts;\n-        if nelts > 0 { Some(self.get_mut(nelts - 1)) } else { None }\n+        if nelts > 0 { Some(&mut self[nelts - 1]) } else { None }\n     }\n \n     /// Removes and returns the first element in the `RingBuf`, or `None` if it\n     /// is empty.\n     fn pop_front(&mut self) -> Option<T> {\n-        let result = self.elts.get_mut(self.lo).take();\n+        let result = self.elts[self.lo].take();\n         if result.is_some() {\n             self.lo = (self.lo + 1u) % self.elts.len();\n             self.nelts -= 1u;\n@@ -91,7 +91,7 @@ impl<T> Deque<T> for RingBuf<T> {\n         if self.lo == 0u {\n             self.lo = self.elts.len() - 1u;\n         } else { self.lo -= 1u; }\n-        *self.elts.get_mut(self.lo) = Some(t);\n+        self.elts[self.lo] = Some(t);\n         self.nelts += 1u;\n     }\n }\n@@ -102,14 +102,14 @@ impl<T> MutableSeq<T> for RingBuf<T> {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n         let hi = self.raw_index(self.nelts);\n-        *self.elts.get_mut(hi) = Some(t);\n+        self.elts[hi] = Some(t);\n         self.nelts += 1u;\n     }\n     fn pop(&mut self) -> Option<T> {\n         if self.nelts > 0 {\n             self.nelts -= 1;\n             let hi = self.raw_index(self.nelts);\n-            self.elts.get_mut(hi).take()\n+            self.elts[hi].take()\n         } else {\n             None\n         }\n@@ -140,6 +140,7 @@ impl<T> RingBuf<T> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n@@ -149,12 +150,9 @@ impl<T> RingBuf<T> {\n     /// *buf.get_mut(1) = 7;\n     /// assert_eq!(buf[1], 7);\n     /// ```\n+    #[deprecated = \"use indexing instead: `buf[index] = value`\"]\n     pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n-        let idx = self.raw_index(i);\n-        match *self.elts.get_mut(idx) {\n-            None => panic!(),\n-            Some(ref mut v) => v\n-        }\n+        &mut self[i]\n     }\n \n     /// Swaps elements at indices `i` and `j`.\n@@ -466,13 +464,16 @@ impl<A> Index<uint, A> for RingBuf<A> {\n     }\n }\n \n-// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n-/*impl<A> IndexMut<uint, A> for RingBuf<A> {\n+impl<A> IndexMut<uint, A> for RingBuf<A> {\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut A {\n-        self.get_mut(*index)\n+    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut A {\n+        let idx = self.raw_index(*i);\n+        match *(&mut self.elts[idx]) {\n+            None => panic!(),\n+            Some(ref mut v) => v\n+        }\n     }\n-}*/\n+}\n \n impl<A> FromIterator<A> for RingBuf<A> {\n     fn from_iter<T: Iterator<A>>(iterator: T) -> RingBuf<A> {"}, {"sha": "22bb4574f9cc4345e3417bd73b820edfb794a2dc", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -100,7 +100,7 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n     /// Returns a mutable reference to the value corresponding to the key.\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n         if *key < self.v.len() {\n-            match *self.v.get_mut(*key) {\n+            match *self.v.index_mut(key) {\n               Some(ref mut value) => Some(value),\n               None => None\n             }\n@@ -118,7 +118,7 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n         if len <= key {\n             self.v.grow_fn(key - len + 1, |_| None);\n         }\n-        *self.v.get_mut(key) = Some(value);\n+        self.v[key] = Some(value);\n         !exists\n     }\n \n@@ -145,7 +145,7 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n         if *key >= self.v.len() {\n             return None;\n         }\n-        self.v.get_mut(*key).take()\n+        self.v[*key].take()\n     }\n }\n \n@@ -405,13 +405,12 @@ impl<V> Index<uint, V> for SmallIntMap<V> {\n     }\n }\n \n-// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n-/*impl<V> IndexMut<uint, V> for SmallIntMap<V> {\n+impl<V> IndexMut<uint, V> for SmallIntMap<V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n         self.find_mut(i).expect(\"key not present\")\n     }\n-}*/\n+}\n \n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {"}, {"sha": "7d882ae53839fcbebdecaf485158a94b21bceba3", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -692,17 +692,17 @@ pub trait StrAllocating: Str {\n         for (i, sc) in me.chars().enumerate() {\n \n             let mut current = i;\n-            *dcol.get_mut(0) = current + 1;\n+            dcol[0] = current + 1;\n \n             for (j, tc) in t.chars().enumerate() {\n \n                 let next = dcol[j + 1];\n \n                 if sc == tc {\n-                    *dcol.get_mut(j + 1) = current;\n+                    dcol[j + 1] = current;\n                 } else {\n-                    *dcol.get_mut(j + 1) = cmp::min(current, next);\n-                    *dcol.get_mut(j + 1) = cmp::min(dcol[j + 1], dcol[j]) + 1;\n+                    dcol[j + 1] = cmp::min(current, next);\n+                    dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n                 }\n \n                 current = next;"}, {"sha": "ea4d541aab94a1f1b30ab4be851b6d63aae20003", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -257,12 +257,12 @@ impl<K: Ord, V> Index<K, V> for TreeMap<K, V> {\n     }\n }\n \n-/*impl<K: Ord, V> IndexMut<K, V> for TreeMap<K, V> {\n+impl<K: Ord, V> IndexMut<K, V> for TreeMap<K, V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &K) -> &'a mut V {\n         self.find_mut(i).expect(\"no entry found for key\")\n     }\n-}*/\n+}\n \n impl<K: Ord, V> TreeMap<K, V> {\n     /// Creates an empty `TreeMap`."}, {"sha": "8c18a6488ba50bb34b1004d56e09311a93c2db4b", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -515,13 +515,12 @@ impl<T> Index<uint, T> for TrieMap<T> {\n     }\n }\n \n-// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n-/*impl<T> IndexMut<uint, T> for TrieMap<T> {\n+impl<T> IndexMut<uint, T> for TrieMap<T> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut T {\n         self.find_mut(i).expect(\"key not present\")\n     }\n-}*/\n+}\n \n /// A set implemented as a radix trie.\n ///"}, {"sha": "ea03873ee83823fff16bbeca1708b2402a44b670", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -46,7 +46,7 @@ use slice::{Items, MutItems};\n /// assert_eq!(vec.pop(), Some(2));\n /// assert_eq!(vec.len(), 1);\n ///\n-/// *vec.get_mut(0) = 7i;\n+/// vec[0] = 7i;\n /// assert_eq!(vec[0], 7);\n ///\n /// vec.push_all([1, 2, 3]);\n@@ -414,11 +414,10 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<T> IndexMut<uint,T> for Vec<T> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n-        self.get_mut(*index)\n+        &mut self.as_mut_slice()[*index]\n     }\n }\n \n@@ -712,14 +711,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Deprecated, use `.extend(other.into_iter())`\n-    #[inline]\n-    #[deprecated = \"use .extend(other.into_iter())\"]\n-    #[cfg(stage0)]\n-    pub fn push_all_move(&mut self, other: Vec<T>) {\n-            self.extend(other.into_iter());\n-    }\n-\n     /// Returns a mutable slice of the elements of `self`.\n     ///\n     /// # Example\n@@ -799,12 +790,13 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut vec = vec![1i, 2, 3];\n     /// *vec.get_mut(1) = 4;\n     /// assert_eq!(vec, vec![1i, 4, 3]);\n     /// ```\n     #[inline]\n-    #[unstable = \"this is likely to be moved to actual indexing\"]\n+    #[deprecated = \"use `foo[index] = bar` instead\"]\n     pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n         &mut self.as_mut_slice()[index]\n     }"}, {"sha": "cd0b72d50c9fe3a26b96858307600248c62cce25", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -57,107 +57,10 @@ pub struct TyDesc {\n     // Called when a value of type `T` is no longer needed\n     pub drop_glue: GlueFn,\n \n-    // Called by reflection visitor to visit a value of type `T`\n-    #[cfg(stage0)]\n-    pub visit_glue: GlueFn,\n-\n     // Name corresponding to the type\n     pub name: &'static str,\n }\n \n-#[cfg(stage0)]\n-#[lang=\"opaque\"]\n-pub enum Opaque { }\n-\n-#[cfg(stage0)]\n-pub type Disr = u64;\n-\n-#[cfg(stage0)]\n-#[lang=\"ty_visitor\"]\n-pub trait TyVisitor {\n-    fn visit_bot(&mut self) -> bool;\n-    fn visit_nil(&mut self) -> bool;\n-    fn visit_bool(&mut self) -> bool;\n-\n-    fn visit_int(&mut self) -> bool;\n-    fn visit_i8(&mut self) -> bool;\n-    fn visit_i16(&mut self) -> bool;\n-    fn visit_i32(&mut self) -> bool;\n-    fn visit_i64(&mut self) -> bool;\n-\n-    fn visit_uint(&mut self) -> bool;\n-    fn visit_u8(&mut self) -> bool;\n-    fn visit_u16(&mut self) -> bool;\n-    fn visit_u32(&mut self) -> bool;\n-    fn visit_u64(&mut self) -> bool;\n-\n-    fn visit_f32(&mut self) -> bool;\n-    fn visit_f64(&mut self) -> bool;\n-\n-    fn visit_char(&mut self) -> bool;\n-\n-    fn visit_estr_slice(&mut self) -> bool;\n-\n-    fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_uniq(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_ptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n-\n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        inner: *const TyDesc) -> bool;\n-\n-    fn visit_enter_rec(&mut self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-    fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_leave_rec(&mut self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n-                         sz: uint, align: uint) -> bool;\n-    fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         mtbl: uint, inner: *const TyDesc) -> bool;\n-    fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n-                         sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_tup(&mut self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool;\n-    fn visit_leave_tup(&mut self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n-                        sz: uint, align: uint) -> bool;\n-    fn visit_enter_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool;\n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint,\n-                                inner: *const TyDesc) -> bool;\n-    fn visit_leave_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool;\n-    fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n-                        sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool;\n-    fn visit_fn_input(&mut self, i: uint, mode: uint,\n-                      inner: *const TyDesc) -> bool;\n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool,\n-                       converging: bool, inner: *const TyDesc) -> bool;\n-    fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool;\n-\n-    fn visit_trait(&mut self, name: &str) -> bool;\n-    fn visit_param(&mut self, i: uint) -> bool;\n-    fn visit_self(&mut self) -> bool;\n-}\n-\n extern \"rust-intrinsic\" {\n \n     // NB: These intrinsics take unsafe pointers because they mutate aliased"}, {"sha": "12851713af25449f28445a98c5dc06f036a6ef8b", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -614,29 +614,29 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     if name_pos == names.len() && !i_arg.is_none() {\n                         return Err(UnexpectedArgument(nm.to_string()));\n                     }\n-                    vals.get_mut(optid).push(Given);\n+                    vals[optid].push(Given);\n                   }\n                   Maybe => {\n                     if !i_arg.is_none() {\n-                        vals.get_mut(optid)\n+                        vals[optid]\n                             .push(Val((i_arg.clone())\n                             .unwrap()));\n                     } else if name_pos < names.len() || i + 1 == l ||\n                             is_arg(args[i + 1].as_slice()) {\n-                        vals.get_mut(optid).push(Given);\n+                        vals[optid].push(Given);\n                     } else {\n                         i += 1;\n-                        vals.get_mut(optid).push(Val(args[i].clone()));\n+                        vals[optid].push(Val(args[i].clone()));\n                     }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n-                        vals.get_mut(optid).push(Val(i_arg.clone().unwrap()));\n+                        vals[optid].push(Val(i_arg.clone().unwrap()));\n                     } else if i + 1 == l {\n                         return Err(ArgumentMissing(nm.to_string()));\n                     } else {\n                         i += 1;\n-                        vals.get_mut(optid).push(Val(args[i].clone()));\n+                        vals[optid].push(Val(args[i].clone()));\n                     }\n                   }\n                 }"}, {"sha": "2b82b620e3968da2a9115881a29ffce1527121fd", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -157,7 +157,7 @@ impl<'r> Compiler<'r> {\n                 if cap >= len {\n                     self.names.grow(10 + cap - len, None)\n                 }\n-                *self.names.get_mut(cap) = name;\n+                self.names[cap] = name;\n \n                 self.push(Save(2 * cap));\n                 self.compile(*x);\n@@ -243,7 +243,7 @@ impl<'r> Compiler<'r> {\n     /// `panic!` is called.\n     #[inline]\n     fn set_split(&mut self, i: InstIdx, pc1: InstIdx, pc2: InstIdx) {\n-        let split = self.insts.get_mut(i);\n+        let split = &mut self.insts[i];\n         match *split {\n             Split(_, _) => *split = Split(pc1, pc2),\n             _ => panic!(\"BUG: Invalid split index.\"),\n@@ -263,7 +263,7 @@ impl<'r> Compiler<'r> {\n     /// `panic!` is called.\n     #[inline]\n     fn set_jump(&mut self, i: InstIdx, pc: InstIdx) {\n-        let jmp = self.insts.get_mut(i);\n+        let jmp = &mut self.insts[i];\n         match *jmp {\n             Jump(_) => *jmp = Jump(pc),\n             _ => panic!(\"BUG: Invalid jump index.\"),"}, {"sha": "3115161682f02b192f11d988478a9297e8555dbf", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -978,7 +978,7 @@ fn combine_ranges(unordered: Vec<(char, char)>) -> Vec<(char, char)> {\n         }\n         match which {\n             None => ordered.push((us, ue)),\n-            Some(i) => *ordered.get_mut(i) = (us, ue),\n+            Some(i) => ordered[i] = (us, ue),\n         }\n     }\n     ordered.sort();"}, {"sha": "ce06828e7643fbc6b7e54c7ff3476aa7f9a9c0dd", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -461,21 +461,21 @@ impl Threads {\n     }\n \n     fn add(&mut self, pc: uint, groups: &[Option<uint>], empty: bool) {\n-        let t = self.queue.get_mut(self.size);\n+        let t = &mut self.queue[self.size];\n         t.pc = pc;\n         match (empty, self.which) {\n             (_, Exists) | (true, _) => {},\n             (false, Location) => {\n-                *t.groups.get_mut(0) = groups[0];\n-                *t.groups.get_mut(1) = groups[1];\n+                t.groups[0] = groups[0];\n+                t.groups[1] = groups[1];\n             }\n             (false, Submatches) => {\n                 for (slot, val) in t.groups.iter_mut().zip(groups.iter()) {\n                     *slot = *val;\n                 }\n             }\n         }\n-        *self.sparse.get_mut(pc) = self.size;\n+        self.sparse[pc] = self.size;\n         self.size += 1;\n     }\n \n@@ -497,7 +497,7 @@ impl Threads {\n \n     #[inline]\n     fn groups<'r>(&'r mut self, i: uint) -> &'r mut [Option<uint>] {\n-        self.queue.get_mut(i).groups.as_mut_slice()\n+        self.queue[i].groups.as_mut_slice()\n     }\n }\n "}, {"sha": "6f5d5f6925cae69b6e9b36268ceefd52a98820fb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -1619,7 +1619,7 @@ fn encode_index<T: Hash>(rbml_w: &mut Encoder, index: Vec<entry<T>>,\n     let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n     for elt in index.into_iter() {\n         let h = hash::hash(&elt.val) as uint;\n-        buckets.get_mut(h % 256).push(elt);\n+        buckets[h % 256].push(elt);\n     }\n \n     rbml_w.start_tag(tag_index);"}, {"sha": "dbdac39a6aa2ec04c5157ec8dddc80611bac3285", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -214,13 +214,13 @@ impl MoveData {\n     fn set_path_first_move(&self,\n                            index: MovePathIndex,\n                            first_move: MoveIndex) {\n-        self.paths.borrow_mut().get_mut(index.get()).first_move = first_move\n+        (*self.paths.borrow_mut())[index.get()].first_move = first_move\n     }\n \n     fn set_path_first_child(&self,\n                             index: MovePathIndex,\n                             first_child: MovePathIndex) {\n-        self.paths.borrow_mut().get_mut(index.get()).first_child = first_child\n+        (*self.paths.borrow_mut())[index.get()].first_child = first_child\n     }\n \n     fn move_next_move(&self, index: MoveIndex) -> MoveIndex {"}, {"sha": "3baa8eb0cc0400c6a64a30b54cb8aed0a6fe1309", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -161,7 +161,7 @@ fn calculate_type(sess: &session::Session,\n         if src.dylib.is_none() && !formats.contains_key(&cnum) {\n             assert!(src.rlib.is_some());\n             add_library(sess, cnum, cstore::RequireStatic, &mut formats);\n-            *ret.get_mut(cnum as uint - 1) = Some(cstore::RequireStatic);\n+            ret[cnum as uint - 1] = Some(cstore::RequireStatic);\n             debug!(\"adding staticlib: {}\", data.name);\n         }\n     });"}, {"sha": "783b94238e251c9305be188f9fdd9115c115ef82", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -142,7 +142,7 @@ impl<N,E> Graph<N,E> {\n     }\n \n     pub fn mut_node_data<'a>(&'a mut self, idx: NodeIndex) -> &'a mut N {\n-        &mut self.nodes.get_mut(idx.get()).data\n+        &mut self.nodes[idx.get()].data\n     }\n \n     pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n@@ -182,14 +182,14 @@ impl<N,E> Graph<N,E> {\n         });\n \n         // adjust the firsts for each node target be the next object.\n-        self.nodes.get_mut(source.get()).first_edge[Outgoing.repr] = idx;\n-        self.nodes.get_mut(target.get()).first_edge[Incoming.repr] = idx;\n+        self.nodes[source.get()].first_edge[Outgoing.repr] = idx;\n+        self.nodes[target.get()].first_edge[Incoming.repr] = idx;\n \n         return idx;\n     }\n \n     pub fn mut_edge_data<'a>(&'a mut self, idx: EdgeIndex) -> &'a mut E {\n-        &mut self.edges.get_mut(idx.get()).data\n+        &mut self.edges[idx.get()].data\n     }\n \n     pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {"}, {"sha": "80eba56ea6ce0290529c219abae228b987fafa3c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -756,7 +756,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n-        *self.successors.get_mut(ln.get()) = succ_ln;\n+        self.successors[ln.get()] = succ_ln;\n \n         // It is not necessary to initialize the\n         // values to empty because this is the value\n@@ -770,10 +770,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n-        *self.successors.get_mut(ln.get()) = succ_ln;\n+        self.successors[ln.get()] = succ_ln;\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            *this.users.get_mut(idx) = this.users[succ_idx]\n+            this.users[idx] = this.users[succ_idx]\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n@@ -789,11 +789,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut changed = false;\n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n             changed |= copy_if_invalid(this.users[succ_idx].reader,\n-                                       &mut this.users.get_mut(idx).reader);\n+                                       &mut this.users[idx].reader);\n             changed |= copy_if_invalid(this.users[succ_idx].writer,\n-                                       &mut this.users.get_mut(idx).writer);\n+                                       &mut this.users[idx].writer);\n             if this.users[succ_idx].used && !this.users[idx].used {\n-                this.users.get_mut(idx).used = true;\n+                this.users[idx].used = true;\n                 changed = true;\n             }\n         });\n@@ -817,8 +817,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     // this) so we just clear out all the data.\n     fn define(&mut self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n-        self.users.get_mut(idx).reader = invalid_node();\n-        self.users.get_mut(idx).writer = invalid_node();\n+        self.users[idx].reader = invalid_node();\n+        self.users[idx].writer = invalid_node();\n \n         debug!(\"{} defines {} (idx={}): {}\", writer.to_string(), var.to_string(),\n                idx, self.ln_str(writer));\n@@ -830,7 +830,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                ln.to_string(), acc, var.to_string(), self.ln_str(ln));\n \n         let idx = self.idx(ln, var);\n-        let user = self.users.get_mut(idx);\n+        let user = &mut self.users[idx];\n \n         if (acc & ACC_WRITE) != 0 {\n             user.reader = invalid_node();"}, {"sha": "63b5e52f8b8088b6610f03c41bb10cf580d63bb6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -2596,7 +2596,7 @@ impl<'a> Resolver<'a> {\n \n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let import_resolution = import_resolutions.get_mut(&target);\n+        let import_resolution = &mut (*import_resolutions)[target];\n \n         match value_result {\n             BoundResult(ref target_module, ref name_bindings) => {\n@@ -5697,7 +5697,7 @@ impl<'a> Resolver<'a> {\n \n         let mut smallest = 0;\n         for (i, other) in maybes.iter().enumerate() {\n-            *values.get_mut(i) = name.lev_distance(other.get());\n+            values[i] = name.lev_distance(other.get());\n \n             if values[i] <= values[smallest] {\n                 smallest = i;"}, {"sha": "70aef4504f031c1e1602ab9f6338698e0bb18a8a", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -403,7 +403,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         let mut pats = br.pats.clone();\n-        *pats.get_mut(col) = pat;\n+        pats[col] = pat;\n         Match {\n             pats: pats,\n             data: &*br.data,"}, {"sha": "5a4979d9dcd5e67a85c22e393f92a3fe325df88c", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -469,7 +469,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         assert!(self.is_valid_custom_scope(custom_scope));\n \n         let mut scopes = self.scopes.borrow_mut();\n-        let scope = scopes.get_mut(custom_scope.index);\n+        let scope = &mut (*scopes)[custom_scope.index];\n         scope.cleanups.push(cleanup);\n         scope.clear_cached_exits();\n     }"}, {"sha": "24c03cb5d422c3c9c0ed6321f2273e74b4367292", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -1331,7 +1331,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           field_ty.name == field.ident.node.name);\n             match opt_pos {\n                 Some(i) => {\n-                    *need_base.get_mut(i) = false;\n+                    need_base[i] = false;\n                     (i, &*field.expr)\n                 }\n                 None => {"}, {"sha": "d53fb8dfcf1bc9c22ef725fc5458ae0cf923bba4", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -284,7 +284,7 @@ impl Type {\n                 return Vec::new();\n             }\n             let mut elts = Vec::from_elem(n_elts, 0 as TypeRef);\n-            llvm::LLVMGetStructElementTypes(self.to_ref(), elts.get_mut(0));\n+            llvm::LLVMGetStructElementTypes(self.to_ref(), &mut elts[0]);\n             mem::transmute(elts)\n         }\n     }"}, {"sha": "6ae1bc82bb4153c59f22cd722713e8f00ba0ff51", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -650,7 +650,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     ByValueExplicitSelfCategory => {\n                         let mut n = (*m).clone();\n                         let self_ty = n.fty.sig.inputs[0];\n-                        *n.fty.sig.inputs.get_mut(0) = ty::mk_uniq(tcx, self_ty);\n+                        n.fty.sig.inputs[0] = ty::mk_uniq(tcx, self_ty);\n                         m = Rc::new(n);\n                     }\n                     _ => { }"}, {"sha": "4d4ac1149375110d8566631b387aaf9ca97171a7", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -5455,7 +5455,7 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n             match ty::get(t).sty {\n                 ty::ty_param(ParamTy {idx, ..}) => {\n                     debug!(\"Found use of ty param num {}\", idx);\n-                    *tps_used.get_mut(idx) = true;\n+                    tps_used[idx] = true;\n                 }\n                 _ => ()\n             }"}, {"sha": "d0338333badee30a46a950d3ef4163817823ef85", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -1757,7 +1757,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n                         // is inferred to mutable if necessary\n                         let mut upvar_borrow_map =\n                             rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                        let ub = upvar_borrow_map.get_mut(upvar_id);\n+                        let ub = &mut (*upvar_borrow_map)[*upvar_id];\n                         return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::MutBorrow);\n                     }\n \n@@ -1807,7 +1807,7 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n                         // borrow_kind of the upvar to make sure it\n                         // is inferred to unique if necessary\n                         let mut ub = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                        let ub = ub.get_mut(upvar_id);\n+                        let ub = &mut (*ub)[*upvar_id];\n                         return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::UniqueImmBorrow);\n                     }\n "}, {"sha": "ff1ded726c566a631a66fd2869e567acc310ad82", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -261,7 +261,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         if snapshot.length == 0 {\n             undo_log.truncate(0);\n         } else {\n-            *undo_log.get_mut(snapshot.length) = CommitedSnapshot;\n+            (*undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n     }\n "}, {"sha": "1383f7aa4dc982558c0759399789cb653ba66326", "filename": "src/librustc/middle/typeck/infer/type_variable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -159,12 +159,12 @@ impl sv::SnapshotVecDelegate<TypeVariableData,UndoEntry> for Delegate {\n                action: UndoEntry) {\n         match action {\n             SpecifyVar(vid, relations) => {\n-                values.get_mut(vid.index).value = Bounded(relations);\n+                values[vid.index].value = Bounded(relations);\n             }\n \n             Relate(a, b) => {\n-                relations(values.get_mut(a.index)).pop();\n-                relations(values.get_mut(b.index)).pop();\n+                relations(&mut (*values)[a.index]).pop();\n+                relations(&mut (*values)[b.index]).pop();\n             }\n         }\n     }"}, {"sha": "21bd876a5c9761a9f89e0756e57a4c8855153c25", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -994,7 +994,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                             new_value,\n                             term.to_string());\n \n-                    *self.solutions.get_mut(inferred) = new_value;\n+                    self.solutions[inferred] = new_value;\n                     changed = true;\n                 }\n             }"}, {"sha": "6d99fc7156ca8f1f9be0fa1618b227868d8b24fc", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -105,7 +105,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n          * action.\n          */\n \n-        self.values.get_mut(index)\n+        &mut self.values[index]\n     }\n \n     pub fn set(&mut self, index: uint, new_elem: T) {\n@@ -114,7 +114,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n          * saved (and perhaps restored) if a snapshot is active.\n          */\n \n-        let old_elem = mem::replace(self.values.get_mut(index), new_elem);\n+        let old_elem = mem::replace(&mut self.values[index], new_elem);\n         if self.in_snapshot() {\n             self.undo_log.push(SetElem(index, old_elem));\n         }\n@@ -162,7 +162,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n                 }\n \n                 SetElem(i, v) => {\n-                    *self.values.get_mut(i) = v;\n+                    self.values[i] = v;\n                 }\n \n                 Other(u) => {\n@@ -189,7 +189,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n             // The root snapshot.\n             self.undo_log.truncate(0);\n         } else {\n-            *self.undo_log.get_mut(snapshot.length) = CommittedSnapshot;\n+            self.undo_log[snapshot.length] = CommittedSnapshot;\n         }\n     }\n }"}, {"sha": "dc14a993016f94b3f1d870a3ad2abdbca01d641c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -1231,7 +1231,7 @@ impl Stack {\n             InternalIndex(i) => { i + 1 }\n             _ => { panic!(); }\n         };\n-        *self.stack.get_mut(len - 1) = InternalIndex(idx);\n+        self.stack[len - 1] = InternalIndex(idx);\n     }\n }\n "}, {"sha": "cb47c28f8bef2643bb81ddaa607a5e253d8c926d", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -14,19 +14,14 @@ use clone::Clone;\n use cmp::{max, Eq, Equiv, PartialEq};\n use collections::{Collection, Mutable, MutableSet, Map, MutableMap};\n use default::Default;\n-use fmt::Show;\n-use fmt;\n+use fmt::{mod, Show};\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{Iterator, FromIterator, Extendable};\n-use iter;\n-use mem::replace;\n-use mem;\n+use iter::{mod, Iterator, FromIterator, Extendable};\n+use mem::{mod, replace};\n use num;\n-use ops::Deref;\n+use ops::{Deref, Index, IndexMut};\n use option::{Some, None, Option};\n-use result::{Ok, Err};\n-use ops::Index;\n-use core::result::Result;\n+use result::{Result, Ok, Err};\n \n use super::table;\n use super::table::{\n@@ -837,6 +832,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n@@ -852,11 +848,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// *map.get_mut(&\"a\") = -2;\n     /// assert_eq!(map[\"a\"], -2);\n     /// ```\n+    #[deprecated = \"use indexing instead: `&mut map[key]`\"]\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n-        match self.find_mut(k) {\n-            Some(v) => v,\n-            None => panic!(\"no entry found for key\")\n-        }\n+        &mut self[*k]\n     }\n \n     /// Return true if the map contains a value for the specified key,\n@@ -1194,13 +1188,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n     }\n }\n \n-// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n-/*impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> ops::IndexMut<K, V> for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> IndexMut<K, V> for HashMap<K, V, H> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &K) -> &'a mut V {\n-        self.get_mut(index)\n+        match self.find_mut(index) {\n+            Some(v) => v,\n+            None => panic!(\"no entry found for key\")\n+        }\n     }\n-}*/\n+}\n \n /// HashMap iterator\n pub struct Entries<'a, K: 'a, V: 'a> {"}, {"sha": "f193ce8cffacb3a9cb29f2c397789a0b3f5d5f49", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -963,7 +963,7 @@ mod test {\n \n     macro_rules! error( ($e:expr, $s:expr) => (\n         match $e {\n-            Ok(val) => panic!(\"Unexpected success. Should've been: {}\", $s),\n+            Ok(_) => panic!(\"Unexpected success. Should've been: {}\", $s),\n             Err(ref err) => assert!(err.to_string().as_slice().contains($s.as_slice()),\n                                     format!(\"`{}` did not contain `{}`\", err, $s))\n         }"}, {"sha": "f79cda0195e4dd690b5bba8a70b852f069e33ee9", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -424,10 +424,10 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                     // or set to 0 if max and carry the 1.\n                     let current_digit = ascii2value(buf[i as uint]);\n                     if current_digit < (radix - 1) {\n-                        *buf.get_mut(i as uint) = value2ascii(current_digit+1);\n+                        buf[i as uint] = value2ascii(current_digit+1);\n                         break;\n                     } else {\n-                        *buf.get_mut(i as uint) = value2ascii(0);\n+                        buf[i as uint] = value2ascii(0);\n                         i -= 1;\n                     }\n                 }"}, {"sha": "1ddc027a07eab3f331b6840d80a1cc19de600c67", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -776,15 +776,15 @@ impl Path {\n                                 let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    *v.get_mut(0) = (*v)[0]\n+                                    v[0] = (*v)[0]\n                                                      .to_ascii()\n                                                      .to_uppercase()\n                                                      .to_byte();\n                                 }\n                                 if is_abs {\n                                     // normalize C:/ to C:\\\n                                     unsafe {\n-                                        *s.as_mut_vec().get_mut(2) = SEP_BYTE;\n+                                        s.as_mut_vec()[2] = SEP_BYTE;\n                                     }\n                                 }\n                                 Some(s)\n@@ -794,7 +794,7 @@ impl Path {\n                                 let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    *v.get_mut(4) = (*v)[4].to_ascii().to_uppercase().to_byte();\n+                                    v[4] = (*v)[4].to_ascii().to_uppercase().to_byte();\n                                 }\n                                 Some(s)\n                             }"}, {"sha": "21e531d211a85076fee0fd0fcae727a82ca4df7f", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -411,7 +411,7 @@ pub fn sample<T, I: Iterator<T>, R: Rng>(rng: &mut R,\n     for (i, elem) in iter.enumerate() {\n         let k = rng.gen_range(0, i + 1 + amount);\n         if k < amount {\n-            *reservoir.get_mut(k) = elem;\n+            reservoir[k] = elem;\n         }\n     }\n     return reservoir;"}, {"sha": "42de6f66289a205a7b6fd5b6967ce8b49ad8984b", "filename": "src/libsync/comm/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsync%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsync%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fsync.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -426,15 +426,15 @@ impl<T> Buffer<T> {\n     fn enqueue(&mut self, t: T) {\n         let pos = (self.start + self.size) % self.buf.len();\n         self.size += 1;\n-        let prev = mem::replace(self.buf.get_mut(pos), Some(t));\n+        let prev = mem::replace(&mut self.buf[pos], Some(t));\n         assert!(prev.is_none());\n     }\n \n     fn dequeue(&mut self) -> T {\n         let start = self.start;\n         self.size -= 1;\n         self.start = (self.start + 1) % self.buf.len();\n-        self.buf.get_mut(start).take().unwrap()\n+        self.buf[start].take().unwrap()\n     }\n \n     fn size(&self) -> uint { self.size }"}, {"sha": "1410091b924ba97e7c8eb1435161b3e684c0fe21", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -308,7 +308,7 @@ impl<'a> Condvar<'a> {\n                     // To avoid :broadcast_heavy, we make a new waitqueue,\n                     // swap it out with the old one, and broadcast on the\n                     // old one outside of the little-lock.\n-                    queue = Some(mem::replace(state.blocked.get_mut(condvar_id),\n+                    queue = Some(mem::replace(&mut state.blocked[condvar_id],\n                                               WaitQueue::new()));\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());"}, {"sha": "fa36577ebdb1f5978ceeb1620224e15019cbb9ad", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -712,7 +712,7 @@ impl<'ast> NodeCollector<'ast> {\n         if id as uint >= len {\n             self.map.grow(id as uint - len + 1, NotPresent);\n         }\n-        *self.map.get_mut(id as uint) = entry;\n+        self.map[id as uint] = entry;\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {"}, {"sha": "e641abbfeee64763f7eb8a0cfd8f2585b075039a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -785,6 +785,6 @@ impl SyntaxEnv {\n \n     pub fn info<'a>(&'a mut self) -> &'a mut BlockInfo {\n         let last_chain_index = self.chain.len() - 1;\n-        &mut self.chain.get_mut(last_chain_index).info\n+        &mut self.chain[last_chain_index].info\n     }\n }"}, {"sha": "fa9a844233a199d79f72deee0f25dd196f843310", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -247,7 +247,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.verify_same(self.args[arg].span, &ty, arg_type);\n                 }\n                 if self.arg_types[arg].is_none() {\n-                    *self.arg_types.get_mut(arg) = Some(ty);\n+                    self.arg_types[arg] = Some(ty);\n                 }\n             }\n \n@@ -567,7 +567,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let lname = self.ecx.ident_of(format!(\"__arg{}\",\n                                                   *name).as_slice());\n             pats.push(self.ecx.pat_ident(e.span, lname));\n-            *names.get_mut(self.name_positions[*name]) =\n+            names[self.name_positions[*name]] =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n                                          self.ecx.expr_ident(e.span, lname)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));"}, {"sha": "4de2042014843c224676c354578d47c57db48bb5", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -288,8 +288,7 @@ pub fn parse(sess: &ParseSess,\n                         // Only touch the binders we have actually bound\n                         for idx in range(ei.match_lo, ei.match_hi) {\n                             let sub = (ei.matches[idx]).clone();\n-                            new_pos.matches\n-                                   .get_mut(idx)\n+                            new_pos.matches[idx]\n                                    .push(Rc::new(MatchedSeq(sub, mk_sp(ei.sp_lo,\n                                                                        sp.hi))));\n                         }\n@@ -331,8 +330,7 @@ pub fn parse(sess: &ParseSess,\n                         new_ei.idx += 1u;\n                         //we specifically matched zero repeats.\n                         for idx in range(match_idx_lo, match_idx_hi) {\n-                            new_ei.matches\n-                                  .get_mut(idx)\n+                            new_ei.matches[idx]\n                                   .push(Rc::new(MatchedSeq(Vec::new(), sp)));\n                         }\n \n@@ -376,7 +374,7 @@ pub fn parse(sess: &ParseSess,\n         if token_name_eq(&tok, &token::Eof) {\n             if eof_eis.len() == 1u {\n                 let mut v = Vec::new();\n-                for dv in eof_eis.get_mut(0).matches.iter_mut() {\n+                for dv in eof_eis[0].matches.iter_mut() {\n                     v.push(dv.pop().unwrap());\n                 }\n                 return Success(nameize(sess, ms, v.as_slice()));\n@@ -417,7 +415,7 @@ pub fn parse(sess: &ParseSess,\n                 match ei.elts[ei.idx].node {\n                   MatchNonterminal(_, name, idx) => {\n                     let name_string = token::get_ident(name);\n-                    ei.matches.get_mut(idx).push(Rc::new(MatchedNonterminal(\n+                    ei.matches[idx].push(Rc::new(MatchedNonterminal(\n                         parse_nt(&mut rust_parser, name_string.get()))));\n                     ei.idx += 1u;\n                   }"}, {"sha": "5523f85acebc889a6e9907b37ffd947ba47ea56e", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -303,7 +303,7 @@ impl Printer {\n     }\n     // be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n-        *self.token.get_mut(self.right) = t;\n+        self.token[self.right] = t;\n     }\n     pub fn pretty_print(&mut self, t: Token) -> io::IoResult<()> {\n         debug!(\"pp ~[{},{}]\", self.left, self.right);\n@@ -327,8 +327,8 @@ impl Printer {\n             } else { self.advance_right(); }\n             debug!(\"pp Begin({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n-            *self.token.get_mut(self.right) = t;\n-            *self.size.get_mut(self.right) = -self.right_total;\n+            self.token[self.right] = t;\n+            self.size[self.right] = -self.right_total;\n             let right = self.right;\n             self.scan_push(right);\n             Ok(())\n@@ -340,8 +340,8 @@ impl Printer {\n             } else {\n                 debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n                 self.advance_right();\n-                *self.token.get_mut(self.right) = t;\n-                *self.size.get_mut(self.right) = -1;\n+                self.token[self.right] = t;\n+                self.size[self.right] = -1;\n                 let right = self.right;\n                 self.scan_push(right);\n                 Ok(())\n@@ -359,8 +359,8 @@ impl Printer {\n             self.check_stack(0);\n             let right = self.right;\n             self.scan_push(right);\n-            *self.token.get_mut(self.right) = t;\n-            *self.size.get_mut(self.right) = -self.right_total;\n+            self.token[self.right] = t;\n+            self.size[self.right] = -self.right_total;\n             self.right_total += b.blank_space;\n             Ok(())\n           }\n@@ -373,8 +373,8 @@ impl Printer {\n                 debug!(\"pp String('{}')/buffer ~[{},{}]\",\n                        *s, self.left, self.right);\n                 self.advance_right();\n-                *self.token.get_mut(self.right) = t.clone();\n-                *self.size.get_mut(self.right) = len;\n+                self.token[self.right] = t.clone();\n+                self.size[self.right] = len;\n                 self.right_total += len;\n                 self.check_stream()\n             }\n@@ -391,7 +391,7 @@ impl Printer {\n                 if self.left == self.scan_stack[self.bottom] {\n                     debug!(\"setting {} to infinity and popping\", self.left);\n                     let scanned = self.scan_pop_bottom();\n-                    *self.size.get_mut(scanned) = SIZE_INFINITY;\n+                    self.size[scanned] = SIZE_INFINITY;\n                 }\n             }\n             let left = self.token[self.left].clone();\n@@ -412,7 +412,7 @@ impl Printer {\n             self.top %= self.buf_len;\n             assert!((self.top != self.bottom));\n         }\n-        *self.scan_stack.get_mut(self.top) = x;\n+        self.scan_stack[self.top] = x;\n     }\n     pub fn scan_pop(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n@@ -474,20 +474,19 @@ impl Printer {\n                 Begin(_) => {\n                     if k > 0 {\n                         let popped = self.scan_pop();\n-                        *self.size.get_mut(popped) = self.size[x] +\n-                            self.right_total;\n+                        self.size[popped] = self.size[x] + self.right_total;\n                         self.check_stack(k - 1);\n                     }\n                 }\n                 End => {\n                     // paper says + not =, but that makes no sense.\n                     let popped = self.scan_pop();\n-                    *self.size.get_mut(popped) = 1;\n+                    self.size[popped] = 1;\n                     self.check_stack(k + 1);\n                 }\n                 _ => {\n                     let popped = self.scan_pop();\n-                    *self.size.get_mut(popped) = self.size[x] + self.right_total;\n+                    self.size[popped] = self.size[x] + self.right_total;\n                     if k > 0 {\n                         self.check_stack(k);\n                     }"}, {"sha": "21cf1d11e800924db1e5daf2c1633ff68a8bfd33", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d356624a1c03363be37886ffdad7dcf25ee81f6/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=1d356624a1c03363be37886ffdad7dcf25ee81f6", "patch": "@@ -185,15 +185,15 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n                 let hi = x + y;\n                 let lo = y - (hi - x);\n                 if !lo.is_zero() {\n-                    *partials.get_mut(j) = lo;\n+                    partials[j] = lo;\n                     j += 1;\n                 }\n                 x = hi;\n             }\n             if j >= partials.len() {\n                 partials.push(x);\n             } else {\n-                *partials.get_mut(j) = x;\n+                partials[j] = x;\n                 partials.truncate(j+1);\n             }\n         }"}]}