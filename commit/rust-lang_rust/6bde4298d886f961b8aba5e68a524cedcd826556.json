{"sha": "6bde4298d886f961b8aba5e68a524cedcd826556", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZGU0Mjk4ZDg4NmY5NjFiOGFiYTVlNjhhNTI0Y2VkY2Q4MjY1NTY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-09-04T14:22:22Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-09-04T14:22:22Z"}, "message": "Minimized (and then greatly expanded) test of failure cases from rust-lang/rust#52934.", "tree": {"sha": "7e4062e94d070559a8b44b2a7ce2a753a9cfc487", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e4062e94d070559a8b44b2a7ce2a753a9cfc487"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bde4298d886f961b8aba5e68a524cedcd826556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bde4298d886f961b8aba5e68a524cedcd826556", "html_url": "https://github.com/rust-lang/rust/commit/6bde4298d886f961b8aba5e68a524cedcd826556", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bde4298d886f961b8aba5e68a524cedcd826556/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4efc0a7811ee0e422dfc5d8a871b54160c18e35b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4efc0a7811ee0e422dfc5d8a871b54160c18e35b", "html_url": "https://github.com/rust-lang/rust/commit/4efc0a7811ee0e422dfc5d8a871b54160c18e35b"}], "stats": {"total": 692, "additions": 692, "deletions": 0}, "files": [{"sha": "6e7f35d1fda7e218ae0064e015c8d89b784b43fc", "filename": "src/test/ui/borrowck/two-phase-surprise-no-conflict.ast.stderr", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/6bde4298d886f961b8aba5e68a524cedcd826556/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bde4298d886f961b8aba5e68a524cedcd826556/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.ast.stderr?ref=6bde4298d886f961b8aba5e68a524cedcd826556", "patch": "@@ -0,0 +1,133 @@\n+error[E0503]: cannot use `self.cx` because it was mutably borrowed\n+  --> $DIR/two-phase-surprise-no-conflict.rs:40:13\n+   |\n+LL |         let _mut_borrow = &mut *self;\n+   |                                ----- borrow of `*self` occurs here\n+LL |         let _access = self.cx;\n+   |             ^^^^^^^ use of borrowed `*self`\n+\n+error[E0502]: cannot borrow `*self.cx_mut` as immutable because `*self` is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:79:33\n+   |\n+LL |                 self.hash_expr(&self.cx_mut.body(eid).value);\n+   |                 ----            ^^^^^^^^^^^                - mutable borrow ends here\n+   |                 |               |\n+   |                 |               immutable borrow occurs here\n+   |                 mutable borrow occurs here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because `*reg` is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:131:52\n+   |\n+LL |     reg.register_static(Box::new(TrivialPass::new(&reg.sess_mut)));\n+   |     ---                                            ^^^^^^^^^^^^  - mutable borrow ends here\n+   |     |                                              |\n+   |     mutable borrow occurs here                     immutable borrow occurs here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because `*reg` is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:135:51\n+   |\n+LL |     reg.register_bound(Box::new(TrivialPass::new(&reg.sess_mut)));\n+   |     ---                                           ^^^^^^^^^^^^  - mutable borrow ends here\n+   |     |                                             |\n+   |     mutable borrow occurs here                    immutable borrow occurs here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because `*reg` is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:139:50\n+   |\n+LL |     reg.register_univ(Box::new(TrivialPass::new(&reg.sess_mut)));\n+   |     ---                                          ^^^^^^^^^^^^  - mutable borrow ends here\n+   |     |                                            |\n+   |     mutable borrow occurs here                   immutable borrow occurs here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because `*reg` is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:143:41\n+   |\n+LL |     reg.register_ref(&TrivialPass::new(&reg.sess_mut));\n+   |     ---                                 ^^^^^^^^^^^^ - mutable borrow ends here\n+   |     |                                   |\n+   |     mutable borrow occurs here          immutable borrow occurs here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:151:56\n+   |\n+LL |     reg.register_static(Box::new(TrivialPass::new(&mut reg.sess_mut)));\n+   |     ---                                                ^^^^^^^^^^^^  - first borrow ends here\n+   |     |                                                  |\n+   |     first mutable borrow occurs here                   second mutable borrow occurs here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:156:59\n+   |\n+LL |     reg.register_bound(Box::new(TrivialPass::new_mut(&mut reg.sess_mut)));\n+   |     ---                                                   ^^^^^^^^^^^^  - first borrow ends here\n+   |     |                                                     |\n+   |     first mutable borrow occurs here                      second mutable borrow occurs here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:161:58\n+   |\n+LL |     reg.register_univ(Box::new(TrivialPass::new_mut(&mut reg.sess_mut)));\n+   |     ---                                                  ^^^^^^^^^^^^  - first borrow ends here\n+   |     |                                                    |\n+   |     first mutable borrow occurs here                     second mutable borrow occurs here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:166:49\n+   |\n+LL |     reg.register_ref(&TrivialPass::new_mut(&mut reg.sess_mut));\n+   |     ---                                         ^^^^^^^^^^^^ - first borrow ends here\n+   |     |                                           |\n+   |     first mutable borrow occurs here            second mutable borrow occurs here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because `*reg` is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:178:51\n+   |\n+LL |     reg.register_bound(Box::new(CapturePass::new(&reg.sess_mut)));\n+   |     ---                                           ^^^^^^^^^^^^  - mutable borrow ends here\n+   |     |                                             |\n+   |     mutable borrow occurs here                    immutable borrow occurs here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because `*reg` is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:183:50\n+   |\n+LL |     reg.register_univ(Box::new(CapturePass::new(&reg.sess_mut)));\n+   |     ---                                          ^^^^^^^^^^^^  - mutable borrow ends here\n+   |     |                                            |\n+   |     mutable borrow occurs here                   immutable borrow occurs here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because `*reg` is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:188:41\n+   |\n+LL |     reg.register_ref(&CapturePass::new(&reg.sess_mut));\n+   |     ---                                 ^^^^^^^^^^^^ - mutable borrow ends here\n+   |     |                                   |\n+   |     mutable borrow occurs here          immutable borrow occurs here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:200:59\n+   |\n+LL |     reg.register_bound(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n+   |     ---                                                   ^^^^^^^^^^^^  - first borrow ends here\n+   |     |                                                     |\n+   |     first mutable borrow occurs here                      second mutable borrow occurs here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:206:58\n+   |\n+LL |     reg.register_univ(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n+   |     ---                                                  ^^^^^^^^^^^^  - first borrow ends here\n+   |     |                                                    |\n+   |     first mutable borrow occurs here                     second mutable borrow occurs here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:212:49\n+   |\n+LL |     reg.register_ref(&CapturePass::new_mut(&mut reg.sess_mut));\n+   |     ---                                         ^^^^^^^^^^^^ - first borrow ends here\n+   |     |                                           |\n+   |     first mutable borrow occurs here            second mutable borrow occurs here\n+\n+error: aborting due to 16 previous errors\n+\n+Some errors occurred: E0499, E0502, E0503.\n+For more information about an error, try `rustc --explain E0499`."}, {"sha": "1fcd902134113a6484b0cf019c547710543c4e5c", "filename": "src/test/ui/borrowck/two-phase-surprise-no-conflict.nll.stderr", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/6bde4298d886f961b8aba5e68a524cedcd826556/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bde4298d886f961b8aba5e68a524cedcd826556/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.nll.stderr?ref=6bde4298d886f961b8aba5e68a524cedcd826556", "patch": "@@ -0,0 +1,165 @@\n+error[E0503]: cannot use `self.cx` because it was mutably borrowed\n+  --> $DIR/two-phase-surprise-no-conflict.rs:40:23\n+   |\n+LL |         let _mut_borrow = &mut *self;\n+   |                           ---------- borrow of `*self` occurs here\n+LL |         let _access = self.cx;\n+   |                       ^^^^^^^ use of borrowed `*self`\n+...\n+LL |         _mut_borrow;\n+   |         ----------- borrow later used here\n+\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:79:17\n+   |\n+LL |                 self.hash_expr(&self.cx_mut.body(eid).value);\n+   |                 ^^^^^^^^^^^^^^^^-----------^^^^^^^^^^^^^^^^^\n+   |                 |               |\n+   |                 |               immutable borrow occurs here\n+   |                 mutable borrow occurs here\n+   |                 borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:151:51\n+   |\n+LL |     reg.register_static(Box::new(TrivialPass::new(&mut reg.sess_mut)));\n+   |     ----------------------------------------------^^^^^^^^^^^^^^^^^---\n+   |     |                                             |\n+   |     |                                             second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:156:54\n+   |\n+LL |     reg.register_bound(Box::new(TrivialPass::new_mut(&mut reg.sess_mut)));\n+   |     -------------------------------------------------^^^^^^^^^^^^^^^^^---\n+   |     |                                                |\n+   |     |                                                second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:161:53\n+   |\n+LL |     reg.register_univ(Box::new(TrivialPass::new_mut(&mut reg.sess_mut)));\n+   |     ------------------------------------------------^^^^^^^^^^^^^^^^^---\n+   |     |                                               |\n+   |     |                                               second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:166:44\n+   |\n+LL |     reg.register_ref(&TrivialPass::new_mut(&mut reg.sess_mut));\n+   |     ---------------------------------------^^^^^^^^^^^^^^^^^--\n+   |     |                                      |\n+   |     |                                      second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0502]: cannot borrow `*reg` as mutable because it is also borrowed as immutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:178:5\n+   |\n+LL |     reg.register_bound(Box::new(CapturePass::new(&reg.sess_mut)));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------^^^\n+   |     |                                            |\n+   |     |                                            immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0502]: cannot borrow `*reg` as mutable because it is also borrowed as immutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:183:5\n+   |\n+LL |     reg.register_univ(Box::new(CapturePass::new(&reg.sess_mut)));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------^^^\n+   |     |                                           |\n+   |     |                                           immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 122:21...\n+  --> $DIR/two-phase-surprise-no-conflict.rs:122:21\n+   |\n+LL | fn register_plugins<'a>(mk_reg: impl Fn() -> &'a mut Registry<'a>) {\n+   |                     ^^\n+\n+error[E0502]: cannot borrow `*reg` as mutable because it is also borrowed as immutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:188:5\n+   |\n+LL |     reg.register_ref(&CapturePass::new(&reg.sess_mut));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------^^\n+   |     |                                  |\n+   |     |                                  immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `*reg` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:200:5\n+   |\n+LL |     reg.register_bound(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-----------------^^^\n+   |     |                                                |\n+   |     |                                                first mutable borrow occurs here\n+   |     second mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:200:54\n+   |\n+LL |     reg.register_bound(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n+   |     -------------------------------------------------^^^^^^^^^^^^^^^^^---\n+   |     |                                                |\n+   |     |                                                second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `*reg` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:206:5\n+   |\n+LL |     reg.register_univ(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-----------------^^^\n+   |     |                                               |\n+   |     |                                               first mutable borrow occurs here\n+   |     second mutable borrow occurs here\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 122:21...\n+  --> $DIR/two-phase-surprise-no-conflict.rs:122:21\n+   |\n+LL | fn register_plugins<'a>(mk_reg: impl Fn() -> &'a mut Registry<'a>) {\n+   |                     ^^\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:206:53\n+   |\n+LL |     reg.register_univ(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n+   |     ------------------------------------------------^^^^^^^^^^^^^^^^^---\n+   |     |                                               |\n+   |     |                                               second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `*reg` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:212:5\n+   |\n+LL |     reg.register_ref(&CapturePass::new_mut(&mut reg.sess_mut));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-----------------^^\n+   |     |                                      |\n+   |     |                                      first mutable borrow occurs here\n+   |     second mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:212:44\n+   |\n+LL |     reg.register_ref(&CapturePass::new_mut(&mut reg.sess_mut));\n+   |     ---------------------------------------^^^^^^^^^^^^^^^^^--\n+   |     |                                      |\n+   |     |                                      second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error: aborting due to 15 previous errors\n+\n+Some errors occurred: E0499, E0502, E0503.\n+For more information about an error, try `rustc --explain E0499`."}, {"sha": "f4fc7e54f80e8d4da91689db6b0b008a38dcc091", "filename": "src/test/ui/borrowck/two-phase-surprise-no-conflict.no2pb.stderr", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/6bde4298d886f961b8aba5e68a524cedcd826556/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.no2pb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bde4298d886f961b8aba5e68a524cedcd826556/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.no2pb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.no2pb.stderr?ref=6bde4298d886f961b8aba5e68a524cedcd826556", "patch": "@@ -0,0 +1,175 @@\n+error[E0503]: cannot use `self.cx` because it was mutably borrowed\n+  --> $DIR/two-phase-surprise-no-conflict.rs:40:23\n+   |\n+LL |         let _mut_borrow = &mut *self;\n+   |                           ---------- borrow of `*self` occurs here\n+LL |         let _access = self.cx;\n+   |                       ^^^^^^^ use of borrowed `*self`\n+...\n+LL |         _mut_borrow;\n+   |         ----------- borrow later used here\n+\n+error[E0502]: cannot borrow `*self.cx` as immutable because it is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:64:33\n+   |\n+LL |                 self.hash_expr(&self.cx.body(eid).value);\n+   |                 ----------------^^^^^^^-----------------\n+   |                 |               |\n+   |                 |               immutable borrow occurs here\n+   |                 mutable borrow occurs here\n+   |                 borrow later used here\n+\n+error[E0502]: cannot borrow `*self.cx_mut` as immutable because it is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:79:33\n+   |\n+LL |                 self.hash_expr(&self.cx_mut.body(eid).value);\n+   |                 ----------------^^^^^^^^^^^-----------------\n+   |                 |               |\n+   |                 |               immutable borrow occurs here\n+   |                 mutable borrow occurs here\n+   |                 borrow later used here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because it is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:131:51\n+   |\n+LL |     reg.register_static(Box::new(TrivialPass::new(&reg.sess_mut)));\n+   |     ----------------------------------------------^^^^^^^^^^^^^---\n+   |     |                                             |\n+   |     |                                             immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because it is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:135:50\n+   |\n+LL |     reg.register_bound(Box::new(TrivialPass::new(&reg.sess_mut)));\n+   |     ---------------------------------------------^^^^^^^^^^^^^---\n+   |     |                                            |\n+   |     |                                            immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because it is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:139:49\n+   |\n+LL |     reg.register_univ(Box::new(TrivialPass::new(&reg.sess_mut)));\n+   |     --------------------------------------------^^^^^^^^^^^^^---\n+   |     |                                           |\n+   |     |                                           immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because it is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:143:40\n+   |\n+LL |     reg.register_ref(&TrivialPass::new(&reg.sess_mut));\n+   |     -----------------------------------^^^^^^^^^^^^^--\n+   |     |                                  |\n+   |     |                                  immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:151:51\n+   |\n+LL |     reg.register_static(Box::new(TrivialPass::new(&mut reg.sess_mut)));\n+   |     ----------------------------------------------^^^^^^^^^^^^^^^^^---\n+   |     |                                             |\n+   |     |                                             second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:156:54\n+   |\n+LL |     reg.register_bound(Box::new(TrivialPass::new_mut(&mut reg.sess_mut)));\n+   |     -------------------------------------------------^^^^^^^^^^^^^^^^^---\n+   |     |                                                |\n+   |     |                                                second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:161:53\n+   |\n+LL |     reg.register_univ(Box::new(TrivialPass::new_mut(&mut reg.sess_mut)));\n+   |     ------------------------------------------------^^^^^^^^^^^^^^^^^---\n+   |     |                                               |\n+   |     |                                               second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:166:44\n+   |\n+LL |     reg.register_ref(&TrivialPass::new_mut(&mut reg.sess_mut));\n+   |     ---------------------------------------^^^^^^^^^^^^^^^^^--\n+   |     |                                      |\n+   |     |                                      second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because it is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:178:50\n+   |\n+LL |     reg.register_bound(Box::new(CapturePass::new(&reg.sess_mut)));\n+   |     ---------------------------------------------^^^^^^^^^^^^^---\n+   |     |                                            |\n+   |     |                                            immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because it is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:183:49\n+   |\n+LL |     reg.register_univ(Box::new(CapturePass::new(&reg.sess_mut)));\n+   |     --------------------------------------------^^^^^^^^^^^^^---\n+   |     |                                           |\n+   |     |                                           immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0502]: cannot borrow `reg.sess_mut` as immutable because it is also borrowed as mutable\n+  --> $DIR/two-phase-surprise-no-conflict.rs:188:40\n+   |\n+LL |     reg.register_ref(&CapturePass::new(&reg.sess_mut));\n+   |     -----------------------------------^^^^^^^^^^^^^--\n+   |     |                                  |\n+   |     |                                  immutable borrow occurs here\n+   |     mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:200:54\n+   |\n+LL |     reg.register_bound(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n+   |     -------------------------------------------------^^^^^^^^^^^^^^^^^---\n+   |     |                                                |\n+   |     |                                                second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:206:53\n+   |\n+LL |     reg.register_univ(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n+   |     ------------------------------------------------^^^^^^^^^^^^^^^^^---\n+   |     |                                               |\n+   |     |                                               second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error[E0499]: cannot borrow `reg.sess_mut` as mutable more than once at a time\n+  --> $DIR/two-phase-surprise-no-conflict.rs:212:44\n+   |\n+LL |     reg.register_ref(&CapturePass::new_mut(&mut reg.sess_mut));\n+   |     ---------------------------------------^^^^^^^^^^^^^^^^^--\n+   |     |                                      |\n+   |     |                                      second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+   |     borrow later used here\n+\n+error: aborting due to 17 previous errors\n+\n+Some errors occurred: E0499, E0502, E0503.\n+For more information about an error, try `rustc --explain E0499`."}, {"sha": "36bf44afb15be7691b3be84bcc173b4b6361a827", "filename": "src/test/ui/borrowck/two-phase-surprise-no-conflict.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/6bde4298d886f961b8aba5e68a524cedcd826556/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bde4298d886f961b8aba5e68a524cedcd826556/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-surprise-no-conflict.rs?ref=6bde4298d886f961b8aba5e68a524cedcd826556", "patch": "@@ -0,0 +1,219 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a test adapted from a minimization of the code from\n+// rust-lang/rust#52934, where an accidental disabling of\n+// two-phase-borrows (in the initial 2018 edition integration) broke\n+// Clippy, but the scenarios where it was breaking were subtle enough\n+// that we decided it warranted its own unit test, and pnkfelix\n+// decided to use that test as an opportunity to illustrate the cases.\n+\n+// revisions: ast no2pb nll\n+//[ast]compile-flags: -Z borrowck=ast\n+//[no2pb]compile-flags: -Z borrowck=mir\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+\n+// (Since we are manually toggling NLL variations on and off, don't\n+// bother with compare-mode=nll)\n+// ignore-compare-mode-nll\n+\n+#[derive(Copy, Clone)]\n+struct BodyId;\n+enum Expr { Closure(BodyId), Others }\n+struct Body { value: Expr }\n+\n+struct Map { body: Body, }\n+impl Map { fn body(&self, _: BodyId) -> &Body { unimplemented!() } }\n+\n+struct SpanlessHash<'a> { cx: &'a Map, cx_mut: &'a mut Map }\n+\n+impl <'a> SpanlessHash<'a> {\n+    fn demo(&mut self) {\n+        let _mut_borrow = &mut *self;\n+        let _access = self.cx;\n+        //[ast]~^ ERROR cannot use `self.cx` because it was mutably borrowed [E0503]\n+        //[no2pb]~^^ ERROR cannot use `self.cx` because it was mutably borrowed [E0503]\n+        //[nll]~^^^ ERROR cannot use `self.cx` because it was mutably borrowed [E0503]\n+        _mut_borrow;\n+    }\n+\n+    fn hash_expr(&mut self, e: &Expr) {\n+        match *e {\n+            Expr::Closure(eid) => {\n+                // Accepted by AST-borrowck for erroneous reasons\n+                // (rust-lang/rust#38899).\n+                //\n+                // Not okay without two-phase borrows: the implicit\n+                // `&mut self` of the receiver is evaluated first, and\n+                // that conflicts with the `self.cx`` access during\n+                // argument evaluation, as demonstrated in `fn demo`\n+                // above.\n+                //\n+                // Okay if we have two-phase borrows. Note that even\n+                // if `self.cx.body(..)` holds onto a reference into\n+                // `self.cx`, `self.cx` is an immutable-borrow, so\n+                // nothing in the activation for `self.hash_expr(..)`\n+                // can interfere with that immutable borrow.\n+                self.hash_expr(&self.cx.body(eid).value);\n+                //[no2pb]~^ ERROR cannot borrow `*self.cx`\n+            },\n+            _ => {}\n+        }\n+    }\n+\n+    fn hash_expr_mut(&mut self, e: &Expr) {\n+        match *e {\n+            Expr::Closure(eid) => {\n+                // Not okay: the call to `self.cx_mut.body(eid)` might\n+                // hold on to some mutably borrowed state in\n+                // `self.cx_mut`, which would then interfere with the\n+                // eventual activation of the `self` mutable borrow\n+                // for `self.hash_expr(..)`\n+                self.hash_expr(&self.cx_mut.body(eid).value);\n+                //[ast]~^ ERROR cannot borrow `*self.cx_mut`\n+                //[no2pb]~^^ ERROR cannot borrow `*self.cx_mut`\n+                //[nll]~^^^ ERROR cannot borrow `*self`\n+            },\n+            _ => {}\n+        }\n+    }\n+}\n+\n+struct Session;\n+struct Config;\n+trait LateLintPass<'a> { }\n+\n+struct TrivialPass;\n+impl TrivialPass {\n+    fn new(_: &Session) -> Self { TrivialPass }\n+    fn new_mut(_: &mut Session) -> Self { TrivialPass }\n+}\n+\n+struct CapturePass<'a> { s: &'a Session }\n+impl<'a> CapturePass<'a> {\n+    fn new(s: &'a Session) -> Self { CapturePass { s } }\n+    fn new_mut(s: &'a mut Session) -> Self { CapturePass { s } }\n+}\n+\n+impl<'a> LateLintPass<'a> for TrivialPass { }\n+impl<'a, 'b> LateLintPass<'a> for CapturePass<'b> { }\n+\n+struct Registry<'a> { sess_mut: &'a mut Session }\n+impl<'a> Registry<'a> {\n+    fn register_static(&mut self, _: Box<dyn LateLintPass + 'static>) { }\n+\n+    // Note: there isn't an interesting distinction between these\n+    // different methods explored by any of the cases in the test\n+    // below. pnkfelix just happened to write these cases out while\n+    // exploring variations on `dyn for <'a> Trait<'a> + 'static`, and\n+    // then decided to keep these particular ones in.\n+    fn register_bound(&mut self, _: Box<dyn LateLintPass + 'a>) { }\n+    fn register_univ(&mut self, _: Box<dyn for <'b> LateLintPass<'b> + 'a>) { }\n+    fn register_ref(&mut self, _: &dyn LateLintPass) { }\n+}\n+\n+fn register_plugins<'a>(mk_reg: impl Fn() -> &'a mut Registry<'a>) {\n+    // Not okay without two-phase borrows: The implicit `&mut reg` of\n+    // the receiver is evaluaated first, and that conflicts with the\n+    // `reg.sess_mut` access during argument evaluation.\n+    //\n+    // Okay if we have two-phase borrows: inner borrows do not survive\n+    // to the actual method invocation, because `TrivialPass::new`\n+    // cannot (according to its type) keep them alive.\n+    let reg = mk_reg();\n+    reg.register_static(Box::new(TrivialPass::new(&reg.sess_mut)));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    let reg = mk_reg();\n+    reg.register_bound(Box::new(TrivialPass::new(&reg.sess_mut)));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    let reg = mk_reg();\n+    reg.register_univ(Box::new(TrivialPass::new(&reg.sess_mut)));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    let reg = mk_reg();\n+    reg.register_ref(&TrivialPass::new(&reg.sess_mut));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+\n+    // These are not okay: the inner mutable borrows immediately\n+    // conflict with the outer borrow/reservation, even with support\n+    // for two-phase borrows.\n+    let reg = mk_reg();\n+    reg.register_static(Box::new(TrivialPass::new(&mut reg.sess_mut)));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    //[nll]~^^^ ERROR cannot borrow `reg.sess_mut`\n+    let reg = mk_reg();\n+    reg.register_bound(Box::new(TrivialPass::new_mut(&mut reg.sess_mut)));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    //[nll]~^^^ ERROR cannot borrow `reg.sess_mut`\n+    let reg = mk_reg();\n+    reg.register_univ(Box::new(TrivialPass::new_mut(&mut reg.sess_mut)));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    //[nll]~^^^ ERROR cannot borrow `reg.sess_mut`\n+    let reg = mk_reg();\n+    reg.register_ref(&TrivialPass::new_mut(&mut reg.sess_mut));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    //[nll]~^^^ ERROR cannot borrow `reg.sess_mut`\n+\n+    // These are not okay: the inner borrows may reach the actual\n+    // method invocation, because `CapturePass::new` might (according\n+    // to its type) keep them alive.\n+    //\n+    // (Also, we don't test `register_static` on CapturePass because\n+    // that will fail to get past lifetime inference.)\n+    let reg = mk_reg();\n+    reg.register_bound(Box::new(CapturePass::new(&reg.sess_mut)));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    //[nll]~^^^ ERROR cannot borrow `*reg` as mutable\n+    let reg = mk_reg();\n+    reg.register_univ(Box::new(CapturePass::new(&reg.sess_mut)));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    //[nll]~^^^ ERROR cannot borrow `*reg` as mutable\n+    let reg = mk_reg();\n+    reg.register_ref(&CapturePass::new(&reg.sess_mut));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    //[nll]~^^^ ERROR cannot borrow `*reg` as mutable\n+\n+    // These are not okay: the inner mutable borrows immediately\n+    // conflict with the outer borrow/reservation, even with support\n+    // for two-phase borrows.\n+    //\n+    // (Again, we don't test `register_static` on CapturePass because\n+    // that will fail to get past lifetime inference.)\n+    let reg = mk_reg();\n+    reg.register_bound(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    //[nll]~^^^ ERROR cannot borrow `reg.sess_mut` as mutable more than once at a time\n+    //[nll]~^^^^ ERROR cannot borrow `*reg` as mutable more than once at a time\n+    let reg = mk_reg();\n+    reg.register_univ(Box::new(CapturePass::new_mut(&mut reg.sess_mut)));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    //[nll]~^^^ ERROR cannot borrow `reg.sess_mut` as mutable more than once at a time\n+    //[nll]~^^^^ ERROR cannot borrow `*reg` as mutable more than once at a time\n+    let reg = mk_reg();\n+    reg.register_ref(&CapturePass::new_mut(&mut reg.sess_mut));\n+    //[ast]~^ ERROR cannot borrow `reg.sess_mut`\n+    //[no2pb]~^^ ERROR cannot borrow `reg.sess_mut`\n+    //[nll]~^^^ ERROR cannot borrow `reg.sess_mut` as mutable more than once at a time\n+    //[nll]~^^^^ ERROR cannot borrow `*reg` as mutable more than once at a time\n+}\n+\n+fn main() { }"}]}