{"sha": "a8a0c652297c73228a29be7a91c51fa5d6974706", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YTBjNjUyMjk3YzczMjI4YTI5YmU3YTkxYzUxZmE1ZDY5NzQ3MDY=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-11-11T19:59:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-11T19:59:07Z"}, "message": "Rollup merge of #78923 - jyn514:intra-doc-comments, r=Manishearth\n\nCleanup and comment intra-doc link pass\n\nr? ```@Manishearth```\ncc ```@seeplusplus```", "tree": {"sha": "430e7eed901900408cbbdad3b90612639176c96d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/430e7eed901900408cbbdad3b90612639176c96d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8a0c652297c73228a29be7a91c51fa5d6974706", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfrEKLCRBK7hj4Ov3rIwAAdHIIAC/28dvWMGg/1vkOqKFziana\n95hDSRIOg1WZiRMOXTK7UV/Qvb2OyY5GgCXVUz82ziiZsuwmfXFQTIgLCGu7EgNA\nm7g6fgPXalOyVui1qODughXVTlzgS5ZdVRk/LvwFZ/9nSNso1qmOtJiIkrP9/eeL\ny5xDdNI0Ujm7NbZMIGPJ5dcY76nfpmN6+OLMc71YOWRy7rsbR/ArMl2lH3P/568e\nDKEZljh7pnEKPolsYbWI3RET0OJ6e5CTZNQVa4KWKiglNoKiR5XCbK2+7QOLp7u0\nX/nrCLWYwBD0M3d4Y1uXmWnqFfJreP/GcjHOoc/ERpk+BWeAxLUVJOfxJdjcaxU=\n=feeB\n-----END PGP SIGNATURE-----\n", "payload": "tree 430e7eed901900408cbbdad3b90612639176c96d\nparent 0b521e5c475d20b4968e2d7856c1fbacd6171165\nparent 03eec5cc732ea298dde33f3188ac9ec926811459\nauthor Jonas Schievink <jonasschievink@gmail.com> 1605124747 +0100\ncommitter GitHub <noreply@github.com> 1605124747 +0100\n\nRollup merge of #78923 - jyn514:intra-doc-comments, r=Manishearth\n\nCleanup and comment intra-doc link pass\n\nr? ```@Manishearth```\ncc ```@seeplusplus```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8a0c652297c73228a29be7a91c51fa5d6974706", "html_url": "https://github.com/rust-lang/rust/commit/a8a0c652297c73228a29be7a91c51fa5d6974706", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8a0c652297c73228a29be7a91c51fa5d6974706/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b521e5c475d20b4968e2d7856c1fbacd6171165", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b521e5c475d20b4968e2d7856c1fbacd6171165", "html_url": "https://github.com/rust-lang/rust/commit/0b521e5c475d20b4968e2d7856c1fbacd6171165"}, {"sha": "03eec5cc732ea298dde33f3188ac9ec926811459", "url": "https://api.github.com/repos/rust-lang/rust/commits/03eec5cc732ea298dde33f3188ac9ec926811459", "html_url": "https://github.com/rust-lang/rust/commit/03eec5cc732ea298dde33f3188ac9ec926811459"}], "stats": {"total": 414, "additions": 247, "deletions": 167}, "files": [{"sha": "c9d4f51cbf3a7e4a78d0d387ae109bfcae01db0e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 247, "deletions": 167, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/a8a0c652297c73228a29be7a91c51fa5d6974706/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a0c652297c73228a29be7a91c51fa5d6974706/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a8a0c652297c73228a29be7a91c51fa5d6974706", "patch": "@@ -1,3 +1,7 @@\n+//! This module implements [RFC 1946]: Intra-rustdoc-links\n+//!\n+//! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n+\n use rustc_ast as ast;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -27,7 +31,7 @@ use std::cell::Cell;\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::*;\n+use crate::clean::{self, Crate, GetDefId, Import, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::markdown_links;\n@@ -42,10 +46,10 @@ pub const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n };\n \n pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n-    let mut coll = LinkCollector::new(cx);\n-    coll.fold_crate(krate)\n+    LinkCollector::new(cx).fold_crate(krate)\n }\n \n+/// Top-level errors emitted by this pass.\n enum ErrorKind<'a> {\n     Resolve(Box<ResolutionFailure<'a>>),\n     AnchorFailure(AnchorFailure),\n@@ -58,18 +62,37 @@ impl<'a> From<ResolutionFailure<'a>> for ErrorKind<'a> {\n }\n \n #[derive(Debug)]\n+/// A link failed to resolve.\n enum ResolutionFailure<'a> {\n     /// This resolved, but with the wrong namespace.\n-    /// `Namespace` is the expected namespace (as opposed to the actual).\n-    WrongNamespace(Res, Namespace),\n+    ///\n+    /// `Namespace` is the namespace specified with a disambiguator\n+    /// (as opposed to the actual namespace of the `Res`).\n+    WrongNamespace(Res, /* disambiguated */ Namespace),\n     /// The link failed to resolve. `resolution_failure` should look to see if there's\n     /// a more helpful error that can be given.\n-    NotResolved { module_id: DefId, partial_res: Option<Res>, unresolved: Cow<'a, str> },\n-    /// should not ever happen\n+    NotResolved {\n+        /// The scope the link was resolved in.\n+        module_id: DefId,\n+        /// If part of the link resolved, this has the `Res`.\n+        ///\n+        /// In `[std::io::Error::x]`, `std::io::Error` would be a partial resolution.\n+        partial_res: Option<Res>,\n+        /// The remaining unresolved path segments.\n+        ///\n+        /// In `[std::io::Error::x]`, `x` would be unresolved.\n+        unresolved: Cow<'a, str>,\n+    },\n+    /// This happens when rustdoc can't determine the parent scope for an item.\n+    ///\n+    /// It is always a bug in rustdoc.\n     NoParentItem,\n     /// This link has malformed generic parameters; e.g., the angle brackets are unbalanced.\n     MalformedGenerics(MalformedGenerics),\n-    /// used to communicate that this should be ignored, but shouldn't be reported to the user\n+    /// Used to communicate that this should be ignored, but shouldn't be reported to the user\n+    ///\n+    /// This happens when there is no disambiguator and one of the namespaces\n+    /// failed to resolve.\n     Dummy,\n }\n \n@@ -115,7 +138,9 @@ enum MalformedGenerics {\n }\n \n impl ResolutionFailure<'a> {\n-    // This resolved fully (not just partially) but is erroneous for some other reason\n+    /// This resolved fully (not just partially) but is erroneous for some other reason\n+    ///\n+    /// Returns the full resolution of the link, if present.\n     fn full_res(&self) -> Option<Res> {\n         match self {\n             Self::WrongNamespace(res, _) => Some(*res),\n@@ -125,13 +150,30 @@ impl ResolutionFailure<'a> {\n }\n \n enum AnchorFailure {\n+    /// User error: `[std#x#y]` is not valid\n     MultipleAnchors,\n+    /// The anchor provided by the user conflicts with Rustdoc's generated anchor.\n+    ///\n+    /// This is an unfortunate state of affairs. Not every item that can be\n+    /// linked to has its own page; sometimes it is a subheading within a page,\n+    /// like for associated items. In those cases, rustdoc uses an anchor to\n+    /// link to the subheading. Since you can't have two anchors for the same\n+    /// link, Rustdoc disallows having a user-specified anchor.\n+    ///\n+    /// Most of the time this is fine, because you can just link to the page of\n+    /// the item if you want to provide your own anchor. For primitives, though,\n+    /// rustdoc uses the anchor as a side channel to know which page to link to;\n+    /// it doesn't show up in the generated link. Ideally, rustdoc would remove\n+    /// this limitation, allowing you to link to subheaders on primitives.\n     RustdocAnchorConflict(Res),\n }\n \n struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n-    // NOTE: this may not necessarily be a module in the current crate\n+    /// A stack of modules used to decide what scope to resolve in.\n+    ///\n+    /// The last module will be used if the parent scope of the current item is\n+    /// unknown.\n     mod_ids: Vec<DefId>,\n     /// This is used to store the kind of associated items,\n     /// because `clean` and the disambiguator code expect them to be different.\n@@ -144,6 +186,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         LinkCollector { cx, mod_ids: Vec::new(), kind_side_channel: Cell::new(None) }\n     }\n \n+    /// Given a full link, parse it as an [enum struct variant].\n+    ///\n+    /// In particular, this will return an error whenever there aren't three\n+    /// full path segments left in the link.\n+    ///\n+    /// [enum struct variant]: hir::VariantData::Struct\n     fn variant_field(\n         &self,\n         path_str: &'path str,\n@@ -235,6 +283,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }\n     }\n \n+    /// Given a primitive type, try to resolve an associated item.\n+    ///\n+    /// HACK(jynelson): `item_str` is passed in instead of derived from `item_name` so the\n+    /// lifetimes on `&'path` will work.\n     fn resolve_primitive_associated_item(\n         &self,\n         prim_ty: hir::PrimTy,\n@@ -286,14 +338,17 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n \n     /// Resolves a string as a macro.\n-    fn macro_resolve(\n+    ///\n+    /// FIXME(jynelson): Can this be unified with `resolve()`?\n+    fn resolve_macro(\n         &self,\n         path_str: &'a str,\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n         let cx = self.cx;\n         let path = ast::Path::from_ident(Ident::from_str(path_str));\n         cx.enter_resolver(|resolver| {\n+            // FIXME(jynelson): does this really need 3 separate lookups?\n             if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n                 &path,\n                 None,\n@@ -326,6 +381,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         })\n     }\n \n+    /// Convenience wrapper around `resolve_str_path_error`.\n+    ///\n+    /// This also handles resolving `true` and `false` as booleans.\n+    /// NOTE: `resolve_str_path_error` knows only about paths, not about types.\n+    /// Associated items will never be resolved by this function.\n     fn resolve_path(&self, path_str: &str, ns: Namespace, module_id: DefId) -> Option<Res> {\n         let result = self.cx.enter_resolver(|resolver| {\n             resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n@@ -339,12 +399,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }\n     }\n \n-    /// Resolves a string as a path within a particular namespace. Also returns an optional\n-    /// URL fragment in the case of variants and methods.\n+    /// Resolves a string as a path within a particular namespace. Returns an\n+    /// optional URL fragment in the case of variants and methods.\n     fn resolve<'path>(\n         &self,\n         path_str: &'path str,\n         ns: Namespace,\n+        // FIXME(#76467): This is for `Self`, and it's wrong.\n         current_item: &Option<String>,\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n@@ -353,15 +414,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n+                // FIXME(#76467): make this fallthrough to lookup the associated\n+                // item a separate function.\n                 Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => {\n                     assert_eq!(ns, ValueNS);\n-                    // Fall through: In case this is a trait item, skip the\n-                    // early return and try looking for the trait.\n                 }\n                 Res::Def(DefKind::AssocTy, _) => {\n                     assert_eq!(ns, TypeNS);\n-                    // Fall through: In case this is a trait item, skip the\n-                    // early return and try looking for the trait.\n                 }\n                 Res::Def(DefKind::Variant, _) => {\n                     return handle_variant(cx, res, extra_fragment);\n@@ -410,7 +469,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             })?;\n \n         // FIXME: are these both necessary?\n-        let ty_res = if let Some(ty_res) = is_primitive(&path_root, TypeNS)\n+        let ty_res = if let Some(ty_res) = resolve_primitive(&path_root, TypeNS)\n             .map(|(_, res)| res)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n         {\n@@ -452,8 +511,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // There should only ever be one associated item that matches from any inherent impl\n                     .next()\n                     // Check if item_name belongs to `impl SomeTrait for SomeItem`\n-                    // This gives precedence to `impl SomeItem`:\n-                    // Although having both would be ambiguous, use impl version for compat. sake.\n+                    // FIXME(#74563): This gives precedence to `impl SomeItem`:\n+                    // Although having both would be ambiguous, use impl version for compatibility's sake.\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n@@ -480,6 +539,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     })\n                 } else if ns == Namespace::ValueNS {\n                     debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n+                    // FIXME(jynelson): why is this different from\n+                    // `variant_field`?\n                     match cx.tcx.type_of(did).kind() {\n                         ty::Adt(def, _) => {\n                             let field = if def.is_enum() {\n@@ -577,7 +638,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     ) -> Option<Res> {\n         // resolve() can't be used for macro namespace\n         let result = match ns {\n-            Namespace::MacroNS => self.macro_resolve(path_str, module_id).map_err(ErrorKind::from),\n+            Namespace::MacroNS => self.resolve_macro(path_str, module_id).map_err(ErrorKind::from),\n             Namespace::TypeNS | Namespace::ValueNS => self\n                 .resolve(path_str, ns, current_item, module_id, extra_fragment)\n                 .map(|(res, _)| res),\n@@ -593,6 +654,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n }\n \n+/// Look to see if a resolved item has an associated item named `item_name`.\n+///\n+/// Given `[std::io::Error::source]`, where `source` is unresolved, this would\n+/// find `std::error::Error::source` and return\n+/// `<io::Error as error::Error>::source`.\n fn resolve_associated_trait_item(\n     did: DefId,\n     module: DefId,\n@@ -601,12 +667,12 @@ fn resolve_associated_trait_item(\n     cx: &DocContext<'_>,\n ) -> Option<(ty::AssocKind, DefId)> {\n     let ty = cx.tcx.type_of(did);\n-    // First consider automatic impls: `impl From<T> for T`\n+    // First consider blanket impls: `impl From<T> for T`\n     let implicit_impls = crate::clean::get_auto_trait_and_blanket_impls(cx, ty, did);\n     let mut candidates: Vec<_> = implicit_impls\n         .flat_map(|impl_outer| {\n             match impl_outer.inner {\n-                ImplItem(impl_) => {\n+                clean::ImplItem(impl_) => {\n                     debug!(\"considering auto or blanket impl for trait {:?}\", impl_.trait_);\n                     // Give precedence to methods that were overridden\n                     if !impl_.provided_trait_methods.contains(&*item_name.as_str()) {\n@@ -669,7 +735,7 @@ fn resolve_associated_trait_item(\n                 .map(|assoc| (assoc.kind, assoc.def_id))\n         }));\n     }\n-    // FIXME: warn about ambiguity\n+    // FIXME(#74563): warn about ambiguity\n     debug!(\"the candidates were {:?}\", candidates);\n     candidates.pop()\n }\n@@ -719,20 +785,15 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n     iter.collect()\n }\n \n-/// Check for resolve collisions between a trait and its derive\n+/// Check for resolve collisions between a trait and its derive.\n ///\n-/// These are common and we should just resolve to the trait in that case\n+/// These are common and we should just resolve to the trait in that case.\n fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_>>>) -> bool {\n-    if let PerNS {\n+    matches!(*ns, PerNS {\n         type_ns: Ok((Res::Def(DefKind::Trait, _), _)),\n         macro_ns: Ok((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n         ..\n-    } = *ns\n-    {\n-        true\n-    } else {\n-        false\n-    }\n+    })\n }\n \n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n@@ -772,29 +833,30 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         }\n \n         let current_item = match item.inner {\n-            ModuleItem(..) => {\n+            clean::ModuleItem(..) => {\n                 if item.attrs.inner_docs {\n                     if item.def_id.is_top_level_module() { item.name.clone() } else { None }\n                 } else {\n                     match parent_node.or(self.mod_ids.last().copied()) {\n                         Some(parent) if !parent.is_top_level_module() => {\n-                            // FIXME: can we pull the parent module's name from elsewhere?\n                             Some(self.cx.tcx.item_name(parent).to_string())\n                         }\n                         _ => None,\n                     }\n                 }\n             }\n-            ImplItem(Impl { ref for_, .. }) => {\n+            clean::ImplItem(clean::Impl { ref for_, .. }) => {\n                 for_.def_id().map(|did| self.cx.tcx.item_name(did).to_string())\n             }\n             // we don't display docs on `extern crate` items anyway, so don't process them.\n-            ExternCrateItem(..) => {\n+            clean::ExternCrateItem(..) => {\n                 debug!(\"ignoring extern crate item {:?}\", item.def_id);\n                 return self.fold_item_recur(item);\n             }\n-            ImportItem(Import { kind: ImportKind::Simple(ref name, ..), .. }) => Some(name.clone()),\n-            MacroItem(..) => None,\n+            clean::ImportItem(Import { kind: clean::ImportKind::Simple(ref name, ..), .. }) => {\n+                Some(name.clone())\n+            }\n+            clean::MacroItem(..) => None,\n             _ => item.name.clone(),\n         };\n \n@@ -803,6 +865,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         }\n \n         // find item's parent to resolve `Self` in item's docs below\n+        // FIXME(#76467, #75809): this is a mess and doesn't handle cross-crate\n+        // re-exports\n         let parent_name = self.cx.as_local_hir_id(item.def_id).and_then(|item_hir| {\n             let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n             let item_parent = self.cx.tcx.hir().find(parent_hir);\n@@ -870,7 +934,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             };\n             // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n             // This is a degenerate case and it's not supported by rustdoc.\n-            // FIXME: this will break links that start in `#[doc = ...]` and end as a sugared doc. Should this be supported?\n             for (ori_link, link_range) in markdown_links(&combined_docs) {\n                 let link = self.resolve_link(\n                     &item,\n@@ -888,15 +951,13 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n         }\n \n-        if item.is_mod() && !item.attrs.inner_docs {\n-            self.mod_ids.push(item.def_id);\n-        }\n-\n         if item.is_mod() {\n-            let ret = self.fold_item_recur(item);\n+            if !item.attrs.inner_docs {\n+                self.mod_ids.push(item.def_id);\n+            }\n \n+            let ret = self.fold_item_recur(item);\n             self.mod_ids.pop();\n-\n             ret\n         } else {\n             self.fold_item_recur(item)\n@@ -905,6 +966,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n }\n \n impl LinkCollector<'_, '_> {\n+    /// This is the entry point for resolving an intra-doc link.\n+    ///\n+    /// FIXME(jynelson): this is way too many arguments\n     fn resolve_link(\n         &self,\n         item: &Item,\n@@ -943,129 +1007,120 @@ impl LinkCollector<'_, '_> {\n         } else {\n             (parts[0], None)\n         };\n-        let resolved_self;\n-        let link_text;\n-        let mut path_str;\n-        let disambiguator;\n-        let stripped_path_string;\n-        let (mut res, mut fragment) = {\n-            path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n-                disambiguator = Some(d);\n-                path\n-            } else {\n-                disambiguator = None;\n-                &link\n-            }\n-            .trim();\n \n-            if path_str.contains(|ch: char| !(ch.is_alphanumeric() || \":_<>, \".contains(ch))) {\n-                return None;\n-            }\n+        // Parse and strip the disambiguator from the link, if present.\n+        let (mut path_str, disambiguator) = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n+            (path.trim(), Some(d))\n+        } else {\n+            (link.trim(), None)\n+        };\n \n-            // We stripped `()` and `!` when parsing the disambiguator.\n-            // Add them back to be displayed, but not prefix disambiguators.\n-            link_text = disambiguator\n-                .map(|d| d.display_for(path_str))\n-                .unwrap_or_else(|| path_str.to_owned());\n-\n-            // In order to correctly resolve intra-doc-links we need to\n-            // pick a base AST node to work from.  If the documentation for\n-            // this module came from an inner comment (//!) then we anchor\n-            // our name resolution *inside* the module.  If, on the other\n-            // hand it was an outer comment (///) then we anchor the name\n-            // resolution in the parent module on the basis that the names\n-            // used are more likely to be intended to be parent names.  For\n-            // this, we set base_node to None for inner comments since\n-            // we've already pushed this node onto the resolution stack but\n-            // for outer comments we explicitly try and resolve against the\n-            // parent_node first.\n-            let base_node = if item.is_mod() && item.attrs.inner_docs {\n-                self.mod_ids.last().copied()\n-            } else {\n-                parent_node\n-            };\n+        if path_str.contains(|ch: char| !(ch.is_alphanumeric() || \":_<>, \".contains(ch))) {\n+            return None;\n+        }\n \n-            let mut module_id = if let Some(id) = base_node {\n-                id\n-            } else {\n-                debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-                let err_kind = ResolutionFailure::NoParentItem.into();\n-                resolution_failure(\n-                    self,\n-                    &item,\n-                    path_str,\n-                    disambiguator,\n-                    dox,\n-                    link_range,\n-                    smallvec![err_kind],\n-                );\n-                return None;\n-            };\n+        // We stripped `()` and `!` when parsing the disambiguator.\n+        // Add them back to be displayed, but not prefix disambiguators.\n+        let link_text =\n+            disambiguator.map(|d| d.display_for(path_str)).unwrap_or_else(|| path_str.to_owned());\n+\n+        // In order to correctly resolve intra-doc-links we need to\n+        // pick a base AST node to work from.  If the documentation for\n+        // this module came from an inner comment (//!) then we anchor\n+        // our name resolution *inside* the module.  If, on the other\n+        // hand it was an outer comment (///) then we anchor the name\n+        // resolution in the parent module on the basis that the names\n+        // used are more likely to be intended to be parent names.  For\n+        // this, we set base_node to None for inner comments since\n+        // we've already pushed this node onto the resolution stack but\n+        // for outer comments we explicitly try and resolve against the\n+        // parent_node first.\n+        let base_node = if item.is_mod() && item.attrs.inner_docs {\n+            self.mod_ids.last().copied()\n+        } else {\n+            parent_node\n+        };\n \n-            // replace `Self` with suitable item's parent name\n-            if path_str.starts_with(\"Self::\") {\n-                if let Some(ref name) = parent_name {\n-                    resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n-                    path_str = &resolved_self;\n-                }\n-            } else if path_str.starts_with(\"crate::\") {\n-                use rustc_span::def_id::CRATE_DEF_INDEX;\n-\n-                // HACK(jynelson): rustc_resolve thinks that `crate` is the crate currently being documented.\n-                // But rustdoc wants it to mean the crate this item was originally present in.\n-                // To work around this, remove it and resolve relative to the crate root instead.\n-                // HACK(jynelson)(2): If we just strip `crate::` then suddenly primitives become ambiguous\n-                // (consider `crate::char`). Instead, change it to `self::`. This works because 'self' is now the crate root.\n-                resolved_self = format!(\"self::{}\", &path_str[\"crate::\".len()..]);\n-                path_str = &resolved_self;\n-                module_id = DefId { krate, index: CRATE_DEF_INDEX };\n-            }\n+        let mut module_id = if let Some(id) = base_node {\n+            id\n+        } else {\n+            // This is a bug.\n+            debug!(\"attempting to resolve item without parent module: {}\", path_str);\n+            let err_kind = ResolutionFailure::NoParentItem.into();\n+            resolution_failure(\n+                self,\n+                &item,\n+                path_str,\n+                disambiguator,\n+                dox,\n+                link_range,\n+                smallvec![err_kind],\n+            );\n+            return None;\n+        };\n \n-            // Strip generics from the path.\n-            if path_str.contains(['<', '>'].as_slice()) {\n-                stripped_path_string = match strip_generics_from_path(path_str) {\n-                    Ok(path) => path,\n-                    Err(err_kind) => {\n-                        debug!(\"link has malformed generics: {}\", path_str);\n-                        resolution_failure(\n-                            self,\n-                            &item,\n-                            path_str,\n-                            disambiguator,\n-                            dox,\n-                            link_range,\n-                            smallvec![err_kind],\n-                        );\n-                        return None;\n-                    }\n-                };\n-                path_str = &stripped_path_string;\n+        let resolved_self;\n+        // replace `Self` with suitable item's parent name\n+        if path_str.starts_with(\"Self::\") {\n+            if let Some(ref name) = parent_name {\n+                resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n+                path_str = &resolved_self;\n             }\n+        } else if path_str.starts_with(\"crate::\") {\n+            use rustc_span::def_id::CRATE_DEF_INDEX;\n+\n+            // HACK(jynelson): rustc_resolve thinks that `crate` is the crate currently being documented.\n+            // But rustdoc wants it to mean the crate this item was originally present in.\n+            // To work around this, remove it and resolve relative to the crate root instead.\n+            // HACK(jynelson)(2): If we just strip `crate::` then suddenly primitives become ambiguous\n+            // (consider `crate::char`). Instead, change it to `self::`. This works because 'self' is now the crate root.\n+            // FIXME(#78696): This doesn't always work.\n+            resolved_self = format!(\"self::{}\", &path_str[\"crate::\".len()..]);\n+            path_str = &resolved_self;\n+            module_id = DefId { krate, index: CRATE_DEF_INDEX };\n+        }\n \n-            // Sanity check to make sure we don't have any angle brackets after stripping generics.\n-            assert!(!path_str.contains(['<', '>'].as_slice()));\n+        // Strip generics from the path.\n+        let stripped_path_string;\n+        if path_str.contains(['<', '>'].as_slice()) {\n+            stripped_path_string = match strip_generics_from_path(path_str) {\n+                Ok(path) => path,\n+                Err(err_kind) => {\n+                    debug!(\"link has malformed generics: {}\", path_str);\n+                    resolution_failure(\n+                        self,\n+                        &item,\n+                        path_str,\n+                        disambiguator,\n+                        dox,\n+                        link_range,\n+                        smallvec![err_kind],\n+                    );\n+                    return None;\n+                }\n+            };\n+            path_str = &stripped_path_string;\n+        }\n+        // Sanity check to make sure we don't have any angle brackets after stripping generics.\n+        assert!(!path_str.contains(['<', '>'].as_slice()));\n \n-            // The link is not an intra-doc link if it still contains commas or spaces after\n-            // stripping generics.\n-            if path_str.contains([',', ' '].as_slice()) {\n-                return None;\n-            }\n+        // The link is not an intra-doc link if it still contains commas or spaces after\n+        // stripping generics.\n+        if path_str.contains([',', ' '].as_slice()) {\n+            return None;\n+        }\n \n-            match self.resolve_with_disambiguator(\n-                disambiguator,\n-                item,\n-                dox,\n-                path_str,\n-                current_item,\n-                module_id,\n-                extra_fragment,\n-                &ori_link,\n-                link_range.clone(),\n-            ) {\n-                Some(x) => x,\n-                None => return None,\n-            }\n-        };\n+        let (mut res, mut fragment) = self.resolve_with_disambiguator(\n+            disambiguator,\n+            item,\n+            dox,\n+            path_str,\n+            current_item,\n+            module_id,\n+            extra_fragment,\n+            &ori_link,\n+            link_range.clone(),\n+        )?;\n \n         // Check for a primitive which might conflict with a module\n         // Report the ambiguity and require that the user specify which one they meant.\n@@ -1075,7 +1130,7 @@ impl LinkCollector<'_, '_> {\n             None | Some(Disambiguator::Namespace(Namespace::TypeNS) | Disambiguator::Primitive)\n         ) && !matches!(res, Res::PrimTy(_))\n         {\n-            if let Some((path, prim)) = is_primitive(path_str, TypeNS) {\n+            if let Some((path, prim)) = resolve_primitive(path_str, TypeNS) {\n                 // `prim@char`\n                 if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n                     if fragment.is_some() {\n@@ -1168,11 +1223,13 @@ impl LinkCollector<'_, '_> {\n                     privacy_error(cx, &item, &path_str, dox, link_range);\n                 }\n             }\n-            let id = register_res(cx, res);\n+            let id = clean::register_res(cx, res);\n             Some(ItemLink { link: ori_link, link_text, did: Some(id), fragment })\n         }\n     }\n \n+    /// After parsing the disambiguator, resolve the main part of the link.\n+    // FIXME(jynelson): wow this is just so much\n     fn resolve_with_disambiguator(\n         &self,\n         disambiguator: Option<Disambiguator>,\n@@ -1232,7 +1289,7 @@ impl LinkCollector<'_, '_> {\n                 // Try everything!\n                 let mut candidates = PerNS {\n                     macro_ns: self\n-                        .macro_resolve(path_str, base_node)\n+                        .resolve_macro(path_str, base_node)\n                         .map(|res| (res, extra_fragment.clone())),\n                     type_ns: match self.resolve(\n                         path_str,\n@@ -1320,10 +1377,10 @@ impl LinkCollector<'_, '_> {\n                 }\n             }\n             Some(MacroNS) => {\n-                match self.macro_resolve(path_str, base_node) {\n+                match self.resolve_macro(path_str, base_node) {\n                     Ok(res) => Some((res, extra_fragment)),\n                     Err(mut kind) => {\n-                        // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n+                        // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for &ns in &[TypeNS, ValueNS] {\n                             if let Some(res) = self.check_full_res(\n                                 ns,\n@@ -1354,9 +1411,15 @@ impl LinkCollector<'_, '_> {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+/// Disambiguators for a link.\n enum Disambiguator {\n+    /// `prim@`\n+    ///\n+    /// This is buggy, see <https://github.com/rust-lang/rust/pull/77875#discussion_r503583103>\n     Primitive,\n+    /// `struct@` or `f()`\n     Kind(DefKind),\n+    /// `type@`\n     Namespace(Namespace),\n }\n \n@@ -1373,7 +1436,7 @@ impl Disambiguator {\n         }\n     }\n \n-    /// (disambiguator, path_str)\n+    /// Given a link, parse and return `(disambiguator, path_str)`\n     fn from_str(link: &str) -> Result<(Self, &str), ()> {\n         use Disambiguator::{Kind, Namespace as NS, Primitive};\n \n@@ -1424,6 +1487,7 @@ impl Disambiguator {\n         }\n     }\n \n+    /// Used for error reporting.\n     fn suggestion(self) -> Suggestion {\n         let kind = match self {\n             Disambiguator::Primitive => return Suggestion::Prefix(\"prim\"),\n@@ -1490,9 +1554,13 @@ impl Disambiguator {\n     }\n }\n \n+/// A suggestion to show in a diagnostic.\n enum Suggestion {\n+    /// `struct@`\n     Prefix(&'static str),\n+    /// `f()`\n     Function,\n+    /// `m!`\n     Macro,\n }\n \n@@ -1582,6 +1650,11 @@ fn report_diagnostic(\n     });\n }\n \n+/// Reports a link that failed to resolve.\n+///\n+/// This also tries to resolve any intermediate path segments that weren't\n+/// handled earlier. For example, if passed `Item::Crate(std)` and `path_str`\n+/// `std::io::Error::x`, this will resolve `std::io::Error`.\n fn resolution_failure(\n     collector: &LinkCollector<'_, '_>,\n     item: &Item,\n@@ -1816,6 +1889,7 @@ fn resolution_failure(\n     );\n }\n \n+/// Report an anchor failure.\n fn anchor_failure(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -1840,6 +1914,7 @@ fn anchor_failure(\n     });\n }\n \n+/// Report an ambiguity error, where there were multiple possible resolutions.\n fn ambiguity_error(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -1886,6 +1961,8 @@ fn ambiguity_error(\n     });\n }\n \n+/// In case of an ambiguity or mismatched disambiguator, suggest the correct\n+/// disambiguator.\n fn suggest_disambiguator(\n     disambiguator: Disambiguator,\n     diag: &mut DiagnosticBuilder<'_>,\n@@ -1911,6 +1988,7 @@ fn suggest_disambiguator(\n     }\n }\n \n+/// Report a link from a public item to a private one.\n fn privacy_error(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -1978,7 +2056,8 @@ const PRIMITIVES: &[(Symbol, Res)] = &[\n     (sym::char, Res::PrimTy(hir::PrimTy::Char)),\n ];\n \n-fn is_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n+/// Resolve a primitive type or value.\n+fn resolve_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n     is_bool_value(path_str, ns).or_else(|| {\n         if ns == TypeNS {\n             // FIXME: this should be replaced by a lookup in PrimitiveTypeTable\n@@ -1990,6 +2069,7 @@ fn is_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n     })\n }\n \n+/// Resolve a primitive value.\n fn is_bool_value(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n     if ns == TypeNS && (path_str == \"true\" || path_str == \"false\") {\n         Some((sym::bool, Res::PrimTy(hir::PrimTy::Bool)))"}]}