{"sha": "4233a13cebe176139d8d16d18f507b90852ddab0", "node_id": "C_kwDOAAsO6NoAKDQyMzNhMTNjZWJlMTc2MTM5ZDhkMTZkMThmNTA3YjkwODUyZGRhYjA", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-08-02T11:33:40Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-08-03T02:12:31Z"}, "message": "suggest a positional formatting argument instead of a captured argument", "tree": {"sha": "2dd6c8c2578a3fbc33f6f379ab3c7c7395895bab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dd6c8c2578a3fbc33f6f379ab3c7c7395895bab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4233a13cebe176139d8d16d18f507b90852ddab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4233a13cebe176139d8d16d18f507b90852ddab0", "html_url": "https://github.com/rust-lang/rust/commit/4233a13cebe176139d8d16d18f507b90852ddab0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4233a13cebe176139d8d16d18f507b90852ddab0/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4417cf020fbcd6182c11637bc6b8694434bd81a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4417cf020fbcd6182c11637bc6b8694434bd81a", "html_url": "https://github.com/rust-lang/rust/commit/e4417cf020fbcd6182c11637bc6b8694434bd81a"}], "stats": {"total": 163, "additions": 148, "deletions": 15}, "files": [{"sha": "1fdc312603dfcabe906852f013039f2f310a1708", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4233a13cebe176139d8d16d18f507b90852ddab0/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4233a13cebe176139d8d16d18f507b90852ddab0/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=4233a13cebe176139d8d16d18f507b90852ddab0", "patch": "@@ -250,6 +250,11 @@ struct Context<'a, 'b> {\n     unused_names_lint: PositionalNamedArgsLint,\n }\n \n+pub struct FormatArg {\n+    expr: P<ast::Expr>,\n+    named: bool,\n+}\n+\n /// Parses the arguments from the given list of tokens, returning the diagnostic\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n@@ -263,8 +268,8 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, (usize, Span)>)> {\n-    let mut args = Vec::<P<ast::Expr>>::new();\n+) -> PResult<'a, (P<ast::Expr>, Vec<FormatArg>, FxHashMap<Symbol, (usize, Span)>)> {\n+    let mut args = Vec::<FormatArg>::new();\n     let mut names = FxHashMap::<Symbol, (usize, Span)>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n@@ -332,7 +337,7 @@ fn parse_args<'a>(\n                 let e = p.parse_expr()?;\n                 if let Some((prev, _)) = names.get(&ident.name) {\n                     ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n-                        .span_label(args[*prev].span, \"previously here\")\n+                        .span_label(args[*prev].expr.span, \"previously here\")\n                         .span_label(e.span, \"duplicate argument\")\n                         .emit();\n                     continue;\n@@ -344,7 +349,7 @@ fn parse_args<'a>(\n                 // args. And remember the names.\n                 let slot = args.len();\n                 names.insert(ident.name, (slot, ident.span));\n-                args.push(e);\n+                args.push(FormatArg { expr: e, named: true });\n             }\n             _ => {\n                 let e = p.parse_expr()?;\n@@ -355,11 +360,11 @@ fn parse_args<'a>(\n                     );\n                     err.span_label(e.span, \"positional arguments must be before named arguments\");\n                     for pos in names.values() {\n-                        err.span_label(args[pos.0].span, \"named argument\");\n+                        err.span_label(args[pos.0].expr.span, \"named argument\");\n                     }\n                     err.emit();\n                 }\n-                args.push(e);\n+                args.push(FormatArg { expr: e, named: false });\n             }\n         }\n     }\n@@ -1180,7 +1185,7 @@ pub fn expand_preparsed_format_args(\n     ecx: &mut ExtCtxt<'_>,\n     sp: Span,\n     efmt: P<ast::Expr>,\n-    args: Vec<P<ast::Expr>>,\n+    args: Vec<FormatArg>,\n     names: FxHashMap<Symbol, (usize, Span)>,\n     append_newline: bool,\n ) -> P<ast::Expr> {\n@@ -1270,6 +1275,24 @@ pub fn expand_preparsed_format_args(\n                 e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n             }\n         }\n+        if err.should_be_replaced_with_positional_argument {\n+            let captured_arg_span =\n+                fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end));\n+            let positional_args = args.iter().filter(|arg| !arg.named).collect::<Vec<_>>();\n+            let mut suggestions = vec![(captured_arg_span, positional_args.len().to_string())];\n+            if let Ok(arg) = ecx.source_map().span_to_snippet(captured_arg_span) {\n+                let span = match positional_args.last() {\n+                    Some(arg) => arg.expr.span,\n+                    None => fmt_sp,\n+                };\n+                suggestions.push((span.shrink_to_hi(), format!(\", {}\", arg)))\n+            }\n+            e.multipart_suggestion_verbose(\n+                \"consider using a positional formatting argument instead\",\n+                suggestions,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n         e.emit();\n         return DummyResult::raw_expr(sp, true);\n     }\n@@ -1284,7 +1307,7 @@ pub fn expand_preparsed_format_args(\n \n     let mut cx = Context {\n         ecx,\n-        args,\n+        args: args.into_iter().map(|arg| arg.expr).collect(),\n         num_captured_args: 0,\n         arg_types,\n         arg_unique_types,"}, {"sha": "4d8bd20aa36aec185780127e930dbad8eea34960", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4233a13cebe176139d8d16d18f507b90852ddab0/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4233a13cebe176139d8d16d18f507b90852ddab0/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=4233a13cebe176139d8d16d18f507b90852ddab0", "patch": "@@ -175,6 +175,7 @@ pub struct ParseError {\n     pub label: string::String,\n     pub span: InnerSpan,\n     pub secondary_label: Option<(string::String, InnerSpan)>,\n+    pub should_be_replaced_with_positional_argument: bool,\n }\n \n /// The parser structure for interpreting the input format string. This is\n@@ -228,13 +229,19 @@ impl<'a> Iterator for Parser<'a> {\n                         Some(String(self.string(pos + 1)))\n                     } else {\n                         let arg = self.argument(lbrace_end);\n-                        if let Some(rbrace_byte_idx) = self.must_consume('}') {\n-                            let lbrace_inner_offset = self.to_span_index(pos);\n-                            let rbrace_inner_offset = self.to_span_index(rbrace_byte_idx);\n-                            if self.is_literal {\n-                                self.arg_places.push(\n-                                    lbrace_inner_offset.to(InnerOffset(rbrace_inner_offset.0 + 1)),\n-                                );\n+                        match self.must_consume('}') {\n+                            Some(rbrace_byte_idx) => {\n+                                let lbrace_inner_offset = self.to_span_index(pos);\n+                                let rbrace_inner_offset = self.to_span_index(rbrace_byte_idx);\n+                                if self.is_literal {\n+                                    self.arg_places.push(\n+                                        lbrace_inner_offset\n+                                            .to(InnerOffset(rbrace_inner_offset.0 + 1)),\n+                                    );\n+                                }\n+                            }\n+                            None => {\n+                                self.suggest_positional_arg_instead_of_captured_arg(arg);\n                             }\n                         }\n                         Some(NextArgument(arg))\n@@ -313,6 +320,7 @@ impl<'a> Parser<'a> {\n             label: label.into(),\n             span,\n             secondary_label: None,\n+            should_be_replaced_with_positional_argument: false,\n         });\n     }\n \n@@ -336,6 +344,7 @@ impl<'a> Parser<'a> {\n             label: label.into(),\n             span,\n             secondary_label: None,\n+            should_be_replaced_with_positional_argument: false,\n         });\n     }\n \n@@ -407,6 +416,7 @@ impl<'a> Parser<'a> {\n                     label,\n                     span: pos.to(pos),\n                     secondary_label,\n+                    should_be_replaced_with_positional_argument: false,\n                 });\n                 None\n             }\n@@ -434,6 +444,7 @@ impl<'a> Parser<'a> {\n                     label,\n                     span: pos.to(pos),\n                     secondary_label,\n+                    should_be_replaced_with_positional_argument: false,\n                 });\n             } else {\n                 self.err(description, format!(\"expected `{:?}`\", c), pos.to(pos));\n@@ -750,6 +761,29 @@ impl<'a> Parser<'a> {\n         }\n         if found { Some(cur) } else { None }\n     }\n+\n+    fn suggest_positional_arg_instead_of_captured_arg(&mut self, arg: Argument<'a>) {\n+        if let Some(end) = self.consume_pos('.') {\n+            let byte_pos = self.to_span_index(end);\n+            let start = InnerOffset(byte_pos.0 + 1);\n+            let field = self.argument(start);\n+            if let ArgumentNamed(_) = arg.position {\n+                if let ArgumentNamed(_) = field.position {\n+                    self.errors.insert(\n+                        0,\n+                        ParseError {\n+                            description: \"field access isn't supported\".to_string(),\n+                            note: None,\n+                            label: \"not supported\".to_string(),\n+                            span: InnerSpan::new(arg.position_span.start, field.position_span.end),\n+                            secondary_label: None,\n+                            should_be_replaced_with_positional_argument: true,\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n }\n \n /// Finds the indices of all characters that have been processed and differ between the actual"}, {"sha": "a8d7b44fb3d315ee78f42e81d1e4251b8d9dc8cf", "filename": "src/test/ui/fmt/struct-field-as-captured-argument.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4233a13cebe176139d8d16d18f507b90852ddab0/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4233a13cebe176139d8d16d18f507b90852ddab0/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.fixed?ref=4233a13cebe176139d8d16d18f507b90852ddab0", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+#[derive(Debug)]\n+struct Foo {\n+    field: usize,\n+}\n+\n+fn main() {\n+    let foo = Foo { field: 0 };\n+    let bar = 3;\n+    format!(\"{0}\", foo.field); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1} {} {bar}\", \"aa\", foo.field); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{2} {} {1} {bar}\", \"aa\", \"bb\", foo.field); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1} {} {baz}\", \"aa\", foo.field, baz = 3); //~ ERROR invalid format string: field access isn't supported\n+}"}, {"sha": "e23c14190b0df16c757b487d81b95b01d408babe", "filename": "src/test/ui/fmt/struct-field-as-captured-argument.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4233a13cebe176139d8d16d18f507b90852ddab0/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4233a13cebe176139d8d16d18f507b90852ddab0/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.rs?ref=4233a13cebe176139d8d16d18f507b90852ddab0", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+#[derive(Debug)]\n+struct Foo {\n+    field: usize,\n+}\n+\n+fn main() {\n+    let foo = Foo { field: 0 };\n+    let bar = 3;\n+    format!(\"{foo.field}\"); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field} {} {bar}\", \"aa\"); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field} {} {1} {bar}\", \"aa\", \"bb\"); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field} {} {baz}\", \"aa\", baz = 3); //~ ERROR invalid format string: field access isn't supported\n+}"}, {"sha": "28d3c8f838bb76b9b6964491c3bcacc0e92bb8d1", "filename": "src/test/ui/fmt/struct-field-as-captured-argument.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4233a13cebe176139d8d16d18f507b90852ddab0/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4233a13cebe176139d8d16d18f507b90852ddab0/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.stderr?ref=4233a13cebe176139d8d16d18f507b90852ddab0", "patch": "@@ -0,0 +1,46 @@\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:11:15\n+   |\n+LL |     format!(\"{foo.field}\");\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{0}\", foo.field);\n+   |               ~  +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:12:15\n+   |\n+LL |     format!(\"{foo.field} {} {bar}\", \"aa\");\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1} {} {bar}\", \"aa\", foo.field);\n+   |               ~                 +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:13:15\n+   |\n+LL |     format!(\"{foo.field} {} {1} {bar}\", \"aa\", \"bb\");\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{2} {} {1} {bar}\", \"aa\", \"bb\", foo.field);\n+   |               ~                           +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:14:15\n+   |\n+LL |     format!(\"{foo.field} {} {baz}\", \"aa\", baz = 3);\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1} {} {baz}\", \"aa\", foo.field, baz = 3);\n+   |               ~                 +++++++++++\n+\n+error: aborting due to 4 previous errors\n+"}]}