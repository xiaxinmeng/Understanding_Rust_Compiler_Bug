{"sha": "879c17f3f9a460e8bb28becead81111ee2cadd97", "node_id": "C_kwDOAAsO6NoAKDg3OWMxN2YzZjlhNDYwZThiYjI4YmVjZWFkODExMTFlZTJjYWRkOTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-06T23:19:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-06T23:19:32Z"}, "message": "Rollup merge of #100127 - ChrisDenton:remove-init, r=thomcc\n\nRemove Windows function preloading\n\nAfter `@Mark-Simulacrum` asked me to provide guidance for when optionally imported functions should be preloaded, I realised my justifications were now quite weak. I think the strongest argument that can be made is that it avoids some degree of nondeterminism when calling these functions (in as far as system API calls can be said to be deterministic). However, I don't think that's particularly convincing unless there's a real world use case where it matters. Further discussion with `@thomcc` has strengthened my feeling that preloading isn't really needed.\n\nNote that `WaitOnAddress` needed some adjustment to work without preloading. I opted not to use a macro for this special case as it seemed silly to do so for just one thing (and I don't like macros tbh).", "tree": {"sha": "b1ccc1011cd13429f82b23b54b91b0a0f127b890", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1ccc1011cd13429f82b23b54b91b0a0f127b890"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/879c17f3f9a460e8bb28becead81111ee2cadd97", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi7vcECRBK7hj4Ov3rIwAAofgIAJ0ORhUF+1umDh8iTcBwxTsa\nEzABTf7O6+qXhSuB4XS56nBpAxwf57PKlajTYsEaDIYx9M8LoMdsz68NjKdyrf0K\nCJhVp+clF3eTtTf7N0FGVtXU1dMYHfffakmCTp+kHZr/OuEXmJ8NxZEcgg5+eYNE\nf4obMvYL8fKtOxuyMPhmS0/efYj6B4v8vYvk26JVA12FQPnNuQ7XeJdQq/JGwof/\nDqiLagw7afgQXi8j7gcKkIgZfbTRqJF8cLPyAKhBkODuvb3awdDXRxRU2LTuaGCp\nkymWHX64+easpzrlWsZmVmaOrgW/fsK/BroZVQMk0zKduMmppa9OeCRRXq59UWY=\n=YegB\n-----END PGP SIGNATURE-----\n", "payload": "tree b1ccc1011cd13429f82b23b54b91b0a0f127b890\nparent aaa054e53c4d43cf047c1b1eeadaedb0eb5a212c\nparent a0e4c1695854db9bf2f4aae3229026608675307d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1659827972 +0200\ncommitter GitHub <noreply@github.com> 1659827972 +0200\n\nRollup merge of #100127 - ChrisDenton:remove-init, r=thomcc\n\nRemove Windows function preloading\n\nAfter `@Mark-Simulacrum` asked me to provide guidance for when optionally imported functions should be preloaded, I realised my justifications were now quite weak. I think the strongest argument that can be made is that it avoids some degree of nondeterminism when calling these functions (in as far as system API calls can be said to be deterministic). However, I don't think that's particularly convincing unless there's a real world use case where it matters. Further discussion with `@thomcc` has strengthened my feeling that preloading isn't really needed.\n\nNote that `WaitOnAddress` needed some adjustment to work without preloading. I opted not to use a macro for this special case as it seemed silly to do so for just one thing (and I don't like macros tbh).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/879c17f3f9a460e8bb28becead81111ee2cadd97", "html_url": "https://github.com/rust-lang/rust/commit/879c17f3f9a460e8bb28becead81111ee2cadd97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/879c17f3f9a460e8bb28becead81111ee2cadd97/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaa054e53c4d43cf047c1b1eeadaedb0eb5a212c", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaa054e53c4d43cf047c1b1eeadaedb0eb5a212c", "html_url": "https://github.com/rust-lang/rust/commit/aaa054e53c4d43cf047c1b1eeadaedb0eb5a212c"}, {"sha": "a0e4c1695854db9bf2f4aae3229026608675307d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0e4c1695854db9bf2f4aae3229026608675307d", "html_url": "https://github.com/rust-lang/rust/commit/a0e4c1695854db9bf2f4aae3229026608675307d"}], "stats": {"total": 254, "additions": 94, "deletions": 160}, "files": [{"sha": "c5a30f8bac86d1687919e0e11a1ea28d1d10b1cd", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/879c17f3f9a460e8bb28becead81111ee2cadd97/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879c17f3f9a460e8bb28becead81111ee2cadd97/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=879c17f3f9a460e8bb28becead81111ee2cadd97", "patch": "@@ -1250,19 +1250,21 @@ compat_fn_with_fallback! {\n     }\n }\n \n-compat_fn_optional! {\n+compat_fn_with_fallback! {\n     pub static SYNCH_API: &CStr = ansi_str!(\"api-ms-win-core-synch-l1-2-0\");\n-\n-    // >= Windows 8 / Server 2012\n-    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress\n-    pub fn WaitOnAddress(\n-        Address: LPVOID,\n-        CompareAddress: LPVOID,\n-        AddressSize: SIZE_T,\n-        dwMilliseconds: DWORD\n-    ) -> BOOL;\n-    pub fn WakeByAddressSingle(Address: LPVOID) -> ();\n+    #[allow(unused)]\n+    fn WakeByAddressSingle(Address: LPVOID) -> () {\n+        // This fallback is currently tightly coupled to its use in Parker::unpark.\n+        //\n+        // FIXME: If `WakeByAddressSingle` needs to be used anywhere other than\n+        // Parker::unpark then this fallback will be wrong and will need to be decoupled.\n+        crate::sys::windows::thread_parker::unpark_keyed_event(Address)\n+    }\n }\n+pub use crate::sys::compat::WaitOnAddress;\n+// Change exported name of `WakeByAddressSingle` to make the strange fallback\n+// behaviour clear.\n+pub use WakeByAddressSingle::call as wake_by_address_single_or_unpark_keyed_event;\n \n compat_fn_with_fallback! {\n     pub static NTDLL: &CStr = ansi_str!(\"ntdll\");"}, {"sha": "473544c4d4f7b99c231209dba5a1765cdacc3fd6", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 65, "deletions": 134, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/879c17f3f9a460e8bb28becead81111ee2cadd97/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879c17f3f9a460e8bb28becead81111ee2cadd97/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=879c17f3f9a460e8bb28becead81111ee2cadd97", "patch": "@@ -7,47 +7,17 @@\n //! `GetModuleHandle` and `GetProcAddress` to look up DLL entry points at\n //! runtime.\n //!\n-//! This implementation uses a static initializer to look up the DLL entry\n-//! points. The CRT (C runtime) executes static initializers before `main`\n-//! is called (for binaries) and before `DllMain` is called (for DLLs).\n-//! This is the ideal time to look up DLL imports, because we are guaranteed\n-//! that no other threads will attempt to call these entry points. Thus,\n-//! we can look up the imports and store them in `static mut` fields\n-//! without any synchronization.\n+//! This is implemented simply by storing a function pointer in an atomic.\n+//! Loading and calling this function will have little or no overhead\n+//! compared with calling any other dynamically imported function.\n //!\n-//! This has an additional advantage: Because the DLL import lookup happens\n-//! at module initialization, the cost of these lookups is deterministic,\n-//! and is removed from the code paths that actually call the DLL imports.\n-//! That is, there is no unpredictable \"cache miss\" that occurs when calling\n-//! a DLL import. For applications that benefit from predictable delays,\n-//! this is a benefit. This also eliminates the comparison-and-branch\n-//! from the hot path.\n-//!\n-//! Currently, the standard library uses only a small number of dynamic\n-//! DLL imports. If this number grows substantially, then the cost of\n-//! performing all of the lookups at initialization time might become\n-//! substantial.\n-//!\n-//! The mechanism of registering a static initializer with the CRT is\n-//! documented in\n-//! [CRT Initialization](https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-160).\n-//! It works by contributing a global symbol to the `.CRT$XCU` section.\n-//! The linker builds a table of all static initializer functions.\n-//! The CRT startup code then iterates that table, calling each\n-//! initializer function.\n-//!\n-//! # **WARNING!!*\n-//! The environment that a static initializer function runs in is highly\n-//! constrained. There are **many** restrictions on what static initializers\n-//! can safely do. Static initializer functions **MUST NOT** do any of the\n-//! following (this list is not comprehensive):\n-//! * touch any other static field that is used by a different static\n-//!   initializer, because the order that static initializers run in\n-//!   is not defined.\n-//! * call `LoadLibrary` or any other function that acquires the DLL\n-//!   loader lock.\n-//! * call any Rust function or CRT function that touches any static\n-//!   (global) state.\n+//! The stored function pointer starts out as an importer function which will\n+//! swap itself with the real function when it's called for the first time. If\n+//! the real function can't be imported then a fallback function is used in its\n+//! place. While this is low cost for the happy path (where the function is\n+//! already loaded) it does mean there's some overhead the first time the\n+//! function is called. In the worst case, multiple threads may all end up\n+//! importing the same function unnecessarily.\n \n use crate::ffi::{c_void, CStr};\n use crate::ptr::NonNull;\n@@ -85,39 +55,6 @@ pub(crate) const fn const_cstr_from_bytes(bytes: &'static [u8]) -> &'static CStr\n     unsafe { crate::ffi::CStr::from_bytes_with_nul_unchecked(bytes) }\n }\n \n-#[used]\n-#[link_section = \".CRT$XCU\"]\n-static INIT_TABLE_ENTRY: unsafe extern \"C\" fn() = init;\n-\n-/// This is where the magic preloading of symbols happens.\n-///\n-/// Note that any functions included here will be unconditionally included in\n-/// the final binary, regardless of whether or not they're actually used.\n-///\n-/// Therefore, this is limited to `compat_fn_optional` functions which must be\n-/// preloaded and any functions which may be more time sensitive, even for the first call.\n-unsafe extern \"C\" fn init() {\n-    // There is no locking here. This code is executed before main() is entered, and\n-    // is guaranteed to be single-threaded.\n-    //\n-    // DO NOT do anything interesting or complicated in this function! DO NOT call\n-    // any Rust functions or CRT functions if those functions touch any global state,\n-    // because this function runs during global initialization. For example, DO NOT\n-    // do any dynamic allocation, don't call LoadLibrary, etc.\n-\n-    if let Some(synch) = Module::new(c::SYNCH_API) {\n-        // These are optional and so we must manually attempt to load them\n-        // before they can be used.\n-        c::WaitOnAddress::preload(synch);\n-        c::WakeByAddressSingle::preload(synch);\n-    }\n-\n-    if let Some(kernel32) = Module::new(c::KERNEL32) {\n-        // Preloading this means getting a precise time will be as fast as possible.\n-        c::GetSystemTimePreciseAsFileTime::preload(kernel32);\n-    }\n-}\n-\n /// Represents a loaded module.\n ///\n /// Note that the modules std depends on must not be unloaded.\n@@ -151,7 +88,7 @@ impl Module {\n macro_rules! compat_fn_with_fallback {\n     (pub static $module:ident: &CStr = $name:expr; $(\n         $(#[$meta:meta])*\n-        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $fallback_body:block\n+        $vis:vis fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $fallback_body:block\n     )*) => (\n         pub static $module: &CStr = $name;\n     $(\n@@ -196,78 +133,72 @@ macro_rules! compat_fn_with_fallback {\n                 $fallback_body\n             }\n \n-            #[allow(unused)]\n-            pub(in crate::sys) fn preload(module: Module) {\n-                load_from_module(Some(module));\n-            }\n-\n             #[inline(always)]\n             pub unsafe fn call($($argname: $argtype),*) -> $rettype {\n                 let func: F = mem::transmute(PTR.load(Ordering::Relaxed));\n                 func($($argname),*)\n             }\n         }\n         $(#[$meta])*\n-        pub use $symbol::call as $symbol;\n+        $vis use $symbol::call as $symbol;\n     )*)\n }\n \n-/// A function that either exists or doesn't.\n+/// Optionally load `WaitOnAddress`.\n+/// Unlike the dynamic loading described above, this does not have a fallback.\n ///\n-/// NOTE: Optional functions must be preloaded in the `init` function above, or they will always be None.\n-macro_rules! compat_fn_optional {\n-    (pub static $module:ident: &CStr = $name:expr; $(\n-        $(#[$meta:meta])*\n-        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty;\n-    )*) => (\n-        pub static $module: &CStr = $name;\n-    $(\n-        $(#[$meta])*\n-        pub mod $symbol {\n-            #[allow(unused_imports)]\n-            use super::*;\n-            use crate::mem;\n-            use crate::sync::atomic::{AtomicPtr, Ordering};\n-            use crate::sys::compat::Module;\n-            use crate::ptr::{self, NonNull};\n-\n-            type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n-\n-            /// `PTR` will either be `null()` or set to the loaded function.\n-            static PTR: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n-\n-            /// Only allow access to the function if it has loaded successfully.\n-            #[inline(always)]\n-            #[cfg(not(miri))]\n-            pub fn option() -> Option<F> {\n-                unsafe {\n-                    NonNull::new(PTR.load(Ordering::Relaxed)).map(|f| mem::transmute(f))\n-                }\n-            }\n-\n-            // Miri does not understand the way we do preloading\n-            // therefore load the function here instead.\n-            #[cfg(miri)]\n-            pub fn option() -> Option<F> {\n-                let mut func = NonNull::new(PTR.load(Ordering::Relaxed));\n-                if func.is_none() {\n-                    unsafe { Module::new($module).map(preload) };\n-                    func = NonNull::new(PTR.load(Ordering::Relaxed));\n-                }\n-                unsafe {\n-                    func.map(|f| mem::transmute(f))\n-                }\n-            }\n+/// This is rexported from sys::c. You should prefer to import\n+/// from there in case this changes again in the future.\n+pub mod WaitOnAddress {\n+    use super::*;\n+    use crate::mem;\n+    use crate::ptr;\n+    use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n+    use crate::sys::c;\n+\n+    static MODULE_NAME: &CStr = ansi_str!(\"api-ms-win-core-synch-l1-2-0\");\n+    static SYMBOL_NAME: &CStr = ansi_str!(\"WaitOnAddress\");\n+\n+    // WaitOnAddress function signature.\n+    type F = unsafe extern \"system\" fn(\n+        Address: c::LPVOID,\n+        CompareAddress: c::LPVOID,\n+        AddressSize: c::SIZE_T,\n+        dwMilliseconds: c::DWORD,\n+    );\n+\n+    // A place to store the loaded function atomically.\n+    static WAIT_ON_ADDRESS: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n+\n+    // We can skip trying to load again if we already tried.\n+    static LOAD_MODULE: AtomicBool = AtomicBool::new(true);\n+\n+    #[inline(always)]\n+    pub fn option() -> Option<F> {\n+        let f = WAIT_ON_ADDRESS.load(Ordering::Acquire);\n+        if !f.is_null() { Some(unsafe { mem::transmute(f) }) } else { try_load() }\n+    }\n \n-            #[allow(unused)]\n-            pub(in crate::sys) fn preload(module: Module) {\n-                unsafe {\n-                    static SYMBOL_NAME: &CStr = ansi_str!(sym $symbol);\n-                    if let Some(f) = module.proc_address(SYMBOL_NAME) {\n-                        PTR.store(f.as_ptr(), Ordering::Relaxed);\n-                    }\n-                }\n+    #[cold]\n+    fn try_load() -> Option<F> {\n+        if LOAD_MODULE.load(Ordering::Acquire) {\n+            // load the module\n+            let mut wait_on_address = None;\n+            if let Some(func) = try_load_inner() {\n+                WAIT_ON_ADDRESS.store(func.as_ptr(), Ordering::Release);\n+                wait_on_address = Some(unsafe { mem::transmute(func) });\n             }\n+            // Don't try to load the module again even if loading failed.\n+            LOAD_MODULE.store(false, Ordering::Release);\n+            wait_on_address\n+        } else {\n+            None\n         }\n-    )*)\n+    }\n+\n+    // In the future this could be a `try` block but until then I think it's a\n+    // little bit cleaner as a separate function.\n+    fn try_load_inner() -> Option<NonNull<c_void>> {\n+        unsafe { Module::new(MODULE_NAME)?.proc_address(SYMBOL_NAME) }\n+    }\n }"}, {"sha": "16863c9903ac7f76a5947fd2b386941c19575fcd", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/879c17f3f9a460e8bb28becead81111ee2cadd97/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879c17f3f9a460e8bb28becead81111ee2cadd97/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=879c17f3f9a460e8bb28becead81111ee2cadd97", "patch": "@@ -197,21 +197,9 @@ impl Parker {\n         // purpose, to make sure every unpark() has a release-acquire ordering\n         // with park().\n         if self.state.swap(NOTIFIED, Release) == PARKED {\n-            if let Some(wake_by_address_single) = c::WakeByAddressSingle::option() {\n-                unsafe {\n-                    wake_by_address_single(self.ptr());\n-                }\n-            } else {\n-                // If we run NtReleaseKeyedEvent before the waiting thread runs\n-                // NtWaitForKeyedEvent, this (shortly) blocks until we can wake it up.\n-                // If the waiting thread wakes up before we run NtReleaseKeyedEvent\n-                // (e.g. due to a timeout), this blocks until we do wake up a thread.\n-                // To prevent this thread from blocking indefinitely in that case,\n-                // park_impl() will, after seeing the state set to NOTIFIED after\n-                // waking up, call NtWaitForKeyedEvent again to unblock us.\n-                unsafe {\n-                    c::NtReleaseKeyedEvent(keyed_event_handle(), self.ptr(), 0, ptr::null_mut());\n-                }\n+            unsafe {\n+                // This calls either WakeByAddressSingle or unpark_keyed_event (see below).\n+                c::wake_by_address_single_or_unpark_keyed_event(self.ptr());\n             }\n         }\n     }\n@@ -221,6 +209,19 @@ impl Parker {\n     }\n }\n \n+// This function signature makes it compatible with c::WakeByAddressSingle\n+// so that it can be used as a fallback for that function.\n+pub unsafe extern \"C\" fn unpark_keyed_event(address: c::LPVOID) {\n+    // If we run NtReleaseKeyedEvent before the waiting thread runs\n+    // NtWaitForKeyedEvent, this (shortly) blocks until we can wake it up.\n+    // If the waiting thread wakes up before we run NtReleaseKeyedEvent\n+    // (e.g. due to a timeout), this blocks until we do wake up a thread.\n+    // To prevent this thread from blocking indefinitely in that case,\n+    // park_impl() will, after seeing the state set to NOTIFIED after\n+    // waking up, call NtWaitForKeyedEvent again to unblock us.\n+    c::NtReleaseKeyedEvent(keyed_event_handle(), address, 0, ptr::null_mut());\n+}\n+\n fn keyed_event_handle() -> c::HANDLE {\n     const INVALID: c::HANDLE = ptr::invalid_mut(!0);\n     static HANDLE: AtomicPtr<libc::c_void> = AtomicPtr::new(INVALID);"}]}