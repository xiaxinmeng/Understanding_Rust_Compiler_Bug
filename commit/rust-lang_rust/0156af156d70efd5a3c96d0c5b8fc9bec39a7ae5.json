{"sha": "0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNTZhZjE1NmQ3MGVmZDVhM2M5NmQwYzViOGZjOWJlYzM5YTdhZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-10T22:31:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-10T22:31:55Z"}, "message": "auto merge of #13443 : alexcrichton/rust/rollup, r=alexcrichton\n\nCloses #13441 (debuginfo: Fixes and improvements for #12840, #12886, and #13213)\r\nCloses #13433 (Remove references to @Trait from a compiler error message)\r\nCloses #13430 (Fix outdated lint warning about inner attribute)\r\nCloses #13425 (Remove a pile of (mainly) internal `~[]` uses)\r\nCloses #13419 (Stop using transmute_mut in RefCell)\r\nCloses #13417 (Remove an unnecessary file `src/libnative/io/p`.)\r\nCloses #13409 (Closing assorted resolve bugs)\r\nCloses #13406 (Generalized the pretty-print entry points to support `-o <file>`.)\r\nCloses #13403 (test: Add a test for #7663)\r\nCloses #13402 (rustdoc: Prune the paths that do not appear in the index.)\r\nCloses #13396 (rustc: Remove absolute rpaths)\r\nCloses #13371 (Rename ast::Purity and ast::Impure Function. Closes #7287)\r\nCloses #13350 (collections: replace all ~[T] with Vec<T>.)", "tree": {"sha": "7cae8ac126922eee38607c2a0032c85cdad7ba0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cae8ac126922eee38607c2a0032c85cdad7ba0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "html_url": "https://github.com/rust-lang/rust/commit/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bcb76181a3b0df2df5ade348af3a1d29fca795e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bcb76181a3b0df2df5ade348af3a1d29fca795e", "html_url": "https://github.com/rust-lang/rust/commit/5bcb76181a3b0df2df5ade348af3a1d29fca795e"}, {"sha": "1f2c18a0afd55bf3a5319d9e3810ec1ac6b3e1bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f2c18a0afd55bf3a5319d9e3810ec1ac6b3e1bb", "html_url": "https://github.com/rust-lang/rust/commit/1f2c18a0afd55bf3a5319d9e3810ec1ac6b3e1bb"}], "stats": {"total": 1775, "additions": 1127, "deletions": 648}, "files": [{"sha": "ddc3b175d101526552b3e7d1c8eebd9c9622d586", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -269,6 +269,7 @@ LIB_DOC_DEP_$(1) = $$(CRATEFILE_$(1)) $$(RSINPUTS_$(1))\n endif\n \n $(2) += doc/$(1)/index.html\n+doc/$(1)/index.html: CFG_COMPILER_HOST_TRIPLE = $(CFG_TARGET)\n doc/$(1)/index.html: $$(LIB_DOC_DEP_$(1))\n \t@$$(call E, rustdoc $$@)\n \t$$(Q)$$(RUSTDOC) --cfg dox --cfg stage2 $$<"}, {"sha": "f2bcdbd4bd539fd1aae0ba2cea7033fdeaaa032f", "filename": "mk/main.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -358,17 +358,13 @@ CFGFLAG$(1)_T_$(2)_H_$(3) = stage1\n endif\n endif\n \n-ifdef CFG_DISABLE_RPATH\n ifeq ($$(OSTYPE_$(3)),apple-darwin)\n   RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n       DYLD_LIBRARY_PATH=\"$$$$DYLD_LIBRARY_PATH:$$(CURDIR)/$$(HLIB$(1)_H_$(3))\"\n else\n   RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n       LD_LIBRARY_PATH=\"$$$$LD_LIBRARY_PATH:$$(CURDIR)/$$(HLIB$(1)_H_$(3))\"\n endif\n-else\n-    RPATH_VAR$(1)_T_$(2)_H_$(3) :=\n-endif\n \n STAGE$(1)_T_$(2)_H_$(3) := \t\t\t\t\t\t\\\n \t$$(Q)$$(RPATH_VAR$(1)_T_$(2)_H_$(3))                            \\"}, {"sha": "c605596b9629ea54432e15cfc8900cc21b73e5af", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -451,7 +451,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         let options_to_remove = [~\"-O\", ~\"-g\", ~\"--debuginfo\"];\n         let new_options = split_maybe_args(options).move_iter()\n                                                    .filter(|x| !options_to_remove.contains(x))\n-                                                   .collect::<~[~str]>()\n+                                                   .collect::<Vec<~str>>()\n                                                    .connect(\" \");\n         Some(new_options)\n     }"}, {"sha": "ea5ffb9965a0f91fe4f05c5dfb3d40024593f98f", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -117,13 +117,13 @@ mod tests {\n             words.push(r.gen_vec::<u8>(range));\n         }\n         for _ in range(0, 20) {\n-            let mut input = ~[];\n+            let mut input = vec![];\n             for _ in range(0, 2000) {\n                 input.push_all(r.choose(words.as_slice()).as_slice());\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n-            let cmp = deflate_bytes(input).expect(\"deflation failed\");\n+            let cmp = deflate_bytes(input.as_slice()).expect(\"deflation failed\");\n             let out = inflate_bytes(cmp.as_slice()).expect(\"inflation failed\");\n             debug!(\"{} bytes deflated to {} ({:.1f}% size)\",\n                    input.len(), cmp.len(),"}, {"sha": "52fbcc0cb1cab659243401f1f1fc03b21f182a59", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -53,7 +53,7 @@\n //!\n //!     let program = args[0].clone();\n //!\n-//!     let opts = ~[\n+//!     let opts = [\n //!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),\n //!         optflag(\"h\", \"help\", \"print this help menu\")\n //!     ];"}, {"sha": "ca1fd2b560ec8689ee88741bb4887fbfba1cc0ae", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -31,6 +31,8 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n \n+#![deny(deprecated_owned_vector)]\n+\n use std::cell::Cell;\n use std::{cmp, os, path};\n use std::io::fs;\n@@ -245,26 +247,26 @@ impl Pattern {\n      */\n     pub fn new(pattern: &str) -> Pattern {\n \n-        let chars = pattern.chars().collect::<~[_]>();\n+        let chars = pattern.chars().collect::<Vec<_>>();\n         let mut tokens = Vec::new();\n         let mut i = 0;\n \n         while i < chars.len() {\n-            match chars[i] {\n+            match *chars.get(i) {\n                 '?' => {\n                     tokens.push(AnyChar);\n                     i += 1;\n                 }\n                 '*' => {\n                     // *, **, ***, ****, ... are all equivalent\n-                    while i < chars.len() && chars[i] == '*' {\n+                    while i < chars.len() && *chars.get(i) == '*' {\n                         i += 1;\n                     }\n                     tokens.push(AnySequence);\n                 }\n                 '[' => {\n \n-                    if i <= chars.len() - 4 && chars[i + 1] == '!' {\n+                    if i <= chars.len() - 4 && *chars.get(i + 1) == '!' {\n                         match chars.slice_from(i + 3).position_elem(&']') {\n                             None => (),\n                             Some(j) => {\n@@ -276,7 +278,7 @@ impl Pattern {\n                             }\n                         }\n                     }\n-                    else if i <= chars.len() - 3 && chars[i + 1] != '!' {\n+                    else if i <= chars.len() - 3 && *chars.get(i + 1) != '!' {\n                         match chars.slice_from(i + 2).position_elem(&']') {\n                             None => (),\n                             Some(j) => {"}, {"sha": "2877768dd8bfe1aee20e3fc9aae592e8a4a5e742", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -27,30 +27,30 @@ pub fn event_loop() -> ~EventLoop:Send {\n }\n \n struct BasicLoop {\n-    work: ~[proc():Send],             // pending work\n+    work: Vec<proc():Send>,             // pending work\n     idle: Option<*mut BasicPausable>, // only one is allowed\n-    remotes: ~[(uint, ~Callback:Send)],\n+    remotes: Vec<(uint, ~Callback:Send)>,\n     next_remote: uint,\n-    messages: Exclusive<~[Message]>,\n+    messages: Exclusive<Vec<Message>>,\n }\n \n enum Message { RunRemote(uint), RemoveRemote(uint) }\n \n impl BasicLoop {\n     fn new() -> BasicLoop {\n         BasicLoop {\n-            work: ~[],\n+            work: vec![],\n             idle: None,\n             next_remote: 0,\n-            remotes: ~[],\n-            messages: Exclusive::new(~[]),\n+            remotes: vec![],\n+            messages: Exclusive::new(vec![]),\n         }\n     }\n \n     /// Process everything in the work queue (continually)\n     fn work(&mut self) {\n         while self.work.len() > 0 {\n-            for work in replace(&mut self.work, ~[]).move_iter() {\n+            for work in replace(&mut self.work, vec![]).move_iter() {\n                 work();\n             }\n         }\n@@ -60,7 +60,7 @@ impl BasicLoop {\n         let messages = unsafe {\n             self.messages.with(|messages| {\n                 if messages.len() > 0 {\n-                    Some(replace(messages, ~[]))\n+                    Some(replace(messages, vec![]))\n                 } else {\n                     None\n                 }\n@@ -165,12 +165,12 @@ impl EventLoop for BasicLoop {\n }\n \n struct BasicRemote {\n-    queue: Exclusive<~[Message]>,\n+    queue: Exclusive<Vec<Message>>,\n     id: uint,\n }\n \n impl BasicRemote {\n-    fn new(queue: Exclusive<~[Message]>, id: uint) -> BasicRemote {\n+    fn new(queue: Exclusive<Vec<Message>>, id: uint) -> BasicRemote {\n         BasicRemote { queue: queue, id: id }\n     }\n }"}, {"sha": "820627b6b7d13d8d395f04449926b90248608a06", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -195,6 +195,7 @@\n // NB this does *not* include globs, please keep it that way.\n #![feature(macro_rules, phase)]\n #![allow(visible_private_types)]\n+#![deny(deprecated_owned_vector)]\n \n #[cfg(test)] #[phase(syntax, link)] extern crate log;\n #[cfg(test)] extern crate rustuv;\n@@ -209,7 +210,6 @@ use std::rt;\n use std::sync::atomics::{SeqCst, AtomicUint, INIT_ATOMIC_UINT};\n use std::sync::deque;\n use std::task::TaskOpts;\n-use std::slice;\n use std::sync::arc::UnsafeArc;\n \n use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, NewNeighbor};\n@@ -318,9 +318,9 @@ impl PoolConfig {\n /// used to keep the pool alive and also reap the status from the pool.\n pub struct SchedPool {\n     id: uint,\n-    threads: ~[Thread<()>],\n-    handles: ~[SchedHandle],\n-    stealers: ~[deque::Stealer<~task::GreenTask>],\n+    threads: Vec<Thread<()>>,\n+    handles: Vec<SchedHandle>,\n+    stealers: Vec<deque::Stealer<~task::GreenTask>>,\n     next_friend: uint,\n     stack_pool: StackPool,\n     deque_pool: deque::BufferPool<~task::GreenTask>,\n@@ -356,9 +356,9 @@ impl SchedPool {\n         // The pool of schedulers that will be returned from this function\n         let (p, state) = TaskState::new();\n         let mut pool = SchedPool {\n-            threads: ~[],\n-            handles: ~[],\n-            stealers: ~[],\n+            threads: vec![],\n+            handles: vec![],\n+            stealers: vec![],\n             id: unsafe { POOL_ID.fetch_add(1, SeqCst) },\n             sleepers: SleeperList::new(),\n             stack_pool: StackPool::new(),\n@@ -371,8 +371,14 @@ impl SchedPool {\n \n         // Create a work queue for each scheduler, ntimes. Create an extra\n         // for the main thread if that flag is set. We won't steal from it.\n-        let arr = slice::from_fn(nscheds, |_| pool.deque_pool.deque());\n-        let (workers, stealers) = slice::unzip(arr.move_iter());\n+        let mut workers = Vec::with_capacity(nscheds);\n+        let mut stealers = Vec::with_capacity(nscheds);\n+\n+        for _ in range(0, nscheds) {\n+            let (w, s) = pool.deque_pool.deque();\n+            workers.push(w);\n+            stealers.push(s);\n+        }\n         pool.stealers = stealers;\n \n         // Now that we've got all our work queues, create one scheduler per\n@@ -420,7 +426,7 @@ impl SchedPool {\n         }\n \n         // Jettison the task away!\n-        self.handles[idx].send(TaskFromFriend(task));\n+        self.handles.get_mut(idx).send(TaskFromFriend(task));\n     }\n \n     /// Spawns a new scheduler into this M:N pool. A handle is returned to the\n@@ -466,7 +472,7 @@ impl SchedPool {\n     /// This only waits for all tasks in *this pool* of schedulers to exit, any\n     /// native tasks or extern pools will not be waited on\n     pub fn shutdown(mut self) {\n-        self.stealers = ~[];\n+        self.stealers = vec![];\n \n         // Wait for everyone to exit. We may have reached a 0-task count\n         // multiple times in the past, meaning there could be several buffered\n@@ -478,10 +484,10 @@ impl SchedPool {\n         }\n \n         // Now that everyone's gone, tell everything to shut down.\n-        for mut handle in replace(&mut self.handles, ~[]).move_iter() {\n+        for mut handle in replace(&mut self.handles, vec![]).move_iter() {\n             handle.send(Shutdown);\n         }\n-        for thread in replace(&mut self.threads, ~[]).move_iter() {\n+        for thread in replace(&mut self.threads, vec![]).move_iter() {\n             thread.join();\n         }\n     }"}, {"sha": "9971dfee828157e0c5f5a05af6138705e62d0d73", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -49,7 +49,7 @@ pub struct Scheduler {\n     work_queue: deque::Worker<~GreenTask>,\n     /// Work queues for the other schedulers. These are created by\n     /// cloning the core work queues.\n-    work_queues: ~[deque::Stealer<~GreenTask>],\n+    work_queues: Vec<deque::Stealer<~GreenTask>>,\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n@@ -125,7 +125,7 @@ impl Scheduler {\n     pub fn new(pool_id: uint,\n                event_loop: ~EventLoop:Send,\n                work_queue: deque::Worker<~GreenTask>,\n-               work_queues: ~[deque::Stealer<~GreenTask>],\n+               work_queues: Vec<deque::Stealer<~GreenTask>>,\n                sleeper_list: SleeperList,\n                state: TaskState)\n         -> Scheduler {\n@@ -138,7 +138,7 @@ impl Scheduler {\n     pub fn new_special(pool_id: uint,\n                        event_loop: ~EventLoop:Send,\n                        work_queue: deque::Worker<~GreenTask>,\n-                       work_queues: ~[deque::Stealer<~GreenTask>],\n+                       work_queues: Vec<deque::Stealer<~GreenTask>>,\n                        sleeper_list: SleeperList,\n                        run_anything: bool,\n                        friend: Option<SchedHandle>,\n@@ -502,7 +502,7 @@ impl Scheduler {\n         let len = work_queues.len();\n         let start_index = self.rng.gen_range(0, len);\n         for index in range(0, len).map(|i| (i + start_index) % len) {\n-            match work_queues[index].steal() {\n+            match work_queues.get_mut(index).steal() {\n                 deque::Data(task) => {\n                     rtdebug!(\"found task by stealing\");\n                     return Some(task)\n@@ -1137,7 +1137,7 @@ mod test {\n             let mut pool = BufferPool::new();\n             let (normal_worker, normal_stealer) = pool.deque();\n             let (special_worker, special_stealer) = pool.deque();\n-            let queues = ~[normal_stealer, special_stealer];\n+            let queues = vec![normal_stealer, special_stealer];\n             let (_p, state) = TaskState::new();\n \n             // Our normal scheduler\n@@ -1326,7 +1326,7 @@ mod test {\n     #[test]\n     fn multithreading() {\n         run(proc() {\n-            let mut rxs = ~[];\n+            let mut rxs = vec![];\n             for _ in range(0, 10) {\n                 let (tx, rx) = channel();\n                 spawn(proc() {"}, {"sha": "1f06ba379f0fa00c9c8a27a341a1430c5f9aaac4", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -126,13 +126,13 @@ impl Drop for Stack {\n pub struct StackPool {\n     // Ideally this would be some datastructure that preserved ordering on\n     // Stack.min_size.\n-    stacks: ~[Stack],\n+    stacks: Vec<Stack>,\n }\n \n impl StackPool {\n     pub fn new() -> StackPool {\n         StackPool {\n-            stacks: ~[],\n+            stacks: vec![],\n         }\n     }\n "}, {"sha": "18e815e9b7c03001cff84de8dc205ca9bbd5c7ed", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -146,7 +146,7 @@ pub use types::os::arch::c95::{c_ushort, clock_t, ptrdiff_t};\n pub use types::os::arch::c95::{size_t, time_t};\n pub use types::os::arch::c99::{c_longlong, c_ulonglong, intptr_t};\n pub use types::os::arch::c99::{uintptr_t};\n-pub use types::os::arch::posix88::{dev_t, dirent_t, ino_t, mode_t};\n+pub use types::os::arch::posix88::{dev_t, ino_t, mode_t};\n pub use types::os::arch::posix88::{off_t, pid_t, ssize_t};\n \n pub use consts::os::c95::{_IOFBF, _IOLBF, _IONBF, BUFSIZ, EOF};"}, {"sha": "5446ab2950e44bb136787d31f9c3a7886b7eb92a", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -340,11 +340,11 @@ pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n     }))\n }\n \n-pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n+pub fn readdir(p: &CString) -> IoResult<Vec<Path>> {\n     use libc::{dirent_t};\n     use libc::{opendir, readdir_r, closedir};\n \n-    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n+    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> {\n         let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n         let root = Path::new(root);\n \n@@ -365,7 +365,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n     let dir_ptr = p.with_ref(|buf| unsafe { opendir(buf) });\n \n     if dir_ptr as uint != 0 {\n-        let mut paths = ~[];\n+        let mut paths = vec!();\n         let mut entry_ptr = 0 as *mut dirent_t;\n         while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n             if entry_ptr.is_null() { break }\n@@ -571,4 +571,3 @@ mod tests {\n         }\n     }\n }\n-"}, {"sha": "de515659bf7adc3c87d94899a92191f5f5aaf8c4", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -323,10 +323,10 @@ pub fn mkdir(p: &CString, _mode: io::FilePermission) -> IoResult<()> {\n     })\n }\n \n-pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n-    use rt::global_heap::malloc_raw;\n+pub fn readdir(p: &CString) -> IoResult<Vec<Path>> {\n+    use std::rt::global_heap::malloc_raw;\n \n-    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n+    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> {\n         let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n         let root = Path::new(root);\n \n@@ -346,7 +346,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n         let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n         let find_handle = libc::FindFirstFileW(path_ptr, wfd_ptr as libc::HANDLE);\n         if find_handle as libc::c_int != libc::INVALID_HANDLE_VALUE {\n-            let mut paths = ~[];\n+            let mut paths = vec!();\n             let mut more_files = 1 as libc::c_int;\n             while more_files != 0 {\n                 let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *c_void);"}, {"sha": "cc432555abb92923213bcb4e6510e6b33d8a1505", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -217,7 +217,7 @@ impl rtio::IoFactory for IoFactory {\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> {\n         file::rename(path, to)\n     }\n-    fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<~[Path]> {\n+    fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<Vec<Path>> {\n         file::readdir(path)\n     }\n     fn fs_lstat(&mut self, path: &CString) -> IoResult<io::FileStat> {"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/libnative/io/p", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5bcb76181a3b0df2df5ade348af3a1d29fca795e/src%2Flibnative%2Fio%2Fp", "raw_url": "https://github.com/rust-lang/rust/raw/5bcb76181a3b0df2df5ade348af3a1d29fca795e/src%2Flibnative%2Fio%2Fp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fp?ref=5bcb76181a3b0df2df5ade348af3a1d29fca795e"}, {"sha": "569b4cbb258e0fa0b2d2f097c65e6e20a1ff208a", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -102,19 +102,19 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n     // active timers are those which are able to be selected upon (and it's a\n     // sorted list, and dead timers are those which have expired, but ownership\n     // hasn't yet been transferred back to the timer itself.\n-    let mut active: ~[~Inner] = ~[];\n-    let mut dead = ~[];\n+    let mut active: Vec<~Inner> = vec![];\n+    let mut dead = vec![];\n \n     // inserts a timer into an array of timers (sorted by firing time)\n-    fn insert(t: ~Inner, active: &mut ~[~Inner]) {\n+    fn insert(t: ~Inner, active: &mut Vec<~Inner>) {\n         match active.iter().position(|tm| tm.target > t.target) {\n             Some(pos) => { active.insert(pos, t); }\n             None => { active.push(t); }\n         }\n     }\n \n     // signals the first requests in the queue, possible re-enqueueing it.\n-    fn signal(active: &mut ~[~Inner], dead: &mut ~[(uint, ~Inner)]) {\n+    fn signal(active: &mut Vec<~Inner>, dead: &mut Vec<(uint, ~Inner)>) {\n         let mut timer = match active.shift() {\n             Some(timer) => timer, None => return\n         };\n@@ -137,15 +137,15 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n             let now = now();\n             // If this request has already expired, then signal it and go\n             // through another iteration\n-            if active[0].target <= now {\n+            if active.get(0).target <= now {\n                 signal(&mut active, &mut dead);\n                 continue;\n             }\n \n             // The actual timeout listed in the requests array is an\n             // absolute date, so here we translate the absolute time to a\n             // relative time.\n-            let tm = active[0].target - now;\n+            let tm = active.get(0).target - now;\n             timeout.tv_sec = (tm / 1000) as libc::time_t;\n             timeout.tv_usec = ((tm % 1000) * 1000) as libc::suseconds_t;\n             &timeout as *libc::timeval"}, {"sha": "d37a39fc30e8d6aa11774d1b9a9e6020daa9cc18", "filename": "src/libnative/io/timer_timerfd.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -76,7 +76,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n \n     add(efd, input);\n     let events: [imp::epoll_event, ..16] = unsafe { mem::init() };\n-    let mut list: ~[(libc::c_int, Sender<()>, bool)] = ~[];\n+    let mut list: Vec<(libc::c_int, Sender<()>, bool)> = vec![];\n     'outer: loop {\n         let n = match unsafe {\n             imp::epoll_wait(efd, events.as_ptr(),\n@@ -104,9 +104,9 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n                 //      times?\n                 let _ = FileDesc::new(fd, false).inner_read(bits).unwrap();\n                 let (remove, i) = {\n-                    match list.bsearch(|&(f, _, _)| f.cmp(&fd)) {\n+                    match list.as_slice().bsearch(|&(f, _, _)| f.cmp(&fd)) {\n                         Some(i) => {\n-                            let (_, ref c, oneshot) = list[i];\n+                            let (_, ref c, oneshot) = *list.get(i);\n                             (!c.try_send(()) || oneshot, i)\n                         }\n                         None => fail!(\"fd not active: {}\", fd),\n@@ -128,9 +128,9 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n \n                     // If we haven't previously seen the file descriptor, then\n                     // we need to add it to the epoll set.\n-                    match list.bsearch(|&(f, _, _)| f.cmp(&fd)) {\n+                    match list.as_slice().bsearch(|&(f, _, _)| f.cmp(&fd)) {\n                         Some(i) => {\n-                            drop(mem::replace(&mut list[i], (fd, chan, one)));\n+                            drop(mem::replace(list.get_mut(i), (fd, chan, one)));\n                         }\n                         None => {\n                             match list.iter().position(|&(f, _, _)| f >= fd) {\n@@ -150,7 +150,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n                 }\n \n                 Data(RemoveTimer(fd, chan)) => {\n-                    match list.bsearch(|&(f, _, _)| f.cmp(&fd)) {\n+                    match list.as_slice().bsearch(|&(f, _, _)| f.cmp(&fd)) {\n                         Some(i) => {\n                             drop(list.remove(i));\n                             del(efd, fd);"}, {"sha": "8b7592783da044dbaada0ff9125f34630e5d21fd", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -40,8 +40,8 @@ pub enum Req {\n }\n \n fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n-    let mut objs = ~[input];\n-    let mut chans = ~[];\n+    let mut objs = vec![input];\n+    let mut chans = vec![];\n \n     'outer: loop {\n         let idx = unsafe {\n@@ -78,7 +78,7 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n             }\n         } else {\n             let remove = {\n-                match &chans[idx as uint - 1] {\n+                match chans.get(idx as uint - 1) {\n                     &(ref c, oneshot) => !c.try_send(()) || oneshot\n                 }\n             };"}, {"sha": "e455c4ad23ce00851f86f07354c7e2e840c6be24", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 8, "deletions": 44, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -12,9 +12,10 @@\n use driver::session::Session;\n use metadata::cstore;\n use metadata::filesearch;\n+use util::fs;\n \n use collections::HashSet;\n-use std::{os, slice};\n+use std::os;\n use syntax::abi;\n \n fn not_win32(os: abi::Os) -> bool {\n@@ -42,25 +43,16 @@ pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<~str> {\n     let sysroot = sess.filesearch().sysroot;\n     let output = out_filename;\n     let libs = sess.cstore.get_used_crates(cstore::RequireDynamic);\n-    let libs = libs.move_iter().filter_map(|(_, l)| l.map(|p| p.clone())).collect();\n-    // We don't currently rpath extern libraries, but we know\n-    // where rustrt is and we know every rust program needs it\n-    let libs = slice::append_one(libs, get_sysroot_absolute_rt_lib(sess));\n+    let libs = libs.move_iter().filter_map(|(_, l)| {\n+        l.map(|p| p.clone())\n+    }).collect::<~[_]>();\n \n     let rpaths = get_rpaths(os, sysroot, output, libs,\n                             sess.opts.target_triple);\n     flags.push_all(rpaths_to_flags(rpaths.as_slice()).as_slice());\n     flags\n }\n \n-fn get_sysroot_absolute_rt_lib(sess: &Session) -> Path {\n-    let sysroot = sess.filesearch().sysroot;\n-    let r = filesearch::relative_target_lib_path(sysroot, sess.opts.target_triple);\n-    let mut p = sysroot.join(&r);\n-    p.push(os::dll_filename(\"rustrt\"));\n-    p\n-}\n-\n pub fn rpaths_to_flags(rpaths: &[~str]) -> Vec<~str> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n@@ -87,10 +79,6 @@ fn get_rpaths(os: abi::Os,\n     // crates they depend on.\n     let rel_rpaths = get_rpaths_relative_to_output(os, output, libs);\n \n-    // Make backup absolute paths to the libraries. Binaries can\n-    // be moved as long as the crates they link against don't move.\n-    let abs_rpaths = get_absolute_rpaths(libs);\n-\n     // And a final backup rpath to the global library location.\n     let fallback_rpaths = vec!(get_install_prefix_rpath(sysroot, target_triple));\n \n@@ -102,11 +90,9 @@ fn get_rpaths(os: abi::Os,\n     }\n \n     log_rpaths(\"relative\", rel_rpaths.as_slice());\n-    log_rpaths(\"absolute\", abs_rpaths.as_slice());\n     log_rpaths(\"fallback\", fallback_rpaths.as_slice());\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(abs_rpaths.as_slice());\n     rpaths.push_all(fallback_rpaths.as_slice());\n \n     // Remove duplicates\n@@ -136,27 +122,16 @@ pub fn get_rpath_relative_to_output(os: abi::Os,\n         abi::OsWin32 => unreachable!()\n     };\n \n-    let mut lib = os::make_absolute(lib);\n+    let mut lib = fs::realpath(&os::make_absolute(lib)).unwrap();\n     lib.pop();\n-    let mut output = os::make_absolute(output);\n+    let mut output = fs::realpath(&os::make_absolute(output)).unwrap();\n     output.pop();\n     let relative = lib.path_relative_from(&output);\n     let relative = relative.expect(\"could not create rpath relative to output\");\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     prefix+\"/\"+relative.as_str().expect(\"non-utf8 component in path\")\n }\n \n-fn get_absolute_rpaths(libs: &[Path]) -> Vec<~str> {\n-    libs.iter().map(|a| get_absolute_rpath(a)).collect()\n-}\n-\n-pub fn get_absolute_rpath(lib: &Path) -> ~str {\n-    let mut p = os::make_absolute(lib);\n-    p.pop();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    p.as_str().expect(\"non-utf8 component in rpath\").to_owned()\n-}\n-\n pub fn get_install_prefix_rpath(sysroot: &Path, target_triple: &str) -> ~str {\n     let install_prefix = env!(\"CFG_PREFIX\");\n \n@@ -183,7 +158,7 @@ pub fn minimize_rpaths(rpaths: &[~str]) -> Vec<~str> {\n mod test {\n     use std::os;\n \n-    use back::rpath::{get_absolute_rpath, get_install_prefix_rpath};\n+    use back::rpath::get_install_prefix_rpath;\n     use back::rpath::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n     use syntax::abi;\n     use metadata::filesearch;\n@@ -258,15 +233,4 @@ mod test {\n                                                &Path::new(\"lib/libstd.so\"));\n         assert_eq!(res.as_slice(), \"@loader_path/../lib\");\n     }\n-\n-    #[test]\n-    fn test_get_absolute_rpath() {\n-        let res = get_absolute_rpath(&Path::new(\"lib/libstd.so\"));\n-        let lib = os::make_absolute(&Path::new(\"lib\"));\n-        debug!(\"test_get_absolute_rpath: {} vs. {}\",\n-               res.to_str(), lib.display());\n-\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        assert_eq!(res.as_slice(), lib.as_str().expect(\"non-utf8 component in path\"));\n-    }\n }"}, {"sha": "1b3653c6948a699910344b7f12e88c22c2ec1a12", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -664,7 +664,8 @@ impl pprust::PpAnn for TypedAnnotation {\n pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n-                          ppm: PpMode) {\n+                          ppm: PpMode,\n+                          ofile: Option<Path>) {\n     let krate = phase_1_parse_input(&sess, cfg, input);\n     let id = link::find_crate_id(krate.attrs.as_slice(), input.filestem());\n \n@@ -682,14 +683,25 @@ pub fn pretty_print_input(sess: Session,\n     let src = Vec::from_slice(sess.codemap().get_filemap(src_name).src.as_bytes());\n     let mut rdr = MemReader::new(src);\n \n+    let out = match ofile {\n+        None => ~io::stdout() as ~Writer,\n+        Some(p) => {\n+            let r = io::File::create(&p);\n+            match r {\n+                Ok(w) => ~w as ~Writer,\n+                Err(e) => fail!(\"print-print failed to open {} due to {}\",\n+                                p.display(), e),\n+            }\n+        }\n+    };\n     match ppm {\n         PpmIdentified | PpmExpandedIdentified => {\n             pprust::print_crate(sess.codemap(),\n                                 sess.diagnostic(),\n                                 &krate,\n                                 src_name,\n                                 &mut rdr,\n-                                ~io::stdout(),\n+                                out,\n                                 &IdentifiedAnnotation,\n                                 is_expanded)\n         }\n@@ -704,7 +716,7 @@ pub fn pretty_print_input(sess: Session,\n                                 &krate,\n                                 src_name,\n                                 &mut rdr,\n-                                ~io::stdout(),\n+                                out,\n                                 &annotation,\n                                 is_expanded)\n         }\n@@ -714,7 +726,7 @@ pub fn pretty_print_input(sess: Session,\n                                 &krate,\n                                 src_name,\n                                 &mut rdr,\n-                                ~io::stdout(),\n+                                out,\n                                 &pprust::NoAnn,\n                                 is_expanded)\n         }"}, {"sha": "dff3d8b03bcbf6709f843c14da5050a92ed9ceb7", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -297,20 +297,22 @@ mod __test {\n \n fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     let id_test = token::str_to_ident(\"test\");\n-    let vi = if cx.is_test_crate {\n-        ast::ViewItemUse(\n+    let (vi, vis) = if cx.is_test_crate {\n+        (ast::ViewItemUse(\n             vec!(@nospan(ast::ViewPathSimple(id_test,\n                                              path_node(vec!(id_test)),\n-                                             ast::DUMMY_NODE_ID))))\n+                                             ast::DUMMY_NODE_ID)))),\n+         ast::Public)\n     } else {\n-        ast::ViewItemExternCrate(id_test,\n+        (ast::ViewItemExternCrate(id_test,\n                                with_version(\"test\"),\n-                               ast::DUMMY_NODE_ID)\n+                               ast::DUMMY_NODE_ID),\n+         ast::Inherited)\n     };\n     ast::ViewItem {\n         node: vi,\n         attrs: Vec::new(),\n-        vis: ast::Inherited,\n+        vis: vis,\n         span: DUMMY_SP\n     }\n }"}, {"sha": "b9acd4132152060cd31bcf69a850bfa22a9729a2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -127,6 +127,7 @@ pub mod util {\n     pub mod ppaux;\n     pub mod sha2;\n     pub mod nodemap;\n+    pub mod fs;\n }\n \n pub mod lib {\n@@ -293,7 +294,7 @@ pub fn run_compiler(args: &[~str]) {\n     });\n     match pretty {\n         Some::<d::PpMode>(ppm) => {\n-            d::pretty_print_input(sess, cfg, &input, ppm);\n+            d::pretty_print_input(sess, cfg, &input, ppm, ofile);\n             return;\n         }\n         None::<d::PpMode> => {/* continue */ }"}, {"sha": "b57ab8d0f2fc84c1aefc409f50a8ec190c995944", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -190,7 +190,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                 } else {\n                     None\n                 })\n-                .collect::<~[&ast::Attribute]>();\n+                .collect::<Vec<&ast::Attribute>>();\n             for m in link_args.iter() {\n                 match m.value_str() {\n                     Some(linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n@@ -205,7 +205,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                 } else {\n                     None\n                 })\n-                .collect::<~[&ast::Attribute]>();\n+                .collect::<Vec<&ast::Attribute>>();\n             for m in link_args.iter() {\n                 match m.meta_item_list() {\n                     Some(items) => {"}, {"sha": "16068dd939b1d13edd7ca0ccfac7646a30e24384", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -28,7 +28,7 @@ use syntax::parse::token;\n pub struct StaticMethodInfo {\n     pub ident: ast::Ident,\n     pub def_id: ast::DefId,\n-    pub purity: ast::Purity,\n+    pub fn_style: ast::FnStyle,\n     pub vis: ast::Visibility,\n }\n "}, {"sha": "28968a6001616c7dbcd6045434277ddbda3505c9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -330,11 +330,11 @@ fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n         MutStatic => DlDef(ast::DefStatic(did, true)),\n         Struct    => DlDef(ast::DefStruct(did)),\n         UnsafeFn  => DlDef(ast::DefFn(did, ast::UnsafeFn)),\n-        Fn        => DlDef(ast::DefFn(did, ast::ImpureFn)),\n+        Fn        => DlDef(ast::DefFn(did, ast::NormalFn)),\n         ForeignFn => DlDef(ast::DefFn(did, ast::ExternFn)),\n         StaticMethod | UnsafeStaticMethod => {\n-            let purity = if fam == UnsafeStaticMethod { ast::UnsafeFn } else\n-                { ast::ImpureFn };\n+            let fn_style = if fam == UnsafeStaticMethod { ast::UnsafeFn } else\n+                { ast::NormalFn };\n             // def_static_method carries an optional field of its enclosing\n             // trait or enclosing impl (if this is an inherent static method).\n             // So we need to detect whether this is in a trait or not, which\n@@ -348,7 +348,7 @@ fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n                 ast::FromImpl(item_reqd_and_translated_parent_item(cnum,\n                                                                    item))\n             };\n-            DlDef(ast::DefStaticMethod(did, provenance, purity))\n+            DlDef(ast::DefStaticMethod(did, provenance, fn_style))\n         }\n         Type | ForeignType => DlDef(ast::DefTy(did)),\n         Mod => DlDef(ast::DefMod(did)),\n@@ -905,17 +905,17 @@ pub fn get_static_methods_if_impl(intr: Rc<IdentInterner>,\n         let family = item_family(impl_method_doc);\n         match family {\n             StaticMethod | UnsafeStaticMethod => {\n-                let purity;\n+                let fn_style;\n                 match item_family(impl_method_doc) {\n-                    StaticMethod => purity = ast::ImpureFn,\n-                    UnsafeStaticMethod => purity = ast::UnsafeFn,\n+                    StaticMethod => fn_style = ast::NormalFn,\n+                    UnsafeStaticMethod => fn_style = ast::UnsafeFn,\n                     _ => fail!()\n                 }\n \n                 static_impl_methods.push(StaticMethodInfo {\n                     ident: item_name(&*intr, impl_method_doc),\n                     def_id: item_def_id(impl_method_doc, cdata),\n-                    purity: purity,\n+                    fn_style: fn_style,\n                     vis: item_visibility(impl_method_doc),\n                 });\n             }"}, {"sha": "ac62702e59ed1f1645c12b8dedabc18594ee7f80", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -758,12 +758,12 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n     encode_visibility(ebml_w, method_ty.vis);\n     encode_explicit_self(ebml_w, method_ty.explicit_self);\n-    let purity = method_ty.fty.purity;\n+    let fn_style = method_ty.fty.fn_style;\n     match method_ty.explicit_self {\n         ast::SelfStatic => {\n-            encode_family(ebml_w, purity_static_method_family(purity));\n+            encode_family(ebml_w, fn_style_static_method_family(fn_style));\n         }\n-        _ => encode_family(ebml_w, purity_fn_family(purity))\n+        _ => encode_family(ebml_w, style_fn_family(fn_style))\n     }\n     encode_provided_source(ebml_w, method_ty.provided_source);\n }\n@@ -811,18 +811,18 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn purity_fn_family(p: Purity) -> char {\n-    match p {\n+fn style_fn_family(s: FnStyle) -> char {\n+    match s {\n         UnsafeFn => 'u',\n-        ImpureFn => 'f',\n+        NormalFn => 'f',\n         ExternFn => 'e'\n     }\n }\n \n-fn purity_static_method_family(p: Purity) -> char {\n-    match p {\n+fn fn_style_static_method_family(s: FnStyle) -> char {\n+    match s {\n         UnsafeFn => 'U',\n-        ImpureFn => 'F',\n+        NormalFn => 'F',\n         _ => fail!(\"extern fn can't be static\")\n     }\n }\n@@ -911,11 +911,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n-      ItemFn(_, purity, _, ref generics, _) => {\n+      ItemFn(_, fn_style, _, ref generics, _) => {\n         add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, purity_fn_family(purity));\n+        encode_family(ebml_w, style_fn_family(fn_style));\n         let tps_len = generics.ty_params.len();\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ebml_w, item.ident.name);\n@@ -1165,17 +1165,17 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             match method_ty.explicit_self {\n                 SelfStatic => {\n                     encode_family(ebml_w,\n-                                  purity_static_method_family(\n-                                      method_ty.fty.purity));\n+                                  fn_style_static_method_family(\n+                                      method_ty.fty.fn_style));\n \n                     let tpt = ty::lookup_item_type(tcx, method_def_id);\n                     encode_bounds_and_type(ebml_w, ecx, &tpt);\n                 }\n \n                 _ => {\n                     encode_family(ebml_w,\n-                                  purity_fn_family(\n-                                      method_ty.fty.purity));\n+                                  style_fn_family(\n+                                      method_ty.fty.fn_style));\n                 }\n             }\n \n@@ -1227,7 +1227,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     encode_def_id(ebml_w, local_def(nitem.id));\n     match nitem.node {\n       ForeignItemFn(..) => {\n-        encode_family(ebml_w, purity_fn_family(ImpureFn));\n+        encode_family(ebml_w, style_fn_family(NormalFn));\n         encode_bounds_and_type(ebml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_name(ebml_w, nitem.ident.name);"}, {"sha": "f4ea386a2ecad753ca230d56ad9bffba906ff127", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -15,6 +15,8 @@ use std::os;\n use std::io::fs;\n use collections::HashSet;\n \n+use myfs = util::fs;\n+\n pub enum FileMatch { FileMatches, FileDoesntMatch }\n \n // A module for searching for libraries\n@@ -156,17 +158,10 @@ fn make_rustpkg_target_lib_path(sysroot: &Path,\n pub fn get_or_default_sysroot() -> Path {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n     fn canonicalize(path: Option<Path>) -> Option<Path> {\n-        path.and_then(|mut path|\n-            match fs::readlink(&path) {\n-                Ok(canon) => {\n-                    if canon.is_absolute() {\n-                        Some(canon)\n-                    } else {\n-                        path.pop();\n-                        Some(path.join(canon))\n-                    }\n-                },\n-                Err(..) => Some(path),\n+        path.and_then(|path|\n+            match myfs::realpath(&path) {\n+                Ok(canon) => Some(canon),\n+                Err(e) => fail!(\"failed to get realpath: {}\", e),\n             })\n     }\n "}, {"sha": "cf404481670285619af0422dedf99af6d3b7835b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -449,12 +449,12 @@ fn parse_hex(st: &mut PState) -> uint {\n     };\n }\n \n-fn parse_purity(c: char) -> Purity {\n+fn parse_fn_style(c: char) -> FnStyle {\n     match c {\n         'u' => UnsafeFn,\n-        'i' => ImpureFn,\n+        'n' => NormalFn,\n         'c' => ExternFn,\n-        _ => fail!(\"parse_purity: bad purity {}\", c)\n+        _ => fail!(\"parse_fn_style: bad fn_style {}\", c)\n     }\n }\n \n@@ -476,13 +476,13 @@ fn parse_onceness(c: char) -> ast::Onceness {\n \n fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     let sigil = parse_sigil(st);\n-    let purity = parse_purity(next(st));\n+    let fn_style = parse_fn_style(next(st));\n     let onceness = parse_onceness(next(st));\n     let region = parse_region(st, |x,y| conv(x,y));\n     let bounds = parse_bounds(st, |x,y| conv(x,y));\n     let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::ClosureTy {\n-        purity: purity,\n+        fn_style: fn_style,\n         sigil: sigil,\n         onceness: onceness,\n         region: region,\n@@ -492,11 +492,11 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n }\n \n fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n-    let purity = parse_purity(next(st));\n+    let fn_style = parse_fn_style(next(st));\n     let abi = parse_abi_set(st);\n     let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::BareFnTy {\n-        purity: purity,\n+        fn_style: fn_style,\n         abi: abi,\n         sig: sig\n     }"}, {"sha": "485b28ca13bea674b97472624d31b2f27c1c7d49", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -332,9 +332,9 @@ fn enc_sigil(w: &mut MemWriter, sigil: Sigil) {\n     }\n }\n \n-fn enc_purity(w: &mut MemWriter, p: Purity) {\n+fn enc_fn_style(w: &mut MemWriter, p: FnStyle) {\n     match p {\n-        ImpureFn => mywrite!(w, \"i\"),\n+        NormalFn => mywrite!(w, \"n\"),\n         UnsafeFn => mywrite!(w, \"u\"),\n         ExternFn => mywrite!(w, \"c\")\n     }\n@@ -354,14 +354,14 @@ fn enc_onceness(w: &mut MemWriter, o: Onceness) {\n }\n \n pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n-    enc_purity(w, ft.purity);\n+    enc_fn_style(w, ft.fn_style);\n     enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n fn enc_closure_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n     enc_sigil(w, ft.sigil);\n-    enc_purity(w, ft.purity);\n+    enc_fn_style(w, ft.fn_style);\n     enc_onceness(w, ft.onceness);\n     enc_region(w, cx, ft.region);\n     let bounds = ty::ParamBounds {builtin_bounds: ft.bounds,"}, {"sha": "827d07484b739d9a10726d483ae8e6ce106c92f7", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -29,8 +29,8 @@ enum UnsafeContext {\n \n fn type_is_unsafe_function(ty: ty::t) -> bool {\n     match ty::get(ty).sty {\n-        ty::ty_bare_fn(ref f) => f.purity == ast::UnsafeFn,\n-        ty::ty_closure(ref f) => f.purity == ast::UnsafeFn,\n+        ty::ty_bare_fn(ref f) => f.fn_style == ast::UnsafeFn,\n+        ty::ty_closure(ref f) => f.fn_style == ast::UnsafeFn,\n         _ => false,\n     }\n }\n@@ -84,10 +84,10 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n                 block: &ast::Block, span: Span, node_id: ast::NodeId, _:()) {\n \n         let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n-            visit::FkItemFn(_, _, purity, _) =>\n-                (true, purity == ast::UnsafeFn),\n+            visit::FkItemFn(_, _, fn_style, _) =>\n+                (true, fn_style == ast::UnsafeFn),\n             visit::FkMethod(_, _, method) =>\n-                (true, method.purity == ast::UnsafeFn),\n+                (true, method.fn_style == ast::UnsafeFn),\n             _ => (false, false),\n         };\n "}, {"sha": "24dea77c17019e486af4fb6157aad73a8fc6001c", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -1063,7 +1063,7 @@ fn check_attrs_usage(cx: &Context, attrs: &[ast::Attribute]) {\n             if name.equiv(crate_attr) {\n                 let msg = match attr.node.style {\n                     ast::AttrOuter => \"crate-level attribute should be an inner attribute: \\\n-                                       add semicolon at end\",\n+                                       add an exclamation mark: #![foo]\",\n                     ast::AttrInner => \"crate-level attribute should be in the root module\",\n                 };\n                 cx.span_lint(AttributeUsage, attr.span, msg);"}, {"sha": "38eab354f2bd86cbd9cfac8cc66ac588df3bfc2b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -144,6 +144,12 @@ impl NamespaceResult {\n             _ => false\n         }\n     }\n+    fn is_unbound(&self) -> bool {\n+        match *self {\n+            UnboundResult => true,\n+            _ => false\n+        }\n+    }\n }\n \n enum NameDefinition {\n@@ -1182,11 +1188,11 @@ impl<'a> Resolver<'a> {\n                     (DefStatic(local_def(item.id), mutbl), sp, is_public);\n                 parent\n             }\n-            ItemFn(_, purity, _, _, _) => {\n+            ItemFn(_, fn_style, _, _, _) => {\n               let (name_bindings, new_parent) =\n                 self.add_child(ident, parent, ForbidDuplicateValues, sp);\n \n-                let def = DefFn(local_def(item.id), purity);\n+                let def = DefFn(local_def(item.id), fn_style);\n                 name_bindings.define_value(def, sp, is_public);\n                 new_parent\n             }\n@@ -1313,7 +1319,7 @@ impl<'a> Resolver<'a> {\n                                     DefStaticMethod(local_def(method.id),\n                                                       FromImpl(local_def(\n                                                         item.id)),\n-                                                      method.purity)\n+                                                      method.fn_style)\n                                 }\n                                 _ => {\n                                     // Non-static methods become\n@@ -1364,7 +1370,7 @@ impl<'a> Resolver<'a> {\n                             // Static methods become `def_static_method`s.\n                             DefStaticMethod(local_def(ty_m.id),\n                                               FromTrait(local_def(item.id)),\n-                                              ty_m.purity)\n+                                              ty_m.fn_style)\n                         }\n                         _ => {\n                             // Non-static methods become `def_method`s.\n@@ -1869,7 +1875,7 @@ impl<'a> Resolver<'a> {\n                                                        DUMMY_SP);\n                                     let def = DefFn(\n                                         static_method_info.def_id,\n-                                        static_method_info.purity);\n+                                        static_method_info.fn_style);\n \n                                     method_name_bindings.define_value(\n                                         def, DUMMY_SP,\n@@ -1976,6 +1982,7 @@ impl<'a> Resolver<'a> {\n                         // the source of this name is different now\n                         resolution.type_id.set(id);\n                         resolution.value_id.set(id);\n+                        resolution.is_public.set(is_public);\n                     }\n                     None => {\n                         debug!(\"(building import directive) creating new\");\n@@ -2286,10 +2293,12 @@ impl<'a> Resolver<'a> {\n             }\n             Some(child_name_bindings) => {\n                 if child_name_bindings.defined_in_namespace(ValueNS) {\n+                    debug!(\"(resolving single import) found value binding\");\n                     value_result = BoundResult(containing_module,\n                                                *child_name_bindings);\n                 }\n                 if child_name_bindings.defined_in_namespace(TypeNS) {\n+                    debug!(\"(resolving single import) found type binding\");\n                     type_result = BoundResult(containing_module,\n                                               *child_name_bindings);\n                 }\n@@ -2320,6 +2329,7 @@ impl<'a> Resolver<'a> {\n                                                           .borrow();\n                 match import_resolutions.find(&source.name) {\n                     None => {\n+                        debug!(\"(resolving single import) no import\");\n                         // The containing module definitely doesn't have an\n                         // exported import with the name in question. We can\n                         // therefore accurately report that the names are\n@@ -2353,6 +2363,8 @@ impl<'a> Resolver<'a> {\n                                     return UnboundResult;\n                                 }\n                                 Some(target) => {\n+                                    debug!(\"(resolving single import) found \\\n+                                            import in ns {:?}\", namespace);\n                                     let id = import_resolution.id(namespace);\n                                     this.used_imports.insert((id, namespace));\n                                     return BoundResult(target.target_module,\n@@ -2396,6 +2408,8 @@ impl<'a> Resolver<'a> {\n                                        .find_copy(&source.name) {\n                     None => {} // Continue.\n                     Some(module) => {\n+                        debug!(\"(resolving single import) found external \\\n+                                module\");\n                         let name_bindings =\n                             @Resolver::create_name_bindings_from_module(\n                                 module);\n@@ -2442,8 +2456,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        if import_resolution.value_target.borrow().is_none() &&\n-           import_resolution.type_target.borrow().is_none() {\n+        if value_result.is_unbound() && type_result.is_unbound() {\n             let msg = format!(\"unresolved import: there is no \\\n                                `{}` in `{}`\",\n                               token::get_ident(source),\n@@ -2669,7 +2682,8 @@ impl<'a> Resolver<'a> {\n             match self.resolve_name_in_module(search_module,\n                                               name,\n                                               TypeNS,\n-                                              name_search_type) {\n+                                              name_search_type,\n+                                              false) {\n                 Failed => {\n                     let segment_name = token::get_ident(name);\n                     let module_name = self.module_to_str(search_module);\n@@ -2977,7 +2991,8 @@ impl<'a> Resolver<'a> {\n             match self.resolve_name_in_module(search_module,\n                                               name,\n                                               namespace,\n-                                              PathSearch) {\n+                                              PathSearch,\n+                                              true) {\n                 Failed => {\n                     // Continue up the search chain.\n                 }\n@@ -3141,7 +3156,8 @@ impl<'a> Resolver<'a> {\n                               module_: @Module,\n                               name: Ident,\n                               namespace: Namespace,\n-                              name_search_type: NameSearchType)\n+                              name_search_type: NameSearchType,\n+                              allow_private_imports: bool)\n                               -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                token::get_ident(name),\n@@ -3172,7 +3188,9 @@ impl<'a> Resolver<'a> {\n \n         // Check the list of resolved imports.\n         match module_.import_resolutions.borrow().find(&name.name) {\n-            Some(import_resolution) => {\n+            Some(import_resolution) if allow_private_imports ||\n+                                       import_resolution.is_public.get() => {\n+\n                 if import_resolution.is_public.get() &&\n                         import_resolution.outstanding_references.get() != 0 {\n                     debug!(\"(resolving name in module) import \\\n@@ -3193,7 +3211,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            None => {} // Continue.\n+            Some(..) | None => {} // Continue.\n         }\n \n         // Finally, search through external children."}, {"sha": "92b1a60598b7ce506f03131dcb907eddfd397a12", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -1554,8 +1554,8 @@ impl<'a> Visitor<()> for TransItemVisitor<'a> {\n pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n     match item.node {\n-      ast::ItemFn(decl, purity, _abi, ref generics, body) => {\n-        if purity == ast::ExternFn  {\n+      ast::ItemFn(decl, fn_style, _abi, ref generics, body) => {\n+        if fn_style == ast::ExternFn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi(\n                 ccx, decl, body, item.attrs.as_slice(), llfndecl, item.id);\n@@ -1899,8 +1899,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     }\n                 }\n \n-                ast::ItemFn(_, purity, _, _, _) => {\n-                    let llfn = if purity != ast::ExternFn {\n+                ast::ItemFn(_, fn_style, _, _, _) => {\n+                    let llfn = if fn_style != ast::ExternFn {\n                         register_fn(ccx, i.span, sym, i.id, ty)\n                     } else {\n                         foreign::register_rust_fn_with_foreign_abi(ccx,"}, {"sha": "d6156e7c3e64eae80152deee8745d0db9420f4b0", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -615,7 +615,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n \n             let opt_def = cx.tcx().def_map.borrow().find_copy(&e.id);\n             match opt_def {\n-                Some(ast::DefFn(def_id, _purity)) => {\n+                Some(ast::DefFn(def_id, _fn_style)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx(), def_id).ty;\n                         (base::trans_external_path(cx, def_id, ty), true)"}, {"sha": "8ea2065509bb8a6da58c85fa13ae02edee49572e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 79, "deletions": 32, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -130,6 +130,7 @@ use driver::session::{FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use lib::llvm::llvm;\n use lib::llvm::{ModuleRef, ContextRef, ValueRef};\n use lib::llvm::debuginfo::*;\n+use metadata::csearch;\n use middle::trans::adt;\n use middle::trans::common::*;\n use middle::trans::datum::{Datum, Lvalue};\n@@ -178,6 +179,7 @@ pub struct CrateDebugContext {\n     current_debug_location: Cell<DebugLocation>,\n     created_files: RefCell<HashMap<~str, DIFile>>,\n     created_types: RefCell<HashMap<uint, DIType>>,\n+    created_enum_disr_types: RefCell<HashMap<ast::DefId, DIType>>,\n     namespace_map: RefCell<HashMap<Vec<ast::Name> , @NamespaceTreeNode>>,\n     // This collection is used to assert that composite types (structs, enums, ...) have their\n     // members only set once:\n@@ -196,6 +198,7 @@ impl CrateDebugContext {\n             current_debug_location: Cell::new(UnknownLocation),\n             created_files: RefCell::new(HashMap::new()),\n             created_types: RefCell::new(HashMap::new()),\n+            created_enum_disr_types: RefCell::new(HashMap::new()),\n             namespace_map: RefCell::new(HashMap::new()),\n             composite_types_completed: RefCell::new(HashSet::new()),\n         };\n@@ -290,6 +293,13 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         return;\n     }\n \n+    // Don't create debuginfo for globals inlined from other crates. The other crate should already\n+    // contain debuginfo for it. More importantly, the global might not even exist in un-inlined\n+    // form anywhere which would lead to a linker errors.\n+    if cx.external_srcs.borrow().contains_key(&node_id) {\n+        return;\n+    }\n+\n     let var_item = cx.tcx.map.get(node_id);\n \n     let (ident, span) = match var_item {\n@@ -533,21 +543,26 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n                            span: Span) {\n-    if fn_should_be_ignored(fcx) {\n-        return;\n-    }\n-\n-    let cx = fcx.ccx;\n+    match fcx.debug_context {\n+        DebugInfoDisabled => return,\n+        FunctionWithoutDebugInfo => {\n+            set_debug_location(fcx.ccx, UnknownLocation);\n+            return;\n+        }\n+        FunctionDebugContext(~ref function_debug_context) => {\n+            let cx = fcx.ccx;\n \n-    debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_str(span));\n+            debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_str(span));\n \n-    if fcx.debug_context.get_ref(cx, span).source_locations_enabled.get() {\n-        let loc = span_start(cx, span);\n-        let scope = scope_metadata(fcx, node_id, span);\n+            if function_debug_context.source_locations_enabled.get() {\n+                let loc = span_start(cx, span);\n+                let scope = scope_metadata(fcx, node_id, span);\n \n-        set_debug_location(cx, DebugLocation::new(scope, loc.line, loc.col.to_uint()));\n-    } else {\n-        set_debug_location(cx, UnknownLocation);\n+                set_debug_location(cx, DebugLocation::new(scope, loc.line, loc.col.to_uint()));\n+            } else {\n+                set_debug_location(cx, UnknownLocation);\n+            }\n+        }\n     }\n }\n \n@@ -590,6 +605,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         return DebugInfoDisabled;\n     }\n \n+    // Clear the debug location so we don't assign them in the function prelude. Do this here\n+    // already, in case we do an early exit from this function.\n+    set_debug_location(cx, UnknownLocation);\n+\n     if fn_ast_id == -1 {\n         return FunctionWithoutDebugInfo;\n     }\n@@ -740,9 +759,6 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                        fn_metadata,\n                        &mut *fn_debug_context.scope_map.borrow_mut());\n \n-    // Clear the debug location so we don't assign them in the function prelude\n-    set_debug_location(cx, UnknownLocation);\n-\n     return FunctionDebugContext(fn_debug_context);\n \n     fn get_function_signature(cx: &CrateContext,\n@@ -1536,24 +1552,45 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         .collect();\n \n     let discriminant_type_metadata = |inttype| {\n-        let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n-        let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n-        let discriminant_base_type_metadata = type_metadata(cx, adt::ty_of_inttype(inttype),\n-                                                            codemap::DUMMY_SP);\n-        enum_name.with_c_str(|enum_name| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateEnumerationType(\n-                    DIB(cx),\n-                    containing_scope,\n-                    enum_name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    bytes_to_bits(discriminant_size),\n-                    bytes_to_bits(discriminant_align),\n-                    create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n-                    discriminant_base_type_metadata)\n+        // We can reuse the type of the discriminant for all monomorphized instances of an enum\n+        // because it doesn't depend on any type parameters. The def_id, uniquely identifying the\n+        // enum's polytype acts as key in this cache.\n+        let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n+                                                                 .borrow()\n+                                                                 .find_copy(&enum_def_id);\n+        match cached_discriminant_type_metadata {\n+            Some(discriminant_type_metadata) => discriminant_type_metadata,\n+            None => {\n+                let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n+                let (discriminant_size, discriminant_align) =\n+                    size_and_align_of(cx, discriminant_llvm_type);\n+                let discriminant_base_type_metadata = type_metadata(cx,\n+                                                                    adt::ty_of_inttype(inttype),\n+                                                                    codemap::DUMMY_SP);\n+                let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n+\n+                let discriminant_type_metadata = discriminant_name.get().with_c_str(|name| {\n+                    unsafe {\n+                        llvm::LLVMDIBuilderCreateEnumerationType(\n+                            DIB(cx),\n+                            containing_scope,\n+                            name,\n+                            file_metadata,\n+                            loc.line as c_uint,\n+                            bytes_to_bits(discriminant_size),\n+                            bytes_to_bits(discriminant_align),\n+                            create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n+                            discriminant_base_type_metadata)\n+                    }\n+                });\n+\n+                debug_context(cx).created_enum_disr_types\n+                                 .borrow_mut()\n+                                 .insert(enum_def_id, discriminant_type_metadata);\n+\n+                discriminant_type_metadata\n             }\n-        })\n+        }\n     };\n \n     let type_rep = adt::represent_type(cx, enum_type);\n@@ -1642,6 +1679,16 @@ fn prepare_enum_metadata(cx: &CrateContext,\n             }\n         }\n     };\n+\n+    fn get_enum_discriminant_name(cx: &CrateContext, def_id: ast::DefId) -> token::InternedString {\n+        let name = if def_id.krate == ast::LOCAL_CRATE {\n+            cx.tcx.map.get_path_elem(def_id.node).name()\n+        } else {\n+            csearch::get_item_path(&cx.tcx, def_id).last().unwrap().name()\n+        };\n+\n+        token::get_name(name)\n+    }\n }\n \n enum MemberOffset {"}, {"sha": "2244c769af1c004edd5d6cdeb9cca17a3a2fcfe4", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -211,7 +211,7 @@ impl<'a> Reflector<'a> {\n           // FIXME (#2594): fetch constants out of intrinsic\n           // FIXME (#4809): visitor should break out bare fns from other fns\n           ty::ty_closure(ref fty) => {\n-            let pureval = ast_purity_constant(fty.purity);\n+            let pureval = ast_fn_style_constant(fty.fn_style);\n             let sigilval = ast_sigil_constant(fty.sigil);\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n             let extra = vec!(self.c_uint(pureval),\n@@ -226,7 +226,7 @@ impl<'a> Reflector<'a> {\n           // FIXME (#2594): fetch constants out of intrinsic:: for the\n           // numbers.\n           ty::ty_bare_fn(ref fty) => {\n-            let pureval = ast_purity_constant(fty.purity);\n+            let pureval = ast_fn_style_constant(fty.fn_style);\n             let sigilval = 0u;\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n             let extra = vec!(self.c_uint(pureval),\n@@ -399,10 +399,10 @@ pub fn ast_sigil_constant(sigil: ast::Sigil) -> uint {\n     }\n }\n \n-pub fn ast_purity_constant(purity: ast::Purity) -> uint {\n-    match purity {\n+pub fn ast_fn_style_constant(fn_style: ast::FnStyle) -> uint {\n+    match fn_style {\n         ast::UnsafeFn => 1u,\n-        ast::ImpureFn => 2u,\n+        ast::NormalFn => 2u,\n         ast::ExternFn => 3u\n     }\n }"}, {"sha": "aac847c795aeb32c1bfdb36655e95295170319ef", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -415,14 +415,14 @@ pub fn type_id(t: t) -> uint { get(t).id }\n \n #[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct BareFnTy {\n-    pub purity: ast::Purity,\n+    pub fn_style: ast::FnStyle,\n     pub abi: abi::Abi,\n     pub sig: FnSig,\n }\n \n #[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct ClosureTy {\n-    pub purity: ast::Purity,\n+    pub fn_style: ast::FnStyle,\n     pub sigil: ast::Sigil,\n     pub onceness: ast::Onceness,\n     pub region: Region,\n@@ -791,7 +791,7 @@ pub struct expected_found<T> {\n #[deriving(Clone, Show)]\n pub enum type_err {\n     terr_mismatch,\n-    terr_purity_mismatch(expected_found<Purity>),\n+    terr_fn_style_mismatch(expected_found<FnStyle>),\n     terr_onceness_mismatch(expected_found<Onceness>),\n     terr_abi_mismatch(expected_found<abi::Abi>),\n     terr_mutability,\n@@ -1397,7 +1397,7 @@ pub fn mk_ctor_fn(cx: &ctxt,\n     let input_args = input_tys.iter().map(|t| *t).collect();\n     mk_bare_fn(cx,\n                BareFnTy {\n-                   purity: ast::ImpureFn,\n+                   fn_style: ast::NormalFn,\n                    abi: abi::Rust,\n                    sig: FnSig {\n                     binder_id: binder_id,\n@@ -2843,7 +2843,7 @@ pub fn adjust_ty(cx: &ctxt,\n                         ty::ty_bare_fn(ref b) => {\n                             ty::mk_closure(\n                                 cx,\n-                                ty::ClosureTy {purity: b.purity,\n+                                ty::ClosureTy {fn_style: b.fn_style,\n                                                sigil: s,\n                                                onceness: ast::Many,\n                                                region: r,\n@@ -3340,7 +3340,7 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n \n     match *err {\n         terr_mismatch => ~\"types differ\",\n-        terr_purity_mismatch(values) => {\n+        terr_fn_style_mismatch(values) => {\n             format!(\"expected {} fn but found {} fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n@@ -4297,16 +4297,16 @@ pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::Expr) ->\n     }\n }\n \n-// Determine what purity to check a nested function under\n-pub fn determine_inherited_purity(parent: (ast::Purity, ast::NodeId),\n-                                  child: (ast::Purity, ast::NodeId),\n+// Determine what the style to check a nested function under\n+pub fn determine_inherited_style(parent: (ast::FnStyle, ast::NodeId),\n+                                  child: (ast::FnStyle, ast::NodeId),\n                                   child_sigil: ast::Sigil)\n-                                    -> (ast::Purity, ast::NodeId) {\n+                                    -> (ast::FnStyle, ast::NodeId) {\n     // If the closure is a stack closure and hasn't had some non-standard\n-    // purity inferred for it, then check it under its parent's purity.\n+    // style inferred for it, then check it under its parent's style.\n     // Otherwise, use its own\n     match child_sigil {\n-        ast::BorrowedSigil if child.val0() == ast::ImpureFn => parent,\n+        ast::BorrowedSigil if child.val0() == ast::NormalFn => parent,\n         _ => child\n     }\n }\n@@ -4665,12 +4665,12 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             }\n             ty_bare_fn(ref b) => {\n                 byte!(14);\n-                hash!(b.purity);\n+                hash!(b.fn_style);\n                 hash!(b.abi);\n             }\n             ty_closure(ref c) => {\n                 byte!(15);\n-                hash!(c.purity);\n+                hash!(c.fn_style);\n                 hash!(c.sigil);\n                 hash!(c.onceness);\n                 hash!(c.bounds);"}, {"sha": "a0d2318e1d024f362c38877932381e238eac6aac", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -49,7 +49,7 @@ pub trait TypeFolder {\n                        -> ty::BareFnTy {\n         ty::BareFnTy { sig: self.fold_sig(&fty.sig),\n                        abi: fty.abi,\n-                       purity: fty.purity }\n+                       fn_style: fty.fn_style }\n     }\n \n     fn fold_closure_ty(&mut self,\n@@ -58,7 +58,7 @@ pub trait TypeFolder {\n         ty::ClosureTy {\n             region: self.fold_region(fty.region),\n             sig: self.fold_sig(&fty.sig),\n-            purity: fty.purity,\n+            fn_style: fty.fn_style,\n             sigil: fty.sigil,\n             onceness: fty.onceness,\n             bounds: fty.bounds,"}, {"sha": "d2e98c617a7dee82ff9ec766ceb99fe5cc1ce1e0", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -523,7 +523,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     tcx.sess.span_err(ast_ty.span,\n                                       \"variadic function must have C calling convention\");\n                 }\n-                ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.purity,\n+                ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.fn_style,\n                                                   bf.abi, bf.decl))\n             }\n             ast::TyClosure(ref f) => {\n@@ -543,7 +543,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                             rscope,\n                                             ast_ty.id,\n                                             f.sigil,\n-                                            f.purity,\n+                                            f.fn_style,\n                                             f.onceness,\n                                             bounds,\n                                             &f.region,\n@@ -572,9 +572,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                         let path_str = path_to_str(path);\n                         tcx.sess.span_err(\n                             ast_ty.span,\n-                            format!(\"reference to trait `{}` where a type is expected; \\\n-                                    try `@{}`, `~{}`, or `&{}`\",\n-                                    path_str, path_str, path_str, path_str));\n+                            format!(\"reference to trait `{name}` where a type is expected; \\\n+                                    try `~{name}` or `&{name}`\", name=path_str));\n                         ty::mk_err()\n                     }\n                     ast::DefTy(did) | ast::DefStruct(did) => {\n@@ -662,24 +661,24 @@ struct SelfInfo {\n pub fn ty_of_method<AC:AstConv>(\n     this: &AC,\n     id: ast::NodeId,\n-    purity: ast::Purity,\n+    fn_style: ast::FnStyle,\n     untransformed_self_ty: ty::t,\n     explicit_self: ast::ExplicitSelf,\n     decl: &ast::FnDecl) -> ty::BareFnTy {\n-    ty_of_method_or_bare_fn(this, id, purity, abi::Rust, Some(SelfInfo {\n+    ty_of_method_or_bare_fn(this, id, fn_style, abi::Rust, Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: explicit_self\n     }), decl)\n }\n \n pub fn ty_of_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n-                                 purity: ast::Purity, abi: abi::Abi,\n+                                 fn_style: ast::FnStyle, abi: abi::Abi,\n                                  decl: &ast::FnDecl) -> ty::BareFnTy {\n-    ty_of_method_or_bare_fn(this, id, purity, abi, None, decl)\n+    ty_of_method_or_bare_fn(this, id, fn_style, abi, None, decl)\n }\n \n fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n-                                       purity: ast::Purity, abi: abi::Abi,\n+                                       fn_style: ast::FnStyle, abi: abi::Abi,\n                                        opt_self_info: Option<SelfInfo>,\n                                        decl: &ast::FnDecl) -> ty::BareFnTy {\n     debug!(\"ty_of_method_or_bare_fn\");\n@@ -725,7 +724,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n     };\n \n     return ty::BareFnTy {\n-        purity: purity,\n+        fn_style: fn_style,\n         abi: abi,\n         sig: ty::FnSig {\n             binder_id: id,\n@@ -741,7 +740,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     rscope: &RS,\n     id: ast::NodeId,\n     sigil: ast::Sigil,\n-    purity: ast::Purity,\n+    fn_style: ast::FnStyle,\n     onceness: ast::Onceness,\n     bounds: ty::BuiltinBounds,\n     opt_lifetime: &Option<ast::Lifetime>,\n@@ -798,7 +797,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     };\n \n     ty::ClosureTy {\n-        purity: purity,\n+        fn_style: fn_style,\n         sigil: sigil,\n         onceness: onceness,\n         region: bound_region,"}, {"sha": "611b3653ab3f45b9505d059e6fb2cda73c23ff8a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -1163,7 +1163,7 @@ impl<'a> LookupContext<'a> {\n         let transformed_self_ty = *fn_sig.inputs.get(0);\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n-            purity: bare_fn_ty.purity,\n+            fn_style: bare_fn_ty.fn_style,\n             abi: bare_fn_ty.abi.clone(),\n         });\n         debug!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));"}, {"sha": "bfbac7aaebb1ad05d6c1580a15536041994e4d88", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -177,32 +177,32 @@ pub enum FnKind {\n }\n \n #[deriving(Clone)]\n-pub struct PurityState {\n+pub struct FnStyleState {\n     pub def: ast::NodeId,\n-    pub purity: ast::Purity,\n+    pub fn_style: ast::FnStyle,\n     from_fn: bool\n }\n \n-impl PurityState {\n-    pub fn function(purity: ast::Purity, def: ast::NodeId) -> PurityState {\n-        PurityState { def: def, purity: purity, from_fn: true }\n+impl FnStyleState {\n+    pub fn function(fn_style: ast::FnStyle, def: ast::NodeId) -> FnStyleState {\n+        FnStyleState { def: def, fn_style: fn_style, from_fn: true }\n     }\n \n-    pub fn recurse(&mut self, blk: &ast::Block) -> PurityState {\n-        match self.purity {\n+    pub fn recurse(&mut self, blk: &ast::Block) -> FnStyleState {\n+        match self.fn_style {\n             // If this unsafe, then if the outer function was already marked as\n             // unsafe we shouldn't attribute the unsafe'ness to the block. This\n             // way the block can be warned about instead of ignoring this\n             // extraneous block (functions are never warned about).\n             ast::UnsafeFn if self.from_fn => *self,\n \n-            purity => {\n-                let (purity, def) = match blk.rules {\n+            fn_style => {\n+                let (fn_style, def) = match blk.rules {\n                     ast::UnsafeBlock(..) => (ast::UnsafeFn, blk.id),\n-                    ast::DefaultBlock => (purity, self.def),\n+                    ast::DefaultBlock => (fn_style, self.def),\n                 };\n-                PurityState{ def: def,\n-                             purity: purity,\n+                FnStyleState{ def: def,\n+                             fn_style: fn_style,\n                              from_fn: false }\n             }\n         }\n@@ -227,7 +227,7 @@ pub struct FnCtxt<'a> {\n     err_count_on_creation: uint,\n \n     ret_ty: ty::t,\n-    ps: RefCell<PurityState>,\n+    ps: RefCell<FnStyleState>,\n \n     // Sometimes we generate region pointers where the precise region\n     // to use is not known. For example, an expression like `&x.f`\n@@ -281,7 +281,7 @@ fn blank_fn_ctxt<'a>(ccx: &'a CrateCtxt<'a>,\n     FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n-        ps: RefCell::new(PurityState::function(ast::ImpureFn, 0)),\n+        ps: RefCell::new(FnStyleState::function(ast::NormalFn, 0)),\n         region_lb: Cell::new(region_bnd),\n         fn_kind: Vanilla,\n         inh: inh,\n@@ -335,7 +335,7 @@ fn check_bare_fn(ccx: &CrateCtxt,\n     match ty::get(fty).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n-            let fcx = check_fn(ccx, fn_ty.purity, &fn_ty.sig,\n+            let fcx = check_fn(ccx, fn_ty.fn_style, &fn_ty.sig,\n                                decl, id, body, Vanilla, &inh);\n \n             vtable::resolve_in_block(&fcx, body);\n@@ -415,7 +415,7 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n }\n \n fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n-                purity: ast::Purity,\n+                fn_style: ast::FnStyle,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::FnDecl,\n                 id: ast::NodeId,\n@@ -456,7 +456,7 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n     let fcx = FnCtxt {\n         err_count_on_creation: err_count_on_creation,\n         ret_ty: ret_ty,\n-        ps: RefCell::new(PurityState::function(purity, id)),\n+        ps: RefCell::new(FnStyleState::function(fn_style, id)),\n         region_lb: Cell::new(body.id),\n         fn_kind: fn_kind,\n         inh: inherited,\n@@ -2127,7 +2127,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // fresh bound regions for any bound regions we find in the\n         // expected types so as to avoid capture.\n         //\n-        // Also try to pick up inferred purity and sigil, defaulting\n+        // Also try to pick up inferred style and sigil, defaulting\n         // to impure and block. Note that we only will use those for\n         // block syntax lambdas; that is, lambdas without explicit\n         // sigils.\n@@ -2136,7 +2136,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                            |x| Some((*x).clone()));\n         let error_happened = false;\n         let (expected_sig,\n-             expected_purity,\n+             expected_style,\n              expected_sigil,\n              expected_onceness,\n              expected_bounds) = {\n@@ -2146,7 +2146,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         replace_late_bound_regions_in_fn_sig(\n                             tcx, &cenv.sig,\n                             |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n-                    (Some(sig), cenv.purity, cenv.sigil,\n+                    (Some(sig), cenv.fn_style, cenv.sigil,\n                      cenv.onceness, cenv.bounds)\n                 }\n                 _ => {\n@@ -2162,25 +2162,25 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         }\n                         _ => ()\n                     }\n-                    (None, ast::ImpureFn, sigil,\n+                    (None, ast::NormalFn, sigil,\n                      onceness, bounds)\n                 }\n             }\n         };\n \n         // If the proto is specified, use that, otherwise select a\n         // proto based on inference.\n-        let (sigil, purity) = match ast_sigil_opt {\n-            Some(p) => (p, ast::ImpureFn),\n-            None => (expected_sigil, expected_purity)\n+        let (sigil, fn_style) = match ast_sigil_opt {\n+            Some(p) => (p, ast::NormalFn),\n+            None => (expected_sigil, expected_style)\n         };\n \n         // construct the function type\n         let fn_ty = astconv::ty_of_closure(fcx,\n                                            fcx.infcx(),\n                                            expr.id,\n                                            sigil,\n-                                           purity,\n+                                           fn_style,\n                                            expected_onceness,\n                                            expected_bounds,\n                                            &None,\n@@ -2208,13 +2208,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         fcx.write_ty(expr.id, fty);\n \n-        let (inherited_purity, id) =\n-            ty::determine_inherited_purity((fcx.ps.borrow().purity,\n+        let (inherited_style, id) =\n+            ty::determine_inherited_style((fcx.ps.borrow().fn_style,\n                                             fcx.ps.borrow().def),\n-                                           (purity, expr.id),\n+                                           (fn_style, expr.id),\n                                            sigil);\n \n-        check_fn(fcx.ccx, inherited_purity, &fty_sig,\n+        check_fn(fcx.ccx, inherited_style, &fty_sig,\n                  decl, id, body, fn_kind, fcx.inh);\n     }\n \n@@ -3272,8 +3272,8 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                                  expected: Option<ty::t>) {\n     let prev = {\n         let mut fcx_ps = fcx.ps.borrow_mut();\n-        let purity_state = fcx_ps.recurse(blk);\n-        replace(&mut *fcx_ps, purity_state)\n+        let fn_style_state = fcx_ps.recurse(blk);\n+        replace(&mut *fcx_ps, fn_style_state)\n     };\n \n     fcx.with_region_lb(blk.id, || {\n@@ -4223,7 +4223,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         }\n     };\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n-        purity: ast::UnsafeFn,\n+        fn_style: ast::UnsafeFn,\n         abi: abi::RustIntrinsic,\n         sig: FnSig {binder_id: it.id,\n                     inputs: inputs,"}, {"sha": "7e53445147f50dc97b4ea2fc978d96a30da0d117", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -200,14 +200,14 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_ty_generics,\n                                     &m.id, &m.ident, &m.explicit_self,\n-                                    &m.generics, &m.purity, m.decl)\n+                                    &m.generics, &m.fn_style, m.decl)\n                             }\n \n                             &ast::Provided(ref m) => {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_ty_generics,\n                                     &m.id, &m.ident, &m.explicit_self,\n-                                    &m.generics, &m.purity, m.decl)\n+                                    &m.generics, &m.fn_style, m.decl)\n                             }\n                         };\n \n@@ -376,11 +376,11 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                  m_ident: &ast::Ident,\n                                  m_explicit_self: &ast::ExplicitSelf,\n                                  m_generics: &ast::Generics,\n-                                 m_purity: &ast::Purity,\n+                                 m_fn_style: &ast::FnStyle,\n                                  m_decl: &ast::FnDecl) -> ty::Method\n     {\n         let trait_self_ty = ty::mk_self(this.tcx, local_def(trait_id));\n-        let fty = astconv::ty_of_method(this, *m_id, *m_purity, trait_self_ty,\n+        let fty = astconv::ty_of_method(this, *m_id, *m_fn_style, trait_self_ty,\n                                         *m_explicit_self, m_decl);\n         let num_trait_type_params = trait_generics.type_param_defs().len();\n         let ty_generics = ty_generics_for_fn_or_method(this, m_generics,\n@@ -508,7 +508,7 @@ fn convert_methods(ccx: &CrateCtxt,\n                     rcvr_generics: &ast::Generics,\n                     rcvr_visibility: ast::Visibility) -> ty::Method\n     {\n-        let fty = astconv::ty_of_method(ccx, m.id, m.purity,\n+        let fty = astconv::ty_of_method(ccx, m.id, m.fn_style,\n                                         untransformed_rcvr_ty,\n                                         m.explicit_self, m.decl);\n \n@@ -818,11 +818,11 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n-        ast::ItemFn(decl, purity, abi, ref generics, _) => {\n+        ast::ItemFn(decl, fn_style, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn_or_method(ccx, generics, 0);\n             let tofd = astconv::ty_of_bare_fn(ccx,\n                                               it.id,\n-                                              purity,\n+                                              fn_style,\n                                               abi,\n                                               decl);\n             let tpt = ty_param_bounds_and_ty {\n@@ -1029,7 +1029,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         ccx.tcx,\n         ty::BareFnTy {\n             abi: abi,\n-            purity: ast::UnsafeFn,\n+            fn_style: ast::UnsafeFn,\n             sig: ty::FnSig {binder_id: def_id.node,\n                             inputs: input_tys,\n                             output: output_ty,"}, {"sha": "38ffa2ae508287318f200a765630a95dfa461240", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -385,7 +385,7 @@ impl<'f> Coerce<'f> {\n             debug!(\"coerce_from_bare_fn(a={}, b={})\",\n                    a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n \n-            if fn_ty_a.abi != abi::Rust || fn_ty_a.purity != ast::ImpureFn {\n+            if fn_ty_a.abi != abi::Rust || fn_ty_a.fn_style != ast::NormalFn {\n                 return self.subtype(a, b);\n             }\n "}, {"sha": "555aaa90da144b7ec27a0ae36b390578ccc4efca", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -64,7 +64,7 @@ use util::ppaux::Repr;\n \n use std::result;\n \n-use syntax::ast::{Onceness, Purity};\n+use syntax::ast::{Onceness, FnStyle};\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n use syntax::abi;\n@@ -194,10 +194,10 @@ pub trait Combine {\n \n     fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n-        let purity = if_ok!(self.purities(a.purity, b.purity));\n+        let fn_style = if_ok!(self.fn_styles(a.fn_style, b.fn_style));\n         let abi = if_ok!(self.abi(a.abi, b.abi));\n         let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n-        Ok(ty::BareFnTy {purity: purity,\n+        Ok(ty::BareFnTy {fn_style: fn_style,\n                 abi: abi,\n                 sig: sig})\n     }\n@@ -207,11 +207,11 @@ pub trait Combine {\n \n         let p = if_ok!(self.sigils(a.sigil, b.sigil));\n         let r = if_ok!(self.contraregions(a.region, b.region));\n-        let purity = if_ok!(self.purities(a.purity, b.purity));\n+        let fn_style = if_ok!(self.fn_styles(a.fn_style, b.fn_style));\n         let onceness = if_ok!(self.oncenesses(a.onceness, b.onceness));\n         let bounds = if_ok!(self.bounds(a.bounds, b.bounds));\n         let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n-        Ok(ty::ClosureTy {purity: purity,\n+        Ok(ty::ClosureTy {fn_style: fn_style,\n                 sigil: p,\n                 onceness: onceness,\n                 region: r,\n@@ -246,7 +246,7 @@ pub trait Combine {\n         }\n     }\n \n-    fn purities(&self, a: Purity, b: Purity) -> cres<Purity>;\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle>;\n \n     fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<abi::Abi> {\n         if a == b {"}, {"sha": "24a6ab338a76152dd1b5a50ec8813f3109bdfbbb", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -1102,10 +1102,10 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                                 output: ast::P<ast::Ty>,\n                                 item: ast::P<ast::Item>,\n                                 generics: ast::Generics) {\n-        let (fn_decl, purity, ident) = match item.node {\n+        let (fn_decl, fn_style, ident) = match item.node {\n             // FIXME: handling method\n-            ast::ItemFn(ref fn_decl, ref purity, _, _, _) => {\n-                (fn_decl, purity, item.ident)\n+            ast::ItemFn(ref fn_decl, ref fn_style, _, _, _) => {\n+                (fn_decl, fn_style, item.ident)\n             },\n             _ => fail!(\"Expect function or method\")\n \n@@ -1117,7 +1117,7 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n             variadic: fn_decl.variadic\n         };\n         let suggested_fn =\n-            pprust::fun_to_str(&fd, *purity, ident, None, &generics);\n+            pprust::fun_to_str(&fd, *fn_style, ident, None, &generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n         self.tcx.sess.span_note(item.span, msg);"}, {"sha": "ea0d3a1c1d40cdc630bea3e763d413dabf1ce5a7", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -22,8 +22,8 @@ use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n use syntax::ast::{Many, Once, MutImmutable, MutMutable};\n-use syntax::ast::{ExternFn, ImpureFn, UnsafeFn, NodeId};\n-use syntax::ast::{Onceness, Purity};\n+use syntax::ast::{ExternFn, NormalFn, UnsafeFn, NodeId};\n+use syntax::ast::{Onceness, FnStyle};\n use collections::HashMap;\n use util::common::{indenter};\n use util::ppaux::mt_to_str;\n@@ -81,10 +81,10 @@ impl<'f> Combine for Glb<'f> {\n         Lub(*self.get_ref()).tys(a, b)\n     }\n \n-    fn purities(&self, a: Purity, b: Purity) -> cres<Purity> {\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n         match (a, b) {\n           (ExternFn, _) | (_, ExternFn) => Ok(ExternFn),\n-          (ImpureFn, _) | (_, ImpureFn) => Ok(ImpureFn),\n+          (NormalFn, _) | (_, NormalFn) => Ok(NormalFn),\n           (UnsafeFn, UnsafeFn) => Ok(UnsafeFn)\n         }\n     }"}, {"sha": "e355d7d48ac2321b22ae37b18947cc35608bf28b", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -23,8 +23,8 @@ use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::{TypeTrace, Subtype};\n use collections::HashMap;\n use syntax::ast::{Many, Once, NodeId};\n-use syntax::ast::{ExternFn, ImpureFn, UnsafeFn};\n-use syntax::ast::{Onceness, Purity};\n+use syntax::ast::{ExternFn, NormalFn, UnsafeFn};\n+use syntax::ast::{Onceness, FnStyle};\n use util::ppaux::mt_to_str;\n \n pub struct Lub<'f>(pub CombineFields<'f>);  // least-upper-bound: common supertype\n@@ -75,10 +75,10 @@ impl<'f> Combine for Lub<'f> {\n         Glb(*self.get_ref()).tys(a, b)\n     }\n \n-    fn purities(&self, a: Purity, b: Purity) -> cres<Purity> {\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n         match (a, b) {\n           (UnsafeFn, _) | (_, UnsafeFn) => Ok(UnsafeFn),\n-          (ImpureFn, _) | (_, ImpureFn) => Ok(ImpureFn),\n+          (NormalFn, _) | (_, NormalFn) => Ok(NormalFn),\n           (ExternFn, ExternFn) => Ok(ExternFn),\n         }\n     }"}, {"sha": "95b95380fa3efd35ca6697809acc4566085883e7", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -25,7 +25,7 @@ use middle::typeck::infer::{TypeTrace, Subtype};\n use util::common::{indenter};\n use util::ppaux::bound_region_to_str;\n \n-use syntax::ast::{Onceness, Purity};\n+use syntax::ast::{Onceness, FnStyle};\n \n pub struct Sub<'f>(pub CombineFields<'f>);  // \"subtype\", \"subregion\" etc\n \n@@ -87,9 +87,9 @@ impl<'f> Combine for Sub<'f> {\n         }\n     }\n \n-    fn purities(&self, a: Purity, b: Purity) -> cres<Purity> {\n-        self.lub().purities(a, b).compare(b, || {\n-            ty::terr_purity_mismatch(expected_found(self, a, b))\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+        self.lub().fn_styles(a, b).compare(b, || {\n+            ty::terr_fn_style_mismatch(expected_found(self, a, b))\n         })\n     }\n "}, {"sha": "791cd4f86250d63801f630220b4d570d11bfe19d", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -182,7 +182,7 @@ impl Env {\n         let inputs = input_tys.map(|t| {mode: ast::expl(ast::by_copy),\n                                         ty: *t});\n         ty::mk_fn(self.tcx, FnTyBase {\n-            meta: FnMeta {purity: ast::ImpureFn,\n+            meta: FnMeta {fn_style: ast::NormalFn,\n                           proto: ast::ProtoBare,\n                           onceness: ast::Many,\n                           region: ty::ReStatic,"}, {"sha": "f78f0a8f2731f672ac2d731f5524b8f1133b5a8e", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -357,7 +357,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n-                purity: ast::ImpureFn,\n+                fn_style: ast::NormalFn,\n                 abi: abi::Rust,\n                 sig: ty::FnSig {\n                     binder_id: main_id,\n@@ -403,7 +403,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             }\n \n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n-                purity: ast::ImpureFn,\n+                fn_style: ast::NormalFn,\n                 abi: abi::Rust,\n                 sig: ty::FnSig {\n                     binder_id: start_id,"}, {"sha": "c051b8e60cd80ef0cbdf46f83b0b620ab6350e21", "filename": "src/librustc/util/fs.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Futil%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Futil%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Ffs.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io;\n+use std::io::fs;\n+use std::os;\n+\n+/// Returns an absolute path in the filesystem that `path` points to. The\n+/// returned path does not contain any symlinks in its hierarchy.\n+pub fn realpath(original: &Path) -> io::IoResult<Path> {\n+    static MAX_LINKS_FOLLOWED: uint = 256;\n+    let original = os::make_absolute(original);\n+\n+    // Right now lstat on windows doesn't work quite well\n+    if cfg!(windows) {\n+        return Ok(original)\n+    }\n+\n+    let result = original.root_path();\n+    let mut result = result.expect(\"make_absolute has no root_path\");\n+    let mut followed = 0;\n+\n+    for part in original.components() {\n+        result.push(part);\n+\n+        loop {\n+            if followed == MAX_LINKS_FOLLOWED {\n+                return Err(io::standard_error(io::InvalidInput))\n+            }\n+\n+            match fs::lstat(&result) {\n+                Err(..) => break,\n+                Ok(ref stat) if stat.kind != io::TypeSymlink => break,\n+                Ok(..) => {\n+                    followed += 1;\n+                    let path = try!(fs::readlink(&result));\n+                    result.pop();\n+                    result.push(path);\n+                }\n+            }\n+        }\n+    }\n+\n+    return Ok(result);\n+}\n+\n+#[cfg(not(windows), test)]\n+mod test {\n+    use std::io;\n+    use std::io::fs::{File, symlink, mkdir, mkdir_recursive};\n+    use super::realpath;\n+    use std::io::TempDir;\n+\n+    #[test]\n+    fn realpath_works() {\n+        let tmpdir = TempDir::new(\"rustc-fs\").unwrap();\n+        let tmpdir = realpath(tmpdir.path()).unwrap();\n+        let file = tmpdir.join(\"test\");\n+        let dir = tmpdir.join(\"test2\");\n+        let link = dir.join(\"link\");\n+        let linkdir = tmpdir.join(\"test3\");\n+\n+        File::create(&file).unwrap();\n+        mkdir(&dir, io::UserRWX).unwrap();\n+        symlink(&file, &link).unwrap();\n+        symlink(&dir, &linkdir).unwrap();\n+\n+        assert!(realpath(&tmpdir).unwrap() == tmpdir);\n+        assert!(realpath(&file).unwrap() == file);\n+        assert!(realpath(&link).unwrap() == file);\n+        assert!(realpath(&linkdir).unwrap() == dir);\n+        assert!(realpath(&linkdir.join(\"link\")).unwrap() == file);\n+    }\n+\n+    #[test]\n+    fn realpath_works_tricky() {\n+        let tmpdir = TempDir::new(\"rustc-fs\").unwrap();\n+        let tmpdir = realpath(tmpdir.path()).unwrap();\n+\n+        let a = tmpdir.join(\"a\");\n+        let b = a.join(\"b\");\n+        let c = b.join(\"c\");\n+        let d = a.join(\"d\");\n+        let e = d.join(\"e\");\n+        let f = a.join(\"f\");\n+\n+        mkdir_recursive(&b, io::UserRWX).unwrap();\n+        mkdir_recursive(&d, io::UserRWX).unwrap();\n+        File::create(&f).unwrap();\n+        symlink(&Path::new(\"../d/e\"), &c).unwrap();\n+        symlink(&Path::new(\"../f\"), &e).unwrap();\n+\n+        assert!(realpath(&c).unwrap() == f);\n+        assert!(realpath(&e).unwrap() == f);\n+    }\n+}"}, {"sha": "e7b925197076aefb7cdb21916bea9228c29453bb", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -252,7 +252,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n         ty_to_str(cx, input)\n     }\n     fn bare_fn_to_str(cx: &ctxt,\n-                      purity: ast::Purity,\n+                      fn_style: ast::FnStyle,\n                       abi: abi::Abi,\n                       ident: Option<ast::Ident>,\n                       sig: &ty::FnSig)\n@@ -263,10 +263,10 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n             format!(\"extern {} \", abi.to_str())\n         };\n \n-        match purity {\n-            ast::ImpureFn => {}\n+        match fn_style {\n+            ast::NormalFn => {}\n             _ => {\n-                s.push_str(purity.to_str());\n+                s.push_str(fn_style.to_str());\n                 s.push_char(' ');\n             }\n         };\n@@ -305,10 +305,10 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n             }\n         }\n \n-        match cty.purity {\n-            ast::ImpureFn => {}\n+        match cty.fn_style {\n+            ast::NormalFn => {}\n             _ => {\n-                s.push_str(cty.purity.to_str());\n+                s.push_str(cty.fn_style.to_str());\n                 s.push_char(' ');\n             }\n         };\n@@ -405,7 +405,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n           closure_to_str(cx, *f)\n       }\n       ty_bare_fn(ref f) => {\n-          bare_fn_to_str(cx, f.purity, f.abi, None, &f.sig)\n+          bare_fn_to_str(cx, f.fn_style, f.abi, None, &f.sig)\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\",\n@@ -812,8 +812,8 @@ impl Repr for ast::Visibility {\n \n impl Repr for ty::BareFnTy {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"BareFnTy \\\\{purity: {:?}, abi: {}, sig: {}\\\\}\",\n-             self.purity,\n+        format!(\"BareFnTy \\\\{fn_style: {:?}, abi: {}, sig: {}\\\\}\",\n+             self.fn_style,\n              self.abi.to_str(),\n              self.sig.repr(tcx))\n     }"}, {"sha": "ce7f167ea1724fc3450cc1d09d5df5ac8f970b1c", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -356,7 +356,7 @@ impl Clean<Generics> for ast::Generics {\n pub struct Method {\n     pub generics: Generics,\n     pub self_: SelfTy,\n-    pub purity: ast::Purity,\n+    pub fn_style: ast::FnStyle,\n     pub decl: FnDecl,\n }\n \n@@ -383,7 +383,7 @@ impl Clean<Item> for ast::Method {\n             inner: MethodItem(Method {\n                 generics: self.generics.clean(),\n                 self_: self.explicit_self.clean(),\n-                purity: self.purity.clone(),\n+                fn_style: self.fn_style.clone(),\n                 decl: decl,\n             }),\n         }\n@@ -392,7 +392,7 @@ impl Clean<Item> for ast::Method {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct TyMethod {\n-    pub purity: ast::Purity,\n+    pub fn_style: ast::FnStyle,\n     pub decl: FnDecl,\n     pub generics: Generics,\n     pub self_: SelfTy,\n@@ -419,7 +419,7 @@ impl Clean<Item> for ast::TypeMethod {\n             id: self.id,\n             visibility: None,\n             inner: TyMethodItem(TyMethod {\n-                purity: self.purity.clone(),\n+                fn_style: self.fn_style.clone(),\n                 decl: decl,\n                 self_: self.explicit_self.clean(),\n                 generics: self.generics.clean(),\n@@ -451,7 +451,7 @@ impl Clean<SelfTy> for ast::ExplicitSelf {\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n-    pub purity: ast::Purity,\n+    pub fn_style: ast::FnStyle,\n }\n \n impl Clean<Item> for doctree::Function {\n@@ -465,7 +465,7 @@ impl Clean<Item> for doctree::Function {\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(),\n                 generics: self.generics.clean(),\n-                purity: self.purity,\n+                fn_style: self.fn_style,\n             }),\n         }\n     }\n@@ -478,7 +478,7 @@ pub struct ClosureDecl {\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: FnDecl,\n     pub onceness: ast::Onceness,\n-    pub purity: ast::Purity,\n+    pub fn_style: ast::FnStyle,\n     pub bounds: Vec<TyParamBound>,\n }\n \n@@ -490,7 +490,7 @@ impl Clean<ClosureDecl> for ast::ClosureTy {\n             lifetimes: self.lifetimes.clean().move_iter().collect(),\n             decl: self.decl.clean(),\n             onceness: self.onceness,\n-            purity: self.purity,\n+            fn_style: self.fn_style,\n             bounds: match self.bounds {\n                 Some(ref x) => x.clean().move_iter().collect(),\n                 None        => Vec::new()\n@@ -960,7 +960,7 @@ impl Clean<Item> for doctree::Typedef {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct BareFunctionDecl {\n-    pub purity: ast::Purity,\n+    pub fn_style: ast::FnStyle,\n     pub generics: Generics,\n     pub decl: FnDecl,\n     pub abi: ~str,\n@@ -969,7 +969,7 @@ pub struct BareFunctionDecl {\n impl Clean<BareFunctionDecl> for ast::BareFnTy {\n     fn clean(&self) -> BareFunctionDecl {\n         BareFunctionDecl {\n-            purity: self.purity,\n+            fn_style: self.fn_style,\n             generics: Generics {\n                 lifetimes: self.lifetimes.clean().move_iter().collect(),\n                 type_params: Vec::new(),\n@@ -1164,7 +1164,7 @@ impl Clean<Item> for ast::ForeignItem {\n                 ForeignFunctionItem(Function {\n                     decl: decl.clean(),\n                     generics: generics.clean(),\n-                    purity: ast::ExternFn,\n+                    fn_style: ast::ExternFn,\n                 })\n             }\n             ast::ForeignItemStatic(ref ty, mutbl) => {"}, {"sha": "5104ce81465ba829b3fc87928c7b9cf2f54a01ca", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -113,7 +113,7 @@ pub struct Function {\n     pub id: NodeId,\n     pub name: Ident,\n     pub vis: ast::Visibility,\n-    pub purity: ast::Purity,\n+    pub fn_style: ast::FnStyle,\n     pub where: Span,\n     pub generics: ast::Generics,\n }"}, {"sha": "a93107a73921083bb6507ef3f2da3ad03373e4c7", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -29,9 +29,9 @@ use html::render::{cache_key, current_location_key};\n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n pub struct VisSpace(pub Option<ast::Visibility>);\n-/// Similarly to VisSpace, this structure is used to render a purity with a\n+/// Similarly to VisSpace, this structure is used to render a function style with a\n /// space after it.\n-pub struct PuritySpace(pub ast::Purity);\n+pub struct FnStyleSpace(pub ast::FnStyle);\n /// Wrapper struct for properly emitting a method declaration.\n pub struct Method<'a>(pub &'a clean::SelfTy, pub &'a clean::FnDecl);\n \n@@ -41,9 +41,9 @@ impl VisSpace {\n     }\n }\n \n-impl PuritySpace {\n-    pub fn get(&self) -> ast::Purity {\n-        let PuritySpace(v) = *self; v\n+impl FnStyleSpace {\n+    pub fn get(&self) -> ast::FnStyle {\n+        let FnStyleSpace(v) = *self; v\n     }\n }\n \n@@ -343,7 +343,7 @@ impl fmt::Show for clean::Type {\n                 };\n \n                 write!(f.buf, \"{}{}{arrow, select, yes{ -&gt; {ret}} other{}}\",\n-                       PuritySpace(decl.purity),\n+                       FnStyleSpace(decl.fn_style),\n                        match decl.sigil {\n                            ast::OwnedSigil => format!(\"proc({})\", decl.decl.inputs),\n                            ast::BorrowedSigil => format!(\"{}|{}|\", region, decl.decl.inputs),\n@@ -355,7 +355,7 @@ impl fmt::Show for clean::Type {\n             }\n             clean::BareFunction(ref decl) => {\n                 write!(f.buf, \"{}{}fn{}{}\",\n-                       PuritySpace(decl.purity),\n+                       FnStyleSpace(decl.fn_style),\n                        match decl.abi {\n                            ref x if \"\" == *x => ~\"\",\n                            ref x if \"\\\"Rust\\\"\" == *x => ~\"\",\n@@ -472,12 +472,12 @@ impl fmt::Show for VisSpace {\n     }\n }\n \n-impl fmt::Show for PuritySpace {\n+impl fmt::Show for FnStyleSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n             ast::UnsafeFn => write!(f.buf, \"unsafe \"),\n             ast::ExternFn => write!(f.buf, \"extern \"),\n-            ast::ImpureFn => Ok(())\n+            ast::NormalFn => Ok(())\n         }\n     }\n }"}, {"sha": "788b2a5e6cd320848a238eb207a6b19eaf04043b", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -133,7 +133,7 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n             slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n                 let text = str::from_utf8(text).unwrap();\n                 let mut lines = text.lines().filter(|l| stripped_filtered_line(*l).is_none());\n-                let text = lines.collect::<~[&str]>().connect(\"\\n\");\n+                let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n \n                 let buf = buf {\n                     data: text.as_bytes().as_ptr(),\n@@ -186,7 +186,7 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n                 Some(s) => s.to_lower().into_str(),\n                 None => s.to_owned()\n             }\n-        }).collect::<~[~str]>().connect(\"-\");\n+        }).collect::<Vec<~str>>().connect(\"-\");\n \n         let opaque = unsafe {&mut *(opaque as *mut my_opaque)};\n \n@@ -285,7 +285,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                 let tests = &mut *(opaque as *mut ::test::Collector);\n                 let text = str::from_utf8(text).unwrap();\n                 let mut lines = text.lines().map(|l| stripped_filtered_line(l).unwrap_or(l));\n-                let text = lines.collect::<~[&str]>().connect(\"\\n\");\n+                let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n                 tests.add_test(text, should_fail, no_run, ignore);\n             })\n         }"}, {"sha": "2bc4b6e841f55047a3ba03d27a3e41031f9ca8da", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -51,7 +51,7 @@ use rustc::util::nodemap::NodeSet;\n use clean;\n use doctree;\n use fold::DocFolder;\n-use html::format::{VisSpace, Method, PuritySpace};\n+use html::format::{VisSpace, Method, FnStyleSpace};\n use html::layout;\n use html::markdown;\n use html::markdown::Markdown;\n@@ -262,10 +262,11 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     cache.stack.push(krate.name.clone());\n     krate = cache.fold_crate(krate);\n     {\n+        let Cache { search_index: ref mut index,\n+                    orphan_methods: ref meths, paths: ref mut paths, ..} = cache;\n+\n         // Attach all orphan methods to the type's definition if the type\n         // has since been learned.\n-        let Cache { search_index: ref mut index,\n-                    orphan_methods: ref meths, paths: ref paths, ..} = cache;\n         for &(ref pid, ref item) in meths.iter() {\n             match paths.find(pid) {\n                 Some(&(ref fqp, _)) => {\n@@ -280,6 +281,18 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n                 None => {}\n             }\n         };\n+\n+        // Prune the paths that do not appear in the index.\n+        let mut unseen: HashSet<ast::NodeId> = paths.keys().map(|&id| id).collect();\n+        for item in index.iter() {\n+            match item.parent {\n+                Some(ref pid) => { unseen.remove(pid); }\n+                None => {}\n+            }\n+        }\n+        for pid in unseen.iter() {\n+            paths.remove(pid);\n+        }\n     }\n \n     // Publish the search index\n@@ -1178,10 +1191,10 @@ fn item_module(w: &mut Writer, cx: &Context,\n \n fn item_function(w: &mut Writer, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n-    try!(write!(w, \"<pre class='rust fn'>{vis}{purity}fn \\\n+    try!(write!(w, \"<pre class='rust fn'>{vis}{fn_style}fn \\\n                     {name}{generics}{decl}</pre>\",\n            vis = VisSpace(it.visibility),\n-           purity = PuritySpace(f.purity),\n+           fn_style = FnStyleSpace(f.fn_style),\n            name = it.name.get_ref().as_slice(),\n            generics = f.generics,\n            decl = f.decl));\n@@ -1205,8 +1218,8 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n                   it.name.get_ref().as_slice(),\n                   t.generics,\n                   parents));\n-    let required = t.methods.iter().filter(|m| m.is_req()).collect::<~[&clean::TraitMethod]>();\n-    let provided = t.methods.iter().filter(|m| !m.is_req()).collect::<~[&clean::TraitMethod]>();\n+    let required = t.methods.iter().filter(|m| m.is_req()).collect::<Vec<&clean::TraitMethod>>();\n+    let provided = t.methods.iter().filter(|m| !m.is_req()).collect::<Vec<&clean::TraitMethod>>();\n \n     if t.methods.len() == 0 {\n         try!(write!(w, \"\\\\{ \\\\}\"));\n@@ -1292,12 +1305,12 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n }\n \n fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n-    fn fun(w: &mut Writer, it: &clean::Item, purity: ast::Purity,\n+    fn fun(w: &mut Writer, it: &clean::Item, fn_style: ast::FnStyle,\n            g: &clean::Generics, selfty: &clean::SelfTy,\n            d: &clean::FnDecl) -> fmt::Result {\n         write!(w, \"{}fn <a href='\\\\#{ty}.{name}' class='fnname'>{name}</a>\\\n                    {generics}{decl}\",\n-               match purity {\n+               match fn_style {\n                    ast::UnsafeFn => \"unsafe \",\n                    _ => \"\",\n                },\n@@ -1308,10 +1321,10 @@ fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n     }\n     match meth.inner {\n         clean::TyMethodItem(ref m) => {\n-            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl)\n+            fun(w, meth, m.fn_style, &m.generics, &m.self_, &m.decl)\n         }\n         clean::MethodItem(ref m) => {\n-            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl)\n+            fun(w, meth, m.fn_style, &m.generics, &m.self_, &m.decl)\n         }\n         _ => unreachable!()\n     }\n@@ -1502,11 +1515,11 @@ fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n                 let mut non_trait = v.iter().filter(|p| {\n                     p.ref0().trait_.is_none()\n                 });\n-                let non_trait = non_trait.collect::<~[&(clean::Impl, Option<~str>)]>();\n+                let non_trait = non_trait.collect::<Vec<&(clean::Impl, Option<~str>)>>();\n                 let mut traits = v.iter().filter(|p| {\n                     p.ref0().trait_.is_some()\n                 });\n-                let traits = traits.collect::<~[&(clean::Impl, Option<~str>)]>();\n+                let traits = traits.collect::<Vec<&(clean::Impl, Option<~str>)>>();\n \n                 if non_trait.len() > 0 {\n                     try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));"}, {"sha": "1904ab27d17d94f4927281c3bd899e098f5aa4cf", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -137,8 +137,6 @@\n                 val = valLower,\n                 typeFilter = query.type,\n                 results = [],\n-                aa = 0,\n-                bb = 0,\n                 split = valLower.split(\"::\");\n \n             //remove empty keywords\n@@ -150,16 +148,16 @@\n             }\n \n             // quoted values mean literal search\n-            bb = searchWords.length;\n+            var nSearchWords = searchWords.length;\n             if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n                 val.charAt(val.length - 1) === val.charAt(0))\n             {\n                 val = val.substr(1, val.length - 2);\n-                for (aa = 0; aa < bb; aa += 1) {\n-                    if (searchWords[aa] === val) {\n+                for (var i = 0; i < nSearchWords; i += 1) {\n+                    if (searchWords[i] === val) {\n                         // filter type: ... queries\n-                        if (!typeFilter || typeFilter === searchIndex[aa].ty) {\n-                            results.push([aa, -1]);\n+                        if (!typeFilter || typeFilter === searchIndex[i].ty) {\n+                            results.push({id: i, index: -1});\n                         }\n                     }\n                     if (results.length === max) {\n@@ -170,14 +168,14 @@\n                 // gather matching search results up to a certain maximum\n                 val = val.replace(/\\_/g, \"\");\n                 for (var i = 0; i < split.length; i++) {\n-                    for (aa = 0; aa < bb; aa += 1) {\n-                        if (searchWords[aa].indexOf(split[i]) > -1 ||\n-                            searchWords[aa].indexOf(val) > -1 ||\n-                            searchWords[aa].replace(/_/g, \"\").indexOf(val) > -1)\n+                    for (var j = 0; j < nSearchWords; j += 1) {\n+                        if (searchWords[j].indexOf(split[i]) > -1 ||\n+                            searchWords[j].indexOf(val) > -1 ||\n+                            searchWords[j].replace(/_/g, \"\").indexOf(val) > -1)\n                         {\n                             // filter type: ... queries\n-                            if (!typeFilter || typeFilter === searchIndex[aa].ty) {\n-                                results.push([aa, searchWords[aa].replace(/_/g, \"\").indexOf(val)]);\n+                            if (!typeFilter || typeFilter === searchIndex[j].ty) {\n+                                results.push({id: j, index: searchWords[j].replace(/_/g, \"\").indexOf(val)});\n                             }\n                         }\n                         if (results.length === max) {\n@@ -187,13 +185,12 @@\n                 }\n             }\n \n-            bb = results.length;\n-            for (aa = 0; aa < bb; aa += 1) {\n-                results[aa].push(searchIndex[results[aa][0]].ty);\n-                results[aa].push(searchIndex[results[aa][0]].path);\n-                results[aa].push(searchIndex[results[aa][0]].name);\n-                results[aa].push(searchIndex[results[aa][0]].parent);\n-                results[aa].push(searchIndex[results[aa][0]].crate);\n+            var nresults = results.length;\n+            for (var i = 0; i < nresults; i += 1) {\n+                results[i].word = searchWords[results[i].id];\n+                results[i].item = searchIndex[results[i].id] || {};\n+                results[i].ty = results[i].item.ty;\n+                results[i].path = results[i].item.path;\n             }\n             // if there are no results then return to default and fail\n             if (results.length === 0) {\n@@ -202,70 +199,70 @@\n \n             // sort by exact match\n             results.sort(function search_complete_sort0(aaa, bbb) {\n-                if (searchWords[aaa[0]] === valLower &&\n-                    searchWords[bbb[0]] !== valLower) {\n+                if (aaa.word === valLower &&\n+                    bbb.word !== valLower) {\n                     return 1;\n                 }\n             });\n             // first sorting attempt\n             // sort by item name length\n             results.sort(function search_complete_sort1(aaa, bbb) {\n-                if (searchWords[aaa[0]].length > searchWords[bbb[0]].length) {\n+                if (aaa.word.length > bbb.word.length) {\n                     return 1;\n                 }\n             });\n             // second sorting attempt\n             // sort by item name\n             results.sort(function search_complete_sort1(aaa, bbb) {\n-                if (searchWords[aaa[0]].length === searchWords[bbb[0]].length &&\n-                    searchWords[aaa[0]] > searchWords[bbb[0]]) {\n+                if (aaa.word.length === bbb.word.length &&\n+                    aaa.word > bbb.word) {\n                     return 1;\n                 }\n             });\n             // third sorting attempt\n             // sort by index of keyword in item name\n-            if (results[0][1] !== -1) {\n+            if (results[0].index !== -1) {\n                 results.sort(function search_complete_sort1(aaa, bbb) {\n-                    if (aaa[1] > bbb[1] && bbb[1] === 0) {\n+                    if (aaa.index > bbb.index && bbb.index === 0) {\n                         return 1;\n                     }\n                 });\n             }\n             // fourth sorting attempt\n             // sort by type\n             results.sort(function search_complete_sort3(aaa, bbb) {\n-                if (searchWords[aaa[0]] === searchWords[bbb[0]] &&\n-                    aaa[2] > bbb[2]) {\n+                if (aaa.word === bbb.word &&\n+                    aaa.ty > bbb.ty) {\n                     return 1;\n                 }\n             });\n             // fifth sorting attempt\n             // sort by path\n             results.sort(function search_complete_sort4(aaa, bbb) {\n-                if (searchWords[aaa[0]] === searchWords[bbb[0]] &&\n-                    aaa[2] === bbb[2] && aaa[3] > bbb[3]) {\n+                if (aaa.word === bbb.word &&\n+                    aaa.ty === bbb.ty && aaa.path > bbb.path) {\n                     return 1;\n                 }\n             });\n             // sixth sorting attempt\n             // remove duplicates, according to the data provided\n-            for (aa = results.length - 1; aa > 0; aa -= 1) {\n-                if (searchWords[results[aa][0]] === searchWords[results[aa - 1][0]] &&\n-                    results[aa][2] === results[aa - 1][2] &&\n-                    results[aa][3] === results[aa - 1][3])\n+            for (var i = results.length - 1; i > 0; i -= 1) {\n+                if (results[i].word === results[i - 1].word &&\n+                    results[i].ty === results[i - 1].ty &&\n+                    results[i].path === results[i - 1].path)\n                 {\n-                    results[aa][0] = -1;\n+                    results[i].id = -1;\n                 }\n             }\n             for (var i = 0; i < results.length; i++) {\n                 var result = results[i],\n-                    name = result[4].toLowerCase(),\n-                    path = result[3].toLowerCase(),\n-                    parent = allPaths[result[6]][result[5]];\n+                    name = result.item.name.toLowerCase(),\n+                    path = result.item.path.toLowerCase(),\n+                    parent = allPaths[result.item.crate][result.item.parent];\n \n                 var valid = validateResult(name, path, split, parent);\n                 if (!valid) {\n-                    result[0] = -1;\n+                    result.id = -1;\n                 }\n             }\n             return results;\n@@ -495,8 +492,8 @@\n             resultIndex = execQuery(query, 20000, index);\n             len = resultIndex.length;\n             for (i = 0; i < len; i += 1) {\n-                if (resultIndex[i][0] > -1) {\n-                    obj = searchIndex[resultIndex[i][0]];\n+                if (resultIndex[i].id > -1) {\n+                    obj = searchIndex[resultIndex[i].id];\n                     filterdata.push([obj.name, obj.ty, obj.path, obj.desc]);\n                     results.push(obj);\n                 }\n@@ -580,7 +577,6 @@\n \n         // Draw a convenient sidebar of known crates if we have a listing\n         if (rootPath == '../') {\n-            console.log('here');\n             var sidebar = $('.sidebar');\n             var div = $('<div>').attr('class', 'block crate');\n             div.append($('<h2>').text('Crates'));"}, {"sha": "be1a17e3e31434a432dd34e6687f5247c9723310", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -161,12 +161,12 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, libs: HashSet<Path>, mut test_args: ~[~str]) -> int {\n+pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<~str>) -> int {\n     let input_str = load_or_return!(input, 1, 2);\n \n     let mut collector = Collector::new(input.to_owned(), libs, true, true);\n     find_testable_code(input_str, &mut collector);\n     test_args.unshift(~\"rustdoctest\");\n-    testing::test_main(test_args, collector.tests);\n+    testing::test_main(test_args.as_slice(), collector.tests);\n     0\n }"}, {"sha": "7de898a50a9e3485f410ba41179eb45932e7518c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -95,7 +95,7 @@ impl<'a> RustdocVisitor<'a> {\n     }\n \n     pub fn visit_fn(&mut self, item: &ast::Item, fd: &ast::FnDecl,\n-                    purity: &ast::Purity, _abi: &abi::Abi,\n+                    fn_style: &ast::FnStyle, _abi: &abi::Abi,\n                     gen: &ast::Generics) -> Function {\n         debug!(\"Visiting fn\");\n         Function {\n@@ -106,7 +106,7 @@ impl<'a> RustdocVisitor<'a> {\n             name: item.ident,\n             where: item.span,\n             generics: gen.clone(),\n-            purity: *purity,\n+            fn_style: *fn_style,\n         }\n     }\n "}, {"sha": "3ea58a71cfe3ce59b2ce9d5e2b213170a0145563", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -31,15 +31,15 @@ pub struct Guard<'a> {\n }\n \n struct Inner {\n-    queue: ~[BlockedTask],\n+    queue: Vec<BlockedTask>,\n     held: bool,\n }\n \n impl Access {\n     pub fn new() -> Access {\n         Access {\n             inner: UnsafeArc::new(Inner {\n-                queue: ~[],\n+                queue: vec![],\n                 held: false,\n             })\n         }"}, {"sha": "69be32a60211d5812e7a6ae13aad756a407922fb", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -152,13 +152,13 @@ impl FsRequest {\n     }\n \n     pub fn readdir(loop_: &Loop, path: &CString, flags: c_int)\n-        -> Result<~[Path], UvError>\n+        -> Result<Vec<Path>, UvError>\n     {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_readdir(loop_.handle,\n                                 req, path.with_ref(|p| p), flags, cb)\n         }).map(|req| unsafe {\n-            let mut paths = ~[];\n+            let mut paths = vec!();\n             let path = CString::new(path.with_ref(|p| p), false);\n             let parent = Path::new(path);\n             let _ = c_str::from_c_multistring(req.get_ptr() as *libc::c_char,"}, {"sha": "55456bb548e91ec480d1814cfce5c75f0bf8dc06", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -234,7 +234,7 @@ impl IoFactory for UvIoFactory {\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_readdir(&mut self, path: &CString, flags: c_int)\n-        -> Result<~[Path], IoError>\n+        -> Result<Vec<Path>, IoError>\n     {\n         let r = FsRequest::readdir(&self.loop_, path, flags);\n         r.map_err(uv_error_to_io_error)"}, {"sha": "d753922f7f42661c96d9ccffecdea67887a43294", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -636,7 +636,7 @@ pub mod writer {\n     // ebml writing\n     pub struct Encoder<'a, W> {\n         pub writer: &'a mut W,\n-        size_positions: ~[uint],\n+        size_positions: Vec<uint>,\n     }\n \n     fn write_sized_vuint<W: Writer>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n@@ -668,10 +668,9 @@ pub mod writer {\n     }\n \n     pub fn Encoder<'a, W: Writer + Seek>(w: &'a mut W) -> Encoder<'a, W> {\n-        let size_positions: ~[uint] = ~[];\n         Encoder {\n             writer: w,\n-            size_positions: size_positions,\n+            size_positions: vec!(),\n         }\n     }\n "}, {"sha": "ec064f4f5ec735c697063566f738f6b482735380", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -10,7 +10,6 @@\n \n //! Types dealing with dynamic mutability\n \n-use cast;\n use clone::Clone;\n use cmp::Eq;\n use fmt;\n@@ -70,7 +69,7 @@ impl<T: Copy + fmt::Show> fmt::Show for Cell<T> {\n /// A mutable memory location with dynamically checked borrow rules\n pub struct RefCell<T> {\n     value: Unsafe<T>,\n-    borrow: BorrowFlag,\n+    borrow: Cell<BorrowFlag>,\n     nocopy: marker::NoCopy,\n     noshare: marker::NoShare,\n }\n@@ -86,33 +85,29 @@ impl<T> RefCell<T> {\n     pub fn new(value: T) -> RefCell<T> {\n         RefCell {\n             value: Unsafe::new(value),\n+            borrow: Cell::new(UNUSED),\n             nocopy: marker::NoCopy,\n             noshare: marker::NoShare,\n-            borrow: UNUSED,\n         }\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n     pub fn unwrap(self) -> T {\n-        assert!(self.borrow == UNUSED);\n+        assert!(self.borrow.get() == UNUSED);\n         unsafe{self.value.unwrap()}\n     }\n \n-    unsafe fn as_mut<'a>(&'a self) -> &'a mut RefCell<T> {\n-        cast::transmute_mut(self)\n-    }\n-\n     /// Attempts to immutably borrow the wrapped value.\n     ///\n     /// The borrow lasts until the returned `Ref` exits scope. Multiple\n     /// immutable borrows can be taken out at the same time.\n     ///\n     /// Returns `None` if the value is currently mutably borrowed.\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n-        match self.borrow {\n+        match self.borrow.get() {\n             WRITING => None,\n-            _ => {\n-                unsafe { self.as_mut().borrow += 1; }\n+            borrow => {\n+                self.borrow.set(borrow + 1);\n                 Some(Ref { parent: self })\n             }\n         }\n@@ -140,11 +135,10 @@ impl<T> RefCell<T> {\n     ///\n     /// Returns `None` if the value is currently borrowed.\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n-        match self.borrow {\n-            UNUSED => unsafe {\n-                let mut_self = self.as_mut();\n-                mut_self.borrow = WRITING;\n-                Some(RefMut { parent: mut_self })\n+        match self.borrow.get() {\n+            UNUSED => {\n+                self.borrow.set(WRITING);\n+                Some(RefMut { parent: self })\n             },\n             _ => None\n         }\n@@ -186,8 +180,9 @@ pub struct Ref<'b, T> {\n #[unsafe_destructor]\n impl<'b, T> Drop for Ref<'b, T> {\n     fn drop(&mut self) {\n-        assert!(self.parent.borrow != WRITING && self.parent.borrow != UNUSED);\n-        unsafe { self.parent.as_mut().borrow -= 1; }\n+        let borrow = self.parent.borrow.get();\n+        assert!(borrow != WRITING && borrow != UNUSED);\n+        self.parent.borrow.set(borrow - 1);\n     }\n }\n \n@@ -200,14 +195,15 @@ impl<'b, T> Deref<T> for Ref<'b, T> {\n \n /// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n pub struct RefMut<'b, T> {\n-    parent: &'b mut RefCell<T>\n+    parent: &'b RefCell<T>\n }\n \n #[unsafe_destructor]\n impl<'b, T> Drop for RefMut<'b, T> {\n     fn drop(&mut self) {\n-        assert!(self.parent.borrow == WRITING);\n-        self.parent.borrow = UNUSED;\n+        let borrow = self.parent.borrow.get();\n+        assert!(borrow == WRITING);\n+        self.parent.borrow.set(UNUSED);\n     }\n }\n "}, {"sha": "36ffb8572378f170fb2b0d9296c93c3a809afe26", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -131,13 +131,13 @@ pub enum Method<'a> {\n     ///\n     /// The final element of this enum is the default \"other\" case which is\n     /// always required to be specified.\n-    Plural(Option<uint>, ~[PluralArm<'a>], ~[Piece<'a>]),\n+    Plural(Option<uint>, Vec<PluralArm<'a>>, Vec<Piece<'a>>),\n \n     /// A select method selects over a string. Each arm is a different string\n     /// which can be selected for.\n     ///\n     /// As with `Plural`, a default \"other\" case is required as well.\n-    Select(~[SelectArm<'a>], ~[Piece<'a>]),\n+    Select(Vec<SelectArm<'a>>, Vec<Piece<'a>>),\n }\n \n /// A selector for what pluralization a plural method should take\n@@ -156,7 +156,7 @@ pub struct PluralArm<'a> {\n     /// literal.\n     pub selector: PluralSelector,\n     /// Array of pieces which are the format of this arm\n-    pub result: ~[Piece<'a>],\n+    pub result: Vec<Piece<'a>>,\n }\n \n /// Enum of the 5 CLDR plural keywords. There is one more, \"other\", but that\n@@ -184,7 +184,7 @@ pub struct SelectArm<'a> {\n     /// String selector which guards this arm\n     pub selector: &'a str,\n     /// Array of pieces which are the format of this arm\n-    pub result: ~[Piece<'a>],\n+    pub result: Vec<Piece<'a>>,\n }\n \n /// The parser structure for interpreting the input format string. This is\n@@ -198,7 +198,7 @@ pub struct Parser<'a> {\n     cur: str::CharOffsets<'a>,\n     depth: uint,\n     /// Error messages accumulated during parsing\n-    pub errors: ~[~str],\n+    pub errors: Vec<~str>,\n }\n \n impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n@@ -236,7 +236,7 @@ impl<'a> Parser<'a> {\n             input: s,\n             cur: s.char_indices(),\n             depth: 0,\n-            errors: ~[],\n+            errors: vec!(),\n         }\n     }\n \n@@ -463,7 +463,7 @@ impl<'a> Parser<'a> {\n     /// Parses a 'select' statement (after the initial 'select' word)\n     fn select(&mut self) -> ~Method<'a> {\n         let mut other = None;\n-        let mut arms = ~[];\n+        let mut arms = vec!();\n         // Consume arms one at a time\n         loop {\n             self.ws();\n@@ -496,7 +496,7 @@ impl<'a> Parser<'a> {\n             Some(arm) => { arm }\n             None => {\n                 self.err(\"`select` statement must provide an `other` case\");\n-                ~[]\n+                vec!()\n             }\n         };\n         ~Select(arms, other)\n@@ -506,7 +506,7 @@ impl<'a> Parser<'a> {\n     fn plural(&mut self) -> ~Method<'a> {\n         let mut offset = None;\n         let mut other = None;\n-        let mut arms = ~[];\n+        let mut arms = vec!();\n \n         // First, attempt to parse the 'offset:' field. We know the set of\n         // selector words which can appear in plural arms, and the only ones\n@@ -594,7 +594,7 @@ impl<'a> Parser<'a> {\n             Some(arm) => { arm }\n             None => {\n                 self.err(\"`plural` statement must provide an `other` case\");\n-                ~[]\n+                vec!()\n             }\n         };\n         ~Plural(offset, arms, other)\n@@ -684,9 +684,9 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n-    fn same(fmt: &'static str, p: ~[Piece<'static>]) {\n+    fn same(fmt: &'static str, p: &[Piece<'static>]) {\n         let mut parser = Parser::new(fmt);\n-        assert!(p == parser.collect());\n+        assert!(p == parser.collect::<Vec<Piece<'static>>>().as_slice());\n     }\n \n     fn fmtdflt() -> FormatSpec<'static> {\n@@ -708,12 +708,12 @@ mod tests {\n \n     #[test]\n     fn simple() {\n-        same(\"asdf\", ~[String(\"asdf\")]);\n-        same(\"a\\\\{b\", ~[String(\"a\"), String(\"{b\")]);\n-        same(\"a\\\\#b\", ~[String(\"a\"), String(\"#b\")]);\n-        same(\"a\\\\}b\", ~[String(\"a\"), String(\"}b\")]);\n-        same(\"a\\\\}\", ~[String(\"a\"), String(\"}\")]);\n-        same(\"\\\\}\", ~[String(\"}\")]);\n+        same(\"asdf\", [String(\"asdf\")]);\n+        same(\"a\\\\{b\", [String(\"a\"), String(\"{b\")]);\n+        same(\"a\\\\#b\", [String(\"a\"), String(\"#b\")]);\n+        same(\"a\\\\}b\", [String(\"a\"), String(\"}b\")]);\n+        same(\"a\\\\}\", [String(\"a\"), String(\"}\")]);\n+        same(\"\\\\}\", [String(\"}\")]);\n     }\n \n     #[test] fn invalid01() { musterr(\"{\") }\n@@ -725,31 +725,31 @@ mod tests {\n \n     #[test]\n     fn format_nothing() {\n-        same(\"{}\", ~[Argument(Argument {\n+        same(\"{}\", [Argument(Argument {\n             position: ArgumentNext,\n             format: fmtdflt(),\n             method: None,\n         })]);\n     }\n     #[test]\n     fn format_position() {\n-        same(\"{3}\", ~[Argument(Argument {\n+        same(\"{3}\", [Argument(Argument {\n             position: ArgumentIs(3),\n             format: fmtdflt(),\n             method: None,\n         })]);\n     }\n     #[test]\n     fn format_position_nothing_else() {\n-        same(\"{3:}\", ~[Argument(Argument {\n+        same(\"{3:}\", [Argument(Argument {\n             position: ArgumentIs(3),\n             format: fmtdflt(),\n             method: None,\n         })]);\n     }\n     #[test]\n     fn format_type() {\n-        same(\"{3:a}\", ~[Argument(Argument {\n+        same(\"{3:a}\", [Argument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n@@ -764,7 +764,7 @@ mod tests {\n     }\n     #[test]\n     fn format_align_fill() {\n-        same(\"{3:>}\", ~[Argument(Argument {\n+        same(\"{3:>}\", [Argument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n@@ -776,7 +776,7 @@ mod tests {\n             },\n             method: None,\n         })]);\n-        same(\"{3:0<}\", ~[Argument(Argument {\n+        same(\"{3:0<}\", [Argument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('0'),\n@@ -788,7 +788,7 @@ mod tests {\n             },\n             method: None,\n         })]);\n-        same(\"{3:*<abcd}\", ~[Argument(Argument {\n+        same(\"{3:*<abcd}\", [Argument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('*'),\n@@ -803,7 +803,7 @@ mod tests {\n     }\n     #[test]\n     fn format_counts() {\n-        same(\"{:10s}\", ~[Argument(Argument {\n+        same(\"{:10s}\", [Argument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -815,7 +815,7 @@ mod tests {\n             },\n             method: None,\n         })]);\n-        same(\"{:10$.10s}\", ~[Argument(Argument {\n+        same(\"{:10$.10s}\", [Argument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -827,7 +827,7 @@ mod tests {\n             },\n             method: None,\n         })]);\n-        same(\"{:.*s}\", ~[Argument(Argument {\n+        same(\"{:.*s}\", [Argument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -839,7 +839,7 @@ mod tests {\n             },\n             method: None,\n         })]);\n-        same(\"{:.10$s}\", ~[Argument(Argument {\n+        same(\"{:.10$s}\", [Argument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -851,7 +851,7 @@ mod tests {\n             },\n             method: None,\n         })]);\n-        same(\"{:a$.b$s}\", ~[Argument(Argument {\n+        same(\"{:a$.b$s}\", [Argument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -866,7 +866,7 @@ mod tests {\n     }\n     #[test]\n     fn format_flags() {\n-        same(\"{:-}\", ~[Argument(Argument {\n+        same(\"{:-}\", [Argument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -878,7 +878,7 @@ mod tests {\n             },\n             method: None,\n         })]);\n-        same(\"{:+#}\", ~[Argument(Argument {\n+        same(\"{:+#}\", [Argument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -893,7 +893,7 @@ mod tests {\n     }\n     #[test]\n     fn format_mixture() {\n-        same(\"abcd {3:a} efg\", ~[String(\"abcd \"), Argument(Argument {\n+        same(\"abcd {3:a} efg\", [String(\"abcd \"), Argument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n@@ -909,42 +909,42 @@ mod tests {\n \n     #[test]\n     fn select_simple() {\n-        same(\"{, select, other { haha } }\", ~[Argument(Argument{\n+        same(\"{, select, other { haha } }\", [Argument(Argument{\n             position: ArgumentNext,\n             format: fmtdflt(),\n-            method: Some(~Select(~[], ~[String(\" haha \")]))\n+            method: Some(~Select(vec![], vec![String(\" haha \")]))\n         })]);\n-        same(\"{1, select, other { haha } }\", ~[Argument(Argument{\n+        same(\"{1, select, other { haha } }\", [Argument(Argument{\n             position: ArgumentIs(1),\n             format: fmtdflt(),\n-            method: Some(~Select(~[], ~[String(\" haha \")]))\n+            method: Some(~Select(vec![], vec![String(\" haha \")]))\n         })]);\n-        same(\"{1, select, other {#} }\", ~[Argument(Argument{\n+        same(\"{1, select, other {#} }\", [Argument(Argument{\n             position: ArgumentIs(1),\n             format: fmtdflt(),\n-            method: Some(~Select(~[], ~[CurrentArgument]))\n+            method: Some(~Select(vec![], vec![CurrentArgument]))\n         })]);\n-        same(\"{1, select, other {{2, select, other {lol}}} }\", ~[Argument(Argument{\n+        same(\"{1, select, other {{2, select, other {lol}}} }\", [Argument(Argument{\n             position: ArgumentIs(1),\n             format: fmtdflt(),\n-            method: Some(~Select(~[], ~[Argument(Argument{\n+            method: Some(~Select(vec![], vec![Argument(Argument{\n                 position: ArgumentIs(2),\n                 format: fmtdflt(),\n-                method: Some(~Select(~[], ~[String(\"lol\")]))\n+                method: Some(~Select(vec![], vec![String(\"lol\")]))\n             })])) // wat\n         })]);\n     }\n \n     #[test]\n     fn select_cases() {\n-        same(\"{1, select, a{1} b{2} c{3} other{4} }\", ~[Argument(Argument{\n+        same(\"{1, select, a{1} b{2} c{3} other{4} }\", [Argument(Argument{\n             position: ArgumentIs(1),\n             format: fmtdflt(),\n-            method: Some(~Select(~[\n-                SelectArm{ selector: \"a\", result: ~[String(\"1\")] },\n-                SelectArm{ selector: \"b\", result: ~[String(\"2\")] },\n-                SelectArm{ selector: \"c\", result: ~[String(\"3\")] },\n-            ], ~[String(\"4\")]))\n+            method: Some(~Select(vec![\n+                SelectArm{ selector: \"a\", result: vec![String(\"1\")] },\n+                SelectArm{ selector: \"b\", result: vec![String(\"2\")] },\n+                SelectArm{ selector: \"c\", result: vec![String(\"3\")] },\n+            ], vec![String(\"4\")]))\n         })]);\n     }\n \n@@ -961,25 +961,25 @@ mod tests {\n \n     #[test]\n     fn plural_simple() {\n-        same(\"{, plural, other { haha } }\", ~[Argument(Argument{\n+        same(\"{, plural, other { haha } }\", [Argument(Argument{\n             position: ArgumentNext,\n             format: fmtdflt(),\n-            method: Some(~Plural(None, ~[], ~[String(\" haha \")]))\n+            method: Some(~Plural(None, vec![], vec![String(\" haha \")]))\n         })]);\n-        same(\"{:, plural, other { haha } }\", ~[Argument(Argument{\n+        same(\"{:, plural, other { haha } }\", [Argument(Argument{\n             position: ArgumentNext,\n             format: fmtdflt(),\n-            method: Some(~Plural(None, ~[], ~[String(\" haha \")]))\n+            method: Some(~Plural(None, vec![], vec![String(\" haha \")]))\n         })]);\n         same(\"{, plural, offset:1 =2{2} =3{3} many{yes} other{haha} }\",\n-        ~[Argument(Argument{\n+        [Argument(Argument{\n             position: ArgumentNext,\n             format: fmtdflt(),\n-            method: Some(~Plural(Some(1), ~[\n-                PluralArm{ selector: Literal(2), result: ~[String(\"2\")] },\n-                PluralArm{ selector: Literal(3), result: ~[String(\"3\")] },\n-                PluralArm{ selector: Keyword(Many), result: ~[String(\"yes\")] }\n-            ], ~[String(\"haha\")]))\n+            method: Some(~Plural(Some(1), vec![\n+                PluralArm{ selector: Literal(2), result: vec![String(\"2\")] },\n+                PluralArm{ selector: Literal(3), result: vec![String(\"3\")] },\n+                PluralArm{ selector: Keyword(Many), result: vec![String(\"yes\")] }\n+            ], vec![String(\"haha\")]))\n         })]);\n     }\n }"}, {"sha": "e1eaa2792bf3198a812ee1ad8c2cce787fd9f136", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -21,7 +21,7 @@ use option::{Option, Some, None};\n use result::{Ok, Err};\n use io;\n use io::{IoError, IoResult, Reader};\n-use slice::{OwnedVector, ImmutableVector};\n+use slice::{OwnedVector, ImmutableVector, Vector};\n use ptr::RawPtr;\n \n /// An iterator that reads a single byte on each iteration,\n@@ -88,15 +88,15 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n       8u => f(unsafe { transmute::<i64, [u8, ..8]>(to_le64(n as i64)) }),\n       _ => {\n \n-        let mut bytes: ~[u8] = ~[];\n+        let mut bytes = vec!();\n         let mut i = size;\n         let mut n = n;\n         while i > 0u {\n             bytes.push((n & 255_u64) as u8);\n             n >>= 8_u64;\n             i -= 1u;\n         }\n-        f(bytes)\n+        f(bytes.as_slice())\n       }\n     }\n }\n@@ -127,14 +127,14 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n       4u => f(unsafe { transmute::<i32, [u8, ..4]>(to_be32(n as i32)) }),\n       8u => f(unsafe { transmute::<i64, [u8, ..8]>(to_be64(n as i64)) }),\n       _ => {\n-        let mut bytes: ~[u8] = ~[];\n+        let mut bytes = vec!();\n         let mut i = size;\n         while i > 0u {\n             let shift = ((i - 1u) * 8u) as u64;\n             bytes.push((n >> shift) as u8);\n             i -= 1u;\n         }\n-        f(bytes)\n+        f(bytes.as_slice())\n       }\n     }\n }"}, {"sha": "b8a58c5cf1040e99e9e4cef99292d1963a405279", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -483,7 +483,7 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// Will return an error if the provided `from` doesn't exist, the process lacks\n /// permissions to view the contents or if the `path` points at a non-directory\n /// file\n-pub fn readdir(path: &Path) -> IoResult<~[Path]> {\n+pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n     LocalIo::maybe_raise(|io| {\n         io.fs_readdir(&path.to_c_str(), 0)\n     })\n@@ -498,7 +498,7 @@ pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n \n /// An iterator which walks over a directory\n pub struct Directories {\n-    stack: ~[Path],\n+    stack: Vec<Path>,\n }\n \n impl Iterator<Path> for Directories {"}, {"sha": "00b2e4f2307d8efbf443a6ac4e602f31364c5a43", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -29,6 +29,7 @@ use option::{Some, None};\n use result::{Ok, Err};\n use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n use slice::{ImmutableVector, OwnedVector};\n+use vec::Vec;\n \n /// Signals that can be sent and received\n #[repr(int)]\n@@ -80,7 +81,7 @@ pub enum Signum {\n /// ```\n pub struct Listener {\n     /// A map from signums to handles to keep the handles in memory\n-    handles: ~[(Signum, ~RtioSignal:Send)],\n+    handles: Vec<(Signum, ~RtioSignal:Send)>,\n     /// This is where all the handles send signums, which are received by\n     /// the clients from the receiver.\n     tx: Sender<Signum>,\n@@ -99,7 +100,7 @@ impl Listener {\n         Listener {\n             tx: tx,\n             rx: rx,\n-            handles: ~[],\n+            handles: vec!(),\n         }\n     }\n "}, {"sha": "dd874fecc52a5d32de0a6f7982bbc3e73294a6ea", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -39,7 +39,6 @@ macro_rules! iotest (\n             use io::process::*;\n             use unstable::running_on_valgrind;\n             use str;\n-            use util;\n \n             fn f() $b\n "}, {"sha": "c76e079432ae1255bef886a3350d9994b6ee3e29", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -47,6 +47,7 @@ use mem::replace;\n use option::{None, Option, Some};\n use rt::task::{Task, LocalStorage};\n use slice::{ImmutableVector, MutableVector, OwnedVector};\n+use vec::Vec;\n \n /**\n  * Indexes a task-local data slot. This pointer is used for comparison to\n@@ -89,7 +90,7 @@ impl<T: 'static> LocalData for T {}\n // n.b. If TLS is used heavily in future, this could be made more efficient with\n //      a proper map.\n #[doc(hidden)]\n-pub type Map = ~[Option<(*u8, TLSValue, LoanState)>];\n+pub type Map = Vec<Option<(*u8, TLSValue, LoanState)>>;\n type TLSValue = ~LocalData:Send;\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n@@ -106,7 +107,7 @@ unsafe fn get_local_map() -> &mut Map {\n         // If this is the first time we've accessed TLS, perform similar\n         // actions to the oldsched way of doing things.\n         &LocalStorage(ref mut slot) => {\n-            *slot = Some(~[]);\n+            *slot = Some(vec!());\n             match *slot {\n                 Some(ref mut map_ptr) => { return map_ptr }\n                 None => abort()\n@@ -237,7 +238,7 @@ fn get_with<T:'static,\n         Some(i) => {\n             let ret;\n             let mut return_loan = false;\n-            match map[i] {\n+            match *map.get_mut(i) {\n                 Some((_, ref data, ref mut loan)) => {\n                     match (state, *loan) {\n                         (_, NoLoan) => {\n@@ -271,7 +272,7 @@ fn get_with<T:'static,\n             // in turn relocated the vector. Hence we do another lookup here to\n             // fixup the loans.\n             if return_loan {\n-                match map[i] {\n+                match *map.get_mut(i) {\n                     Some((_, _, ref mut loan)) => { *loan = NoLoan; }\n                     None => abort()\n                 }\n@@ -331,7 +332,7 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n     // we're not actually sending it to other schedulers or anything.\n     let data: ~LocalData:Send = unsafe { cast::transmute(data) };\n     match insertion_position(map, keyval) {\n-        Some(i) => { map[i] = Some((keyval, data, NoLoan)); }\n+        Some(i) => { *map.get_mut(i) = Some((keyval, data, NoLoan)); }\n         None => { map.push(Some((keyval, data, NoLoan))); }\n     }\n }"}, {"sha": "7205edee611c1226f108806063b3f9e2bd83fc4a", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -31,6 +31,7 @@ use to_str::ToStr;\n use slice::{Vector, OwnedVector};\n use intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use raw;\n+use vec::Vec;\n \n macro_rules! try( ($me:expr, $e:expr) => (\n     match $e {\n@@ -102,8 +103,8 @@ enum VariantState {\n \n pub struct ReprVisitor<'a> {\n     ptr: *u8,\n-    ptr_stk: ~[*u8],\n-    var_stk: ~[VariantState],\n+    ptr_stk: Vec<*u8>,\n+    var_stk: Vec<VariantState>,\n     writer: &'a mut io::Writer,\n     last_err: Option<io::IoError>,\n }\n@@ -112,8 +113,8 @@ pub fn ReprVisitor<'a>(ptr: *u8,\n                        writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n     ReprVisitor {\n         ptr: ptr,\n-        ptr_stk: ~[],\n-        var_stk: ~[],\n+        ptr_stk: vec!(),\n+        var_stk: vec!(),\n         writer: writer,\n         last_err: None,\n     }\n@@ -154,8 +155,8 @@ impl<'a> ReprVisitor<'a> {\n             // issues we have to recreate it here.\n             let u = ReprVisitor {\n                 ptr: ptr,\n-                ptr_stk: ~[],\n-                var_stk: ~[],\n+                ptr_stk: vec!(),\n+                var_stk: vec!(),\n                 writer: ::cast::transmute_copy(&self.writer),\n                 last_err: None,\n             };\n@@ -505,7 +506,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                                 _offset: uint,\n                                 inner: *TyDesc)\n                                 -> bool {\n-        match self.var_stk[self.var_stk.len() - 1] {\n+        match *self.var_stk.get(self.var_stk.len() - 1) {\n             Matched => {\n                 if i != 0 {\n                     try!(self, self.writer.write(\", \".as_bytes()));\n@@ -523,7 +524,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                                 _disr_val: Disr,\n                                 n_fields: uint,\n                                 _name: &str) -> bool {\n-        match self.var_stk[self.var_stk.len() - 1] {\n+        match *self.var_stk.get(self.var_stk.len() - 1) {\n             Matched => {\n                 if n_fields > 0 {\n                     try!(self, self.writer.write([')' as u8]));"}, {"sha": "67b8b40b47e6eef620ff4334a34eef33014b0eb6", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -20,8 +20,9 @@ use option::{Some, None};\n use ptr::RawPtr;\n use unstable::sync::Exclusive;\n use slice::OwnedVector;\n+use vec::Vec;\n \n-type Queue = Exclusive<~[proc():Send]>;\n+type Queue = Exclusive<Vec<proc():Send>>;\n \n // You'll note that these variables are *not* atomic, and this is done on\n // purpose. This module is designed to have init() called *once* in a\n@@ -35,7 +36,7 @@ pub fn init() {\n     unsafe {\n         rtassert!(!RUNNING);\n         rtassert!(QUEUE.is_null());\n-        let state: ~Queue = ~Exclusive::new(~[]);\n+        let state: ~Queue = ~Exclusive::new(vec!());\n         QUEUE = cast::transmute(state);\n     }\n }\n@@ -61,7 +62,7 @@ pub fn run() {\n         QUEUE = 0 as *mut Queue;\n         let mut vec = None;\n         state.with(|arr| {\n-            vec = Some(mem::replace(arr, ~[]));\n+            vec = Some(mem::replace(arr, vec!()));\n         });\n         vec.take_unwrap()\n     };"}, {"sha": "cc8356d2b9a04bcaefe5335cf3983dfd23b63945", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -20,6 +20,7 @@ use path::Path;\n use result::Err;\n use rt::local::Local;\n use rt::task::Task;\n+use vec::Vec;\n \n use ai = io::net::addrinfo;\n use io;\n@@ -168,7 +169,7 @@ pub trait IoFactory {\n     fn fs_rmdir(&mut self, path: &CString) -> IoResult<()>;\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()>;\n     fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n-        IoResult<~[Path]>;\n+        IoResult<Vec<Path>>;\n     fn fs_lstat(&mut self, path: &CString) -> IoResult<FileStat>;\n     fn fs_chown(&mut self, path: &CString, uid: int, gid: int) ->\n         IoResult<()>;"}, {"sha": "8beadce21604e99d3d6db9a46cef1440f5514dbf", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -62,6 +62,7 @@ use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n use unstable::sync::Exclusive;\n use slice::{OwnedVector, ImmutableVector};\n+use vec::Vec;\n \n // Once the queue is less than 1/K full, then it will be downsized. Note that\n // the deque requires that this number be less than 2.\n@@ -116,14 +117,14 @@ pub enum Stolen<T> {\n /// will only use this structure when allocating a new buffer or deallocating a\n /// previous one.\n pub struct BufferPool<T> {\n-    pool: Exclusive<~[~Buffer<T>]>,\n+    pool: Exclusive<Vec<~Buffer<T>>>,\n }\n \n /// An internal buffer used by the chase-lev deque. This structure is actually\n /// implemented as a circular buffer, and is used as the intermediate storage of\n /// the data in the deque.\n ///\n-/// This type is implemented with *T instead of ~[T] for two reasons:\n+/// This type is implemented with *T instead of Vec<T> for two reasons:\n ///\n ///   1. There is nothing safe about using this buffer. This easily allows the\n ///      same value to be read twice in to rust, and there is nothing to\n@@ -132,7 +133,7 @@ pub struct BufferPool<T> {\n ///      destructors for values in this buffer (on drop) because the bounds\n ///      are defined by the deque it's owned by.\n ///\n-///   2. We can certainly avoid bounds checks using *T instead of ~[T], although\n+///   2. We can certainly avoid bounds checks using *T instead of Vec<T>, although\n ///      LLVM is probably pretty good at doing this already.\n struct Buffer<T> {\n     storage: *T,\n@@ -143,7 +144,7 @@ impl<T: Send> BufferPool<T> {\n     /// Allocates a new buffer pool which in turn can be used to allocate new\n     /// deques.\n     pub fn new() -> BufferPool<T> {\n-        BufferPool { pool: Exclusive::new(~[]) }\n+        BufferPool { pool: Exclusive::new(vec!()) }\n     }\n \n     /// Allocates a new work-stealing deque which will send/receiving memory to\n@@ -494,7 +495,7 @@ mod tests {\n                     }\n                 }\n             })\n-        }).collect::<~[Thread<()>]>();\n+        }).collect::<Vec<Thread<()>>>();\n \n         while remaining.load(SeqCst) > 0 {\n             match w.pop() {\n@@ -525,7 +526,7 @@ mod tests {\n             Thread::start(proc() {\n                 stampede(w, s, 4, 10000);\n             })\n-        }).collect::<~[Thread<()>]>();\n+        }).collect::<Vec<Thread<()>>>();\n \n         for thread in threads.move_iter() {\n             thread.join();\n@@ -556,7 +557,7 @@ mod tests {\n                     }\n                 }\n             })\n-        }).collect::<~[Thread<()>]>();\n+        }).collect::<Vec<Thread<()>>>();\n \n         let mut rng = rand::task_rng();\n         let mut expected = 0;\n@@ -658,4 +659,3 @@ mod tests {\n         }\n     }\n }\n-"}, {"sha": "b392cc8ff9a7099451a107226b6d4f9b5a4725fc", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -35,7 +35,7 @@ use num::next_power_of_two;\n use option::{Option, Some, None};\n use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicUint,Relaxed,Release,Acquire};\n-use slice;\n+use vec::Vec;\n \n struct Node<T> {\n     sequence: AtomicUint,\n@@ -44,7 +44,7 @@ struct Node<T> {\n \n struct State<T> {\n     pad0: [u8, ..64],\n-    buffer: ~[Node<T>],\n+    buffer: Vec<Node<T>>,\n     mask: uint,\n     pad1: [u8, ..64],\n     enqueue_pos: AtomicUint,\n@@ -69,7 +69,7 @@ impl<T: Send> State<T> {\n         } else {\n             capacity\n         };\n-        let buffer = slice::from_fn(capacity, |i| {\n+        let buffer = Vec::from_fn(capacity, |i| {\n             Node { sequence:AtomicUint::new(i), value: None }\n         });\n         State{\n@@ -88,7 +88,7 @@ impl<T: Send> State<T> {\n         let mask = self.mask;\n         let mut pos = self.enqueue_pos.load(Relaxed);\n         loop {\n-            let node = &mut self.buffer[pos & mask];\n+            let node = self.buffer.get_mut(pos & mask);\n             let seq = node.sequence.load(Acquire);\n             let diff: int = seq as int - pos as int;\n \n@@ -114,7 +114,7 @@ impl<T: Send> State<T> {\n         let mask = self.mask;\n         let mut pos = self.dequeue_pos.load(Relaxed);\n         loop {\n-            let node = &mut self.buffer[pos & mask];\n+            let node = self.buffer.get_mut(pos & mask);\n             let seq = node.sequence.load(Acquire);\n             let diff: int = seq as int - (pos + 1) as int;\n             if diff == 0 {\n@@ -186,7 +186,7 @@ mod tests {\n             });\n         }\n \n-        let mut completion_rxs = ~[];\n+        let mut completion_rxs = vec![];\n         for _ in range(0, nthreads) {\n             let (tx, rx) = channel();\n             completion_rxs.push(rx);"}, {"sha": "1eb034a573ac38ab3d7216741269bd7f89c0ec16", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -210,8 +210,8 @@ pub enum MethodProvenance {\n \n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Def {\n-    DefFn(DefId, Purity),\n-    DefStaticMethod(/* method */ DefId, MethodProvenance, Purity),\n+    DefFn(DefId, FnStyle),\n+    DefStaticMethod(/* method */ DefId, MethodProvenance, FnStyle),\n     DefSelfTy(/* trait id */ NodeId),\n     DefMod(DefId),\n     DefForeignMod(DefId),\n@@ -696,7 +696,7 @@ pub struct TypeField {\n pub struct TypeMethod {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n-    pub purity: Purity,\n+    pub fn_style: FnStyle,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n     pub explicit_self: ExplicitSelf,\n@@ -794,7 +794,7 @@ pub struct ClosureTy {\n     pub sigil: Sigil,\n     pub region: Option<Lifetime>,\n     pub lifetimes: Vec<Lifetime>,\n-    pub purity: Purity,\n+    pub fn_style: FnStyle,\n     pub onceness: Onceness,\n     pub decl: P<FnDecl>,\n     // Optional optvec distinguishes between \"fn()\" and \"fn:()\" so we can\n@@ -806,7 +806,7 @@ pub struct ClosureTy {\n \n #[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct BareFnTy {\n-    pub purity: Purity,\n+    pub fn_style: FnStyle,\n     pub abi: Abi,\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: P<FnDecl>\n@@ -886,16 +886,16 @@ pub struct FnDecl {\n }\n \n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n-pub enum Purity {\n+pub enum FnStyle {\n     UnsafeFn, // declared with \"unsafe fn\"\n-    ImpureFn, // declared with \"fn\"\n+    NormalFn, // declared with \"fn\"\n     ExternFn, // declared with \"extern fn\"\n }\n \n-impl fmt::Show for Purity {\n+impl fmt::Show for FnStyle {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ImpureFn => \"impure\".fmt(f),\n+            NormalFn => \"normal\".fmt(f),\n             UnsafeFn => \"unsafe\".fmt(f),\n             ExternFn => \"extern\".fmt(f),\n         }\n@@ -925,7 +925,7 @@ pub struct Method {\n     pub attrs: Vec<Attribute>,\n     pub generics: Generics,\n     pub explicit_self: ExplicitSelf,\n-    pub purity: Purity,\n+    pub fn_style: FnStyle,\n     pub decl: P<FnDecl>,\n     pub body: P<Block>,\n     pub id: NodeId,\n@@ -1119,7 +1119,7 @@ pub struct Item {\n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, @Expr),\n-    ItemFn(P<FnDecl>, Purity, Abi, Generics, P<Block>),\n+    ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n     ItemMod(Mod),\n     ItemForeignMod(ForeignMod),\n     ItemTy(P<Ty>, Generics),"}, {"sha": "558642059969d2354539e3f840402b6f28a9e228", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -264,7 +264,7 @@ pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n             TypeMethod {\n                 ident: m.ident,\n                 attrs: m.attrs.clone(),\n-                purity: m.purity,\n+                fn_style: m.fn_style,\n                 decl: m.decl,\n                 generics: m.generics.clone(),\n                 explicit_self: m.explicit_self,"}, {"sha": "203edf6590fb771cdad0e7f5edde1bc0474c65c7", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -825,7 +825,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                   name,\n                   Vec::new(),\n                   ast::ItemFn(self.fn_decl(inputs, output),\n-                              ast::ImpureFn,\n+                              ast::NormalFn,\n                               abi::Rust,\n                               generics,\n                               body))"}, {"sha": "8a44caf34a5b4c4cc6aebd2c4ee4b05af9b68ff6", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -619,7 +619,7 @@ impl<'a> MethodDef<'a> {\n             attrs: attrs,\n             generics: fn_generics,\n             explicit_self: explicit_self,\n-            purity: ast::ImpureFn,\n+            fn_style: ast::NormalFn,\n             decl: fn_decl,\n             body: body_block,\n             id: ast::DUMMY_NODE_ID,"}, {"sha": "cc0f26dcc2f079bbe5727d958dd87933d0bf8d67", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -242,9 +242,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                             }\n                         }\n                     }\n-                    self.verify_pieces(arm.result);\n+                    self.verify_pieces(arm.result.as_slice());\n                 }\n-                self.verify_pieces(*default);\n+                self.verify_pieces(default.as_slice());\n             }\n             parse::Select(ref arms, ref default) => {\n                 self.verify_arg_type(pos, String);\n@@ -258,9 +258,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                         self.ecx.span_err(self.fmtsp,\n                                           \"empty selector in `select`\");\n                     }\n-                    self.verify_pieces(arm.result);\n+                    self.verify_pieces(arm.result.as_slice());\n                 }\n-                self.verify_pieces(*default);\n+                self.verify_pieces(default.as_slice());\n             }\n         }\n         self.nest_level -= 1;"}, {"sha": "e9e69eabef8968c20743f66bf293d42bd25e228a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -158,7 +158,7 @@ pub trait Folder {\n             TyClosure(ref f) => {\n                 TyClosure(@ClosureTy {\n                     sigil: f.sigil,\n-                    purity: f.purity,\n+                    fn_style: f.fn_style,\n                     region: fold_opt_lifetime(&f.region, self),\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n@@ -169,7 +169,7 @@ pub trait Folder {\n             TyBareFn(ref f) => {\n                 TyBareFn(@BareFnTy {\n                     lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n-                    purity: f.purity,\n+                    fn_style: f.fn_style,\n                     abi: f.abi,\n                     decl: self.fold_fn_decl(f.decl)\n                 })\n@@ -549,10 +549,10 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n         ItemStatic(t, m, e) => {\n             ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n-        ItemFn(decl, purity, abi, ref generics, body) => {\n+        ItemFn(decl, fn_style, abi, ref generics, body) => {\n             ItemFn(\n                 folder.fold_fn_decl(decl),\n-                purity,\n+                fn_style,\n                 abi,\n                 fold_generics(generics, folder),\n                 folder.fold_block(body)\n@@ -603,7 +603,7 @@ pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMeth\n         id: fld.new_id(m.id), // Needs to be first, for ast_map.\n         ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n-        purity: m.purity,\n+        fn_style: m.fn_style,\n         decl: fld.fold_fn_decl(m.decl),\n         generics: fold_generics(&m.generics, fld),\n         explicit_self: fld.fold_explicit_self(&m.explicit_self),\n@@ -680,7 +680,7 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n         attrs: m.attrs.iter().map(|a| fold_attribute_(*a, folder)).collect(),\n         generics: fold_generics(&m.generics, folder),\n         explicit_self: folder.fold_explicit_self(&m.explicit_self),\n-        purity: m.purity,\n+        fn_style: m.fn_style,\n         decl: folder.fold_fn_decl(m.decl),\n         body: folder.fold_block(m.body),\n         span: folder.new_span(m.span),"}, {"sha": "eca9f955d9392fa3131ecd55d24aad56cae058c0", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -657,7 +657,7 @@ mod test {\n                                 cf: ast::Return,\n                                 variadic: false\n                             }),\n-                                    ast::ImpureFn,\n+                                    ast::NormalFn,\n                                     abi::Rust,\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),"}, {"sha": "fe4bd87c4eb18da42fd48a314558e2797b51c37d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -14,7 +14,7 @@ use abi;\n use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n use ast::{BareFnTy, ClosureTy};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n-use ast::{Provided, Public, Purity};\n+use ast::{Provided, Public, FnStyle};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, Block};\n use ast::{BlockCheckMode, UnBox};\n@@ -31,7 +31,7 @@ use ast::{ExprVec, ExprVstore, ExprVstoreSlice};\n use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, ExternFn, Field, FnDecl};\n use ast::{ExprVstoreUniq, Once, Many};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n-use ast::{Ident, ImpureFn, Inherited, Item, Item_, ItemStatic};\n+use ast::{Ident, NormalFn, Inherited, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy, Lit, Lit_};\n use ast::{LitBool, LitFloat, LitFloatUnsuffixed, LitInt, LitChar};\n@@ -867,7 +867,7 @@ impl<'a> Parser<'a> {\n                   |      |           |  Argument types\n                   |      |       Lifetimes\n                   |      |\n-                  |    Purity\n+                  |    Function Style\n                  ABI\n \n         */\n@@ -878,12 +878,12 @@ impl<'a> Parser<'a> {\n             abi::Rust\n         };\n \n-        let purity = self.parse_unsafety();\n+        let fn_style = self.parse_unsafety();\n         self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl(true);\n         return TyBareFn(@BareFnTy {\n             abi: abi,\n-            purity: purity,\n+            fn_style: fn_style,\n             lifetimes: lifetimes,\n             decl: decl\n         });\n@@ -925,7 +925,7 @@ impl<'a> Parser<'a> {\n         TyClosure(@ClosureTy {\n             sigil: OwnedSigil,\n             region: None,\n-            purity: ImpureFn,\n+            fn_style: NormalFn,\n             onceness: Once,\n             bounds: bounds,\n             decl: decl,\n@@ -945,11 +945,11 @@ impl<'a> Parser<'a> {\n           |        |      |  Argument types\n           |        |    Lifetimes\n           |     Once-ness (a.k.a., affine)\n-        Purity\n+        Function Style\n \n         */\n \n-        let purity = self.parse_unsafety();\n+        let fn_style = self.parse_unsafety();\n         let onceness = if self.eat_keyword(keywords::Once) {Once} else {Many};\n \n         let lifetimes = if self.eat(&token::LT) {\n@@ -985,19 +985,19 @@ impl<'a> Parser<'a> {\n         TyClosure(@ClosureTy {\n             sigil: BorrowedSigil,\n             region: region,\n-            purity: purity,\n+            fn_style: fn_style,\n             onceness: onceness,\n             bounds: bounds,\n             decl: decl,\n             lifetimes: lifetimes,\n         })\n     }\n \n-    pub fn parse_unsafety(&mut self) -> Purity {\n+    pub fn parse_unsafety(&mut self) -> FnStyle {\n         if self.eat_keyword(keywords::Unsafe) {\n             return UnsafeFn;\n         } else {\n-            return ImpureFn;\n+            return NormalFn;\n         }\n     }\n \n@@ -1045,7 +1045,7 @@ impl<'a> Parser<'a> {\n \n             let vis_span = p.span;\n             let vis = p.parse_visibility();\n-            let pur = p.parse_fn_purity();\n+            let style = p.parse_fn_style();\n             // NB: at the moment, trait methods are public by default; this\n             // could change.\n             let ident = p.parse_ident();\n@@ -1071,7 +1071,7 @@ impl<'a> Parser<'a> {\n                 Required(TypeMethod {\n                     ident: ident,\n                     attrs: attrs,\n-                    purity: pur,\n+                    fn_style: style,\n                     decl: d,\n                     generics: generics,\n                     explicit_self: explicit_self,\n@@ -1089,7 +1089,7 @@ impl<'a> Parser<'a> {\n                     attrs: attrs,\n                     generics: generics,\n                     explicit_self: explicit_self,\n-                    purity: pur,\n+                    fn_style: style,\n                     decl: d,\n                     body: body,\n                     id: ast::DUMMY_NODE_ID,\n@@ -3754,11 +3754,11 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse an item-position function declaration.\n-    fn parse_item_fn(&mut self, purity: Purity, abi: abi::Abi) -> ItemInfo {\n+    fn parse_item_fn(&mut self, fn_style: FnStyle, abi: abi::Abi) -> ItemInfo {\n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(false);\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n-        (ident, ItemFn(decl, purity, abi, generics, body), Some(inner_attrs))\n+        (ident, ItemFn(decl, fn_style, abi, generics, body), Some(inner_attrs))\n     }\n \n     // parse a method in a trait impl, starting with `attrs` attributes.\n@@ -3772,7 +3772,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n \n         let visa = self.parse_visibility();\n-        let pur = self.parse_fn_purity();\n+        let fn_style = self.parse_fn_style();\n         let ident = self.parse_ident();\n         let generics = self.parse_generics();\n         let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n@@ -3787,7 +3787,7 @@ impl<'a> Parser<'a> {\n             attrs: attrs,\n             generics: generics,\n             explicit_self: explicit_self,\n-            purity: pur,\n+            fn_style: fn_style,\n             decl: decl,\n             body: body,\n             id: ast::DUMMY_NODE_ID,\n@@ -4169,8 +4169,8 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n \n         // Parse obsolete purity.\n-        let purity = self.parse_fn_purity();\n-        if purity != ImpureFn {\n+        let fn_style = self.parse_fn_style();\n+        if fn_style != NormalFn {\n             self.obsolete(self.last_span, ObsoleteUnsafeExternFn);\n         }\n \n@@ -4208,8 +4208,8 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse safe/unsafe and fn\n-    fn parse_fn_purity(&mut self) -> Purity {\n-        if self.eat_keyword(keywords::Fn) { ImpureFn }\n+    fn parse_fn_style(&mut self) -> FnStyle {\n+        if self.eat_keyword(keywords::Fn) { NormalFn }\n         else if self.eat_keyword(keywords::Unsafe) {\n             self.expect_keyword(keywords::Fn);\n             UnsafeFn\n@@ -4540,7 +4540,7 @@ impl<'a> Parser<'a> {\n             // FUNCTION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(ImpureFn, abi::Rust);\n+                self.parse_item_fn(NormalFn, abi::Rust);\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     ident,"}, {"sha": "b33f76a6047ef614180ef519ae079fa54aaa8c83", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -186,11 +186,11 @@ pub fn path_to_str(p: &ast::Path) -> ~str {\n     to_str(|s| s.print_path(p, false))\n }\n \n-pub fn fun_to_str(decl: &ast::FnDecl, purity: ast::Purity, name: ast::Ident,\n+pub fn fun_to_str(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Ident,\n                   opt_explicit_self: Option<ast::ExplicitSelf_>,\n                   generics: &ast::Generics) -> ~str {\n     to_str(|s| {\n-        try!(s.print_fn(decl, Some(purity), abi::Rust,\n+        try!(s.print_fn(decl, Some(fn_style), abi::Rust,\n                         name, generics, opt_explicit_self, ast::Inherited));\n         try!(s.end()); // Close the head box\n         s.end() // Close the outer box\n@@ -479,7 +479,7 @@ impl<'a> State<'a> {\n                     ty_params: OwnedSlice::empty()\n                 };\n                 try!(self.print_ty_fn(Some(f.abi), None, &None,\n-                                   f.purity, ast::Many, f.decl, None, &None,\n+                                   f.fn_style, ast::Many, f.decl, None, &None,\n                                    Some(&generics), None));\n             }\n             ast::TyClosure(f) => {\n@@ -488,7 +488,7 @@ impl<'a> State<'a> {\n                     ty_params: OwnedSlice::empty()\n                 };\n                 try!(self.print_ty_fn(None, Some(f.sigil), &f.region,\n-                                   f.purity, f.onceness, f.decl, None, &f.bounds,\n+                                   f.fn_style, f.onceness, f.decl, None, &f.bounds,\n                                    Some(&generics), None));\n             }\n             ast::TyPath(ref path, ref bounds, _) => {\n@@ -567,10 +567,10 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n-            ast::ItemFn(decl, purity, abi, ref typarams, body) => {\n+            ast::ItemFn(decl, fn_style, abi, ref typarams, body) => {\n                 try!(self.print_fn(\n                     decl,\n-                    Some(purity),\n+                    Some(fn_style),\n                     abi,\n                     item.ident,\n                     typarams,\n@@ -861,7 +861,7 @@ impl<'a> State<'a> {\n         try!(self.print_ty_fn(None,\n                               None,\n                               &None,\n-                              m.purity,\n+                              m.fn_style,\n                               ast::Many,\n                               m.decl,\n                               Some(m.ident),\n@@ -883,7 +883,7 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n         try!(self.print_outer_attributes(meth.attrs.as_slice()));\n-        try!(self.print_fn(meth.decl, Some(meth.purity), abi::Rust,\n+        try!(self.print_fn(meth.decl, Some(meth.fn_style), abi::Rust,\n                         meth.ident, &meth.generics, Some(meth.explicit_self.node),\n                         meth.vis));\n         try!(word(&mut self.s, \" \"));\n@@ -1708,14 +1708,14 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n-                    purity: Option<ast::Purity>,\n+                    fn_style: Option<ast::FnStyle>,\n                     abi: abi::Abi,\n                     name: ast::Ident,\n                     generics: &ast::Generics,\n                     opt_explicit_self: Option<ast::ExplicitSelf_>,\n                     vis: ast::Visibility) -> IoResult<()> {\n         try!(self.head(\"\"));\n-        try!(self.print_fn_header_info(opt_explicit_self, purity, abi,\n+        try!(self.print_fn_header_info(opt_explicit_self, fn_style, abi,\n                                        ast::Many, None, vis));\n         try!(self.nbsp());\n         try!(self.print_ident(name));\n@@ -2024,7 +2024,7 @@ impl<'a> State<'a> {\n                        opt_abi: Option<abi::Abi>,\n                        opt_sigil: Option<ast::Sigil>,\n                        opt_region: &Option<ast::Lifetime>,\n-                       purity: ast::Purity,\n+                       fn_style: ast::FnStyle,\n                        onceness: ast::Onceness,\n                        decl: &ast::FnDecl,\n                        id: Option<ast::Ident>,\n@@ -2040,12 +2040,12 @@ impl<'a> State<'a> {\n             try!(word(&mut self.s, \"proc\"));\n         } else if opt_sigil == Some(ast::BorrowedSigil) {\n             try!(self.print_extern_opt_abi(opt_abi));\n-            try!(self.print_purity(purity));\n+            try!(self.print_fn_style(fn_style));\n             try!(self.print_onceness(onceness));\n         } else {\n             try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n             try!(self.print_opt_sigil(opt_sigil));\n-            try!(self.print_purity(purity));\n+            try!(self.print_fn_style(fn_style));\n             try!(self.print_onceness(onceness));\n             try!(word(&mut self.s, \"fn\"));\n         }\n@@ -2294,10 +2294,10 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_opt_purity(&mut self,\n-                            opt_purity: Option<ast::Purity>) -> IoResult<()> {\n-        match opt_purity {\n-            Some(purity) => self.print_purity(purity),\n+    pub fn print_opt_fn_style(&mut self,\n+                            opt_fn_style: Option<ast::FnStyle>) -> IoResult<()> {\n+        match opt_fn_style {\n+            Some(fn_style) => self.print_fn_style(fn_style),\n             None => Ok(())\n         }\n     }\n@@ -2338,7 +2338,7 @@ impl<'a> State<'a> {\n \n     pub fn print_fn_header_info(&mut self,\n                                 _opt_explicit_self: Option<ast::ExplicitSelf_>,\n-                                opt_purity: Option<ast::Purity>,\n+                                opt_fn_style: Option<ast::FnStyle>,\n                                 abi: abi::Abi,\n                                 onceness: ast::Onceness,\n                                 opt_sigil: Option<ast::Sigil>,\n@@ -2349,21 +2349,21 @@ impl<'a> State<'a> {\n             try!(self.word_nbsp(\"extern\"));\n             try!(self.word_nbsp(abi.to_str()));\n \n-            if opt_purity != Some(ast::ExternFn) {\n-                try!(self.print_opt_purity(opt_purity));\n+            if opt_fn_style != Some(ast::ExternFn) {\n+                try!(self.print_opt_fn_style(opt_fn_style));\n             }\n         } else {\n-            try!(self.print_opt_purity(opt_purity));\n+            try!(self.print_opt_fn_style(opt_fn_style));\n         }\n \n         try!(self.print_onceness(onceness));\n         try!(word(&mut self.s, \"fn\"));\n         self.print_opt_sigil(opt_sigil)\n     }\n \n-    pub fn print_purity(&mut self, p: ast::Purity) -> IoResult<()> {\n-        match p {\n-            ast::ImpureFn => Ok(()),\n+    pub fn print_fn_style(&mut self, s: ast::FnStyle) -> IoResult<()> {\n+        match s {\n+            ast::NormalFn => Ok(()),\n             ast::UnsafeFn => self.word_nbsp(\"unsafe\"),\n             ast::ExternFn => self.word_nbsp(\"extern\")\n         }\n@@ -2399,7 +2399,7 @@ mod test {\n             variadic: false\n         };\n         let generics = ast_util::empty_generics();\n-        assert_eq!(&fun_to_str(&decl, ast::ImpureFn, abba_ident,\n+        assert_eq!(&fun_to_str(&decl, ast::NormalFn, abba_ident,\n                                None, &generics),\n                    &~\"fn abba()\");\n     }"}, {"sha": "5b376f4c5feb6ae9e3b3c77b717f1083949b0f48", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -29,7 +29,7 @@ use owned_slice::OwnedSlice;\n \n pub enum FnKind<'a> {\n     // fn foo() or extern \"Abi\" fn foo()\n-    FkItemFn(Ident, &'a Generics, Purity, Abi),\n+    FkItemFn(Ident, &'a Generics, FnStyle, Abi),\n \n     // fn foo(&self)\n     FkMethod(Ident, &'a Generics, &'a Method),\n@@ -207,8 +207,8 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n             visitor.visit_ty(typ, env.clone());\n             visitor.visit_expr(expr, env);\n         }\n-        ItemFn(declaration, purity, abi, ref generics, body) => {\n-            visitor.visit_fn(&FkItemFn(item.ident, generics, purity, abi),\n+        ItemFn(declaration, fn_style, abi, ref generics, body) => {\n+            visitor.visit_fn(&FkItemFn(item.ident, generics, fn_style, abi),\n                              declaration,\n                              body,\n                              item.span,"}, {"sha": "f6c138b8c669d3afd7e528af93125473d687ca97", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -170,14 +170,14 @@ impl<'a> Stats for &'a [f64] {\n     // FIXME #11059 handle NaN, inf and overflow\n     #[allow(deprecated_owned_vector)]\n     fn sum(self) -> f64 {\n-        let mut partials : ~[f64] = ~[];\n+        let mut partials = vec![];\n \n         for &mut x in self.iter() {\n             let mut j = 0;\n             // This inner loop applies `hi`/`lo` summation to each\n             // partial so that the list of partial sums remains exact.\n             for i in range(0, partials.len()) {\n-                let mut y = partials[i];\n+                let mut y = *partials.get(i);\n                 if num::abs(x) < num::abs(y) {\n                     mem::swap(&mut x, &mut y);\n                 }\n@@ -186,15 +186,15 @@ impl<'a> Stats for &'a [f64] {\n                 let hi = x + y;\n                 let lo = y - (hi - x);\n                 if lo != 0f64 {\n-                    partials[j] = lo;\n+                    *partials.get_mut(j) = lo;\n                     j += 1;\n                 }\n                 x = hi;\n             }\n             if j >= partials.len() {\n                 partials.push(x);\n             } else {\n-                partials[j] = x;\n+                *partials.get_mut(j) = x;\n                 partials.truncate(j+1);\n             }\n         }"}, {"sha": "623488ac6129d148e9509dc2925b8af998881e20", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -17,6 +17,7 @@\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n #![feature(phase)]\n #![allow(visible_private_types)]\n+#![deny(deprecated_owned_vector)]\n \n #[phase(syntax, link)] extern crate log;\n extern crate serialize;\n@@ -319,8 +320,8 @@ impl Exec {\n     }\n \n     // returns pairs of (kind, name)\n-    pub fn lookup_discovered_inputs(&self) -> ~[(~str, ~str)] {\n-        let mut rs = ~[];\n+    pub fn lookup_discovered_inputs(&self) -> Vec<(~str, ~str)> {\n+        let mut rs = vec![];\n         let WorkMap(ref discovered_inputs) = self.discovered_inputs;\n         for (k, v) in discovered_inputs.iter() {\n             let KindMap(ref vmap) = *v;\n@@ -341,8 +342,8 @@ impl<'a> Prep<'a> {\n         }\n     }\n \n-    pub fn lookup_declared_inputs(&self) -> ~[~str] {\n-        let mut rs = ~[];\n+    pub fn lookup_declared_inputs(&self) -> Vec<~str> {\n+        let mut rs = vec![];\n         let WorkMap(ref declared_inputs) = self.declared_inputs;\n         for (_, v) in declared_inputs.iter() {\n             let KindMap(ref vmap) = *v;"}, {"sha": "a0234c1185a9789f8e449952538dba150886f0fa", "filename": "src/test/auxiliary/issue-12612-1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fauxiliary%2Fissue-12612-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fauxiliary%2Fissue-12612-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-12612-1.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod bar {\n+    pub fn foo() {}\n+}"}, {"sha": "b4ae4374b2e58001196decbb9e3cc814eb30f5f8", "filename": "src/test/auxiliary/issue-12612-2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fauxiliary%2Fissue-12612-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fauxiliary%2Fissue-12612-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-12612-2.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn baz() {}"}, {"sha": "23cf49fb1d8dae9e1fc01147bbb003ec3139d7e2", "filename": "src/test/auxiliary/issue13213aux.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+// compile-flags:-g\n+\n+pub use private::P;\n+\n+pub struct S {\n+    p: P,\n+}\n+\n+mod private {\n+    pub struct P {\n+        p: i32,\n+    }\n+    pub static THREE: P = P { p: 3 };\n+}\n+\n+pub static A: S = S { p: private::THREE };\n\\ No newline at end of file"}, {"sha": "49184e188ebb61fbcd08efb0e93a91f3028c18b9", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -76,7 +76,7 @@ fn main() {\n                 format!(\"{}\\t trees of depth {}\\t check: {}\",\n                         iterations * 2, depth, chk)\n             })\n-        }).collect::<~[Future<~str>]>();\n+        }).collect::<Vec<Future<~str>>>();\n \n     for message in messages.mut_iter() {\n         println!(\"{}\", *message.get_ref());"}, {"sha": "9d6eb42567893e382c0b529d791bdc90a645006f", "filename": "src/test/compile-fail/issue-12612.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-12612-1.rs\n+\n+extern crate foo = \"issue-12612-1\";\n+\n+use foo::bar;\n+\n+mod test {\n+    use bar::foo;\n+    //~^ ERROR: unresolved import\n+    //~^^ ERROR: failed to resolve import\n+}\n+\n+fn main() {}\n+"}, {"sha": "2ce502ee8dbb3fb62d35aff0ac001ea2ecf72c79", "filename": "src/test/compile-fail/issue-13404.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fissue-13404.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fissue-13404.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13404.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use a::f;\n+use b::f;\n+//~^ ERROR: unresolved import\n+//~^^ ERROR: failed to resolve import\n+\n+mod a { pub fn f() {} }\n+mod b { }\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "5a7eb75d90d4ca926a8fa8bebb0213d016ff20d9", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -11,13 +11,15 @@\n trait A {}\n \n struct Struct {\n-    r: A //~ ERROR reference to trait `A` where a type is expected\n+    r: A //~ ERROR reference to trait `A` where a type is expected; try `~A` or `&A`\n }\n \n-fn new_struct(r: A) -> Struct { //~ ERROR reference to trait `A` where a type is expected\n+fn new_struct(r: A) -> Struct {\n+    //~^ ERROR reference to trait `A` where a type is expected; try `~A` or `&A`\n     Struct { r: r }\n }\n \n trait Curve {}\n-enum E {X(Curve)} //~ ERROR reference to trait `Curve` where a type is expected\n+enum E {X(Curve)}\n+//~^ ERROR reference to trait `Curve` where a type is expected; try `~Curve` or `&Curve`\n fn main() {}"}, {"sha": "baea483ad982b0abd65bd2297046f049ee06e8f8", "filename": "src/test/compile-fail/issue-7663.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fissue-7663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fissue-7663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7663.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(globs)]\n+#![deny(unused_imports)]\n+#![allow(dead_code)]\n+\n+mod test1 {\n+\n+    mod foo { pub fn p() -> int { 1 } }\n+    mod bar { pub fn p() -> int { 2 } }\n+\n+    pub mod baz {\n+        use test1::foo::*; //~ ERROR: unused import\n+        use test1::bar::*;\n+\n+        pub fn my_main() { assert!(p() == 2); }\n+    }\n+}\n+\n+mod test2 {\n+\n+    mod foo { pub fn p() -> int { 1 } }\n+    mod bar { pub fn p() -> int { 2 } }\n+\n+    pub mod baz {\n+        use test2::foo::p; //~ ERROR: unused import\n+        use test2::bar::p;\n+\n+        pub fn my_main() { assert!(p() == 2); }\n+    }\n+}\n+\n+mod test3 {\n+\n+    mod foo { pub fn p() -> int { 1 } }\n+    mod bar { pub fn p() -> int { 2 } }\n+\n+    pub mod baz {\n+        use test3::foo::*; //~ ERROR: unused import\n+        use test3::bar::p;\n+\n+        pub fn my_main() { assert!(p() == 2); }\n+    }\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "92c1849c15b83c13aa2b047ff2e290242f7637e0", "filename": "src/test/compile-fail/regions-trait-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -29,7 +29,7 @@ fn make_gc() -> @get_ctxt  {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n     return @hc as @get_ctxt;\n-    //^~ ERROR source contains reference\n+    //~^ ERROR source contains reference\n }\n \n fn main() {"}, {"sha": "0830722f9692950209511cc60a330788f0f5b541", "filename": "src/test/compile-fail/resolve-priv-shadowing-pub.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fresolve-priv-shadowing-pub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Fresolve-priv-shadowing-pub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-priv-shadowing-pub.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub fn foobar() -> int { 1 }\n+}\n+\n+mod b {\n+    pub fn foobar() -> int { 2 }\n+}\n+\n+mod c {\n+    // Technically the second use shadows the first, but in theory it should\n+    // only be shadowed for this module. The implementation of resolve currently\n+    // doesn't implement this, so this test is ensuring that using \"c::foobar\"\n+    // is *not* getting b::foobar. Today it's an error, but perhaps one day it\n+    // can correctly get a::foobar instead.\n+    pub use a::foobar;\n+    use b::foobar;\n+}\n+\n+fn main() {\n+    assert_eq!(c::foobar(), 1);\n+    //~^ ERROR: unresolved name `c::foobar`\n+}\n+"}, {"sha": "50e55ad295ecbd48ccf59edf99e460b39ba16238", "filename": "src/test/compile-fail/trait-bounds-not-on-bare-trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -13,7 +13,8 @@ trait Foo {\n \n // This should emit the less confusing error, not the more confusing one.\n \n-fn foo(_x: Foo:Send) { //~ERROR reference to trait `Foo` where a type is expected\n+fn foo(_x: Foo:Send) {\n+    //~^ERROR reference to trait `Foo` where a type is expected; try `~Foo` or `&Foo`\n }\n \n fn main() { }"}, {"sha": "e64f76bb4cd779418d8bdda9d79c5b61f1e2efb0", "filename": "src/test/compile-fail/trait-impl-method-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -17,7 +17,7 @@ trait Mumbo {\n impl Mumbo for uint {\n     // Cannot have a larger effect than the trait:\n     unsafe fn jumbo(&self, x: @uint) { *self + *x; }\n-    //~^ ERROR expected impure fn but found unsafe fn\n+    //~^ ERROR expected normal fn but found unsafe fn\n }\n \n fn main() {}"}, {"sha": "e60643eb3f402539627b0f42818a44f93c270fa8", "filename": "src/test/debug-info/issue13213.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fdebug-info%2Fissue13213.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Fdebug-info%2Fissue13213.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fissue13213.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android: FIXME(#10381)\n+\n+// aux-build:issue13213aux.rs\n+extern crate issue13213aux;\n+\n+// compile-flags:-g\n+\n+// This tests make sure that we get no linker error when using a completely inlined static. Some\n+// statics that are marked with AvailableExternallyLinkage in the importing crate, may actually not\n+// be available because they have been optimized out from the exporting crate.\n+fn main() {\n+    let b: issue13213aux::S = issue13213aux::A;\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "1c1242ada8a6d901d775db0b943f26204978f622", "filename": "src/test/run-make/pretty-print-to-file/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-make%2Fpretty-print-to-file%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-make%2Fpretty-print-to-file%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-to-file%2FMakefile?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) -o $(TMPDIR)/input.out --pretty=normal input.rs\n+\tdiff -u $(TMPDIR)/input.out input.pp"}, {"sha": "a6dd6b6778ed0c70451d62ce0605a6e8be8060fa", "filename": "src/test/run-make/pretty-print-to-file/input.pp", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-make%2Fpretty-print-to-file%2Finput.pp", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-make%2Fpretty-print-to-file%2Finput.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-to-file%2Finput.pp?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#[crate_type = \"lib\"]\n+pub fn foo() -> i32 { 45 }"}, {"sha": "8e3ec36318749eb9f4b9b6f574d0540ea9fa5f10", "filename": "src/test/run-make/pretty-print-to-file/input.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-make%2Fpretty-print-to-file%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-make%2Fpretty-print-to-file%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-to-file%2Finput.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_type=\"lib\"]\n+\n+pub fn\n+foo() -> i32\n+{ 45 }"}, {"sha": "7e51c6ad2aebbe2cd1679392047a5a13c884816d", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate ser = \"serialize\";\n+extern crate serialize;\n \n-use serialize = self::ser;\n- //necessary for deriving(Encodable)\n-use ser::{Encodable, Encoder};\n-use ser::json;\n-use ser::ebml::writer;\n+use serialize::{Encodable, Encoder};\n+use serialize::json;\n+use serialize::ebml::writer;\n use std::io::MemWriter;\n use std::str::from_utf8_owned;\n "}, {"sha": "fcb658036b6b1e0ac6ac2e275ba90616f6249ffa", "filename": "src/test/run-pass/issue-12612.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-pass%2Fissue-12612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-pass%2Fissue-12612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12612.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-12612-1.rs\n+// aux-build:issue-12612-2.rs\n+\n+extern crate foo = \"issue-12612-1\";\n+extern crate bar = \"issue-12612-2\";\n+\n+use foo::bar;\n+\n+mod test {\n+    use bar::baz;\n+}\n+\n+fn main() {}"}, {"sha": "baf37e314173d56293c217cf73776e8306cea7c7", "filename": "src/test/run-pass/issue-7663.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-pass%2Fissue-7663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5/src%2Ftest%2Frun-pass%2Fissue-7663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7663.rs?ref=0156af156d70efd5a3c96d0c5b8fc9bec39a7ae5", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(globs)]\n+#![allow(unused_imports, dead_code)]\n+\n+mod test1 {\n+\n+    mod foo { pub fn p() -> int { 1 } }\n+    mod bar { pub fn p() -> int { 2 } }\n+\n+    pub mod baz {\n+        use test1::foo::*;\n+        use test1::bar::*;\n+\n+        pub fn my_main() { assert!(p() == 2); }\n+    }\n+}\n+\n+mod test2 {\n+\n+    mod foo { pub fn p() -> int { 1 } }\n+    mod bar { pub fn p() -> int { 2 } }\n+\n+    pub mod baz {\n+        use test2::foo::p;\n+        use test2::bar::p;\n+\n+        pub fn my_main() { assert!(p() == 2); }\n+    }\n+}\n+\n+mod test3 {\n+\n+    mod foo { pub fn p() -> int { 1 } }\n+    mod bar { pub fn p() -> int { 2 } }\n+\n+    pub mod baz {\n+        use test3::foo::*;\n+        use test3::bar::p;\n+\n+        pub fn my_main() { assert!(p() == 2); }\n+    }\n+}\n+\n+fn main() {\n+    test1::baz::my_main();\n+    test2::baz::my_main();\n+    test3::baz::my_main();\n+}"}]}